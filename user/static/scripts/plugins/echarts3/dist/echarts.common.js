(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["echarts"] = factory();
	else
		root["echarts"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 288);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/* unknown exports provided */
/* all exports used */
/*!*******************************************!*\
  !*** /home/yx/~/zrender/lib/core/util.js ***!
  \*******************************************/
/***/ (function(module, exports) {

eval("/**\n * @module zrender/core/util\n */\n\n\n    // 用于处理merge时无法遍历Date等对象的问题\n    var BUILTIN_OBJECT = {\n        '[object Function]': 1,\n        '[object RegExp]': 1,\n        '[object Date]': 1,\n        '[object Error]': 1,\n        '[object CanvasGradient]': 1,\n        '[object CanvasPattern]': 1,\n        // For node-canvas\n        '[object Image]': 1,\n        '[object Canvas]': 1\n    };\n\n    var TYPED_ARRAY = {\n        '[object Int8Array]': 1,\n        '[object Uint8Array]': 1,\n        '[object Uint8ClampedArray]': 1,\n        '[object Int16Array]': 1,\n        '[object Uint16Array]': 1,\n        '[object Int32Array]': 1,\n        '[object Uint32Array]': 1,\n        '[object Float32Array]': 1,\n        '[object Float64Array]': 1\n    };\n\n    var objToString = Object.prototype.toString;\n\n    var arrayProto = Array.prototype;\n    var nativeForEach = arrayProto.forEach;\n    var nativeFilter = arrayProto.filter;\n    var nativeSlice = arrayProto.slice;\n    var nativeMap = arrayProto.map;\n    var nativeReduce = arrayProto.reduce;\n\n    /**\n     * Those data types can be cloned:\n     *     Plain object, Array, TypedArray, number, string, null, undefined.\n     * Those data types will be assgined using the orginal data:\n     *     BUILTIN_OBJECT\n     * Instance of user defined class will be cloned to a plain object, without\n     * properties in prototype.\n     * Other data types is not supported (not sure what will happen).\n     *\n     * Caution: do not support clone Date, for performance consideration.\n     * (There might be a large number of date in `series.data`).\n     * So date should not be modified in and out of echarts.\n     *\n     * @param {*} source\n     * @return {*} new\n     */\n    function clone(source) {\n        if (source == null || typeof source != 'object') {\n            return source;\n        }\n\n        var result = source;\n        var typeStr = objToString.call(source);\n\n        if (typeStr === '[object Array]') {\n            result = [];\n            for (var i = 0, len = source.length; i < len; i++) {\n                result[i] = clone(source[i]);\n            }\n        }\n        else if (TYPED_ARRAY[typeStr]) {\n            result = source.constructor.from(source);\n        }\n        else if (!BUILTIN_OBJECT[typeStr] && !isPrimitive(source) && !isDom(source)) {\n            result = {};\n            for (var key in source) {\n                if (source.hasOwnProperty(key)) {\n                    result[key] = clone(source[key]);\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} target\n     * @param {*} source\n     * @param {boolean} [overwrite=false]\n     */\n    function merge(target, source, overwrite) {\n        // We should escapse that source is string\n        // and enter for ... in ...\n        if (!isObject(source) || !isObject(target)) {\n            return overwrite ? clone(source) : target;\n        }\n\n        for (var key in source) {\n            if (source.hasOwnProperty(key)) {\n                var targetProp = target[key];\n                var sourceProp = source[key];\n\n                if (isObject(sourceProp)\n                    && isObject(targetProp)\n                    && !isArray(sourceProp)\n                    && !isArray(targetProp)\n                    && !isDom(sourceProp)\n                    && !isDom(targetProp)\n                    && !isBuiltInObject(sourceProp)\n                    && !isBuiltInObject(targetProp)\n                    && !isPrimitive(sourceProp)\n                    && !isPrimitive(targetProp)\n                ) {\n                    // 如果需要递归覆盖，就递归调用merge\n                    merge(targetProp, sourceProp, overwrite);\n                }\n                else if (overwrite || !(key in target)) {\n                    // 否则只处理overwrite为true，或者在目标对象中没有此属性的情况\n                    // NOTE，在 target[key] 不存在的时候也是直接覆盖\n                    target[key] = clone(source[key], true);\n                }\n            }\n        }\n\n        return target;\n    }\n\n    /**\n     * @param {Array} targetAndSources The first item is target, and the rests are source.\n     * @param {boolean} [overwrite=false]\n     * @return {*} target\n     */\n    function mergeAll(targetAndSources, overwrite) {\n        var result = targetAndSources[0];\n        for (var i = 1, len = targetAndSources.length; i < len; i++) {\n            result = merge(result, targetAndSources[i], overwrite);\n        }\n        return result;\n    }\n\n    /**\n     * @param {*} target\n     * @param {*} source\n     * @memberOf module:zrender/core/util\n     */\n    function extend(target, source) {\n        for (var key in source) {\n            if (source.hasOwnProperty(key)) {\n                target[key] = source[key];\n            }\n        }\n        return target;\n    }\n\n    /**\n     * @param {*} target\n     * @param {*} source\n     * @param {boolen} [overlay=false]\n     * @memberOf module:zrender/core/util\n     */\n    function defaults(target, source, overlay) {\n        for (var key in source) {\n            if (source.hasOwnProperty(key)\n                && (overlay ? source[key] != null : target[key] == null)\n            ) {\n                target[key] = source[key];\n            }\n        }\n        return target;\n    }\n\n    function createCanvas() {\n        return document.createElement('canvas');\n    }\n    // FIXME\n    var _ctx;\n    function getContext() {\n        if (!_ctx) {\n            // Use util.createCanvas instead of createCanvas\n            // because createCanvas may be overwritten in different environment\n            _ctx = util.createCanvas().getContext('2d');\n        }\n        return _ctx;\n    }\n\n    /**\n     * 查询数组中元素的index\n     * @memberOf module:zrender/core/util\n     */\n    function indexOf(array, value) {\n        if (array) {\n            if (array.indexOf) {\n                return array.indexOf(value);\n            }\n            for (var i = 0, len = array.length; i < len; i++) {\n                if (array[i] === value) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * 构造类继承关系\n     *\n     * @memberOf module:zrender/core/util\n     * @param {Function} clazz 源类\n     * @param {Function} baseClazz 基类\n     */\n    function inherits(clazz, baseClazz) {\n        var clazzPrototype = clazz.prototype;\n        function F() {}\n        F.prototype = baseClazz.prototype;\n        clazz.prototype = new F();\n\n        for (var prop in clazzPrototype) {\n            clazz.prototype[prop] = clazzPrototype[prop];\n        }\n        clazz.prototype.constructor = clazz;\n        clazz.superClass = baseClazz;\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Object|Function} target\n     * @param {Object|Function} sorce\n     * @param {boolean} overlay\n     */\n    function mixin(target, source, overlay) {\n        target = 'prototype' in target ? target.prototype : target;\n        source = 'prototype' in source ? source.prototype : source;\n\n        defaults(target, source, overlay);\n    }\n\n    /**\n     * Consider typed array.\n     * @param {Array|TypedArray} data\n     */\n    function isArrayLike(data) {\n        if (! data) {\n            return;\n        }\n        if (typeof data == 'string') {\n            return false;\n        }\n        return typeof data.length == 'number';\n    }\n\n    /**\n     * 数组或对象遍历\n     * @memberOf module:zrender/core/util\n     * @param {Object|Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     */\n    function each(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.forEach && obj.forEach === nativeForEach) {\n            obj.forEach(cb, context);\n        }\n        else if (obj.length === +obj.length) {\n            for (var i = 0, len = obj.length; i < len; i++) {\n                cb.call(context, obj[i], i, obj);\n            }\n        }\n        else {\n            for (var key in obj) {\n                if (obj.hasOwnProperty(key)) {\n                    cb.call(context, obj[key], key, obj);\n                }\n            }\n        }\n    }\n\n    /**\n     * 数组映射\n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function map(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.map && obj.map === nativeMap) {\n            return obj.map(cb, context);\n        }\n        else {\n            var result = [];\n            for (var i = 0, len = obj.length; i < len; i++) {\n                result.push(cb.call(context, obj[i], i, obj));\n            }\n            return result;\n        }\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {Object} [memo]\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function reduce(obj, cb, memo, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.reduce && obj.reduce === nativeReduce) {\n            return obj.reduce(cb, memo, context);\n        }\n        else {\n            for (var i = 0, len = obj.length; i < len; i++) {\n                memo = cb.call(context, memo, obj[i], i, obj);\n            }\n            return memo;\n        }\n    }\n\n    /**\n     * 数组过滤\n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function filter(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.filter && obj.filter === nativeFilter) {\n            return obj.filter(cb, context);\n        }\n        else {\n            var result = [];\n            for (var i = 0, len = obj.length; i < len; i++) {\n                if (cb.call(context, obj[i], i, obj)) {\n                    result.push(obj[i]);\n                }\n            }\n            return result;\n        }\n    }\n\n    /**\n     * 数组项查找\n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function find(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        for (var i = 0, len = obj.length; i < len; i++) {\n            if (cb.call(context, obj[i], i, obj)) {\n                return obj[i];\n            }\n        }\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Function} func\n     * @param {*} context\n     * @return {Function}\n     */\n    function bind(func, context) {\n        var args = nativeSlice.call(arguments, 2);\n        return function () {\n            return func.apply(context, args.concat(nativeSlice.call(arguments)));\n        };\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Function} func\n     * @return {Function}\n     */\n    function curry(func) {\n        var args = nativeSlice.call(arguments, 1);\n        return function () {\n            return func.apply(this, args.concat(nativeSlice.call(arguments)));\n        };\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isArray(value) {\n        return objToString.call(value) === '[object Array]';\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isFunction(value) {\n        return typeof value === 'function';\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isString(value) {\n        return objToString.call(value) === '[object String]';\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isObject(value) {\n        // Avoid a V8 JIT bug in Chrome 19-20.\n        // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n        var type = typeof value;\n        return type === 'function' || (!!value && type == 'object');\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isBuiltInObject(value) {\n        return !!BUILTIN_OBJECT[objToString.call(value)];\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isDom(value) {\n        return typeof value === 'object'\n            && typeof value.nodeType === 'number'\n            && typeof value.ownerDocument === 'object';\n    }\n\n    /**\n     * Whether is exactly NaN. Notice isNaN('a') returns true.\n     * @param {*} value\n     * @return {boolean}\n     */\n    function eqNaN(value) {\n        return value !== value;\n    }\n\n    /**\n     * If value1 is not null, then return value1, otherwise judget rest of values.\n     * @memberOf module:zrender/core/util\n     * @return {*} Final value\n     */\n    function retrieve(values) {\n        for (var i = 0, len = arguments.length; i < len; i++) {\n            if (arguments[i] != null) {\n                return arguments[i];\n            }\n        }\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Array} arr\n     * @param {number} startIndex\n     * @param {number} endIndex\n     * @return {Array}\n     */\n    function slice() {\n        return Function.call.apply(nativeSlice, arguments);\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {boolean} condition\n     * @param {string} message\n     */\n    function assert(condition, message) {\n        if (!condition) {\n            throw new Error(message);\n        }\n    }\n\n    var primitiveKey = '__ec_primitive__';\n    /**\n     * Set an object as primitive to be ignored traversing children in clone or merge\n     */\n    function setAsPrimitive(obj) {\n        obj[primitiveKey] = true;\n    }\n\n    function isPrimitive(obj) {\n        return obj[primitiveKey];\n    }\n\n    /**\n     * @constructor\n     */\n    function HashMap(obj) {\n        obj && extend(this, obj);\n    }\n\n    // Add prefix to avoid conflict with Object.prototype.\n    var HASH_MAP_PREFIX = '_ec_';\n    var HASH_MAP_PREFIX_LENGTH = 4;\n\n    HashMap.prototype = {\n        constructor: HashMap,\n        // Do not provide `has` method to avoid defining what is `has`.\n        // (We usually treat `null` and `undefined` as the same, different\n        // from ES6 Map).\n        get: function (key) {\n            return this[HASH_MAP_PREFIX + key];\n        },\n        set: function (key, value) {\n            this[HASH_MAP_PREFIX + key] = value;\n            // Comparing with invocation chaining, `return value` is more commonly\n            // used in this case: `var someVal = map.set('a', genVal());`\n            return value;\n        },\n        // Although util.each can be performed on this hashMap directly, user\n        // should not use the exposed keys, who are prefixed.\n        each: function (cb, context) {\n            context !== void 0 && (cb = bind(cb, context));\n            for (var prefixedKey in this) {\n                this.hasOwnProperty(prefixedKey)\n                    && cb(this[prefixedKey], prefixedKey.slice(HASH_MAP_PREFIX_LENGTH));\n            }\n        },\n        // Do not use this method if performance sensitive.\n        removeKey: function (key) {\n            delete this[key];\n        }\n    };\n\n    function createHashMap() {\n        return new HashMap();\n    }\n\n    var util = {\n        inherits: inherits,\n        mixin: mixin,\n        clone: clone,\n        merge: merge,\n        mergeAll: mergeAll,\n        extend: extend,\n        defaults: defaults,\n        getContext: getContext,\n        createCanvas: createCanvas,\n        indexOf: indexOf,\n        slice: slice,\n        find: find,\n        isArrayLike: isArrayLike,\n        each: each,\n        map: map,\n        reduce: reduce,\n        filter: filter,\n        bind: bind,\n        curry: curry,\n        isArray: isArray,\n        isString: isString,\n        isObject: isObject,\n        isFunction: isFunction,\n        isBuiltInObject: isBuiltInObject,\n        isDom: isDom,\n        eqNaN: eqNaN,\n        retrieve: retrieve,\n        assert: assert,\n        setAsPrimitive: setAsPrimitive,\n        createHashMap: createHashMap,\n        noop: function () {}\n    };\n    module.exports = util;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vaG9tZS95eC9+L3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcz85MmMwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQG1vZHVsZSB6cmVuZGVyL2NvcmUvdXRpbFxuICovXG5cblxuICAgIC8vIOeUqOS6juWkhOeQhm1lcmdl5pe25peg5rOV6YGN5Y6GRGF0ZeetieWvueixoeeahOmXrumimFxuICAgIHZhciBCVUlMVElOX09CSkVDVCA9IHtcbiAgICAgICAgJ1tvYmplY3QgRnVuY3Rpb25dJzogMSxcbiAgICAgICAgJ1tvYmplY3QgUmVnRXhwXSc6IDEsXG4gICAgICAgICdbb2JqZWN0IERhdGVdJzogMSxcbiAgICAgICAgJ1tvYmplY3QgRXJyb3JdJzogMSxcbiAgICAgICAgJ1tvYmplY3QgQ2FudmFzR3JhZGllbnRdJzogMSxcbiAgICAgICAgJ1tvYmplY3QgQ2FudmFzUGF0dGVybl0nOiAxLFxuICAgICAgICAvLyBGb3Igbm9kZS1jYW52YXNcbiAgICAgICAgJ1tvYmplY3QgSW1hZ2VdJzogMSxcbiAgICAgICAgJ1tvYmplY3QgQ2FudmFzXSc6IDFcbiAgICB9O1xuXG4gICAgdmFyIFRZUEVEX0FSUkFZID0ge1xuICAgICAgICAnW29iamVjdCBJbnQ4QXJyYXldJzogMSxcbiAgICAgICAgJ1tvYmplY3QgVWludDhBcnJheV0nOiAxLFxuICAgICAgICAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nOiAxLFxuICAgICAgICAnW29iamVjdCBJbnQxNkFycmF5XSc6IDEsXG4gICAgICAgICdbb2JqZWN0IFVpbnQxNkFycmF5XSc6IDEsXG4gICAgICAgICdbb2JqZWN0IEludDMyQXJyYXldJzogMSxcbiAgICAgICAgJ1tvYmplY3QgVWludDMyQXJyYXldJzogMSxcbiAgICAgICAgJ1tvYmplY3QgRmxvYXQzMkFycmF5XSc6IDEsXG4gICAgICAgICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nOiAxXG4gICAgfTtcblxuICAgIHZhciBvYmpUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbiAgICB2YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcbiAgICB2YXIgbmF0aXZlRm9yRWFjaCA9IGFycmF5UHJvdG8uZm9yRWFjaDtcbiAgICB2YXIgbmF0aXZlRmlsdGVyID0gYXJyYXlQcm90by5maWx0ZXI7XG4gICAgdmFyIG5hdGl2ZVNsaWNlID0gYXJyYXlQcm90by5zbGljZTtcbiAgICB2YXIgbmF0aXZlTWFwID0gYXJyYXlQcm90by5tYXA7XG4gICAgdmFyIG5hdGl2ZVJlZHVjZSA9IGFycmF5UHJvdG8ucmVkdWNlO1xuXG4gICAgLyoqXG4gICAgICogVGhvc2UgZGF0YSB0eXBlcyBjYW4gYmUgY2xvbmVkOlxuICAgICAqICAgICBQbGFpbiBvYmplY3QsIEFycmF5LCBUeXBlZEFycmF5LCBudW1iZXIsIHN0cmluZywgbnVsbCwgdW5kZWZpbmVkLlxuICAgICAqIFRob3NlIGRhdGEgdHlwZXMgd2lsbCBiZSBhc3NnaW5lZCB1c2luZyB0aGUgb3JnaW5hbCBkYXRhOlxuICAgICAqICAgICBCVUlMVElOX09CSkVDVFxuICAgICAqIEluc3RhbmNlIG9mIHVzZXIgZGVmaW5lZCBjbGFzcyB3aWxsIGJlIGNsb25lZCB0byBhIHBsYWluIG9iamVjdCwgd2l0aG91dFxuICAgICAqIHByb3BlcnRpZXMgaW4gcHJvdG90eXBlLlxuICAgICAqIE90aGVyIGRhdGEgdHlwZXMgaXMgbm90IHN1cHBvcnRlZCAobm90IHN1cmUgd2hhdCB3aWxsIGhhcHBlbikuXG4gICAgICpcbiAgICAgKiBDYXV0aW9uOiBkbyBub3Qgc3VwcG9ydCBjbG9uZSBEYXRlLCBmb3IgcGVyZm9ybWFuY2UgY29uc2lkZXJhdGlvbi5cbiAgICAgKiAoVGhlcmUgbWlnaHQgYmUgYSBsYXJnZSBudW1iZXIgb2YgZGF0ZSBpbiBgc2VyaWVzLmRhdGFgKS5cbiAgICAgKiBTbyBkYXRlIHNob3VsZCBub3QgYmUgbW9kaWZpZWQgaW4gYW5kIG91dCBvZiBlY2hhcnRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSBzb3VyY2VcbiAgICAgKiBAcmV0dXJuIHsqfSBuZXdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZShzb3VyY2UpIHtcbiAgICAgICAgaWYgKHNvdXJjZSA9PSBudWxsIHx8IHR5cGVvZiBzb3VyY2UgIT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzdWx0ID0gc291cmNlO1xuICAgICAgICB2YXIgdHlwZVN0ciA9IG9ialRvU3RyaW5nLmNhbGwoc291cmNlKTtcblxuICAgICAgICBpZiAodHlwZVN0ciA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgICAgICAgcmVzdWx0ID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc291cmNlLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2ldID0gY2xvbmUoc291cmNlW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChUWVBFRF9BUlJBWVt0eXBlU3RyXSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gc291cmNlLmNvbnN0cnVjdG9yLmZyb20oc291cmNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghQlVJTFRJTl9PQkpFQ1RbdHlwZVN0cl0gJiYgIWlzUHJpbWl0aXZlKHNvdXJjZSkgJiYgIWlzRG9tKHNvdXJjZSkpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHt9O1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgICAgICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IGNsb25lKHNvdXJjZVtrZXldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAgICAgKiBAcGFyYW0geyp9IHRhcmdldFxuICAgICAqIEBwYXJhbSB7Kn0gc291cmNlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3ZlcndyaXRlPWZhbHNlXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1lcmdlKHRhcmdldCwgc291cmNlLCBvdmVyd3JpdGUpIHtcbiAgICAgICAgLy8gV2Ugc2hvdWxkIGVzY2Fwc2UgdGhhdCBzb3VyY2UgaXMgc3RyaW5nXG4gICAgICAgIC8vIGFuZCBlbnRlciBmb3IgLi4uIGluIC4uLlxuICAgICAgICBpZiAoIWlzT2JqZWN0KHNvdXJjZSkgfHwgIWlzT2JqZWN0KHRhcmdldCkpIHtcbiAgICAgICAgICAgIHJldHVybiBvdmVyd3JpdGUgPyBjbG9uZShzb3VyY2UpIDogdGFyZ2V0O1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldFByb3AgPSB0YXJnZXRba2V5XTtcbiAgICAgICAgICAgICAgICB2YXIgc291cmNlUHJvcCA9IHNvdXJjZVtrZXldO1xuXG4gICAgICAgICAgICAgICAgaWYgKGlzT2JqZWN0KHNvdXJjZVByb3ApXG4gICAgICAgICAgICAgICAgICAgICYmIGlzT2JqZWN0KHRhcmdldFByb3ApXG4gICAgICAgICAgICAgICAgICAgICYmICFpc0FycmF5KHNvdXJjZVByb3ApXG4gICAgICAgICAgICAgICAgICAgICYmICFpc0FycmF5KHRhcmdldFByb3ApXG4gICAgICAgICAgICAgICAgICAgICYmICFpc0RvbShzb3VyY2VQcm9wKVxuICAgICAgICAgICAgICAgICAgICAmJiAhaXNEb20odGFyZ2V0UHJvcClcbiAgICAgICAgICAgICAgICAgICAgJiYgIWlzQnVpbHRJbk9iamVjdChzb3VyY2VQcm9wKVxuICAgICAgICAgICAgICAgICAgICAmJiAhaXNCdWlsdEluT2JqZWN0KHRhcmdldFByb3ApXG4gICAgICAgICAgICAgICAgICAgICYmICFpc1ByaW1pdGl2ZShzb3VyY2VQcm9wKVxuICAgICAgICAgICAgICAgICAgICAmJiAhaXNQcmltaXRpdmUodGFyZ2V0UHJvcClcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8g5aaC5p6c6ZyA6KaB6YCS5b2S6KaG55uW77yM5bCx6YCS5b2S6LCD55SobWVyZ2VcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2UodGFyZ2V0UHJvcCwgc291cmNlUHJvcCwgb3ZlcndyaXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob3ZlcndyaXRlIHx8ICEoa2V5IGluIHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8g5ZCm5YiZ5Y+q5aSE55CGb3ZlcndyaXRl5Li6dHJ1Ze+8jOaIluiAheWcqOebruagh+WvueixoeS4reayoeacieatpOWxnuaAp+eahOaDheWGtVxuICAgICAgICAgICAgICAgICAgICAvLyBOT1RF77yM5ZyoIHRhcmdldFtrZXldIOS4jeWtmOWcqOeahOaXtuWAmeS5n+aYr+ebtOaOpeimhuebllxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IGNsb25lKHNvdXJjZVtrZXldLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHRhcmdldEFuZFNvdXJjZXMgVGhlIGZpcnN0IGl0ZW0gaXMgdGFyZ2V0LCBhbmQgdGhlIHJlc3RzIGFyZSBzb3VyY2UuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3ZlcndyaXRlPWZhbHNlXVxuICAgICAqIEByZXR1cm4geyp9IHRhcmdldFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1lcmdlQWxsKHRhcmdldEFuZFNvdXJjZXMsIG92ZXJ3cml0ZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGFyZ2V0QW5kU291cmNlc1swXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDEsIGxlbiA9IHRhcmdldEFuZFNvdXJjZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IG1lcmdlKHJlc3VsdCwgdGFyZ2V0QW5kU291cmNlc1tpXSwgb3ZlcndyaXRlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Kn0gdGFyZ2V0XG4gICAgICogQHBhcmFtIHsqfSBzb3VyY2VcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXh0ZW5kKHRhcmdldCwgc291cmNlKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyp9IHRhcmdldFxuICAgICAqIEBwYXJhbSB7Kn0gc291cmNlXG4gICAgICogQHBhcmFtIHtib29sZW59IFtvdmVybGF5PWZhbHNlXVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWZhdWx0cyh0YXJnZXQsIHNvdXJjZSwgb3ZlcmxheSkge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KGtleSlcbiAgICAgICAgICAgICAgICAmJiAob3ZlcmxheSA/IHNvdXJjZVtrZXldICE9IG51bGwgOiB0YXJnZXRba2V5XSA9PSBudWxsKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUNhbnZhcygpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIH1cbiAgICAvLyBGSVhNRVxuICAgIHZhciBfY3R4O1xuICAgIGZ1bmN0aW9uIGdldENvbnRleHQoKSB7XG4gICAgICAgIGlmICghX2N0eCkge1xuICAgICAgICAgICAgLy8gVXNlIHV0aWwuY3JlYXRlQ2FudmFzIGluc3RlYWQgb2YgY3JlYXRlQ2FudmFzXG4gICAgICAgICAgICAvLyBiZWNhdXNlIGNyZWF0ZUNhbnZhcyBtYXkgYmUgb3ZlcndyaXR0ZW4gaW4gZGlmZmVyZW50IGVudmlyb25tZW50XG4gICAgICAgICAgICBfY3R4ID0gdXRpbC5jcmVhdGVDYW52YXMoKS5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfY3R4O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOafpeivouaVsOe7hOS4reWFg+e0oOeahGluZGV4XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluZGV4T2YoYXJyYXksIHZhbHVlKSB7XG4gICAgICAgIGlmIChhcnJheSkge1xuICAgICAgICAgICAgaWYgKGFycmF5LmluZGV4T2YpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXkuaW5kZXhPZih2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoYXJyYXlbaV0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5p6E6YCg57G757un5om/5YWz57O7XG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2xhenog5rqQ57G7XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gYmFzZUNsYXp6IOWfuuexu1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluaGVyaXRzKGNsYXp6LCBiYXNlQ2xhenopIHtcbiAgICAgICAgdmFyIGNsYXp6UHJvdG90eXBlID0gY2xhenoucHJvdG90eXBlO1xuICAgICAgICBmdW5jdGlvbiBGKCkge31cbiAgICAgICAgRi5wcm90b3R5cGUgPSBiYXNlQ2xhenoucHJvdG90eXBlO1xuICAgICAgICBjbGF6ei5wcm90b3R5cGUgPSBuZXcgRigpO1xuXG4gICAgICAgIGZvciAodmFyIHByb3AgaW4gY2xhenpQcm90b3R5cGUpIHtcbiAgICAgICAgICAgIGNsYXp6LnByb3RvdHlwZVtwcm9wXSA9IGNsYXp6UHJvdG90eXBlW3Byb3BdO1xuICAgICAgICB9XG4gICAgICAgIGNsYXp6LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGNsYXp6O1xuICAgICAgICBjbGF6ei5zdXBlckNsYXNzID0gYmFzZUNsYXp6O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAgICAgKiBAcGFyYW0ge09iamVjdHxGdW5jdGlvbn0gdGFyZ2V0XG4gICAgICogQHBhcmFtIHtPYmplY3R8RnVuY3Rpb259IHNvcmNlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBvdmVybGF5XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWl4aW4odGFyZ2V0LCBzb3VyY2UsIG92ZXJsYXkpIHtcbiAgICAgICAgdGFyZ2V0ID0gJ3Byb3RvdHlwZScgaW4gdGFyZ2V0ID8gdGFyZ2V0LnByb3RvdHlwZSA6IHRhcmdldDtcbiAgICAgICAgc291cmNlID0gJ3Byb3RvdHlwZScgaW4gc291cmNlID8gc291cmNlLnByb3RvdHlwZSA6IHNvdXJjZTtcblxuICAgICAgICBkZWZhdWx0cyh0YXJnZXQsIHNvdXJjZSwgb3ZlcmxheSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29uc2lkZXIgdHlwZWQgYXJyYXkuXG4gICAgICogQHBhcmFtIHtBcnJheXxUeXBlZEFycmF5fSBkYXRhXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNBcnJheUxpa2UoZGF0YSkge1xuICAgICAgICBpZiAoISBkYXRhKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHR5cGVvZiBkYXRhLmxlbmd0aCA9PSAnbnVtYmVyJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDmlbDnu4TmiJblr7nosaHpgY3ljoZcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gICAgICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IG9ialxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gICAgICogQHBhcmFtIHsqfSBbY29udGV4dF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlYWNoKG9iaiwgY2IsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKCEob2JqICYmIGNiKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmouZm9yRWFjaCAmJiBvYmouZm9yRWFjaCA9PT0gbmF0aXZlRm9yRWFjaCkge1xuICAgICAgICAgICAgb2JqLmZvckVhY2goY2IsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9iai5sZW5ndGggPT09ICtvYmoubGVuZ3RoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gb2JqLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY2IuY2FsbChjb250ZXh0LCBvYmpbaV0sIGksIG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNiLmNhbGwoY29udGV4dCwgb2JqW2tleV0sIGtleSwgb2JqKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDmlbDnu4TmmKDlsIRcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gICAgICogQHBhcmFtIHtBcnJheX0gb2JqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAgICAgKiBAcGFyYW0geyp9IFtjb250ZXh0XVxuICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcChvYmosIGNiLCBjb250ZXh0KSB7XG4gICAgICAgIGlmICghKG9iaiAmJiBjYikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqLm1hcCAmJiBvYmoubWFwID09PSBuYXRpdmVNYXApIHtcbiAgICAgICAgICAgIHJldHVybiBvYmoubWFwKGNiLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBvYmoubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjYi5jYWxsKGNvbnRleHQsIG9ialtpXSwgaSwgb2JqKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG9ialxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFttZW1vXVxuICAgICAqIEBwYXJhbSB7Kn0gW2NvbnRleHRdXG4gICAgICogQHJldHVybiB7QXJyYXl9XG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVkdWNlKG9iaiwgY2IsIG1lbW8sIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKCEob2JqICYmIGNiKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmoucmVkdWNlICYmIG9iai5yZWR1Y2UgPT09IG5hdGl2ZVJlZHVjZSkge1xuICAgICAgICAgICAgcmV0dXJuIG9iai5yZWR1Y2UoY2IsIG1lbW8sIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG9iai5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIG1lbW8gPSBjYi5jYWxsKGNvbnRleHQsIG1lbW8sIG9ialtpXSwgaSwgb2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZW1vO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5pWw57uE6L+H5rukXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG9ialxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gICAgICogQHBhcmFtIHsqfSBbY29udGV4dF1cbiAgICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaWx0ZXIob2JqLCBjYiwgY29udGV4dCkge1xuICAgICAgICBpZiAoIShvYmogJiYgY2IpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iai5maWx0ZXIgJiYgb2JqLmZpbHRlciA9PT0gbmF0aXZlRmlsdGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqLmZpbHRlcihjYiwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gb2JqLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNiLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG9ialtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOaVsOe7hOmhueafpeaJvlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBvYmpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICAgICAqIEBwYXJhbSB7Kn0gW2NvbnRleHRdXG4gICAgICogQHJldHVybiB7QXJyYXl9XG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZChvYmosIGNiLCBjb250ZXh0KSB7XG4gICAgICAgIGlmICghKG9iaiAmJiBjYikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gb2JqLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoY2IuY2FsbChjb250ZXh0LCBvYmpbaV0sIGksIG9iaikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmNcbiAgICAgKiBAcGFyYW0geyp9IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiaW5kKGZ1bmMsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBuYXRpdmVTbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzLmNvbmNhdChuYXRpdmVTbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuY1xuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGN1cnJ5KGZ1bmMpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBuYXRpdmVTbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmdzLmNvbmNhdChuYXRpdmVTbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNBcnJheSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBTdHJpbmddJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgICAgICAgLy8gQXZvaWQgYSBWOCBKSVQgYnVnIGluIENocm9tZSAxOS0yMC5cbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0yMjkxIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgICAgICByZXR1cm4gdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCAoISF2YWx1ZSAmJiB0eXBlID09ICdvYmplY3QnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNCdWlsdEluT2JqZWN0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAhIUJVSUxUSU5fT0JKRUNUW29ialRvU3RyaW5nLmNhbGwodmFsdWUpXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNEb20odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCdcbiAgICAgICAgICAgICYmIHR5cGVvZiB2YWx1ZS5ub2RlVHlwZSA9PT0gJ251bWJlcidcbiAgICAgICAgICAgICYmIHR5cGVvZiB2YWx1ZS5vd25lckRvY3VtZW50ID09PSAnb2JqZWN0JztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGlzIGV4YWN0bHkgTmFOLiBOb3RpY2UgaXNOYU4oJ2EnKSByZXR1cm5zIHRydWUuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gZXFOYU4odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJZiB2YWx1ZTEgaXMgbm90IG51bGwsIHRoZW4gcmV0dXJuIHZhbHVlMSwgb3RoZXJ3aXNlIGp1ZGdldCByZXN0IG9mIHZhbHVlcy5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gICAgICogQHJldHVybiB7Kn0gRmluYWwgdmFsdWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXRyaWV2ZSh2YWx1ZXMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50c1tpXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRJbmRleFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmRJbmRleFxuICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNsaWNlKCkge1xuICAgICAgICByZXR1cm4gRnVuY3Rpb24uY2FsbC5hcHBseShuYXRpdmVTbGljZSwgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gICAgICogQHBhcmFtIHtib29sZWFufSBjb25kaXRpb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFzc2VydChjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBwcmltaXRpdmVLZXkgPSAnX19lY19wcmltaXRpdmVfXyc7XG4gICAgLyoqXG4gICAgICogU2V0IGFuIG9iamVjdCBhcyBwcmltaXRpdmUgdG8gYmUgaWdub3JlZCB0cmF2ZXJzaW5nIGNoaWxkcmVuIGluIGNsb25lIG9yIG1lcmdlXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0QXNQcmltaXRpdmUob2JqKSB7XG4gICAgICAgIG9ialtwcmltaXRpdmVLZXldID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1ByaW1pdGl2ZShvYmopIHtcbiAgICAgICAgcmV0dXJuIG9ialtwcmltaXRpdmVLZXldO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEhhc2hNYXAob2JqKSB7XG4gICAgICAgIG9iaiAmJiBleHRlbmQodGhpcywgb2JqKTtcbiAgICB9XG5cbiAgICAvLyBBZGQgcHJlZml4IHRvIGF2b2lkIGNvbmZsaWN0IHdpdGggT2JqZWN0LnByb3RvdHlwZS5cbiAgICB2YXIgSEFTSF9NQVBfUFJFRklYID0gJ19lY18nO1xuICAgIHZhciBIQVNIX01BUF9QUkVGSVhfTEVOR1RIID0gNDtcblxuICAgIEhhc2hNYXAucHJvdG90eXBlID0ge1xuICAgICAgICBjb25zdHJ1Y3RvcjogSGFzaE1hcCxcbiAgICAgICAgLy8gRG8gbm90IHByb3ZpZGUgYGhhc2AgbWV0aG9kIHRvIGF2b2lkIGRlZmluaW5nIHdoYXQgaXMgYGhhc2AuXG4gICAgICAgIC8vIChXZSB1c3VhbGx5IHRyZWF0IGBudWxsYCBhbmQgYHVuZGVmaW5lZGAgYXMgdGhlIHNhbWUsIGRpZmZlcmVudFxuICAgICAgICAvLyBmcm9tIEVTNiBNYXApLlxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW0hBU0hfTUFQX1BSRUZJWCArIGtleV07XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXNbSEFTSF9NQVBfUFJFRklYICsga2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgLy8gQ29tcGFyaW5nIHdpdGggaW52b2NhdGlvbiBjaGFpbmluZywgYHJldHVybiB2YWx1ZWAgaXMgbW9yZSBjb21tb25seVxuICAgICAgICAgICAgLy8gdXNlZCBpbiB0aGlzIGNhc2U6IGB2YXIgc29tZVZhbCA9IG1hcC5zZXQoJ2EnLCBnZW5WYWwoKSk7YFxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICAvLyBBbHRob3VnaCB1dGlsLmVhY2ggY2FuIGJlIHBlcmZvcm1lZCBvbiB0aGlzIGhhc2hNYXAgZGlyZWN0bHksIHVzZXJcbiAgICAgICAgLy8gc2hvdWxkIG5vdCB1c2UgdGhlIGV4cG9zZWQga2V5cywgd2hvIGFyZSBwcmVmaXhlZC5cbiAgICAgICAgZWFjaDogZnVuY3Rpb24gKGNiLCBjb250ZXh0KSB7XG4gICAgICAgICAgICBjb250ZXh0ICE9PSB2b2lkIDAgJiYgKGNiID0gYmluZChjYiwgY29udGV4dCkpO1xuICAgICAgICAgICAgZm9yICh2YXIgcHJlZml4ZWRLZXkgaW4gdGhpcykge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFzT3duUHJvcGVydHkocHJlZml4ZWRLZXkpXG4gICAgICAgICAgICAgICAgICAgICYmIGNiKHRoaXNbcHJlZml4ZWRLZXldLCBwcmVmaXhlZEtleS5zbGljZShIQVNIX01BUF9QUkVGSVhfTEVOR1RIKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8vIERvIG5vdCB1c2UgdGhpcyBtZXRob2QgaWYgcGVyZm9ybWFuY2Ugc2Vuc2l0aXZlLlxuICAgICAgICByZW1vdmVLZXk6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzW2tleV07XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlSGFzaE1hcCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBIYXNoTWFwKCk7XG4gICAgfVxuXG4gICAgdmFyIHV0aWwgPSB7XG4gICAgICAgIGluaGVyaXRzOiBpbmhlcml0cyxcbiAgICAgICAgbWl4aW46IG1peGluLFxuICAgICAgICBjbG9uZTogY2xvbmUsXG4gICAgICAgIG1lcmdlOiBtZXJnZSxcbiAgICAgICAgbWVyZ2VBbGw6IG1lcmdlQWxsLFxuICAgICAgICBleHRlbmQ6IGV4dGVuZCxcbiAgICAgICAgZGVmYXVsdHM6IGRlZmF1bHRzLFxuICAgICAgICBnZXRDb250ZXh0OiBnZXRDb250ZXh0LFxuICAgICAgICBjcmVhdGVDYW52YXM6IGNyZWF0ZUNhbnZhcyxcbiAgICAgICAgaW5kZXhPZjogaW5kZXhPZixcbiAgICAgICAgc2xpY2U6IHNsaWNlLFxuICAgICAgICBmaW5kOiBmaW5kLFxuICAgICAgICBpc0FycmF5TGlrZTogaXNBcnJheUxpa2UsXG4gICAgICAgIGVhY2g6IGVhY2gsXG4gICAgICAgIG1hcDogbWFwLFxuICAgICAgICByZWR1Y2U6IHJlZHVjZSxcbiAgICAgICAgZmlsdGVyOiBmaWx0ZXIsXG4gICAgICAgIGJpbmQ6IGJpbmQsXG4gICAgICAgIGN1cnJ5OiBjdXJyeSxcbiAgICAgICAgaXNBcnJheTogaXNBcnJheSxcbiAgICAgICAgaXNTdHJpbmc6IGlzU3RyaW5nLFxuICAgICAgICBpc09iamVjdDogaXNPYmplY3QsXG4gICAgICAgIGlzRnVuY3Rpb246IGlzRnVuY3Rpb24sXG4gICAgICAgIGlzQnVpbHRJbk9iamVjdDogaXNCdWlsdEluT2JqZWN0LFxuICAgICAgICBpc0RvbTogaXNEb20sXG4gICAgICAgIGVxTmFOOiBlcU5hTixcbiAgICAgICAgcmV0cmlldmU6IHJldHJpZXZlLFxuICAgICAgICBhc3NlcnQ6IGFzc2VydCxcbiAgICAgICAgc2V0QXNQcmltaXRpdmU6IHNldEFzUHJpbWl0aXZlLFxuICAgICAgICBjcmVhdGVIYXNoTWFwOiBjcmVhdGVIYXNoTWFwLFxuICAgICAgICBub29wOiBmdW5jdGlvbiAoKSB7fVxuICAgIH07XG4gICAgbW9kdWxlLmV4cG9ydHMgPSB1dGlsO1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS95eC9+L3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qc1xuLy8gbW9kdWxlIGlkID0gMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 1 */
/* unknown exports provided */
/* all exports used */
/*!************************!*\
  !*** ./lib/echarts.js ***!
  \************************/
/***/ (function(module, exports, __webpack_require__) {

eval("// Enable DEV mode when using source code without build. which has no __DEV__ variable\n// In build process 'typeof __DEV__' will be replace with 'boolean'\n// So this code will be removed or disabled anyway after built.\nif (false) {\n    // In browser\n    if (typeof window !== 'undefined') {\n        window.__DEV__ = true;\n    }\n    // In node\n    else if (typeof global !== 'undefined') {\n        global.__DEV__ = true;\n    }\n}\n\n/*!\n * ECharts, a javascript interactive chart library.\n *\n * Copyright (c) 2015, Baidu Inc.\n * All rights reserved.\n *\n * LICENSE\n * https://github.com/ecomfe/echarts/blob/master/LICENSE.txt\n */\n\n/**\n * @module echarts\n */\n\n\n    var env = __webpack_require__(/*! zrender/lib/core/env */ 8);\n\n    var GlobalModel = __webpack_require__(/*! ./model/Global */ 167);\n    var ExtensionAPI = __webpack_require__(/*! ./ExtensionAPI */ 133);\n    var CoordinateSystemManager = __webpack_require__(/*! ./CoordinateSystem */ 26);\n    var OptionManager = __webpack_require__(/*! ./model/OptionManager */ 168);\n\n    var ComponentModel = __webpack_require__(/*! ./model/Component */ 12);\n    var SeriesModel = __webpack_require__(/*! ./model/Series */ 17);\n\n    var ComponentView = __webpack_require__(/*! ./view/Component */ 72);\n    var ChartView = __webpack_require__(/*! ./view/Chart */ 29);\n    var graphic = __webpack_require__(/*! ./util/graphic */ 2);\n    var modelUtil = __webpack_require__(/*! ./util/model */ 5);\n    var throttle = __webpack_require__(/*! ./util/throttle */ 38);\n\n    var zrender = __webpack_require__(/*! zrender */ 79);\n    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 0);\n    var colorTool = __webpack_require__(/*! zrender/lib/tool/color */ 21);\n    var Eventful = __webpack_require__(/*! zrender/lib/mixin/Eventful */ 22);\n    var timsort = __webpack_require__(/*! zrender/lib/core/timsort */ 43);\n\n    var each = zrUtil.each;\n    var parseClassType = ComponentModel.parseClassType;\n\n    var PRIORITY_PROCESSOR_FILTER = 1000;\n    var PRIORITY_PROCESSOR_STATISTIC = 5000;\n\n\n    var PRIORITY_VISUAL_LAYOUT = 1000;\n    var PRIORITY_VISUAL_GLOBAL = 2000;\n    var PRIORITY_VISUAL_CHART = 3000;\n    var PRIORITY_VISUAL_COMPONENT = 4000;\n    // FIXME\n    // necessary?\n    var PRIORITY_VISUAL_BRUSH = 5000;\n\n    // Main process have three entries: `setOption`, `dispatchAction` and `resize`,\n    // where they must not be invoked nestedly, except the only case: invoke\n    // dispatchAction with updateMethod \"none\" in main process.\n    // This flag is used to carry out this rule.\n    // All events will be triggered out side main process (i.e. when !this[IN_MAIN_PROCESS]).\n    var IN_MAIN_PROCESS = '__flagInMainProcess';\n    var HAS_GRADIENT_OR_PATTERN_BG = '__hasGradientOrPatternBg';\n    var OPTION_UPDATED = '__optionUpdated';\n    var ACTION_REG = /^[a-zA-Z0-9_]+$/;\n\n    function createRegisterEventWithLowercaseName(method) {\n        return function (eventName, handler, context) {\n            // Event name is all lowercase\n            eventName = eventName && eventName.toLowerCase();\n            Eventful.prototype[method].call(this, eventName, handler, context);\n        };\n    }\n\n    /**\n     * @module echarts~MessageCenter\n     */\n    function MessageCenter() {\n        Eventful.call(this);\n    }\n    MessageCenter.prototype.on = createRegisterEventWithLowercaseName('on');\n    MessageCenter.prototype.off = createRegisterEventWithLowercaseName('off');\n    MessageCenter.prototype.one = createRegisterEventWithLowercaseName('one');\n    zrUtil.mixin(MessageCenter, Eventful);\n\n    /**\n     * @module echarts~ECharts\n     */\n    function ECharts(dom, theme, opts) {\n        opts = opts || {};\n\n        // Get theme by name\n        if (typeof theme === 'string') {\n            theme = themeStorage[theme];\n        }\n\n        /**\n         * @type {string}\n         */\n        this.id;\n        /**\n         * Group id\n         * @type {string}\n         */\n        this.group;\n        /**\n         * @type {HTMLDomElement}\n         * @private\n         */\n        this._dom = dom;\n        /**\n         * @type {module:zrender/ZRender}\n         * @private\n         */\n        var zr = this._zr = zrender.init(dom, {\n            renderer: opts.renderer || 'canvas',\n            devicePixelRatio: opts.devicePixelRatio,\n            width: opts.width,\n            height: opts.height\n        });\n\n        /**\n         * Expect 60 pfs.\n         * @type {Function}\n         * @private\n         */\n        this._throttledZrFlush = throttle.throttle(zrUtil.bind(zr.flush, zr), 17);\n\n        /**\n         * @type {Object}\n         * @private\n         */\n        this._theme = zrUtil.clone(theme);\n\n        /**\n         * @type {Array.<module:echarts/view/Chart>}\n         * @private\n         */\n        this._chartsViews = [];\n\n        /**\n         * @type {Object.<string, module:echarts/view/Chart>}\n         * @private\n         */\n        this._chartsMap = {};\n\n        /**\n         * @type {Array.<module:echarts/view/Component>}\n         * @private\n         */\n        this._componentsViews = [];\n\n        /**\n         * @type {Object.<string, module:echarts/view/Component>}\n         * @private\n         */\n        this._componentsMap = {};\n\n        /**\n         * @type {module:echarts/CoordinateSystem}\n         * @private\n         */\n        this._coordSysMgr = new CoordinateSystemManager();\n\n        /**\n         * @type {module:echarts/ExtensionAPI}\n         * @private\n         */\n        this._api = createExtensionAPI(this);\n\n        Eventful.call(this);\n\n        /**\n         * @type {module:echarts~MessageCenter}\n         * @private\n         */\n        this._messageCenter = new MessageCenter();\n\n        // Init mouse events\n        this._initEvents();\n\n        // In case some people write `window.onresize = chart.resize`\n        this.resize = zrUtil.bind(this.resize, this);\n\n        // Can't dispatch action during rendering procedure\n        this._pendingActions = [];\n        // Sort on demand\n        function prioritySortFunc(a, b) {\n            return a.prio - b.prio;\n        }\n        timsort(visualFuncs, prioritySortFunc);\n        timsort(dataProcessorFuncs, prioritySortFunc);\n\n        zr.animation.on('frame', this._onframe, this);\n\n        // ECharts instance can be used as value.\n        zrUtil.setAsPrimitive(this);\n    }\n\n    var echartsProto = ECharts.prototype;\n\n    echartsProto._onframe = function () {\n        // Lazy update\n        if (this[OPTION_UPDATED]) {\n            var silent = this[OPTION_UPDATED].silent;\n\n            this[IN_MAIN_PROCESS] = true;\n\n            updateMethods.prepareAndUpdate.call(this);\n\n            this[IN_MAIN_PROCESS] = false;\n\n            this[OPTION_UPDATED] = false;\n\n            flushPendingActions.call(this, silent);\n\n            triggerUpdatedEvent.call(this, silent);\n        }\n    };\n    /**\n     * @return {HTMLDomElement}\n     */\n    echartsProto.getDom = function () {\n        return this._dom;\n    };\n\n    /**\n     * @return {module:zrender~ZRender}\n     */\n    echartsProto.getZr = function () {\n        return this._zr;\n    };\n\n    /**\n     * Usage:\n     * chart.setOption(option, notMerge, lazyUpdate);\n     * chart.setOption(option, {\n     *     notMerge: ...,\n     *     lazyUpdate: ...,\n     *     silent: ...\n     * });\n     *\n     * @param {Object} option\n     * @param {Object|boolean} [opts] opts or notMerge.\n     * @param {boolean} [opts.notMerge=false]\n     * @param {boolean} [opts.lazyUpdate=false] Useful when setOption frequently.\n     */\n    echartsProto.setOption = function (option, notMerge, lazyUpdate) {\n        if (true) {\n            zrUtil.assert(!this[IN_MAIN_PROCESS], '`setOption` should not be called during main process.');\n        }\n\n        var silent;\n        if (zrUtil.isObject(notMerge)) {\n            lazyUpdate = notMerge.lazyUpdate;\n            silent = notMerge.silent;\n            notMerge = notMerge.notMerge;\n        }\n\n        this[IN_MAIN_PROCESS] = true;\n\n        if (!this._model || notMerge) {\n            var optionManager = new OptionManager(this._api);\n            var theme = this._theme;\n            var ecModel = this._model = new GlobalModel(null, null, theme, optionManager);\n            ecModel.init(null, null, theme, optionManager);\n        }\n\n        // FIXME\n        // ugly\n        this.__lastOnlyGraphic = !!(option && option.graphic);\n        zrUtil.each(option, function (o, mainType) {\n            mainType !== 'graphic' && (this.__lastOnlyGraphic = false);\n        }, this);\n\n        this._model.setOption(option, optionPreprocessorFuncs, this.__lastOnlyGraphic);\n\n        if (lazyUpdate) {\n            this[OPTION_UPDATED] = {silent: silent};\n            this[IN_MAIN_PROCESS] = false;\n        }\n        else {\n            updateMethods.prepareAndUpdate.call(this);\n            // Ensure zr refresh sychronously, and then pixel in canvas can be\n            // fetched after `setOption`.\n            this._zr.flush();\n\n            this[OPTION_UPDATED] = false;\n            this[IN_MAIN_PROCESS] = false;\n\n            flushPendingActions.call(this, silent);\n            triggerUpdatedEvent.call(this, silent);\n        }\n    };\n\n    /**\n     * @DEPRECATED\n     */\n    echartsProto.setTheme = function () {\n        console.log('ECharts#setTheme() is DEPRECATED in ECharts 3.0');\n    };\n\n    /**\n     * @return {module:echarts/model/Global}\n     */\n    echartsProto.getModel = function () {\n        return this._model;\n    };\n\n    /**\n     * @return {Object}\n     */\n    echartsProto.getOption = function () {\n        return this._model && this._model.getOption();\n    };\n\n    /**\n     * @return {number}\n     */\n    echartsProto.getWidth = function () {\n        return this._zr.getWidth();\n    };\n\n    /**\n     * @return {number}\n     */\n    echartsProto.getHeight = function () {\n        return this._zr.getHeight();\n    };\n\n    /**\n     * @return {number}\n     */\n    echartsProto.getDevicePixelRatio = function () {\n        return this._zr.painter.dpr || window.devicePixelRatio || 1;\n    };\n\n    /**\n     * Get canvas which has all thing rendered\n     * @param {Object} opts\n     * @param {string} [opts.backgroundColor]\n     */\n    echartsProto.getRenderedCanvas = function (opts) {\n        if (!env.canvasSupported) {\n            return;\n        }\n        opts = opts || {};\n        opts.pixelRatio = opts.pixelRatio || 1;\n        opts.backgroundColor = opts.backgroundColor\n            || this._model.get('backgroundColor');\n        var zr = this._zr;\n        var list = zr.storage.getDisplayList();\n        // Stop animations\n        zrUtil.each(list, function (el) {\n            el.stopAnimation(true);\n        });\n        return zr.painter.getRenderedCanvas(opts);\n    };\n    /**\n     * @return {string}\n     * @param {Object} opts\n     * @param {string} [opts.type='png']\n     * @param {string} [opts.pixelRatio=1]\n     * @param {string} [opts.backgroundColor]\n     * @param {string} [opts.excludeComponents]\n     */\n    echartsProto.getDataURL = function (opts) {\n        opts = opts || {};\n        var excludeComponents = opts.excludeComponents;\n        var ecModel = this._model;\n        var excludesComponentViews = [];\n        var self = this;\n\n        each(excludeComponents, function (componentType) {\n            ecModel.eachComponent({\n                mainType: componentType\n            }, function (component) {\n                var view = self._componentsMap[component.__viewId];\n                if (!view.group.ignore) {\n                    excludesComponentViews.push(view);\n                    view.group.ignore = true;\n                }\n            });\n        });\n\n        var url = this.getRenderedCanvas(opts).toDataURL(\n            'image/' + (opts && opts.type || 'png')\n        );\n\n        each(excludesComponentViews, function (view) {\n            view.group.ignore = false;\n        });\n        return url;\n    };\n\n\n    /**\n     * @return {string}\n     * @param {Object} opts\n     * @param {string} [opts.type='png']\n     * @param {string} [opts.pixelRatio=1]\n     * @param {string} [opts.backgroundColor]\n     */\n    echartsProto.getConnectedDataURL = function (opts) {\n        if (!env.canvasSupported) {\n            return;\n        }\n        var groupId = this.group;\n        var mathMin = Math.min;\n        var mathMax = Math.max;\n        var MAX_NUMBER = Infinity;\n        if (connectedGroups[groupId]) {\n            var left = MAX_NUMBER;\n            var top = MAX_NUMBER;\n            var right = -MAX_NUMBER;\n            var bottom = -MAX_NUMBER;\n            var canvasList = [];\n            var dpr = (opts && opts.pixelRatio) || 1;\n\n            zrUtil.each(instances, function (chart, id) {\n                if (chart.group === groupId) {\n                    var canvas = chart.getRenderedCanvas(\n                        zrUtil.clone(opts)\n                    );\n                    var boundingRect = chart.getDom().getBoundingClientRect();\n                    left = mathMin(boundingRect.left, left);\n                    top = mathMin(boundingRect.top, top);\n                    right = mathMax(boundingRect.right, right);\n                    bottom = mathMax(boundingRect.bottom, bottom);\n                    canvasList.push({\n                        dom: canvas,\n                        left: boundingRect.left,\n                        top: boundingRect.top\n                    });\n                }\n            });\n\n            left *= dpr;\n            top *= dpr;\n            right *= dpr;\n            bottom *= dpr;\n            var width = right - left;\n            var height = bottom - top;\n            var targetCanvas = zrUtil.createCanvas();\n            targetCanvas.width = width;\n            targetCanvas.height = height;\n            var zr = zrender.init(targetCanvas);\n\n            each(canvasList, function (item) {\n                var img = new graphic.Image({\n                    style: {\n                        x: item.left * dpr - left,\n                        y: item.top * dpr - top,\n                        image: item.dom\n                    }\n                });\n                zr.add(img);\n            });\n            zr.refreshImmediately();\n\n            return targetCanvas.toDataURL('image/' + (opts && opts.type || 'png'));\n        }\n        else {\n            return this.getDataURL(opts);\n        }\n    };\n\n    /**\n     * Convert from logical coordinate system to pixel coordinate system.\n     * See CoordinateSystem#convertToPixel.\n     * @param {string|Object} finder\n     *        If string, e.g., 'geo', means {geoIndex: 0}.\n     *        If Object, could contain some of these properties below:\n     *        {\n     *            seriesIndex / seriesId / seriesName,\n     *            geoIndex / geoId, geoName,\n     *            bmapIndex / bmapId / bmapName,\n     *            xAxisIndex / xAxisId / xAxisName,\n     *            yAxisIndex / yAxisId / yAxisName,\n     *            gridIndex / gridId / gridName,\n     *            ... (can be extended)\n     *        }\n     * @param {Array|number} value\n     * @return {Array|number} result\n     */\n    echartsProto.convertToPixel = zrUtil.curry(doConvertPixel, 'convertToPixel');\n\n    /**\n     * Convert from pixel coordinate system to logical coordinate system.\n     * See CoordinateSystem#convertFromPixel.\n     * @param {string|Object} finder\n     *        If string, e.g., 'geo', means {geoIndex: 0}.\n     *        If Object, could contain some of these properties below:\n     *        {\n     *            seriesIndex / seriesId / seriesName,\n     *            geoIndex / geoId / geoName,\n     *            bmapIndex / bmapId / bmapName,\n     *            xAxisIndex / xAxisId / xAxisName,\n     *            yAxisIndex / yAxisId / yAxisName\n     *            gridIndex / gridId / gridName,\n     *            ... (can be extended)\n     *        }\n     * @param {Array|number} value\n     * @return {Array|number} result\n     */\n    echartsProto.convertFromPixel = zrUtil.curry(doConvertPixel, 'convertFromPixel');\n\n    function doConvertPixel(methodName, finder, value) {\n        var ecModel = this._model;\n        var coordSysList = this._coordSysMgr.getCoordinateSystems();\n        var result;\n\n        finder = modelUtil.parseFinder(ecModel, finder);\n\n        for (var i = 0; i < coordSysList.length; i++) {\n            var coordSys = coordSysList[i];\n            if (coordSys[methodName]\n                && (result = coordSys[methodName](ecModel, finder, value)) != null\n            ) {\n                return result;\n            }\n        }\n\n        if (true) {\n            console.warn(\n                'No coordinate system that supports ' + methodName + ' found by the given finder.'\n            );\n        }\n    }\n\n    /**\n     * Is the specified coordinate systems or components contain the given pixel point.\n     * @param {string|Object} finder\n     *        If string, e.g., 'geo', means {geoIndex: 0}.\n     *        If Object, could contain some of these properties below:\n     *        {\n     *            seriesIndex / seriesId / seriesName,\n     *            geoIndex / geoId / geoName,\n     *            bmapIndex / bmapId / bmapName,\n     *            xAxisIndex / xAxisId / xAxisName,\n     *            yAxisIndex / yAxisId / yAxisName,\n     *            gridIndex / gridId / gridName,\n     *            ... (can be extended)\n     *        }\n     * @param {Array|number} value\n     * @return {boolean} result\n     */\n    echartsProto.containPixel = function (finder, value) {\n        var ecModel = this._model;\n        var result;\n\n        finder = modelUtil.parseFinder(ecModel, finder);\n\n        zrUtil.each(finder, function (models, key) {\n            key.indexOf('Models') >= 0 && zrUtil.each(models, function (model) {\n                var coordSys = model.coordinateSystem;\n                if (coordSys && coordSys.containPoint) {\n                    result |= !!coordSys.containPoint(value);\n                }\n                else if (key === 'seriesModels') {\n                    var view = this._chartsMap[model.__viewId];\n                    if (view && view.containPoint) {\n                        result |= view.containPoint(value, model);\n                    }\n                    else {\n                        if (true) {\n                            console.warn(key + ': ' + (view\n                                ? 'The found component do not support containPoint.'\n                                : 'No view mapping to the found component.'\n                            ));\n                        }\n                    }\n                }\n                else {\n                    if (true) {\n                        console.warn(key + ': containPoint is not supported');\n                    }\n                }\n            }, this);\n        }, this);\n\n        return !!result;\n    };\n\n    /**\n     * Get visual from series or data.\n     * @param {string|Object} finder\n     *        If string, e.g., 'series', means {seriesIndex: 0}.\n     *        If Object, could contain some of these properties below:\n     *        {\n     *            seriesIndex / seriesId / seriesName,\n     *            dataIndex / dataIndexInside\n     *        }\n     *        If dataIndex is not specified, series visual will be fetched,\n     *        but not data item visual.\n     *        If all of seriesIndex, seriesId, seriesName are not specified,\n     *        visual will be fetched from first series.\n     * @param {string} visualType 'color', 'symbol', 'symbolSize'\n     */\n    echartsProto.getVisual = function (finder, visualType) {\n        var ecModel = this._model;\n\n        finder = modelUtil.parseFinder(ecModel, finder, {defaultMainType: 'series'});\n\n        var seriesModel = finder.seriesModel;\n\n        if (true) {\n            if (!seriesModel) {\n                console.warn('There is no specified seires model');\n            }\n        }\n\n        var data = seriesModel.getData();\n\n        var dataIndexInside = finder.hasOwnProperty('dataIndexInside')\n            ? finder.dataIndexInside\n            : finder.hasOwnProperty('dataIndex')\n            ? data.indexOfRawIndex(finder.dataIndex)\n            : null;\n\n        return dataIndexInside != null\n            ? data.getItemVisual(dataIndexInside, visualType)\n            : data.getVisual(visualType);\n    };\n\n    /**\n     * Get view of corresponding component model\n     * @param  {module:echarts/model/Component} componentModel\n     * @return {module:echarts/view/Component}\n     */\n    echartsProto.getViewOfComponentModel = function (componentModel) {\n        return this._componentsMap[componentModel.__viewId];\n    };\n\n    /**\n     * Get view of corresponding series model\n     * @param  {module:echarts/model/Series} seriesModel\n     * @return {module:echarts/view/Chart}\n     */\n    echartsProto.getViewOfSeriesModel = function (seriesModel) {\n        return this._chartsMap[seriesModel.__viewId];\n    };\n\n\n    var updateMethods = {\n\n        /**\n         * @param {Object} payload\n         * @private\n         */\n        update: function (payload) {\n            // console.profile && console.profile('update');\n\n            var ecModel = this._model;\n            var api = this._api;\n            var coordSysMgr = this._coordSysMgr;\n            var zr = this._zr;\n            // update before setOption\n            if (!ecModel) {\n                return;\n            }\n\n            // Fixme First time update ?\n            ecModel.restoreData();\n\n            // TODO\n            // Save total ecModel here for undo/redo (after restoring data and before processing data).\n            // Undo (restoration of total ecModel) can be carried out in 'action' or outside API call.\n\n            // Create new coordinate system each update\n            // In LineView may save the old coordinate system and use it to get the orignal point\n            coordSysMgr.create(this._model, this._api);\n\n            processData.call(this, ecModel, api);\n\n            stackSeriesData.call(this, ecModel);\n\n            coordSysMgr.update(ecModel, api);\n\n            doVisualEncoding.call(this, ecModel, payload);\n\n            doRender.call(this, ecModel, payload);\n\n            // Set background\n            var backgroundColor = ecModel.get('backgroundColor') || 'transparent';\n\n            var painter = zr.painter;\n            // TODO all use clearColor ?\n            if (painter.isSingleCanvas && painter.isSingleCanvas()) {\n                zr.configLayer(0, {\n                    clearColor: backgroundColor\n                });\n            }\n            else {\n                // In IE8\n                if (!env.canvasSupported) {\n                    var colorArr = colorTool.parse(backgroundColor);\n                    backgroundColor = colorTool.stringify(colorArr, 'rgb');\n                    if (colorArr[3] === 0) {\n                        backgroundColor = 'transparent';\n                    }\n                }\n                if (backgroundColor.colorStops || backgroundColor.image) {\n                    // Gradient background\n                    // FIXME Fixed layer？\n                    zr.configLayer(0, {\n                        clearColor: backgroundColor\n                    });\n                    this[HAS_GRADIENT_OR_PATTERN_BG] = true;\n\n                    this._dom.style.background = 'transparent';\n                }\n                else {\n                    if (this[HAS_GRADIENT_OR_PATTERN_BG]) {\n                        zr.configLayer(0, {\n                            clearColor: null\n                        });\n                    }\n                    this[HAS_GRADIENT_OR_PATTERN_BG] = false;\n\n                    this._dom.style.background = backgroundColor;\n                }\n            }\n\n            each(postUpdateFuncs, function (func) {\n                func(ecModel, api);\n            });\n\n            // console.profile && console.profileEnd('update');\n        },\n\n        /**\n         * @param {Object} payload\n         * @private\n         */\n        updateView: function (payload) {\n            var ecModel = this._model;\n\n            // update before setOption\n            if (!ecModel) {\n                return;\n            }\n\n            ecModel.eachSeries(function (seriesModel) {\n                seriesModel.getData().clearAllVisual();\n            });\n\n            doVisualEncoding.call(this, ecModel, payload);\n\n            invokeUpdateMethod.call(this, 'updateView', ecModel, payload);\n        },\n\n        /**\n         * @param {Object} payload\n         * @private\n         */\n        updateVisual: function (payload) {\n            var ecModel = this._model;\n\n            // update before setOption\n            if (!ecModel) {\n                return;\n            }\n\n            ecModel.eachSeries(function (seriesModel) {\n                seriesModel.getData().clearAllVisual();\n            });\n\n            doVisualEncoding.call(this, ecModel, payload, true);\n\n            invokeUpdateMethod.call(this, 'updateVisual', ecModel, payload);\n        },\n\n        /**\n         * @param {Object} payload\n         * @private\n         */\n        updateLayout: function (payload) {\n            var ecModel = this._model;\n\n            // update before setOption\n            if (!ecModel) {\n                return;\n            }\n\n            doLayout.call(this, ecModel, payload);\n\n            invokeUpdateMethod.call(this, 'updateLayout', ecModel, payload);\n        },\n\n        /**\n         * @param {Object} payload\n         * @private\n         */\n        prepareAndUpdate: function (payload) {\n            var ecModel = this._model;\n\n            prepareView.call(this, 'component', ecModel);\n\n            prepareView.call(this, 'chart', ecModel);\n\n            // FIXME\n            // ugly\n            if (this.__lastOnlyGraphic) {\n                each(this._componentsViews, function (componentView) {\n                    var componentModel = componentView.__model;\n                    if (componentModel && componentModel.mainType === 'graphic') {\n                        componentView.render(componentModel, ecModel, this._api, payload);\n                        updateZ(componentModel, componentView);\n                    }\n                }, this);\n                this.__lastOnlyGraphic = false;\n            }\n            else {\n                updateMethods.update.call(this, payload);\n            }\n        }\n    };\n\n    /**\n     * @private\n     */\n    function updateDirectly(ecIns, method, payload, mainType, subType) {\n        var ecModel = ecIns._model;\n\n        // broadcast\n        if (!mainType) {\n            each(ecIns._componentsViews.concat(ecIns._chartsViews), callView);\n            return;\n        }\n\n        var query = {};\n        query[mainType + 'Id'] = payload[mainType + 'Id'];\n        query[mainType + 'Index'] = payload[mainType + 'Index'];\n        query[mainType + 'Name'] = payload[mainType + 'Name'];\n\n        var condition = {mainType: mainType, query: query};\n        subType && (condition.subType = subType); // subType may be '' by parseClassType;\n\n        // If dispatchAction before setOption, do nothing.\n        ecModel && ecModel.eachComponent(condition, function (model, index) {\n            callView(ecIns[\n                mainType === 'series' ? '_chartsMap' : '_componentsMap'\n            ][model.__viewId]);\n        }, ecIns);\n\n        function callView(view) {\n            view && view.__alive && view[method] && view[method](\n                view.__model, ecModel, ecIns._api, payload\n            );\n        }\n    }\n\n    /**\n     * Resize the chart\n     * @param {Object} opts\n     * @param {number} [opts.width] Can be 'auto' (the same as null/undefined)\n     * @param {number} [opts.height] Can be 'auto' (the same as null/undefined)\n     * @param {boolean} [opts.silent=false]\n     */\n    echartsProto.resize = function (opts) {\n        if (true) {\n            zrUtil.assert(!this[IN_MAIN_PROCESS], '`resize` should not be called during main process.');\n        }\n\n        this[IN_MAIN_PROCESS] = true;\n\n        this._zr.resize(opts);\n\n        var optionChanged = this._model && this._model.resetOption('media');\n        var updateMethod = optionChanged ? 'prepareAndUpdate' : 'update';\n\n        updateMethods[updateMethod].call(this);\n\n        // Resize loading effect\n        this._loadingFX && this._loadingFX.resize();\n\n        this[IN_MAIN_PROCESS] = false;\n\n        var silent = opts && opts.silent;\n\n        flushPendingActions.call(this, silent);\n\n        triggerUpdatedEvent.call(this, silent);\n    };\n\n    /**\n     * Show loading effect\n     * @param  {string} [name='default']\n     * @param  {Object} [cfg]\n     */\n    echartsProto.showLoading = function (name, cfg) {\n        if (zrUtil.isObject(name)) {\n            cfg = name;\n            name = '';\n        }\n        name = name || 'default';\n\n        this.hideLoading();\n        if (!loadingEffects[name]) {\n            if (true) {\n                console.warn('Loading effects ' + name + ' not exists.');\n            }\n            return;\n        }\n        var el = loadingEffects[name](this._api, cfg);\n        var zr = this._zr;\n        this._loadingFX = el;\n\n        zr.add(el);\n    };\n\n    /**\n     * Hide loading effect\n     */\n    echartsProto.hideLoading = function () {\n        this._loadingFX && this._zr.remove(this._loadingFX);\n        this._loadingFX = null;\n    };\n\n    /**\n     * @param {Object} eventObj\n     * @return {Object}\n     */\n    echartsProto.makeActionFromEvent = function (eventObj) {\n        var payload = zrUtil.extend({}, eventObj);\n        payload.type = eventActionMap[eventObj.type];\n        return payload;\n    };\n\n    /**\n     * @pubilc\n     * @param {Object} payload\n     * @param {string} [payload.type] Action type\n     * @param {Object|boolean} [opt] If pass boolean, means opt.silent\n     * @param {boolean} [opt.silent=false] Whether trigger events.\n     * @param {boolean} [opt.flush=undefined]\n     *                  true: Flush immediately, and then pixel in canvas can be fetched\n     *                      immediately. Caution: it might affect performance.\n     *                  false: Not not flush.\n     *                  undefined: Auto decide whether perform flush.\n     */\n    echartsProto.dispatchAction = function (payload, opt) {\n        if (!zrUtil.isObject(opt)) {\n            opt = {silent: !!opt};\n        }\n\n        if (!actions[payload.type]) {\n            return;\n        }\n\n        // May dispatchAction in rendering procedure\n        if (this[IN_MAIN_PROCESS]) {\n            this._pendingActions.push(payload);\n            return;\n        }\n\n        doDispatchAction.call(this, payload, opt.silent);\n\n        if (opt.flush) {\n            this._zr.flush(true);\n        }\n        else if (opt.flush !== false && env.browser.weChat) {\n            // In WeChat embeded browser, `requestAnimationFrame` and `setInterval`\n            // hang when sliding page (on touch event), which cause that zr does not\n            // refresh util user interaction finished, which is not expected.\n            // But `dispatchAction` may be called too frequently when pan on touch\n            // screen, which impacts performance if do not throttle them.\n            this._throttledZrFlush();\n        }\n\n        flushPendingActions.call(this, opt.silent);\n\n        triggerUpdatedEvent.call(this, opt.silent);\n    };\n\n    function doDispatchAction(payload, silent) {\n        var payloadType = payload.type;\n        var escapeConnect = payload.escapeConnect;\n        var actionWrap = actions[payloadType];\n        var actionInfo = actionWrap.actionInfo;\n\n        var cptType = (actionInfo.update || 'update').split(':');\n        var updateMethod = cptType.pop();\n        cptType = cptType[0] != null && parseClassType(cptType[0]);\n\n        this[IN_MAIN_PROCESS] = true;\n\n        var payloads = [payload];\n        var batched = false;\n        // Batch action\n        if (payload.batch) {\n            batched = true;\n            payloads = zrUtil.map(payload.batch, function (item) {\n                item = zrUtil.defaults(zrUtil.extend({}, item), payload);\n                item.batch = null;\n                return item;\n            });\n        }\n\n        var eventObjBatch = [];\n        var eventObj;\n        var isHighDown = payloadType === 'highlight' || payloadType === 'downplay';\n\n        each(payloads, function (batchItem) {\n            // Action can specify the event by return it.\n            eventObj = actionWrap.action(batchItem, this._model, this._api);\n            // Emit event outside\n            eventObj = eventObj || zrUtil.extend({}, batchItem);\n            // Convert type to eventType\n            eventObj.type = actionInfo.event || eventObj.type;\n            eventObjBatch.push(eventObj);\n\n            // light update does not perform data process, layout and visual.\n            if (isHighDown) {\n                // method, payload, mainType, subType\n                updateDirectly(this, updateMethod, batchItem, 'series');\n            }\n            else if (cptType) {\n                updateDirectly(this, updateMethod, batchItem, cptType.main, cptType.sub);\n            }\n        }, this);\n\n        if (updateMethod !== 'none' && !isHighDown && !cptType) {\n            // Still dirty\n            if (this[OPTION_UPDATED]) {\n                // FIXME Pass payload ?\n                updateMethods.prepareAndUpdate.call(this, payload);\n                this[OPTION_UPDATED] = false;\n            }\n            else {\n                updateMethods[updateMethod].call(this, payload);\n            }\n        }\n\n        // Follow the rule of action batch\n        if (batched) {\n            eventObj = {\n                type: actionInfo.event || payloadType,\n                escapeConnect: escapeConnect,\n                batch: eventObjBatch\n            };\n        }\n        else {\n            eventObj = eventObjBatch[0];\n        }\n\n        this[IN_MAIN_PROCESS] = false;\n\n        !silent && this._messageCenter.trigger(eventObj.type, eventObj);\n    }\n\n    function flushPendingActions(silent) {\n        var pendingActions = this._pendingActions;\n        while (pendingActions.length) {\n            var payload = pendingActions.shift();\n            doDispatchAction.call(this, payload, silent);\n        }\n    }\n\n    function triggerUpdatedEvent(silent) {\n        !silent && this.trigger('updated');\n    }\n\n    /**\n     * Register event\n     * @method\n     */\n    echartsProto.on = createRegisterEventWithLowercaseName('on');\n    echartsProto.off = createRegisterEventWithLowercaseName('off');\n    echartsProto.one = createRegisterEventWithLowercaseName('one');\n\n    /**\n     * @param {string} methodName\n     * @private\n     */\n    function invokeUpdateMethod(methodName, ecModel, payload) {\n        var api = this._api;\n\n        // Update all components\n        each(this._componentsViews, function (component) {\n            var componentModel = component.__model;\n            component[methodName](componentModel, ecModel, api, payload);\n\n            updateZ(componentModel, component);\n        }, this);\n\n        // Upate all charts\n        ecModel.eachSeries(function (seriesModel, idx) {\n            var chart = this._chartsMap[seriesModel.__viewId];\n            chart[methodName](seriesModel, ecModel, api, payload);\n\n            updateZ(seriesModel, chart);\n\n            updateProgressiveAndBlend(seriesModel, chart);\n        }, this);\n\n        // If use hover layer\n        updateHoverLayerStatus(this._zr, ecModel);\n\n        // Post render\n        each(postUpdateFuncs, function (func) {\n            func(ecModel, api);\n        });\n    }\n\n    /**\n     * Prepare view instances of charts and components\n     * @param  {module:echarts/model/Global} ecModel\n     * @private\n     */\n    function prepareView(type, ecModel) {\n        var isComponent = type === 'component';\n        var viewList = isComponent ? this._componentsViews : this._chartsViews;\n        var viewMap = isComponent ? this._componentsMap : this._chartsMap;\n        var zr = this._zr;\n\n        for (var i = 0; i < viewList.length; i++) {\n            viewList[i].__alive = false;\n        }\n\n        ecModel[isComponent ? 'eachComponent' : 'eachSeries'](function (componentType, model) {\n            if (isComponent) {\n                if (componentType === 'series') {\n                    return;\n                }\n            }\n            else {\n                model = componentType;\n            }\n\n            // Consider: id same and type changed.\n            var viewId = model.id + '_' + model.type;\n            var view = viewMap[viewId];\n            if (!view) {\n                var classType = parseClassType(model.type);\n                var Clazz = isComponent\n                    ? ComponentView.getClass(classType.main, classType.sub)\n                    : ChartView.getClass(classType.sub);\n                if (Clazz) {\n                    view = new Clazz();\n                    view.init(ecModel, this._api);\n                    viewMap[viewId] = view;\n                    viewList.push(view);\n                    zr.add(view.group);\n                }\n                else {\n                    // Error\n                    return;\n                }\n            }\n\n            model.__viewId = view.__id = viewId;\n            view.__alive = true;\n            view.__model = model;\n            view.group.__ecComponentInfo = {\n                mainType: model.mainType,\n                index: model.componentIndex\n            };\n        }, this);\n\n        for (var i = 0; i < viewList.length;) {\n            var view = viewList[i];\n            if (!view.__alive) {\n                zr.remove(view.group);\n                view.dispose(ecModel, this._api);\n                viewList.splice(i, 1);\n                delete viewMap[view.__id];\n                view.__id = view.group.__ecComponentInfo = null;\n            }\n            else {\n                i++;\n            }\n        }\n    }\n\n    /**\n     * Processor data in each series\n     *\n     * @param {module:echarts/model/Global} ecModel\n     * @private\n     */\n    function processData(ecModel, api) {\n        each(dataProcessorFuncs, function (process) {\n            process.func(ecModel, api);\n        });\n    }\n\n    /**\n     * @private\n     */\n    function stackSeriesData(ecModel) {\n        var stackedDataMap = {};\n        ecModel.eachSeries(function (series) {\n            var stack = series.get('stack');\n            var data = series.getData();\n            if (stack && data.type === 'list') {\n                var previousStack = stackedDataMap[stack];\n                if (previousStack) {\n                    data.stackedOn = previousStack;\n                }\n                stackedDataMap[stack] = data;\n            }\n        });\n    }\n\n    /**\n     * Layout before each chart render there series, special visual encoding stage\n     *\n     * @param {module:echarts/model/Global} ecModel\n     * @private\n     */\n    function doLayout(ecModel, payload) {\n        var api = this._api;\n        each(visualFuncs, function (visual) {\n            if (visual.isLayout) {\n                visual.func(ecModel, api, payload);\n            }\n        });\n    }\n\n    /**\n     * Encode visual infomation from data after data processing\n     *\n     * @param {module:echarts/model/Global} ecModel\n     * @param {object} layout\n     * @param {boolean} [excludesLayout]\n     * @private\n     */\n    function doVisualEncoding(ecModel, payload, excludesLayout) {\n        var api = this._api;\n        ecModel.clearColorPalette();\n        ecModel.eachSeries(function (seriesModel) {\n            seriesModel.clearColorPalette();\n        });\n        each(visualFuncs, function (visual) {\n            (!excludesLayout || !visual.isLayout)\n                && visual.func(ecModel, api, payload);\n        });\n    }\n\n    /**\n     * Render each chart and component\n     * @private\n     */\n    function doRender(ecModel, payload) {\n        var api = this._api;\n        // Render all components\n        each(this._componentsViews, function (componentView) {\n            var componentModel = componentView.__model;\n            componentView.render(componentModel, ecModel, api, payload);\n\n            updateZ(componentModel, componentView);\n        }, this);\n\n        each(this._chartsViews, function (chart) {\n            chart.__alive = false;\n        }, this);\n\n        // Render all charts\n        ecModel.eachSeries(function (seriesModel, idx) {\n            var chartView = this._chartsMap[seriesModel.__viewId];\n            chartView.__alive = true;\n            chartView.render(seriesModel, ecModel, api, payload);\n\n            chartView.group.silent = !!seriesModel.get('silent');\n\n            updateZ(seriesModel, chartView);\n\n            updateProgressiveAndBlend(seriesModel, chartView);\n\n        }, this);\n\n        // If use hover layer\n        updateHoverLayerStatus(this._zr, ecModel);\n\n        // Remove groups of unrendered charts\n        each(this._chartsViews, function (chart) {\n            if (!chart.__alive) {\n                chart.remove(ecModel, api);\n            }\n        }, this);\n    }\n\n    var MOUSE_EVENT_NAMES = [\n        'click', 'dblclick', 'mouseover', 'mouseout', 'mousemove',\n        'mousedown', 'mouseup', 'globalout', 'contextmenu'\n    ];\n    /**\n     * @private\n     */\n    echartsProto._initEvents = function () {\n        each(MOUSE_EVENT_NAMES, function (eveName) {\n            this._zr.on(eveName, function (e) {\n                var ecModel = this.getModel();\n                var el = e.target;\n                var params;\n\n                // no e.target when 'globalout'.\n                if (eveName === 'globalout') {\n                    params = {};\n                }\n                else if (el && el.dataIndex != null) {\n                    var dataModel = el.dataModel || ecModel.getSeriesByIndex(el.seriesIndex);\n                    params = dataModel && dataModel.getDataParams(el.dataIndex, el.dataType) || {};\n                }\n                // If element has custom eventData of components\n                else if (el && el.eventData) {\n                    params = zrUtil.extend({}, el.eventData);\n                }\n\n                if (params) {\n                    params.event = e;\n                    params.type = eveName;\n                    this.trigger(eveName, params);\n                }\n\n            }, this);\n        }, this);\n\n        each(eventActionMap, function (actionType, eventType) {\n            this._messageCenter.on(eventType, function (event) {\n                this.trigger(eventType, event);\n            }, this);\n        }, this);\n    };\n\n    /**\n     * @return {boolean}\n     */\n    echartsProto.isDisposed = function () {\n        return this._disposed;\n    };\n\n    /**\n     * Clear\n     */\n    echartsProto.clear = function () {\n        this.setOption({ series: [] }, true);\n    };\n\n    /**\n     * Dispose instance\n     */\n    echartsProto.dispose = function () {\n        if (this._disposed) {\n            if (true) {\n                console.warn('Instance ' + this.id + ' has been disposed');\n            }\n            return;\n        }\n        this._disposed = true;\n\n        var api = this._api;\n        var ecModel = this._model;\n\n        each(this._componentsViews, function (component) {\n            component.dispose(ecModel, api);\n        });\n        each(this._chartsViews, function (chart) {\n            chart.dispose(ecModel, api);\n        });\n\n        // Dispose after all views disposed\n        this._zr.dispose();\n\n        delete instances[this.id];\n    };\n\n    zrUtil.mixin(ECharts, Eventful);\n\n    function updateHoverLayerStatus(zr, ecModel) {\n        var storage = zr.storage;\n        var elCount = 0;\n        storage.traverse(function (el) {\n            if (!el.isGroup) {\n                elCount++;\n            }\n        });\n        if (elCount > ecModel.get('hoverLayerThreshold') && !env.node) {\n            storage.traverse(function (el) {\n                if (!el.isGroup) {\n                    el.useHoverLayer = true;\n                }\n            });\n        }\n    }\n\n    /**\n     * Update chart progressive and blend.\n     * @param {module:echarts/model/Series|module:echarts/model/Component} model\n     * @param {module:echarts/view/Component|module:echarts/view/Chart} view\n     */\n    function updateProgressiveAndBlend(seriesModel, chartView) {\n        // Progressive configuration\n        var elCount = 0;\n        chartView.group.traverse(function (el) {\n            if (el.type !== 'group' && !el.ignore) {\n                elCount++;\n            }\n        });\n        var frameDrawNum = +seriesModel.get('progressive');\n        var needProgressive = elCount > seriesModel.get('progressiveThreshold') && frameDrawNum && !env.node;\n        if (needProgressive) {\n            chartView.group.traverse(function (el) {\n                // FIXME marker and other components\n                if (!el.isGroup) {\n                    el.progressive = needProgressive ?\n                        Math.floor(elCount++ / frameDrawNum) : -1;\n                    if (needProgressive) {\n                        el.stopAnimation(true);\n                    }\n                }\n            });\n        }\n\n        // Blend configration\n        var blendMode = seriesModel.get('blendMode') || null;\n        if (true) {\n            if (!env.canvasSupported && blendMode && blendMode !== 'source-over') {\n                console.warn('Only canvas support blendMode');\n            }\n        }\n        chartView.group.traverse(function (el) {\n            // FIXME marker and other components\n            if (!el.isGroup) {\n                el.setStyle('blend', blendMode);\n            }\n        });\n    }\n\n    /**\n     * @param {module:echarts/model/Series|module:echarts/model/Component} model\n     * @param {module:echarts/view/Component|module:echarts/view/Chart} view\n     */\n    function updateZ(model, view) {\n        var z = model.get('z');\n        var zlevel = model.get('zlevel');\n        // Set z and zlevel\n        view.group.traverse(function (el) {\n            if (el.type !== 'group') {\n                z != null && (el.z = z);\n                zlevel != null && (el.zlevel = zlevel);\n            }\n        });\n    }\n\n    function createExtensionAPI(ecInstance) {\n        var coordSysMgr = ecInstance._coordSysMgr;\n        return zrUtil.extend(new ExtensionAPI(ecInstance), {\n            // Inject methods\n            getCoordinateSystems: zrUtil.bind(\n                coordSysMgr.getCoordinateSystems, coordSysMgr\n            ),\n            getComponentByElement: function (el) {\n                while (el) {\n                    var modelInfo = el.__ecComponentInfo;\n                    if (modelInfo != null) {\n                        return ecInstance._model.getComponent(modelInfo.mainType, modelInfo.index);\n                    }\n                    el = el.parent;\n                }\n            }\n        });\n    }\n\n    /**\n     * @type {Object} key: actionType.\n     * @inner\n     */\n    var actions = {};\n\n    /**\n     * Map eventType to actionType\n     * @type {Object}\n     */\n    var eventActionMap = {};\n\n    /**\n     * Data processor functions of each stage\n     * @type {Array.<Object.<string, Function>>}\n     * @inner\n     */\n    var dataProcessorFuncs = [];\n\n    /**\n     * @type {Array.<Function>}\n     * @inner\n     */\n    var optionPreprocessorFuncs = [];\n\n    /**\n     * @type {Array.<Function>}\n     * @inner\n     */\n    var postUpdateFuncs = [];\n\n    /**\n     * Visual encoding functions of each stage\n     * @type {Array.<Object.<string, Function>>}\n     * @inner\n     */\n    var visualFuncs = [];\n    /**\n     * Theme storage\n     * @type {Object.<key, Object>}\n     */\n    var themeStorage = {};\n    /**\n     * Loading effects\n     */\n    var loadingEffects = {};\n\n\n    var instances = {};\n    var connectedGroups = {};\n\n    var idBase = new Date() - 0;\n    var groupIdBase = new Date() - 0;\n    var DOM_ATTRIBUTE_KEY = '_echarts_instance_';\n    /**\n     * @alias module:echarts\n     */\n    var echarts = {\n        /**\n         * @type {number}\n         */\n        version: '3.5.4',\n        dependencies: {\n            zrender: '3.4.4'\n        }\n    };\n\n    function enableConnect(chart) {\n        var STATUS_PENDING = 0;\n        var STATUS_UPDATING = 1;\n        var STATUS_UPDATED = 2;\n        var STATUS_KEY = '__connectUpdateStatus';\n\n        function updateConnectedChartsStatus(charts, status) {\n            for (var i = 0; i < charts.length; i++) {\n                var otherChart = charts[i];\n                otherChart[STATUS_KEY] = status;\n            }\n        }\n\n        zrUtil.each(eventActionMap, function (actionType, eventType) {\n            chart._messageCenter.on(eventType, function (event) {\n                if (connectedGroups[chart.group] && chart[STATUS_KEY] !== STATUS_PENDING) {\n                    if (event && event.escapeConnect) {\n                        return;\n                    }\n\n                    var action = chart.makeActionFromEvent(event);\n                    var otherCharts = [];\n\n                    zrUtil.each(instances, function (otherChart) {\n                        if (otherChart !== chart && otherChart.group === chart.group) {\n                            otherCharts.push(otherChart);\n                        }\n                    });\n\n                    updateConnectedChartsStatus(otherCharts, STATUS_PENDING);\n                    each(otherCharts, function (otherChart) {\n                        if (otherChart[STATUS_KEY] !== STATUS_UPDATING) {\n                            otherChart.dispatchAction(action);\n                        }\n                    });\n                    updateConnectedChartsStatus(otherCharts, STATUS_UPDATED);\n                }\n            });\n        });\n    }\n\n    /**\n     * @param {HTMLDomElement} dom\n     * @param {Object} [theme]\n     * @param {Object} opts\n     * @param {number} [opts.devicePixelRatio] Use window.devicePixelRatio by default\n     * @param {string} [opts.renderer] Currently only 'canvas' is supported.\n     * @param {number} [opts.width] Use clientWidth of the input `dom` by default.\n     *                              Can be 'auto' (the same as null/undefined)\n     * @param {number} [opts.height] Use clientHeight of the input `dom` by default.\n     *                               Can be 'auto' (the same as null/undefined)\n     */\n    echarts.init = function (dom, theme, opts) {\n        if (true) {\n            // Check version\n            if ((zrender.version.replace('.', '') - 0) < (echarts.dependencies.zrender.replace('.', '') - 0)) {\n                throw new Error(\n                    'ZRender ' + zrender.version\n                    + ' is too old for ECharts ' + echarts.version\n                    + '. Current version need ZRender '\n                    + echarts.dependencies.zrender + '+'\n                );\n            }\n            if (!dom) {\n                throw new Error('Initialize failed: invalid dom.');\n            }\n            if (zrUtil.isDom(dom)\n                && dom.nodeName.toUpperCase() !== 'CANVAS'\n                && (\n                    (!dom.clientWidth && (!opts || opts.width == null))\n                    || (!dom.clientHeight && (!opts || opts.height == null))\n                )\n            ) {\n                console.warn('Can\\'t get dom width or height');\n            }\n        }\n\n        var chart = new ECharts(dom, theme, opts);\n        chart.id = 'ec_' + idBase++;\n        instances[chart.id] = chart;\n\n        dom.setAttribute &&\n            dom.setAttribute(DOM_ATTRIBUTE_KEY, chart.id);\n\n        enableConnect(chart);\n\n        return chart;\n    };\n\n    /**\n     * @return {string|Array.<module:echarts~ECharts>} groupId\n     */\n    echarts.connect = function (groupId) {\n        // Is array of charts\n        if (zrUtil.isArray(groupId)) {\n            var charts = groupId;\n            groupId = null;\n            // If any chart has group\n            zrUtil.each(charts, function (chart) {\n                if (chart.group != null) {\n                    groupId = chart.group;\n                }\n            });\n            groupId = groupId || ('g_' + groupIdBase++);\n            zrUtil.each(charts, function (chart) {\n                chart.group = groupId;\n            });\n        }\n        connectedGroups[groupId] = true;\n        return groupId;\n    };\n\n    /**\n     * @DEPRECATED\n     * @return {string} groupId\n     */\n    echarts.disConnect = function (groupId) {\n        connectedGroups[groupId] = false;\n    };\n\n    /**\n     * @return {string} groupId\n     */\n    echarts.disconnect = echarts.disConnect;\n\n    /**\n     * Dispose a chart instance\n     * @param  {module:echarts~ECharts|HTMLDomElement|string} chart\n     */\n    echarts.dispose = function (chart) {\n        if (zrUtil.isDom(chart)) {\n            chart = echarts.getInstanceByDom(chart);\n        }\n        else if (typeof chart === 'string') {\n            chart = instances[chart];\n        }\n        if ((chart instanceof ECharts) && !chart.isDisposed()) {\n            chart.dispose();\n        }\n    };\n\n    /**\n     * @param  {HTMLDomElement} dom\n     * @return {echarts~ECharts}\n     */\n    echarts.getInstanceByDom = function (dom) {\n        var key = dom.getAttribute(DOM_ATTRIBUTE_KEY);\n        return instances[key];\n    };\n    /**\n     * @param {string} key\n     * @return {echarts~ECharts}\n     */\n    echarts.getInstanceById = function (key) {\n        return instances[key];\n    };\n\n    /**\n     * Register theme\n     */\n    echarts.registerTheme = function (name, theme) {\n        themeStorage[name] = theme;\n    };\n\n    /**\n     * Register option preprocessor\n     * @param {Function} preprocessorFunc\n     */\n    echarts.registerPreprocessor = function (preprocessorFunc) {\n        optionPreprocessorFuncs.push(preprocessorFunc);\n    };\n\n    /**\n     * @param {number} [priority=1000]\n     * @param {Function} processorFunc\n     */\n    echarts.registerProcessor = function (priority, processorFunc) {\n        if (typeof priority === 'function') {\n            processorFunc = priority;\n            priority = PRIORITY_PROCESSOR_FILTER;\n        }\n        if (true) {\n            if (isNaN(priority)) {\n                throw new Error('Unkown processor priority');\n            }\n        }\n        dataProcessorFuncs.push({\n            prio: priority,\n            func: processorFunc\n        });\n    };\n\n    /**\n     * Register postUpdater\n     * @param {Function} postUpdateFunc\n     */\n    echarts.registerPostUpdate = function (postUpdateFunc) {\n        postUpdateFuncs.push(postUpdateFunc);\n    };\n\n    /**\n     * Usage:\n     * registerAction('someAction', 'someEvent', function () { ... });\n     * registerAction('someAction', function () { ... });\n     * registerAction(\n     *     {type: 'someAction', event: 'someEvent', update: 'updateView'},\n     *     function () { ... }\n     * );\n     *\n     * @param {(string|Object)} actionInfo\n     * @param {string} actionInfo.type\n     * @param {string} [actionInfo.event]\n     * @param {string} [actionInfo.update]\n     * @param {string} [eventName]\n     * @param {Function} action\n     */\n    echarts.registerAction = function (actionInfo, eventName, action) {\n        if (typeof eventName === 'function') {\n            action = eventName;\n            eventName = '';\n        }\n        var actionType = zrUtil.isObject(actionInfo)\n            ? actionInfo.type\n            : ([actionInfo, actionInfo = {\n                event: eventName\n            }][0]);\n\n        // Event name is all lowercase\n        actionInfo.event = (actionInfo.event || actionType).toLowerCase();\n        eventName = actionInfo.event;\n\n        // Validate action type and event name.\n        zrUtil.assert(ACTION_REG.test(actionType) && ACTION_REG.test(eventName));\n\n        if (!actions[actionType]) {\n            actions[actionType] = {action: action, actionInfo: actionInfo};\n        }\n        eventActionMap[eventName] = actionType;\n    };\n\n    /**\n     * @param {string} type\n     * @param {*} CoordinateSystem\n     */\n    echarts.registerCoordinateSystem = function (type, CoordinateSystem) {\n        CoordinateSystemManager.register(type, CoordinateSystem);\n    };\n\n    /**\n     * Layout is a special stage of visual encoding\n     * Most visual encoding like color are common for different chart\n     * But each chart has it's own layout algorithm\n     *\n     * @param {number} [priority=1000]\n     * @param {Function} layoutFunc\n     */\n    echarts.registerLayout = function (priority, layoutFunc) {\n        if (typeof priority === 'function') {\n            layoutFunc = priority;\n            priority = PRIORITY_VISUAL_LAYOUT;\n        }\n        if (true) {\n            if (isNaN(priority)) {\n                throw new Error('Unkown layout priority');\n            }\n        }\n        visualFuncs.push({\n            prio: priority,\n            func: layoutFunc,\n            isLayout: true\n        });\n    };\n\n    /**\n     * @param {number} [priority=3000]\n     * @param {Function} visualFunc\n     */\n    echarts.registerVisual = function (priority, visualFunc) {\n        if (typeof priority === 'function') {\n            visualFunc = priority;\n            priority = PRIORITY_VISUAL_CHART;\n        }\n        if (true) {\n            if (isNaN(priority)) {\n                throw new Error('Unkown visual priority');\n            }\n        }\n        visualFuncs.push({\n            prio: priority,\n            func: visualFunc\n        });\n    };\n\n    /**\n     * @param {string} name\n     */\n    echarts.registerLoading = function (name, loadingFx) {\n        loadingEffects[name] = loadingFx;\n    };\n\n    /**\n     * @param {Object} opts\n     * @param {string} [superClass]\n     */\n    echarts.extendComponentModel = function (opts/*, superClass*/) {\n        // var Clazz = ComponentModel;\n        // if (superClass) {\n        //     var classType = parseClassType(superClass);\n        //     Clazz = ComponentModel.getClass(classType.main, classType.sub, true);\n        // }\n        return ComponentModel.extend(opts);\n    };\n\n    /**\n     * @param {Object} opts\n     * @param {string} [superClass]\n     */\n    echarts.extendComponentView = function (opts/*, superClass*/) {\n        // var Clazz = ComponentView;\n        // if (superClass) {\n        //     var classType = parseClassType(superClass);\n        //     Clazz = ComponentView.getClass(classType.main, classType.sub, true);\n        // }\n        return ComponentView.extend(opts);\n    };\n\n    /**\n     * @param {Object} opts\n     * @param {string} [superClass]\n     */\n    echarts.extendSeriesModel = function (opts/*, superClass*/) {\n        // var Clazz = SeriesModel;\n        // if (superClass) {\n        //     superClass = 'series.' + superClass.replace('series.', '');\n        //     var classType = parseClassType(superClass);\n        //     Clazz = ComponentModel.getClass(classType.main, classType.sub, true);\n        // }\n        return SeriesModel.extend(opts);\n    };\n\n    /**\n     * @param {Object} opts\n     * @param {string} [superClass]\n     */\n    echarts.extendChartView = function (opts/*, superClass*/) {\n        // var Clazz = ChartView;\n        // if (superClass) {\n        //     superClass = superClass.replace('series.', '');\n        //     var classType = parseClassType(superClass);\n        //     Clazz = ChartView.getClass(classType.main, true);\n        // }\n        return ChartView.extend(opts);\n    };\n\n    /**\n     * ZRender need a canvas context to do measureText.\n     * But in node environment canvas may be created by node-canvas.\n     * So we need to specify how to create a canvas instead of using document.createElement('canvas')\n     *\n     * Be careful of using it in the browser.\n     *\n     * @param {Function} creator\n     * @example\n     *     var Canvas = require('canvas');\n     *     var echarts = require('echarts');\n     *     echarts.setCanvasCreator(function () {\n     *         // Small size is enough.\n     *         return new Canvas(32, 32);\n     *     });\n     */\n    echarts.setCanvasCreator = function (creator) {\n        zrUtil.createCanvas = creator;\n    };\n\n    echarts.registerVisual(PRIORITY_VISUAL_GLOBAL, __webpack_require__(/*! ./visual/seriesColor */ 181));\n    echarts.registerPreprocessor(__webpack_require__(/*! ./preprocessor/backwardCompat */ 175));\n    echarts.registerLoading('default', __webpack_require__(/*! ./loading/default */ 166));\n\n    // Default action\n    echarts.registerAction({\n        type: 'highlight',\n        event: 'highlight',\n        update: 'highlight'\n    }, zrUtil.noop);\n    echarts.registerAction({\n        type: 'downplay',\n        event: 'downplay',\n        update: 'downplay'\n    }, zrUtil.noop);\n\n\n    // --------\n    // Exports\n    // --------\n    echarts.zrender = zrender;\n\n    echarts.List = __webpack_require__(/*! ./data/List */ 13);\n    echarts.Model = __webpack_require__(/*! ./model/Model */ 9);\n\n    echarts.Axis = __webpack_require__(/*! ./coord/Axis */ 34);\n\n    echarts.graphic = __webpack_require__(/*! ./util/graphic */ 2);\n    echarts.number = __webpack_require__(/*! ./util/number */ 3);\n    echarts.format = __webpack_require__(/*! ./util/format */ 6);\n    echarts.throttle = throttle.throttle;\n    echarts.matrix = __webpack_require__(/*! zrender/lib/core/matrix */ 18);\n    echarts.vector = __webpack_require__(/*! zrender/lib/core/vector */ 4);\n    echarts.color = __webpack_require__(/*! zrender/lib/tool/color */ 21);\n\n    echarts.util = {};\n    each([\n            'map', 'each', 'filter', 'indexOf', 'inherits', 'reduce', 'filter',\n            'bind', 'curry', 'isArray', 'isString', 'isObject', 'isFunction',\n            'extend', 'defaults', 'clone', 'merge'\n        ],\n        function (name) {\n            echarts.util[name] = zrUtil[name];\n        }\n    );\n\n    echarts.helper = __webpack_require__(/*! ./helper */ 165);\n\n\n    // PRIORITY\n    echarts.PRIORITY = {\n        PROCESSOR: {\n            FILTER: PRIORITY_PROCESSOR_FILTER,\n            STATISTIC: PRIORITY_PROCESSOR_STATISTIC\n        },\n        VISUAL: {\n            LAYOUT: PRIORITY_VISUAL_LAYOUT,\n            GLOBAL: PRIORITY_VISUAL_GLOBAL,\n            CHART: PRIORITY_VISUAL_CHART,\n            COMPONENT: PRIORITY_VISUAL_COMPONENT,\n            BRUSH: PRIORITY_VISUAL_BRUSH\n        }\n    };\n\n    module.exports = echarts;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2xpYi9lY2hhcnRzLmpzP2U2ZTAiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gRW5hYmxlIERFViBtb2RlIHdoZW4gdXNpbmcgc291cmNlIGNvZGUgd2l0aG91dCBidWlsZC4gd2hpY2ggaGFzIG5vIF9fREVWX18gdmFyaWFibGVcbi8vIEluIGJ1aWxkIHByb2Nlc3MgJ3R5cGVvZiBfX0RFVl9fJyB3aWxsIGJlIHJlcGxhY2Ugd2l0aCAnYm9vbGVhbidcbi8vIFNvIHRoaXMgY29kZSB3aWxsIGJlIHJlbW92ZWQgb3IgZGlzYWJsZWQgYW55d2F5IGFmdGVyIGJ1aWx0LlxuaWYgKHR5cGVvZiBfX0RFVl9fID09PSAndW5kZWZpbmVkJykge1xuICAgIC8vIEluIGJyb3dzZXJcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgd2luZG93Ll9fREVWX18gPSB0cnVlO1xuICAgIH1cbiAgICAvLyBJbiBub2RlXG4gICAgZWxzZSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgZ2xvYmFsLl9fREVWX18gPSB0cnVlO1xuICAgIH1cbn1cblxuLyohXG4gKiBFQ2hhcnRzLCBhIGphdmFzY3JpcHQgaW50ZXJhY3RpdmUgY2hhcnQgbGlicmFyeS5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUsIEJhaWR1IEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTElDRU5TRVxuICogaHR0cHM6Ly9naXRodWIuY29tL2Vjb21mZS9lY2hhcnRzL2Jsb2IvbWFzdGVyL0xJQ0VOU0UudHh0XG4gKi9cblxuLyoqXG4gKiBAbW9kdWxlIGVjaGFydHNcbiAqL1xuXG5cbiAgICB2YXIgZW52ID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS9lbnYnKTtcblxuICAgIHZhciBHbG9iYWxNb2RlbCA9IHJlcXVpcmUoJy4vbW9kZWwvR2xvYmFsJyk7XG4gICAgdmFyIEV4dGVuc2lvbkFQSSA9IHJlcXVpcmUoJy4vRXh0ZW5zaW9uQVBJJyk7XG4gICAgdmFyIENvb3JkaW5hdGVTeXN0ZW1NYW5hZ2VyID0gcmVxdWlyZSgnLi9Db29yZGluYXRlU3lzdGVtJyk7XG4gICAgdmFyIE9wdGlvbk1hbmFnZXIgPSByZXF1aXJlKCcuL21vZGVsL09wdGlvbk1hbmFnZXInKTtcblxuICAgIHZhciBDb21wb25lbnRNb2RlbCA9IHJlcXVpcmUoJy4vbW9kZWwvQ29tcG9uZW50Jyk7XG4gICAgdmFyIFNlcmllc01vZGVsID0gcmVxdWlyZSgnLi9tb2RlbC9TZXJpZXMnKTtcblxuICAgIHZhciBDb21wb25lbnRWaWV3ID0gcmVxdWlyZSgnLi92aWV3L0NvbXBvbmVudCcpO1xuICAgIHZhciBDaGFydFZpZXcgPSByZXF1aXJlKCcuL3ZpZXcvQ2hhcnQnKTtcbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoJy4vdXRpbC9ncmFwaGljJyk7XG4gICAgdmFyIG1vZGVsVXRpbCA9IHJlcXVpcmUoJy4vdXRpbC9tb2RlbCcpO1xuICAgIHZhciB0aHJvdHRsZSA9IHJlcXVpcmUoJy4vdXRpbC90aHJvdHRsZScpO1xuXG4gICAgdmFyIHpyZW5kZXIgPSByZXF1aXJlKCd6cmVuZGVyJyk7XG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuICAgIHZhciBjb2xvclRvb2wgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi90b29sL2NvbG9yJyk7XG4gICAgdmFyIEV2ZW50ZnVsID0gcmVxdWlyZSgnenJlbmRlci9saWIvbWl4aW4vRXZlbnRmdWwnKTtcbiAgICB2YXIgdGltc29ydCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdGltc29ydCcpO1xuXG4gICAgdmFyIGVhY2ggPSB6clV0aWwuZWFjaDtcbiAgICB2YXIgcGFyc2VDbGFzc1R5cGUgPSBDb21wb25lbnRNb2RlbC5wYXJzZUNsYXNzVHlwZTtcblxuICAgIHZhciBQUklPUklUWV9QUk9DRVNTT1JfRklMVEVSID0gMTAwMDtcbiAgICB2YXIgUFJJT1JJVFlfUFJPQ0VTU09SX1NUQVRJU1RJQyA9IDUwMDA7XG5cblxuICAgIHZhciBQUklPUklUWV9WSVNVQUxfTEFZT1VUID0gMTAwMDtcbiAgICB2YXIgUFJJT1JJVFlfVklTVUFMX0dMT0JBTCA9IDIwMDA7XG4gICAgdmFyIFBSSU9SSVRZX1ZJU1VBTF9DSEFSVCA9IDMwMDA7XG4gICAgdmFyIFBSSU9SSVRZX1ZJU1VBTF9DT01QT05FTlQgPSA0MDAwO1xuICAgIC8vIEZJWE1FXG4gICAgLy8gbmVjZXNzYXJ5P1xuICAgIHZhciBQUklPUklUWV9WSVNVQUxfQlJVU0ggPSA1MDAwO1xuXG4gICAgLy8gTWFpbiBwcm9jZXNzIGhhdmUgdGhyZWUgZW50cmllczogYHNldE9wdGlvbmAsIGBkaXNwYXRjaEFjdGlvbmAgYW5kIGByZXNpemVgLFxuICAgIC8vIHdoZXJlIHRoZXkgbXVzdCBub3QgYmUgaW52b2tlZCBuZXN0ZWRseSwgZXhjZXB0IHRoZSBvbmx5IGNhc2U6IGludm9rZVxuICAgIC8vIGRpc3BhdGNoQWN0aW9uIHdpdGggdXBkYXRlTWV0aG9kIFwibm9uZVwiIGluIG1haW4gcHJvY2Vzcy5cbiAgICAvLyBUaGlzIGZsYWcgaXMgdXNlZCB0byBjYXJyeSBvdXQgdGhpcyBydWxlLlxuICAgIC8vIEFsbCBldmVudHMgd2lsbCBiZSB0cmlnZ2VyZWQgb3V0IHNpZGUgbWFpbiBwcm9jZXNzIChpLmUuIHdoZW4gIXRoaXNbSU5fTUFJTl9QUk9DRVNTXSkuXG4gICAgdmFyIElOX01BSU5fUFJPQ0VTUyA9ICdfX2ZsYWdJbk1haW5Qcm9jZXNzJztcbiAgICB2YXIgSEFTX0dSQURJRU5UX09SX1BBVFRFUk5fQkcgPSAnX19oYXNHcmFkaWVudE9yUGF0dGVybkJnJztcbiAgICB2YXIgT1BUSU9OX1VQREFURUQgPSAnX19vcHRpb25VcGRhdGVkJztcbiAgICB2YXIgQUNUSU9OX1JFRyA9IC9eW2EtekEtWjAtOV9dKyQvO1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlUmVnaXN0ZXJFdmVudFdpdGhMb3dlcmNhc2VOYW1lKG1ldGhvZCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50TmFtZSwgaGFuZGxlciwgY29udGV4dCkge1xuICAgICAgICAgICAgLy8gRXZlbnQgbmFtZSBpcyBhbGwgbG93ZXJjYXNlXG4gICAgICAgICAgICBldmVudE5hbWUgPSBldmVudE5hbWUgJiYgZXZlbnROYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBFdmVudGZ1bC5wcm90b3R5cGVbbWV0aG9kXS5jYWxsKHRoaXMsIGV2ZW50TmFtZSwgaGFuZGxlciwgY29udGV4dCk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1vZHVsZSBlY2hhcnRzfk1lc3NhZ2VDZW50ZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNZXNzYWdlQ2VudGVyKCkge1xuICAgICAgICBFdmVudGZ1bC5jYWxsKHRoaXMpO1xuICAgIH1cbiAgICBNZXNzYWdlQ2VudGVyLnByb3RvdHlwZS5vbiA9IGNyZWF0ZVJlZ2lzdGVyRXZlbnRXaXRoTG93ZXJjYXNlTmFtZSgnb24nKTtcbiAgICBNZXNzYWdlQ2VudGVyLnByb3RvdHlwZS5vZmYgPSBjcmVhdGVSZWdpc3RlckV2ZW50V2l0aExvd2VyY2FzZU5hbWUoJ29mZicpO1xuICAgIE1lc3NhZ2VDZW50ZXIucHJvdG90eXBlLm9uZSA9IGNyZWF0ZVJlZ2lzdGVyRXZlbnRXaXRoTG93ZXJjYXNlTmFtZSgnb25lJyk7XG4gICAgenJVdGlsLm1peGluKE1lc3NhZ2VDZW50ZXIsIEV2ZW50ZnVsKTtcblxuICAgIC8qKlxuICAgICAqIEBtb2R1bGUgZWNoYXJ0c35FQ2hhcnRzXG4gICAgICovXG4gICAgZnVuY3Rpb24gRUNoYXJ0cyhkb20sIHRoZW1lLCBvcHRzKSB7XG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gICAgICAgIC8vIEdldCB0aGVtZSBieSBuYW1lXG4gICAgICAgIGlmICh0eXBlb2YgdGhlbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aGVtZSA9IHRoZW1lU3RvcmFnZVt0aGVtZV07XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaWQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHcm91cCBpZFxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ncm91cDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtIVE1MRG9tRWxlbWVudH1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2RvbSA9IGRvbTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9aUmVuZGVyfVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIHpyID0gdGhpcy5fenIgPSB6cmVuZGVyLmluaXQoZG9tLCB7XG4gICAgICAgICAgICByZW5kZXJlcjogb3B0cy5yZW5kZXJlciB8fCAnY2FudmFzJyxcbiAgICAgICAgICAgIGRldmljZVBpeGVsUmF0aW86IG9wdHMuZGV2aWNlUGl4ZWxSYXRpbyxcbiAgICAgICAgICAgIHdpZHRoOiBvcHRzLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBvcHRzLmhlaWdodFxuICAgICAgICB9KTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRXhwZWN0IDYwIHBmcy5cbiAgICAgICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fdGhyb3R0bGVkWnJGbHVzaCA9IHRocm90dGxlLnRocm90dGxlKHpyVXRpbC5iaW5kKHpyLmZsdXNoLCB6ciksIDE3KTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3RoZW1lID0genJVdGlsLmNsb25lKHRoZW1lKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge0FycmF5Ljxtb2R1bGU6ZWNoYXJ0cy92aWV3L0NoYXJ0Pn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2NoYXJ0c1ZpZXdzID0gW107XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywgbW9kdWxlOmVjaGFydHMvdmlldy9DaGFydD59XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9jaGFydHNNYXAgPSB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge0FycmF5Ljxtb2R1bGU6ZWNoYXJ0cy92aWV3L0NvbXBvbmVudD59XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9jb21wb25lbnRzVmlld3MgPSBbXTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLCBtb2R1bGU6ZWNoYXJ0cy92aWV3L0NvbXBvbmVudD59XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9jb21wb25lbnRzTWFwID0ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHttb2R1bGU6ZWNoYXJ0cy9Db29yZGluYXRlU3lzdGVtfVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fY29vcmRTeXNNZ3IgPSBuZXcgQ29vcmRpbmF0ZVN5c3RlbU1hbmFnZXIoKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge21vZHVsZTplY2hhcnRzL0V4dGVuc2lvbkFQSX1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2FwaSA9IGNyZWF0ZUV4dGVuc2lvbkFQSSh0aGlzKTtcblxuICAgICAgICBFdmVudGZ1bC5jYWxsKHRoaXMpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bW9kdWxlOmVjaGFydHN+TWVzc2FnZUNlbnRlcn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX21lc3NhZ2VDZW50ZXIgPSBuZXcgTWVzc2FnZUNlbnRlcigpO1xuXG4gICAgICAgIC8vIEluaXQgbW91c2UgZXZlbnRzXG4gICAgICAgIHRoaXMuX2luaXRFdmVudHMoKTtcblxuICAgICAgICAvLyBJbiBjYXNlIHNvbWUgcGVvcGxlIHdyaXRlIGB3aW5kb3cub25yZXNpemUgPSBjaGFydC5yZXNpemVgXG4gICAgICAgIHRoaXMucmVzaXplID0genJVdGlsLmJpbmQodGhpcy5yZXNpemUsIHRoaXMpO1xuXG4gICAgICAgIC8vIENhbid0IGRpc3BhdGNoIGFjdGlvbiBkdXJpbmcgcmVuZGVyaW5nIHByb2NlZHVyZVxuICAgICAgICB0aGlzLl9wZW5kaW5nQWN0aW9ucyA9IFtdO1xuICAgICAgICAvLyBTb3J0IG9uIGRlbWFuZFxuICAgICAgICBmdW5jdGlvbiBwcmlvcml0eVNvcnRGdW5jKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBhLnByaW8gLSBiLnByaW87XG4gICAgICAgIH1cbiAgICAgICAgdGltc29ydCh2aXN1YWxGdW5jcywgcHJpb3JpdHlTb3J0RnVuYyk7XG4gICAgICAgIHRpbXNvcnQoZGF0YVByb2Nlc3NvckZ1bmNzLCBwcmlvcml0eVNvcnRGdW5jKTtcblxuICAgICAgICB6ci5hbmltYXRpb24ub24oJ2ZyYW1lJywgdGhpcy5fb25mcmFtZSwgdGhpcyk7XG5cbiAgICAgICAgLy8gRUNoYXJ0cyBpbnN0YW5jZSBjYW4gYmUgdXNlZCBhcyB2YWx1ZS5cbiAgICAgICAgenJVdGlsLnNldEFzUHJpbWl0aXZlKHRoaXMpO1xuICAgIH1cblxuICAgIHZhciBlY2hhcnRzUHJvdG8gPSBFQ2hhcnRzLnByb3RvdHlwZTtcblxuICAgIGVjaGFydHNQcm90by5fb25mcmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gTGF6eSB1cGRhdGVcbiAgICAgICAgaWYgKHRoaXNbT1BUSU9OX1VQREFURURdKSB7XG4gICAgICAgICAgICB2YXIgc2lsZW50ID0gdGhpc1tPUFRJT05fVVBEQVRFRF0uc2lsZW50O1xuXG4gICAgICAgICAgICB0aGlzW0lOX01BSU5fUFJPQ0VTU10gPSB0cnVlO1xuXG4gICAgICAgICAgICB1cGRhdGVNZXRob2RzLnByZXBhcmVBbmRVcGRhdGUuY2FsbCh0aGlzKTtcblxuICAgICAgICAgICAgdGhpc1tJTl9NQUlOX1BST0NFU1NdID0gZmFsc2U7XG5cbiAgICAgICAgICAgIHRoaXNbT1BUSU9OX1VQREFURURdID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGZsdXNoUGVuZGluZ0FjdGlvbnMuY2FsbCh0aGlzLCBzaWxlbnQpO1xuXG4gICAgICAgICAgICB0cmlnZ2VyVXBkYXRlZEV2ZW50LmNhbGwodGhpcywgc2lsZW50KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7SFRNTERvbUVsZW1lbnR9XG4gICAgICovXG4gICAgZWNoYXJ0c1Byb3RvLmdldERvbSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RvbTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXJ+WlJlbmRlcn1cbiAgICAgKi9cbiAgICBlY2hhcnRzUHJvdG8uZ2V0WnIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl96cjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVXNhZ2U6XG4gICAgICogY2hhcnQuc2V0T3B0aW9uKG9wdGlvbiwgbm90TWVyZ2UsIGxhenlVcGRhdGUpO1xuICAgICAqIGNoYXJ0LnNldE9wdGlvbihvcHRpb24sIHtcbiAgICAgKiAgICAgbm90TWVyZ2U6IC4uLixcbiAgICAgKiAgICAgbGF6eVVwZGF0ZTogLi4uLFxuICAgICAqICAgICBzaWxlbnQ6IC4uLlxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fGJvb2xlYW59IFtvcHRzXSBvcHRzIG9yIG5vdE1lcmdlLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMubm90TWVyZ2U9ZmFsc2VdXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5sYXp5VXBkYXRlPWZhbHNlXSBVc2VmdWwgd2hlbiBzZXRPcHRpb24gZnJlcXVlbnRseS5cbiAgICAgKi9cbiAgICBlY2hhcnRzUHJvdG8uc2V0T3B0aW9uID0gZnVuY3Rpb24gKG9wdGlvbiwgbm90TWVyZ2UsIGxhenlVcGRhdGUpIHtcbiAgICAgICAgaWYgKF9fREVWX18pIHtcbiAgICAgICAgICAgIHpyVXRpbC5hc3NlcnQoIXRoaXNbSU5fTUFJTl9QUk9DRVNTXSwgJ2BzZXRPcHRpb25gIHNob3VsZCBub3QgYmUgY2FsbGVkIGR1cmluZyBtYWluIHByb2Nlc3MuJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2lsZW50O1xuICAgICAgICBpZiAoenJVdGlsLmlzT2JqZWN0KG5vdE1lcmdlKSkge1xuICAgICAgICAgICAgbGF6eVVwZGF0ZSA9IG5vdE1lcmdlLmxhenlVcGRhdGU7XG4gICAgICAgICAgICBzaWxlbnQgPSBub3RNZXJnZS5zaWxlbnQ7XG4gICAgICAgICAgICBub3RNZXJnZSA9IG5vdE1lcmdlLm5vdE1lcmdlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpc1tJTl9NQUlOX1BST0NFU1NdID0gdHJ1ZTtcblxuICAgICAgICBpZiAoIXRoaXMuX21vZGVsIHx8IG5vdE1lcmdlKSB7XG4gICAgICAgICAgICB2YXIgb3B0aW9uTWFuYWdlciA9IG5ldyBPcHRpb25NYW5hZ2VyKHRoaXMuX2FwaSk7XG4gICAgICAgICAgICB2YXIgdGhlbWUgPSB0aGlzLl90aGVtZTtcbiAgICAgICAgICAgIHZhciBlY01vZGVsID0gdGhpcy5fbW9kZWwgPSBuZXcgR2xvYmFsTW9kZWwobnVsbCwgbnVsbCwgdGhlbWUsIG9wdGlvbk1hbmFnZXIpO1xuICAgICAgICAgICAgZWNNb2RlbC5pbml0KG51bGwsIG51bGwsIHRoZW1lLCBvcHRpb25NYW5hZ2VyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZJWE1FXG4gICAgICAgIC8vIHVnbHlcbiAgICAgICAgdGhpcy5fX2xhc3RPbmx5R3JhcGhpYyA9ICEhKG9wdGlvbiAmJiBvcHRpb24uZ3JhcGhpYyk7XG4gICAgICAgIHpyVXRpbC5lYWNoKG9wdGlvbiwgZnVuY3Rpb24gKG8sIG1haW5UeXBlKSB7XG4gICAgICAgICAgICBtYWluVHlwZSAhPT0gJ2dyYXBoaWMnICYmICh0aGlzLl9fbGFzdE9ubHlHcmFwaGljID0gZmFsc2UpO1xuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICB0aGlzLl9tb2RlbC5zZXRPcHRpb24ob3B0aW9uLCBvcHRpb25QcmVwcm9jZXNzb3JGdW5jcywgdGhpcy5fX2xhc3RPbmx5R3JhcGhpYyk7XG5cbiAgICAgICAgaWYgKGxhenlVcGRhdGUpIHtcbiAgICAgICAgICAgIHRoaXNbT1BUSU9OX1VQREFURURdID0ge3NpbGVudDogc2lsZW50fTtcbiAgICAgICAgICAgIHRoaXNbSU5fTUFJTl9QUk9DRVNTXSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdXBkYXRlTWV0aG9kcy5wcmVwYXJlQW5kVXBkYXRlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAvLyBFbnN1cmUgenIgcmVmcmVzaCBzeWNocm9ub3VzbHksIGFuZCB0aGVuIHBpeGVsIGluIGNhbnZhcyBjYW4gYmVcbiAgICAgICAgICAgIC8vIGZldGNoZWQgYWZ0ZXIgYHNldE9wdGlvbmAuXG4gICAgICAgICAgICB0aGlzLl96ci5mbHVzaCgpO1xuXG4gICAgICAgICAgICB0aGlzW09QVElPTl9VUERBVEVEXSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpc1tJTl9NQUlOX1BST0NFU1NdID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGZsdXNoUGVuZGluZ0FjdGlvbnMuY2FsbCh0aGlzLCBzaWxlbnQpO1xuICAgICAgICAgICAgdHJpZ2dlclVwZGF0ZWRFdmVudC5jYWxsKHRoaXMsIHNpbGVudCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQERFUFJFQ0FURURcbiAgICAgKi9cbiAgICBlY2hhcnRzUHJvdG8uc2V0VGhlbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdFQ2hhcnRzI3NldFRoZW1lKCkgaXMgREVQUkVDQVRFRCBpbiBFQ2hhcnRzIDMuMCcpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9XG4gICAgICovXG4gICAgZWNoYXJ0c1Byb3RvLmdldE1vZGVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbW9kZWw7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgKi9cbiAgICBlY2hhcnRzUHJvdG8uZ2V0T3B0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbW9kZWwgJiYgdGhpcy5fbW9kZWwuZ2V0T3B0aW9uKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBlY2hhcnRzUHJvdG8uZ2V0V2lkdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl96ci5nZXRXaWR0aCgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgZWNoYXJ0c1Byb3RvLmdldEhlaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3pyLmdldEhlaWdodCgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgZWNoYXJ0c1Byb3RvLmdldERldmljZVBpeGVsUmF0aW8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl96ci5wYWludGVyLmRwciB8fCB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgY2FudmFzIHdoaWNoIGhhcyBhbGwgdGhpbmcgcmVuZGVyZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5iYWNrZ3JvdW5kQ29sb3JdXG4gICAgICovXG4gICAgZWNoYXJ0c1Byb3RvLmdldFJlbmRlcmVkQ2FudmFzID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgICAgICAgaWYgKCFlbnYuY2FudmFzU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgICAgIG9wdHMucGl4ZWxSYXRpbyA9IG9wdHMucGl4ZWxSYXRpbyB8fCAxO1xuICAgICAgICBvcHRzLmJhY2tncm91bmRDb2xvciA9IG9wdHMuYmFja2dyb3VuZENvbG9yXG4gICAgICAgICAgICB8fCB0aGlzLl9tb2RlbC5nZXQoJ2JhY2tncm91bmRDb2xvcicpO1xuICAgICAgICB2YXIgenIgPSB0aGlzLl96cjtcbiAgICAgICAgdmFyIGxpc3QgPSB6ci5zdG9yYWdlLmdldERpc3BsYXlMaXN0KCk7XG4gICAgICAgIC8vIFN0b3AgYW5pbWF0aW9uc1xuICAgICAgICB6clV0aWwuZWFjaChsaXN0LCBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIGVsLnN0b3BBbmltYXRpb24odHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4genIucGFpbnRlci5nZXRSZW5kZXJlZENhbnZhcyhvcHRzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy50eXBlPSdwbmcnXVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5waXhlbFJhdGlvPTFdXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmJhY2tncm91bmRDb2xvcl1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuZXhjbHVkZUNvbXBvbmVudHNdXG4gICAgICovXG4gICAgZWNoYXJ0c1Byb3RvLmdldERhdGFVUkwgPSBmdW5jdGlvbiAob3B0cykge1xuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICAgICAgdmFyIGV4Y2x1ZGVDb21wb25lbnRzID0gb3B0cy5leGNsdWRlQ29tcG9uZW50cztcbiAgICAgICAgdmFyIGVjTW9kZWwgPSB0aGlzLl9tb2RlbDtcbiAgICAgICAgdmFyIGV4Y2x1ZGVzQ29tcG9uZW50Vmlld3MgPSBbXTtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIGVhY2goZXhjbHVkZUNvbXBvbmVudHMsIGZ1bmN0aW9uIChjb21wb25lbnRUeXBlKSB7XG4gICAgICAgICAgICBlY01vZGVsLmVhY2hDb21wb25lbnQoe1xuICAgICAgICAgICAgICAgIG1haW5UeXBlOiBjb21wb25lbnRUeXBlXG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIHZpZXcgPSBzZWxmLl9jb21wb25lbnRzTWFwW2NvbXBvbmVudC5fX3ZpZXdJZF07XG4gICAgICAgICAgICAgICAgaWYgKCF2aWV3Lmdyb3VwLmlnbm9yZSkge1xuICAgICAgICAgICAgICAgICAgICBleGNsdWRlc0NvbXBvbmVudFZpZXdzLnB1c2godmlldyk7XG4gICAgICAgICAgICAgICAgICAgIHZpZXcuZ3JvdXAuaWdub3JlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIHVybCA9IHRoaXMuZ2V0UmVuZGVyZWRDYW52YXMob3B0cykudG9EYXRhVVJMKFxuICAgICAgICAgICAgJ2ltYWdlLycgKyAob3B0cyAmJiBvcHRzLnR5cGUgfHwgJ3BuZycpXG4gICAgICAgICk7XG5cbiAgICAgICAgZWFjaChleGNsdWRlc0NvbXBvbmVudFZpZXdzLCBmdW5jdGlvbiAodmlldykge1xuICAgICAgICAgICAgdmlldy5ncm91cC5pZ25vcmUgPSBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB1cmw7XG4gICAgfTtcblxuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLnR5cGU9J3BuZyddXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLnBpeGVsUmF0aW89MV1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuYmFja2dyb3VuZENvbG9yXVxuICAgICAqL1xuICAgIGVjaGFydHNQcm90by5nZXRDb25uZWN0ZWREYXRhVVJMID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgICAgICAgaWYgKCFlbnYuY2FudmFzU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGdyb3VwSWQgPSB0aGlzLmdyb3VwO1xuICAgICAgICB2YXIgbWF0aE1pbiA9IE1hdGgubWluO1xuICAgICAgICB2YXIgbWF0aE1heCA9IE1hdGgubWF4O1xuICAgICAgICB2YXIgTUFYX05VTUJFUiA9IEluZmluaXR5O1xuICAgICAgICBpZiAoY29ubmVjdGVkR3JvdXBzW2dyb3VwSWRdKSB7XG4gICAgICAgICAgICB2YXIgbGVmdCA9IE1BWF9OVU1CRVI7XG4gICAgICAgICAgICB2YXIgdG9wID0gTUFYX05VTUJFUjtcbiAgICAgICAgICAgIHZhciByaWdodCA9IC1NQVhfTlVNQkVSO1xuICAgICAgICAgICAgdmFyIGJvdHRvbSA9IC1NQVhfTlVNQkVSO1xuICAgICAgICAgICAgdmFyIGNhbnZhc0xpc3QgPSBbXTtcbiAgICAgICAgICAgIHZhciBkcHIgPSAob3B0cyAmJiBvcHRzLnBpeGVsUmF0aW8pIHx8IDE7XG5cbiAgICAgICAgICAgIHpyVXRpbC5lYWNoKGluc3RhbmNlcywgZnVuY3Rpb24gKGNoYXJ0LCBpZCkge1xuICAgICAgICAgICAgICAgIGlmIChjaGFydC5ncm91cCA9PT0gZ3JvdXBJZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2FudmFzID0gY2hhcnQuZ2V0UmVuZGVyZWRDYW52YXMoXG4gICAgICAgICAgICAgICAgICAgICAgICB6clV0aWwuY2xvbmUob3B0cylcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJvdW5kaW5nUmVjdCA9IGNoYXJ0LmdldERvbSgpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbWF0aE1pbihib3VuZGluZ1JlY3QubGVmdCwgbGVmdCk7XG4gICAgICAgICAgICAgICAgICAgIHRvcCA9IG1hdGhNaW4oYm91bmRpbmdSZWN0LnRvcCwgdG9wKTtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSBtYXRoTWF4KGJvdW5kaW5nUmVjdC5yaWdodCwgcmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBib3R0b20gPSBtYXRoTWF4KGJvdW5kaW5nUmVjdC5ib3R0b20sIGJvdHRvbSk7XG4gICAgICAgICAgICAgICAgICAgIGNhbnZhc0xpc3QucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb206IGNhbnZhcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IGJvdW5kaW5nUmVjdC5sZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiBib3VuZGluZ1JlY3QudG9wXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBsZWZ0ICo9IGRwcjtcbiAgICAgICAgICAgIHRvcCAqPSBkcHI7XG4gICAgICAgICAgICByaWdodCAqPSBkcHI7XG4gICAgICAgICAgICBib3R0b20gKj0gZHByO1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gcmlnaHQgLSBsZWZ0O1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IGJvdHRvbSAtIHRvcDtcbiAgICAgICAgICAgIHZhciB0YXJnZXRDYW52YXMgPSB6clV0aWwuY3JlYXRlQ2FudmFzKCk7XG4gICAgICAgICAgICB0YXJnZXRDYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgIHRhcmdldENhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICB2YXIgenIgPSB6cmVuZGVyLmluaXQodGFyZ2V0Q2FudmFzKTtcblxuICAgICAgICAgICAgZWFjaChjYW52YXNMaXN0LCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgIHZhciBpbWcgPSBuZXcgZ3JhcGhpYy5JbWFnZSh7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBpdGVtLmxlZnQgKiBkcHIgLSBsZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogaXRlbS50b3AgKiBkcHIgLSB0b3AsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZTogaXRlbS5kb21cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHpyLmFkZChpbWcpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB6ci5yZWZyZXNoSW1tZWRpYXRlbHkoKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRhcmdldENhbnZhcy50b0RhdGFVUkwoJ2ltYWdlLycgKyAob3B0cyAmJiBvcHRzLnR5cGUgfHwgJ3BuZycpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldERhdGFVUkwob3B0cyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydCBmcm9tIGxvZ2ljYWwgY29vcmRpbmF0ZSBzeXN0ZW0gdG8gcGl4ZWwgY29vcmRpbmF0ZSBzeXN0ZW0uXG4gICAgICogU2VlIENvb3JkaW5hdGVTeXN0ZW0jY29udmVydFRvUGl4ZWwuXG4gICAgICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0fSBmaW5kZXJcbiAgICAgKiAgICAgICAgSWYgc3RyaW5nLCBlLmcuLCAnZ2VvJywgbWVhbnMge2dlb0luZGV4OiAwfS5cbiAgICAgKiAgICAgICAgSWYgT2JqZWN0LCBjb3VsZCBjb250YWluIHNvbWUgb2YgdGhlc2UgcHJvcGVydGllcyBiZWxvdzpcbiAgICAgKiAgICAgICAge1xuICAgICAqICAgICAgICAgICAgc2VyaWVzSW5kZXggLyBzZXJpZXNJZCAvIHNlcmllc05hbWUsXG4gICAgICogICAgICAgICAgICBnZW9JbmRleCAvIGdlb0lkLCBnZW9OYW1lLFxuICAgICAqICAgICAgICAgICAgYm1hcEluZGV4IC8gYm1hcElkIC8gYm1hcE5hbWUsXG4gICAgICogICAgICAgICAgICB4QXhpc0luZGV4IC8geEF4aXNJZCAvIHhBeGlzTmFtZSxcbiAgICAgKiAgICAgICAgICAgIHlBeGlzSW5kZXggLyB5QXhpc0lkIC8geUF4aXNOYW1lLFxuICAgICAqICAgICAgICAgICAgZ3JpZEluZGV4IC8gZ3JpZElkIC8gZ3JpZE5hbWUsXG4gICAgICogICAgICAgICAgICAuLi4gKGNhbiBiZSBleHRlbmRlZClcbiAgICAgKiAgICAgICAgfVxuICAgICAqIEBwYXJhbSB7QXJyYXl8bnVtYmVyfSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge0FycmF5fG51bWJlcn0gcmVzdWx0XG4gICAgICovXG4gICAgZWNoYXJ0c1Byb3RvLmNvbnZlcnRUb1BpeGVsID0genJVdGlsLmN1cnJ5KGRvQ29udmVydFBpeGVsLCAnY29udmVydFRvUGl4ZWwnKTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgZnJvbSBwaXhlbCBjb29yZGluYXRlIHN5c3RlbSB0byBsb2dpY2FsIGNvb3JkaW5hdGUgc3lzdGVtLlxuICAgICAqIFNlZSBDb29yZGluYXRlU3lzdGVtI2NvbnZlcnRGcm9tUGl4ZWwuXG4gICAgICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0fSBmaW5kZXJcbiAgICAgKiAgICAgICAgSWYgc3RyaW5nLCBlLmcuLCAnZ2VvJywgbWVhbnMge2dlb0luZGV4OiAwfS5cbiAgICAgKiAgICAgICAgSWYgT2JqZWN0LCBjb3VsZCBjb250YWluIHNvbWUgb2YgdGhlc2UgcHJvcGVydGllcyBiZWxvdzpcbiAgICAgKiAgICAgICAge1xuICAgICAqICAgICAgICAgICAgc2VyaWVzSW5kZXggLyBzZXJpZXNJZCAvIHNlcmllc05hbWUsXG4gICAgICogICAgICAgICAgICBnZW9JbmRleCAvIGdlb0lkIC8gZ2VvTmFtZSxcbiAgICAgKiAgICAgICAgICAgIGJtYXBJbmRleCAvIGJtYXBJZCAvIGJtYXBOYW1lLFxuICAgICAqICAgICAgICAgICAgeEF4aXNJbmRleCAvIHhBeGlzSWQgLyB4QXhpc05hbWUsXG4gICAgICogICAgICAgICAgICB5QXhpc0luZGV4IC8geUF4aXNJZCAvIHlBeGlzTmFtZVxuICAgICAqICAgICAgICAgICAgZ3JpZEluZGV4IC8gZ3JpZElkIC8gZ3JpZE5hbWUsXG4gICAgICogICAgICAgICAgICAuLi4gKGNhbiBiZSBleHRlbmRlZClcbiAgICAgKiAgICAgICAgfVxuICAgICAqIEBwYXJhbSB7QXJyYXl8bnVtYmVyfSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge0FycmF5fG51bWJlcn0gcmVzdWx0XG4gICAgICovXG4gICAgZWNoYXJ0c1Byb3RvLmNvbnZlcnRGcm9tUGl4ZWwgPSB6clV0aWwuY3VycnkoZG9Db252ZXJ0UGl4ZWwsICdjb252ZXJ0RnJvbVBpeGVsJyk7XG5cbiAgICBmdW5jdGlvbiBkb0NvbnZlcnRQaXhlbChtZXRob2ROYW1lLCBmaW5kZXIsIHZhbHVlKSB7XG4gICAgICAgIHZhciBlY01vZGVsID0gdGhpcy5fbW9kZWw7XG4gICAgICAgIHZhciBjb29yZFN5c0xpc3QgPSB0aGlzLl9jb29yZFN5c01nci5nZXRDb29yZGluYXRlU3lzdGVtcygpO1xuICAgICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICAgIGZpbmRlciA9IG1vZGVsVXRpbC5wYXJzZUZpbmRlcihlY01vZGVsLCBmaW5kZXIpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29vcmRTeXNMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY29vcmRTeXMgPSBjb29yZFN5c0xpc3RbaV07XG4gICAgICAgICAgICBpZiAoY29vcmRTeXNbbWV0aG9kTmFtZV1cbiAgICAgICAgICAgICAgICAmJiAocmVzdWx0ID0gY29vcmRTeXNbbWV0aG9kTmFtZV0oZWNNb2RlbCwgZmluZGVyLCB2YWx1ZSkpICE9IG51bGxcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX19ERVZfXykge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAgICdObyBjb29yZGluYXRlIHN5c3RlbSB0aGF0IHN1cHBvcnRzICcgKyBtZXRob2ROYW1lICsgJyBmb3VuZCBieSB0aGUgZ2l2ZW4gZmluZGVyLidcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJcyB0aGUgc3BlY2lmaWVkIGNvb3JkaW5hdGUgc3lzdGVtcyBvciBjb21wb25lbnRzIGNvbnRhaW4gdGhlIGdpdmVuIHBpeGVsIHBvaW50LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0gZmluZGVyXG4gICAgICogICAgICAgIElmIHN0cmluZywgZS5nLiwgJ2dlbycsIG1lYW5zIHtnZW9JbmRleDogMH0uXG4gICAgICogICAgICAgIElmIE9iamVjdCwgY291bGQgY29udGFpbiBzb21lIG9mIHRoZXNlIHByb3BlcnRpZXMgYmVsb3c6XG4gICAgICogICAgICAgIHtcbiAgICAgKiAgICAgICAgICAgIHNlcmllc0luZGV4IC8gc2VyaWVzSWQgLyBzZXJpZXNOYW1lLFxuICAgICAqICAgICAgICAgICAgZ2VvSW5kZXggLyBnZW9JZCAvIGdlb05hbWUsXG4gICAgICogICAgICAgICAgICBibWFwSW5kZXggLyBibWFwSWQgLyBibWFwTmFtZSxcbiAgICAgKiAgICAgICAgICAgIHhBeGlzSW5kZXggLyB4QXhpc0lkIC8geEF4aXNOYW1lLFxuICAgICAqICAgICAgICAgICAgeUF4aXNJbmRleCAvIHlBeGlzSWQgLyB5QXhpc05hbWUsXG4gICAgICogICAgICAgICAgICBncmlkSW5kZXggLyBncmlkSWQgLyBncmlkTmFtZSxcbiAgICAgKiAgICAgICAgICAgIC4uLiAoY2FuIGJlIGV4dGVuZGVkKVxuICAgICAqICAgICAgICB9XG4gICAgICogQHBhcmFtIHtBcnJheXxudW1iZXJ9IHZhbHVlXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gcmVzdWx0XG4gICAgICovXG4gICAgZWNoYXJ0c1Byb3RvLmNvbnRhaW5QaXhlbCA9IGZ1bmN0aW9uIChmaW5kZXIsIHZhbHVlKSB7XG4gICAgICAgIHZhciBlY01vZGVsID0gdGhpcy5fbW9kZWw7XG4gICAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgICAgZmluZGVyID0gbW9kZWxVdGlsLnBhcnNlRmluZGVyKGVjTW9kZWwsIGZpbmRlcik7XG5cbiAgICAgICAgenJVdGlsLmVhY2goZmluZGVyLCBmdW5jdGlvbiAobW9kZWxzLCBrZXkpIHtcbiAgICAgICAgICAgIGtleS5pbmRleE9mKCdNb2RlbHMnKSA+PSAwICYmIHpyVXRpbC5lYWNoKG1vZGVscywgZnVuY3Rpb24gKG1vZGVsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvb3JkU3lzID0gbW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcbiAgICAgICAgICAgICAgICBpZiAoY29vcmRTeXMgJiYgY29vcmRTeXMuY29udGFpblBvaW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCB8PSAhIWNvb3JkU3lzLmNvbnRhaW5Qb2ludCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGtleSA9PT0gJ3Nlcmllc01vZGVscycpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZpZXcgPSB0aGlzLl9jaGFydHNNYXBbbW9kZWwuX192aWV3SWRdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmlldyAmJiB2aWV3LmNvbnRhaW5Qb2ludCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0IHw9IHZpZXcuY29udGFpblBvaW50KHZhbHVlLCBtb2RlbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX19ERVZfXykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihrZXkgKyAnOiAnICsgKHZpZXdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAnVGhlIGZvdW5kIGNvbXBvbmVudCBkbyBub3Qgc3VwcG9ydCBjb250YWluUG9pbnQuJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICdObyB2aWV3IG1hcHBpbmcgdG8gdGhlIGZvdW5kIGNvbXBvbmVudC4nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oa2V5ICsgJzogY29udGFpblBvaW50IGlzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICByZXR1cm4gISFyZXN1bHQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB2aXN1YWwgZnJvbSBzZXJpZXMgb3IgZGF0YS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IGZpbmRlclxuICAgICAqICAgICAgICBJZiBzdHJpbmcsIGUuZy4sICdzZXJpZXMnLCBtZWFucyB7c2VyaWVzSW5kZXg6IDB9LlxuICAgICAqICAgICAgICBJZiBPYmplY3QsIGNvdWxkIGNvbnRhaW4gc29tZSBvZiB0aGVzZSBwcm9wZXJ0aWVzIGJlbG93OlxuICAgICAqICAgICAgICB7XG4gICAgICogICAgICAgICAgICBzZXJpZXNJbmRleCAvIHNlcmllc0lkIC8gc2VyaWVzTmFtZSxcbiAgICAgKiAgICAgICAgICAgIGRhdGFJbmRleCAvIGRhdGFJbmRleEluc2lkZVxuICAgICAqICAgICAgICB9XG4gICAgICogICAgICAgIElmIGRhdGFJbmRleCBpcyBub3Qgc3BlY2lmaWVkLCBzZXJpZXMgdmlzdWFsIHdpbGwgYmUgZmV0Y2hlZCxcbiAgICAgKiAgICAgICAgYnV0IG5vdCBkYXRhIGl0ZW0gdmlzdWFsLlxuICAgICAqICAgICAgICBJZiBhbGwgb2Ygc2VyaWVzSW5kZXgsIHNlcmllc0lkLCBzZXJpZXNOYW1lIGFyZSBub3Qgc3BlY2lmaWVkLFxuICAgICAqICAgICAgICB2aXN1YWwgd2lsbCBiZSBmZXRjaGVkIGZyb20gZmlyc3Qgc2VyaWVzLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2aXN1YWxUeXBlICdjb2xvcicsICdzeW1ib2wnLCAnc3ltYm9sU2l6ZSdcbiAgICAgKi9cbiAgICBlY2hhcnRzUHJvdG8uZ2V0VmlzdWFsID0gZnVuY3Rpb24gKGZpbmRlciwgdmlzdWFsVHlwZSkge1xuICAgICAgICB2YXIgZWNNb2RlbCA9IHRoaXMuX21vZGVsO1xuXG4gICAgICAgIGZpbmRlciA9IG1vZGVsVXRpbC5wYXJzZUZpbmRlcihlY01vZGVsLCBmaW5kZXIsIHtkZWZhdWx0TWFpblR5cGU6ICdzZXJpZXMnfSk7XG5cbiAgICAgICAgdmFyIHNlcmllc01vZGVsID0gZmluZGVyLnNlcmllc01vZGVsO1xuXG4gICAgICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgICAgICBpZiAoIXNlcmllc01vZGVsKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdUaGVyZSBpcyBubyBzcGVjaWZpZWQgc2VpcmVzIG1vZGVsJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcblxuICAgICAgICB2YXIgZGF0YUluZGV4SW5zaWRlID0gZmluZGVyLmhhc093blByb3BlcnR5KCdkYXRhSW5kZXhJbnNpZGUnKVxuICAgICAgICAgICAgPyBmaW5kZXIuZGF0YUluZGV4SW5zaWRlXG4gICAgICAgICAgICA6IGZpbmRlci5oYXNPd25Qcm9wZXJ0eSgnZGF0YUluZGV4JylcbiAgICAgICAgICAgID8gZGF0YS5pbmRleE9mUmF3SW5kZXgoZmluZGVyLmRhdGFJbmRleClcbiAgICAgICAgICAgIDogbnVsbDtcblxuICAgICAgICByZXR1cm4gZGF0YUluZGV4SW5zaWRlICE9IG51bGxcbiAgICAgICAgICAgID8gZGF0YS5nZXRJdGVtVmlzdWFsKGRhdGFJbmRleEluc2lkZSwgdmlzdWFsVHlwZSlcbiAgICAgICAgICAgIDogZGF0YS5nZXRWaXN1YWwodmlzdWFsVHlwZSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB2aWV3IG9mIGNvcnJlc3BvbmRpbmcgY29tcG9uZW50IG1vZGVsXG4gICAgICogQHBhcmFtICB7bW9kdWxlOmVjaGFydHMvbW9kZWwvQ29tcG9uZW50fSBjb21wb25lbnRNb2RlbFxuICAgICAqIEByZXR1cm4ge21vZHVsZTplY2hhcnRzL3ZpZXcvQ29tcG9uZW50fVxuICAgICAqL1xuICAgIGVjaGFydHNQcm90by5nZXRWaWV3T2ZDb21wb25lbnRNb2RlbCA9IGZ1bmN0aW9uIChjb21wb25lbnRNb2RlbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29tcG9uZW50c01hcFtjb21wb25lbnRNb2RlbC5fX3ZpZXdJZF07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB2aWV3IG9mIGNvcnJlc3BvbmRpbmcgc2VyaWVzIG1vZGVsXG4gICAgICogQHBhcmFtICB7bW9kdWxlOmVjaGFydHMvbW9kZWwvU2VyaWVzfSBzZXJpZXNNb2RlbFxuICAgICAqIEByZXR1cm4ge21vZHVsZTplY2hhcnRzL3ZpZXcvQ2hhcnR9XG4gICAgICovXG4gICAgZWNoYXJ0c1Byb3RvLmdldFZpZXdPZlNlcmllc01vZGVsID0gZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGFydHNNYXBbc2VyaWVzTW9kZWwuX192aWV3SWRdO1xuICAgIH07XG5cblxuICAgIHZhciB1cGRhdGVNZXRob2RzID0ge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcGF5bG9hZFxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdXBkYXRlOiBmdW5jdGlvbiAocGF5bG9hZCkge1xuICAgICAgICAgICAgLy8gY29uc29sZS5wcm9maWxlICYmIGNvbnNvbGUucHJvZmlsZSgndXBkYXRlJyk7XG5cbiAgICAgICAgICAgIHZhciBlY01vZGVsID0gdGhpcy5fbW9kZWw7XG4gICAgICAgICAgICB2YXIgYXBpID0gdGhpcy5fYXBpO1xuICAgICAgICAgICAgdmFyIGNvb3JkU3lzTWdyID0gdGhpcy5fY29vcmRTeXNNZ3I7XG4gICAgICAgICAgICB2YXIgenIgPSB0aGlzLl96cjtcbiAgICAgICAgICAgIC8vIHVwZGF0ZSBiZWZvcmUgc2V0T3B0aW9uXG4gICAgICAgICAgICBpZiAoIWVjTW9kZWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZpeG1lIEZpcnN0IHRpbWUgdXBkYXRlID9cbiAgICAgICAgICAgIGVjTW9kZWwucmVzdG9yZURhdGEoKTtcblxuICAgICAgICAgICAgLy8gVE9ET1xuICAgICAgICAgICAgLy8gU2F2ZSB0b3RhbCBlY01vZGVsIGhlcmUgZm9yIHVuZG8vcmVkbyAoYWZ0ZXIgcmVzdG9yaW5nIGRhdGEgYW5kIGJlZm9yZSBwcm9jZXNzaW5nIGRhdGEpLlxuICAgICAgICAgICAgLy8gVW5kbyAocmVzdG9yYXRpb24gb2YgdG90YWwgZWNNb2RlbCkgY2FuIGJlIGNhcnJpZWQgb3V0IGluICdhY3Rpb24nIG9yIG91dHNpZGUgQVBJIGNhbGwuXG5cbiAgICAgICAgICAgIC8vIENyZWF0ZSBuZXcgY29vcmRpbmF0ZSBzeXN0ZW0gZWFjaCB1cGRhdGVcbiAgICAgICAgICAgIC8vIEluIExpbmVWaWV3IG1heSBzYXZlIHRoZSBvbGQgY29vcmRpbmF0ZSBzeXN0ZW0gYW5kIHVzZSBpdCB0byBnZXQgdGhlIG9yaWduYWwgcG9pbnRcbiAgICAgICAgICAgIGNvb3JkU3lzTWdyLmNyZWF0ZSh0aGlzLl9tb2RlbCwgdGhpcy5fYXBpKTtcblxuICAgICAgICAgICAgcHJvY2Vzc0RhdGEuY2FsbCh0aGlzLCBlY01vZGVsLCBhcGkpO1xuXG4gICAgICAgICAgICBzdGFja1Nlcmllc0RhdGEuY2FsbCh0aGlzLCBlY01vZGVsKTtcblxuICAgICAgICAgICAgY29vcmRTeXNNZ3IudXBkYXRlKGVjTW9kZWwsIGFwaSk7XG5cbiAgICAgICAgICAgIGRvVmlzdWFsRW5jb2RpbmcuY2FsbCh0aGlzLCBlY01vZGVsLCBwYXlsb2FkKTtcblxuICAgICAgICAgICAgZG9SZW5kZXIuY2FsbCh0aGlzLCBlY01vZGVsLCBwYXlsb2FkKTtcblxuICAgICAgICAgICAgLy8gU2V0IGJhY2tncm91bmRcbiAgICAgICAgICAgIHZhciBiYWNrZ3JvdW5kQ29sb3IgPSBlY01vZGVsLmdldCgnYmFja2dyb3VuZENvbG9yJykgfHwgJ3RyYW5zcGFyZW50JztcblxuICAgICAgICAgICAgdmFyIHBhaW50ZXIgPSB6ci5wYWludGVyO1xuICAgICAgICAgICAgLy8gVE9ETyBhbGwgdXNlIGNsZWFyQ29sb3IgP1xuICAgICAgICAgICAgaWYgKHBhaW50ZXIuaXNTaW5nbGVDYW52YXMgJiYgcGFpbnRlci5pc1NpbmdsZUNhbnZhcygpKSB7XG4gICAgICAgICAgICAgICAgenIuY29uZmlnTGF5ZXIoMCwge1xuICAgICAgICAgICAgICAgICAgICBjbGVhckNvbG9yOiBiYWNrZ3JvdW5kQ29sb3JcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEluIElFOFxuICAgICAgICAgICAgICAgIGlmICghZW52LmNhbnZhc1N1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29sb3JBcnIgPSBjb2xvclRvb2wucGFyc2UoYmFja2dyb3VuZENvbG9yKTtcbiAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yID0gY29sb3JUb29sLnN0cmluZ2lmeShjb2xvckFyciwgJ3JnYicpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29sb3JBcnJbM10gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvciA9ICd0cmFuc3BhcmVudCc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGJhY2tncm91bmRDb2xvci5jb2xvclN0b3BzIHx8IGJhY2tncm91bmRDb2xvci5pbWFnZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBHcmFkaWVudCBiYWNrZ3JvdW5kXG4gICAgICAgICAgICAgICAgICAgIC8vIEZJWE1FIEZpeGVkIGxheWVy77yfXG4gICAgICAgICAgICAgICAgICAgIHpyLmNvbmZpZ0xheWVyKDAsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyQ29sb3I6IGJhY2tncm91bmRDb2xvclxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tIQVNfR1JBRElFTlRfT1JfUEFUVEVSTl9CR10gPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RvbS5zdHlsZS5iYWNrZ3JvdW5kID0gJ3RyYW5zcGFyZW50JztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzW0hBU19HUkFESUVOVF9PUl9QQVRURVJOX0JHXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgenIuY29uZmlnTGF5ZXIoMCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyQ29sb3I6IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbSEFTX0dSQURJRU5UX09SX1BBVFRFUk5fQkddID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZG9tLnN0eWxlLmJhY2tncm91bmQgPSBiYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlYWNoKHBvc3RVcGRhdGVGdW5jcywgZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICAgICAgICAgICAgICBmdW5jKGVjTW9kZWwsIGFwaSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gY29uc29sZS5wcm9maWxlICYmIGNvbnNvbGUucHJvZmlsZUVuZCgndXBkYXRlJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXlsb2FkXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB1cGRhdGVWaWV3OiBmdW5jdGlvbiAocGF5bG9hZCkge1xuICAgICAgICAgICAgdmFyIGVjTW9kZWwgPSB0aGlzLl9tb2RlbDtcblxuICAgICAgICAgICAgLy8gdXBkYXRlIGJlZm9yZSBzZXRPcHRpb25cbiAgICAgICAgICAgIGlmICghZWNNb2RlbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZWNNb2RlbC5lYWNoU2VyaWVzKGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgICAgICAgICAgICAgIHNlcmllc01vZGVsLmdldERhdGEoKS5jbGVhckFsbFZpc3VhbCgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGRvVmlzdWFsRW5jb2RpbmcuY2FsbCh0aGlzLCBlY01vZGVsLCBwYXlsb2FkKTtcblxuICAgICAgICAgICAgaW52b2tlVXBkYXRlTWV0aG9kLmNhbGwodGhpcywgJ3VwZGF0ZVZpZXcnLCBlY01vZGVsLCBwYXlsb2FkKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHBheWxvYWRcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHVwZGF0ZVZpc3VhbDogZnVuY3Rpb24gKHBheWxvYWQpIHtcbiAgICAgICAgICAgIHZhciBlY01vZGVsID0gdGhpcy5fbW9kZWw7XG5cbiAgICAgICAgICAgIC8vIHVwZGF0ZSBiZWZvcmUgc2V0T3B0aW9uXG4gICAgICAgICAgICBpZiAoIWVjTW9kZWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVjTW9kZWwuZWFjaFNlcmllcyhmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICAgICAgICAgICAgICBzZXJpZXNNb2RlbC5nZXREYXRhKCkuY2xlYXJBbGxWaXN1YWwoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBkb1Zpc3VhbEVuY29kaW5nLmNhbGwodGhpcywgZWNNb2RlbCwgcGF5bG9hZCwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIGludm9rZVVwZGF0ZU1ldGhvZC5jYWxsKHRoaXMsICd1cGRhdGVWaXN1YWwnLCBlY01vZGVsLCBwYXlsb2FkKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHBheWxvYWRcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHVwZGF0ZUxheW91dDogZnVuY3Rpb24gKHBheWxvYWQpIHtcbiAgICAgICAgICAgIHZhciBlY01vZGVsID0gdGhpcy5fbW9kZWw7XG5cbiAgICAgICAgICAgIC8vIHVwZGF0ZSBiZWZvcmUgc2V0T3B0aW9uXG4gICAgICAgICAgICBpZiAoIWVjTW9kZWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRvTGF5b3V0LmNhbGwodGhpcywgZWNNb2RlbCwgcGF5bG9hZCk7XG5cbiAgICAgICAgICAgIGludm9rZVVwZGF0ZU1ldGhvZC5jYWxsKHRoaXMsICd1cGRhdGVMYXlvdXQnLCBlY01vZGVsLCBwYXlsb2FkKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHBheWxvYWRcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHByZXBhcmVBbmRVcGRhdGU6IGZ1bmN0aW9uIChwYXlsb2FkKSB7XG4gICAgICAgICAgICB2YXIgZWNNb2RlbCA9IHRoaXMuX21vZGVsO1xuXG4gICAgICAgICAgICBwcmVwYXJlVmlldy5jYWxsKHRoaXMsICdjb21wb25lbnQnLCBlY01vZGVsKTtcblxuICAgICAgICAgICAgcHJlcGFyZVZpZXcuY2FsbCh0aGlzLCAnY2hhcnQnLCBlY01vZGVsKTtcblxuICAgICAgICAgICAgLy8gRklYTUVcbiAgICAgICAgICAgIC8vIHVnbHlcbiAgICAgICAgICAgIGlmICh0aGlzLl9fbGFzdE9ubHlHcmFwaGljKSB7XG4gICAgICAgICAgICAgICAgZWFjaCh0aGlzLl9jb21wb25lbnRzVmlld3MsIGZ1bmN0aW9uIChjb21wb25lbnRWaWV3KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb21wb25lbnRNb2RlbCA9IGNvbXBvbmVudFZpZXcuX19tb2RlbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBvbmVudE1vZGVsICYmIGNvbXBvbmVudE1vZGVsLm1haW5UeXBlID09PSAnZ3JhcGhpYycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudFZpZXcucmVuZGVyKGNvbXBvbmVudE1vZGVsLCBlY01vZGVsLCB0aGlzLl9hcGksIHBheWxvYWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlWihjb21wb25lbnRNb2RlbCwgY29tcG9uZW50Vmlldyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9fbGFzdE9ubHlHcmFwaGljID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVNZXRob2RzLnVwZGF0ZS5jYWxsKHRoaXMsIHBheWxvYWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZnVuY3Rpb24gdXBkYXRlRGlyZWN0bHkoZWNJbnMsIG1ldGhvZCwgcGF5bG9hZCwgbWFpblR5cGUsIHN1YlR5cGUpIHtcbiAgICAgICAgdmFyIGVjTW9kZWwgPSBlY0lucy5fbW9kZWw7XG5cbiAgICAgICAgLy8gYnJvYWRjYXN0XG4gICAgICAgIGlmICghbWFpblR5cGUpIHtcbiAgICAgICAgICAgIGVhY2goZWNJbnMuX2NvbXBvbmVudHNWaWV3cy5jb25jYXQoZWNJbnMuX2NoYXJ0c1ZpZXdzKSwgY2FsbFZpZXcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHF1ZXJ5ID0ge307XG4gICAgICAgIHF1ZXJ5W21haW5UeXBlICsgJ0lkJ10gPSBwYXlsb2FkW21haW5UeXBlICsgJ0lkJ107XG4gICAgICAgIHF1ZXJ5W21haW5UeXBlICsgJ0luZGV4J10gPSBwYXlsb2FkW21haW5UeXBlICsgJ0luZGV4J107XG4gICAgICAgIHF1ZXJ5W21haW5UeXBlICsgJ05hbWUnXSA9IHBheWxvYWRbbWFpblR5cGUgKyAnTmFtZSddO1xuXG4gICAgICAgIHZhciBjb25kaXRpb24gPSB7bWFpblR5cGU6IG1haW5UeXBlLCBxdWVyeTogcXVlcnl9O1xuICAgICAgICBzdWJUeXBlICYmIChjb25kaXRpb24uc3ViVHlwZSA9IHN1YlR5cGUpOyAvLyBzdWJUeXBlIG1heSBiZSAnJyBieSBwYXJzZUNsYXNzVHlwZTtcblxuICAgICAgICAvLyBJZiBkaXNwYXRjaEFjdGlvbiBiZWZvcmUgc2V0T3B0aW9uLCBkbyBub3RoaW5nLlxuICAgICAgICBlY01vZGVsICYmIGVjTW9kZWwuZWFjaENvbXBvbmVudChjb25kaXRpb24sIGZ1bmN0aW9uIChtb2RlbCwgaW5kZXgpIHtcbiAgICAgICAgICAgIGNhbGxWaWV3KGVjSW5zW1xuICAgICAgICAgICAgICAgIG1haW5UeXBlID09PSAnc2VyaWVzJyA/ICdfY2hhcnRzTWFwJyA6ICdfY29tcG9uZW50c01hcCdcbiAgICAgICAgICAgIF1bbW9kZWwuX192aWV3SWRdKTtcbiAgICAgICAgfSwgZWNJbnMpO1xuXG4gICAgICAgIGZ1bmN0aW9uIGNhbGxWaWV3KHZpZXcpIHtcbiAgICAgICAgICAgIHZpZXcgJiYgdmlldy5fX2FsaXZlICYmIHZpZXdbbWV0aG9kXSAmJiB2aWV3W21ldGhvZF0oXG4gICAgICAgICAgICAgICAgdmlldy5fX21vZGVsLCBlY01vZGVsLCBlY0lucy5fYXBpLCBwYXlsb2FkXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVzaXplIHRoZSBjaGFydFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLndpZHRoXSBDYW4gYmUgJ2F1dG8nICh0aGUgc2FtZSBhcyBudWxsL3VuZGVmaW5lZClcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdHMuaGVpZ2h0XSBDYW4gYmUgJ2F1dG8nICh0aGUgc2FtZSBhcyBudWxsL3VuZGVmaW5lZClcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnNpbGVudD1mYWxzZV1cbiAgICAgKi9cbiAgICBlY2hhcnRzUHJvdG8ucmVzaXplID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgICAgICAgaWYgKF9fREVWX18pIHtcbiAgICAgICAgICAgIHpyVXRpbC5hc3NlcnQoIXRoaXNbSU5fTUFJTl9QUk9DRVNTXSwgJ2ByZXNpemVgIHNob3VsZCBub3QgYmUgY2FsbGVkIGR1cmluZyBtYWluIHByb2Nlc3MuJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzW0lOX01BSU5fUFJPQ0VTU10gPSB0cnVlO1xuXG4gICAgICAgIHRoaXMuX3pyLnJlc2l6ZShvcHRzKTtcblxuICAgICAgICB2YXIgb3B0aW9uQ2hhbmdlZCA9IHRoaXMuX21vZGVsICYmIHRoaXMuX21vZGVsLnJlc2V0T3B0aW9uKCdtZWRpYScpO1xuICAgICAgICB2YXIgdXBkYXRlTWV0aG9kID0gb3B0aW9uQ2hhbmdlZCA/ICdwcmVwYXJlQW5kVXBkYXRlJyA6ICd1cGRhdGUnO1xuXG4gICAgICAgIHVwZGF0ZU1ldGhvZHNbdXBkYXRlTWV0aG9kXS5jYWxsKHRoaXMpO1xuXG4gICAgICAgIC8vIFJlc2l6ZSBsb2FkaW5nIGVmZmVjdFxuICAgICAgICB0aGlzLl9sb2FkaW5nRlggJiYgdGhpcy5fbG9hZGluZ0ZYLnJlc2l6ZSgpO1xuXG4gICAgICAgIHRoaXNbSU5fTUFJTl9QUk9DRVNTXSA9IGZhbHNlO1xuXG4gICAgICAgIHZhciBzaWxlbnQgPSBvcHRzICYmIG9wdHMuc2lsZW50O1xuXG4gICAgICAgIGZsdXNoUGVuZGluZ0FjdGlvbnMuY2FsbCh0aGlzLCBzaWxlbnQpO1xuXG4gICAgICAgIHRyaWdnZXJVcGRhdGVkRXZlbnQuY2FsbCh0aGlzLCBzaWxlbnQpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTaG93IGxvYWRpbmcgZWZmZWN0XG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBbbmFtZT0nZGVmYXVsdCddXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBbY2ZnXVxuICAgICAqL1xuICAgIGVjaGFydHNQcm90by5zaG93TG9hZGluZyA9IGZ1bmN0aW9uIChuYW1lLCBjZmcpIHtcbiAgICAgICAgaWYgKHpyVXRpbC5pc09iamVjdChuYW1lKSkge1xuICAgICAgICAgICAgY2ZnID0gbmFtZTtcbiAgICAgICAgICAgIG5hbWUgPSAnJztcbiAgICAgICAgfVxuICAgICAgICBuYW1lID0gbmFtZSB8fCAnZGVmYXVsdCc7XG5cbiAgICAgICAgdGhpcy5oaWRlTG9hZGluZygpO1xuICAgICAgICBpZiAoIWxvYWRpbmdFZmZlY3RzW25hbWVdKSB7XG4gICAgICAgICAgICBpZiAoX19ERVZfXykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignTG9hZGluZyBlZmZlY3RzICcgKyBuYW1lICsgJyBub3QgZXhpc3RzLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlbCA9IGxvYWRpbmdFZmZlY3RzW25hbWVdKHRoaXMuX2FwaSwgY2ZnKTtcbiAgICAgICAgdmFyIHpyID0gdGhpcy5fenI7XG4gICAgICAgIHRoaXMuX2xvYWRpbmdGWCA9IGVsO1xuXG4gICAgICAgIHpyLmFkZChlbCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEhpZGUgbG9hZGluZyBlZmZlY3RcbiAgICAgKi9cbiAgICBlY2hhcnRzUHJvdG8uaGlkZUxvYWRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2xvYWRpbmdGWCAmJiB0aGlzLl96ci5yZW1vdmUodGhpcy5fbG9hZGluZ0ZYKTtcbiAgICAgICAgdGhpcy5fbG9hZGluZ0ZYID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50T2JqXG4gICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAqL1xuICAgIGVjaGFydHNQcm90by5tYWtlQWN0aW9uRnJvbUV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50T2JqKSB7XG4gICAgICAgIHZhciBwYXlsb2FkID0genJVdGlsLmV4dGVuZCh7fSwgZXZlbnRPYmopO1xuICAgICAgICBwYXlsb2FkLnR5cGUgPSBldmVudEFjdGlvbk1hcFtldmVudE9iai50eXBlXTtcbiAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwdWJpbGNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGF5bG9hZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGF5bG9hZC50eXBlXSBBY3Rpb24gdHlwZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fGJvb2xlYW59IFtvcHRdIElmIHBhc3MgYm9vbGVhbiwgbWVhbnMgb3B0LnNpbGVudFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdC5zaWxlbnQ9ZmFsc2VdIFdoZXRoZXIgdHJpZ2dlciBldmVudHMuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0LmZsdXNoPXVuZGVmaW5lZF1cbiAgICAgKiAgICAgICAgICAgICAgICAgIHRydWU6IEZsdXNoIGltbWVkaWF0ZWx5LCBhbmQgdGhlbiBwaXhlbCBpbiBjYW52YXMgY2FuIGJlIGZldGNoZWRcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICBpbW1lZGlhdGVseS4gQ2F1dGlvbjogaXQgbWlnaHQgYWZmZWN0IHBlcmZvcm1hbmNlLlxuICAgICAqICAgICAgICAgICAgICAgICAgZmFsc2U6IE5vdCBub3QgZmx1c2guXG4gICAgICogICAgICAgICAgICAgICAgICB1bmRlZmluZWQ6IEF1dG8gZGVjaWRlIHdoZXRoZXIgcGVyZm9ybSBmbHVzaC5cbiAgICAgKi9cbiAgICBlY2hhcnRzUHJvdG8uZGlzcGF0Y2hBY3Rpb24gPSBmdW5jdGlvbiAocGF5bG9hZCwgb3B0KSB7XG4gICAgICAgIGlmICghenJVdGlsLmlzT2JqZWN0KG9wdCkpIHtcbiAgICAgICAgICAgIG9wdCA9IHtzaWxlbnQ6ICEhb3B0fTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghYWN0aW9uc1twYXlsb2FkLnR5cGVdKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBNYXkgZGlzcGF0Y2hBY3Rpb24gaW4gcmVuZGVyaW5nIHByb2NlZHVyZVxuICAgICAgICBpZiAodGhpc1tJTl9NQUlOX1BST0NFU1NdKSB7XG4gICAgICAgICAgICB0aGlzLl9wZW5kaW5nQWN0aW9ucy5wdXNoKHBheWxvYWQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZG9EaXNwYXRjaEFjdGlvbi5jYWxsKHRoaXMsIHBheWxvYWQsIG9wdC5zaWxlbnQpO1xuXG4gICAgICAgIGlmIChvcHQuZmx1c2gpIHtcbiAgICAgICAgICAgIHRoaXMuX3pyLmZsdXNoKHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wdC5mbHVzaCAhPT0gZmFsc2UgJiYgZW52LmJyb3dzZXIud2VDaGF0KSB7XG4gICAgICAgICAgICAvLyBJbiBXZUNoYXQgZW1iZWRlZCBicm93c2VyLCBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYCBhbmQgYHNldEludGVydmFsYFxuICAgICAgICAgICAgLy8gaGFuZyB3aGVuIHNsaWRpbmcgcGFnZSAob24gdG91Y2ggZXZlbnQpLCB3aGljaCBjYXVzZSB0aGF0IHpyIGRvZXMgbm90XG4gICAgICAgICAgICAvLyByZWZyZXNoIHV0aWwgdXNlciBpbnRlcmFjdGlvbiBmaW5pc2hlZCwgd2hpY2ggaXMgbm90IGV4cGVjdGVkLlxuICAgICAgICAgICAgLy8gQnV0IGBkaXNwYXRjaEFjdGlvbmAgbWF5IGJlIGNhbGxlZCB0b28gZnJlcXVlbnRseSB3aGVuIHBhbiBvbiB0b3VjaFxuICAgICAgICAgICAgLy8gc2NyZWVuLCB3aGljaCBpbXBhY3RzIHBlcmZvcm1hbmNlIGlmIGRvIG5vdCB0aHJvdHRsZSB0aGVtLlxuICAgICAgICAgICAgdGhpcy5fdGhyb3R0bGVkWnJGbHVzaCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZmx1c2hQZW5kaW5nQWN0aW9ucy5jYWxsKHRoaXMsIG9wdC5zaWxlbnQpO1xuXG4gICAgICAgIHRyaWdnZXJVcGRhdGVkRXZlbnQuY2FsbCh0aGlzLCBvcHQuc2lsZW50KTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZG9EaXNwYXRjaEFjdGlvbihwYXlsb2FkLCBzaWxlbnQpIHtcbiAgICAgICAgdmFyIHBheWxvYWRUeXBlID0gcGF5bG9hZC50eXBlO1xuICAgICAgICB2YXIgZXNjYXBlQ29ubmVjdCA9IHBheWxvYWQuZXNjYXBlQ29ubmVjdDtcbiAgICAgICAgdmFyIGFjdGlvbldyYXAgPSBhY3Rpb25zW3BheWxvYWRUeXBlXTtcbiAgICAgICAgdmFyIGFjdGlvbkluZm8gPSBhY3Rpb25XcmFwLmFjdGlvbkluZm87XG5cbiAgICAgICAgdmFyIGNwdFR5cGUgPSAoYWN0aW9uSW5mby51cGRhdGUgfHwgJ3VwZGF0ZScpLnNwbGl0KCc6Jyk7XG4gICAgICAgIHZhciB1cGRhdGVNZXRob2QgPSBjcHRUeXBlLnBvcCgpO1xuICAgICAgICBjcHRUeXBlID0gY3B0VHlwZVswXSAhPSBudWxsICYmIHBhcnNlQ2xhc3NUeXBlKGNwdFR5cGVbMF0pO1xuXG4gICAgICAgIHRoaXNbSU5fTUFJTl9QUk9DRVNTXSA9IHRydWU7XG5cbiAgICAgICAgdmFyIHBheWxvYWRzID0gW3BheWxvYWRdO1xuICAgICAgICB2YXIgYmF0Y2hlZCA9IGZhbHNlO1xuICAgICAgICAvLyBCYXRjaCBhY3Rpb25cbiAgICAgICAgaWYgKHBheWxvYWQuYmF0Y2gpIHtcbiAgICAgICAgICAgIGJhdGNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgcGF5bG9hZHMgPSB6clV0aWwubWFwKHBheWxvYWQuYmF0Y2gsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgaXRlbSA9IHpyVXRpbC5kZWZhdWx0cyh6clV0aWwuZXh0ZW5kKHt9LCBpdGVtKSwgcGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgaXRlbS5iYXRjaCA9IG51bGw7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBldmVudE9iakJhdGNoID0gW107XG4gICAgICAgIHZhciBldmVudE9iajtcbiAgICAgICAgdmFyIGlzSGlnaERvd24gPSBwYXlsb2FkVHlwZSA9PT0gJ2hpZ2hsaWdodCcgfHwgcGF5bG9hZFR5cGUgPT09ICdkb3ducGxheSc7XG5cbiAgICAgICAgZWFjaChwYXlsb2FkcywgZnVuY3Rpb24gKGJhdGNoSXRlbSkge1xuICAgICAgICAgICAgLy8gQWN0aW9uIGNhbiBzcGVjaWZ5IHRoZSBldmVudCBieSByZXR1cm4gaXQuXG4gICAgICAgICAgICBldmVudE9iaiA9IGFjdGlvbldyYXAuYWN0aW9uKGJhdGNoSXRlbSwgdGhpcy5fbW9kZWwsIHRoaXMuX2FwaSk7XG4gICAgICAgICAgICAvLyBFbWl0IGV2ZW50IG91dHNpZGVcbiAgICAgICAgICAgIGV2ZW50T2JqID0gZXZlbnRPYmogfHwgenJVdGlsLmV4dGVuZCh7fSwgYmF0Y2hJdGVtKTtcbiAgICAgICAgICAgIC8vIENvbnZlcnQgdHlwZSB0byBldmVudFR5cGVcbiAgICAgICAgICAgIGV2ZW50T2JqLnR5cGUgPSBhY3Rpb25JbmZvLmV2ZW50IHx8IGV2ZW50T2JqLnR5cGU7XG4gICAgICAgICAgICBldmVudE9iakJhdGNoLnB1c2goZXZlbnRPYmopO1xuXG4gICAgICAgICAgICAvLyBsaWdodCB1cGRhdGUgZG9lcyBub3QgcGVyZm9ybSBkYXRhIHByb2Nlc3MsIGxheW91dCBhbmQgdmlzdWFsLlxuICAgICAgICAgICAgaWYgKGlzSGlnaERvd24pIHtcbiAgICAgICAgICAgICAgICAvLyBtZXRob2QsIHBheWxvYWQsIG1haW5UeXBlLCBzdWJUeXBlXG4gICAgICAgICAgICAgICAgdXBkYXRlRGlyZWN0bHkodGhpcywgdXBkYXRlTWV0aG9kLCBiYXRjaEl0ZW0sICdzZXJpZXMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNwdFR5cGUpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVEaXJlY3RseSh0aGlzLCB1cGRhdGVNZXRob2QsIGJhdGNoSXRlbSwgY3B0VHlwZS5tYWluLCBjcHRUeXBlLnN1Yik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIGlmICh1cGRhdGVNZXRob2QgIT09ICdub25lJyAmJiAhaXNIaWdoRG93biAmJiAhY3B0VHlwZSkge1xuICAgICAgICAgICAgLy8gU3RpbGwgZGlydHlcbiAgICAgICAgICAgIGlmICh0aGlzW09QVElPTl9VUERBVEVEXSkge1xuICAgICAgICAgICAgICAgIC8vIEZJWE1FIFBhc3MgcGF5bG9hZCA/XG4gICAgICAgICAgICAgICAgdXBkYXRlTWV0aG9kcy5wcmVwYXJlQW5kVXBkYXRlLmNhbGwodGhpcywgcGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgdGhpc1tPUFRJT05fVVBEQVRFRF0gPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHVwZGF0ZU1ldGhvZHNbdXBkYXRlTWV0aG9kXS5jYWxsKHRoaXMsIHBheWxvYWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRm9sbG93IHRoZSBydWxlIG9mIGFjdGlvbiBiYXRjaFxuICAgICAgICBpZiAoYmF0Y2hlZCkge1xuICAgICAgICAgICAgZXZlbnRPYmogPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogYWN0aW9uSW5mby5ldmVudCB8fCBwYXlsb2FkVHlwZSxcbiAgICAgICAgICAgICAgICBlc2NhcGVDb25uZWN0OiBlc2NhcGVDb25uZWN0LFxuICAgICAgICAgICAgICAgIGJhdGNoOiBldmVudE9iakJhdGNoXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZXZlbnRPYmogPSBldmVudE9iakJhdGNoWzBdO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpc1tJTl9NQUlOX1BST0NFU1NdID0gZmFsc2U7XG5cbiAgICAgICAgIXNpbGVudCAmJiB0aGlzLl9tZXNzYWdlQ2VudGVyLnRyaWdnZXIoZXZlbnRPYmoudHlwZSwgZXZlbnRPYmopO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZsdXNoUGVuZGluZ0FjdGlvbnMoc2lsZW50KSB7XG4gICAgICAgIHZhciBwZW5kaW5nQWN0aW9ucyA9IHRoaXMuX3BlbmRpbmdBY3Rpb25zO1xuICAgICAgICB3aGlsZSAocGVuZGluZ0FjdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgcGF5bG9hZCA9IHBlbmRpbmdBY3Rpb25zLnNoaWZ0KCk7XG4gICAgICAgICAgICBkb0Rpc3BhdGNoQWN0aW9uLmNhbGwodGhpcywgcGF5bG9hZCwgc2lsZW50KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRyaWdnZXJVcGRhdGVkRXZlbnQoc2lsZW50KSB7XG4gICAgICAgICFzaWxlbnQgJiYgdGhpcy50cmlnZ2VyKCd1cGRhdGVkJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgZXZlbnRcbiAgICAgKiBAbWV0aG9kXG4gICAgICovXG4gICAgZWNoYXJ0c1Byb3RvLm9uID0gY3JlYXRlUmVnaXN0ZXJFdmVudFdpdGhMb3dlcmNhc2VOYW1lKCdvbicpO1xuICAgIGVjaGFydHNQcm90by5vZmYgPSBjcmVhdGVSZWdpc3RlckV2ZW50V2l0aExvd2VyY2FzZU5hbWUoJ29mZicpO1xuICAgIGVjaGFydHNQcm90by5vbmUgPSBjcmVhdGVSZWdpc3RlckV2ZW50V2l0aExvd2VyY2FzZU5hbWUoJ29uZScpO1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZE5hbWVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGludm9rZVVwZGF0ZU1ldGhvZChtZXRob2ROYW1lLCBlY01vZGVsLCBwYXlsb2FkKSB7XG4gICAgICAgIHZhciBhcGkgPSB0aGlzLl9hcGk7XG5cbiAgICAgICAgLy8gVXBkYXRlIGFsbCBjb21wb25lbnRzXG4gICAgICAgIGVhY2godGhpcy5fY29tcG9uZW50c1ZpZXdzLCBmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICAgICAgICB2YXIgY29tcG9uZW50TW9kZWwgPSBjb21wb25lbnQuX19tb2RlbDtcbiAgICAgICAgICAgIGNvbXBvbmVudFttZXRob2ROYW1lXShjb21wb25lbnRNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKTtcblxuICAgICAgICAgICAgdXBkYXRlWihjb21wb25lbnRNb2RlbCwgY29tcG9uZW50KTtcbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgLy8gVXBhdGUgYWxsIGNoYXJ0c1xuICAgICAgICBlY01vZGVsLmVhY2hTZXJpZXMoZnVuY3Rpb24gKHNlcmllc01vZGVsLCBpZHgpIHtcbiAgICAgICAgICAgIHZhciBjaGFydCA9IHRoaXMuX2NoYXJ0c01hcFtzZXJpZXNNb2RlbC5fX3ZpZXdJZF07XG4gICAgICAgICAgICBjaGFydFttZXRob2ROYW1lXShzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKTtcblxuICAgICAgICAgICAgdXBkYXRlWihzZXJpZXNNb2RlbCwgY2hhcnQpO1xuXG4gICAgICAgICAgICB1cGRhdGVQcm9ncmVzc2l2ZUFuZEJsZW5kKHNlcmllc01vZGVsLCBjaGFydCk7XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIC8vIElmIHVzZSBob3ZlciBsYXllclxuICAgICAgICB1cGRhdGVIb3ZlckxheWVyU3RhdHVzKHRoaXMuX3pyLCBlY01vZGVsKTtcblxuICAgICAgICAvLyBQb3N0IHJlbmRlclxuICAgICAgICBlYWNoKHBvc3RVcGRhdGVGdW5jcywgZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICAgICAgICAgIGZ1bmMoZWNNb2RlbCwgYXBpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJlcGFyZSB2aWV3IGluc3RhbmNlcyBvZiBjaGFydHMgYW5kIGNvbXBvbmVudHNcbiAgICAgKiBAcGFyYW0gIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9IGVjTW9kZWxcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHByZXBhcmVWaWV3KHR5cGUsIGVjTW9kZWwpIHtcbiAgICAgICAgdmFyIGlzQ29tcG9uZW50ID0gdHlwZSA9PT0gJ2NvbXBvbmVudCc7XG4gICAgICAgIHZhciB2aWV3TGlzdCA9IGlzQ29tcG9uZW50ID8gdGhpcy5fY29tcG9uZW50c1ZpZXdzIDogdGhpcy5fY2hhcnRzVmlld3M7XG4gICAgICAgIHZhciB2aWV3TWFwID0gaXNDb21wb25lbnQgPyB0aGlzLl9jb21wb25lbnRzTWFwIDogdGhpcy5fY2hhcnRzTWFwO1xuICAgICAgICB2YXIgenIgPSB0aGlzLl96cjtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZpZXdMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2aWV3TGlzdFtpXS5fX2FsaXZlID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBlY01vZGVsW2lzQ29tcG9uZW50ID8gJ2VhY2hDb21wb25lbnQnIDogJ2VhY2hTZXJpZXMnXShmdW5jdGlvbiAoY29tcG9uZW50VHlwZSwgbW9kZWwpIHtcbiAgICAgICAgICAgIGlmIChpc0NvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgIGlmIChjb21wb25lbnRUeXBlID09PSAnc2VyaWVzJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbW9kZWwgPSBjb21wb25lbnRUeXBlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDb25zaWRlcjogaWQgc2FtZSBhbmQgdHlwZSBjaGFuZ2VkLlxuICAgICAgICAgICAgdmFyIHZpZXdJZCA9IG1vZGVsLmlkICsgJ18nICsgbW9kZWwudHlwZTtcbiAgICAgICAgICAgIHZhciB2aWV3ID0gdmlld01hcFt2aWV3SWRdO1xuICAgICAgICAgICAgaWYgKCF2aWV3KSB7XG4gICAgICAgICAgICAgICAgdmFyIGNsYXNzVHlwZSA9IHBhcnNlQ2xhc3NUeXBlKG1vZGVsLnR5cGUpO1xuICAgICAgICAgICAgICAgIHZhciBDbGF6eiA9IGlzQ29tcG9uZW50XG4gICAgICAgICAgICAgICAgICAgID8gQ29tcG9uZW50Vmlldy5nZXRDbGFzcyhjbGFzc1R5cGUubWFpbiwgY2xhc3NUeXBlLnN1YilcbiAgICAgICAgICAgICAgICAgICAgOiBDaGFydFZpZXcuZ2V0Q2xhc3MoY2xhc3NUeXBlLnN1Yik7XG4gICAgICAgICAgICAgICAgaWYgKENsYXp6KSB7XG4gICAgICAgICAgICAgICAgICAgIHZpZXcgPSBuZXcgQ2xhenooKTtcbiAgICAgICAgICAgICAgICAgICAgdmlldy5pbml0KGVjTW9kZWwsIHRoaXMuX2FwaSk7XG4gICAgICAgICAgICAgICAgICAgIHZpZXdNYXBbdmlld0lkXSA9IHZpZXc7XG4gICAgICAgICAgICAgICAgICAgIHZpZXdMaXN0LnB1c2godmlldyk7XG4gICAgICAgICAgICAgICAgICAgIHpyLmFkZCh2aWV3Lmdyb3VwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEVycm9yXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1vZGVsLl9fdmlld0lkID0gdmlldy5fX2lkID0gdmlld0lkO1xuICAgICAgICAgICAgdmlldy5fX2FsaXZlID0gdHJ1ZTtcbiAgICAgICAgICAgIHZpZXcuX19tb2RlbCA9IG1vZGVsO1xuICAgICAgICAgICAgdmlldy5ncm91cC5fX2VjQ29tcG9uZW50SW5mbyA9IHtcbiAgICAgICAgICAgICAgICBtYWluVHlwZTogbW9kZWwubWFpblR5cGUsXG4gICAgICAgICAgICAgICAgaW5kZXg6IG1vZGVsLmNvbXBvbmVudEluZGV4XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZpZXdMaXN0Lmxlbmd0aDspIHtcbiAgICAgICAgICAgIHZhciB2aWV3ID0gdmlld0xpc3RbaV07XG4gICAgICAgICAgICBpZiAoIXZpZXcuX19hbGl2ZSkge1xuICAgICAgICAgICAgICAgIHpyLnJlbW92ZSh2aWV3Lmdyb3VwKTtcbiAgICAgICAgICAgICAgICB2aWV3LmRpc3Bvc2UoZWNNb2RlbCwgdGhpcy5fYXBpKTtcbiAgICAgICAgICAgICAgICB2aWV3TGlzdC5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHZpZXdNYXBbdmlldy5fX2lkXTtcbiAgICAgICAgICAgICAgICB2aWV3Ll9faWQgPSB2aWV3Lmdyb3VwLl9fZWNDb21wb25lbnRJbmZvID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByb2Nlc3NvciBkYXRhIGluIGVhY2ggc2VyaWVzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL0dsb2JhbH0gZWNNb2RlbFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHJvY2Vzc0RhdGEoZWNNb2RlbCwgYXBpKSB7XG4gICAgICAgIGVhY2goZGF0YVByb2Nlc3NvckZ1bmNzLCBmdW5jdGlvbiAocHJvY2Vzcykge1xuICAgICAgICAgICAgcHJvY2Vzcy5mdW5jKGVjTW9kZWwsIGFwaSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RhY2tTZXJpZXNEYXRhKGVjTW9kZWwpIHtcbiAgICAgICAgdmFyIHN0YWNrZWREYXRhTWFwID0ge307XG4gICAgICAgIGVjTW9kZWwuZWFjaFNlcmllcyhmdW5jdGlvbiAoc2VyaWVzKSB7XG4gICAgICAgICAgICB2YXIgc3RhY2sgPSBzZXJpZXMuZ2V0KCdzdGFjaycpO1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBzZXJpZXMuZ2V0RGF0YSgpO1xuICAgICAgICAgICAgaWYgKHN0YWNrICYmIGRhdGEudHlwZSA9PT0gJ2xpc3QnKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByZXZpb3VzU3RhY2sgPSBzdGFja2VkRGF0YU1hcFtzdGFja107XG4gICAgICAgICAgICAgICAgaWYgKHByZXZpb3VzU3RhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5zdGFja2VkT24gPSBwcmV2aW91c1N0YWNrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdGFja2VkRGF0YU1hcFtzdGFja10gPSBkYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMYXlvdXQgYmVmb3JlIGVhY2ggY2hhcnQgcmVuZGVyIHRoZXJlIHNlcmllcywgc3BlY2lhbCB2aXN1YWwgZW5jb2Rpbmcgc3RhZ2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvR2xvYmFsfSBlY01vZGVsXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkb0xheW91dChlY01vZGVsLCBwYXlsb2FkKSB7XG4gICAgICAgIHZhciBhcGkgPSB0aGlzLl9hcGk7XG4gICAgICAgIGVhY2godmlzdWFsRnVuY3MsIGZ1bmN0aW9uICh2aXN1YWwpIHtcbiAgICAgICAgICAgIGlmICh2aXN1YWwuaXNMYXlvdXQpIHtcbiAgICAgICAgICAgICAgICB2aXN1YWwuZnVuYyhlY01vZGVsLCBhcGksIHBheWxvYWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbmNvZGUgdmlzdWFsIGluZm9tYXRpb24gZnJvbSBkYXRhIGFmdGVyIGRhdGEgcHJvY2Vzc2luZ1xuICAgICAqXG4gICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9IGVjTW9kZWxcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gbGF5b3V0XG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZXhjbHVkZXNMYXlvdXRdXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkb1Zpc3VhbEVuY29kaW5nKGVjTW9kZWwsIHBheWxvYWQsIGV4Y2x1ZGVzTGF5b3V0KSB7XG4gICAgICAgIHZhciBhcGkgPSB0aGlzLl9hcGk7XG4gICAgICAgIGVjTW9kZWwuY2xlYXJDb2xvclBhbGV0dGUoKTtcbiAgICAgICAgZWNNb2RlbC5lYWNoU2VyaWVzKGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgICAgICAgICAgc2VyaWVzTW9kZWwuY2xlYXJDb2xvclBhbGV0dGUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGVhY2godmlzdWFsRnVuY3MsIGZ1bmN0aW9uICh2aXN1YWwpIHtcbiAgICAgICAgICAgICghZXhjbHVkZXNMYXlvdXQgfHwgIXZpc3VhbC5pc0xheW91dClcbiAgICAgICAgICAgICAgICAmJiB2aXN1YWwuZnVuYyhlY01vZGVsLCBhcGksIHBheWxvYWQpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgZWFjaCBjaGFydCBhbmQgY29tcG9uZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkb1JlbmRlcihlY01vZGVsLCBwYXlsb2FkKSB7XG4gICAgICAgIHZhciBhcGkgPSB0aGlzLl9hcGk7XG4gICAgICAgIC8vIFJlbmRlciBhbGwgY29tcG9uZW50c1xuICAgICAgICBlYWNoKHRoaXMuX2NvbXBvbmVudHNWaWV3cywgZnVuY3Rpb24gKGNvbXBvbmVudFZpZXcpIHtcbiAgICAgICAgICAgIHZhciBjb21wb25lbnRNb2RlbCA9IGNvbXBvbmVudFZpZXcuX19tb2RlbDtcbiAgICAgICAgICAgIGNvbXBvbmVudFZpZXcucmVuZGVyKGNvbXBvbmVudE1vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpO1xuXG4gICAgICAgICAgICB1cGRhdGVaKGNvbXBvbmVudE1vZGVsLCBjb21wb25lbnRWaWV3KTtcbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgZWFjaCh0aGlzLl9jaGFydHNWaWV3cywgZnVuY3Rpb24gKGNoYXJ0KSB7XG4gICAgICAgICAgICBjaGFydC5fX2FsaXZlID0gZmFsc2U7XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIC8vIFJlbmRlciBhbGwgY2hhcnRzXG4gICAgICAgIGVjTW9kZWwuZWFjaFNlcmllcyhmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIGlkeCkge1xuICAgICAgICAgICAgdmFyIGNoYXJ0VmlldyA9IHRoaXMuX2NoYXJ0c01hcFtzZXJpZXNNb2RlbC5fX3ZpZXdJZF07XG4gICAgICAgICAgICBjaGFydFZpZXcuX19hbGl2ZSA9IHRydWU7XG4gICAgICAgICAgICBjaGFydFZpZXcucmVuZGVyKHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpO1xuXG4gICAgICAgICAgICBjaGFydFZpZXcuZ3JvdXAuc2lsZW50ID0gISFzZXJpZXNNb2RlbC5nZXQoJ3NpbGVudCcpO1xuXG4gICAgICAgICAgICB1cGRhdGVaKHNlcmllc01vZGVsLCBjaGFydFZpZXcpO1xuXG4gICAgICAgICAgICB1cGRhdGVQcm9ncmVzc2l2ZUFuZEJsZW5kKHNlcmllc01vZGVsLCBjaGFydFZpZXcpO1xuXG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIC8vIElmIHVzZSBob3ZlciBsYXllclxuICAgICAgICB1cGRhdGVIb3ZlckxheWVyU3RhdHVzKHRoaXMuX3pyLCBlY01vZGVsKTtcblxuICAgICAgICAvLyBSZW1vdmUgZ3JvdXBzIG9mIHVucmVuZGVyZWQgY2hhcnRzXG4gICAgICAgIGVhY2godGhpcy5fY2hhcnRzVmlld3MsIGZ1bmN0aW9uIChjaGFydCkge1xuICAgICAgICAgICAgaWYgKCFjaGFydC5fX2FsaXZlKSB7XG4gICAgICAgICAgICAgICAgY2hhcnQucmVtb3ZlKGVjTW9kZWwsIGFwaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH1cblxuICAgIHZhciBNT1VTRV9FVkVOVF9OQU1FUyA9IFtcbiAgICAgICAgJ2NsaWNrJywgJ2RibGNsaWNrJywgJ21vdXNlb3ZlcicsICdtb3VzZW91dCcsICdtb3VzZW1vdmUnLFxuICAgICAgICAnbW91c2Vkb3duJywgJ21vdXNldXAnLCAnZ2xvYmFsb3V0JywgJ2NvbnRleHRtZW51J1xuICAgIF07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBlY2hhcnRzUHJvdG8uX2luaXRFdmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGVhY2goTU9VU0VfRVZFTlRfTkFNRVMsIGZ1bmN0aW9uIChldmVOYW1lKSB7XG4gICAgICAgICAgICB0aGlzLl96ci5vbihldmVOYW1lLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHZhciBlY01vZGVsID0gdGhpcy5nZXRNb2RlbCgpO1xuICAgICAgICAgICAgICAgIHZhciBlbCA9IGUudGFyZ2V0O1xuICAgICAgICAgICAgICAgIHZhciBwYXJhbXM7XG5cbiAgICAgICAgICAgICAgICAvLyBubyBlLnRhcmdldCB3aGVuICdnbG9iYWxvdXQnLlxuICAgICAgICAgICAgICAgIGlmIChldmVOYW1lID09PSAnZ2xvYmFsb3V0Jykge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZWwgJiYgZWwuZGF0YUluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGFNb2RlbCA9IGVsLmRhdGFNb2RlbCB8fCBlY01vZGVsLmdldFNlcmllc0J5SW5kZXgoZWwuc2VyaWVzSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSBkYXRhTW9kZWwgJiYgZGF0YU1vZGVsLmdldERhdGFQYXJhbXMoZWwuZGF0YUluZGV4LCBlbC5kYXRhVHlwZSkgfHwge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElmIGVsZW1lbnQgaGFzIGN1c3RvbSBldmVudERhdGEgb2YgY29tcG9uZW50c1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGVsICYmIGVsLmV2ZW50RGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSB6clV0aWwuZXh0ZW5kKHt9LCBlbC5ldmVudERhdGEpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChwYXJhbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLmV2ZW50ID0gZTtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnR5cGUgPSBldmVOYW1lO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoZXZlTmFtZSwgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICBlYWNoKGV2ZW50QWN0aW9uTWFwLCBmdW5jdGlvbiAoYWN0aW9uVHlwZSwgZXZlbnRUeXBlKSB7XG4gICAgICAgICAgICB0aGlzLl9tZXNzYWdlQ2VudGVyLm9uKGV2ZW50VHlwZSwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKGV2ZW50VHlwZSwgZXZlbnQpO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIGVjaGFydHNQcm90by5pc0Rpc3Bvc2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGlzcG9zZWQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENsZWFyXG4gICAgICovXG4gICAgZWNoYXJ0c1Byb3RvLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNldE9wdGlvbih7IHNlcmllczogW10gfSwgdHJ1ZSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERpc3Bvc2UgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBlY2hhcnRzUHJvdG8uZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2Rpc3Bvc2VkKSB7XG4gICAgICAgICAgICBpZiAoX19ERVZfXykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignSW5zdGFuY2UgJyArIHRoaXMuaWQgKyAnIGhhcyBiZWVuIGRpc3Bvc2VkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZGlzcG9zZWQgPSB0cnVlO1xuXG4gICAgICAgIHZhciBhcGkgPSB0aGlzLl9hcGk7XG4gICAgICAgIHZhciBlY01vZGVsID0gdGhpcy5fbW9kZWw7XG5cbiAgICAgICAgZWFjaCh0aGlzLl9jb21wb25lbnRzVmlld3MsIGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudC5kaXNwb3NlKGVjTW9kZWwsIGFwaSk7XG4gICAgICAgIH0pO1xuICAgICAgICBlYWNoKHRoaXMuX2NoYXJ0c1ZpZXdzLCBmdW5jdGlvbiAoY2hhcnQpIHtcbiAgICAgICAgICAgIGNoYXJ0LmRpc3Bvc2UoZWNNb2RlbCwgYXBpKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gRGlzcG9zZSBhZnRlciBhbGwgdmlld3MgZGlzcG9zZWRcbiAgICAgICAgdGhpcy5fenIuZGlzcG9zZSgpO1xuXG4gICAgICAgIGRlbGV0ZSBpbnN0YW5jZXNbdGhpcy5pZF07XG4gICAgfTtcblxuICAgIHpyVXRpbC5taXhpbihFQ2hhcnRzLCBFdmVudGZ1bCk7XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVIb3ZlckxheWVyU3RhdHVzKHpyLCBlY01vZGVsKSB7XG4gICAgICAgIHZhciBzdG9yYWdlID0genIuc3RvcmFnZTtcbiAgICAgICAgdmFyIGVsQ291bnQgPSAwO1xuICAgICAgICBzdG9yYWdlLnRyYXZlcnNlKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgaWYgKCFlbC5pc0dyb3VwKSB7XG4gICAgICAgICAgICAgICAgZWxDb3VudCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGVsQ291bnQgPiBlY01vZGVsLmdldCgnaG92ZXJMYXllclRocmVzaG9sZCcpICYmICFlbnYubm9kZSkge1xuICAgICAgICAgICAgc3RvcmFnZS50cmF2ZXJzZShmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWVsLmlzR3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgZWwudXNlSG92ZXJMYXllciA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgY2hhcnQgcHJvZ3Jlc3NpdmUgYW5kIGJsZW5kLlxuICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvU2VyaWVzfG1vZHVsZTplY2hhcnRzL21vZGVsL0NvbXBvbmVudH0gbW9kZWxcbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL3ZpZXcvQ29tcG9uZW50fG1vZHVsZTplY2hhcnRzL3ZpZXcvQ2hhcnR9IHZpZXdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1cGRhdGVQcm9ncmVzc2l2ZUFuZEJsZW5kKHNlcmllc01vZGVsLCBjaGFydFZpZXcpIHtcbiAgICAgICAgLy8gUHJvZ3Jlc3NpdmUgY29uZmlndXJhdGlvblxuICAgICAgICB2YXIgZWxDb3VudCA9IDA7XG4gICAgICAgIGNoYXJ0Vmlldy5ncm91cC50cmF2ZXJzZShmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIGlmIChlbC50eXBlICE9PSAnZ3JvdXAnICYmICFlbC5pZ25vcmUpIHtcbiAgICAgICAgICAgICAgICBlbENvdW50Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgZnJhbWVEcmF3TnVtID0gK3Nlcmllc01vZGVsLmdldCgncHJvZ3Jlc3NpdmUnKTtcbiAgICAgICAgdmFyIG5lZWRQcm9ncmVzc2l2ZSA9IGVsQ291bnQgPiBzZXJpZXNNb2RlbC5nZXQoJ3Byb2dyZXNzaXZlVGhyZXNob2xkJykgJiYgZnJhbWVEcmF3TnVtICYmICFlbnYubm9kZTtcbiAgICAgICAgaWYgKG5lZWRQcm9ncmVzc2l2ZSkge1xuICAgICAgICAgICAgY2hhcnRWaWV3Lmdyb3VwLnRyYXZlcnNlKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgICAgIC8vIEZJWE1FIG1hcmtlciBhbmQgb3RoZXIgY29tcG9uZW50c1xuICAgICAgICAgICAgICAgIGlmICghZWwuaXNHcm91cCkge1xuICAgICAgICAgICAgICAgICAgICBlbC5wcm9ncmVzc2l2ZSA9IG5lZWRQcm9ncmVzc2l2ZSA/XG4gICAgICAgICAgICAgICAgICAgICAgICBNYXRoLmZsb29yKGVsQ291bnQrKyAvIGZyYW1lRHJhd051bSkgOiAtMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5lZWRQcm9ncmVzc2l2ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwuc3RvcEFuaW1hdGlvbih0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmxlbmQgY29uZmlncmF0aW9uXG4gICAgICAgIHZhciBibGVuZE1vZGUgPSBzZXJpZXNNb2RlbC5nZXQoJ2JsZW5kTW9kZScpIHx8IG51bGw7XG4gICAgICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgICAgICBpZiAoIWVudi5jYW52YXNTdXBwb3J0ZWQgJiYgYmxlbmRNb2RlICYmIGJsZW5kTW9kZSAhPT0gJ3NvdXJjZS1vdmVyJykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignT25seSBjYW52YXMgc3VwcG9ydCBibGVuZE1vZGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjaGFydFZpZXcuZ3JvdXAudHJhdmVyc2UoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAvLyBGSVhNRSBtYXJrZXIgYW5kIG90aGVyIGNvbXBvbmVudHNcbiAgICAgICAgICAgIGlmICghZWwuaXNHcm91cCkge1xuICAgICAgICAgICAgICAgIGVsLnNldFN0eWxlKCdibGVuZCcsIGJsZW5kTW9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvU2VyaWVzfG1vZHVsZTplY2hhcnRzL21vZGVsL0NvbXBvbmVudH0gbW9kZWxcbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL3ZpZXcvQ29tcG9uZW50fG1vZHVsZTplY2hhcnRzL3ZpZXcvQ2hhcnR9IHZpZXdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1cGRhdGVaKG1vZGVsLCB2aWV3KSB7XG4gICAgICAgIHZhciB6ID0gbW9kZWwuZ2V0KCd6Jyk7XG4gICAgICAgIHZhciB6bGV2ZWwgPSBtb2RlbC5nZXQoJ3psZXZlbCcpO1xuICAgICAgICAvLyBTZXQgeiBhbmQgemxldmVsXG4gICAgICAgIHZpZXcuZ3JvdXAudHJhdmVyc2UoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICBpZiAoZWwudHlwZSAhPT0gJ2dyb3VwJykge1xuICAgICAgICAgICAgICAgIHogIT0gbnVsbCAmJiAoZWwueiA9IHopO1xuICAgICAgICAgICAgICAgIHpsZXZlbCAhPSBudWxsICYmIChlbC56bGV2ZWwgPSB6bGV2ZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVFeHRlbnNpb25BUEkoZWNJbnN0YW5jZSkge1xuICAgICAgICB2YXIgY29vcmRTeXNNZ3IgPSBlY0luc3RhbmNlLl9jb29yZFN5c01ncjtcbiAgICAgICAgcmV0dXJuIHpyVXRpbC5leHRlbmQobmV3IEV4dGVuc2lvbkFQSShlY0luc3RhbmNlKSwge1xuICAgICAgICAgICAgLy8gSW5qZWN0IG1ldGhvZHNcbiAgICAgICAgICAgIGdldENvb3JkaW5hdGVTeXN0ZW1zOiB6clV0aWwuYmluZChcbiAgICAgICAgICAgICAgICBjb29yZFN5c01nci5nZXRDb29yZGluYXRlU3lzdGVtcywgY29vcmRTeXNNZ3JcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBnZXRDb21wb25lbnRCeUVsZW1lbnQ6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgICAgIHdoaWxlIChlbCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbW9kZWxJbmZvID0gZWwuX19lY0NvbXBvbmVudEluZm87XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb2RlbEluZm8gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVjSW5zdGFuY2UuX21vZGVsLmdldENvbXBvbmVudChtb2RlbEluZm8ubWFpblR5cGUsIG1vZGVsSW5mby5pbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWwgPSBlbC5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7T2JqZWN0fSBrZXk6IGFjdGlvblR5cGUuXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgdmFyIGFjdGlvbnMgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIE1hcCBldmVudFR5cGUgdG8gYWN0aW9uVHlwZVxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgdmFyIGV2ZW50QWN0aW9uTWFwID0ge307XG5cbiAgICAvKipcbiAgICAgKiBEYXRhIHByb2Nlc3NvciBmdW5jdGlvbnMgb2YgZWFjaCBzdGFnZVxuICAgICAqIEB0eXBlIHtBcnJheS48T2JqZWN0LjxzdHJpbmcsIEZ1bmN0aW9uPj59XG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgdmFyIGRhdGFQcm9jZXNzb3JGdW5jcyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5LjxGdW5jdGlvbj59XG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgdmFyIG9wdGlvblByZXByb2Nlc3NvckZ1bmNzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXkuPEZ1bmN0aW9uPn1cbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICB2YXIgcG9zdFVwZGF0ZUZ1bmNzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBWaXN1YWwgZW5jb2RpbmcgZnVuY3Rpb25zIG9mIGVhY2ggc3RhZ2VcbiAgICAgKiBAdHlwZSB7QXJyYXkuPE9iamVjdC48c3RyaW5nLCBGdW5jdGlvbj4+fVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIHZhciB2aXN1YWxGdW5jcyA9IFtdO1xuICAgIC8qKlxuICAgICAqIFRoZW1lIHN0b3JhZ2VcbiAgICAgKiBAdHlwZSB7T2JqZWN0LjxrZXksIE9iamVjdD59XG4gICAgICovXG4gICAgdmFyIHRoZW1lU3RvcmFnZSA9IHt9O1xuICAgIC8qKlxuICAgICAqIExvYWRpbmcgZWZmZWN0c1xuICAgICAqL1xuICAgIHZhciBsb2FkaW5nRWZmZWN0cyA9IHt9O1xuXG5cbiAgICB2YXIgaW5zdGFuY2VzID0ge307XG4gICAgdmFyIGNvbm5lY3RlZEdyb3VwcyA9IHt9O1xuXG4gICAgdmFyIGlkQmFzZSA9IG5ldyBEYXRlKCkgLSAwO1xuICAgIHZhciBncm91cElkQmFzZSA9IG5ldyBEYXRlKCkgLSAwO1xuICAgIHZhciBET01fQVRUUklCVVRFX0tFWSA9ICdfZWNoYXJ0c19pbnN0YW5jZV8nO1xuICAgIC8qKlxuICAgICAqIEBhbGlhcyBtb2R1bGU6ZWNoYXJ0c1xuICAgICAqL1xuICAgIHZhciBlY2hhcnRzID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHZlcnNpb246ICczLjUuNCcsXG4gICAgICAgIGRlcGVuZGVuY2llczoge1xuICAgICAgICAgICAgenJlbmRlcjogJzMuNC40J1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGVuYWJsZUNvbm5lY3QoY2hhcnQpIHtcbiAgICAgICAgdmFyIFNUQVRVU19QRU5ESU5HID0gMDtcbiAgICAgICAgdmFyIFNUQVRVU19VUERBVElORyA9IDE7XG4gICAgICAgIHZhciBTVEFUVVNfVVBEQVRFRCA9IDI7XG4gICAgICAgIHZhciBTVEFUVVNfS0VZID0gJ19fY29ubmVjdFVwZGF0ZVN0YXR1cyc7XG5cbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlQ29ubmVjdGVkQ2hhcnRzU3RhdHVzKGNoYXJ0cywgc3RhdHVzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBvdGhlckNoYXJ0ID0gY2hhcnRzW2ldO1xuICAgICAgICAgICAgICAgIG90aGVyQ2hhcnRbU1RBVFVTX0tFWV0gPSBzdGF0dXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB6clV0aWwuZWFjaChldmVudEFjdGlvbk1hcCwgZnVuY3Rpb24gKGFjdGlvblR5cGUsIGV2ZW50VHlwZSkge1xuICAgICAgICAgICAgY2hhcnQuX21lc3NhZ2VDZW50ZXIub24oZXZlbnRUeXBlLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29ubmVjdGVkR3JvdXBzW2NoYXJ0Lmdyb3VwXSAmJiBjaGFydFtTVEFUVVNfS0VZXSAhPT0gU1RBVFVTX1BFTkRJTkcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50ICYmIGV2ZW50LmVzY2FwZUNvbm5lY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhciBhY3Rpb24gPSBjaGFydC5tYWtlQWN0aW9uRnJvbUV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG90aGVyQ2hhcnRzID0gW107XG5cbiAgICAgICAgICAgICAgICAgICAgenJVdGlsLmVhY2goaW5zdGFuY2VzLCBmdW5jdGlvbiAob3RoZXJDaGFydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG90aGVyQ2hhcnQgIT09IGNoYXJ0ICYmIG90aGVyQ2hhcnQuZ3JvdXAgPT09IGNoYXJ0Lmdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3RoZXJDaGFydHMucHVzaChvdGhlckNoYXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlQ29ubmVjdGVkQ2hhcnRzU3RhdHVzKG90aGVyQ2hhcnRzLCBTVEFUVVNfUEVORElORyk7XG4gICAgICAgICAgICAgICAgICAgIGVhY2gob3RoZXJDaGFydHMsIGZ1bmN0aW9uIChvdGhlckNoYXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3RoZXJDaGFydFtTVEFUVVNfS0VZXSAhPT0gU1RBVFVTX1VQREFUSU5HKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3RoZXJDaGFydC5kaXNwYXRjaEFjdGlvbihhY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlQ29ubmVjdGVkQ2hhcnRzU3RhdHVzKG90aGVyQ2hhcnRzLCBTVEFUVVNfVVBEQVRFRCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7SFRNTERvbUVsZW1lbnR9IGRvbVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbdGhlbWVdXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdHMuZGV2aWNlUGl4ZWxSYXRpb10gVXNlIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIGJ5IGRlZmF1bHRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMucmVuZGVyZXJdIEN1cnJlbnRseSBvbmx5ICdjYW52YXMnIGlzIHN1cHBvcnRlZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdHMud2lkdGhdIFVzZSBjbGllbnRXaWR0aCBvZiB0aGUgaW5wdXQgYGRvbWAgYnkgZGVmYXVsdC5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENhbiBiZSAnYXV0bycgKHRoZSBzYW1lIGFzIG51bGwvdW5kZWZpbmVkKVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy5oZWlnaHRdIFVzZSBjbGllbnRIZWlnaHQgb2YgdGhlIGlucHV0IGBkb21gIGJ5IGRlZmF1bHQuXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ2FuIGJlICdhdXRvJyAodGhlIHNhbWUgYXMgbnVsbC91bmRlZmluZWQpXG4gICAgICovXG4gICAgZWNoYXJ0cy5pbml0ID0gZnVuY3Rpb24gKGRvbSwgdGhlbWUsIG9wdHMpIHtcbiAgICAgICAgaWYgKF9fREVWX18pIHtcbiAgICAgICAgICAgIC8vIENoZWNrIHZlcnNpb25cbiAgICAgICAgICAgIGlmICgoenJlbmRlci52ZXJzaW9uLnJlcGxhY2UoJy4nLCAnJykgLSAwKSA8IChlY2hhcnRzLmRlcGVuZGVuY2llcy56cmVuZGVyLnJlcGxhY2UoJy4nLCAnJykgLSAwKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgJ1pSZW5kZXIgJyArIHpyZW5kZXIudmVyc2lvblxuICAgICAgICAgICAgICAgICAgICArICcgaXMgdG9vIG9sZCBmb3IgRUNoYXJ0cyAnICsgZWNoYXJ0cy52ZXJzaW9uXG4gICAgICAgICAgICAgICAgICAgICsgJy4gQ3VycmVudCB2ZXJzaW9uIG5lZWQgWlJlbmRlciAnXG4gICAgICAgICAgICAgICAgICAgICsgZWNoYXJ0cy5kZXBlbmRlbmNpZXMuenJlbmRlciArICcrJ1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWRvbSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW5pdGlhbGl6ZSBmYWlsZWQ6IGludmFsaWQgZG9tLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHpyVXRpbC5pc0RvbShkb20pXG4gICAgICAgICAgICAgICAgJiYgZG9tLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgIT09ICdDQU5WQVMnXG4gICAgICAgICAgICAgICAgJiYgKFxuICAgICAgICAgICAgICAgICAgICAoIWRvbS5jbGllbnRXaWR0aCAmJiAoIW9wdHMgfHwgb3B0cy53aWR0aCA9PSBudWxsKSlcbiAgICAgICAgICAgICAgICAgICAgfHwgKCFkb20uY2xpZW50SGVpZ2h0ICYmICghb3B0cyB8fCBvcHRzLmhlaWdodCA9PSBudWxsKSlcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0NhblxcJ3QgZ2V0IGRvbSB3aWR0aCBvciBoZWlnaHQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjaGFydCA9IG5ldyBFQ2hhcnRzKGRvbSwgdGhlbWUsIG9wdHMpO1xuICAgICAgICBjaGFydC5pZCA9ICdlY18nICsgaWRCYXNlKys7XG4gICAgICAgIGluc3RhbmNlc1tjaGFydC5pZF0gPSBjaGFydDtcblxuICAgICAgICBkb20uc2V0QXR0cmlidXRlICYmXG4gICAgICAgICAgICBkb20uc2V0QXR0cmlidXRlKERPTV9BVFRSSUJVVEVfS0VZLCBjaGFydC5pZCk7XG5cbiAgICAgICAgZW5hYmxlQ29ubmVjdChjaGFydCk7XG5cbiAgICAgICAgcmV0dXJuIGNoYXJ0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd8QXJyYXkuPG1vZHVsZTplY2hhcnRzfkVDaGFydHM+fSBncm91cElkXG4gICAgICovXG4gICAgZWNoYXJ0cy5jb25uZWN0ID0gZnVuY3Rpb24gKGdyb3VwSWQpIHtcbiAgICAgICAgLy8gSXMgYXJyYXkgb2YgY2hhcnRzXG4gICAgICAgIGlmICh6clV0aWwuaXNBcnJheShncm91cElkKSkge1xuICAgICAgICAgICAgdmFyIGNoYXJ0cyA9IGdyb3VwSWQ7XG4gICAgICAgICAgICBncm91cElkID0gbnVsbDtcbiAgICAgICAgICAgIC8vIElmIGFueSBjaGFydCBoYXMgZ3JvdXBcbiAgICAgICAgICAgIHpyVXRpbC5lYWNoKGNoYXJ0cywgZnVuY3Rpb24gKGNoYXJ0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoYXJ0Lmdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBJZCA9IGNoYXJ0Lmdyb3VwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZ3JvdXBJZCA9IGdyb3VwSWQgfHwgKCdnXycgKyBncm91cElkQmFzZSsrKTtcbiAgICAgICAgICAgIHpyVXRpbC5lYWNoKGNoYXJ0cywgZnVuY3Rpb24gKGNoYXJ0KSB7XG4gICAgICAgICAgICAgICAgY2hhcnQuZ3JvdXAgPSBncm91cElkO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29ubmVjdGVkR3JvdXBzW2dyb3VwSWRdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGdyb3VwSWQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBERVBSRUNBVEVEXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBncm91cElkXG4gICAgICovXG4gICAgZWNoYXJ0cy5kaXNDb25uZWN0ID0gZnVuY3Rpb24gKGdyb3VwSWQpIHtcbiAgICAgICAgY29ubmVjdGVkR3JvdXBzW2dyb3VwSWRdID0gZmFsc2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gZ3JvdXBJZFxuICAgICAqL1xuICAgIGVjaGFydHMuZGlzY29ubmVjdCA9IGVjaGFydHMuZGlzQ29ubmVjdDtcblxuICAgIC8qKlxuICAgICAqIERpc3Bvc2UgYSBjaGFydCBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSAge21vZHVsZTplY2hhcnRzfkVDaGFydHN8SFRNTERvbUVsZW1lbnR8c3RyaW5nfSBjaGFydFxuICAgICAqL1xuICAgIGVjaGFydHMuZGlzcG9zZSA9IGZ1bmN0aW9uIChjaGFydCkge1xuICAgICAgICBpZiAoenJVdGlsLmlzRG9tKGNoYXJ0KSkge1xuICAgICAgICAgICAgY2hhcnQgPSBlY2hhcnRzLmdldEluc3RhbmNlQnlEb20oY2hhcnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBjaGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNoYXJ0ID0gaW5zdGFuY2VzW2NoYXJ0XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKGNoYXJ0IGluc3RhbmNlb2YgRUNoYXJ0cykgJiYgIWNoYXJ0LmlzRGlzcG9zZWQoKSkge1xuICAgICAgICAgICAgY2hhcnQuZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSAge0hUTUxEb21FbGVtZW50fSBkb21cbiAgICAgKiBAcmV0dXJuIHtlY2hhcnRzfkVDaGFydHN9XG4gICAgICovXG4gICAgZWNoYXJ0cy5nZXRJbnN0YW5jZUJ5RG9tID0gZnVuY3Rpb24gKGRvbSkge1xuICAgICAgICB2YXIga2V5ID0gZG9tLmdldEF0dHJpYnV0ZShET01fQVRUUklCVVRFX0tFWSk7XG4gICAgICAgIHJldHVybiBpbnN0YW5jZXNba2V5XTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICAgKiBAcmV0dXJuIHtlY2hhcnRzfkVDaGFydHN9XG4gICAgICovXG4gICAgZWNoYXJ0cy5nZXRJbnN0YW5jZUJ5SWQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiBpbnN0YW5jZXNba2V5XTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgdGhlbWVcbiAgICAgKi9cbiAgICBlY2hhcnRzLnJlZ2lzdGVyVGhlbWUgPSBmdW5jdGlvbiAobmFtZSwgdGhlbWUpIHtcbiAgICAgICAgdGhlbWVTdG9yYWdlW25hbWVdID0gdGhlbWU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIG9wdGlvbiBwcmVwcm9jZXNzb3JcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVwcm9jZXNzb3JGdW5jXG4gICAgICovXG4gICAgZWNoYXJ0cy5yZWdpc3RlclByZXByb2Nlc3NvciA9IGZ1bmN0aW9uIChwcmVwcm9jZXNzb3JGdW5jKSB7XG4gICAgICAgIG9wdGlvblByZXByb2Nlc3NvckZ1bmNzLnB1c2gocHJlcHJvY2Vzc29yRnVuYyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcHJpb3JpdHk9MTAwMF1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcm9jZXNzb3JGdW5jXG4gICAgICovXG4gICAgZWNoYXJ0cy5yZWdpc3RlclByb2Nlc3NvciA9IGZ1bmN0aW9uIChwcmlvcml0eSwgcHJvY2Vzc29yRnVuYykge1xuICAgICAgICBpZiAodHlwZW9mIHByaW9yaXR5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBwcm9jZXNzb3JGdW5jID0gcHJpb3JpdHk7XG4gICAgICAgICAgICBwcmlvcml0eSA9IFBSSU9SSVRZX1BST0NFU1NPUl9GSUxURVI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF9fREVWX18pIHtcbiAgICAgICAgICAgIGlmIChpc05hTihwcmlvcml0eSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua293biBwcm9jZXNzb3IgcHJpb3JpdHknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkYXRhUHJvY2Vzc29yRnVuY3MucHVzaCh7XG4gICAgICAgICAgICBwcmlvOiBwcmlvcml0eSxcbiAgICAgICAgICAgIGZ1bmM6IHByb2Nlc3NvckZ1bmNcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIHBvc3RVcGRhdGVyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcG9zdFVwZGF0ZUZ1bmNcbiAgICAgKi9cbiAgICBlY2hhcnRzLnJlZ2lzdGVyUG9zdFVwZGF0ZSA9IGZ1bmN0aW9uIChwb3N0VXBkYXRlRnVuYykge1xuICAgICAgICBwb3N0VXBkYXRlRnVuY3MucHVzaChwb3N0VXBkYXRlRnVuYyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFVzYWdlOlxuICAgICAqIHJlZ2lzdGVyQWN0aW9uKCdzb21lQWN0aW9uJywgJ3NvbWVFdmVudCcsIGZ1bmN0aW9uICgpIHsgLi4uIH0pO1xuICAgICAqIHJlZ2lzdGVyQWN0aW9uKCdzb21lQWN0aW9uJywgZnVuY3Rpb24gKCkgeyAuLi4gfSk7XG4gICAgICogcmVnaXN0ZXJBY3Rpb24oXG4gICAgICogICAgIHt0eXBlOiAnc29tZUFjdGlvbicsIGV2ZW50OiAnc29tZUV2ZW50JywgdXBkYXRlOiAndXBkYXRlVmlldyd9LFxuICAgICAqICAgICBmdW5jdGlvbiAoKSB7IC4uLiB9XG4gICAgICogKTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7KHN0cmluZ3xPYmplY3QpfSBhY3Rpb25JbmZvXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFjdGlvbkluZm8udHlwZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbYWN0aW9uSW5mby5ldmVudF1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2FjdGlvbkluZm8udXBkYXRlXVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbZXZlbnROYW1lXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGFjdGlvblxuICAgICAqL1xuICAgIGVjaGFydHMucmVnaXN0ZXJBY3Rpb24gPSBmdW5jdGlvbiAoYWN0aW9uSW5mbywgZXZlbnROYW1lLCBhY3Rpb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBldmVudE5hbWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGFjdGlvbiA9IGV2ZW50TmFtZTtcbiAgICAgICAgICAgIGV2ZW50TmFtZSA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhY3Rpb25UeXBlID0genJVdGlsLmlzT2JqZWN0KGFjdGlvbkluZm8pXG4gICAgICAgICAgICA/IGFjdGlvbkluZm8udHlwZVxuICAgICAgICAgICAgOiAoW2FjdGlvbkluZm8sIGFjdGlvbkluZm8gPSB7XG4gICAgICAgICAgICAgICAgZXZlbnQ6IGV2ZW50TmFtZVxuICAgICAgICAgICAgfV1bMF0pO1xuXG4gICAgICAgIC8vIEV2ZW50IG5hbWUgaXMgYWxsIGxvd2VyY2FzZVxuICAgICAgICBhY3Rpb25JbmZvLmV2ZW50ID0gKGFjdGlvbkluZm8uZXZlbnQgfHwgYWN0aW9uVHlwZSkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgZXZlbnROYW1lID0gYWN0aW9uSW5mby5ldmVudDtcblxuICAgICAgICAvLyBWYWxpZGF0ZSBhY3Rpb24gdHlwZSBhbmQgZXZlbnQgbmFtZS5cbiAgICAgICAgenJVdGlsLmFzc2VydChBQ1RJT05fUkVHLnRlc3QoYWN0aW9uVHlwZSkgJiYgQUNUSU9OX1JFRy50ZXN0KGV2ZW50TmFtZSkpO1xuXG4gICAgICAgIGlmICghYWN0aW9uc1thY3Rpb25UeXBlXSkge1xuICAgICAgICAgICAgYWN0aW9uc1thY3Rpb25UeXBlXSA9IHthY3Rpb246IGFjdGlvbiwgYWN0aW9uSW5mbzogYWN0aW9uSW5mb307XG4gICAgICAgIH1cbiAgICAgICAgZXZlbnRBY3Rpb25NYXBbZXZlbnROYW1lXSA9IGFjdGlvblR5cGU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAgICogQHBhcmFtIHsqfSBDb29yZGluYXRlU3lzdGVtXG4gICAgICovXG4gICAgZWNoYXJ0cy5yZWdpc3RlckNvb3JkaW5hdGVTeXN0ZW0gPSBmdW5jdGlvbiAodHlwZSwgQ29vcmRpbmF0ZVN5c3RlbSkge1xuICAgICAgICBDb29yZGluYXRlU3lzdGVtTWFuYWdlci5yZWdpc3Rlcih0eXBlLCBDb29yZGluYXRlU3lzdGVtKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTGF5b3V0IGlzIGEgc3BlY2lhbCBzdGFnZSBvZiB2aXN1YWwgZW5jb2RpbmdcbiAgICAgKiBNb3N0IHZpc3VhbCBlbmNvZGluZyBsaWtlIGNvbG9yIGFyZSBjb21tb24gZm9yIGRpZmZlcmVudCBjaGFydFxuICAgICAqIEJ1dCBlYWNoIGNoYXJ0IGhhcyBpdCdzIG93biBsYXlvdXQgYWxnb3JpdGhtXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ByaW9yaXR5PTEwMDBdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGF5b3V0RnVuY1xuICAgICAqL1xuICAgIGVjaGFydHMucmVnaXN0ZXJMYXlvdXQgPSBmdW5jdGlvbiAocHJpb3JpdHksIGxheW91dEZ1bmMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwcmlvcml0eSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgbGF5b3V0RnVuYyA9IHByaW9yaXR5O1xuICAgICAgICAgICAgcHJpb3JpdHkgPSBQUklPUklUWV9WSVNVQUxfTEFZT1VUO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgICAgICBpZiAoaXNOYU4ocHJpb3JpdHkpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtvd24gbGF5b3V0IHByaW9yaXR5Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmlzdWFsRnVuY3MucHVzaCh7XG4gICAgICAgICAgICBwcmlvOiBwcmlvcml0eSxcbiAgICAgICAgICAgIGZ1bmM6IGxheW91dEZ1bmMsXG4gICAgICAgICAgICBpc0xheW91dDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwcmlvcml0eT0zMDAwXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHZpc3VhbEZ1bmNcbiAgICAgKi9cbiAgICBlY2hhcnRzLnJlZ2lzdGVyVmlzdWFsID0gZnVuY3Rpb24gKHByaW9yaXR5LCB2aXN1YWxGdW5jKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcHJpb3JpdHkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZpc3VhbEZ1bmMgPSBwcmlvcml0eTtcbiAgICAgICAgICAgIHByaW9yaXR5ID0gUFJJT1JJVFlfVklTVUFMX0NIQVJUO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgICAgICBpZiAoaXNOYU4ocHJpb3JpdHkpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtvd24gdmlzdWFsIHByaW9yaXR5Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmlzdWFsRnVuY3MucHVzaCh7XG4gICAgICAgICAgICBwcmlvOiBwcmlvcml0eSxcbiAgICAgICAgICAgIGZ1bmM6IHZpc3VhbEZ1bmNcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICovXG4gICAgZWNoYXJ0cy5yZWdpc3RlckxvYWRpbmcgPSBmdW5jdGlvbiAobmFtZSwgbG9hZGluZ0Z4KSB7XG4gICAgICAgIGxvYWRpbmdFZmZlY3RzW25hbWVdID0gbG9hZGluZ0Z4O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3VwZXJDbGFzc11cbiAgICAgKi9cbiAgICBlY2hhcnRzLmV4dGVuZENvbXBvbmVudE1vZGVsID0gZnVuY3Rpb24gKG9wdHMvKiwgc3VwZXJDbGFzcyovKSB7XG4gICAgICAgIC8vIHZhciBDbGF6eiA9IENvbXBvbmVudE1vZGVsO1xuICAgICAgICAvLyBpZiAoc3VwZXJDbGFzcykge1xuICAgICAgICAvLyAgICAgdmFyIGNsYXNzVHlwZSA9IHBhcnNlQ2xhc3NUeXBlKHN1cGVyQ2xhc3MpO1xuICAgICAgICAvLyAgICAgQ2xhenogPSBDb21wb25lbnRNb2RlbC5nZXRDbGFzcyhjbGFzc1R5cGUubWFpbiwgY2xhc3NUeXBlLnN1YiwgdHJ1ZSk7XG4gICAgICAgIC8vIH1cbiAgICAgICAgcmV0dXJuIENvbXBvbmVudE1vZGVsLmV4dGVuZChvcHRzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N1cGVyQ2xhc3NdXG4gICAgICovXG4gICAgZWNoYXJ0cy5leHRlbmRDb21wb25lbnRWaWV3ID0gZnVuY3Rpb24gKG9wdHMvKiwgc3VwZXJDbGFzcyovKSB7XG4gICAgICAgIC8vIHZhciBDbGF6eiA9IENvbXBvbmVudFZpZXc7XG4gICAgICAgIC8vIGlmIChzdXBlckNsYXNzKSB7XG4gICAgICAgIC8vICAgICB2YXIgY2xhc3NUeXBlID0gcGFyc2VDbGFzc1R5cGUoc3VwZXJDbGFzcyk7XG4gICAgICAgIC8vICAgICBDbGF6eiA9IENvbXBvbmVudFZpZXcuZ2V0Q2xhc3MoY2xhc3NUeXBlLm1haW4sIGNsYXNzVHlwZS5zdWIsIHRydWUpO1xuICAgICAgICAvLyB9XG4gICAgICAgIHJldHVybiBDb21wb25lbnRWaWV3LmV4dGVuZChvcHRzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N1cGVyQ2xhc3NdXG4gICAgICovXG4gICAgZWNoYXJ0cy5leHRlbmRTZXJpZXNNb2RlbCA9IGZ1bmN0aW9uIChvcHRzLyosIHN1cGVyQ2xhc3MqLykge1xuICAgICAgICAvLyB2YXIgQ2xhenogPSBTZXJpZXNNb2RlbDtcbiAgICAgICAgLy8gaWYgKHN1cGVyQ2xhc3MpIHtcbiAgICAgICAgLy8gICAgIHN1cGVyQ2xhc3MgPSAnc2VyaWVzLicgKyBzdXBlckNsYXNzLnJlcGxhY2UoJ3Nlcmllcy4nLCAnJyk7XG4gICAgICAgIC8vICAgICB2YXIgY2xhc3NUeXBlID0gcGFyc2VDbGFzc1R5cGUoc3VwZXJDbGFzcyk7XG4gICAgICAgIC8vICAgICBDbGF6eiA9IENvbXBvbmVudE1vZGVsLmdldENsYXNzKGNsYXNzVHlwZS5tYWluLCBjbGFzc1R5cGUuc3ViLCB0cnVlKTtcbiAgICAgICAgLy8gfVxuICAgICAgICByZXR1cm4gU2VyaWVzTW9kZWwuZXh0ZW5kKG9wdHMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3VwZXJDbGFzc11cbiAgICAgKi9cbiAgICBlY2hhcnRzLmV4dGVuZENoYXJ0VmlldyA9IGZ1bmN0aW9uIChvcHRzLyosIHN1cGVyQ2xhc3MqLykge1xuICAgICAgICAvLyB2YXIgQ2xhenogPSBDaGFydFZpZXc7XG4gICAgICAgIC8vIGlmIChzdXBlckNsYXNzKSB7XG4gICAgICAgIC8vICAgICBzdXBlckNsYXNzID0gc3VwZXJDbGFzcy5yZXBsYWNlKCdzZXJpZXMuJywgJycpO1xuICAgICAgICAvLyAgICAgdmFyIGNsYXNzVHlwZSA9IHBhcnNlQ2xhc3NUeXBlKHN1cGVyQ2xhc3MpO1xuICAgICAgICAvLyAgICAgQ2xhenogPSBDaGFydFZpZXcuZ2V0Q2xhc3MoY2xhc3NUeXBlLm1haW4sIHRydWUpO1xuICAgICAgICAvLyB9XG4gICAgICAgIHJldHVybiBDaGFydFZpZXcuZXh0ZW5kKG9wdHMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBaUmVuZGVyIG5lZWQgYSBjYW52YXMgY29udGV4dCB0byBkbyBtZWFzdXJlVGV4dC5cbiAgICAgKiBCdXQgaW4gbm9kZSBlbnZpcm9ubWVudCBjYW52YXMgbWF5IGJlIGNyZWF0ZWQgYnkgbm9kZS1jYW52YXMuXG4gICAgICogU28gd2UgbmVlZCB0byBzcGVjaWZ5IGhvdyB0byBjcmVhdGUgYSBjYW52YXMgaW5zdGVhZCBvZiB1c2luZyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKVxuICAgICAqXG4gICAgICogQmUgY2FyZWZ1bCBvZiB1c2luZyBpdCBpbiB0aGUgYnJvd3Nlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNyZWF0b3JcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgICB2YXIgQ2FudmFzID0gcmVxdWlyZSgnY2FudmFzJyk7XG4gICAgICogICAgIHZhciBlY2hhcnRzID0gcmVxdWlyZSgnZWNoYXJ0cycpO1xuICAgICAqICAgICBlY2hhcnRzLnNldENhbnZhc0NyZWF0b3IoZnVuY3Rpb24gKCkge1xuICAgICAqICAgICAgICAgLy8gU21hbGwgc2l6ZSBpcyBlbm91Z2guXG4gICAgICogICAgICAgICByZXR1cm4gbmV3IENhbnZhcygzMiwgMzIpO1xuICAgICAqICAgICB9KTtcbiAgICAgKi9cbiAgICBlY2hhcnRzLnNldENhbnZhc0NyZWF0b3IgPSBmdW5jdGlvbiAoY3JlYXRvcikge1xuICAgICAgICB6clV0aWwuY3JlYXRlQ2FudmFzID0gY3JlYXRvcjtcbiAgICB9O1xuXG4gICAgZWNoYXJ0cy5yZWdpc3RlclZpc3VhbChQUklPUklUWV9WSVNVQUxfR0xPQkFMLCByZXF1aXJlKCcuL3Zpc3VhbC9zZXJpZXNDb2xvcicpKTtcbiAgICBlY2hhcnRzLnJlZ2lzdGVyUHJlcHJvY2Vzc29yKHJlcXVpcmUoJy4vcHJlcHJvY2Vzc29yL2JhY2t3YXJkQ29tcGF0JykpO1xuICAgIGVjaGFydHMucmVnaXN0ZXJMb2FkaW5nKCdkZWZhdWx0JywgcmVxdWlyZSgnLi9sb2FkaW5nL2RlZmF1bHQnKSk7XG5cbiAgICAvLyBEZWZhdWx0IGFjdGlvblxuICAgIGVjaGFydHMucmVnaXN0ZXJBY3Rpb24oe1xuICAgICAgICB0eXBlOiAnaGlnaGxpZ2h0JyxcbiAgICAgICAgZXZlbnQ6ICdoaWdobGlnaHQnLFxuICAgICAgICB1cGRhdGU6ICdoaWdobGlnaHQnXG4gICAgfSwgenJVdGlsLm5vb3ApO1xuICAgIGVjaGFydHMucmVnaXN0ZXJBY3Rpb24oe1xuICAgICAgICB0eXBlOiAnZG93bnBsYXknLFxuICAgICAgICBldmVudDogJ2Rvd25wbGF5JyxcbiAgICAgICAgdXBkYXRlOiAnZG93bnBsYXknXG4gICAgfSwgenJVdGlsLm5vb3ApO1xuXG5cbiAgICAvLyAtLS0tLS0tLVxuICAgIC8vIEV4cG9ydHNcbiAgICAvLyAtLS0tLS0tLVxuICAgIGVjaGFydHMuenJlbmRlciA9IHpyZW5kZXI7XG5cbiAgICBlY2hhcnRzLkxpc3QgPSByZXF1aXJlKCcuL2RhdGEvTGlzdCcpO1xuICAgIGVjaGFydHMuTW9kZWwgPSByZXF1aXJlKCcuL21vZGVsL01vZGVsJyk7XG5cbiAgICBlY2hhcnRzLkF4aXMgPSByZXF1aXJlKCcuL2Nvb3JkL0F4aXMnKTtcblxuICAgIGVjaGFydHMuZ3JhcGhpYyA9IHJlcXVpcmUoJy4vdXRpbC9ncmFwaGljJyk7XG4gICAgZWNoYXJ0cy5udW1iZXIgPSByZXF1aXJlKCcuL3V0aWwvbnVtYmVyJyk7XG4gICAgZWNoYXJ0cy5mb3JtYXQgPSByZXF1aXJlKCcuL3V0aWwvZm9ybWF0Jyk7XG4gICAgZWNoYXJ0cy50aHJvdHRsZSA9IHRocm90dGxlLnRocm90dGxlO1xuICAgIGVjaGFydHMubWF0cml4ID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS9tYXRyaXgnKTtcbiAgICBlY2hhcnRzLnZlY3RvciA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdmVjdG9yJyk7XG4gICAgZWNoYXJ0cy5jb2xvciA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL3Rvb2wvY29sb3InKTtcblxuICAgIGVjaGFydHMudXRpbCA9IHt9O1xuICAgIGVhY2goW1xuICAgICAgICAgICAgJ21hcCcsICdlYWNoJywgJ2ZpbHRlcicsICdpbmRleE9mJywgJ2luaGVyaXRzJywgJ3JlZHVjZScsICdmaWx0ZXInLFxuICAgICAgICAgICAgJ2JpbmQnLCAnY3VycnknLCAnaXNBcnJheScsICdpc1N0cmluZycsICdpc09iamVjdCcsICdpc0Z1bmN0aW9uJyxcbiAgICAgICAgICAgICdleHRlbmQnLCAnZGVmYXVsdHMnLCAnY2xvbmUnLCAnbWVyZ2UnXG4gICAgICAgIF0sXG4gICAgICAgIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICBlY2hhcnRzLnV0aWxbbmFtZV0gPSB6clV0aWxbbmFtZV07XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgZWNoYXJ0cy5oZWxwZXIgPSByZXF1aXJlKCcuL2hlbHBlcicpO1xuXG5cbiAgICAvLyBQUklPUklUWVxuICAgIGVjaGFydHMuUFJJT1JJVFkgPSB7XG4gICAgICAgIFBST0NFU1NPUjoge1xuICAgICAgICAgICAgRklMVEVSOiBQUklPUklUWV9QUk9DRVNTT1JfRklMVEVSLFxuICAgICAgICAgICAgU1RBVElTVElDOiBQUklPUklUWV9QUk9DRVNTT1JfU1RBVElTVElDXG4gICAgICAgIH0sXG4gICAgICAgIFZJU1VBTDoge1xuICAgICAgICAgICAgTEFZT1VUOiBQUklPUklUWV9WSVNVQUxfTEFZT1VULFxuICAgICAgICAgICAgR0xPQkFMOiBQUklPUklUWV9WSVNVQUxfR0xPQkFMLFxuICAgICAgICAgICAgQ0hBUlQ6IFBSSU9SSVRZX1ZJU1VBTF9DSEFSVCxcbiAgICAgICAgICAgIENPTVBPTkVOVDogUFJJT1JJVFlfVklTVUFMX0NPTVBPTkVOVCxcbiAgICAgICAgICAgIEJSVVNIOiBQUklPUklUWV9WSVNVQUxfQlJVU0hcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGVjaGFydHM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9lY2hhcnRzLmpzXG4vLyBtb2R1bGUgaWQgPSAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 2 */
/* unknown exports provided */
/* all exports used */
/*!*****************************!*\
  !*** ./lib/util/graphic.js ***!
  \*****************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\n    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 0);\n\n    var pathTool = __webpack_require__(/*! zrender/lib/tool/path */ 130);\n    var round = Math.round;\n    var Path = __webpack_require__(/*! zrender/lib/graphic/Path */ 7);\n    var colorTool = __webpack_require__(/*! zrender/lib/tool/color */ 21);\n    var matrix = __webpack_require__(/*! zrender/lib/core/matrix */ 18);\n    var vector = __webpack_require__(/*! zrender/lib/core/vector */ 4);\n    var Transformable = __webpack_require__(/*! zrender/lib/mixin/Transformable */ 54);\n    var BoundingRect = __webpack_require__(/*! zrender/lib/core/BoundingRect */ 10);\n\n    var graphic = {};\n\n    graphic.Group = __webpack_require__(/*! zrender/lib/container/Group */ 33);\n\n    graphic.Image = __webpack_require__(/*! zrender/lib/graphic/Image */ 53);\n\n    graphic.Text = __webpack_require__(/*! zrender/lib/graphic/Text */ 77);\n\n    graphic.Circle = __webpack_require__(/*! zrender/lib/graphic/shape/Circle */ 121);\n\n    graphic.Sector = __webpack_require__(/*! zrender/lib/graphic/shape/Sector */ 127);\n\n    graphic.Ring = __webpack_require__(/*! zrender/lib/graphic/shape/Ring */ 126);\n\n    graphic.Polygon = __webpack_require__(/*! zrender/lib/graphic/shape/Polygon */ 123);\n\n    graphic.Polyline = __webpack_require__(/*! zrender/lib/graphic/shape/Polyline */ 124);\n\n    graphic.Rect = __webpack_require__(/*! zrender/lib/graphic/shape/Rect */ 125);\n\n    graphic.Line = __webpack_require__(/*! zrender/lib/graphic/shape/Line */ 122);\n\n    graphic.BezierCurve = __webpack_require__(/*! zrender/lib/graphic/shape/BezierCurve */ 120);\n\n    graphic.Arc = __webpack_require__(/*! zrender/lib/graphic/shape/Arc */ 119);\n\n    graphic.CompoundPath = __webpack_require__(/*! zrender/lib/graphic/CompoundPath */ 114);\n\n    graphic.LinearGradient = __webpack_require__(/*! zrender/lib/graphic/LinearGradient */ 93);\n\n    graphic.RadialGradient = __webpack_require__(/*! zrender/lib/graphic/RadialGradient */ 115);\n\n    graphic.BoundingRect = BoundingRect;\n\n    /**\n     * Extend shape with parameters\n     */\n    graphic.extendShape = function (opts) {\n        return Path.extend(opts);\n    };\n\n    /**\n     * Extend path\n     */\n    graphic.extendPath = function (pathData, opts) {\n        return pathTool.extendFromString(pathData, opts);\n    };\n\n    /**\n     * Create a path element from path data string\n     * @param {string} pathData\n     * @param {Object} opts\n     * @param {module:zrender/core/BoundingRect} rect\n     * @param {string} [layout=cover] 'center' or 'cover'\n     */\n    graphic.makePath = function (pathData, opts, rect, layout) {\n        var path = pathTool.createFromString(pathData, opts);\n        var boundingRect = path.getBoundingRect();\n        if (rect) {\n            var aspect = boundingRect.width / boundingRect.height;\n\n            if (layout === 'center') {\n                // Set rect to center, keep width / height ratio.\n                var width = rect.height * aspect;\n                var height;\n                if (width <= rect.width) {\n                    height = rect.height;\n                }\n                else {\n                    width = rect.width;\n                    height = width / aspect;\n                }\n                var cx = rect.x + rect.width / 2;\n                var cy = rect.y + rect.height / 2;\n\n                rect.x = cx - width / 2;\n                rect.y = cy - height / 2;\n                rect.width = width;\n                rect.height = height;\n            }\n\n            graphic.resizePath(path, rect);\n        }\n        return path;\n    };\n\n    graphic.mergePath = pathTool.mergePath,\n\n    /**\n     * Resize a path to fit the rect\n     * @param {module:zrender/graphic/Path} path\n     * @param {Object} rect\n     */\n    graphic.resizePath = function (path, rect) {\n        if (!path.applyTransform) {\n            return;\n        }\n\n        var pathRect = path.getBoundingRect();\n\n        var m = pathRect.calculateTransform(rect);\n\n        path.applyTransform(m);\n    };\n\n    /**\n     * Sub pixel optimize line for canvas\n     *\n     * @param {Object} param\n     * @param {Object} [param.shape]\n     * @param {number} [param.shape.x1]\n     * @param {number} [param.shape.y1]\n     * @param {number} [param.shape.x2]\n     * @param {number} [param.shape.y2]\n     * @param {Object} [param.style]\n     * @param {number} [param.style.lineWidth]\n     * @return {Object} Modified param\n     */\n    graphic.subPixelOptimizeLine = function (param) {\n        var subPixelOptimize = graphic.subPixelOptimize;\n        var shape = param.shape;\n        var lineWidth = param.style.lineWidth;\n\n        if (round(shape.x1 * 2) === round(shape.x2 * 2)) {\n            shape.x1 = shape.x2 = subPixelOptimize(shape.x1, lineWidth, true);\n        }\n        if (round(shape.y1 * 2) === round(shape.y2 * 2)) {\n            shape.y1 = shape.y2 = subPixelOptimize(shape.y1, lineWidth, true);\n        }\n        return param;\n    };\n\n    /**\n     * Sub pixel optimize rect for canvas\n     *\n     * @param {Object} param\n     * @param {Object} [param.shape]\n     * @param {number} [param.shape.x]\n     * @param {number} [param.shape.y]\n     * @param {number} [param.shape.width]\n     * @param {number} [param.shape.height]\n     * @param {Object} [param.style]\n     * @param {number} [param.style.lineWidth]\n     * @return {Object} Modified param\n     */\n    graphic.subPixelOptimizeRect = function (param) {\n        var subPixelOptimize = graphic.subPixelOptimize;\n        var shape = param.shape;\n        var lineWidth = param.style.lineWidth;\n        var originX = shape.x;\n        var originY = shape.y;\n        var originWidth = shape.width;\n        var originHeight = shape.height;\n        shape.x = subPixelOptimize(shape.x, lineWidth, true);\n        shape.y = subPixelOptimize(shape.y, lineWidth, true);\n        shape.width = Math.max(\n            subPixelOptimize(originX + originWidth, lineWidth, false) - shape.x,\n            originWidth === 0 ? 0 : 1\n        );\n        shape.height = Math.max(\n            subPixelOptimize(originY + originHeight, lineWidth, false) - shape.y,\n            originHeight === 0 ? 0 : 1\n        );\n        return param;\n    };\n\n    /**\n     * Sub pixel optimize for canvas\n     *\n     * @param {number} position Coordinate, such as x, y\n     * @param {number} lineWidth Should be nonnegative integer.\n     * @param {boolean=} positiveOrNegative Default false (negative).\n     * @return {number} Optimized position.\n     */\n    graphic.subPixelOptimize = function (position, lineWidth, positiveOrNegative) {\n        // Assure that (position + lineWidth / 2) is near integer edge,\n        // otherwise line will be fuzzy in canvas.\n        var doubledPosition = round(position * 2);\n        return (doubledPosition + round(lineWidth)) % 2 === 0\n            ? doubledPosition / 2\n            : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;\n    };\n\n    function hasFillOrStroke(fillOrStroke) {\n        return fillOrStroke != null && fillOrStroke != 'none';\n    }\n\n    function liftColor(color) {\n        return typeof color === 'string' ? colorTool.lift(color, -0.1) : color;\n    }\n\n    /**\n     * @private\n     */\n    function cacheElementStl(el) {\n        if (el.__hoverStlDirty) {\n            var stroke = el.style.stroke;\n            var fill = el.style.fill;\n\n            // Create hoverStyle on mouseover\n            var hoverStyle = el.__hoverStl;\n            hoverStyle.fill = hoverStyle.fill\n                || (hasFillOrStroke(fill) ? liftColor(fill) : null);\n            hoverStyle.stroke = hoverStyle.stroke\n                || (hasFillOrStroke(stroke) ? liftColor(stroke) : null);\n\n            var normalStyle = {};\n            for (var name in hoverStyle) {\n                if (hoverStyle.hasOwnProperty(name)) {\n                    normalStyle[name] = el.style[name];\n                }\n            }\n\n            el.__normalStl = normalStyle;\n\n            el.__hoverStlDirty = false;\n        }\n    }\n\n    /**\n     * @private\n     */\n    function doSingleEnterHover(el) {\n        if (el.__isHover) {\n            return;\n        }\n\n        cacheElementStl(el);\n\n        if (el.useHoverLayer) {\n            el.__zr && el.__zr.addHover(el, el.__hoverStl);\n        }\n        else {\n            el.setStyle(el.__hoverStl);\n            el.z2 += 1;\n        }\n\n        el.__isHover = true;\n    }\n\n    /**\n     * @inner\n     */\n    function doSingleLeaveHover(el) {\n        if (!el.__isHover) {\n            return;\n        }\n\n        var normalStl = el.__normalStl;\n        if (el.useHoverLayer) {\n            el.__zr && el.__zr.removeHover(el);\n        }\n        else {\n            normalStl && el.setStyle(normalStl);\n            el.z2 -= 1;\n        }\n\n        el.__isHover = false;\n    }\n\n    /**\n     * @inner\n     */\n    function doEnterHover(el) {\n        el.type === 'group'\n            ? el.traverse(function (child) {\n                if (child.type !== 'group') {\n                    doSingleEnterHover(child);\n                }\n            })\n            : doSingleEnterHover(el);\n    }\n\n    function doLeaveHover(el) {\n        el.type === 'group'\n            ? el.traverse(function (child) {\n                if (child.type !== 'group') {\n                    doSingleLeaveHover(child);\n                }\n            })\n            : doSingleLeaveHover(el);\n    }\n\n    /**\n     * @inner\n     */\n    function setElementHoverStl(el, hoverStl) {\n        // If element has sepcified hoverStyle, then use it instead of given hoverStyle\n        // Often used when item group has a label element and it's hoverStyle is different\n        el.__hoverStl = el.hoverStyle || hoverStl || {};\n        el.__hoverStlDirty = true;\n\n        if (el.__isHover) {\n            cacheElementStl(el);\n        }\n    }\n\n    /**\n     * @inner\n     */\n    function onElementMouseOver(e) {\n        if (this.__hoverSilentOnTouch && e.zrByTouch) {\n            return;\n        }\n\n        // Only if element is not in emphasis status\n        !this.__isEmphasis && doEnterHover(this);\n    }\n\n    /**\n     * @inner\n     */\n    function onElementMouseOut(e) {\n        if (this.__hoverSilentOnTouch && e.zrByTouch) {\n            return;\n        }\n\n        // Only if element is not in emphasis status\n        !this.__isEmphasis && doLeaveHover(this);\n    }\n\n    /**\n     * @inner\n     */\n    function enterEmphasis() {\n        this.__isEmphasis = true;\n        doEnterHover(this);\n    }\n\n    /**\n     * @inner\n     */\n    function leaveEmphasis() {\n        this.__isEmphasis = false;\n        doLeaveHover(this);\n    }\n\n    /**\n     * Set hover style of element.\n     * This method can be called repeatly without side-effects.\n     * @param {module:zrender/Element} el\n     * @param {Object} [hoverStyle]\n     * @param {Object} [opt]\n     * @param {boolean} [opt.hoverSilentOnTouch=false]\n     *        In touch device, mouseover event will be trigger on touchstart event\n     *        (see module:zrender/dom/HandlerProxy). By this mechanism, we can\n     *        conviniently use hoverStyle when tap on touch screen without additional\n     *        code for compatibility.\n     *        But if the chart/component has select feature, which usually also use\n     *        hoverStyle, there might be conflict between 'select-highlight' and\n     *        'hover-highlight' especially when roam is enabled (see geo for example).\n     *        In this case, hoverSilentOnTouch should be used to disable hover-highlight\n     *        on touch device.\n     */\n    graphic.setHoverStyle = function (el, hoverStyle, opt) {\n        el.__hoverSilentOnTouch = opt && opt.hoverSilentOnTouch;\n\n        el.type === 'group'\n            ? el.traverse(function (child) {\n                if (child.type !== 'group') {\n                    setElementHoverStl(child, hoverStyle);\n                }\n            })\n            : setElementHoverStl(el, hoverStyle);\n\n        // Duplicated function will be auto-ignored, see Eventful.js.\n        el.on('mouseover', onElementMouseOver)\n          .on('mouseout', onElementMouseOut);\n\n        // Emphasis, normal can be triggered manually\n        el.on('emphasis', enterEmphasis)\n          .on('normal', leaveEmphasis);\n    };\n\n    /**\n     * Set text option in the style\n     * @param {Object} textStyle\n     * @param {module:echarts/model/Model} labelModel\n     * @param {string} color\n     */\n    graphic.setText = function (textStyle, labelModel, color) {\n        var labelPosition = labelModel.getShallow('position') || 'inside';\n        var labelOffset = labelModel.getShallow('offset');\n        var labelColor = labelPosition.indexOf('inside') >= 0 ? 'white' : color;\n        var textStyleModel = labelModel.getModel('textStyle');\n        zrUtil.extend(textStyle, {\n            textDistance: labelModel.getShallow('distance') || 5,\n            textFont: textStyleModel.getFont(),\n            textPosition: labelPosition,\n            textOffset: labelOffset,\n            textFill: textStyleModel.getTextColor() || labelColor\n        });\n    };\n\n    function animateOrSetProps(isUpdate, el, props, animatableModel, dataIndex, cb) {\n        if (typeof dataIndex === 'function') {\n            cb = dataIndex;\n            dataIndex = null;\n        }\n        // Do not check 'animation' property directly here. Consider this case:\n        // animation model is an `itemModel`, whose does not have `isAnimationEnabled`\n        // but its parent model (`seriesModel`) does.\n        var animationEnabled = animatableModel && animatableModel.isAnimationEnabled();\n\n        if (animationEnabled) {\n            var postfix = isUpdate ? 'Update' : '';\n            var duration = animatableModel.getShallow('animationDuration' + postfix);\n            var animationEasing = animatableModel.getShallow('animationEasing' + postfix);\n            var animationDelay = animatableModel.getShallow('animationDelay' + postfix);\n            if (typeof animationDelay === 'function') {\n                animationDelay = animationDelay(\n                    dataIndex,\n                    animatableModel.getAnimationDelayParams\n                        ? animatableModel.getAnimationDelayParams(el, dataIndex)\n                        : null\n                );\n            }\n            if (typeof duration === 'function') {\n                duration = duration(dataIndex);\n            }\n\n            duration > 0\n                ? el.animateTo(props, duration, animationDelay || 0, animationEasing, cb)\n                : (el.stopAnimation(), el.attr(props), cb && cb());\n        }\n        else {\n            el.stopAnimation();\n            el.attr(props);\n            cb && cb();\n        }\n    }\n\n    /**\n     * Update graphic element properties with or without animation according to the configuration in series\n     * @param {module:zrender/Element} el\n     * @param {Object} props\n     * @param {module:echarts/model/Model} [animatableModel]\n     * @param {number} [dataIndex]\n     * @param {Function} [cb]\n     * @example\n     *     graphic.updateProps(el, {\n     *         position: [100, 100]\n     *     }, seriesModel, dataIndex, function () { console.log('Animation done!'); });\n     *     // Or\n     *     graphic.updateProps(el, {\n     *         position: [100, 100]\n     *     }, seriesModel, function () { console.log('Animation done!'); });\n     */\n    graphic.updateProps = function (el, props, animatableModel, dataIndex, cb) {\n        animateOrSetProps(true, el, props, animatableModel, dataIndex, cb);\n    };\n\n    /**\n     * Init graphic element properties with or without animation according to the configuration in series\n     * @param {module:zrender/Element} el\n     * @param {Object} props\n     * @param {module:echarts/model/Model} [animatableModel]\n     * @param {number} [dataIndex]\n     * @param {Function} cb\n     */\n    graphic.initProps = function (el, props, animatableModel, dataIndex, cb) {\n        animateOrSetProps(false, el, props, animatableModel, dataIndex, cb);\n    };\n\n    /**\n     * Get transform matrix of target (param target),\n     * in coordinate of its ancestor (param ancestor)\n     *\n     * @param {module:zrender/mixin/Transformable} target\n     * @param {module:zrender/mixin/Transformable} [ancestor]\n     */\n    graphic.getTransform = function (target, ancestor) {\n        var mat = matrix.identity([]);\n\n        while (target && target !== ancestor) {\n            matrix.mul(mat, target.getLocalTransform(), mat);\n            target = target.parent;\n        }\n\n        return mat;\n    };\n\n    /**\n     * Apply transform to an vertex.\n     * @param {Array.<number>} target [x, y]\n     * @param {Array.<number>|TypedArray.<number>|Object} transform Can be:\n     *      + Transform matrix: like [1, 0, 0, 1, 0, 0]\n     *      + {position, rotation, scale}, the same as `zrender/Transformable`.\n     * @param {boolean=} invert Whether use invert matrix.\n     * @return {Array.<number>} [x, y]\n     */\n    graphic.applyTransform = function (target, transform, invert) {\n        if (transform && !zrUtil.isArrayLike(transform)) {\n            transform = Transformable.getLocalTransform(transform);\n        }\n\n        if (invert) {\n            transform = matrix.invert([], transform);\n        }\n        return vector.applyTransform([], target, transform);\n    };\n\n    /**\n     * @param {string} direction 'left' 'right' 'top' 'bottom'\n     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]\n     * @param {boolean=} invert Whether use invert matrix.\n     * @return {string} Transformed direction. 'left' 'right' 'top' 'bottom'\n     */\n    graphic.transformDirection = function (direction, transform, invert) {\n\n        // Pick a base, ensure that transform result will not be (0, 0).\n        var hBase = (transform[4] === 0 || transform[5] === 0 || transform[0] === 0)\n            ? 1 : Math.abs(2 * transform[4] / transform[0]);\n        var vBase = (transform[4] === 0 || transform[5] === 0 || transform[2] === 0)\n            ? 1 : Math.abs(2 * transform[4] / transform[2]);\n\n        var vertex = [\n            direction === 'left' ? -hBase : direction === 'right' ? hBase : 0,\n            direction === 'top' ? -vBase : direction === 'bottom' ? vBase : 0\n        ];\n\n        vertex = graphic.applyTransform(vertex, transform, invert);\n\n        return Math.abs(vertex[0]) > Math.abs(vertex[1])\n            ? (vertex[0] > 0 ? 'right' : 'left')\n            : (vertex[1] > 0 ? 'bottom' : 'top');\n    };\n\n    /**\n     * Apply group transition animation from g1 to g2.\n     * If no animatableModel, no animation.\n     */\n    graphic.groupTransition = function (g1, g2, animatableModel, cb) {\n        if (!g1 || !g2) {\n            return;\n        }\n\n        function getElMap(g) {\n            var elMap = {};\n            g.traverse(function (el) {\n                if (!el.isGroup && el.anid) {\n                    elMap[el.anid] = el;\n                }\n            });\n            return elMap;\n        }\n        function getAnimatableProps(el) {\n            var obj = {\n                position: vector.clone(el.position),\n                rotation: el.rotation\n            };\n            if (el.shape) {\n                obj.shape = zrUtil.extend({}, el.shape);\n            }\n            return obj;\n        }\n        var elMap1 = getElMap(g1);\n\n        g2.traverse(function (el) {\n            if (!el.isGroup && el.anid) {\n                var oldEl = elMap1[el.anid];\n                if (oldEl) {\n                    var newProp = getAnimatableProps(el);\n                    el.attr(getAnimatableProps(oldEl));\n                    graphic.updateProps(el, newProp, animatableModel, el.dataIndex);\n                }\n                // else {\n                //     if (el.previousProps) {\n                //         graphic.updateProps\n                //     }\n                // }\n            }\n        });\n    };\n\n    module.exports = graphic;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2xpYi91dGlsL2dyYXBoaWMuanM/OTE4NCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcblxuICAgIHZhciBwYXRoVG9vbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL3Rvb2wvcGF0aCcpO1xuICAgIHZhciByb3VuZCA9IE1hdGgucm91bmQ7XG4gICAgdmFyIFBhdGggPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9ncmFwaGljL1BhdGgnKTtcbiAgICB2YXIgY29sb3JUb29sID0gcmVxdWlyZSgnenJlbmRlci9saWIvdG9vbC9jb2xvcicpO1xuICAgIHZhciBtYXRyaXggPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL21hdHJpeCcpO1xuICAgIHZhciB2ZWN0b3IgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3ZlY3RvcicpO1xuICAgIHZhciBUcmFuc2Zvcm1hYmxlID0gcmVxdWlyZSgnenJlbmRlci9saWIvbWl4aW4vVHJhbnNmb3JtYWJsZScpO1xuICAgIHZhciBCb3VuZGluZ1JlY3QgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL0JvdW5kaW5nUmVjdCcpO1xuXG4gICAgdmFyIGdyYXBoaWMgPSB7fTtcblxuICAgIGdyYXBoaWMuR3JvdXAgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb250YWluZXIvR3JvdXAnKTtcblxuICAgIGdyYXBoaWMuSW1hZ2UgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9ncmFwaGljL0ltYWdlJyk7XG5cbiAgICBncmFwaGljLlRleHQgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9ncmFwaGljL1RleHQnKTtcblxuICAgIGdyYXBoaWMuQ2lyY2xlID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9DaXJjbGUnKTtcblxuICAgIGdyYXBoaWMuU2VjdG9yID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9TZWN0b3InKTtcblxuICAgIGdyYXBoaWMuUmluZyA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvUmluZycpO1xuXG4gICAgZ3JhcGhpYy5Qb2x5Z29uID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9Qb2x5Z29uJyk7XG5cbiAgICBncmFwaGljLlBvbHlsaW5lID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9Qb2x5bGluZScpO1xuXG4gICAgZ3JhcGhpYy5SZWN0ID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9SZWN0Jyk7XG5cbiAgICBncmFwaGljLkxpbmUgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL0xpbmUnKTtcblxuICAgIGdyYXBoaWMuQmV6aWVyQ3VydmUgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL0JlemllckN1cnZlJyk7XG5cbiAgICBncmFwaGljLkFyYyA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvQXJjJyk7XG5cbiAgICBncmFwaGljLkNvbXBvdW5kUGF0aCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2dyYXBoaWMvQ29tcG91bmRQYXRoJyk7XG5cbiAgICBncmFwaGljLkxpbmVhckdyYWRpZW50ID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9MaW5lYXJHcmFkaWVudCcpO1xuXG4gICAgZ3JhcGhpYy5SYWRpYWxHcmFkaWVudCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2dyYXBoaWMvUmFkaWFsR3JhZGllbnQnKTtcblxuICAgIGdyYXBoaWMuQm91bmRpbmdSZWN0ID0gQm91bmRpbmdSZWN0O1xuXG4gICAgLyoqXG4gICAgICogRXh0ZW5kIHNoYXBlIHdpdGggcGFyYW1ldGVyc1xuICAgICAqL1xuICAgIGdyYXBoaWMuZXh0ZW5kU2hhcGUgPSBmdW5jdGlvbiAob3B0cykge1xuICAgICAgICByZXR1cm4gUGF0aC5leHRlbmQob3B0cyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEV4dGVuZCBwYXRoXG4gICAgICovXG4gICAgZ3JhcGhpYy5leHRlbmRQYXRoID0gZnVuY3Rpb24gKHBhdGhEYXRhLCBvcHRzKSB7XG4gICAgICAgIHJldHVybiBwYXRoVG9vbC5leHRlbmRGcm9tU3RyaW5nKHBhdGhEYXRhLCBvcHRzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgcGF0aCBlbGVtZW50IGZyb20gcGF0aCBkYXRhIHN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoRGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9jb3JlL0JvdW5kaW5nUmVjdH0gcmVjdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbbGF5b3V0PWNvdmVyXSAnY2VudGVyJyBvciAnY292ZXInXG4gICAgICovXG4gICAgZ3JhcGhpYy5tYWtlUGF0aCA9IGZ1bmN0aW9uIChwYXRoRGF0YSwgb3B0cywgcmVjdCwgbGF5b3V0KSB7XG4gICAgICAgIHZhciBwYXRoID0gcGF0aFRvb2wuY3JlYXRlRnJvbVN0cmluZyhwYXRoRGF0YSwgb3B0cyk7XG4gICAgICAgIHZhciBib3VuZGluZ1JlY3QgPSBwYXRoLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgICAgICBpZiAocmVjdCkge1xuICAgICAgICAgICAgdmFyIGFzcGVjdCA9IGJvdW5kaW5nUmVjdC53aWR0aCAvIGJvdW5kaW5nUmVjdC5oZWlnaHQ7XG5cbiAgICAgICAgICAgIGlmIChsYXlvdXQgPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgICAgICAgLy8gU2V0IHJlY3QgdG8gY2VudGVyLCBrZWVwIHdpZHRoIC8gaGVpZ2h0IHJhdGlvLlxuICAgICAgICAgICAgICAgIHZhciB3aWR0aCA9IHJlY3QuaGVpZ2h0ICogYXNwZWN0O1xuICAgICAgICAgICAgICAgIHZhciBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgaWYgKHdpZHRoIDw9IHJlY3Qud2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IHJlY3Qud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCA9IHdpZHRoIC8gYXNwZWN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgY3ggPSByZWN0LnggKyByZWN0LndpZHRoIC8gMjtcbiAgICAgICAgICAgICAgICB2YXIgY3kgPSByZWN0LnkgKyByZWN0LmhlaWdodCAvIDI7XG5cbiAgICAgICAgICAgICAgICByZWN0LnggPSBjeCAtIHdpZHRoIC8gMjtcbiAgICAgICAgICAgICAgICByZWN0LnkgPSBjeSAtIGhlaWdodCAvIDI7XG4gICAgICAgICAgICAgICAgcmVjdC53aWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgICAgIHJlY3QuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBncmFwaGljLnJlc2l6ZVBhdGgocGF0aCwgcmVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfTtcblxuICAgIGdyYXBoaWMubWVyZ2VQYXRoID0gcGF0aFRvb2wubWVyZ2VQYXRoLFxuXG4gICAgLyoqXG4gICAgICogUmVzaXplIGEgcGF0aCB0byBmaXQgdGhlIHJlY3RcbiAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2dyYXBoaWMvUGF0aH0gcGF0aFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWN0XG4gICAgICovXG4gICAgZ3JhcGhpYy5yZXNpemVQYXRoID0gZnVuY3Rpb24gKHBhdGgsIHJlY3QpIHtcbiAgICAgICAgaWYgKCFwYXRoLmFwcGx5VHJhbnNmb3JtKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGF0aFJlY3QgPSBwYXRoLmdldEJvdW5kaW5nUmVjdCgpO1xuXG4gICAgICAgIHZhciBtID0gcGF0aFJlY3QuY2FsY3VsYXRlVHJhbnNmb3JtKHJlY3QpO1xuXG4gICAgICAgIHBhdGguYXBwbHlUcmFuc2Zvcm0obSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFN1YiBwaXhlbCBvcHRpbWl6ZSBsaW5lIGZvciBjYW52YXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW0uc2hhcGVdXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbS5zaGFwZS54MV1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtLnNoYXBlLnkxXVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW0uc2hhcGUueDJdXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbS5zaGFwZS55Ml1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtLnN0eWxlXVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW0uc3R5bGUubGluZVdpZHRoXVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gTW9kaWZpZWQgcGFyYW1cbiAgICAgKi9cbiAgICBncmFwaGljLnN1YlBpeGVsT3B0aW1pemVMaW5lID0gZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgICAgIHZhciBzdWJQaXhlbE9wdGltaXplID0gZ3JhcGhpYy5zdWJQaXhlbE9wdGltaXplO1xuICAgICAgICB2YXIgc2hhcGUgPSBwYXJhbS5zaGFwZTtcbiAgICAgICAgdmFyIGxpbmVXaWR0aCA9IHBhcmFtLnN0eWxlLmxpbmVXaWR0aDtcblxuICAgICAgICBpZiAocm91bmQoc2hhcGUueDEgKiAyKSA9PT0gcm91bmQoc2hhcGUueDIgKiAyKSkge1xuICAgICAgICAgICAgc2hhcGUueDEgPSBzaGFwZS54MiA9IHN1YlBpeGVsT3B0aW1pemUoc2hhcGUueDEsIGxpbmVXaWR0aCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJvdW5kKHNoYXBlLnkxICogMikgPT09IHJvdW5kKHNoYXBlLnkyICogMikpIHtcbiAgICAgICAgICAgIHNoYXBlLnkxID0gc2hhcGUueTIgPSBzdWJQaXhlbE9wdGltaXplKHNoYXBlLnkxLCBsaW5lV2lkdGgsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJhbTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU3ViIHBpeGVsIG9wdGltaXplIHJlY3QgZm9yIGNhbnZhc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbS5zaGFwZV1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtLnNoYXBlLnhdXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbS5zaGFwZS55XVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW0uc2hhcGUud2lkdGhdXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbS5zaGFwZS5oZWlnaHRdXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbS5zdHlsZV1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtLnN0eWxlLmxpbmVXaWR0aF1cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE1vZGlmaWVkIHBhcmFtXG4gICAgICovXG4gICAgZ3JhcGhpYy5zdWJQaXhlbE9wdGltaXplUmVjdCA9IGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgICB2YXIgc3ViUGl4ZWxPcHRpbWl6ZSA9IGdyYXBoaWMuc3ViUGl4ZWxPcHRpbWl6ZTtcbiAgICAgICAgdmFyIHNoYXBlID0gcGFyYW0uc2hhcGU7XG4gICAgICAgIHZhciBsaW5lV2lkdGggPSBwYXJhbS5zdHlsZS5saW5lV2lkdGg7XG4gICAgICAgIHZhciBvcmlnaW5YID0gc2hhcGUueDtcbiAgICAgICAgdmFyIG9yaWdpblkgPSBzaGFwZS55O1xuICAgICAgICB2YXIgb3JpZ2luV2lkdGggPSBzaGFwZS53aWR0aDtcbiAgICAgICAgdmFyIG9yaWdpbkhlaWdodCA9IHNoYXBlLmhlaWdodDtcbiAgICAgICAgc2hhcGUueCA9IHN1YlBpeGVsT3B0aW1pemUoc2hhcGUueCwgbGluZVdpZHRoLCB0cnVlKTtcbiAgICAgICAgc2hhcGUueSA9IHN1YlBpeGVsT3B0aW1pemUoc2hhcGUueSwgbGluZVdpZHRoLCB0cnVlKTtcbiAgICAgICAgc2hhcGUud2lkdGggPSBNYXRoLm1heChcbiAgICAgICAgICAgIHN1YlBpeGVsT3B0aW1pemUob3JpZ2luWCArIG9yaWdpbldpZHRoLCBsaW5lV2lkdGgsIGZhbHNlKSAtIHNoYXBlLngsXG4gICAgICAgICAgICBvcmlnaW5XaWR0aCA9PT0gMCA/IDAgOiAxXG4gICAgICAgICk7XG4gICAgICAgIHNoYXBlLmhlaWdodCA9IE1hdGgubWF4KFxuICAgICAgICAgICAgc3ViUGl4ZWxPcHRpbWl6ZShvcmlnaW5ZICsgb3JpZ2luSGVpZ2h0LCBsaW5lV2lkdGgsIGZhbHNlKSAtIHNoYXBlLnksXG4gICAgICAgICAgICBvcmlnaW5IZWlnaHQgPT09IDAgPyAwIDogMVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gcGFyYW07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFN1YiBwaXhlbCBvcHRpbWl6ZSBmb3IgY2FudmFzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcG9zaXRpb24gQ29vcmRpbmF0ZSwgc3VjaCBhcyB4LCB5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxpbmVXaWR0aCBTaG91bGQgYmUgbm9ubmVnYXRpdmUgaW50ZWdlci5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBwb3NpdGl2ZU9yTmVnYXRpdmUgRGVmYXVsdCBmYWxzZSAobmVnYXRpdmUpLlxuICAgICAqIEByZXR1cm4ge251bWJlcn0gT3B0aW1pemVkIHBvc2l0aW9uLlxuICAgICAqL1xuICAgIGdyYXBoaWMuc3ViUGl4ZWxPcHRpbWl6ZSA9IGZ1bmN0aW9uIChwb3NpdGlvbiwgbGluZVdpZHRoLCBwb3NpdGl2ZU9yTmVnYXRpdmUpIHtcbiAgICAgICAgLy8gQXNzdXJlIHRoYXQgKHBvc2l0aW9uICsgbGluZVdpZHRoIC8gMikgaXMgbmVhciBpbnRlZ2VyIGVkZ2UsXG4gICAgICAgIC8vIG90aGVyd2lzZSBsaW5lIHdpbGwgYmUgZnV6enkgaW4gY2FudmFzLlxuICAgICAgICB2YXIgZG91YmxlZFBvc2l0aW9uID0gcm91bmQocG9zaXRpb24gKiAyKTtcbiAgICAgICAgcmV0dXJuIChkb3VibGVkUG9zaXRpb24gKyByb3VuZChsaW5lV2lkdGgpKSAlIDIgPT09IDBcbiAgICAgICAgICAgID8gZG91YmxlZFBvc2l0aW9uIC8gMlxuICAgICAgICAgICAgOiAoZG91YmxlZFBvc2l0aW9uICsgKHBvc2l0aXZlT3JOZWdhdGl2ZSA/IDEgOiAtMSkpIC8gMjtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gaGFzRmlsbE9yU3Ryb2tlKGZpbGxPclN0cm9rZSkge1xuICAgICAgICByZXR1cm4gZmlsbE9yU3Ryb2tlICE9IG51bGwgJiYgZmlsbE9yU3Ryb2tlICE9ICdub25lJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWZ0Q29sb3IoY29sb3IpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBjb2xvciA9PT0gJ3N0cmluZycgPyBjb2xvclRvb2wubGlmdChjb2xvciwgLTAuMSkgOiBjb2xvcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhY2hlRWxlbWVudFN0bChlbCkge1xuICAgICAgICBpZiAoZWwuX19ob3ZlclN0bERpcnR5KSB7XG4gICAgICAgICAgICB2YXIgc3Ryb2tlID0gZWwuc3R5bGUuc3Ryb2tlO1xuICAgICAgICAgICAgdmFyIGZpbGwgPSBlbC5zdHlsZS5maWxsO1xuXG4gICAgICAgICAgICAvLyBDcmVhdGUgaG92ZXJTdHlsZSBvbiBtb3VzZW92ZXJcbiAgICAgICAgICAgIHZhciBob3ZlclN0eWxlID0gZWwuX19ob3ZlclN0bDtcbiAgICAgICAgICAgIGhvdmVyU3R5bGUuZmlsbCA9IGhvdmVyU3R5bGUuZmlsbFxuICAgICAgICAgICAgICAgIHx8IChoYXNGaWxsT3JTdHJva2UoZmlsbCkgPyBsaWZ0Q29sb3IoZmlsbCkgOiBudWxsKTtcbiAgICAgICAgICAgIGhvdmVyU3R5bGUuc3Ryb2tlID0gaG92ZXJTdHlsZS5zdHJva2VcbiAgICAgICAgICAgICAgICB8fCAoaGFzRmlsbE9yU3Ryb2tlKHN0cm9rZSkgPyBsaWZ0Q29sb3Ioc3Ryb2tlKSA6IG51bGwpO1xuXG4gICAgICAgICAgICB2YXIgbm9ybWFsU3R5bGUgPSB7fTtcbiAgICAgICAgICAgIGZvciAodmFyIG5hbWUgaW4gaG92ZXJTdHlsZSkge1xuICAgICAgICAgICAgICAgIGlmIChob3ZlclN0eWxlLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbFN0eWxlW25hbWVdID0gZWwuc3R5bGVbbmFtZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlbC5fX25vcm1hbFN0bCA9IG5vcm1hbFN0eWxlO1xuXG4gICAgICAgICAgICBlbC5fX2hvdmVyU3RsRGlydHkgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZG9TaW5nbGVFbnRlckhvdmVyKGVsKSB7XG4gICAgICAgIGlmIChlbC5fX2lzSG92ZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNhY2hlRWxlbWVudFN0bChlbCk7XG5cbiAgICAgICAgaWYgKGVsLnVzZUhvdmVyTGF5ZXIpIHtcbiAgICAgICAgICAgIGVsLl9fenIgJiYgZWwuX196ci5hZGRIb3ZlcihlbCwgZWwuX19ob3ZlclN0bCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbC5zZXRTdHlsZShlbC5fX2hvdmVyU3RsKTtcbiAgICAgICAgICAgIGVsLnoyICs9IDE7XG4gICAgICAgIH1cblxuICAgICAgICBlbC5fX2lzSG92ZXIgPSB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRvU2luZ2xlTGVhdmVIb3ZlcihlbCkge1xuICAgICAgICBpZiAoIWVsLl9faXNIb3Zlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5vcm1hbFN0bCA9IGVsLl9fbm9ybWFsU3RsO1xuICAgICAgICBpZiAoZWwudXNlSG92ZXJMYXllcikge1xuICAgICAgICAgICAgZWwuX196ciAmJiBlbC5fX3pyLnJlbW92ZUhvdmVyKGVsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5vcm1hbFN0bCAmJiBlbC5zZXRTdHlsZShub3JtYWxTdGwpO1xuICAgICAgICAgICAgZWwuejIgLT0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsLl9faXNIb3ZlciA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRvRW50ZXJIb3ZlcihlbCkge1xuICAgICAgICBlbC50eXBlID09PSAnZ3JvdXAnXG4gICAgICAgICAgICA/IGVsLnRyYXZlcnNlKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZC50eXBlICE9PSAnZ3JvdXAnKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvU2luZ2xlRW50ZXJIb3ZlcihjaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIDogZG9TaW5nbGVFbnRlckhvdmVyKGVsKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkb0xlYXZlSG92ZXIoZWwpIHtcbiAgICAgICAgZWwudHlwZSA9PT0gJ2dyb3VwJ1xuICAgICAgICAgICAgPyBlbC50cmF2ZXJzZShmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQudHlwZSAhPT0gJ2dyb3VwJykge1xuICAgICAgICAgICAgICAgICAgICBkb1NpbmdsZUxlYXZlSG92ZXIoY2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICA6IGRvU2luZ2xlTGVhdmVIb3ZlcihlbCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0RWxlbWVudEhvdmVyU3RsKGVsLCBob3ZlclN0bCkge1xuICAgICAgICAvLyBJZiBlbGVtZW50IGhhcyBzZXBjaWZpZWQgaG92ZXJTdHlsZSwgdGhlbiB1c2UgaXQgaW5zdGVhZCBvZiBnaXZlbiBob3ZlclN0eWxlXG4gICAgICAgIC8vIE9mdGVuIHVzZWQgd2hlbiBpdGVtIGdyb3VwIGhhcyBhIGxhYmVsIGVsZW1lbnQgYW5kIGl0J3MgaG92ZXJTdHlsZSBpcyBkaWZmZXJlbnRcbiAgICAgICAgZWwuX19ob3ZlclN0bCA9IGVsLmhvdmVyU3R5bGUgfHwgaG92ZXJTdGwgfHwge307XG4gICAgICAgIGVsLl9faG92ZXJTdGxEaXJ0eSA9IHRydWU7XG5cbiAgICAgICAgaWYgKGVsLl9faXNIb3Zlcikge1xuICAgICAgICAgICAgY2FjaGVFbGVtZW50U3RsKGVsKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9uRWxlbWVudE1vdXNlT3ZlcihlKSB7XG4gICAgICAgIGlmICh0aGlzLl9faG92ZXJTaWxlbnRPblRvdWNoICYmIGUuenJCeVRvdWNoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBPbmx5IGlmIGVsZW1lbnQgaXMgbm90IGluIGVtcGhhc2lzIHN0YXR1c1xuICAgICAgICAhdGhpcy5fX2lzRW1waGFzaXMgJiYgZG9FbnRlckhvdmVyKHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9uRWxlbWVudE1vdXNlT3V0KGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX19ob3ZlclNpbGVudE9uVG91Y2ggJiYgZS56ckJ5VG91Y2gpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE9ubHkgaWYgZWxlbWVudCBpcyBub3QgaW4gZW1waGFzaXMgc3RhdHVzXG4gICAgICAgICF0aGlzLl9faXNFbXBoYXNpcyAmJiBkb0xlYXZlSG92ZXIodGhpcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gZW50ZXJFbXBoYXNpcygpIHtcbiAgICAgICAgdGhpcy5fX2lzRW1waGFzaXMgPSB0cnVlO1xuICAgICAgICBkb0VudGVySG92ZXIodGhpcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGVhdmVFbXBoYXNpcygpIHtcbiAgICAgICAgdGhpcy5fX2lzRW1waGFzaXMgPSBmYWxzZTtcbiAgICAgICAgZG9MZWF2ZUhvdmVyKHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCBob3ZlciBzdHlsZSBvZiBlbGVtZW50LlxuICAgICAqIFRoaXMgbWV0aG9kIGNhbiBiZSBjYWxsZWQgcmVwZWF0bHkgd2l0aG91dCBzaWRlLWVmZmVjdHMuXG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBlbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbaG92ZXJTdHlsZV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdF1cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHQuaG92ZXJTaWxlbnRPblRvdWNoPWZhbHNlXVxuICAgICAqICAgICAgICBJbiB0b3VjaCBkZXZpY2UsIG1vdXNlb3ZlciBldmVudCB3aWxsIGJlIHRyaWdnZXIgb24gdG91Y2hzdGFydCBldmVudFxuICAgICAqICAgICAgICAoc2VlIG1vZHVsZTp6cmVuZGVyL2RvbS9IYW5kbGVyUHJveHkpLiBCeSB0aGlzIG1lY2hhbmlzbSwgd2UgY2FuXG4gICAgICogICAgICAgIGNvbnZpbmllbnRseSB1c2UgaG92ZXJTdHlsZSB3aGVuIHRhcCBvbiB0b3VjaCBzY3JlZW4gd2l0aG91dCBhZGRpdGlvbmFsXG4gICAgICogICAgICAgIGNvZGUgZm9yIGNvbXBhdGliaWxpdHkuXG4gICAgICogICAgICAgIEJ1dCBpZiB0aGUgY2hhcnQvY29tcG9uZW50IGhhcyBzZWxlY3QgZmVhdHVyZSwgd2hpY2ggdXN1YWxseSBhbHNvIHVzZVxuICAgICAqICAgICAgICBob3ZlclN0eWxlLCB0aGVyZSBtaWdodCBiZSBjb25mbGljdCBiZXR3ZWVuICdzZWxlY3QtaGlnaGxpZ2h0JyBhbmRcbiAgICAgKiAgICAgICAgJ2hvdmVyLWhpZ2hsaWdodCcgZXNwZWNpYWxseSB3aGVuIHJvYW0gaXMgZW5hYmxlZCAoc2VlIGdlbyBmb3IgZXhhbXBsZSkuXG4gICAgICogICAgICAgIEluIHRoaXMgY2FzZSwgaG92ZXJTaWxlbnRPblRvdWNoIHNob3VsZCBiZSB1c2VkIHRvIGRpc2FibGUgaG92ZXItaGlnaGxpZ2h0XG4gICAgICogICAgICAgIG9uIHRvdWNoIGRldmljZS5cbiAgICAgKi9cbiAgICBncmFwaGljLnNldEhvdmVyU3R5bGUgPSBmdW5jdGlvbiAoZWwsIGhvdmVyU3R5bGUsIG9wdCkge1xuICAgICAgICBlbC5fX2hvdmVyU2lsZW50T25Ub3VjaCA9IG9wdCAmJiBvcHQuaG92ZXJTaWxlbnRPblRvdWNoO1xuXG4gICAgICAgIGVsLnR5cGUgPT09ICdncm91cCdcbiAgICAgICAgICAgID8gZWwudHJhdmVyc2UoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLnR5cGUgIT09ICdncm91cCcpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0RWxlbWVudEhvdmVyU3RsKGNoaWxkLCBob3ZlclN0eWxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgOiBzZXRFbGVtZW50SG92ZXJTdGwoZWwsIGhvdmVyU3R5bGUpO1xuXG4gICAgICAgIC8vIER1cGxpY2F0ZWQgZnVuY3Rpb24gd2lsbCBiZSBhdXRvLWlnbm9yZWQsIHNlZSBFdmVudGZ1bC5qcy5cbiAgICAgICAgZWwub24oJ21vdXNlb3ZlcicsIG9uRWxlbWVudE1vdXNlT3ZlcilcbiAgICAgICAgICAub24oJ21vdXNlb3V0Jywgb25FbGVtZW50TW91c2VPdXQpO1xuXG4gICAgICAgIC8vIEVtcGhhc2lzLCBub3JtYWwgY2FuIGJlIHRyaWdnZXJlZCBtYW51YWxseVxuICAgICAgICBlbC5vbignZW1waGFzaXMnLCBlbnRlckVtcGhhc2lzKVxuICAgICAgICAgIC5vbignbm9ybWFsJywgbGVhdmVFbXBoYXNpcyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldCB0ZXh0IG9wdGlvbiBpbiB0aGUgc3R5bGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdGV4dFN0eWxlXG4gICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH0gbGFiZWxNb2RlbFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvclxuICAgICAqL1xuICAgIGdyYXBoaWMuc2V0VGV4dCA9IGZ1bmN0aW9uICh0ZXh0U3R5bGUsIGxhYmVsTW9kZWwsIGNvbG9yKSB7XG4gICAgICAgIHZhciBsYWJlbFBvc2l0aW9uID0gbGFiZWxNb2RlbC5nZXRTaGFsbG93KCdwb3NpdGlvbicpIHx8ICdpbnNpZGUnO1xuICAgICAgICB2YXIgbGFiZWxPZmZzZXQgPSBsYWJlbE1vZGVsLmdldFNoYWxsb3coJ29mZnNldCcpO1xuICAgICAgICB2YXIgbGFiZWxDb2xvciA9IGxhYmVsUG9zaXRpb24uaW5kZXhPZignaW5zaWRlJykgPj0gMCA/ICd3aGl0ZScgOiBjb2xvcjtcbiAgICAgICAgdmFyIHRleHRTdHlsZU1vZGVsID0gbGFiZWxNb2RlbC5nZXRNb2RlbCgndGV4dFN0eWxlJyk7XG4gICAgICAgIHpyVXRpbC5leHRlbmQodGV4dFN0eWxlLCB7XG4gICAgICAgICAgICB0ZXh0RGlzdGFuY2U6IGxhYmVsTW9kZWwuZ2V0U2hhbGxvdygnZGlzdGFuY2UnKSB8fCA1LFxuICAgICAgICAgICAgdGV4dEZvbnQ6IHRleHRTdHlsZU1vZGVsLmdldEZvbnQoKSxcbiAgICAgICAgICAgIHRleHRQb3NpdGlvbjogbGFiZWxQb3NpdGlvbixcbiAgICAgICAgICAgIHRleHRPZmZzZXQ6IGxhYmVsT2Zmc2V0LFxuICAgICAgICAgICAgdGV4dEZpbGw6IHRleHRTdHlsZU1vZGVsLmdldFRleHRDb2xvcigpIHx8IGxhYmVsQ29sb3JcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGFuaW1hdGVPclNldFByb3BzKGlzVXBkYXRlLCBlbCwgcHJvcHMsIGFuaW1hdGFibGVNb2RlbCwgZGF0YUluZGV4LCBjYikge1xuICAgICAgICBpZiAodHlwZW9mIGRhdGFJbmRleCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2IgPSBkYXRhSW5kZXg7XG4gICAgICAgICAgICBkYXRhSW5kZXggPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIERvIG5vdCBjaGVjayAnYW5pbWF0aW9uJyBwcm9wZXJ0eSBkaXJlY3RseSBoZXJlLiBDb25zaWRlciB0aGlzIGNhc2U6XG4gICAgICAgIC8vIGFuaW1hdGlvbiBtb2RlbCBpcyBhbiBgaXRlbU1vZGVsYCwgd2hvc2UgZG9lcyBub3QgaGF2ZSBgaXNBbmltYXRpb25FbmFibGVkYFxuICAgICAgICAvLyBidXQgaXRzIHBhcmVudCBtb2RlbCAoYHNlcmllc01vZGVsYCkgZG9lcy5cbiAgICAgICAgdmFyIGFuaW1hdGlvbkVuYWJsZWQgPSBhbmltYXRhYmxlTW9kZWwgJiYgYW5pbWF0YWJsZU1vZGVsLmlzQW5pbWF0aW9uRW5hYmxlZCgpO1xuXG4gICAgICAgIGlmIChhbmltYXRpb25FbmFibGVkKSB7XG4gICAgICAgICAgICB2YXIgcG9zdGZpeCA9IGlzVXBkYXRlID8gJ1VwZGF0ZScgOiAnJztcbiAgICAgICAgICAgIHZhciBkdXJhdGlvbiA9IGFuaW1hdGFibGVNb2RlbC5nZXRTaGFsbG93KCdhbmltYXRpb25EdXJhdGlvbicgKyBwb3N0Zml4KTtcbiAgICAgICAgICAgIHZhciBhbmltYXRpb25FYXNpbmcgPSBhbmltYXRhYmxlTW9kZWwuZ2V0U2hhbGxvdygnYW5pbWF0aW9uRWFzaW5nJyArIHBvc3RmaXgpO1xuICAgICAgICAgICAgdmFyIGFuaW1hdGlvbkRlbGF5ID0gYW5pbWF0YWJsZU1vZGVsLmdldFNoYWxsb3coJ2FuaW1hdGlvbkRlbGF5JyArIHBvc3RmaXgpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBhbmltYXRpb25EZWxheSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGFuaW1hdGlvbkRlbGF5ID0gYW5pbWF0aW9uRGVsYXkoXG4gICAgICAgICAgICAgICAgICAgIGRhdGFJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0YWJsZU1vZGVsLmdldEFuaW1hdGlvbkRlbGF5UGFyYW1zXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGFuaW1hdGFibGVNb2RlbC5nZXRBbmltYXRpb25EZWxheVBhcmFtcyhlbCwgZGF0YUluZGV4KVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBudWxsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZHVyYXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBkdXJhdGlvbiA9IGR1cmF0aW9uKGRhdGFJbmRleCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGR1cmF0aW9uID4gMFxuICAgICAgICAgICAgICAgID8gZWwuYW5pbWF0ZVRvKHByb3BzLCBkdXJhdGlvbiwgYW5pbWF0aW9uRGVsYXkgfHwgMCwgYW5pbWF0aW9uRWFzaW5nLCBjYilcbiAgICAgICAgICAgICAgICA6IChlbC5zdG9wQW5pbWF0aW9uKCksIGVsLmF0dHIocHJvcHMpLCBjYiAmJiBjYigpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVsLnN0b3BBbmltYXRpb24oKTtcbiAgICAgICAgICAgIGVsLmF0dHIocHJvcHMpO1xuICAgICAgICAgICAgY2IgJiYgY2IoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBncmFwaGljIGVsZW1lbnQgcHJvcGVydGllcyB3aXRoIG9yIHdpdGhvdXQgYW5pbWF0aW9uIGFjY29yZGluZyB0byB0aGUgY29uZmlndXJhdGlvbiBpbiBzZXJpZXNcbiAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGVsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzXG4gICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH0gW2FuaW1hdGFibGVNb2RlbF1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2RhdGFJbmRleF1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgICAgZ3JhcGhpYy51cGRhdGVQcm9wcyhlbCwge1xuICAgICAqICAgICAgICAgcG9zaXRpb246IFsxMDAsIDEwMF1cbiAgICAgKiAgICAgfSwgc2VyaWVzTW9kZWwsIGRhdGFJbmRleCwgZnVuY3Rpb24gKCkgeyBjb25zb2xlLmxvZygnQW5pbWF0aW9uIGRvbmUhJyk7IH0pO1xuICAgICAqICAgICAvLyBPclxuICAgICAqICAgICBncmFwaGljLnVwZGF0ZVByb3BzKGVsLCB7XG4gICAgICogICAgICAgICBwb3NpdGlvbjogWzEwMCwgMTAwXVxuICAgICAqICAgICB9LCBzZXJpZXNNb2RlbCwgZnVuY3Rpb24gKCkgeyBjb25zb2xlLmxvZygnQW5pbWF0aW9uIGRvbmUhJyk7IH0pO1xuICAgICAqL1xuICAgIGdyYXBoaWMudXBkYXRlUHJvcHMgPSBmdW5jdGlvbiAoZWwsIHByb3BzLCBhbmltYXRhYmxlTW9kZWwsIGRhdGFJbmRleCwgY2IpIHtcbiAgICAgICAgYW5pbWF0ZU9yU2V0UHJvcHModHJ1ZSwgZWwsIHByb3BzLCBhbmltYXRhYmxlTW9kZWwsIGRhdGFJbmRleCwgY2IpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJbml0IGdyYXBoaWMgZWxlbWVudCBwcm9wZXJ0aWVzIHdpdGggb3Igd2l0aG91dCBhbmltYXRpb24gYWNjb3JkaW5nIHRvIHRoZSBjb25maWd1cmF0aW9uIGluIHNlcmllc1xuICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gZWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcHNcbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBbYW5pbWF0YWJsZU1vZGVsXVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZGF0YUluZGV4XVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gICAgICovXG4gICAgZ3JhcGhpYy5pbml0UHJvcHMgPSBmdW5jdGlvbiAoZWwsIHByb3BzLCBhbmltYXRhYmxlTW9kZWwsIGRhdGFJbmRleCwgY2IpIHtcbiAgICAgICAgYW5pbWF0ZU9yU2V0UHJvcHMoZmFsc2UsIGVsLCBwcm9wcywgYW5pbWF0YWJsZU1vZGVsLCBkYXRhSW5kZXgsIGNiKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRyYW5zZm9ybSBtYXRyaXggb2YgdGFyZ2V0IChwYXJhbSB0YXJnZXQpLFxuICAgICAqIGluIGNvb3JkaW5hdGUgb2YgaXRzIGFuY2VzdG9yIChwYXJhbSBhbmNlc3RvcilcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvbWl4aW4vVHJhbnNmb3JtYWJsZX0gdGFyZ2V0XG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9taXhpbi9UcmFuc2Zvcm1hYmxlfSBbYW5jZXN0b3JdXG4gICAgICovXG4gICAgZ3JhcGhpYy5nZXRUcmFuc2Zvcm0gPSBmdW5jdGlvbiAodGFyZ2V0LCBhbmNlc3Rvcikge1xuICAgICAgICB2YXIgbWF0ID0gbWF0cml4LmlkZW50aXR5KFtdKTtcblxuICAgICAgICB3aGlsZSAodGFyZ2V0ICYmIHRhcmdldCAhPT0gYW5jZXN0b3IpIHtcbiAgICAgICAgICAgIG1hdHJpeC5tdWwobWF0LCB0YXJnZXQuZ2V0TG9jYWxUcmFuc2Zvcm0oKSwgbWF0KTtcbiAgICAgICAgICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWF0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBcHBseSB0cmFuc2Zvcm0gdG8gYW4gdmVydGV4LlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHRhcmdldCBbeCwgeV1cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fFR5cGVkQXJyYXkuPG51bWJlcj58T2JqZWN0fSB0cmFuc2Zvcm0gQ2FuIGJlOlxuICAgICAqICAgICAgKyBUcmFuc2Zvcm0gbWF0cml4OiBsaWtlIFsxLCAwLCAwLCAxLCAwLCAwXVxuICAgICAqICAgICAgKyB7cG9zaXRpb24sIHJvdGF0aW9uLCBzY2FsZX0sIHRoZSBzYW1lIGFzIGB6cmVuZGVyL1RyYW5zZm9ybWFibGVgLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGludmVydCBXaGV0aGVyIHVzZSBpbnZlcnQgbWF0cml4LlxuICAgICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fSBbeCwgeV1cbiAgICAgKi9cbiAgICBncmFwaGljLmFwcGx5VHJhbnNmb3JtID0gZnVuY3Rpb24gKHRhcmdldCwgdHJhbnNmb3JtLCBpbnZlcnQpIHtcbiAgICAgICAgaWYgKHRyYW5zZm9ybSAmJiAhenJVdGlsLmlzQXJyYXlMaWtlKHRyYW5zZm9ybSkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybSA9IFRyYW5zZm9ybWFibGUuZ2V0TG9jYWxUcmFuc2Zvcm0odHJhbnNmb3JtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbnZlcnQpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybSA9IG1hdHJpeC5pbnZlcnQoW10sIHRyYW5zZm9ybSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZlY3Rvci5hcHBseVRyYW5zZm9ybShbXSwgdGFyZ2V0LCB0cmFuc2Zvcm0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGlyZWN0aW9uICdsZWZ0JyAncmlnaHQnICd0b3AnICdib3R0b20nXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gdHJhbnNmb3JtIFRyYW5zZm9ybSBtYXRyaXg6IGxpa2UgWzEsIDAsIDAsIDEsIDAsIDBdXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gaW52ZXJ0IFdoZXRoZXIgdXNlIGludmVydCBtYXRyaXguXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBUcmFuc2Zvcm1lZCBkaXJlY3Rpb24uICdsZWZ0JyAncmlnaHQnICd0b3AnICdib3R0b20nXG4gICAgICovXG4gICAgZ3JhcGhpYy50cmFuc2Zvcm1EaXJlY3Rpb24gPSBmdW5jdGlvbiAoZGlyZWN0aW9uLCB0cmFuc2Zvcm0sIGludmVydCkge1xuXG4gICAgICAgIC8vIFBpY2sgYSBiYXNlLCBlbnN1cmUgdGhhdCB0cmFuc2Zvcm0gcmVzdWx0IHdpbGwgbm90IGJlICgwLCAwKS5cbiAgICAgICAgdmFyIGhCYXNlID0gKHRyYW5zZm9ybVs0XSA9PT0gMCB8fCB0cmFuc2Zvcm1bNV0gPT09IDAgfHwgdHJhbnNmb3JtWzBdID09PSAwKVxuICAgICAgICAgICAgPyAxIDogTWF0aC5hYnMoMiAqIHRyYW5zZm9ybVs0XSAvIHRyYW5zZm9ybVswXSk7XG4gICAgICAgIHZhciB2QmFzZSA9ICh0cmFuc2Zvcm1bNF0gPT09IDAgfHwgdHJhbnNmb3JtWzVdID09PSAwIHx8IHRyYW5zZm9ybVsyXSA9PT0gMClcbiAgICAgICAgICAgID8gMSA6IE1hdGguYWJzKDIgKiB0cmFuc2Zvcm1bNF0gLyB0cmFuc2Zvcm1bMl0pO1xuXG4gICAgICAgIHZhciB2ZXJ0ZXggPSBbXG4gICAgICAgICAgICBkaXJlY3Rpb24gPT09ICdsZWZ0JyA/IC1oQmFzZSA6IGRpcmVjdGlvbiA9PT0gJ3JpZ2h0JyA/IGhCYXNlIDogMCxcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9PT0gJ3RvcCcgPyAtdkJhc2UgOiBkaXJlY3Rpb24gPT09ICdib3R0b20nID8gdkJhc2UgOiAwXG4gICAgICAgIF07XG5cbiAgICAgICAgdmVydGV4ID0gZ3JhcGhpYy5hcHBseVRyYW5zZm9ybSh2ZXJ0ZXgsIHRyYW5zZm9ybSwgaW52ZXJ0KTtcblxuICAgICAgICByZXR1cm4gTWF0aC5hYnModmVydGV4WzBdKSA+IE1hdGguYWJzKHZlcnRleFsxXSlcbiAgICAgICAgICAgID8gKHZlcnRleFswXSA+IDAgPyAncmlnaHQnIDogJ2xlZnQnKVxuICAgICAgICAgICAgOiAodmVydGV4WzFdID4gMCA/ICdib3R0b20nIDogJ3RvcCcpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBcHBseSBncm91cCB0cmFuc2l0aW9uIGFuaW1hdGlvbiBmcm9tIGcxIHRvIGcyLlxuICAgICAqIElmIG5vIGFuaW1hdGFibGVNb2RlbCwgbm8gYW5pbWF0aW9uLlxuICAgICAqL1xuICAgIGdyYXBoaWMuZ3JvdXBUcmFuc2l0aW9uID0gZnVuY3Rpb24gKGcxLCBnMiwgYW5pbWF0YWJsZU1vZGVsLCBjYikge1xuICAgICAgICBpZiAoIWcxIHx8ICFnMikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0RWxNYXAoZykge1xuICAgICAgICAgICAgdmFyIGVsTWFwID0ge307XG4gICAgICAgICAgICBnLnRyYXZlcnNlKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgICAgIGlmICghZWwuaXNHcm91cCAmJiBlbC5hbmlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsTWFwW2VsLmFuaWRdID0gZWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZWxNYXA7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ2V0QW5pbWF0YWJsZVByb3BzKGVsKSB7XG4gICAgICAgICAgICB2YXIgb2JqID0ge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiB2ZWN0b3IuY2xvbmUoZWwucG9zaXRpb24pLFxuICAgICAgICAgICAgICAgIHJvdGF0aW9uOiBlbC5yb3RhdGlvblxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChlbC5zaGFwZSkge1xuICAgICAgICAgICAgICAgIG9iai5zaGFwZSA9IHpyVXRpbC5leHRlbmQoe30sIGVsLnNoYXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVsTWFwMSA9IGdldEVsTWFwKGcxKTtcblxuICAgICAgICBnMi50cmF2ZXJzZShmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIGlmICghZWwuaXNHcm91cCAmJiBlbC5hbmlkKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9sZEVsID0gZWxNYXAxW2VsLmFuaWRdO1xuICAgICAgICAgICAgICAgIGlmIChvbGRFbCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3UHJvcCA9IGdldEFuaW1hdGFibGVQcm9wcyhlbCk7XG4gICAgICAgICAgICAgICAgICAgIGVsLmF0dHIoZ2V0QW5pbWF0YWJsZVByb3BzKG9sZEVsKSk7XG4gICAgICAgICAgICAgICAgICAgIGdyYXBoaWMudXBkYXRlUHJvcHMoZWwsIG5ld1Byb3AsIGFuaW1hdGFibGVNb2RlbCwgZWwuZGF0YUluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gICAgIGlmIChlbC5wcmV2aW91c1Byb3BzKSB7XG4gICAgICAgICAgICAgICAgLy8gICAgICAgICBncmFwaGljLnVwZGF0ZVByb3BzXG4gICAgICAgICAgICAgICAgLy8gICAgIH1cbiAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGdyYXBoaWM7XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL3V0aWwvZ3JhcGhpYy5qc1xuLy8gbW9kdWxlIGlkID0gMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 3 */
/* unknown exports provided */
/* all exports used */
/*!****************************!*\
  !*** ./lib/util/number.js ***!
  \****************************/
/***/ (function(module, exports) {

eval("/**\n * 数值处理模块\n * @module echarts/util/number\n */\n\n\n\n    var number = {};\n\n    var RADIAN_EPSILON = 1e-4;\n\n    function _trim(str) {\n        return str.replace(/^\\s+/, '').replace(/\\s+$/, '');\n    }\n\n    /**\n     * Linear mapping a value from domain to range\n     * @memberOf module:echarts/util/number\n     * @param  {(number|Array.<number>)} val\n     * @param  {Array.<number>} domain Domain extent domain[0] can be bigger than domain[1]\n     * @param  {Array.<number>} range  Range extent range[0] can be bigger than range[1]\n     * @param  {boolean} clamp\n     * @return {(number|Array.<number>}\n     */\n    number.linearMap = function (val, domain, range, clamp) {\n        var subDomain = domain[1] - domain[0];\n        var subRange = range[1] - range[0];\n\n        if (subDomain === 0) {\n            return subRange === 0\n                ? range[0]\n                : (range[0] + range[1]) / 2;\n        }\n\n        // Avoid accuracy problem in edge, such as\n        // 146.39 - 62.83 === 83.55999999999999.\n        // See echarts/test/ut/spec/util/number.js#linearMap#accuracyError\n        // It is a little verbose for efficiency considering this method\n        // is a hotspot.\n        if (clamp) {\n            if (subDomain > 0) {\n                if (val <= domain[0]) {\n                    return range[0];\n                }\n                else if (val >= domain[1]) {\n                    return range[1];\n                }\n            }\n            else {\n                if (val >= domain[0]) {\n                    return range[0];\n                }\n                else if (val <= domain[1]) {\n                    return range[1];\n                }\n            }\n        }\n        else {\n            if (val === domain[0]) {\n                return range[0];\n            }\n            if (val === domain[1]) {\n                return range[1];\n            }\n        }\n\n        return (val - domain[0]) / subDomain * subRange + range[0];\n    };\n\n    /**\n     * Convert a percent string to absolute number.\n     * Returns NaN if percent is not a valid string or number\n     * @memberOf module:echarts/util/number\n     * @param {string|number} percent\n     * @param {number} all\n     * @return {number}\n     */\n    number.parsePercent = function(percent, all) {\n        switch (percent) {\n            case 'center':\n            case 'middle':\n                percent = '50%';\n                break;\n            case 'left':\n            case 'top':\n                percent = '0%';\n                break;\n            case 'right':\n            case 'bottom':\n                percent = '100%';\n                break;\n        }\n        if (typeof percent === 'string') {\n            if (_trim(percent).match(/%$/)) {\n                return parseFloat(percent) / 100 * all;\n            }\n\n            return parseFloat(percent);\n        }\n\n        return percent == null ? NaN : +percent;\n    };\n\n    /**\n     * (1) Fix rounding error of float numbers.\n     * (2) Support return string to avoid scientific notation like '3.5e-7'.\n     *\n     * @param {number} x\n     * @param {number} [precision]\n     * @param {boolean} [returnStr]\n     * @return {number|string}\n     */\n    number.round = function (x, precision, returnStr) {\n        if (precision == null) {\n            precision = 10;\n        }\n        // Avoid range error\n        precision = Math.min(Math.max(0, precision), 20);\n        x = (+x).toFixed(precision);\n        return returnStr ? x : +x;\n    };\n\n    number.asc = function (arr) {\n        arr.sort(function (a, b) {\n            return a - b;\n        });\n        return arr;\n    };\n\n    /**\n     * Get precision\n     * @param {number} val\n     */\n    number.getPrecision = function (val) {\n        val = +val;\n        if (isNaN(val)) {\n            return 0;\n        }\n        // It is much faster than methods converting number to string as follows\n        //      var tmp = val.toString();\n        //      return tmp.length - 1 - tmp.indexOf('.');\n        // especially when precision is low\n        var e = 1;\n        var count = 0;\n        while (Math.round(val * e) / e !== val) {\n            e *= 10;\n            count++;\n        }\n        return count;\n    };\n\n    /**\n     * @param {string|number} val\n     * @return {number}\n     */\n    number.getPrecisionSafe = function (val) {\n        var str = val.toString();\n\n        // Consider scientific notation: '3.4e-12' '3.4e+12'\n        var eIndex = str.indexOf('e');\n        if (eIndex > 0) {\n            var precision = +str.slice(eIndex + 1);\n            return precision < 0 ? -precision : 0;\n        }\n        else {\n            var dotIndex = str.indexOf('.');\n            return dotIndex < 0 ? 0 : str.length - 1 - dotIndex;\n        }\n    };\n\n    /**\n     * Minimal dicernible data precisioin according to a single pixel.\n     *\n     * @param {Array.<number>} dataExtent\n     * @param {Array.<number>} pixelExtent\n     * @return {number} precision\n     */\n    number.getPixelPrecision = function (dataExtent, pixelExtent) {\n        var log = Math.log;\n        var LN10 = Math.LN10;\n        var dataQuantity = Math.floor(log(dataExtent[1] - dataExtent[0]) / LN10);\n        var sizeQuantity = Math.round(log(Math.abs(pixelExtent[1] - pixelExtent[0])) / LN10);\n        // toFixed() digits argument must be between 0 and 20.\n        var precision = Math.min(Math.max(-dataQuantity + sizeQuantity, 0), 20);\n        return !isFinite(precision) ? 20 : precision;\n    };\n\n    // Number.MAX_SAFE_INTEGER, ie do not support.\n    number.MAX_SAFE_INTEGER = 9007199254740991;\n\n    /**\n     * To 0 - 2 * PI, considering negative radian.\n     * @param {number} radian\n     * @return {number}\n     */\n    number.remRadian = function (radian) {\n        var pi2 = Math.PI * 2;\n        return (radian % pi2 + pi2) % pi2;\n    };\n\n    /**\n     * @param {type} radian\n     * @return {boolean}\n     */\n    number.isRadianAroundZero = function (val) {\n        return val > -RADIAN_EPSILON && val < RADIAN_EPSILON;\n    };\n\n    var TIME_REG = /^(?:(\\d{4})(?:[-\\/](\\d{1,2})(?:[-\\/](\\d{1,2})(?:[T ](\\d{1,2})(?::(\\d\\d)(?::(\\d\\d)(?:[.,](\\d+))?)?)?(Z|[\\+\\-]\\d\\d:?\\d\\d)?)?)?)?)?$/; // jshint ignore:line\n\n    /**\n     * @return {number} in minutes\n     */\n    number.getTimezoneOffset = function () {\n        return (new Date()).getTimezoneOffset();\n    };\n\n    /**\n     * @param {string|Date|number} value These values can be accepted:\n     *   + An instance of Date, represent a time in its own time zone.\n     *   + Or string in a subset of ISO 8601, only including:\n     *     + only year, month, date: '2012-03', '2012-03-01', '2012-03-01 05', '2012-03-01 05:06',\n     *     + separated with T or space: '2012-03-01T12:22:33.123', '2012-03-01 12:22:33.123',\n     *     + time zone: '2012-03-01T12:22:33Z', '2012-03-01T12:22:33+8000', '2012-03-01T12:22:33-05:00',\n     *     all of which will be treated as local time if time zone is not specified\n     *     (see <https://momentjs.com/>).\n     *   + Or other string format, including (all of which will be treated as loacal time):\n     *     '2012', '2012-3-1', '2012/3/1', '2012/03/01',\n     *     '2009/6/12 2:00', '2009/6/12 2:05:08', '2009/6/12 2:05:08.123'\n     *   + a timestamp, which represent a time in UTC.\n     * @return {Date} date\n     */\n    number.parseDate = function (value) {\n        if (value instanceof Date) {\n            return value;\n        }\n        else if (typeof value === 'string') {\n            // Different browsers parse date in different way, so we parse it manually.\n            // Some other issues:\n            // new Date('1970-01-01') is UTC,\n            // new Date('1970/01/01') and new Date('1970-1-01') is local.\n            // See issue #3623\n            var match = TIME_REG.exec(value);\n\n            if (!match) {\n                // return Invalid Date.\n                return new Date(NaN);\n            }\n\n            var timezoneOffset = number.getTimezoneOffset();\n            var timeOffset = !match[8]\n                ? 0\n                : match[8].toUpperCase() === 'Z'\n                ? timezoneOffset\n                : +match[8].slice(0, 3) * 60 + timezoneOffset;\n\n            // match[n] can only be string or undefined.\n            // But take care of '12' + 1 => '121'.\n            return new Date(\n                +match[1],\n                +(match[2] || 1) - 1,\n                +match[3] || 1,\n                +match[4] || 0,\n                +(match[5] || 0) - timeOffset,\n                +match[6] || 0,\n                +match[7] || 0\n            );\n        }\n        else if (value == null) {\n            return new Date(NaN);\n        }\n\n        return new Date(Math.round(value));\n    };\n\n    /**\n     * Quantity of a number. e.g. 0.1, 1, 10, 100\n     *\n     * @param  {number} val\n     * @return {number}\n     */\n    number.quantity = function (val) {\n        return Math.pow(10, quantityExponent(val));\n    };\n\n    function quantityExponent(val) {\n        return Math.floor(Math.log(val) / Math.LN10);\n    }\n\n    /**\n     * find a “nice” number approximately equal to x. Round the number if round = true,\n     * take ceiling if round = false. The primary observation is that the “nicest”\n     * numbers in decimal are 1, 2, and 5, and all power-of-ten multiples of these numbers.\n     *\n     * See \"Nice Numbers for Graph Labels\" of Graphic Gems.\n     *\n     * @param  {number} val Non-negative value.\n     * @param  {boolean} round\n     * @return {number}\n     */\n    number.nice = function (val, round) {\n        var exponent = quantityExponent(val);\n        var exp10 = Math.pow(10, exponent);\n        var f = val / exp10; // 1 <= f < 10\n        var nf;\n        if (round) {\n            if (f < 1.5) { nf = 1; }\n            else if (f < 2.5) { nf = 2; }\n            else if (f < 4) { nf = 3; }\n            else if (f < 7) { nf = 5; }\n            else { nf = 10; }\n        }\n        else {\n            if (f < 1) { nf = 1; }\n            else if (f < 2) { nf = 2; }\n            else if (f < 3) { nf = 3; }\n            else if (f < 5) { nf = 5; }\n            else { nf = 10; }\n        }\n        val = nf * exp10;\n\n        // Fix 3 * 0.1 === 0.30000000000000004 issue (see IEEE 754).\n        // 20 is the uppper bound of toFixed.\n        return exponent >= -20 ? +val.toFixed(exponent < 0 ? -exponent : 0) : val;\n    };\n\n    /**\n     * Order intervals asc, and split them when overlap.\n     * expect(numberUtil.reformIntervals([\n     *     {interval: [18, 62], close: [1, 1]},\n     *     {interval: [-Infinity, -70], close: [0, 0]},\n     *     {interval: [-70, -26], close: [1, 1]},\n     *     {interval: [-26, 18], close: [1, 1]},\n     *     {interval: [62, 150], close: [1, 1]},\n     *     {interval: [106, 150], close: [1, 1]},\n     *     {interval: [150, Infinity], close: [0, 0]}\n     * ])).toEqual([\n     *     {interval: [-Infinity, -70], close: [0, 0]},\n     *     {interval: [-70, -26], close: [1, 1]},\n     *     {interval: [-26, 18], close: [0, 1]},\n     *     {interval: [18, 62], close: [0, 1]},\n     *     {interval: [62, 150], close: [0, 1]},\n     *     {interval: [150, Infinity], close: [0, 0]}\n     * ]);\n     * @param {Array.<Object>} list, where `close` mean open or close\n     *        of the interval, and Infinity can be used.\n     * @return {Array.<Object>} The origin list, which has been reformed.\n     */\n    number.reformIntervals = function (list) {\n        list.sort(function (a, b) {\n            return littleThan(a, b, 0) ? -1 : 1;\n        });\n\n        var curr = -Infinity;\n        var currClose = 1;\n        for (var i = 0; i < list.length;) {\n            var interval = list[i].interval;\n            var close = list[i].close;\n\n            for (var lg = 0; lg < 2; lg++) {\n                if (interval[lg] <= curr) {\n                    interval[lg] = curr;\n                    close[lg] = !lg ? 1 - currClose : 1;\n                }\n                curr = interval[lg];\n                currClose = close[lg];\n            }\n\n            if (interval[0] === interval[1] && close[0] * close[1] !== 1) {\n                list.splice(i, 1);\n            }\n            else {\n                i++;\n            }\n        }\n\n        return list;\n\n        function littleThan(a, b, lg) {\n            return a.interval[lg] < b.interval[lg]\n                || (\n                    a.interval[lg] === b.interval[lg]\n                    && (\n                        (a.close[lg] - b.close[lg] === (!lg ? 1 : -1))\n                        || (!lg && littleThan(a, b, 1))\n                    )\n                );\n        }\n    };\n\n    /**\n     * parseFloat NaNs numeric-cast false positives (null|true|false|\"\")\n     * ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n     * subtraction forces infinities to NaN\n     *\n     * @param {*} v\n     * @return {boolean}\n     */\n    number.isNumeric = function (v) {\n        return v - parseFloat(v) >= 0;\n    };\n\n    module.exports = number;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2xpYi91dGlsL251bWJlci5qcz9mNGExIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICog5pWw5YC85aSE55CG5qih5Z2XXG4gKiBAbW9kdWxlIGVjaGFydHMvdXRpbC9udW1iZXJcbiAqL1xuXG5cblxuICAgIHZhciBudW1iZXIgPSB7fTtcblxuICAgIHZhciBSQURJQU5fRVBTSUxPTiA9IDFlLTQ7XG5cbiAgICBmdW5jdGlvbiBfdHJpbShzdHIpIHtcbiAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzKy8sICcnKS5yZXBsYWNlKC9cXHMrJC8sICcnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaW5lYXIgbWFwcGluZyBhIHZhbHVlIGZyb20gZG9tYWluIHRvIHJhbmdlXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTplY2hhcnRzL3V0aWwvbnVtYmVyXG4gICAgICogQHBhcmFtICB7KG51bWJlcnxBcnJheS48bnVtYmVyPil9IHZhbFxuICAgICAqIEBwYXJhbSAge0FycmF5LjxudW1iZXI+fSBkb21haW4gRG9tYWluIGV4dGVudCBkb21haW5bMF0gY2FuIGJlIGJpZ2dlciB0aGFuIGRvbWFpblsxXVxuICAgICAqIEBwYXJhbSAge0FycmF5LjxudW1iZXI+fSByYW5nZSAgUmFuZ2UgZXh0ZW50IHJhbmdlWzBdIGNhbiBiZSBiaWdnZXIgdGhhbiByYW5nZVsxXVxuICAgICAqIEBwYXJhbSAge2Jvb2xlYW59IGNsYW1wXG4gICAgICogQHJldHVybiB7KG51bWJlcnxBcnJheS48bnVtYmVyPn1cbiAgICAgKi9cbiAgICBudW1iZXIubGluZWFyTWFwID0gZnVuY3Rpb24gKHZhbCwgZG9tYWluLCByYW5nZSwgY2xhbXApIHtcbiAgICAgICAgdmFyIHN1YkRvbWFpbiA9IGRvbWFpblsxXSAtIGRvbWFpblswXTtcbiAgICAgICAgdmFyIHN1YlJhbmdlID0gcmFuZ2VbMV0gLSByYW5nZVswXTtcblxuICAgICAgICBpZiAoc3ViRG9tYWluID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gc3ViUmFuZ2UgPT09IDBcbiAgICAgICAgICAgICAgICA/IHJhbmdlWzBdXG4gICAgICAgICAgICAgICAgOiAocmFuZ2VbMF0gKyByYW5nZVsxXSkgLyAyO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQXZvaWQgYWNjdXJhY3kgcHJvYmxlbSBpbiBlZGdlLCBzdWNoIGFzXG4gICAgICAgIC8vIDE0Ni4zOSAtIDYyLjgzID09PSA4My41NTk5OTk5OTk5OTk5OS5cbiAgICAgICAgLy8gU2VlIGVjaGFydHMvdGVzdC91dC9zcGVjL3V0aWwvbnVtYmVyLmpzI2xpbmVhck1hcCNhY2N1cmFjeUVycm9yXG4gICAgICAgIC8vIEl0IGlzIGEgbGl0dGxlIHZlcmJvc2UgZm9yIGVmZmljaWVuY3kgY29uc2lkZXJpbmcgdGhpcyBtZXRob2RcbiAgICAgICAgLy8gaXMgYSBob3RzcG90LlxuICAgICAgICBpZiAoY2xhbXApIHtcbiAgICAgICAgICAgIGlmIChzdWJEb21haW4gPiAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbCA8PSBkb21haW5bMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJhbmdlWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWwgPj0gZG9tYWluWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByYW5nZVsxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsID49IGRvbWFpblswXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmFuZ2VbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbCA8PSBkb21haW5bMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJhbmdlWzFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh2YWwgPT09IGRvbWFpblswXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByYW5nZVswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWwgPT09IGRvbWFpblsxXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByYW5nZVsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAodmFsIC0gZG9tYWluWzBdKSAvIHN1YkRvbWFpbiAqIHN1YlJhbmdlICsgcmFuZ2VbMF07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgYSBwZXJjZW50IHN0cmluZyB0byBhYnNvbHV0ZSBudW1iZXIuXG4gICAgICogUmV0dXJucyBOYU4gaWYgcGVyY2VudCBpcyBub3QgYSB2YWxpZCBzdHJpbmcgb3IgbnVtYmVyXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTplY2hhcnRzL3V0aWwvbnVtYmVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBwZXJjZW50XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFsbFxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBudW1iZXIucGFyc2VQZXJjZW50ID0gZnVuY3Rpb24ocGVyY2VudCwgYWxsKSB7XG4gICAgICAgIHN3aXRjaCAocGVyY2VudCkge1xuICAgICAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICAgIGNhc2UgJ21pZGRsZSc6XG4gICAgICAgICAgICAgICAgcGVyY2VudCA9ICc1MCUnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgICAgICAgIHBlcmNlbnQgPSAnMCUnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgICAgICBwZXJjZW50ID0gJzEwMCUnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcGVyY2VudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmIChfdHJpbShwZXJjZW50KS5tYXRjaCgvJSQvKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHBlcmNlbnQpIC8gMTAwICogYWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChwZXJjZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwZXJjZW50ID09IG51bGwgPyBOYU4gOiArcGVyY2VudDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogKDEpIEZpeCByb3VuZGluZyBlcnJvciBvZiBmbG9hdCBudW1iZXJzLlxuICAgICAqICgyKSBTdXBwb3J0IHJldHVybiBzdHJpbmcgdG8gYXZvaWQgc2NpZW50aWZpYyBub3RhdGlvbiBsaWtlICczLjVlLTcnLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ByZWNpc2lvbl1cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXR1cm5TdHJdXG4gICAgICogQHJldHVybiB7bnVtYmVyfHN0cmluZ31cbiAgICAgKi9cbiAgICBudW1iZXIucm91bmQgPSBmdW5jdGlvbiAoeCwgcHJlY2lzaW9uLCByZXR1cm5TdHIpIHtcbiAgICAgICAgaWYgKHByZWNpc2lvbiA9PSBudWxsKSB7XG4gICAgICAgICAgICBwcmVjaXNpb24gPSAxMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBBdm9pZCByYW5nZSBlcnJvclxuICAgICAgICBwcmVjaXNpb24gPSBNYXRoLm1pbihNYXRoLm1heCgwLCBwcmVjaXNpb24pLCAyMCk7XG4gICAgICAgIHggPSAoK3gpLnRvRml4ZWQocHJlY2lzaW9uKTtcbiAgICAgICAgcmV0dXJuIHJldHVyblN0ciA/IHggOiAreDtcbiAgICB9O1xuXG4gICAgbnVtYmVyLmFzYyA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgICAgICAgYXJyLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBhIC0gYjtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBwcmVjaXNpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsXG4gICAgICovXG4gICAgbnVtYmVyLmdldFByZWNpc2lvbiA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgdmFsID0gK3ZhbDtcbiAgICAgICAgaWYgKGlzTmFOKHZhbCkpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIEl0IGlzIG11Y2ggZmFzdGVyIHRoYW4gbWV0aG9kcyBjb252ZXJ0aW5nIG51bWJlciB0byBzdHJpbmcgYXMgZm9sbG93c1xuICAgICAgICAvLyAgICAgIHZhciB0bXAgPSB2YWwudG9TdHJpbmcoKTtcbiAgICAgICAgLy8gICAgICByZXR1cm4gdG1wLmxlbmd0aCAtIDEgLSB0bXAuaW5kZXhPZignLicpO1xuICAgICAgICAvLyBlc3BlY2lhbGx5IHdoZW4gcHJlY2lzaW9uIGlzIGxvd1xuICAgICAgICB2YXIgZSA9IDE7XG4gICAgICAgIHZhciBjb3VudCA9IDA7XG4gICAgICAgIHdoaWxlIChNYXRoLnJvdW5kKHZhbCAqIGUpIC8gZSAhPT0gdmFsKSB7XG4gICAgICAgICAgICBlICo9IDEwO1xuICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY291bnQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gdmFsXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIG51bWJlci5nZXRQcmVjaXNpb25TYWZlID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICB2YXIgc3RyID0gdmFsLnRvU3RyaW5nKCk7XG5cbiAgICAgICAgLy8gQ29uc2lkZXIgc2NpZW50aWZpYyBub3RhdGlvbjogJzMuNGUtMTInICczLjRlKzEyJ1xuICAgICAgICB2YXIgZUluZGV4ID0gc3RyLmluZGV4T2YoJ2UnKTtcbiAgICAgICAgaWYgKGVJbmRleCA+IDApIHtcbiAgICAgICAgICAgIHZhciBwcmVjaXNpb24gPSArc3RyLnNsaWNlKGVJbmRleCArIDEpO1xuICAgICAgICAgICAgcmV0dXJuIHByZWNpc2lvbiA8IDAgPyAtcHJlY2lzaW9uIDogMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBkb3RJbmRleCA9IHN0ci5pbmRleE9mKCcuJyk7XG4gICAgICAgICAgICByZXR1cm4gZG90SW5kZXggPCAwID8gMCA6IHN0ci5sZW5ndGggLSAxIC0gZG90SW5kZXg7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTWluaW1hbCBkaWNlcm5pYmxlIGRhdGEgcHJlY2lzaW9pbiBhY2NvcmRpbmcgdG8gYSBzaW5nbGUgcGl4ZWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBkYXRhRXh0ZW50XG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gcGl4ZWxFeHRlbnRcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IHByZWNpc2lvblxuICAgICAqL1xuICAgIG51bWJlci5nZXRQaXhlbFByZWNpc2lvbiA9IGZ1bmN0aW9uIChkYXRhRXh0ZW50LCBwaXhlbEV4dGVudCkge1xuICAgICAgICB2YXIgbG9nID0gTWF0aC5sb2c7XG4gICAgICAgIHZhciBMTjEwID0gTWF0aC5MTjEwO1xuICAgICAgICB2YXIgZGF0YVF1YW50aXR5ID0gTWF0aC5mbG9vcihsb2coZGF0YUV4dGVudFsxXSAtIGRhdGFFeHRlbnRbMF0pIC8gTE4xMCk7XG4gICAgICAgIHZhciBzaXplUXVhbnRpdHkgPSBNYXRoLnJvdW5kKGxvZyhNYXRoLmFicyhwaXhlbEV4dGVudFsxXSAtIHBpeGVsRXh0ZW50WzBdKSkgLyBMTjEwKTtcbiAgICAgICAgLy8gdG9GaXhlZCgpIGRpZ2l0cyBhcmd1bWVudCBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMjAuXG4gICAgICAgIHZhciBwcmVjaXNpb24gPSBNYXRoLm1pbihNYXRoLm1heCgtZGF0YVF1YW50aXR5ICsgc2l6ZVF1YW50aXR5LCAwKSwgMjApO1xuICAgICAgICByZXR1cm4gIWlzRmluaXRlKHByZWNpc2lvbikgPyAyMCA6IHByZWNpc2lvbjtcbiAgICB9O1xuXG4gICAgLy8gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIsIGllIGRvIG5vdCBzdXBwb3J0LlxuICAgIG51bWJlci5NQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuICAgIC8qKlxuICAgICAqIFRvIDAgLSAyICogUEksIGNvbnNpZGVyaW5nIG5lZ2F0aXZlIHJhZGlhbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmFkaWFuXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIG51bWJlci5yZW1SYWRpYW4gPSBmdW5jdGlvbiAocmFkaWFuKSB7XG4gICAgICAgIHZhciBwaTIgPSBNYXRoLlBJICogMjtcbiAgICAgICAgcmV0dXJuIChyYWRpYW4gJSBwaTIgKyBwaTIpICUgcGkyO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3R5cGV9IHJhZGlhblxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgbnVtYmVyLmlzUmFkaWFuQXJvdW5kWmVybyA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgcmV0dXJuIHZhbCA+IC1SQURJQU5fRVBTSUxPTiAmJiB2YWwgPCBSQURJQU5fRVBTSUxPTjtcbiAgICB9O1xuXG4gICAgdmFyIFRJTUVfUkVHID0gL14oPzooXFxkezR9KSg/OlstXFwvXShcXGR7MSwyfSkoPzpbLVxcL10oXFxkezEsMn0pKD86W1QgXShcXGR7MSwyfSkoPzo6KFxcZFxcZCkoPzo6KFxcZFxcZCkoPzpbLixdKFxcZCspKT8pPyk/KFp8W1xcK1xcLV1cXGRcXGQ6P1xcZFxcZCk/KT8pPyk/KT8kLzsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IGluIG1pbnV0ZXNcbiAgICAgKi9cbiAgICBudW1iZXIuZ2V0VGltZXpvbmVPZmZzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAobmV3IERhdGUoKSkuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd8RGF0ZXxudW1iZXJ9IHZhbHVlIFRoZXNlIHZhbHVlcyBjYW4gYmUgYWNjZXB0ZWQ6XG4gICAgICogICArIEFuIGluc3RhbmNlIG9mIERhdGUsIHJlcHJlc2VudCBhIHRpbWUgaW4gaXRzIG93biB0aW1lIHpvbmUuXG4gICAgICogICArIE9yIHN0cmluZyBpbiBhIHN1YnNldCBvZiBJU08gODYwMSwgb25seSBpbmNsdWRpbmc6XG4gICAgICogICAgICsgb25seSB5ZWFyLCBtb250aCwgZGF0ZTogJzIwMTItMDMnLCAnMjAxMi0wMy0wMScsICcyMDEyLTAzLTAxIDA1JywgJzIwMTItMDMtMDEgMDU6MDYnLFxuICAgICAqICAgICArIHNlcGFyYXRlZCB3aXRoIFQgb3Igc3BhY2U6ICcyMDEyLTAzLTAxVDEyOjIyOjMzLjEyMycsICcyMDEyLTAzLTAxIDEyOjIyOjMzLjEyMycsXG4gICAgICogICAgICsgdGltZSB6b25lOiAnMjAxMi0wMy0wMVQxMjoyMjozM1onLCAnMjAxMi0wMy0wMVQxMjoyMjozMys4MDAwJywgJzIwMTItMDMtMDFUMTI6MjI6MzMtMDU6MDAnLFxuICAgICAqICAgICBhbGwgb2Ygd2hpY2ggd2lsbCBiZSB0cmVhdGVkIGFzIGxvY2FsIHRpbWUgaWYgdGltZSB6b25lIGlzIG5vdCBzcGVjaWZpZWRcbiAgICAgKiAgICAgKHNlZSA8aHR0cHM6Ly9tb21lbnRqcy5jb20vPikuXG4gICAgICogICArIE9yIG90aGVyIHN0cmluZyBmb3JtYXQsIGluY2x1ZGluZyAoYWxsIG9mIHdoaWNoIHdpbGwgYmUgdHJlYXRlZCBhcyBsb2FjYWwgdGltZSk6XG4gICAgICogICAgICcyMDEyJywgJzIwMTItMy0xJywgJzIwMTIvMy8xJywgJzIwMTIvMDMvMDEnLFxuICAgICAqICAgICAnMjAwOS82LzEyIDI6MDAnLCAnMjAwOS82LzEyIDI6MDU6MDgnLCAnMjAwOS82LzEyIDI6MDU6MDguMTIzJ1xuICAgICAqICAgKyBhIHRpbWVzdGFtcCwgd2hpY2ggcmVwcmVzZW50IGEgdGltZSBpbiBVVEMuXG4gICAgICogQHJldHVybiB7RGF0ZX0gZGF0ZVxuICAgICAqL1xuICAgIG51bWJlci5wYXJzZURhdGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIC8vIERpZmZlcmVudCBicm93c2VycyBwYXJzZSBkYXRlIGluIGRpZmZlcmVudCB3YXksIHNvIHdlIHBhcnNlIGl0IG1hbnVhbGx5LlxuICAgICAgICAgICAgLy8gU29tZSBvdGhlciBpc3N1ZXM6XG4gICAgICAgICAgICAvLyBuZXcgRGF0ZSgnMTk3MC0wMS0wMScpIGlzIFVUQyxcbiAgICAgICAgICAgIC8vIG5ldyBEYXRlKCcxOTcwLzAxLzAxJykgYW5kIG5ldyBEYXRlKCcxOTcwLTEtMDEnKSBpcyBsb2NhbC5cbiAgICAgICAgICAgIC8vIFNlZSBpc3N1ZSAjMzYyM1xuICAgICAgICAgICAgdmFyIG1hdGNoID0gVElNRV9SRUcuZXhlYyh2YWx1ZSk7XG5cbiAgICAgICAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAvLyByZXR1cm4gSW52YWxpZCBEYXRlLlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShOYU4pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdGltZXpvbmVPZmZzZXQgPSBudW1iZXIuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgICAgICAgICAgIHZhciB0aW1lT2Zmc2V0ID0gIW1hdGNoWzhdXG4gICAgICAgICAgICAgICAgPyAwXG4gICAgICAgICAgICAgICAgOiBtYXRjaFs4XS50b1VwcGVyQ2FzZSgpID09PSAnWidcbiAgICAgICAgICAgICAgICA/IHRpbWV6b25lT2Zmc2V0XG4gICAgICAgICAgICAgICAgOiArbWF0Y2hbOF0uc2xpY2UoMCwgMykgKiA2MCArIHRpbWV6b25lT2Zmc2V0O1xuXG4gICAgICAgICAgICAvLyBtYXRjaFtuXSBjYW4gb25seSBiZSBzdHJpbmcgb3IgdW5kZWZpbmVkLlxuICAgICAgICAgICAgLy8gQnV0IHRha2UgY2FyZSBvZiAnMTInICsgMSA9PiAnMTIxJy5cbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShcbiAgICAgICAgICAgICAgICArbWF0Y2hbMV0sXG4gICAgICAgICAgICAgICAgKyhtYXRjaFsyXSB8fCAxKSAtIDEsXG4gICAgICAgICAgICAgICAgK21hdGNoWzNdIHx8IDEsXG4gICAgICAgICAgICAgICAgK21hdGNoWzRdIHx8IDAsXG4gICAgICAgICAgICAgICAgKyhtYXRjaFs1XSB8fCAwKSAtIHRpbWVPZmZzZXQsXG4gICAgICAgICAgICAgICAgK21hdGNoWzZdIHx8IDAsXG4gICAgICAgICAgICAgICAgK21hdGNoWzddIHx8IDBcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKE5hTik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IERhdGUoTWF0aC5yb3VuZCh2YWx1ZSkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBRdWFudGl0eSBvZiBhIG51bWJlci4gZS5nLiAwLjEsIDEsIDEwLCAxMDBcbiAgICAgKlxuICAgICAqIEBwYXJhbSAge251bWJlcn0gdmFsXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIG51bWJlci5xdWFudGl0eSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgucG93KDEwLCBxdWFudGl0eUV4cG9uZW50KHZhbCkpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBxdWFudGl0eUV4cG9uZW50KHZhbCkge1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWwpIC8gTWF0aC5MTjEwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBmaW5kIGEg4oCcbmljZeKAnSBudW1iZXIgYXBwcm94aW1hdGVseSBlcXVhbCB0byB4LiBSb3VuZCB0aGUgbnVtYmVyIGlmIHJvdW5kID0gdHJ1ZSxcbiAgICAgKiB0YWtlIGNlaWxpbmcgaWYgcm91bmQgPSBmYWxzZS4gVGhlIHByaW1hcnkgb2JzZXJ2YXRpb24gaXMgdGhhdCB0aGUg4oCcbmljZXN04oCdXG4gICAgICogbnVtYmVycyBpbiBkZWNpbWFsIGFyZSAxLCAyLCBhbmQgNSwgYW5kIGFsbCBwb3dlci1vZi10ZW4gbXVsdGlwbGVzIG9mIHRoZXNlIG51bWJlcnMuXG4gICAgICpcbiAgICAgKiBTZWUgXCJOaWNlIE51bWJlcnMgZm9yIEdyYXBoIExhYmVsc1wiIG9mIEdyYXBoaWMgR2Vtcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge251bWJlcn0gdmFsIE5vbi1uZWdhdGl2ZSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0gIHtib29sZWFufSByb3VuZFxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBudW1iZXIubmljZSA9IGZ1bmN0aW9uICh2YWwsIHJvdW5kKSB7XG4gICAgICAgIHZhciBleHBvbmVudCA9IHF1YW50aXR5RXhwb25lbnQodmFsKTtcbiAgICAgICAgdmFyIGV4cDEwID0gTWF0aC5wb3coMTAsIGV4cG9uZW50KTtcbiAgICAgICAgdmFyIGYgPSB2YWwgLyBleHAxMDsgLy8gMSA8PSBmIDwgMTBcbiAgICAgICAgdmFyIG5mO1xuICAgICAgICBpZiAocm91bmQpIHtcbiAgICAgICAgICAgIGlmIChmIDwgMS41KSB7IG5mID0gMTsgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZiA8IDIuNSkgeyBuZiA9IDI7IH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGYgPCA0KSB7IG5mID0gMzsgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZiA8IDcpIHsgbmYgPSA1OyB9XG4gICAgICAgICAgICBlbHNlIHsgbmYgPSAxMDsgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGYgPCAxKSB7IG5mID0gMTsgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZiA8IDIpIHsgbmYgPSAyOyB9XG4gICAgICAgICAgICBlbHNlIGlmIChmIDwgMykgeyBuZiA9IDM7IH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGYgPCA1KSB7IG5mID0gNTsgfVxuICAgICAgICAgICAgZWxzZSB7IG5mID0gMTA7IH1cbiAgICAgICAgfVxuICAgICAgICB2YWwgPSBuZiAqIGV4cDEwO1xuXG4gICAgICAgIC8vIEZpeCAzICogMC4xID09PSAwLjMwMDAwMDAwMDAwMDAwMDA0IGlzc3VlIChzZWUgSUVFRSA3NTQpLlxuICAgICAgICAvLyAyMCBpcyB0aGUgdXBwcGVyIGJvdW5kIG9mIHRvRml4ZWQuXG4gICAgICAgIHJldHVybiBleHBvbmVudCA+PSAtMjAgPyArdmFsLnRvRml4ZWQoZXhwb25lbnQgPCAwID8gLWV4cG9uZW50IDogMCkgOiB2YWw7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIE9yZGVyIGludGVydmFscyBhc2MsIGFuZCBzcGxpdCB0aGVtIHdoZW4gb3ZlcmxhcC5cbiAgICAgKiBleHBlY3QobnVtYmVyVXRpbC5yZWZvcm1JbnRlcnZhbHMoW1xuICAgICAqICAgICB7aW50ZXJ2YWw6IFsxOCwgNjJdLCBjbG9zZTogWzEsIDFdfSxcbiAgICAgKiAgICAge2ludGVydmFsOiBbLUluZmluaXR5LCAtNzBdLCBjbG9zZTogWzAsIDBdfSxcbiAgICAgKiAgICAge2ludGVydmFsOiBbLTcwLCAtMjZdLCBjbG9zZTogWzEsIDFdfSxcbiAgICAgKiAgICAge2ludGVydmFsOiBbLTI2LCAxOF0sIGNsb3NlOiBbMSwgMV19LFxuICAgICAqICAgICB7aW50ZXJ2YWw6IFs2MiwgMTUwXSwgY2xvc2U6IFsxLCAxXX0sXG4gICAgICogICAgIHtpbnRlcnZhbDogWzEwNiwgMTUwXSwgY2xvc2U6IFsxLCAxXX0sXG4gICAgICogICAgIHtpbnRlcnZhbDogWzE1MCwgSW5maW5pdHldLCBjbG9zZTogWzAsIDBdfVxuICAgICAqIF0pKS50b0VxdWFsKFtcbiAgICAgKiAgICAge2ludGVydmFsOiBbLUluZmluaXR5LCAtNzBdLCBjbG9zZTogWzAsIDBdfSxcbiAgICAgKiAgICAge2ludGVydmFsOiBbLTcwLCAtMjZdLCBjbG9zZTogWzEsIDFdfSxcbiAgICAgKiAgICAge2ludGVydmFsOiBbLTI2LCAxOF0sIGNsb3NlOiBbMCwgMV19LFxuICAgICAqICAgICB7aW50ZXJ2YWw6IFsxOCwgNjJdLCBjbG9zZTogWzAsIDFdfSxcbiAgICAgKiAgICAge2ludGVydmFsOiBbNjIsIDE1MF0sIGNsb3NlOiBbMCwgMV19LFxuICAgICAqICAgICB7aW50ZXJ2YWw6IFsxNTAsIEluZmluaXR5XSwgY2xvc2U6IFswLCAwXX1cbiAgICAgKiBdKTtcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxPYmplY3Q+fSBsaXN0LCB3aGVyZSBgY2xvc2VgIG1lYW4gb3BlbiBvciBjbG9zZVxuICAgICAqICAgICAgICBvZiB0aGUgaW50ZXJ2YWwsIGFuZCBJbmZpbml0eSBjYW4gYmUgdXNlZC5cbiAgICAgKiBAcmV0dXJuIHtBcnJheS48T2JqZWN0Pn0gVGhlIG9yaWdpbiBsaXN0LCB3aGljaCBoYXMgYmVlbiByZWZvcm1lZC5cbiAgICAgKi9cbiAgICBudW1iZXIucmVmb3JtSW50ZXJ2YWxzID0gZnVuY3Rpb24gKGxpc3QpIHtcbiAgICAgICAgbGlzdC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gbGl0dGxlVGhhbihhLCBiLCAwKSA/IC0xIDogMTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIGN1cnIgPSAtSW5maW5pdHk7XG4gICAgICAgIHZhciBjdXJyQ2xvc2UgPSAxO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOykge1xuICAgICAgICAgICAgdmFyIGludGVydmFsID0gbGlzdFtpXS5pbnRlcnZhbDtcbiAgICAgICAgICAgIHZhciBjbG9zZSA9IGxpc3RbaV0uY2xvc2U7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGxnID0gMDsgbGcgPCAyOyBsZysrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGludGVydmFsW2xnXSA8PSBjdXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGludGVydmFsW2xnXSA9IGN1cnI7XG4gICAgICAgICAgICAgICAgICAgIGNsb3NlW2xnXSA9ICFsZyA/IDEgLSBjdXJyQ2xvc2UgOiAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJyID0gaW50ZXJ2YWxbbGddO1xuICAgICAgICAgICAgICAgIGN1cnJDbG9zZSA9IGNsb3NlW2xnXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGludGVydmFsWzBdID09PSBpbnRlcnZhbFsxXSAmJiBjbG9zZVswXSAqIGNsb3NlWzFdICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgbGlzdC5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGlzdDtcblxuICAgICAgICBmdW5jdGlvbiBsaXR0bGVUaGFuKGEsIGIsIGxnKSB7XG4gICAgICAgICAgICByZXR1cm4gYS5pbnRlcnZhbFtsZ10gPCBiLmludGVydmFsW2xnXVxuICAgICAgICAgICAgICAgIHx8IChcbiAgICAgICAgICAgICAgICAgICAgYS5pbnRlcnZhbFtsZ10gPT09IGIuaW50ZXJ2YWxbbGddXG4gICAgICAgICAgICAgICAgICAgICYmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIChhLmNsb3NlW2xnXSAtIGIuY2xvc2VbbGddID09PSAoIWxnID8gMSA6IC0xKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHx8ICghbGcgJiYgbGl0dGxlVGhhbihhLCBiLCAxKSlcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogcGFyc2VGbG9hdCBOYU5zIG51bWVyaWMtY2FzdCBmYWxzZSBwb3NpdGl2ZXMgKG51bGx8dHJ1ZXxmYWxzZXxcIlwiKVxuICAgICAqIC4uLmJ1dCBtaXNpbnRlcnByZXRzIGxlYWRpbmctbnVtYmVyIHN0cmluZ3MsIHBhcnRpY3VsYXJseSBoZXggbGl0ZXJhbHMgKFwiMHguLi5cIilcbiAgICAgKiBzdWJ0cmFjdGlvbiBmb3JjZXMgaW5maW5pdGllcyB0byBOYU5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gdlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgbnVtYmVyLmlzTnVtZXJpYyA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHJldHVybiB2IC0gcGFyc2VGbG9hdCh2KSA+PSAwO1xuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IG51bWJlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL3V0aWwvbnVtYmVyLmpzXG4vLyBtb2R1bGUgaWQgPSAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 4 */
/* unknown exports provided */
/* all exports used */
/*!*********************************************!*\
  !*** /home/yx/~/zrender/lib/core/vector.js ***!
  \*********************************************/
/***/ (function(module, exports) {

eval("\n    var ArrayCtor = typeof Float32Array === 'undefined'\n        ? Array\n        : Float32Array;\n\n    /**\n     * @typedef {Float32Array|Array.<number>} Vector2\n     */\n    /**\n     * 二维向量类\n     * @exports zrender/tool/vector\n     */\n    var vector = {\n        /**\n         * 创建一个向量\n         * @param {number} [x=0]\n         * @param {number} [y=0]\n         * @return {Vector2}\n         */\n        create: function (x, y) {\n            var out = new ArrayCtor(2);\n            if (x == null) {\n                x = 0;\n            }\n            if (y == null) {\n                y = 0;\n            }\n            out[0] = x;\n            out[1] = y;\n            return out;\n        },\n\n        /**\n         * 复制向量数据\n         * @param {Vector2} out\n         * @param {Vector2} v\n         * @return {Vector2}\n         */\n        copy: function (out, v) {\n            out[0] = v[0];\n            out[1] = v[1];\n            return out;\n        },\n\n        /**\n         * 克隆一个向量\n         * @param {Vector2} v\n         * @return {Vector2}\n         */\n        clone: function (v) {\n            var out = new ArrayCtor(2);\n            out[0] = v[0];\n            out[1] = v[1];\n            return out;\n        },\n\n        /**\n         * 设置向量的两个项\n         * @param {Vector2} out\n         * @param {number} a\n         * @param {number} b\n         * @return {Vector2} 结果\n         */\n        set: function (out, a, b) {\n            out[0] = a;\n            out[1] = b;\n            return out;\n        },\n\n        /**\n         * 向量相加\n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        add: function (out, v1, v2) {\n            out[0] = v1[0] + v2[0];\n            out[1] = v1[1] + v2[1];\n            return out;\n        },\n\n        /**\n         * 向量缩放后相加\n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @param {number} a\n         */\n        scaleAndAdd: function (out, v1, v2, a) {\n            out[0] = v1[0] + v2[0] * a;\n            out[1] = v1[1] + v2[1] * a;\n            return out;\n        },\n\n        /**\n         * 向量相减\n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        sub: function (out, v1, v2) {\n            out[0] = v1[0] - v2[0];\n            out[1] = v1[1] - v2[1];\n            return out;\n        },\n\n        /**\n         * 向量长度\n         * @param {Vector2} v\n         * @return {number}\n         */\n        len: function (v) {\n            return Math.sqrt(this.lenSquare(v));\n        },\n\n        /**\n         * 向量长度平方\n         * @param {Vector2} v\n         * @return {number}\n         */\n        lenSquare: function (v) {\n            return v[0] * v[0] + v[1] * v[1];\n        },\n\n        /**\n         * 向量乘法\n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        mul: function (out, v1, v2) {\n            out[0] = v1[0] * v2[0];\n            out[1] = v1[1] * v2[1];\n            return out;\n        },\n\n        /**\n         * 向量除法\n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        div: function (out, v1, v2) {\n            out[0] = v1[0] / v2[0];\n            out[1] = v1[1] / v2[1];\n            return out;\n        },\n\n        /**\n         * 向量点乘\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @return {number}\n         */\n        dot: function (v1, v2) {\n            return v1[0] * v2[0] + v1[1] * v2[1];\n        },\n\n        /**\n         * 向量缩放\n         * @param {Vector2} out\n         * @param {Vector2} v\n         * @param {number} s\n         */\n        scale: function (out, v, s) {\n            out[0] = v[0] * s;\n            out[1] = v[1] * s;\n            return out;\n        },\n\n        /**\n         * 向量归一化\n         * @param {Vector2} out\n         * @param {Vector2} v\n         */\n        normalize: function (out, v) {\n            var d = vector.len(v);\n            if (d === 0) {\n                out[0] = 0;\n                out[1] = 0;\n            }\n            else {\n                out[0] = v[0] / d;\n                out[1] = v[1] / d;\n            }\n            return out;\n        },\n\n        /**\n         * 计算向量间距离\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @return {number}\n         */\n        distance: function (v1, v2) {\n            return Math.sqrt(\n                (v1[0] - v2[0]) * (v1[0] - v2[0])\n                + (v1[1] - v2[1]) * (v1[1] - v2[1])\n            );\n        },\n\n        /**\n         * 向量距离平方\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @return {number}\n         */\n        distanceSquare: function (v1, v2) {\n            return (v1[0] - v2[0]) * (v1[0] - v2[0])\n                + (v1[1] - v2[1]) * (v1[1] - v2[1]);\n        },\n\n        /**\n         * 求负向量\n         * @param {Vector2} out\n         * @param {Vector2} v\n         */\n        negate: function (out, v) {\n            out[0] = -v[0];\n            out[1] = -v[1];\n            return out;\n        },\n\n        /**\n         * 插值两个点\n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @param {number} t\n         */\n        lerp: function (out, v1, v2, t) {\n            out[0] = v1[0] + t * (v2[0] - v1[0]);\n            out[1] = v1[1] + t * (v2[1] - v1[1]);\n            return out;\n        },\n\n        /**\n         * 矩阵左乘向量\n         * @param {Vector2} out\n         * @param {Vector2} v\n         * @param {Vector2} m\n         */\n        applyTransform: function (out, v, m) {\n            var x = v[0];\n            var y = v[1];\n            out[0] = m[0] * x + m[2] * y + m[4];\n            out[1] = m[1] * x + m[3] * y + m[5];\n            return out;\n        },\n        /**\n         * 求两个向量最小值\n         * @param  {Vector2} out\n         * @param  {Vector2} v1\n         * @param  {Vector2} v2\n         */\n        min: function (out, v1, v2) {\n            out[0] = Math.min(v1[0], v2[0]);\n            out[1] = Math.min(v1[1], v2[1]);\n            return out;\n        },\n        /**\n         * 求两个向量最大值\n         * @param  {Vector2} out\n         * @param  {Vector2} v1\n         * @param  {Vector2} v2\n         */\n        max: function (out, v1, v2) {\n            out[0] = Math.max(v1[0], v2[0]);\n            out[1] = Math.max(v1[1], v2[1]);\n            return out;\n        }\n    };\n\n    vector.length = vector.len;\n    vector.lengthSquare = vector.lenSquare;\n    vector.dist = vector.distance;\n    vector.distSquare = vector.distanceSquare;\n\n    module.exports = vector;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vaG9tZS95eC9+L3pyZW5kZXIvbGliL2NvcmUvdmVjdG9yLmpzPzA1NTciXSwic291cmNlc0NvbnRlbnQiOlsiXG4gICAgdmFyIEFycmF5Q3RvciA9IHR5cGVvZiBGbG9hdDMyQXJyYXkgPT09ICd1bmRlZmluZWQnXG4gICAgICAgID8gQXJyYXlcbiAgICAgICAgOiBGbG9hdDMyQXJyYXk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBWZWN0b3IyXG4gICAgICovXG4gICAgLyoqXG4gICAgICog5LqM57u05ZCR6YeP57G7XG4gICAgICogQGV4cG9ydHMgenJlbmRlci90b29sL3ZlY3RvclxuICAgICAqL1xuICAgIHZhciB2ZWN0b3IgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDliJvlu7rkuIDkuKrlkJHph49cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFt4PTBdXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbeT0wXVxuICAgICAgICAgKiBAcmV0dXJuIHtWZWN0b3IyfVxuICAgICAgICAgKi9cbiAgICAgICAgY3JlYXRlOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgdmFyIG91dCA9IG5ldyBBcnJheUN0b3IoMik7XG4gICAgICAgICAgICBpZiAoeCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgeCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgeSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXRbMF0gPSB4O1xuICAgICAgICAgICAgb3V0WzFdID0geTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWkjeWItuWQkemHj+aVsOaNrlxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHZcbiAgICAgICAgICogQHJldHVybiB7VmVjdG9yMn1cbiAgICAgICAgICovXG4gICAgICAgIGNvcHk6IGZ1bmN0aW9uIChvdXQsIHYpIHtcbiAgICAgICAgICAgIG91dFswXSA9IHZbMF07XG4gICAgICAgICAgICBvdXRbMV0gPSB2WzFdO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5YWL6ZqG5LiA5Liq5ZCR6YePXG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdlxuICAgICAgICAgKiBAcmV0dXJuIHtWZWN0b3IyfVxuICAgICAgICAgKi9cbiAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICB2YXIgb3V0ID0gbmV3IEFycmF5Q3RvcigyKTtcbiAgICAgICAgICAgIG91dFswXSA9IHZbMF07XG4gICAgICAgICAgICBvdXRbMV0gPSB2WzFdO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog6K6+572u5ZCR6YeP55qE5Lik5Liq6aG5XG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gb3V0XG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiXG4gICAgICAgICAqIEByZXR1cm4ge1ZlY3RvcjJ9IOe7k+aenFxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAob3V0LCBhLCBiKSB7XG4gICAgICAgICAgICBvdXRbMF0gPSBhO1xuICAgICAgICAgICAgb3V0WzFdID0gYjtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWQkemHj+ebuOWKoFxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHYxXG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdjJcbiAgICAgICAgICovXG4gICAgICAgIGFkZDogZnVuY3Rpb24gKG91dCwgdjEsIHYyKSB7XG4gICAgICAgICAgICBvdXRbMF0gPSB2MVswXSArIHYyWzBdO1xuICAgICAgICAgICAgb3V0WzFdID0gdjFbMV0gKyB2MlsxXTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWQkemHj+e8qeaUvuWQjuebuOWKoFxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHYxXG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdjJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGFcbiAgICAgICAgICovXG4gICAgICAgIHNjYWxlQW5kQWRkOiBmdW5jdGlvbiAob3V0LCB2MSwgdjIsIGEpIHtcbiAgICAgICAgICAgIG91dFswXSA9IHYxWzBdICsgdjJbMF0gKiBhO1xuICAgICAgICAgICAgb3V0WzFdID0gdjFbMV0gKyB2MlsxXSAqIGE7XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlkJHph4/nm7jlh49cbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2MVxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHYyXG4gICAgICAgICAqL1xuICAgICAgICBzdWI6IGZ1bmN0aW9uIChvdXQsIHYxLCB2Mikge1xuICAgICAgICAgICAgb3V0WzBdID0gdjFbMF0gLSB2MlswXTtcbiAgICAgICAgICAgIG91dFsxXSA9IHYxWzFdIC0gdjJbMV07XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlkJHph4/plb/luqZcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2XG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIGxlbjogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnNxcnQodGhpcy5sZW5TcXVhcmUodikpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlkJHph4/plb/luqblubPmlrlcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2XG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIGxlblNxdWFyZTogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHJldHVybiB2WzBdICogdlswXSArIHZbMV0gKiB2WzFdO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlkJHph4/kuZjms5VcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2MVxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHYyXG4gICAgICAgICAqL1xuICAgICAgICBtdWw6IGZ1bmN0aW9uIChvdXQsIHYxLCB2Mikge1xuICAgICAgICAgICAgb3V0WzBdID0gdjFbMF0gKiB2MlswXTtcbiAgICAgICAgICAgIG91dFsxXSA9IHYxWzFdICogdjJbMV07XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlkJHph4/pmaTms5VcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2MVxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHYyXG4gICAgICAgICAqL1xuICAgICAgICBkaXY6IGZ1bmN0aW9uIChvdXQsIHYxLCB2Mikge1xuICAgICAgICAgICAgb3V0WzBdID0gdjFbMF0gLyB2MlswXTtcbiAgICAgICAgICAgIG91dFsxXSA9IHYxWzFdIC8gdjJbMV07XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlkJHph4/ngrnkuZhcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2MVxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHYyXG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIGRvdDogZnVuY3Rpb24gKHYxLCB2Mikge1xuICAgICAgICAgICAgcmV0dXJuIHYxWzBdICogdjJbMF0gKyB2MVsxXSAqIHYyWzFdO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlkJHph4/nvKnmlL5cbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2XG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzXG4gICAgICAgICAqL1xuICAgICAgICBzY2FsZTogZnVuY3Rpb24gKG91dCwgdiwgcykge1xuICAgICAgICAgICAgb3V0WzBdID0gdlswXSAqIHM7XG4gICAgICAgICAgICBvdXRbMV0gPSB2WzFdICogcztcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWQkemHj+W9kuS4gOWMllxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHZcbiAgICAgICAgICovXG4gICAgICAgIG5vcm1hbGl6ZTogZnVuY3Rpb24gKG91dCwgdikge1xuICAgICAgICAgICAgdmFyIGQgPSB2ZWN0b3IubGVuKHYpO1xuICAgICAgICAgICAgaWYgKGQgPT09IDApIHtcbiAgICAgICAgICAgICAgICBvdXRbMF0gPSAwO1xuICAgICAgICAgICAgICAgIG91dFsxXSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXRbMF0gPSB2WzBdIC8gZDtcbiAgICAgICAgICAgICAgICBvdXRbMV0gPSB2WzFdIC8gZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiuoeeul+WQkemHj+mXtOi3neemu1xuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHYxXG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdjJcbiAgICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgZGlzdGFuY2U6IGZ1bmN0aW9uICh2MSwgdjIpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnNxcnQoXG4gICAgICAgICAgICAgICAgKHYxWzBdIC0gdjJbMF0pICogKHYxWzBdIC0gdjJbMF0pXG4gICAgICAgICAgICAgICAgKyAodjFbMV0gLSB2MlsxXSkgKiAodjFbMV0gLSB2MlsxXSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWQkemHj+i3neemu+W5s+aWuVxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHYxXG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdjJcbiAgICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgZGlzdGFuY2VTcXVhcmU6IGZ1bmN0aW9uICh2MSwgdjIpIHtcbiAgICAgICAgICAgIHJldHVybiAodjFbMF0gLSB2MlswXSkgKiAodjFbMF0gLSB2MlswXSlcbiAgICAgICAgICAgICAgICArICh2MVsxXSAtIHYyWzFdKSAqICh2MVsxXSAtIHYyWzFdKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5rGC6LSf5ZCR6YePXG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gb3V0XG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdlxuICAgICAgICAgKi9cbiAgICAgICAgbmVnYXRlOiBmdW5jdGlvbiAob3V0LCB2KSB7XG4gICAgICAgICAgICBvdXRbMF0gPSAtdlswXTtcbiAgICAgICAgICAgIG91dFsxXSA9IC12WzFdO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5o+S5YC85Lik5Liq54K5XG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gb3V0XG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdjFcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2MlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gdFxuICAgICAgICAgKi9cbiAgICAgICAgbGVycDogZnVuY3Rpb24gKG91dCwgdjEsIHYyLCB0KSB7XG4gICAgICAgICAgICBvdXRbMF0gPSB2MVswXSArIHQgKiAodjJbMF0gLSB2MVswXSk7XG4gICAgICAgICAgICBvdXRbMV0gPSB2MVsxXSArIHQgKiAodjJbMV0gLSB2MVsxXSk7XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDnn6npmLXlt6bkuZjlkJHph49cbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2XG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gbVxuICAgICAgICAgKi9cbiAgICAgICAgYXBwbHlUcmFuc2Zvcm06IGZ1bmN0aW9uIChvdXQsIHYsIG0pIHtcbiAgICAgICAgICAgIHZhciB4ID0gdlswXTtcbiAgICAgICAgICAgIHZhciB5ID0gdlsxXTtcbiAgICAgICAgICAgIG91dFswXSA9IG1bMF0gKiB4ICsgbVsyXSAqIHkgKyBtWzRdO1xuICAgICAgICAgICAgb3V0WzFdID0gbVsxXSAqIHggKyBtWzNdICogeSArIG1bNV07XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICog5rGC5Lik5Liq5ZCR6YeP5pyA5bCP5YC8XG4gICAgICAgICAqIEBwYXJhbSAge1ZlY3RvcjJ9IG91dFxuICAgICAgICAgKiBAcGFyYW0gIHtWZWN0b3IyfSB2MVxuICAgICAgICAgKiBAcGFyYW0gIHtWZWN0b3IyfSB2MlxuICAgICAgICAgKi9cbiAgICAgICAgbWluOiBmdW5jdGlvbiAob3V0LCB2MSwgdjIpIHtcbiAgICAgICAgICAgIG91dFswXSA9IE1hdGgubWluKHYxWzBdLCB2MlswXSk7XG4gICAgICAgICAgICBvdXRbMV0gPSBNYXRoLm1pbih2MVsxXSwgdjJbMV0pO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaxguS4pOS4quWQkemHj+acgOWkp+WAvFxuICAgICAgICAgKiBAcGFyYW0gIHtWZWN0b3IyfSBvdXRcbiAgICAgICAgICogQHBhcmFtICB7VmVjdG9yMn0gdjFcbiAgICAgICAgICogQHBhcmFtICB7VmVjdG9yMn0gdjJcbiAgICAgICAgICovXG4gICAgICAgIG1heDogZnVuY3Rpb24gKG91dCwgdjEsIHYyKSB7XG4gICAgICAgICAgICBvdXRbMF0gPSBNYXRoLm1heCh2MVswXSwgdjJbMF0pO1xuICAgICAgICAgICAgb3V0WzFdID0gTWF0aC5tYXgodjFbMV0sIHYyWzFdKTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmVjdG9yLmxlbmd0aCA9IHZlY3Rvci5sZW47XG4gICAgdmVjdG9yLmxlbmd0aFNxdWFyZSA9IHZlY3Rvci5sZW5TcXVhcmU7XG4gICAgdmVjdG9yLmRpc3QgPSB2ZWN0b3IuZGlzdGFuY2U7XG4gICAgdmVjdG9yLmRpc3RTcXVhcmUgPSB2ZWN0b3IuZGlzdGFuY2VTcXVhcmU7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHZlY3RvcjtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2hvbWUveXgvfi96cmVuZGVyL2xpYi9jb3JlL3ZlY3Rvci5qc1xuLy8gbW9kdWxlIGlkID0gNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 5 */
/* unknown exports provided */
/* all exports used */
/*!***************************!*\
  !*** ./lib/util/model.js ***!
  \***************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var formatUtil = __webpack_require__(/*! ./format */ 6);\n    var nubmerUtil = __webpack_require__(/*! ./number */ 3);\n    var Model = __webpack_require__(/*! ../model/Model */ 9);\n    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 0);\n    var each = zrUtil.each;\n    var isObject = zrUtil.isObject;\n\n    var modelUtil = {};\n\n    /**\n     * If value is not array, then translate it to array.\n     * @param  {*} value\n     * @return {Array} [value] or value\n     */\n    modelUtil.normalizeToArray = function (value) {\n        return value instanceof Array\n            ? value\n            : value == null\n            ? []\n            : [value];\n    };\n\n    /**\n     * Sync default option between normal and emphasis like `position` and `show`\n     * In case some one will write code like\n     *     label: {\n     *         normal: {\n     *             show: false,\n     *             position: 'outside',\n     *             textStyle: {\n     *                 fontSize: 18\n     *             }\n     *         },\n     *         emphasis: {\n     *             show: true\n     *         }\n     *     }\n     * @param {Object} opt\n     * @param {Array.<string>} subOpts\n     */\n     modelUtil.defaultEmphasis = function (opt, subOpts) {\n        if (opt) {\n            var emphasisOpt = opt.emphasis = opt.emphasis || {};\n            var normalOpt = opt.normal = opt.normal || {};\n\n            // Default emphasis option from normal\n            each(subOpts, function (subOptName) {\n                var val = zrUtil.retrieve(emphasisOpt[subOptName], normalOpt[subOptName]);\n                if (val != null) {\n                    emphasisOpt[subOptName] = val;\n                }\n            });\n        }\n    };\n\n    modelUtil.LABEL_OPTIONS = ['position', 'offset', 'show', 'textStyle', 'distance', 'formatter'];\n\n    /**\n     * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]\n     * This helper method retieves value from data.\n     * @param {string|number|Date|Array|Object} dataItem\n     * @return {number|string|Date|Array.<number|string|Date>}\n     */\n    modelUtil.getDataItemValue = function (dataItem) {\n        // Performance sensitive.\n        return dataItem && (dataItem.value == null ? dataItem : dataItem.value);\n    };\n\n    /**\n     * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]\n     * This helper method determine if dataItem has extra option besides value\n     * @param {string|number|Date|Array|Object} dataItem\n     */\n    modelUtil.isDataItemOption = function (dataItem) {\n        return isObject(dataItem)\n            && !(dataItem instanceof Array);\n            // // markLine data can be array\n            // && !(dataItem[0] && isObject(dataItem[0]) && !(dataItem[0] instanceof Array));\n    };\n\n    /**\n     * This helper method convert value in data.\n     * @param {string|number|Date} value\n     * @param {Object|string} [dimInfo] If string (like 'x'), dimType defaults 'number'.\n     */\n    modelUtil.converDataValue = function (value, dimInfo) {\n        // Performance sensitive.\n        var dimType = dimInfo && dimInfo.type;\n        if (dimType === 'ordinal') {\n            return value;\n        }\n\n        if (dimType === 'time'\n            // spead up when using timestamp\n            && typeof value !== 'number'\n            && value != null\n            && value !== '-'\n        ) {\n            value = +nubmerUtil.parseDate(value);\n        }\n\n        // dimType defaults 'number'.\n        // If dimType is not ordinal and value is null or undefined or NaN or '-',\n        // parse to NaN.\n        return (value == null || value === '')\n            ? NaN : +value; // If string (like '-'), using '+' parse to NaN\n    };\n\n    /**\n     * Create a model proxy to be used in tooltip for edge data, markLine data, markPoint data.\n     * @param {module:echarts/data/List} data\n     * @param {Object} opt\n     * @param {string} [opt.seriesIndex]\n     * @param {Object} [opt.name]\n     * @param {Object} [opt.mainType]\n     * @param {Object} [opt.subType]\n     */\n    modelUtil.createDataFormatModel = function (data, opt) {\n        var model = new Model();\n        zrUtil.mixin(model, modelUtil.dataFormatMixin);\n        model.seriesIndex = opt.seriesIndex;\n        model.name = opt.name || '';\n        model.mainType = opt.mainType;\n        model.subType = opt.subType;\n\n        model.getData = function () {\n            return data;\n        };\n        return model;\n    };\n\n    // PENDING A little ugly\n    modelUtil.dataFormatMixin = {\n        /**\n         * Get params for formatter\n         * @param {number} dataIndex\n         * @param {string} [dataType]\n         * @return {Object}\n         */\n        getDataParams: function (dataIndex, dataType) {\n            var data = this.getData(dataType);\n            var rawValue = this.getRawValue(dataIndex, dataType);\n            var rawDataIndex = data.getRawIndex(dataIndex);\n            var name = data.getName(dataIndex, true);\n            var itemOpt = data.getRawDataItem(dataIndex);\n\n            return {\n                componentType: this.mainType,\n                componentSubType: this.subType,\n                seriesType: this.mainType === 'series' ? this.subType : null,\n                seriesIndex: this.seriesIndex,\n                seriesId: this.id,\n                seriesName: this.name,\n                name: name,\n                dataIndex: rawDataIndex,\n                data: itemOpt,\n                dataType: dataType,\n                value: rawValue,\n                color: data.getItemVisual(dataIndex, 'color'),\n\n                // Param name list for mapping `a`, `b`, `c`, `d`, `e`\n                $vars: ['seriesName', 'name', 'value']\n            };\n        },\n\n        /**\n         * Format label\n         * @param {number} dataIndex\n         * @param {string} [status='normal'] 'normal' or 'emphasis'\n         * @param {string} [dataType]\n         * @param {number} [dimIndex]\n         * @return {string}\n         */\n        getFormattedLabel: function (dataIndex, status, dataType, dimIndex) {\n            status = status || 'normal';\n            var data = this.getData(dataType);\n            var itemModel = data.getItemModel(dataIndex);\n\n            var params = this.getDataParams(dataIndex, dataType);\n            if (dimIndex != null && (params.value instanceof Array)) {\n                params.value = params.value[dimIndex];\n            }\n\n            var formatter = itemModel.get(['label', status, 'formatter']);\n\n            if (typeof formatter === 'function') {\n                params.status = status;\n                return formatter(params);\n            }\n            else if (typeof formatter === 'string') {\n                return formatUtil.formatTpl(formatter, params);\n            }\n        },\n\n        /**\n         * Get raw value in option\n         * @param {number} idx\n         * @param {string} [dataType]\n         * @return {Object}\n         */\n        getRawValue: function (idx, dataType) {\n            var data = this.getData(dataType);\n            var dataItem = data.getRawDataItem(idx);\n            if (dataItem != null) {\n                return (isObject(dataItem) && !(dataItem instanceof Array))\n                    ? dataItem.value : dataItem;\n            }\n        },\n\n        /**\n         * Should be implemented.\n         * @param {number} dataIndex\n         * @param {boolean} [multipleSeries=false]\n         * @param {number} [dataType]\n         * @return {string} tooltip string\n         */\n        formatTooltip: zrUtil.noop\n    };\n\n    /**\n     * Mapping to exists for merge.\n     *\n     * @public\n     * @param {Array.<Object>|Array.<module:echarts/model/Component>} exists\n     * @param {Object|Array.<Object>} newCptOptions\n     * @return {Array.<Object>} Result, like [{exist: ..., option: ...}, {}],\n     *                          index of which is the same as exists.\n     */\n    modelUtil.mappingToExists = function (exists, newCptOptions) {\n        // Mapping by the order by original option (but not order of\n        // new option) in merge mode. Because we should ensure\n        // some specified index (like xAxisIndex) is consistent with\n        // original option, which is easy to understand, espatially in\n        // media query. And in most case, merge option is used to\n        // update partial option but not be expected to change order.\n        newCptOptions = (newCptOptions || []).slice();\n\n        var result = zrUtil.map(exists || [], function (obj, index) {\n            return {exist: obj};\n        });\n\n        // Mapping by id or name if specified.\n        each(newCptOptions, function (cptOption, index) {\n            if (!isObject(cptOption)) {\n                return;\n            }\n\n            // id has highest priority.\n            for (var i = 0; i < result.length; i++) {\n                if (!result[i].option // Consider name: two map to one.\n                    && cptOption.id != null\n                    && result[i].exist.id === cptOption.id + ''\n                ) {\n                    result[i].option = cptOption;\n                    newCptOptions[index] = null;\n                    return;\n                }\n            }\n\n            for (var i = 0; i < result.length; i++) {\n                var exist = result[i].exist;\n                if (!result[i].option // Consider name: two map to one.\n                    // Can not match when both ids exist but different.\n                    && (exist.id == null || cptOption.id == null)\n                    && cptOption.name != null\n                    && !modelUtil.isIdInner(cptOption)\n                    && !modelUtil.isIdInner(exist)\n                    && exist.name === cptOption.name + ''\n                ) {\n                    result[i].option = cptOption;\n                    newCptOptions[index] = null;\n                    return;\n                }\n            }\n        });\n\n        // Otherwise mapping by index.\n        each(newCptOptions, function (cptOption, index) {\n            if (!isObject(cptOption)) {\n                return;\n            }\n\n            var i = 0;\n            for (; i < result.length; i++) {\n                var exist = result[i].exist;\n                if (!result[i].option\n                    // Existing model that already has id should be able to\n                    // mapped to (because after mapping performed model may\n                    // be assigned with a id, whish should not affect next\n                    // mapping), except those has inner id.\n                    && !modelUtil.isIdInner(exist)\n                    // Caution:\n                    // Do not overwrite id. But name can be overwritten,\n                    // because axis use name as 'show label text'.\n                    // 'exist' always has id and name and we dont\n                    // need to check it.\n                    && cptOption.id == null\n                ) {\n                    result[i].option = cptOption;\n                    break;\n                }\n            }\n\n            if (i >= result.length) {\n                result.push({option: cptOption});\n            }\n        });\n\n        return result;\n    };\n\n    /**\n     * Make id and name for mapping result (result of mappingToExists)\n     * into `keyInfo` field.\n     *\n     * @public\n     * @param {Array.<Object>} Result, like [{exist: ..., option: ...}, {}],\n     *                          which order is the same as exists.\n     * @return {Array.<Object>} The input.\n     */\n    modelUtil.makeIdAndName = function (mapResult) {\n        // We use this id to hash component models and view instances\n        // in echarts. id can be specified by user, or auto generated.\n\n        // The id generation rule ensures new view instance are able\n        // to mapped to old instance when setOption are called in\n        // no-merge mode. So we generate model id by name and plus\n        // type in view id.\n\n        // name can be duplicated among components, which is convenient\n        // to specify multi components (like series) by one name.\n\n        // Ensure that each id is distinct.\n        var idMap = {};\n\n        each(mapResult, function (item, index) {\n            var existCpt = item.exist;\n            existCpt && (idMap[existCpt.id] = item);\n        });\n\n        each(mapResult, function (item, index) {\n            var opt = item.option;\n\n            zrUtil.assert(\n                !opt || opt.id == null || !idMap[opt.id] || idMap[opt.id] === item,\n                'id duplicates: ' + (opt && opt.id)\n            );\n\n            opt && opt.id != null && (idMap[opt.id] = item);\n            !item.keyInfo && (item.keyInfo = {});\n        });\n\n        // Make name and id.\n        each(mapResult, function (item, index) {\n            var existCpt = item.exist;\n            var opt = item.option;\n            var keyInfo = item.keyInfo;\n\n            if (!isObject(opt)) {\n                return;\n            }\n\n            // name can be overwitten. Consider case: axis.name = '20km'.\n            // But id generated by name will not be changed, which affect\n            // only in that case: setOption with 'not merge mode' and view\n            // instance will be recreated, which can be accepted.\n            keyInfo.name = opt.name != null\n                ? opt.name + ''\n                : existCpt\n                ? existCpt.name\n                : '\\0-'; // name may be displayed on screen, so use '-'.\n\n            if (existCpt) {\n                keyInfo.id = existCpt.id;\n            }\n            else if (opt.id != null) {\n                keyInfo.id = opt.id + '';\n            }\n            else {\n                // Consider this situatoin:\n                //  optionA: [{name: 'a'}, {name: 'a'}, {..}]\n                //  optionB [{..}, {name: 'a'}, {name: 'a'}]\n                // Series with the same name between optionA and optionB\n                // should be mapped.\n                var idNum = 0;\n                do {\n                    keyInfo.id = '\\0' + keyInfo.name + '\\0' + idNum++;\n                }\n                while (idMap[keyInfo.id]);\n            }\n\n            idMap[keyInfo.id] = item;\n        });\n    };\n\n    /**\n     * @public\n     * @param {Object} cptOption\n     * @return {boolean}\n     */\n    modelUtil.isIdInner = function (cptOption) {\n        return isObject(cptOption)\n            && cptOption.id\n            && (cptOption.id + '').indexOf('\\0_ec_\\0') === 0;\n    };\n\n    /**\n     * A helper for removing duplicate items between batchA and batchB,\n     * and in themselves, and categorize by series.\n     *\n     * @param {Array.<Object>} batchA Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]\n     * @param {Array.<Object>} batchB Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]\n     * @return {Array.<Array.<Object>, Array.<Object>>} result: [resultBatchA, resultBatchB]\n     */\n    modelUtil.compressBatches = function (batchA, batchB) {\n        var mapA = {};\n        var mapB = {};\n\n        makeMap(batchA || [], mapA);\n        makeMap(batchB || [], mapB, mapA);\n\n        return [mapToArray(mapA), mapToArray(mapB)];\n\n        function makeMap(sourceBatch, map, otherMap) {\n            for (var i = 0, len = sourceBatch.length; i < len; i++) {\n                var seriesId = sourceBatch[i].seriesId;\n                var dataIndices = modelUtil.normalizeToArray(sourceBatch[i].dataIndex);\n                var otherDataIndices = otherMap && otherMap[seriesId];\n\n                for (var j = 0, lenj = dataIndices.length; j < lenj; j++) {\n                    var dataIndex = dataIndices[j];\n\n                    if (otherDataIndices && otherDataIndices[dataIndex]) {\n                        otherDataIndices[dataIndex] = null;\n                    }\n                    else {\n                        (map[seriesId] || (map[seriesId] = {}))[dataIndex] = 1;\n                    }\n                }\n            }\n        }\n\n        function mapToArray(map, isData) {\n            var result = [];\n            for (var i in map) {\n                if (map.hasOwnProperty(i) && map[i] != null) {\n                    if (isData) {\n                        result.push(+i);\n                    }\n                    else {\n                        var dataIndices = mapToArray(map[i], true);\n                        dataIndices.length && result.push({seriesId: i, dataIndex: dataIndices});\n                    }\n                }\n            }\n            return result;\n        }\n    };\n\n    /**\n     * @param {module:echarts/data/List} data\n     * @param {Object} payload Contains dataIndex (means rawIndex) / dataIndexInside / name\n     *                         each of which can be Array or primary type.\n     * @return {number|Array.<number>} dataIndex If not found, return undefined/null.\n     */\n    modelUtil.queryDataIndex = function (data, payload) {\n        if (payload.dataIndexInside != null) {\n            return payload.dataIndexInside;\n        }\n        else if (payload.dataIndex != null) {\n            return zrUtil.isArray(payload.dataIndex)\n                ? zrUtil.map(payload.dataIndex, function (value) {\n                    return data.indexOfRawIndex(value);\n                })\n                : data.indexOfRawIndex(payload.dataIndex);\n        }\n        else if (payload.name != null) {\n            return zrUtil.isArray(payload.name)\n                ? zrUtil.map(payload.name, function (value) {\n                    return data.indexOfName(value);\n                })\n                : data.indexOfName(payload.name);\n        }\n    };\n\n    /**\n     * Enable property storage to any host object.\n     * Notice: Serialization is not supported.\n     *\n     * For example:\n     * var get = modelUitl.makeGetter();\n     *\n     * function some(hostObj) {\n     *      get(hostObj)._someProperty = 1212;\n     *      ...\n     * }\n     *\n     * @return {Function}\n     */\n    modelUtil.makeGetter = (function () {\n        var index = 0;\n        return function () {\n            var key = '\\0__ec_prop_getter_' + index++;\n            return function (hostObj) {\n                return hostObj[key] || (hostObj[key] = {});\n            };\n        };\n    })();\n\n    /**\n     * @param {module:echarts/model/Global} ecModel\n     * @param {string|Object} finder\n     *        If string, e.g., 'geo', means {geoIndex: 0}.\n     *        If Object, could contain some of these properties below:\n     *        {\n     *            seriesIndex, seriesId, seriesName,\n     *            geoIndex, geoId, geoName,\n     *            bmapIndex, bmapId, bmapName,\n     *            xAxisIndex, xAxisId, xAxisName,\n     *            yAxisIndex, yAxisId, yAxisName,\n     *            gridIndex, gridId, gridName,\n     *            ... (can be extended)\n     *        }\n     *        Each properties can be number|string|Array.<number>|Array.<string>\n     *        For example, a finder could be\n     *        {\n     *            seriesIndex: 3,\n     *            geoId: ['aa', 'cc'],\n     *            gridName: ['xx', 'rr']\n     *        }\n     *        xxxIndex can be set as 'all' (means all xxx) or 'none' (means not specify)\n     *        If nothing or null/undefined specified, return nothing.\n     * @param {Object} [opt]\n     * @param {string} [opt.defaultMainType]\n     * @param {Array.<string>} [opt.includeMainTypes]\n     * @return {Object} result like:\n     *        {\n     *            seriesModels: [seriesModel1, seriesModel2],\n     *            seriesModel: seriesModel1, // The first model\n     *            geoModels: [geoModel1, geoModel2],\n     *            geoModel: geoModel1, // The first model\n     *            ...\n     *        }\n     */\n    modelUtil.parseFinder = function (ecModel, finder, opt) {\n        if (zrUtil.isString(finder)) {\n            var obj = {};\n            obj[finder + 'Index'] = 0;\n            finder = obj;\n        }\n\n        var defaultMainType = opt && opt.defaultMainType;\n        if (defaultMainType\n            && !has(finder, defaultMainType + 'Index')\n            && !has(finder, defaultMainType + 'Id')\n            && !has(finder, defaultMainType + 'Name')\n        ) {\n            finder[defaultMainType + 'Index'] = 0;\n        }\n\n        var result = {};\n\n        each(finder, function (value, key) {\n            var value = finder[key];\n\n            // Exclude 'dataIndex' and other illgal keys.\n            if (key === 'dataIndex' || key === 'dataIndexInside') {\n                result[key] = value;\n                return;\n            }\n\n            var parsedKey = key.match(/^(\\w+)(Index|Id|Name)$/) || [];\n            var mainType = parsedKey[1];\n            var queryType = (parsedKey[2] || '').toLowerCase();\n\n            if (!mainType\n                || !queryType\n                || value == null\n                || (queryType === 'index' && value === 'none')\n                || (opt && opt.includeMainTypes && zrUtil.indexOf(opt.includeMainTypes, mainType) < 0)\n            ) {\n                return;\n            }\n\n            var queryParam = {mainType: mainType};\n            if (queryType !== 'index' || value !== 'all') {\n                queryParam[queryType] = value;\n            }\n\n            var models = ecModel.queryComponents(queryParam);\n            result[mainType + 'Models'] = models;\n            result[mainType + 'Model'] = models[0];\n        });\n\n        return result;\n    };\n\n    function has(obj, prop) {\n        return obj && obj.hasOwnProperty(prop);\n    }\n\n    module.exports = modelUtil;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2xpYi91dGlsL21vZGVsLmpzP2U0MGIiXSwic291cmNlc0NvbnRlbnQiOlsiXG5cbiAgICB2YXIgZm9ybWF0VXRpbCA9IHJlcXVpcmUoJy4vZm9ybWF0Jyk7XG4gICAgdmFyIG51Ym1lclV0aWwgPSByZXF1aXJlKCcuL251bWJlcicpO1xuICAgIHZhciBNb2RlbCA9IHJlcXVpcmUoJy4uL21vZGVsL01vZGVsJyk7XG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuICAgIHZhciBlYWNoID0genJVdGlsLmVhY2g7XG4gICAgdmFyIGlzT2JqZWN0ID0genJVdGlsLmlzT2JqZWN0O1xuXG4gICAgdmFyIG1vZGVsVXRpbCA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogSWYgdmFsdWUgaXMgbm90IGFycmF5LCB0aGVuIHRyYW5zbGF0ZSBpdCB0byBhcnJheS5cbiAgICAgKiBAcGFyYW0gIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge0FycmF5fSBbdmFsdWVdIG9yIHZhbHVlXG4gICAgICovXG4gICAgbW9kZWxVdGlsLm5vcm1hbGl6ZVRvQXJyYXkgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgQXJyYXlcbiAgICAgICAgICAgID8gdmFsdWVcbiAgICAgICAgICAgIDogdmFsdWUgPT0gbnVsbFxuICAgICAgICAgICAgPyBbXVxuICAgICAgICAgICAgOiBbdmFsdWVdO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTeW5jIGRlZmF1bHQgb3B0aW9uIGJldHdlZW4gbm9ybWFsIGFuZCBlbXBoYXNpcyBsaWtlIGBwb3NpdGlvbmAgYW5kIGBzaG93YFxuICAgICAqIEluIGNhc2Ugc29tZSBvbmUgd2lsbCB3cml0ZSBjb2RlIGxpa2VcbiAgICAgKiAgICAgbGFiZWw6IHtcbiAgICAgKiAgICAgICAgIG5vcm1hbDoge1xuICAgICAqICAgICAgICAgICAgIHNob3c6IGZhbHNlLFxuICAgICAqICAgICAgICAgICAgIHBvc2l0aW9uOiAnb3V0c2lkZScsXG4gICAgICogICAgICAgICAgICAgdGV4dFN0eWxlOiB7XG4gICAgICogICAgICAgICAgICAgICAgIGZvbnRTaXplOiAxOFxuICAgICAqICAgICAgICAgICAgIH1cbiAgICAgKiAgICAgICAgIH0sXG4gICAgICogICAgICAgICBlbXBoYXNpczoge1xuICAgICAqICAgICAgICAgICAgIHNob3c6IHRydWVcbiAgICAgKiAgICAgICAgIH1cbiAgICAgKiAgICAgfVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBzdWJPcHRzXG4gICAgICovXG4gICAgIG1vZGVsVXRpbC5kZWZhdWx0RW1waGFzaXMgPSBmdW5jdGlvbiAob3B0LCBzdWJPcHRzKSB7XG4gICAgICAgIGlmIChvcHQpIHtcbiAgICAgICAgICAgIHZhciBlbXBoYXNpc09wdCA9IG9wdC5lbXBoYXNpcyA9IG9wdC5lbXBoYXNpcyB8fCB7fTtcbiAgICAgICAgICAgIHZhciBub3JtYWxPcHQgPSBvcHQubm9ybWFsID0gb3B0Lm5vcm1hbCB8fCB7fTtcblxuICAgICAgICAgICAgLy8gRGVmYXVsdCBlbXBoYXNpcyBvcHRpb24gZnJvbSBub3JtYWxcbiAgICAgICAgICAgIGVhY2goc3ViT3B0cywgZnVuY3Rpb24gKHN1Yk9wdE5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsID0genJVdGlsLnJldHJpZXZlKGVtcGhhc2lzT3B0W3N1Yk9wdE5hbWVdLCBub3JtYWxPcHRbc3ViT3B0TmFtZV0pO1xuICAgICAgICAgICAgICAgIGlmICh2YWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBlbXBoYXNpc09wdFtzdWJPcHROYW1lXSA9IHZhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBtb2RlbFV0aWwuTEFCRUxfT1BUSU9OUyA9IFsncG9zaXRpb24nLCAnb2Zmc2V0JywgJ3Nob3cnLCAndGV4dFN0eWxlJywgJ2Rpc3RhbmNlJywgJ2Zvcm1hdHRlciddO1xuXG4gICAgLyoqXG4gICAgICogZGF0YSBjb3VsZCBiZSBbMTIsIDIzMjMsIHt2YWx1ZTogMjIzfSwgWzEyMjEsIDIzXSwge3ZhbHVlOiBbMiwgMjNdfV1cbiAgICAgKiBUaGlzIGhlbHBlciBtZXRob2QgcmV0aWV2ZXMgdmFsdWUgZnJvbSBkYXRhLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcnxEYXRlfEFycmF5fE9iamVjdH0gZGF0YUl0ZW1cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ8c3RyaW5nfERhdGV8QXJyYXkuPG51bWJlcnxzdHJpbmd8RGF0ZT59XG4gICAgICovXG4gICAgbW9kZWxVdGlsLmdldERhdGFJdGVtVmFsdWUgPSBmdW5jdGlvbiAoZGF0YUl0ZW0pIHtcbiAgICAgICAgLy8gUGVyZm9ybWFuY2Ugc2Vuc2l0aXZlLlxuICAgICAgICByZXR1cm4gZGF0YUl0ZW0gJiYgKGRhdGFJdGVtLnZhbHVlID09IG51bGwgPyBkYXRhSXRlbSA6IGRhdGFJdGVtLnZhbHVlKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogZGF0YSBjb3VsZCBiZSBbMTIsIDIzMjMsIHt2YWx1ZTogMjIzfSwgWzEyMjEsIDIzXSwge3ZhbHVlOiBbMiwgMjNdfV1cbiAgICAgKiBUaGlzIGhlbHBlciBtZXRob2QgZGV0ZXJtaW5lIGlmIGRhdGFJdGVtIGhhcyBleHRyYSBvcHRpb24gYmVzaWRlcyB2YWx1ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcnxEYXRlfEFycmF5fE9iamVjdH0gZGF0YUl0ZW1cbiAgICAgKi9cbiAgICBtb2RlbFV0aWwuaXNEYXRhSXRlbU9wdGlvbiA9IGZ1bmN0aW9uIChkYXRhSXRlbSkge1xuICAgICAgICByZXR1cm4gaXNPYmplY3QoZGF0YUl0ZW0pXG4gICAgICAgICAgICAmJiAhKGRhdGFJdGVtIGluc3RhbmNlb2YgQXJyYXkpO1xuICAgICAgICAgICAgLy8gLy8gbWFya0xpbmUgZGF0YSBjYW4gYmUgYXJyYXlcbiAgICAgICAgICAgIC8vICYmICEoZGF0YUl0ZW1bMF0gJiYgaXNPYmplY3QoZGF0YUl0ZW1bMF0pICYmICEoZGF0YUl0ZW1bMF0gaW5zdGFuY2VvZiBBcnJheSkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGhlbHBlciBtZXRob2QgY29udmVydCB2YWx1ZSBpbiBkYXRhLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcnxEYXRlfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fHN0cmluZ30gW2RpbUluZm9dIElmIHN0cmluZyAobGlrZSAneCcpLCBkaW1UeXBlIGRlZmF1bHRzICdudW1iZXInLlxuICAgICAqL1xuICAgIG1vZGVsVXRpbC5jb252ZXJEYXRhVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUsIGRpbUluZm8pIHtcbiAgICAgICAgLy8gUGVyZm9ybWFuY2Ugc2Vuc2l0aXZlLlxuICAgICAgICB2YXIgZGltVHlwZSA9IGRpbUluZm8gJiYgZGltSW5mby50eXBlO1xuICAgICAgICBpZiAoZGltVHlwZSA9PT0gJ29yZGluYWwnKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGltVHlwZSA9PT0gJ3RpbWUnXG4gICAgICAgICAgICAvLyBzcGVhZCB1cCB3aGVuIHVzaW5nIHRpbWVzdGFtcFxuICAgICAgICAgICAgJiYgdHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJ1xuICAgICAgICAgICAgJiYgdmFsdWUgIT0gbnVsbFxuICAgICAgICAgICAgJiYgdmFsdWUgIT09ICctJ1xuICAgICAgICApIHtcbiAgICAgICAgICAgIHZhbHVlID0gK251Ym1lclV0aWwucGFyc2VEYXRlKHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGRpbVR5cGUgZGVmYXVsdHMgJ251bWJlcicuXG4gICAgICAgIC8vIElmIGRpbVR5cGUgaXMgbm90IG9yZGluYWwgYW5kIHZhbHVlIGlzIG51bGwgb3IgdW5kZWZpbmVkIG9yIE5hTiBvciAnLScsXG4gICAgICAgIC8vIHBhcnNlIHRvIE5hTi5cbiAgICAgICAgcmV0dXJuICh2YWx1ZSA9PSBudWxsIHx8IHZhbHVlID09PSAnJylcbiAgICAgICAgICAgID8gTmFOIDogK3ZhbHVlOyAvLyBJZiBzdHJpbmcgKGxpa2UgJy0nKSwgdXNpbmcgJysnIHBhcnNlIHRvIE5hTlxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBtb2RlbCBwcm94eSB0byBiZSB1c2VkIGluIHRvb2x0aXAgZm9yIGVkZ2UgZGF0YSwgbWFya0xpbmUgZGF0YSwgbWFya1BvaW50IGRhdGEuXG4gICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9kYXRhL0xpc3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHQuc2VyaWVzSW5kZXhdXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHQubmFtZV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdC5tYWluVHlwZV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdC5zdWJUeXBlXVxuICAgICAqL1xuICAgIG1vZGVsVXRpbC5jcmVhdGVEYXRhRm9ybWF0TW9kZWwgPSBmdW5jdGlvbiAoZGF0YSwgb3B0KSB7XG4gICAgICAgIHZhciBtb2RlbCA9IG5ldyBNb2RlbCgpO1xuICAgICAgICB6clV0aWwubWl4aW4obW9kZWwsIG1vZGVsVXRpbC5kYXRhRm9ybWF0TWl4aW4pO1xuICAgICAgICBtb2RlbC5zZXJpZXNJbmRleCA9IG9wdC5zZXJpZXNJbmRleDtcbiAgICAgICAgbW9kZWwubmFtZSA9IG9wdC5uYW1lIHx8ICcnO1xuICAgICAgICBtb2RlbC5tYWluVHlwZSA9IG9wdC5tYWluVHlwZTtcbiAgICAgICAgbW9kZWwuc3ViVHlwZSA9IG9wdC5zdWJUeXBlO1xuXG4gICAgICAgIG1vZGVsLmdldERhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG1vZGVsO1xuICAgIH07XG5cbiAgICAvLyBQRU5ESU5HIEEgbGl0dGxlIHVnbHlcbiAgICBtb2RlbFV0aWwuZGF0YUZvcm1hdE1peGluID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHBhcmFtcyBmb3IgZm9ybWF0dGVyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkYXRhSW5kZXhcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtkYXRhVHlwZV1cbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0RGF0YVBhcmFtczogZnVuY3Rpb24gKGRhdGFJbmRleCwgZGF0YVR5cGUpIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5nZXREYXRhKGRhdGFUeXBlKTtcbiAgICAgICAgICAgIHZhciByYXdWYWx1ZSA9IHRoaXMuZ2V0UmF3VmFsdWUoZGF0YUluZGV4LCBkYXRhVHlwZSk7XG4gICAgICAgICAgICB2YXIgcmF3RGF0YUluZGV4ID0gZGF0YS5nZXRSYXdJbmRleChkYXRhSW5kZXgpO1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBkYXRhLmdldE5hbWUoZGF0YUluZGV4LCB0cnVlKTtcbiAgICAgICAgICAgIHZhciBpdGVtT3B0ID0gZGF0YS5nZXRSYXdEYXRhSXRlbShkYXRhSW5kZXgpO1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudFR5cGU6IHRoaXMubWFpblR5cGUsXG4gICAgICAgICAgICAgICAgY29tcG9uZW50U3ViVHlwZTogdGhpcy5zdWJUeXBlLFxuICAgICAgICAgICAgICAgIHNlcmllc1R5cGU6IHRoaXMubWFpblR5cGUgPT09ICdzZXJpZXMnID8gdGhpcy5zdWJUeXBlIDogbnVsbCxcbiAgICAgICAgICAgICAgICBzZXJpZXNJbmRleDogdGhpcy5zZXJpZXNJbmRleCxcbiAgICAgICAgICAgICAgICBzZXJpZXNJZDogdGhpcy5pZCxcbiAgICAgICAgICAgICAgICBzZXJpZXNOYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICBkYXRhSW5kZXg6IHJhd0RhdGFJbmRleCxcbiAgICAgICAgICAgICAgICBkYXRhOiBpdGVtT3B0LFxuICAgICAgICAgICAgICAgIGRhdGFUeXBlOiBkYXRhVHlwZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogcmF3VmFsdWUsXG4gICAgICAgICAgICAgICAgY29sb3I6IGRhdGEuZ2V0SXRlbVZpc3VhbChkYXRhSW5kZXgsICdjb2xvcicpLFxuXG4gICAgICAgICAgICAgICAgLy8gUGFyYW0gbmFtZSBsaXN0IGZvciBtYXBwaW5nIGBhYCwgYGJgLCBgY2AsIGBkYCwgYGVgXG4gICAgICAgICAgICAgICAgJHZhcnM6IFsnc2VyaWVzTmFtZScsICduYW1lJywgJ3ZhbHVlJ11cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZvcm1hdCBsYWJlbFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gZGF0YUluZGV4XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RhdHVzPSdub3JtYWwnXSAnbm9ybWFsJyBvciAnZW1waGFzaXMnXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbZGF0YVR5cGVdXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZGltSW5kZXhdXG4gICAgICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIGdldEZvcm1hdHRlZExhYmVsOiBmdW5jdGlvbiAoZGF0YUluZGV4LCBzdGF0dXMsIGRhdGFUeXBlLCBkaW1JbmRleCkge1xuICAgICAgICAgICAgc3RhdHVzID0gc3RhdHVzIHx8ICdub3JtYWwnO1xuICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmdldERhdGEoZGF0YVR5cGUpO1xuICAgICAgICAgICAgdmFyIGl0ZW1Nb2RlbCA9IGRhdGEuZ2V0SXRlbU1vZGVsKGRhdGFJbmRleCk7XG5cbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSB0aGlzLmdldERhdGFQYXJhbXMoZGF0YUluZGV4LCBkYXRhVHlwZSk7XG4gICAgICAgICAgICBpZiAoZGltSW5kZXggIT0gbnVsbCAmJiAocGFyYW1zLnZhbHVlIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zLnZhbHVlID0gcGFyYW1zLnZhbHVlW2RpbUluZGV4XTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGZvcm1hdHRlciA9IGl0ZW1Nb2RlbC5nZXQoWydsYWJlbCcsIHN0YXR1cywgJ2Zvcm1hdHRlciddKTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBmb3JtYXR0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMuc3RhdHVzID0gc3RhdHVzO1xuICAgICAgICAgICAgICAgIHJldHVybiBmb3JtYXR0ZXIocGFyYW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBmb3JtYXR0ZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvcm1hdFV0aWwuZm9ybWF0VHBsKGZvcm1hdHRlciwgcGFyYW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHJhdyB2YWx1ZSBpbiBvcHRpb25cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGlkeFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2RhdGFUeXBlXVxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRSYXdWYWx1ZTogZnVuY3Rpb24gKGlkeCwgZGF0YVR5cGUpIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5nZXREYXRhKGRhdGFUeXBlKTtcbiAgICAgICAgICAgIHZhciBkYXRhSXRlbSA9IGRhdGEuZ2V0UmF3RGF0YUl0ZW0oaWR4KTtcbiAgICAgICAgICAgIGlmIChkYXRhSXRlbSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChpc09iamVjdChkYXRhSXRlbSkgJiYgIShkYXRhSXRlbSBpbnN0YW5jZW9mIEFycmF5KSlcbiAgICAgICAgICAgICAgICAgICAgPyBkYXRhSXRlbS52YWx1ZSA6IGRhdGFJdGVtO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaG91bGQgYmUgaW1wbGVtZW50ZWQuXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkYXRhSW5kZXhcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbbXVsdGlwbGVTZXJpZXM9ZmFsc2VdXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZGF0YVR5cGVdXG4gICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gdG9vbHRpcCBzdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIGZvcm1hdFRvb2x0aXA6IHpyVXRpbC5ub29wXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIE1hcHBpbmcgdG8gZXhpc3RzIGZvciBtZXJnZS5cbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxPYmplY3Q+fEFycmF5Ljxtb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Db21wb25lbnQ+fSBleGlzdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdHxBcnJheS48T2JqZWN0Pn0gbmV3Q3B0T3B0aW9uc1xuICAgICAqIEByZXR1cm4ge0FycmF5LjxPYmplY3Q+fSBSZXN1bHQsIGxpa2UgW3tleGlzdDogLi4uLCBvcHRpb246IC4uLn0sIHt9XSxcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggb2Ygd2hpY2ggaXMgdGhlIHNhbWUgYXMgZXhpc3RzLlxuICAgICAqL1xuICAgIG1vZGVsVXRpbC5tYXBwaW5nVG9FeGlzdHMgPSBmdW5jdGlvbiAoZXhpc3RzLCBuZXdDcHRPcHRpb25zKSB7XG4gICAgICAgIC8vIE1hcHBpbmcgYnkgdGhlIG9yZGVyIGJ5IG9yaWdpbmFsIG9wdGlvbiAoYnV0IG5vdCBvcmRlciBvZlxuICAgICAgICAvLyBuZXcgb3B0aW9uKSBpbiBtZXJnZSBtb2RlLiBCZWNhdXNlIHdlIHNob3VsZCBlbnN1cmVcbiAgICAgICAgLy8gc29tZSBzcGVjaWZpZWQgaW5kZXggKGxpa2UgeEF4aXNJbmRleCkgaXMgY29uc2lzdGVudCB3aXRoXG4gICAgICAgIC8vIG9yaWdpbmFsIG9wdGlvbiwgd2hpY2ggaXMgZWFzeSB0byB1bmRlcnN0YW5kLCBlc3BhdGlhbGx5IGluXG4gICAgICAgIC8vIG1lZGlhIHF1ZXJ5LiBBbmQgaW4gbW9zdCBjYXNlLCBtZXJnZSBvcHRpb24gaXMgdXNlZCB0b1xuICAgICAgICAvLyB1cGRhdGUgcGFydGlhbCBvcHRpb24gYnV0IG5vdCBiZSBleHBlY3RlZCB0byBjaGFuZ2Ugb3JkZXIuXG4gICAgICAgIG5ld0NwdE9wdGlvbnMgPSAobmV3Q3B0T3B0aW9ucyB8fCBbXSkuc2xpY2UoKTtcblxuICAgICAgICB2YXIgcmVzdWx0ID0genJVdGlsLm1hcChleGlzdHMgfHwgW10sIGZ1bmN0aW9uIChvYmosIGluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4ge2V4aXN0OiBvYmp9O1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBNYXBwaW5nIGJ5IGlkIG9yIG5hbWUgaWYgc3BlY2lmaWVkLlxuICAgICAgICBlYWNoKG5ld0NwdE9wdGlvbnMsIGZ1bmN0aW9uIChjcHRPcHRpb24sIGluZGV4KSB7XG4gICAgICAgICAgICBpZiAoIWlzT2JqZWN0KGNwdE9wdGlvbikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlkIGhhcyBoaWdoZXN0IHByaW9yaXR5LlxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdFtpXS5vcHRpb24gLy8gQ29uc2lkZXIgbmFtZTogdHdvIG1hcCB0byBvbmUuXG4gICAgICAgICAgICAgICAgICAgICYmIGNwdE9wdGlvbi5pZCAhPSBudWxsXG4gICAgICAgICAgICAgICAgICAgICYmIHJlc3VsdFtpXS5leGlzdC5pZCA9PT0gY3B0T3B0aW9uLmlkICsgJydcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2ldLm9wdGlvbiA9IGNwdE9wdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgbmV3Q3B0T3B0aW9uc1tpbmRleF0gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBleGlzdCA9IHJlc3VsdFtpXS5leGlzdDtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdFtpXS5vcHRpb24gLy8gQ29uc2lkZXIgbmFtZTogdHdvIG1hcCB0byBvbmUuXG4gICAgICAgICAgICAgICAgICAgIC8vIENhbiBub3QgbWF0Y2ggd2hlbiBib3RoIGlkcyBleGlzdCBidXQgZGlmZmVyZW50LlxuICAgICAgICAgICAgICAgICAgICAmJiAoZXhpc3QuaWQgPT0gbnVsbCB8fCBjcHRPcHRpb24uaWQgPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgJiYgY3B0T3B0aW9uLm5hbWUgIT0gbnVsbFxuICAgICAgICAgICAgICAgICAgICAmJiAhbW9kZWxVdGlsLmlzSWRJbm5lcihjcHRPcHRpb24pXG4gICAgICAgICAgICAgICAgICAgICYmICFtb2RlbFV0aWwuaXNJZElubmVyKGV4aXN0KVxuICAgICAgICAgICAgICAgICAgICAmJiBleGlzdC5uYW1lID09PSBjcHRPcHRpb24ubmFtZSArICcnXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpXS5vcHRpb24gPSBjcHRPcHRpb247XG4gICAgICAgICAgICAgICAgICAgIG5ld0NwdE9wdGlvbnNbaW5kZXhdID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gT3RoZXJ3aXNlIG1hcHBpbmcgYnkgaW5kZXguXG4gICAgICAgIGVhY2gobmV3Q3B0T3B0aW9ucywgZnVuY3Rpb24gKGNwdE9wdGlvbiwgaW5kZXgpIHtcbiAgICAgICAgICAgIGlmICghaXNPYmplY3QoY3B0T3B0aW9uKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICAgICAgZm9yICg7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZXhpc3QgPSByZXN1bHRbaV0uZXhpc3Q7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXN1bHRbaV0ub3B0aW9uXG4gICAgICAgICAgICAgICAgICAgIC8vIEV4aXN0aW5nIG1vZGVsIHRoYXQgYWxyZWFkeSBoYXMgaWQgc2hvdWxkIGJlIGFibGUgdG9cbiAgICAgICAgICAgICAgICAgICAgLy8gbWFwcGVkIHRvIChiZWNhdXNlIGFmdGVyIG1hcHBpbmcgcGVyZm9ybWVkIG1vZGVsIG1heVxuICAgICAgICAgICAgICAgICAgICAvLyBiZSBhc3NpZ25lZCB3aXRoIGEgaWQsIHdoaXNoIHNob3VsZCBub3QgYWZmZWN0IG5leHRcbiAgICAgICAgICAgICAgICAgICAgLy8gbWFwcGluZyksIGV4Y2VwdCB0aG9zZSBoYXMgaW5uZXIgaWQuXG4gICAgICAgICAgICAgICAgICAgICYmICFtb2RlbFV0aWwuaXNJZElubmVyKGV4aXN0KVxuICAgICAgICAgICAgICAgICAgICAvLyBDYXV0aW9uOlxuICAgICAgICAgICAgICAgICAgICAvLyBEbyBub3Qgb3ZlcndyaXRlIGlkLiBCdXQgbmFtZSBjYW4gYmUgb3ZlcndyaXR0ZW4sXG4gICAgICAgICAgICAgICAgICAgIC8vIGJlY2F1c2UgYXhpcyB1c2UgbmFtZSBhcyAnc2hvdyBsYWJlbCB0ZXh0Jy5cbiAgICAgICAgICAgICAgICAgICAgLy8gJ2V4aXN0JyBhbHdheXMgaGFzIGlkIGFuZCBuYW1lIGFuZCB3ZSBkb250XG4gICAgICAgICAgICAgICAgICAgIC8vIG5lZWQgdG8gY2hlY2sgaXQuXG4gICAgICAgICAgICAgICAgICAgICYmIGNwdE9wdGlvbi5pZCA9PSBudWxsXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpXS5vcHRpb24gPSBjcHRPcHRpb247XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGkgPj0gcmVzdWx0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtvcHRpb246IGNwdE9wdGlvbn0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGlkIGFuZCBuYW1lIGZvciBtYXBwaW5nIHJlc3VsdCAocmVzdWx0IG9mIG1hcHBpbmdUb0V4aXN0cylcbiAgICAgKiBpbnRvIGBrZXlJbmZvYCBmaWVsZC5cbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxPYmplY3Q+fSBSZXN1bHQsIGxpa2UgW3tleGlzdDogLi4uLCBvcHRpb246IC4uLn0sIHt9XSxcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpY2ggb3JkZXIgaXMgdGhlIHNhbWUgYXMgZXhpc3RzLlxuICAgICAqIEByZXR1cm4ge0FycmF5LjxPYmplY3Q+fSBUaGUgaW5wdXQuXG4gICAgICovXG4gICAgbW9kZWxVdGlsLm1ha2VJZEFuZE5hbWUgPSBmdW5jdGlvbiAobWFwUmVzdWx0KSB7XG4gICAgICAgIC8vIFdlIHVzZSB0aGlzIGlkIHRvIGhhc2ggY29tcG9uZW50IG1vZGVscyBhbmQgdmlldyBpbnN0YW5jZXNcbiAgICAgICAgLy8gaW4gZWNoYXJ0cy4gaWQgY2FuIGJlIHNwZWNpZmllZCBieSB1c2VyLCBvciBhdXRvIGdlbmVyYXRlZC5cblxuICAgICAgICAvLyBUaGUgaWQgZ2VuZXJhdGlvbiBydWxlIGVuc3VyZXMgbmV3IHZpZXcgaW5zdGFuY2UgYXJlIGFibGVcbiAgICAgICAgLy8gdG8gbWFwcGVkIHRvIG9sZCBpbnN0YW5jZSB3aGVuIHNldE9wdGlvbiBhcmUgY2FsbGVkIGluXG4gICAgICAgIC8vIG5vLW1lcmdlIG1vZGUuIFNvIHdlIGdlbmVyYXRlIG1vZGVsIGlkIGJ5IG5hbWUgYW5kIHBsdXNcbiAgICAgICAgLy8gdHlwZSBpbiB2aWV3IGlkLlxuXG4gICAgICAgIC8vIG5hbWUgY2FuIGJlIGR1cGxpY2F0ZWQgYW1vbmcgY29tcG9uZW50cywgd2hpY2ggaXMgY29udmVuaWVudFxuICAgICAgICAvLyB0byBzcGVjaWZ5IG11bHRpIGNvbXBvbmVudHMgKGxpa2Ugc2VyaWVzKSBieSBvbmUgbmFtZS5cblxuICAgICAgICAvLyBFbnN1cmUgdGhhdCBlYWNoIGlkIGlzIGRpc3RpbmN0LlxuICAgICAgICB2YXIgaWRNYXAgPSB7fTtcblxuICAgICAgICBlYWNoKG1hcFJlc3VsdCwgZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgZXhpc3RDcHQgPSBpdGVtLmV4aXN0O1xuICAgICAgICAgICAgZXhpc3RDcHQgJiYgKGlkTWFwW2V4aXN0Q3B0LmlkXSA9IGl0ZW0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBlYWNoKG1hcFJlc3VsdCwgZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgb3B0ID0gaXRlbS5vcHRpb247XG5cbiAgICAgICAgICAgIHpyVXRpbC5hc3NlcnQoXG4gICAgICAgICAgICAgICAgIW9wdCB8fCBvcHQuaWQgPT0gbnVsbCB8fCAhaWRNYXBbb3B0LmlkXSB8fCBpZE1hcFtvcHQuaWRdID09PSBpdGVtLFxuICAgICAgICAgICAgICAgICdpZCBkdXBsaWNhdGVzOiAnICsgKG9wdCAmJiBvcHQuaWQpXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBvcHQgJiYgb3B0LmlkICE9IG51bGwgJiYgKGlkTWFwW29wdC5pZF0gPSBpdGVtKTtcbiAgICAgICAgICAgICFpdGVtLmtleUluZm8gJiYgKGl0ZW0ua2V5SW5mbyA9IHt9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gTWFrZSBuYW1lIGFuZCBpZC5cbiAgICAgICAgZWFjaChtYXBSZXN1bHQsIGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgICAgICAgICAgdmFyIGV4aXN0Q3B0ID0gaXRlbS5leGlzdDtcbiAgICAgICAgICAgIHZhciBvcHQgPSBpdGVtLm9wdGlvbjtcbiAgICAgICAgICAgIHZhciBrZXlJbmZvID0gaXRlbS5rZXlJbmZvO1xuXG4gICAgICAgICAgICBpZiAoIWlzT2JqZWN0KG9wdCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIG5hbWUgY2FuIGJlIG92ZXJ3aXR0ZW4uIENvbnNpZGVyIGNhc2U6IGF4aXMubmFtZSA9ICcyMGttJy5cbiAgICAgICAgICAgIC8vIEJ1dCBpZCBnZW5lcmF0ZWQgYnkgbmFtZSB3aWxsIG5vdCBiZSBjaGFuZ2VkLCB3aGljaCBhZmZlY3RcbiAgICAgICAgICAgIC8vIG9ubHkgaW4gdGhhdCBjYXNlOiBzZXRPcHRpb24gd2l0aCAnbm90IG1lcmdlIG1vZGUnIGFuZCB2aWV3XG4gICAgICAgICAgICAvLyBpbnN0YW5jZSB3aWxsIGJlIHJlY3JlYXRlZCwgd2hpY2ggY2FuIGJlIGFjY2VwdGVkLlxuICAgICAgICAgICAga2V5SW5mby5uYW1lID0gb3B0Lm5hbWUgIT0gbnVsbFxuICAgICAgICAgICAgICAgID8gb3B0Lm5hbWUgKyAnJ1xuICAgICAgICAgICAgICAgIDogZXhpc3RDcHRcbiAgICAgICAgICAgICAgICA/IGV4aXN0Q3B0Lm5hbWVcbiAgICAgICAgICAgICAgICA6ICdcXDAtJzsgLy8gbmFtZSBtYXkgYmUgZGlzcGxheWVkIG9uIHNjcmVlbiwgc28gdXNlICctJy5cblxuICAgICAgICAgICAgaWYgKGV4aXN0Q3B0KSB7XG4gICAgICAgICAgICAgICAga2V5SW5mby5pZCA9IGV4aXN0Q3B0LmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob3B0LmlkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBrZXlJbmZvLmlkID0gb3B0LmlkICsgJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBDb25zaWRlciB0aGlzIHNpdHVhdG9pbjpcbiAgICAgICAgICAgICAgICAvLyAgb3B0aW9uQTogW3tuYW1lOiAnYSd9LCB7bmFtZTogJ2EnfSwgey4ufV1cbiAgICAgICAgICAgICAgICAvLyAgb3B0aW9uQiBbey4ufSwge25hbWU6ICdhJ30sIHtuYW1lOiAnYSd9XVxuICAgICAgICAgICAgICAgIC8vIFNlcmllcyB3aXRoIHRoZSBzYW1lIG5hbWUgYmV0d2VlbiBvcHRpb25BIGFuZCBvcHRpb25CXG4gICAgICAgICAgICAgICAgLy8gc2hvdWxkIGJlIG1hcHBlZC5cbiAgICAgICAgICAgICAgICB2YXIgaWROdW0gPSAwO1xuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAga2V5SW5mby5pZCA9ICdcXDAnICsga2V5SW5mby5uYW1lICsgJ1xcMCcgKyBpZE51bSsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3aGlsZSAoaWRNYXBba2V5SW5mby5pZF0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZE1hcFtrZXlJbmZvLmlkXSA9IGl0ZW07XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcHVibGljXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNwdE9wdGlvblxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgbW9kZWxVdGlsLmlzSWRJbm5lciA9IGZ1bmN0aW9uIChjcHRPcHRpb24pIHtcbiAgICAgICAgcmV0dXJuIGlzT2JqZWN0KGNwdE9wdGlvbilcbiAgICAgICAgICAgICYmIGNwdE9wdGlvbi5pZFxuICAgICAgICAgICAgJiYgKGNwdE9wdGlvbi5pZCArICcnKS5pbmRleE9mKCdcXDBfZWNfXFwwJykgPT09IDA7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEEgaGVscGVyIGZvciByZW1vdmluZyBkdXBsaWNhdGUgaXRlbXMgYmV0d2VlbiBiYXRjaEEgYW5kIGJhdGNoQixcbiAgICAgKiBhbmQgaW4gdGhlbXNlbHZlcywgYW5kIGNhdGVnb3JpemUgYnkgc2VyaWVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheS48T2JqZWN0Pn0gYmF0Y2hBIExpa2U6IFt7c2VyaWVzSWQ6IDIsIGRhdGFJbmRleDogWzMyLCA0LCA1XX0sIC4uLl1cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxPYmplY3Q+fSBiYXRjaEIgTGlrZTogW3tzZXJpZXNJZDogMiwgZGF0YUluZGV4OiBbMzIsIDQsIDVdfSwgLi4uXVxuICAgICAqIEByZXR1cm4ge0FycmF5LjxBcnJheS48T2JqZWN0PiwgQXJyYXkuPE9iamVjdD4+fSByZXN1bHQ6IFtyZXN1bHRCYXRjaEEsIHJlc3VsdEJhdGNoQl1cbiAgICAgKi9cbiAgICBtb2RlbFV0aWwuY29tcHJlc3NCYXRjaGVzID0gZnVuY3Rpb24gKGJhdGNoQSwgYmF0Y2hCKSB7XG4gICAgICAgIHZhciBtYXBBID0ge307XG4gICAgICAgIHZhciBtYXBCID0ge307XG5cbiAgICAgICAgbWFrZU1hcChiYXRjaEEgfHwgW10sIG1hcEEpO1xuICAgICAgICBtYWtlTWFwKGJhdGNoQiB8fCBbXSwgbWFwQiwgbWFwQSk7XG5cbiAgICAgICAgcmV0dXJuIFttYXBUb0FycmF5KG1hcEEpLCBtYXBUb0FycmF5KG1hcEIpXTtcblxuICAgICAgICBmdW5jdGlvbiBtYWtlTWFwKHNvdXJjZUJhdGNoLCBtYXAsIG90aGVyTWFwKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc291cmNlQmF0Y2gubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VyaWVzSWQgPSBzb3VyY2VCYXRjaFtpXS5zZXJpZXNJZDtcbiAgICAgICAgICAgICAgICB2YXIgZGF0YUluZGljZXMgPSBtb2RlbFV0aWwubm9ybWFsaXplVG9BcnJheShzb3VyY2VCYXRjaFtpXS5kYXRhSW5kZXgpO1xuICAgICAgICAgICAgICAgIHZhciBvdGhlckRhdGFJbmRpY2VzID0gb3RoZXJNYXAgJiYgb3RoZXJNYXBbc2VyaWVzSWRdO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGxlbmogPSBkYXRhSW5kaWNlcy5sZW5ndGg7IGogPCBsZW5qOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGFJbmRleCA9IGRhdGFJbmRpY2VzW2pdO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdGhlckRhdGFJbmRpY2VzICYmIG90aGVyRGF0YUluZGljZXNbZGF0YUluZGV4XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3RoZXJEYXRhSW5kaWNlc1tkYXRhSW5kZXhdID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIChtYXBbc2VyaWVzSWRdIHx8IChtYXBbc2VyaWVzSWRdID0ge30pKVtkYXRhSW5kZXhdID0gMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG1hcFRvQXJyYXkobWFwLCBpc0RhdGEpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgaW4gbWFwKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hcC5oYXNPd25Qcm9wZXJ0eShpKSAmJiBtYXBbaV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNEYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgraSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YUluZGljZXMgPSBtYXBUb0FycmF5KG1hcFtpXSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhSW5kaWNlcy5sZW5ndGggJiYgcmVzdWx0LnB1c2goe3Nlcmllc0lkOiBpLCBkYXRhSW5kZXg6IGRhdGFJbmRpY2VzfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvZGF0YS9MaXN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBheWxvYWQgQ29udGFpbnMgZGF0YUluZGV4IChtZWFucyByYXdJbmRleCkgLyBkYXRhSW5kZXhJbnNpZGUgLyBuYW1lXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgZWFjaCBvZiB3aGljaCBjYW4gYmUgQXJyYXkgb3IgcHJpbWFyeSB0eXBlLlxuICAgICAqIEByZXR1cm4ge251bWJlcnxBcnJheS48bnVtYmVyPn0gZGF0YUluZGV4IElmIG5vdCBmb3VuZCwgcmV0dXJuIHVuZGVmaW5lZC9udWxsLlxuICAgICAqL1xuICAgIG1vZGVsVXRpbC5xdWVyeURhdGFJbmRleCA9IGZ1bmN0aW9uIChkYXRhLCBwYXlsb2FkKSB7XG4gICAgICAgIGlmIChwYXlsb2FkLmRhdGFJbmRleEluc2lkZSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gcGF5bG9hZC5kYXRhSW5kZXhJbnNpZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGF5bG9hZC5kYXRhSW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHpyVXRpbC5pc0FycmF5KHBheWxvYWQuZGF0YUluZGV4KVxuICAgICAgICAgICAgICAgID8genJVdGlsLm1hcChwYXlsb2FkLmRhdGFJbmRleCwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhLmluZGV4T2ZSYXdJbmRleCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICA6IGRhdGEuaW5kZXhPZlJhd0luZGV4KHBheWxvYWQuZGF0YUluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwYXlsb2FkLm5hbWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHpyVXRpbC5pc0FycmF5KHBheWxvYWQubmFtZSlcbiAgICAgICAgICAgICAgICA/IHpyVXRpbC5tYXAocGF5bG9hZC5uYW1lLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEuaW5kZXhPZk5hbWUodmFsdWUpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgOiBkYXRhLmluZGV4T2ZOYW1lKHBheWxvYWQubmFtZSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRW5hYmxlIHByb3BlcnR5IHN0b3JhZ2UgdG8gYW55IGhvc3Qgb2JqZWN0LlxuICAgICAqIE5vdGljZTogU2VyaWFsaXphdGlvbiBpcyBub3Qgc3VwcG9ydGVkLlxuICAgICAqXG4gICAgICogRm9yIGV4YW1wbGU6XG4gICAgICogdmFyIGdldCA9IG1vZGVsVWl0bC5tYWtlR2V0dGVyKCk7XG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBzb21lKGhvc3RPYmopIHtcbiAgICAgKiAgICAgIGdldChob3N0T2JqKS5fc29tZVByb3BlcnR5ID0gMTIxMjtcbiAgICAgKiAgICAgIC4uLlxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIG1vZGVsVXRpbC5tYWtlR2V0dGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSAnXFwwX19lY19wcm9wX2dldHRlcl8nICsgaW5kZXgrKztcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoaG9zdE9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiBob3N0T2JqW2tleV0gfHwgKGhvc3RPYmpba2V5XSA9IHt9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgfSkoKTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvR2xvYmFsfSBlY01vZGVsXG4gICAgICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0fSBmaW5kZXJcbiAgICAgKiAgICAgICAgSWYgc3RyaW5nLCBlLmcuLCAnZ2VvJywgbWVhbnMge2dlb0luZGV4OiAwfS5cbiAgICAgKiAgICAgICAgSWYgT2JqZWN0LCBjb3VsZCBjb250YWluIHNvbWUgb2YgdGhlc2UgcHJvcGVydGllcyBiZWxvdzpcbiAgICAgKiAgICAgICAge1xuICAgICAqICAgICAgICAgICAgc2VyaWVzSW5kZXgsIHNlcmllc0lkLCBzZXJpZXNOYW1lLFxuICAgICAqICAgICAgICAgICAgZ2VvSW5kZXgsIGdlb0lkLCBnZW9OYW1lLFxuICAgICAqICAgICAgICAgICAgYm1hcEluZGV4LCBibWFwSWQsIGJtYXBOYW1lLFxuICAgICAqICAgICAgICAgICAgeEF4aXNJbmRleCwgeEF4aXNJZCwgeEF4aXNOYW1lLFxuICAgICAqICAgICAgICAgICAgeUF4aXNJbmRleCwgeUF4aXNJZCwgeUF4aXNOYW1lLFxuICAgICAqICAgICAgICAgICAgZ3JpZEluZGV4LCBncmlkSWQsIGdyaWROYW1lLFxuICAgICAqICAgICAgICAgICAgLi4uIChjYW4gYmUgZXh0ZW5kZWQpXG4gICAgICogICAgICAgIH1cbiAgICAgKiAgICAgICAgRWFjaCBwcm9wZXJ0aWVzIGNhbiBiZSBudW1iZXJ8c3RyaW5nfEFycmF5LjxudW1iZXI+fEFycmF5LjxzdHJpbmc+XG4gICAgICogICAgICAgIEZvciBleGFtcGxlLCBhIGZpbmRlciBjb3VsZCBiZVxuICAgICAqICAgICAgICB7XG4gICAgICogICAgICAgICAgICBzZXJpZXNJbmRleDogMyxcbiAgICAgKiAgICAgICAgICAgIGdlb0lkOiBbJ2FhJywgJ2NjJ10sXG4gICAgICogICAgICAgICAgICBncmlkTmFtZTogWyd4eCcsICdyciddXG4gICAgICogICAgICAgIH1cbiAgICAgKiAgICAgICAgeHh4SW5kZXggY2FuIGJlIHNldCBhcyAnYWxsJyAobWVhbnMgYWxsIHh4eCkgb3IgJ25vbmUnIChtZWFucyBub3Qgc3BlY2lmeSlcbiAgICAgKiAgICAgICAgSWYgbm90aGluZyBvciBudWxsL3VuZGVmaW5lZCBzcGVjaWZpZWQsIHJldHVybiBub3RoaW5nLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0XVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0LmRlZmF1bHRNYWluVHlwZV1cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBbb3B0LmluY2x1ZGVNYWluVHlwZXNdXG4gICAgICogQHJldHVybiB7T2JqZWN0fSByZXN1bHQgbGlrZTpcbiAgICAgKiAgICAgICAge1xuICAgICAqICAgICAgICAgICAgc2VyaWVzTW9kZWxzOiBbc2VyaWVzTW9kZWwxLCBzZXJpZXNNb2RlbDJdLFxuICAgICAqICAgICAgICAgICAgc2VyaWVzTW9kZWw6IHNlcmllc01vZGVsMSwgLy8gVGhlIGZpcnN0IG1vZGVsXG4gICAgICogICAgICAgICAgICBnZW9Nb2RlbHM6IFtnZW9Nb2RlbDEsIGdlb01vZGVsMl0sXG4gICAgICogICAgICAgICAgICBnZW9Nb2RlbDogZ2VvTW9kZWwxLCAvLyBUaGUgZmlyc3QgbW9kZWxcbiAgICAgKiAgICAgICAgICAgIC4uLlxuICAgICAqICAgICAgICB9XG4gICAgICovXG4gICAgbW9kZWxVdGlsLnBhcnNlRmluZGVyID0gZnVuY3Rpb24gKGVjTW9kZWwsIGZpbmRlciwgb3B0KSB7XG4gICAgICAgIGlmICh6clV0aWwuaXNTdHJpbmcoZmluZGVyKSkge1xuICAgICAgICAgICAgdmFyIG9iaiA9IHt9O1xuICAgICAgICAgICAgb2JqW2ZpbmRlciArICdJbmRleCddID0gMDtcbiAgICAgICAgICAgIGZpbmRlciA9IG9iajtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkZWZhdWx0TWFpblR5cGUgPSBvcHQgJiYgb3B0LmRlZmF1bHRNYWluVHlwZTtcbiAgICAgICAgaWYgKGRlZmF1bHRNYWluVHlwZVxuICAgICAgICAgICAgJiYgIWhhcyhmaW5kZXIsIGRlZmF1bHRNYWluVHlwZSArICdJbmRleCcpXG4gICAgICAgICAgICAmJiAhaGFzKGZpbmRlciwgZGVmYXVsdE1haW5UeXBlICsgJ0lkJylcbiAgICAgICAgICAgICYmICFoYXMoZmluZGVyLCBkZWZhdWx0TWFpblR5cGUgKyAnTmFtZScpXG4gICAgICAgICkge1xuICAgICAgICAgICAgZmluZGVyW2RlZmF1bHRNYWluVHlwZSArICdJbmRleCddID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcblxuICAgICAgICBlYWNoKGZpbmRlciwgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGZpbmRlcltrZXldO1xuXG4gICAgICAgICAgICAvLyBFeGNsdWRlICdkYXRhSW5kZXgnIGFuZCBvdGhlciBpbGxnYWwga2V5cy5cbiAgICAgICAgICAgIGlmIChrZXkgPT09ICdkYXRhSW5kZXgnIHx8IGtleSA9PT0gJ2RhdGFJbmRleEluc2lkZScpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHBhcnNlZEtleSA9IGtleS5tYXRjaCgvXihcXHcrKShJbmRleHxJZHxOYW1lKSQvKSB8fCBbXTtcbiAgICAgICAgICAgIHZhciBtYWluVHlwZSA9IHBhcnNlZEtleVsxXTtcbiAgICAgICAgICAgIHZhciBxdWVyeVR5cGUgPSAocGFyc2VkS2V5WzJdIHx8ICcnKS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgICAgICBpZiAoIW1haW5UeXBlXG4gICAgICAgICAgICAgICAgfHwgIXF1ZXJ5VHlwZVxuICAgICAgICAgICAgICAgIHx8IHZhbHVlID09IG51bGxcbiAgICAgICAgICAgICAgICB8fCAocXVlcnlUeXBlID09PSAnaW5kZXgnICYmIHZhbHVlID09PSAnbm9uZScpXG4gICAgICAgICAgICAgICAgfHwgKG9wdCAmJiBvcHQuaW5jbHVkZU1haW5UeXBlcyAmJiB6clV0aWwuaW5kZXhPZihvcHQuaW5jbHVkZU1haW5UeXBlcywgbWFpblR5cGUpIDwgMClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHF1ZXJ5UGFyYW0gPSB7bWFpblR5cGU6IG1haW5UeXBlfTtcbiAgICAgICAgICAgIGlmIChxdWVyeVR5cGUgIT09ICdpbmRleCcgfHwgdmFsdWUgIT09ICdhbGwnKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbVtxdWVyeVR5cGVdID0gdmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBtb2RlbHMgPSBlY01vZGVsLnF1ZXJ5Q29tcG9uZW50cyhxdWVyeVBhcmFtKTtcbiAgICAgICAgICAgIHJlc3VsdFttYWluVHlwZSArICdNb2RlbHMnXSA9IG1vZGVscztcbiAgICAgICAgICAgIHJlc3VsdFttYWluVHlwZSArICdNb2RlbCddID0gbW9kZWxzWzBdO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBoYXMob2JqLCBwcm9wKSB7XG4gICAgICAgIHJldHVybiBvYmogJiYgb2JqLmhhc093blByb3BlcnR5KHByb3ApO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gbW9kZWxVdGlsO1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi91dGlsL21vZGVsLmpzXG4vLyBtb2R1bGUgaWQgPSA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 6 */
/* unknown exports provided */
/* all exports used */
/*!****************************!*\
  !*** ./lib/util/format.js ***!
  \****************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 0);\n    var numberUtil = __webpack_require__(/*! ./number */ 3);\n    var textContain = __webpack_require__(/*! zrender/lib/contain/text */ 15);\n\n    var formatUtil = {};\n\n    /**\n     * 每三位默认加,格式化\n     * @param {string|number} x\n     * @return {string}\n     */\n    formatUtil.addCommas = function (x) {\n        if (isNaN(x)) {\n            return '-';\n        }\n        x = (x + '').split('.');\n        return x[0].replace(/(\\d{1,3})(?=(?:\\d{3})+(?!\\d))/g,'$1,')\n               + (x.length > 1 ? ('.' + x[1]) : '');\n    };\n\n    /**\n     * @param {string} str\n     * @param {boolean} [upperCaseFirst=false]\n     * @return {string} str\n     */\n    formatUtil.toCamelCase = function (str, upperCaseFirst) {\n        str = (str || '').toLowerCase().replace(/-(.)/g, function(match, group1) {\n            return group1.toUpperCase();\n        });\n\n        if (upperCaseFirst && str) {\n            str = str.charAt(0).toUpperCase() + str.slice(1);\n        }\n\n        return str;\n    };\n\n    /**\n     * Normalize css liked array configuration\n     * e.g.\n     *  3 => [3, 3, 3, 3]\n     *  [4, 2] => [4, 2, 4, 2]\n     *  [4, 3, 2] => [4, 3, 2, 3]\n     * @param {number|Array.<number>} val\n     */\n    formatUtil.normalizeCssArray = function (val) {\n        var len = val.length;\n        if (typeof (val) === 'number') {\n            return [val, val, val, val];\n        }\n        else if (len === 2) {\n            // vertical | horizontal\n            return [val[0], val[1], val[0], val[1]];\n        }\n        else if (len === 3) {\n            // top | horizontal | bottom\n            return [val[0], val[1], val[2], val[1]];\n        }\n        return val;\n    };\n\n    var encodeHTML = formatUtil.encodeHTML = function (source) {\n        return String(source)\n            .replace(/&/g, '&amp;')\n            .replace(/</g, '&lt;')\n            .replace(/>/g, '&gt;')\n            .replace(/\"/g, '&quot;')\n            .replace(/'/g, '&#39;');\n    };\n\n    var TPL_VAR_ALIAS = ['a', 'b', 'c', 'd', 'e', 'f', 'g'];\n\n    var wrapVar = function (varName, seriesIdx) {\n        return '{' + varName + (seriesIdx == null ? '' : seriesIdx) + '}';\n    };\n\n    /**\n     * Template formatter\n     * @param {string} tpl\n     * @param {Array.<Object>|Object} paramsList\n     * @param {boolean} [encode=false]\n     * @return {string}\n     */\n    formatUtil.formatTpl = function (tpl, paramsList, encode) {\n        if (!zrUtil.isArray(paramsList)) {\n            paramsList = [paramsList];\n        }\n        var seriesLen = paramsList.length;\n        if (!seriesLen) {\n            return '';\n        }\n\n        var $vars = paramsList[0].$vars || [];\n        for (var i = 0; i < $vars.length; i++) {\n            var alias = TPL_VAR_ALIAS[i];\n            var val = wrapVar(alias, 0);\n            tpl = tpl.replace(wrapVar(alias), encode ? encodeHTML(val) : val);\n        }\n        for (var seriesIdx = 0; seriesIdx < seriesLen; seriesIdx++) {\n            for (var k = 0; k < $vars.length; k++) {\n                var val = paramsList[seriesIdx][$vars[k]];\n                tpl = tpl.replace(\n                    wrapVar(TPL_VAR_ALIAS[k], seriesIdx),\n                    encode ? encodeHTML(val) : val\n                );\n            }\n        }\n\n        return tpl;\n    };\n\n    /**\n     * simple Template formatter\n     *\n     * @param {string} tpl\n     * @param {Object} param\n     * @param {boolean} [encode=false]\n     * @return {string}\n     */\n    formatUtil.formatTplSimple = function (tpl, param, encode) {\n        zrUtil.each(param, function (value, key) {\n            tpl = tpl.replace(\n                '{' + key + '}',\n                encode ? encodeHTML(value) : value\n            );\n        });\n        return tpl;\n    };\n\n\n    /**\n     * @param {string} str\n     * @return {string}\n     * @inner\n     */\n    var s2d = function (str) {\n        return str < 10 ? ('0' + str) : str;\n    };\n\n    /**\n     * ISO Date format\n     * @param {string} tpl\n     * @param {number} value\n     * @param {boolean} [isUTC=false] Default in local time.\n     *           see `module:echarts/scale/Time`\n     *           and `module:echarts/util/number#parseDate`.\n     * @inner\n     */\n    formatUtil.formatTime = function (tpl, value, isUTC) {\n        if (tpl === 'week'\n            || tpl === 'month'\n            || tpl === 'quarter'\n            || tpl === 'half-year'\n            || tpl === 'year'\n        ) {\n            tpl = 'MM-dd\\nyyyy';\n        }\n\n        var date = numberUtil.parseDate(value);\n        var utc = isUTC ? 'UTC' : '';\n        var y = date['get' + utc + 'FullYear']();\n        var M = date['get' + utc + 'Month']() + 1;\n        var d = date['get' + utc + 'Date']();\n        var h = date['get' + utc + 'Hours']();\n        var m = date['get' + utc + 'Minutes']();\n        var s = date['get' + utc + 'Seconds']();\n\n        tpl = tpl.replace('MM', s2d(M))\n            .toLowerCase()\n            .replace('yyyy', y)\n            .replace('yy', y % 100)\n            .replace('dd', s2d(d))\n            .replace('d', d)\n            .replace('hh', s2d(h))\n            .replace('h', h)\n            .replace('mm', s2d(m))\n            .replace('m', m)\n            .replace('ss', s2d(s))\n            .replace('s', s);\n\n        return tpl;\n    };\n\n    /**\n     * Capital first\n     * @param {string} str\n     * @return {string}\n     */\n    formatUtil.capitalFirst = function (str) {\n        return str ? str.charAt(0).toUpperCase() + str.substr(1) : str;\n    };\n\n    formatUtil.truncateText = textContain.truncateText;\n\n    module.exports = formatUtil;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2xpYi91dGlsL2Zvcm1hdC5qcz9hMGE2Il0sInNvdXJjZXNDb250ZW50IjpbIlxuXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuICAgIHZhciBudW1iZXJVdGlsID0gcmVxdWlyZSgnLi9udW1iZXInKTtcbiAgICB2YXIgdGV4dENvbnRhaW4gPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb250YWluL3RleHQnKTtcblxuICAgIHZhciBmb3JtYXRVdGlsID0ge307XG5cbiAgICAvKipcbiAgICAgKiDmr4/kuInkvY3pu5jorqTliqAs5qC85byP5YyWXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSB4XG4gICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAqL1xuICAgIGZvcm1hdFV0aWwuYWRkQ29tbWFzID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgaWYgKGlzTmFOKHgpKSB7XG4gICAgICAgICAgICByZXR1cm4gJy0nO1xuICAgICAgICB9XG4gICAgICAgIHggPSAoeCArICcnKS5zcGxpdCgnLicpO1xuICAgICAgICByZXR1cm4geFswXS5yZXBsYWNlKC8oXFxkezEsM30pKD89KD86XFxkezN9KSsoPyFcXGQpKS9nLCckMSwnKVxuICAgICAgICAgICAgICAgKyAoeC5sZW5ndGggPiAxID8gKCcuJyArIHhbMV0pIDogJycpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbdXBwZXJDYXNlRmlyc3Q9ZmFsc2VdXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBzdHJcbiAgICAgKi9cbiAgICBmb3JtYXRVdGlsLnRvQ2FtZWxDYXNlID0gZnVuY3Rpb24gKHN0ciwgdXBwZXJDYXNlRmlyc3QpIHtcbiAgICAgICAgc3RyID0gKHN0ciB8fCAnJykudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC8tKC4pL2csIGZ1bmN0aW9uKG1hdGNoLCBncm91cDEpIHtcbiAgICAgICAgICAgIHJldHVybiBncm91cDEudG9VcHBlckNhc2UoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHVwcGVyQ2FzZUZpcnN0ICYmIHN0cikge1xuICAgICAgICAgICAgc3RyID0gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTm9ybWFsaXplIGNzcyBsaWtlZCBhcnJheSBjb25maWd1cmF0aW9uXG4gICAgICogZS5nLlxuICAgICAqICAzID0+IFszLCAzLCAzLCAzXVxuICAgICAqICBbNCwgMl0gPT4gWzQsIDIsIDQsIDJdXG4gICAgICogIFs0LCAzLCAyXSA9PiBbNCwgMywgMiwgM11cbiAgICAgKiBAcGFyYW0ge251bWJlcnxBcnJheS48bnVtYmVyPn0gdmFsXG4gICAgICovXG4gICAgZm9ybWF0VXRpbC5ub3JtYWxpemVDc3NBcnJheSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgdmFyIGxlbiA9IHZhbC5sZW5ndGg7XG4gICAgICAgIGlmICh0eXBlb2YgKHZhbCkgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gW3ZhbCwgdmFsLCB2YWwsIHZhbF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGVuID09PSAyKSB7XG4gICAgICAgICAgICAvLyB2ZXJ0aWNhbCB8IGhvcml6b250YWxcbiAgICAgICAgICAgIHJldHVybiBbdmFsWzBdLCB2YWxbMV0sIHZhbFswXSwgdmFsWzFdXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsZW4gPT09IDMpIHtcbiAgICAgICAgICAgIC8vIHRvcCB8IGhvcml6b250YWwgfCBib3R0b21cbiAgICAgICAgICAgIHJldHVybiBbdmFsWzBdLCB2YWxbMV0sIHZhbFsyXSwgdmFsWzFdXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH07XG5cbiAgICB2YXIgZW5jb2RlSFRNTCA9IGZvcm1hdFV0aWwuZW5jb2RlSFRNTCA9IGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZyhzb3VyY2UpXG4gICAgICAgICAgICAucmVwbGFjZSgvJi9nLCAnJmFtcDsnKVxuICAgICAgICAgICAgLnJlcGxhY2UoLzwvZywgJyZsdDsnKVxuICAgICAgICAgICAgLnJlcGxhY2UoLz4vZywgJyZndDsnKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKVxuICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgJyYjMzk7Jyk7XG4gICAgfTtcblxuICAgIHZhciBUUExfVkFSX0FMSUFTID0gWydhJywgJ2InLCAnYycsICdkJywgJ2UnLCAnZicsICdnJ107XG5cbiAgICB2YXIgd3JhcFZhciA9IGZ1bmN0aW9uICh2YXJOYW1lLCBzZXJpZXNJZHgpIHtcbiAgICAgICAgcmV0dXJuICd7JyArIHZhck5hbWUgKyAoc2VyaWVzSWR4ID09IG51bGwgPyAnJyA6IHNlcmllc0lkeCkgKyAnfSc7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRlbXBsYXRlIGZvcm1hdHRlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0cGxcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxPYmplY3Q+fE9iamVjdH0gcGFyYW1zTGlzdFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2VuY29kZT1mYWxzZV1cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICovXG4gICAgZm9ybWF0VXRpbC5mb3JtYXRUcGwgPSBmdW5jdGlvbiAodHBsLCBwYXJhbXNMaXN0LCBlbmNvZGUpIHtcbiAgICAgICAgaWYgKCF6clV0aWwuaXNBcnJheShwYXJhbXNMaXN0KSkge1xuICAgICAgICAgICAgcGFyYW1zTGlzdCA9IFtwYXJhbXNMaXN0XTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2VyaWVzTGVuID0gcGFyYW1zTGlzdC5sZW5ndGg7XG4gICAgICAgIGlmICghc2VyaWVzTGVuKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgJHZhcnMgPSBwYXJhbXNMaXN0WzBdLiR2YXJzIHx8IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8ICR2YXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYWxpYXMgPSBUUExfVkFSX0FMSUFTW2ldO1xuICAgICAgICAgICAgdmFyIHZhbCA9IHdyYXBWYXIoYWxpYXMsIDApO1xuICAgICAgICAgICAgdHBsID0gdHBsLnJlcGxhY2Uod3JhcFZhcihhbGlhcyksIGVuY29kZSA/IGVuY29kZUhUTUwodmFsKSA6IHZhbCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgc2VyaWVzSWR4ID0gMDsgc2VyaWVzSWR4IDwgc2VyaWVzTGVuOyBzZXJpZXNJZHgrKykge1xuICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCAkdmFycy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgIHZhciB2YWwgPSBwYXJhbXNMaXN0W3Nlcmllc0lkeF1bJHZhcnNba11dO1xuICAgICAgICAgICAgICAgIHRwbCA9IHRwbC5yZXBsYWNlKFxuICAgICAgICAgICAgICAgICAgICB3cmFwVmFyKFRQTF9WQVJfQUxJQVNba10sIHNlcmllc0lkeCksXG4gICAgICAgICAgICAgICAgICAgIGVuY29kZSA/IGVuY29kZUhUTUwodmFsKSA6IHZhbFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHBsO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBzaW1wbGUgVGVtcGxhdGUgZm9ybWF0dGVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHBsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZW5jb2RlPWZhbHNlXVxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKi9cbiAgICBmb3JtYXRVdGlsLmZvcm1hdFRwbFNpbXBsZSA9IGZ1bmN0aW9uICh0cGwsIHBhcmFtLCBlbmNvZGUpIHtcbiAgICAgICAgenJVdGlsLmVhY2gocGFyYW0sIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgICB0cGwgPSB0cGwucmVwbGFjZShcbiAgICAgICAgICAgICAgICAneycgKyBrZXkgKyAnfScsXG4gICAgICAgICAgICAgICAgZW5jb2RlID8gZW5jb2RlSFRNTCh2YWx1ZSkgOiB2YWx1ZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0cGw7XG4gICAgfTtcblxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICB2YXIgczJkID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICByZXR1cm4gc3RyIDwgMTAgPyAoJzAnICsgc3RyKSA6IHN0cjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSVNPIERhdGUgZm9ybWF0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRwbFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzVVRDPWZhbHNlXSBEZWZhdWx0IGluIGxvY2FsIHRpbWUuXG4gICAgICogICAgICAgICAgIHNlZSBgbW9kdWxlOmVjaGFydHMvc2NhbGUvVGltZWBcbiAgICAgKiAgICAgICAgICAgYW5kIGBtb2R1bGU6ZWNoYXJ0cy91dGlsL251bWJlciNwYXJzZURhdGVgLlxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZvcm1hdFV0aWwuZm9ybWF0VGltZSA9IGZ1bmN0aW9uICh0cGwsIHZhbHVlLCBpc1VUQykge1xuICAgICAgICBpZiAodHBsID09PSAnd2VlaydcbiAgICAgICAgICAgIHx8IHRwbCA9PT0gJ21vbnRoJ1xuICAgICAgICAgICAgfHwgdHBsID09PSAncXVhcnRlcidcbiAgICAgICAgICAgIHx8IHRwbCA9PT0gJ2hhbGYteWVhcidcbiAgICAgICAgICAgIHx8IHRwbCA9PT0gJ3llYXInXG4gICAgICAgICkge1xuICAgICAgICAgICAgdHBsID0gJ01NLWRkXFxueXl5eSc7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGF0ZSA9IG51bWJlclV0aWwucGFyc2VEYXRlKHZhbHVlKTtcbiAgICAgICAgdmFyIHV0YyA9IGlzVVRDID8gJ1VUQycgOiAnJztcbiAgICAgICAgdmFyIHkgPSBkYXRlWydnZXQnICsgdXRjICsgJ0Z1bGxZZWFyJ10oKTtcbiAgICAgICAgdmFyIE0gPSBkYXRlWydnZXQnICsgdXRjICsgJ01vbnRoJ10oKSArIDE7XG4gICAgICAgIHZhciBkID0gZGF0ZVsnZ2V0JyArIHV0YyArICdEYXRlJ10oKTtcbiAgICAgICAgdmFyIGggPSBkYXRlWydnZXQnICsgdXRjICsgJ0hvdXJzJ10oKTtcbiAgICAgICAgdmFyIG0gPSBkYXRlWydnZXQnICsgdXRjICsgJ01pbnV0ZXMnXSgpO1xuICAgICAgICB2YXIgcyA9IGRhdGVbJ2dldCcgKyB1dGMgKyAnU2Vjb25kcyddKCk7XG5cbiAgICAgICAgdHBsID0gdHBsLnJlcGxhY2UoJ01NJywgczJkKE0pKVxuICAgICAgICAgICAgLnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgIC5yZXBsYWNlKCd5eXl5JywgeSlcbiAgICAgICAgICAgIC5yZXBsYWNlKCd5eScsIHkgJSAxMDApXG4gICAgICAgICAgICAucmVwbGFjZSgnZGQnLCBzMmQoZCkpXG4gICAgICAgICAgICAucmVwbGFjZSgnZCcsIGQpXG4gICAgICAgICAgICAucmVwbGFjZSgnaGgnLCBzMmQoaCkpXG4gICAgICAgICAgICAucmVwbGFjZSgnaCcsIGgpXG4gICAgICAgICAgICAucmVwbGFjZSgnbW0nLCBzMmQobSkpXG4gICAgICAgICAgICAucmVwbGFjZSgnbScsIG0pXG4gICAgICAgICAgICAucmVwbGFjZSgnc3MnLCBzMmQocykpXG4gICAgICAgICAgICAucmVwbGFjZSgncycsIHMpO1xuXG4gICAgICAgIHJldHVybiB0cGw7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENhcGl0YWwgZmlyc3RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAqL1xuICAgIGZvcm1hdFV0aWwuY2FwaXRhbEZpcnN0ID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICByZXR1cm4gc3RyID8gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnN1YnN0cigxKSA6IHN0cjtcbiAgICB9O1xuXG4gICAgZm9ybWF0VXRpbC50cnVuY2F0ZVRleHQgPSB0ZXh0Q29udGFpbi50cnVuY2F0ZVRleHQ7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZvcm1hdFV0aWw7XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL3V0aWwvZm9ybWF0LmpzXG4vLyBtb2R1bGUgaWQgPSA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 7 */
/* unknown exports provided */
/* all exports used */
/*!**********************************************!*\
  !*** /home/yx/~/zrender/lib/graphic/Path.js ***!
  \**********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Path element\n * @module zrender/graphic/Path\n */\n\n\n\n    var Displayable = __webpack_require__(/*! ./Displayable */ 36);\n    var zrUtil = __webpack_require__(/*! ../core/util */ 0);\n    var PathProxy = __webpack_require__(/*! ../core/PathProxy */ 25);\n    var pathContain = __webpack_require__(/*! ../contain/path */ 111);\n\n    var Pattern = __webpack_require__(/*! ./Pattern */ 63);\n    var getCanvasPattern = Pattern.prototype.getCanvasPattern;\n\n    var abs = Math.abs;\n\n    var pathProxyForDraw = new PathProxy(true);\n    /**\n     * @alias module:zrender/graphic/Path\n     * @extends module:zrender/graphic/Displayable\n     * @constructor\n     * @param {Object} opts\n     */\n    function Path(opts) {\n        Displayable.call(this, opts);\n\n        /**\n         * @type {module:zrender/core/PathProxy}\n         * @readOnly\n         */\n        this.path = null;\n    }\n\n    Path.prototype = {\n\n        constructor: Path,\n\n        type: 'path',\n\n        __dirtyPath: true,\n\n        strokeContainThreshold: 5,\n\n        brush: function (ctx, prevEl) {\n            var style = this.style;\n            var path = this.path || pathProxyForDraw;\n            var hasStroke = style.hasStroke();\n            var hasFill = style.hasFill();\n            var fill = style.fill;\n            var stroke = style.stroke;\n            var hasFillGradient = hasFill && !!(fill.colorStops);\n            var hasStrokeGradient = hasStroke && !!(stroke.colorStops);\n            var hasFillPattern = hasFill && !!(fill.image);\n            var hasStrokePattern = hasStroke && !!(stroke.image);\n\n            style.bind(ctx, this, prevEl);\n            this.setTransform(ctx);\n\n            if (this.__dirty) {\n                var rect;\n                // Update gradient because bounding rect may changed\n                if (hasFillGradient) {\n                    rect = rect || this.getBoundingRect();\n                    this._fillGradient = style.getGradient(ctx, fill, rect);\n                }\n                if (hasStrokeGradient) {\n                    rect = rect || this.getBoundingRect();\n                    this._strokeGradient = style.getGradient(ctx, stroke, rect);\n                }\n            }\n            // Use the gradient or pattern\n            if (hasFillGradient) {\n                // PENDING If may have affect the state\n                ctx.fillStyle = this._fillGradient;\n            }\n            else if (hasFillPattern) {\n                ctx.fillStyle = getCanvasPattern.call(fill, ctx);\n            }\n            if (hasStrokeGradient) {\n                ctx.strokeStyle = this._strokeGradient;\n            }\n            else if (hasStrokePattern) {\n                ctx.strokeStyle = getCanvasPattern.call(stroke, ctx);\n            }\n\n            var lineDash = style.lineDash;\n            var lineDashOffset = style.lineDashOffset;\n\n            var ctxLineDash = !!ctx.setLineDash;\n\n            // Update path sx, sy\n            var scale = this.getGlobalScale();\n            path.setScale(scale[0], scale[1]);\n\n            // Proxy context\n            // Rebuild path in following 2 cases\n            // 1. Path is dirty\n            // 2. Path needs javascript implemented lineDash stroking.\n            //    In this case, lineDash information will not be saved in PathProxy\n            if (this.__dirtyPath\n                || (lineDash && !ctxLineDash && hasStroke)\n            ) {\n                path.beginPath(ctx);\n\n                // Setting line dash before build path\n                if (lineDash && !ctxLineDash) {\n                    path.setLineDash(lineDash);\n                    path.setLineDashOffset(lineDashOffset);\n                }\n\n                this.buildPath(path, this.shape, false);\n\n                // Clear path dirty flag\n                if (this.path) {\n                    this.__dirtyPath = false;\n                }\n            }\n            else {\n                // Replay path building\n                ctx.beginPath();\n                this.path.rebuildPath(ctx);\n            }\n\n            hasFill && path.fill(ctx);\n\n            if (lineDash && ctxLineDash) {\n                ctx.setLineDash(lineDash);\n                ctx.lineDashOffset = lineDashOffset;\n            }\n\n            hasStroke && path.stroke(ctx);\n\n            if (lineDash && ctxLineDash) {\n                // PENDING\n                // Remove lineDash\n                ctx.setLineDash([]);\n            }\n\n\n            this.restoreTransform(ctx);\n\n            // Draw rect text\n            if (style.text != null) {\n                // var rect = this.getBoundingRect();\n                this.drawRectText(ctx, this.getBoundingRect());\n            }\n        },\n\n        // When bundling path, some shape may decide if use moveTo to begin a new subpath or closePath\n        // Like in circle\n        buildPath: function (ctx, shapeCfg, inBundle) {},\n\n        createPathProxy: function () {\n            this.path = new PathProxy();\n        },\n\n        getBoundingRect: function () {\n            var rect = this._rect;\n            var style = this.style;\n            var needsUpdateRect = !rect;\n            if (needsUpdateRect) {\n                var path = this.path;\n                if (!path) {\n                    // Create path on demand.\n                    path = this.path = new PathProxy();\n                }\n                if (this.__dirtyPath) {\n                    path.beginPath();\n                    this.buildPath(path, this.shape, false);\n                }\n                rect = path.getBoundingRect();\n            }\n            this._rect = rect;\n\n            if (style.hasStroke()) {\n                // Needs update rect with stroke lineWidth when\n                // 1. Element changes scale or lineWidth\n                // 2. Shape is changed\n                var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());\n                if (this.__dirty || needsUpdateRect) {\n                    rectWithStroke.copy(rect);\n                    // FIXME Must after updateTransform\n                    var w = style.lineWidth;\n                    // PENDING, Min line width is needed when line is horizontal or vertical\n                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;\n\n                    // Only add extra hover lineWidth when there are no fill\n                    if (!style.hasFill()) {\n                        w = Math.max(w, this.strokeContainThreshold || 4);\n                    }\n                    // Consider line width\n                    // Line scale can't be 0;\n                    if (lineScale > 1e-10) {\n                        rectWithStroke.width += w / lineScale;\n                        rectWithStroke.height += w / lineScale;\n                        rectWithStroke.x -= w / lineScale / 2;\n                        rectWithStroke.y -= w / lineScale / 2;\n                    }\n                }\n\n                // Return rect with stroke\n                return rectWithStroke;\n            }\n\n            return rect;\n        },\n\n        contain: function (x, y) {\n            var localPos = this.transformCoordToLocal(x, y);\n            var rect = this.getBoundingRect();\n            var style = this.style;\n            x = localPos[0];\n            y = localPos[1];\n\n            if (rect.contain(x, y)) {\n                var pathData = this.path.data;\n                if (style.hasStroke()) {\n                    var lineWidth = style.lineWidth;\n                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;\n                    // Line scale can't be 0;\n                    if (lineScale > 1e-10) {\n                        // Only add extra hover lineWidth when there are no fill\n                        if (!style.hasFill()) {\n                            lineWidth = Math.max(lineWidth, this.strokeContainThreshold);\n                        }\n                        if (pathContain.containStroke(\n                            pathData, lineWidth / lineScale, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                }\n                if (style.hasFill()) {\n                    return pathContain.contain(pathData, x, y);\n                }\n            }\n            return false;\n        },\n\n        /**\n         * @param  {boolean} dirtyPath\n         */\n        dirty: function (dirtyPath) {\n            if (dirtyPath == null) {\n                dirtyPath = true;\n            }\n            // Only mark dirty, not mark clean\n            if (dirtyPath) {\n                this.__dirtyPath = dirtyPath;\n                this._rect = null;\n            }\n\n            this.__dirty = true;\n\n            this.__zr && this.__zr.refresh();\n\n            // Used as a clipping path\n            if (this.__clipTarget) {\n                this.__clipTarget.dirty();\n            }\n        },\n\n        /**\n         * Alias for animate('shape')\n         * @param {boolean} loop\n         */\n        animateShape: function (loop) {\n            return this.animate('shape', loop);\n        },\n\n        // Overwrite attrKV\n        attrKV: function (key, value) {\n            // FIXME\n            if (key === 'shape') {\n                this.setShape(value);\n                this.__dirtyPath = true;\n                this._rect = null;\n            }\n            else {\n                Displayable.prototype.attrKV.call(this, key, value);\n            }\n        },\n\n        /**\n         * @param {Object|string} key\n         * @param {*} value\n         */\n        setShape: function (key, value) {\n            var shape = this.shape;\n            // Path from string may not have shape\n            if (shape) {\n                if (zrUtil.isObject(key)) {\n                    for (var name in key) {\n                        if (key.hasOwnProperty(name)) {\n                            shape[name] = key[name];\n                        }\n                    }\n                }\n                else {\n                    shape[key] = value;\n                }\n                this.dirty(true);\n            }\n            return this;\n        },\n\n        getLineScale: function () {\n            var m = this.transform;\n            // Get the line scale.\n            // Determinant of `m` means how much the area is enlarged by the\n            // transformation. So its square root can be used as a scale factor\n            // for width.\n            return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10\n                ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1]))\n                : 1;\n        }\n    };\n\n    /**\n     * 扩展一个 Path element, 比如星形，圆等。\n     * Extend a path element\n     * @param {Object} props\n     * @param {string} props.type Path type\n     * @param {Function} props.init Initialize\n     * @param {Function} props.buildPath Overwrite buildPath method\n     * @param {Object} [props.style] Extended default style config\n     * @param {Object} [props.shape] Extended default shape config\n     */\n    Path.extend = function (defaults) {\n        var Sub = function (opts) {\n            Path.call(this, opts);\n\n            if (defaults.style) {\n                // Extend default style\n                this.style.extendFrom(defaults.style, false);\n            }\n\n            // Extend default shape\n            var defaultShape = defaults.shape;\n            if (defaultShape) {\n                this.shape = this.shape || {};\n                var thisShape = this.shape;\n                for (var name in defaultShape) {\n                    if (\n                        ! thisShape.hasOwnProperty(name)\n                        && defaultShape.hasOwnProperty(name)\n                    ) {\n                        thisShape[name] = defaultShape[name];\n                    }\n                }\n            }\n\n            defaults.init && defaults.init.call(this, opts);\n        };\n\n        zrUtil.inherits(Sub, Path);\n\n        // FIXME 不能 extend position, rotation 等引用对象\n        for (var name in defaults) {\n            // Extending prototype values and methods\n            if (name !== 'style' && name !== 'shape') {\n                Sub.prototype[name] = defaults[name];\n            }\n        }\n\n        return Sub;\n    };\n\n    zrUtil.inherits(Path, Displayable);\n\n    module.exports = Path;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vaG9tZS95eC9+L3pyZW5kZXIvbGliL2dyYXBoaWMvUGF0aC5qcz9jYjFlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogUGF0aCBlbGVtZW50XG4gKiBAbW9kdWxlIHpyZW5kZXIvZ3JhcGhpYy9QYXRoXG4gKi9cblxuXG5cbiAgICB2YXIgRGlzcGxheWFibGUgPSByZXF1aXJlKCcuL0Rpc3BsYXlhYmxlJyk7XG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpO1xuICAgIHZhciBQYXRoUHJveHkgPSByZXF1aXJlKCcuLi9jb3JlL1BhdGhQcm94eScpO1xuICAgIHZhciBwYXRoQ29udGFpbiA9IHJlcXVpcmUoJy4uL2NvbnRhaW4vcGF0aCcpO1xuXG4gICAgdmFyIFBhdHRlcm4gPSByZXF1aXJlKCcuL1BhdHRlcm4nKTtcbiAgICB2YXIgZ2V0Q2FudmFzUGF0dGVybiA9IFBhdHRlcm4ucHJvdG90eXBlLmdldENhbnZhc1BhdHRlcm47XG5cbiAgICB2YXIgYWJzID0gTWF0aC5hYnM7XG5cbiAgICB2YXIgcGF0aFByb3h5Rm9yRHJhdyA9IG5ldyBQYXRoUHJveHkodHJ1ZSk7XG4gICAgLyoqXG4gICAgICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL2dyYXBoaWMvUGF0aFxuICAgICAqIEBleHRlbmRzIG1vZHVsZTp6cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIFBhdGgob3B0cykge1xuICAgICAgICBEaXNwbGF5YWJsZS5jYWxsKHRoaXMsIG9wdHMpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl9XG4gICAgICAgICAqIEByZWFkT25seVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wYXRoID0gbnVsbDtcbiAgICB9XG5cbiAgICBQYXRoLnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogUGF0aCxcblxuICAgICAgICB0eXBlOiAncGF0aCcsXG5cbiAgICAgICAgX19kaXJ0eVBhdGg6IHRydWUsXG5cbiAgICAgICAgc3Ryb2tlQ29udGFpblRocmVzaG9sZDogNSxcblxuICAgICAgICBicnVzaDogZnVuY3Rpb24gKGN0eCwgcHJldkVsKSB7XG4gICAgICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLnN0eWxlO1xuICAgICAgICAgICAgdmFyIHBhdGggPSB0aGlzLnBhdGggfHwgcGF0aFByb3h5Rm9yRHJhdztcbiAgICAgICAgICAgIHZhciBoYXNTdHJva2UgPSBzdHlsZS5oYXNTdHJva2UoKTtcbiAgICAgICAgICAgIHZhciBoYXNGaWxsID0gc3R5bGUuaGFzRmlsbCgpO1xuICAgICAgICAgICAgdmFyIGZpbGwgPSBzdHlsZS5maWxsO1xuICAgICAgICAgICAgdmFyIHN0cm9rZSA9IHN0eWxlLnN0cm9rZTtcbiAgICAgICAgICAgIHZhciBoYXNGaWxsR3JhZGllbnQgPSBoYXNGaWxsICYmICEhKGZpbGwuY29sb3JTdG9wcyk7XG4gICAgICAgICAgICB2YXIgaGFzU3Ryb2tlR3JhZGllbnQgPSBoYXNTdHJva2UgJiYgISEoc3Ryb2tlLmNvbG9yU3RvcHMpO1xuICAgICAgICAgICAgdmFyIGhhc0ZpbGxQYXR0ZXJuID0gaGFzRmlsbCAmJiAhIShmaWxsLmltYWdlKTtcbiAgICAgICAgICAgIHZhciBoYXNTdHJva2VQYXR0ZXJuID0gaGFzU3Ryb2tlICYmICEhKHN0cm9rZS5pbWFnZSk7XG5cbiAgICAgICAgICAgIHN0eWxlLmJpbmQoY3R4LCB0aGlzLCBwcmV2RWwpO1xuICAgICAgICAgICAgdGhpcy5zZXRUcmFuc2Zvcm0oY3R4KTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX19kaXJ0eSkge1xuICAgICAgICAgICAgICAgIHZhciByZWN0O1xuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBncmFkaWVudCBiZWNhdXNlIGJvdW5kaW5nIHJlY3QgbWF5IGNoYW5nZWRcbiAgICAgICAgICAgICAgICBpZiAoaGFzRmlsbEdyYWRpZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlY3QgPSByZWN0IHx8IHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZpbGxHcmFkaWVudCA9IHN0eWxlLmdldEdyYWRpZW50KGN0eCwgZmlsbCwgcmVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChoYXNTdHJva2VHcmFkaWVudCkge1xuICAgICAgICAgICAgICAgICAgICByZWN0ID0gcmVjdCB8fCB0aGlzLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdHJva2VHcmFkaWVudCA9IHN0eWxlLmdldEdyYWRpZW50KGN0eCwgc3Ryb2tlLCByZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBVc2UgdGhlIGdyYWRpZW50IG9yIHBhdHRlcm5cbiAgICAgICAgICAgIGlmIChoYXNGaWxsR3JhZGllbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBQRU5ESU5HIElmIG1heSBoYXZlIGFmZmVjdCB0aGUgc3RhdGVcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5fZmlsbEdyYWRpZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaGFzRmlsbFBhdHRlcm4pIHtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gZ2V0Q2FudmFzUGF0dGVybi5jYWxsKGZpbGwsIGN0eCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGFzU3Ryb2tlR3JhZGllbnQpIHtcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLl9zdHJva2VHcmFkaWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGhhc1N0cm9rZVBhdHRlcm4pIHtcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBnZXRDYW52YXNQYXR0ZXJuLmNhbGwoc3Ryb2tlLCBjdHgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbGluZURhc2ggPSBzdHlsZS5saW5lRGFzaDtcbiAgICAgICAgICAgIHZhciBsaW5lRGFzaE9mZnNldCA9IHN0eWxlLmxpbmVEYXNoT2Zmc2V0O1xuXG4gICAgICAgICAgICB2YXIgY3R4TGluZURhc2ggPSAhIWN0eC5zZXRMaW5lRGFzaDtcblxuICAgICAgICAgICAgLy8gVXBkYXRlIHBhdGggc3gsIHN5XG4gICAgICAgICAgICB2YXIgc2NhbGUgPSB0aGlzLmdldEdsb2JhbFNjYWxlKCk7XG4gICAgICAgICAgICBwYXRoLnNldFNjYWxlKHNjYWxlWzBdLCBzY2FsZVsxXSk7XG5cbiAgICAgICAgICAgIC8vIFByb3h5IGNvbnRleHRcbiAgICAgICAgICAgIC8vIFJlYnVpbGQgcGF0aCBpbiBmb2xsb3dpbmcgMiBjYXNlc1xuICAgICAgICAgICAgLy8gMS4gUGF0aCBpcyBkaXJ0eVxuICAgICAgICAgICAgLy8gMi4gUGF0aCBuZWVkcyBqYXZhc2NyaXB0IGltcGxlbWVudGVkIGxpbmVEYXNoIHN0cm9raW5nLlxuICAgICAgICAgICAgLy8gICAgSW4gdGhpcyBjYXNlLCBsaW5lRGFzaCBpbmZvcm1hdGlvbiB3aWxsIG5vdCBiZSBzYXZlZCBpbiBQYXRoUHJveHlcbiAgICAgICAgICAgIGlmICh0aGlzLl9fZGlydHlQYXRoXG4gICAgICAgICAgICAgICAgfHwgKGxpbmVEYXNoICYmICFjdHhMaW5lRGFzaCAmJiBoYXNTdHJva2UpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBwYXRoLmJlZ2luUGF0aChjdHgpO1xuXG4gICAgICAgICAgICAgICAgLy8gU2V0dGluZyBsaW5lIGRhc2ggYmVmb3JlIGJ1aWxkIHBhdGhcbiAgICAgICAgICAgICAgICBpZiAobGluZURhc2ggJiYgIWN0eExpbmVEYXNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGguc2V0TGluZURhc2gobGluZURhc2gpO1xuICAgICAgICAgICAgICAgICAgICBwYXRoLnNldExpbmVEYXNoT2Zmc2V0KGxpbmVEYXNoT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmJ1aWxkUGF0aChwYXRoLCB0aGlzLnNoYXBlLCBmYWxzZSk7XG5cbiAgICAgICAgICAgICAgICAvLyBDbGVhciBwYXRoIGRpcnR5IGZsYWdcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX19kaXJ0eVBhdGggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBSZXBsYXkgcGF0aCBidWlsZGluZ1xuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBhdGgucmVidWlsZFBhdGgoY3R4KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaGFzRmlsbCAmJiBwYXRoLmZpbGwoY3R4KTtcblxuICAgICAgICAgICAgaWYgKGxpbmVEYXNoICYmIGN0eExpbmVEYXNoKSB7XG4gICAgICAgICAgICAgICAgY3R4LnNldExpbmVEYXNoKGxpbmVEYXNoKTtcbiAgICAgICAgICAgICAgICBjdHgubGluZURhc2hPZmZzZXQgPSBsaW5lRGFzaE9mZnNldDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaGFzU3Ryb2tlICYmIHBhdGguc3Ryb2tlKGN0eCk7XG5cbiAgICAgICAgICAgIGlmIChsaW5lRGFzaCAmJiBjdHhMaW5lRGFzaCkge1xuICAgICAgICAgICAgICAgIC8vIFBFTkRJTkdcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgbGluZURhc2hcbiAgICAgICAgICAgICAgICBjdHguc2V0TGluZURhc2goW10pO1xuICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgIHRoaXMucmVzdG9yZVRyYW5zZm9ybShjdHgpO1xuXG4gICAgICAgICAgICAvLyBEcmF3IHJlY3QgdGV4dFxuICAgICAgICAgICAgaWYgKHN0eWxlLnRleHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIHZhciByZWN0ID0gdGhpcy5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYXdSZWN0VGV4dChjdHgsIHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIFdoZW4gYnVuZGxpbmcgcGF0aCwgc29tZSBzaGFwZSBtYXkgZGVjaWRlIGlmIHVzZSBtb3ZlVG8gdG8gYmVnaW4gYSBuZXcgc3VicGF0aCBvciBjbG9zZVBhdGhcbiAgICAgICAgLy8gTGlrZSBpbiBjaXJjbGVcbiAgICAgICAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZUNmZywgaW5CdW5kbGUpIHt9LFxuXG4gICAgICAgIGNyZWF0ZVBhdGhQcm94eTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5wYXRoID0gbmV3IFBhdGhQcm94eSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldEJvdW5kaW5nUmVjdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJlY3QgPSB0aGlzLl9yZWN0O1xuICAgICAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTtcbiAgICAgICAgICAgIHZhciBuZWVkc1VwZGF0ZVJlY3QgPSAhcmVjdDtcbiAgICAgICAgICAgIGlmIChuZWVkc1VwZGF0ZVJlY3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGF0aCA9IHRoaXMucGF0aDtcbiAgICAgICAgICAgICAgICBpZiAoIXBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIHBhdGggb24gZGVtYW5kLlxuICAgICAgICAgICAgICAgICAgICBwYXRoID0gdGhpcy5wYXRoID0gbmV3IFBhdGhQcm94eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fX2RpcnR5UGF0aCkge1xuICAgICAgICAgICAgICAgICAgICBwYXRoLmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1aWxkUGF0aChwYXRoLCB0aGlzLnNoYXBlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlY3QgPSBwYXRoLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcmVjdCA9IHJlY3Q7XG5cbiAgICAgICAgICAgIGlmIChzdHlsZS5oYXNTdHJva2UoKSkge1xuICAgICAgICAgICAgICAgIC8vIE5lZWRzIHVwZGF0ZSByZWN0IHdpdGggc3Ryb2tlIGxpbmVXaWR0aCB3aGVuXG4gICAgICAgICAgICAgICAgLy8gMS4gRWxlbWVudCBjaGFuZ2VzIHNjYWxlIG9yIGxpbmVXaWR0aFxuICAgICAgICAgICAgICAgIC8vIDIuIFNoYXBlIGlzIGNoYW5nZWRcbiAgICAgICAgICAgICAgICB2YXIgcmVjdFdpdGhTdHJva2UgPSB0aGlzLl9yZWN0V2l0aFN0cm9rZSB8fCAodGhpcy5fcmVjdFdpdGhTdHJva2UgPSByZWN0LmNsb25lKCkpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9fZGlydHkgfHwgbmVlZHNVcGRhdGVSZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlY3RXaXRoU3Ryb2tlLmNvcHkocmVjdCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZJWE1FIE11c3QgYWZ0ZXIgdXBkYXRlVHJhbnNmb3JtXG4gICAgICAgICAgICAgICAgICAgIHZhciB3ID0gc3R5bGUubGluZVdpZHRoO1xuICAgICAgICAgICAgICAgICAgICAvLyBQRU5ESU5HLCBNaW4gbGluZSB3aWR0aCBpcyBuZWVkZWQgd2hlbiBsaW5lIGlzIGhvcml6b250YWwgb3IgdmVydGljYWxcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxpbmVTY2FsZSA9IHN0eWxlLnN0cm9rZU5vU2NhbGUgPyB0aGlzLmdldExpbmVTY2FsZSgpIDogMTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IGFkZCBleHRyYSBob3ZlciBsaW5lV2lkdGggd2hlbiB0aGVyZSBhcmUgbm8gZmlsbFxuICAgICAgICAgICAgICAgICAgICBpZiAoIXN0eWxlLmhhc0ZpbGwoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdyA9IE1hdGgubWF4KHcsIHRoaXMuc3Ryb2tlQ29udGFpblRocmVzaG9sZCB8fCA0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBDb25zaWRlciBsaW5lIHdpZHRoXG4gICAgICAgICAgICAgICAgICAgIC8vIExpbmUgc2NhbGUgY2FuJ3QgYmUgMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmVTY2FsZSA+IDFlLTEwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWN0V2l0aFN0cm9rZS53aWR0aCArPSB3IC8gbGluZVNjYWxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjdFdpdGhTdHJva2UuaGVpZ2h0ICs9IHcgLyBsaW5lU2NhbGU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWN0V2l0aFN0cm9rZS54IC09IHcgLyBsaW5lU2NhbGUgLyAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjdFdpdGhTdHJva2UueSAtPSB3IC8gbGluZVNjYWxlIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFJldHVybiByZWN0IHdpdGggc3Ryb2tlXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlY3RXaXRoU3Ryb2tlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVjdDtcbiAgICAgICAgfSxcblxuICAgICAgICBjb250YWluOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgdmFyIGxvY2FsUG9zID0gdGhpcy50cmFuc2Zvcm1Db29yZFRvTG9jYWwoeCwgeSk7XG4gICAgICAgICAgICB2YXIgcmVjdCA9IHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLnN0eWxlO1xuICAgICAgICAgICAgeCA9IGxvY2FsUG9zWzBdO1xuICAgICAgICAgICAgeSA9IGxvY2FsUG9zWzFdO1xuXG4gICAgICAgICAgICBpZiAocmVjdC5jb250YWluKHgsIHkpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhdGhEYXRhID0gdGhpcy5wYXRoLmRhdGE7XG4gICAgICAgICAgICAgICAgaWYgKHN0eWxlLmhhc1N0cm9rZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsaW5lV2lkdGggPSBzdHlsZS5saW5lV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsaW5lU2NhbGUgPSBzdHlsZS5zdHJva2VOb1NjYWxlID8gdGhpcy5nZXRMaW5lU2NhbGUoKSA6IDE7XG4gICAgICAgICAgICAgICAgICAgIC8vIExpbmUgc2NhbGUgY2FuJ3QgYmUgMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmVTY2FsZSA+IDFlLTEwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IGFkZCBleHRyYSBob3ZlciBsaW5lV2lkdGggd2hlbiB0aGVyZSBhcmUgbm8gZmlsbFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzdHlsZS5oYXNGaWxsKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lV2lkdGggPSBNYXRoLm1heChsaW5lV2lkdGgsIHRoaXMuc3Ryb2tlQ29udGFpblRocmVzaG9sZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGF0aENvbnRhaW4uY29udGFpblN0cm9rZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoRGF0YSwgbGluZVdpZHRoIC8gbGluZVNjYWxlLCB4LCB5XG4gICAgICAgICAgICAgICAgICAgICAgICApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHN0eWxlLmhhc0ZpbGwoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGF0aENvbnRhaW4uY29udGFpbihwYXRoRGF0YSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gIHtib29sZWFufSBkaXJ0eVBhdGhcbiAgICAgICAgICovXG4gICAgICAgIGRpcnR5OiBmdW5jdGlvbiAoZGlydHlQYXRoKSB7XG4gICAgICAgICAgICBpZiAoZGlydHlQYXRoID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkaXJ0eVBhdGggPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gT25seSBtYXJrIGRpcnR5LCBub3QgbWFyayBjbGVhblxuICAgICAgICAgICAgaWYgKGRpcnR5UGF0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX19kaXJ0eVBhdGggPSBkaXJ0eVBhdGg7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVjdCA9IG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX19kaXJ0eSA9IHRydWU7XG5cbiAgICAgICAgICAgIHRoaXMuX196ciAmJiB0aGlzLl9fenIucmVmcmVzaCgpO1xuXG4gICAgICAgICAgICAvLyBVc2VkIGFzIGEgY2xpcHBpbmcgcGF0aFxuICAgICAgICAgICAgaWYgKHRoaXMuX19jbGlwVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fX2NsaXBUYXJnZXQuZGlydHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQWxpYXMgZm9yIGFuaW1hdGUoJ3NoYXBlJylcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBsb29wXG4gICAgICAgICAqL1xuICAgICAgICBhbmltYXRlU2hhcGU6IGZ1bmN0aW9uIChsb29wKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hbmltYXRlKCdzaGFwZScsIGxvb3ApO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIE92ZXJ3cml0ZSBhdHRyS1ZcbiAgICAgICAgYXR0cktWOiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgLy8gRklYTUVcbiAgICAgICAgICAgIGlmIChrZXkgPT09ICdzaGFwZScpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFNoYXBlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9fZGlydHlQYXRoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWN0ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIERpc3BsYXlhYmxlLnByb3RvdHlwZS5hdHRyS1YuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R8c3RyaW5nfSBrZXlcbiAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0U2hhcGU6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgc2hhcGUgPSB0aGlzLnNoYXBlO1xuICAgICAgICAgICAgLy8gUGF0aCBmcm9tIHN0cmluZyBtYXkgbm90IGhhdmUgc2hhcGVcbiAgICAgICAgICAgIGlmIChzaGFwZSkge1xuICAgICAgICAgICAgICAgIGlmICh6clV0aWwuaXNPYmplY3Qoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBuYW1lIGluIGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYXBlW25hbWVdID0ga2V5W25hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzaGFwZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZGlydHkodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRMaW5lU2NhbGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBtID0gdGhpcy50cmFuc2Zvcm07XG4gICAgICAgICAgICAvLyBHZXQgdGhlIGxpbmUgc2NhbGUuXG4gICAgICAgICAgICAvLyBEZXRlcm1pbmFudCBvZiBgbWAgbWVhbnMgaG93IG11Y2ggdGhlIGFyZWEgaXMgZW5sYXJnZWQgYnkgdGhlXG4gICAgICAgICAgICAvLyB0cmFuc2Zvcm1hdGlvbi4gU28gaXRzIHNxdWFyZSByb290IGNhbiBiZSB1c2VkIGFzIGEgc2NhbGUgZmFjdG9yXG4gICAgICAgICAgICAvLyBmb3Igd2lkdGguXG4gICAgICAgICAgICByZXR1cm4gbSAmJiBhYnMobVswXSAtIDEpID4gMWUtMTAgJiYgYWJzKG1bM10gLSAxKSA+IDFlLTEwXG4gICAgICAgICAgICAgICAgPyBNYXRoLnNxcnQoYWJzKG1bMF0gKiBtWzNdIC0gbVsyXSAqIG1bMV0pKVxuICAgICAgICAgICAgICAgIDogMTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiDmianlsZXkuIDkuKogUGF0aCBlbGVtZW50LCDmr5TlpoLmmJ/lvaLvvIzlnIbnrYnjgIJcbiAgICAgKiBFeHRlbmQgYSBwYXRoIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcHNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcHMudHlwZSBQYXRoIHR5cGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcm9wcy5pbml0IEluaXRpYWxpemVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcm9wcy5idWlsZFBhdGggT3ZlcndyaXRlIGJ1aWxkUGF0aCBtZXRob2RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3Byb3BzLnN0eWxlXSBFeHRlbmRlZCBkZWZhdWx0IHN0eWxlIGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMuc2hhcGVdIEV4dGVuZGVkIGRlZmF1bHQgc2hhcGUgY29uZmlnXG4gICAgICovXG4gICAgUGF0aC5leHRlbmQgPSBmdW5jdGlvbiAoZGVmYXVsdHMpIHtcbiAgICAgICAgdmFyIFN1YiA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgICAgICAgICBQYXRoLmNhbGwodGhpcywgb3B0cyk7XG5cbiAgICAgICAgICAgIGlmIChkZWZhdWx0cy5zdHlsZSkge1xuICAgICAgICAgICAgICAgIC8vIEV4dGVuZCBkZWZhdWx0IHN0eWxlXG4gICAgICAgICAgICAgICAgdGhpcy5zdHlsZS5leHRlbmRGcm9tKGRlZmF1bHRzLnN0eWxlLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEV4dGVuZCBkZWZhdWx0IHNoYXBlXG4gICAgICAgICAgICB2YXIgZGVmYXVsdFNoYXBlID0gZGVmYXVsdHMuc2hhcGU7XG4gICAgICAgICAgICBpZiAoZGVmYXVsdFNoYXBlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zaGFwZSA9IHRoaXMuc2hhcGUgfHwge307XG4gICAgICAgICAgICAgICAgdmFyIHRoaXNTaGFwZSA9IHRoaXMuc2hhcGU7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBkZWZhdWx0U2hhcGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgISB0aGlzU2hhcGUuaGFzT3duUHJvcGVydHkobmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIGRlZmF1bHRTaGFwZS5oYXNPd25Qcm9wZXJ0eShuYW1lKVxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNTaGFwZVtuYW1lXSA9IGRlZmF1bHRTaGFwZVtuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGVmYXVsdHMuaW5pdCAmJiBkZWZhdWx0cy5pbml0LmNhbGwodGhpcywgb3B0cyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgenJVdGlsLmluaGVyaXRzKFN1YiwgUGF0aCk7XG5cbiAgICAgICAgLy8gRklYTUUg5LiN6IO9IGV4dGVuZCBwb3NpdGlvbiwgcm90YXRpb24g562J5byV55So5a+56LGhXG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gZGVmYXVsdHMpIHtcbiAgICAgICAgICAgIC8vIEV4dGVuZGluZyBwcm90b3R5cGUgdmFsdWVzIGFuZCBtZXRob2RzXG4gICAgICAgICAgICBpZiAobmFtZSAhPT0gJ3N0eWxlJyAmJiBuYW1lICE9PSAnc2hhcGUnKSB7XG4gICAgICAgICAgICAgICAgU3ViLnByb3RvdHlwZVtuYW1lXSA9IGRlZmF1bHRzW25hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFN1YjtcbiAgICB9O1xuXG4gICAgenJVdGlsLmluaGVyaXRzKFBhdGgsIERpc3BsYXlhYmxlKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gUGF0aDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9ob21lL3l4L34venJlbmRlci9saWIvZ3JhcGhpYy9QYXRoLmpzXG4vLyBtb2R1bGUgaWQgPSA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 8 */
/* unknown exports provided */
/* all exports used */
/*!******************************************!*\
  !*** /home/yx/~/zrender/lib/core/env.js ***!
  \******************************************/
/***/ (function(module, exports) {

eval("/**\n * echarts设备环境识别\n *\n * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。\n * @author firede[firede@firede.us]\n * @desc thanks zepto.\n */\n\n    var env = {};\n    if (typeof navigator === 'undefined') {\n        // In node\n        env = {\n            browser: {},\n            os: {},\n            node: true,\n            // Assume canvas is supported\n            canvasSupported: true\n        };\n    }\n    else {\n        env = detect(navigator.userAgent);\n    }\n\n    module.exports = env;\n\n    // Zepto.js\n    // (c) 2010-2013 Thomas Fuchs\n    // Zepto.js may be freely distributed under the MIT license.\n\n    function detect(ua) {\n        var os = {};\n        var browser = {};\n        // var webkit = ua.match(/Web[kK]it[\\/]{0,1}([\\d.]+)/);\n        // var android = ua.match(/(Android);?[\\s\\/]+([\\d.]+)?/);\n        // var ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/);\n        // var ipod = ua.match(/(iPod)(.*OS\\s([\\d_]+))?/);\n        // var iphone = !ipad && ua.match(/(iPhone\\sOS)\\s([\\d_]+)/);\n        // var webos = ua.match(/(webOS|hpwOS)[\\s\\/]([\\d.]+)/);\n        // var touchpad = webos && ua.match(/TouchPad/);\n        // var kindle = ua.match(/Kindle\\/([\\d.]+)/);\n        // var silk = ua.match(/Silk\\/([\\d._]+)/);\n        // var blackberry = ua.match(/(BlackBerry).*Version\\/([\\d.]+)/);\n        // var bb10 = ua.match(/(BB10).*Version\\/([\\d.]+)/);\n        // var rimtabletos = ua.match(/(RIM\\sTablet\\sOS)\\s([\\d.]+)/);\n        // var playbook = ua.match(/PlayBook/);\n        // var chrome = ua.match(/Chrome\\/([\\d.]+)/) || ua.match(/CriOS\\/([\\d.]+)/);\n        var firefox = ua.match(/Firefox\\/([\\d.]+)/);\n        // var safari = webkit && ua.match(/Mobile\\//) && !chrome;\n        // var webview = ua.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) && !chrome;\n        var ie = ua.match(/MSIE\\s([\\d.]+)/)\n            // IE 11 Trident/7.0; rv:11.0\n            || ua.match(/Trident\\/.+?rv:(([\\d.]+))/);\n        var edge = ua.match(/Edge\\/([\\d.]+)/); // IE 12 and 12+\n\n        var weChat = (/micromessenger/i).test(ua);\n\n        // Todo: clean this up with a better OS/browser seperation:\n        // - discern (more) between multiple browsers on android\n        // - decide if kindle fire in silk mode is android or not\n        // - Firefox on Android doesn't specify the Android version\n        // - possibly devide in os, device and browser hashes\n\n        // if (browser.webkit = !!webkit) browser.version = webkit[1];\n\n        // if (android) os.android = true, os.version = android[2];\n        // if (iphone && !ipod) os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.');\n        // if (ipad) os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.');\n        // if (ipod) os.ios = os.ipod = true, os.version = ipod[3] ? ipod[3].replace(/_/g, '.') : null;\n        // if (webos) os.webos = true, os.version = webos[2];\n        // if (touchpad) os.touchpad = true;\n        // if (blackberry) os.blackberry = true, os.version = blackberry[2];\n        // if (bb10) os.bb10 = true, os.version = bb10[2];\n        // if (rimtabletos) os.rimtabletos = true, os.version = rimtabletos[2];\n        // if (playbook) browser.playbook = true;\n        // if (kindle) os.kindle = true, os.version = kindle[1];\n        // if (silk) browser.silk = true, browser.version = silk[1];\n        // if (!silk && os.android && ua.match(/Kindle Fire/)) browser.silk = true;\n        // if (chrome) browser.chrome = true, browser.version = chrome[1];\n        if (firefox) {\n            browser.firefox = true;\n            browser.version = firefox[1];\n        }\n        // if (safari && (ua.match(/Safari/) || !!os.ios)) browser.safari = true;\n        // if (webview) browser.webview = true;\n\n        if (ie) {\n            browser.ie = true;\n            browser.version = ie[1];\n        }\n\n        if (edge) {\n            browser.edge = true;\n            browser.version = edge[1];\n        }\n\n        // It is difficult to detect WeChat in Win Phone precisely, because ua can\n        // not be set on win phone. So we do not consider Win Phone.\n        if (weChat) {\n            browser.weChat = true;\n        }\n\n        // os.tablet = !!(ipad || playbook || (android && !ua.match(/Mobile/)) ||\n        //     (firefox && ua.match(/Tablet/)) || (ie && !ua.match(/Phone/) && ua.match(/Touch/)));\n        // os.phone  = !!(!os.tablet && !os.ipod && (android || iphone || webos ||\n        //     (chrome && ua.match(/Android/)) || (chrome && ua.match(/CriOS\\/([\\d.]+)/)) ||\n        //     (firefox && ua.match(/Mobile/)) || (ie && ua.match(/Touch/))));\n\n        return {\n            browser: browser,\n            os: os,\n            node: false,\n            // 原生canvas支持，改极端点了\n            // canvasSupported : !(browser.ie && parseFloat(browser.version) < 9)\n            canvasSupported : document.createElement('canvas').getContext ? true : false,\n            // @see <http://stackoverflow.com/questions/4817029/whats-the-best-way-to-detect-a-touch-screen-device-using-javascript>\n            // works on most browsers\n            // IE10/11 does not support touch event, and MS Edge supports them but not by\n            // default, so we dont check navigator.maxTouchPoints for them here.\n            touchEventsSupported: 'ontouchstart' in window && !browser.ie && !browser.edge,\n            // <http://caniuse.com/#search=pointer%20event>.\n            pointerEventsSupported: 'onpointerdown' in window\n                // Firefox supports pointer but not by default, only MS browsers are reliable on pointer\n                // events currently. So we dont use that on other browsers unless tested sufficiently.\n                // Although IE 10 supports pointer event, it use old style and is different from the\n                // standard. So we exclude that. (IE 10 is hardly used on touch device)\n                && (browser.edge || (browser.ie && browser.version >= 11))\n        };\n    }\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vaG9tZS95eC9+L3pyZW5kZXIvbGliL2NvcmUvZW52LmpzPzgyZDYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBlY2hhcnRz6K6+5aSH546v5aKD6K+G5YirXG4gKlxuICogQGRlc2MgZWNoYXJ0c+WfuuS6jkNhbnZhc++8jOe6r0phdmFzY3JpcHTlm77ooajlupPvvIzmj5Dkvpvnm7Top4LvvIznlJ/liqjvvIzlj6/kuqTkupLvvIzlj6/kuKrmgKfljJblrprliLbnmoTmlbDmja7nu5/orqHlm77ooajjgIJcbiAqIEBhdXRob3IgZmlyZWRlW2ZpcmVkZUBmaXJlZGUudXNdXG4gKiBAZGVzYyB0aGFua3MgemVwdG8uXG4gKi9cblxuICAgIHZhciBlbnYgPSB7fTtcbiAgICBpZiAodHlwZW9mIG5hdmlnYXRvciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLy8gSW4gbm9kZVxuICAgICAgICBlbnYgPSB7XG4gICAgICAgICAgICBicm93c2VyOiB7fSxcbiAgICAgICAgICAgIG9zOiB7fSxcbiAgICAgICAgICAgIG5vZGU6IHRydWUsXG4gICAgICAgICAgICAvLyBBc3N1bWUgY2FudmFzIGlzIHN1cHBvcnRlZFxuICAgICAgICAgICAgY2FudmFzU3VwcG9ydGVkOiB0cnVlXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBlbnYgPSBkZXRlY3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBlbnY7XG5cbiAgICAvLyBaZXB0by5qc1xuICAgIC8vIChjKSAyMDEwLTIwMTMgVGhvbWFzIEZ1Y2hzXG4gICAgLy8gWmVwdG8uanMgbWF5IGJlIGZyZWVseSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG5cbiAgICBmdW5jdGlvbiBkZXRlY3QodWEpIHtcbiAgICAgICAgdmFyIG9zID0ge307XG4gICAgICAgIHZhciBicm93c2VyID0ge307XG4gICAgICAgIC8vIHZhciB3ZWJraXQgPSB1YS5tYXRjaCgvV2ViW2tLXWl0W1xcL117MCwxfShbXFxkLl0rKS8pO1xuICAgICAgICAvLyB2YXIgYW5kcm9pZCA9IHVhLm1hdGNoKC8oQW5kcm9pZCk7P1tcXHNcXC9dKyhbXFxkLl0rKT8vKTtcbiAgICAgICAgLy8gdmFyIGlwYWQgPSB1YS5tYXRjaCgvKGlQYWQpLipPU1xccyhbXFxkX10rKS8pO1xuICAgICAgICAvLyB2YXIgaXBvZCA9IHVhLm1hdGNoKC8oaVBvZCkoLipPU1xccyhbXFxkX10rKSk/Lyk7XG4gICAgICAgIC8vIHZhciBpcGhvbmUgPSAhaXBhZCAmJiB1YS5tYXRjaCgvKGlQaG9uZVxcc09TKVxccyhbXFxkX10rKS8pO1xuICAgICAgICAvLyB2YXIgd2Vib3MgPSB1YS5tYXRjaCgvKHdlYk9TfGhwd09TKVtcXHNcXC9dKFtcXGQuXSspLyk7XG4gICAgICAgIC8vIHZhciB0b3VjaHBhZCA9IHdlYm9zICYmIHVhLm1hdGNoKC9Ub3VjaFBhZC8pO1xuICAgICAgICAvLyB2YXIga2luZGxlID0gdWEubWF0Y2goL0tpbmRsZVxcLyhbXFxkLl0rKS8pO1xuICAgICAgICAvLyB2YXIgc2lsayA9IHVhLm1hdGNoKC9TaWxrXFwvKFtcXGQuX10rKS8pO1xuICAgICAgICAvLyB2YXIgYmxhY2tiZXJyeSA9IHVhLm1hdGNoKC8oQmxhY2tCZXJyeSkuKlZlcnNpb25cXC8oW1xcZC5dKykvKTtcbiAgICAgICAgLy8gdmFyIGJiMTAgPSB1YS5tYXRjaCgvKEJCMTApLipWZXJzaW9uXFwvKFtcXGQuXSspLyk7XG4gICAgICAgIC8vIHZhciByaW10YWJsZXRvcyA9IHVhLm1hdGNoKC8oUklNXFxzVGFibGV0XFxzT1MpXFxzKFtcXGQuXSspLyk7XG4gICAgICAgIC8vIHZhciBwbGF5Ym9vayA9IHVhLm1hdGNoKC9QbGF5Qm9vay8pO1xuICAgICAgICAvLyB2YXIgY2hyb21lID0gdWEubWF0Y2goL0Nocm9tZVxcLyhbXFxkLl0rKS8pIHx8IHVhLm1hdGNoKC9DcmlPU1xcLyhbXFxkLl0rKS8pO1xuICAgICAgICB2YXIgZmlyZWZveCA9IHVhLm1hdGNoKC9GaXJlZm94XFwvKFtcXGQuXSspLyk7XG4gICAgICAgIC8vIHZhciBzYWZhcmkgPSB3ZWJraXQgJiYgdWEubWF0Y2goL01vYmlsZVxcLy8pICYmICFjaHJvbWU7XG4gICAgICAgIC8vIHZhciB3ZWJ2aWV3ID0gdWEubWF0Y2goLyhpUGhvbmV8aVBvZHxpUGFkKS4qQXBwbGVXZWJLaXQoPyEuKlNhZmFyaSkvKSAmJiAhY2hyb21lO1xuICAgICAgICB2YXIgaWUgPSB1YS5tYXRjaCgvTVNJRVxccyhbXFxkLl0rKS8pXG4gICAgICAgICAgICAvLyBJRSAxMSBUcmlkZW50LzcuMDsgcnY6MTEuMFxuICAgICAgICAgICAgfHwgdWEubWF0Y2goL1RyaWRlbnRcXC8uKz9ydjooKFtcXGQuXSspKS8pO1xuICAgICAgICB2YXIgZWRnZSA9IHVhLm1hdGNoKC9FZGdlXFwvKFtcXGQuXSspLyk7IC8vIElFIDEyIGFuZCAxMitcblxuICAgICAgICB2YXIgd2VDaGF0ID0gKC9taWNyb21lc3Nlbmdlci9pKS50ZXN0KHVhKTtcblxuICAgICAgICAvLyBUb2RvOiBjbGVhbiB0aGlzIHVwIHdpdGggYSBiZXR0ZXIgT1MvYnJvd3NlciBzZXBlcmF0aW9uOlxuICAgICAgICAvLyAtIGRpc2Nlcm4gKG1vcmUpIGJldHdlZW4gbXVsdGlwbGUgYnJvd3NlcnMgb24gYW5kcm9pZFxuICAgICAgICAvLyAtIGRlY2lkZSBpZiBraW5kbGUgZmlyZSBpbiBzaWxrIG1vZGUgaXMgYW5kcm9pZCBvciBub3RcbiAgICAgICAgLy8gLSBGaXJlZm94IG9uIEFuZHJvaWQgZG9lc24ndCBzcGVjaWZ5IHRoZSBBbmRyb2lkIHZlcnNpb25cbiAgICAgICAgLy8gLSBwb3NzaWJseSBkZXZpZGUgaW4gb3MsIGRldmljZSBhbmQgYnJvd3NlciBoYXNoZXNcblxuICAgICAgICAvLyBpZiAoYnJvd3Nlci53ZWJraXQgPSAhIXdlYmtpdCkgYnJvd3Nlci52ZXJzaW9uID0gd2Via2l0WzFdO1xuXG4gICAgICAgIC8vIGlmIChhbmRyb2lkKSBvcy5hbmRyb2lkID0gdHJ1ZSwgb3MudmVyc2lvbiA9IGFuZHJvaWRbMl07XG4gICAgICAgIC8vIGlmIChpcGhvbmUgJiYgIWlwb2QpIG9zLmlvcyA9IG9zLmlwaG9uZSA9IHRydWUsIG9zLnZlcnNpb24gPSBpcGhvbmVbMl0ucmVwbGFjZSgvXy9nLCAnLicpO1xuICAgICAgICAvLyBpZiAoaXBhZCkgb3MuaW9zID0gb3MuaXBhZCA9IHRydWUsIG9zLnZlcnNpb24gPSBpcGFkWzJdLnJlcGxhY2UoL18vZywgJy4nKTtcbiAgICAgICAgLy8gaWYgKGlwb2QpIG9zLmlvcyA9IG9zLmlwb2QgPSB0cnVlLCBvcy52ZXJzaW9uID0gaXBvZFszXSA/IGlwb2RbM10ucmVwbGFjZSgvXy9nLCAnLicpIDogbnVsbDtcbiAgICAgICAgLy8gaWYgKHdlYm9zKSBvcy53ZWJvcyA9IHRydWUsIG9zLnZlcnNpb24gPSB3ZWJvc1syXTtcbiAgICAgICAgLy8gaWYgKHRvdWNocGFkKSBvcy50b3VjaHBhZCA9IHRydWU7XG4gICAgICAgIC8vIGlmIChibGFja2JlcnJ5KSBvcy5ibGFja2JlcnJ5ID0gdHJ1ZSwgb3MudmVyc2lvbiA9IGJsYWNrYmVycnlbMl07XG4gICAgICAgIC8vIGlmIChiYjEwKSBvcy5iYjEwID0gdHJ1ZSwgb3MudmVyc2lvbiA9IGJiMTBbMl07XG4gICAgICAgIC8vIGlmIChyaW10YWJsZXRvcykgb3MucmltdGFibGV0b3MgPSB0cnVlLCBvcy52ZXJzaW9uID0gcmltdGFibGV0b3NbMl07XG4gICAgICAgIC8vIGlmIChwbGF5Ym9vaykgYnJvd3Nlci5wbGF5Ym9vayA9IHRydWU7XG4gICAgICAgIC8vIGlmIChraW5kbGUpIG9zLmtpbmRsZSA9IHRydWUsIG9zLnZlcnNpb24gPSBraW5kbGVbMV07XG4gICAgICAgIC8vIGlmIChzaWxrKSBicm93c2VyLnNpbGsgPSB0cnVlLCBicm93c2VyLnZlcnNpb24gPSBzaWxrWzFdO1xuICAgICAgICAvLyBpZiAoIXNpbGsgJiYgb3MuYW5kcm9pZCAmJiB1YS5tYXRjaCgvS2luZGxlIEZpcmUvKSkgYnJvd3Nlci5zaWxrID0gdHJ1ZTtcbiAgICAgICAgLy8gaWYgKGNocm9tZSkgYnJvd3Nlci5jaHJvbWUgPSB0cnVlLCBicm93c2VyLnZlcnNpb24gPSBjaHJvbWVbMV07XG4gICAgICAgIGlmIChmaXJlZm94KSB7XG4gICAgICAgICAgICBicm93c2VyLmZpcmVmb3ggPSB0cnVlO1xuICAgICAgICAgICAgYnJvd3Nlci52ZXJzaW9uID0gZmlyZWZveFsxXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiAoc2FmYXJpICYmICh1YS5tYXRjaCgvU2FmYXJpLykgfHwgISFvcy5pb3MpKSBicm93c2VyLnNhZmFyaSA9IHRydWU7XG4gICAgICAgIC8vIGlmICh3ZWJ2aWV3KSBicm93c2VyLndlYnZpZXcgPSB0cnVlO1xuXG4gICAgICAgIGlmIChpZSkge1xuICAgICAgICAgICAgYnJvd3Nlci5pZSA9IHRydWU7XG4gICAgICAgICAgICBicm93c2VyLnZlcnNpb24gPSBpZVsxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlZGdlKSB7XG4gICAgICAgICAgICBicm93c2VyLmVkZ2UgPSB0cnVlO1xuICAgICAgICAgICAgYnJvd3Nlci52ZXJzaW9uID0gZWRnZVsxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEl0IGlzIGRpZmZpY3VsdCB0byBkZXRlY3QgV2VDaGF0IGluIFdpbiBQaG9uZSBwcmVjaXNlbHksIGJlY2F1c2UgdWEgY2FuXG4gICAgICAgIC8vIG5vdCBiZSBzZXQgb24gd2luIHBob25lLiBTbyB3ZSBkbyBub3QgY29uc2lkZXIgV2luIFBob25lLlxuICAgICAgICBpZiAod2VDaGF0KSB7XG4gICAgICAgICAgICBicm93c2VyLndlQ2hhdCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBvcy50YWJsZXQgPSAhIShpcGFkIHx8IHBsYXlib29rIHx8IChhbmRyb2lkICYmICF1YS5tYXRjaCgvTW9iaWxlLykpIHx8XG4gICAgICAgIC8vICAgICAoZmlyZWZveCAmJiB1YS5tYXRjaCgvVGFibGV0LykpIHx8IChpZSAmJiAhdWEubWF0Y2goL1Bob25lLykgJiYgdWEubWF0Y2goL1RvdWNoLykpKTtcbiAgICAgICAgLy8gb3MucGhvbmUgID0gISEoIW9zLnRhYmxldCAmJiAhb3MuaXBvZCAmJiAoYW5kcm9pZCB8fCBpcGhvbmUgfHwgd2Vib3MgfHxcbiAgICAgICAgLy8gICAgIChjaHJvbWUgJiYgdWEubWF0Y2goL0FuZHJvaWQvKSkgfHwgKGNocm9tZSAmJiB1YS5tYXRjaCgvQ3JpT1NcXC8oW1xcZC5dKykvKSkgfHxcbiAgICAgICAgLy8gICAgIChmaXJlZm94ICYmIHVhLm1hdGNoKC9Nb2JpbGUvKSkgfHwgKGllICYmIHVhLm1hdGNoKC9Ub3VjaC8pKSkpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBicm93c2VyOiBicm93c2VyLFxuICAgICAgICAgICAgb3M6IG9zLFxuICAgICAgICAgICAgbm9kZTogZmFsc2UsXG4gICAgICAgICAgICAvLyDljp/nlJ9jYW52YXPmlK/mjIHvvIzmlLnmnoHnq6/ngrnkuoZcbiAgICAgICAgICAgIC8vIGNhbnZhc1N1cHBvcnRlZCA6ICEoYnJvd3Nlci5pZSAmJiBwYXJzZUZsb2F0KGJyb3dzZXIudmVyc2lvbikgPCA5KVxuICAgICAgICAgICAgY2FudmFzU3VwcG9ydGVkIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJykuZ2V0Q29udGV4dCA/IHRydWUgOiBmYWxzZSxcbiAgICAgICAgICAgIC8vIEBzZWUgPGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDgxNzAyOS93aGF0cy10aGUtYmVzdC13YXktdG8tZGV0ZWN0LWEtdG91Y2gtc2NyZWVuLWRldmljZS11c2luZy1qYXZhc2NyaXB0PlxuICAgICAgICAgICAgLy8gd29ya3Mgb24gbW9zdCBicm93c2Vyc1xuICAgICAgICAgICAgLy8gSUUxMC8xMSBkb2VzIG5vdCBzdXBwb3J0IHRvdWNoIGV2ZW50LCBhbmQgTVMgRWRnZSBzdXBwb3J0cyB0aGVtIGJ1dCBub3QgYnlcbiAgICAgICAgICAgIC8vIGRlZmF1bHQsIHNvIHdlIGRvbnQgY2hlY2sgbmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzIGZvciB0aGVtIGhlcmUuXG4gICAgICAgICAgICB0b3VjaEV2ZW50c1N1cHBvcnRlZDogJ29udG91Y2hzdGFydCcgaW4gd2luZG93ICYmICFicm93c2VyLmllICYmICFicm93c2VyLmVkZ2UsXG4gICAgICAgICAgICAvLyA8aHR0cDovL2Nhbml1c2UuY29tLyNzZWFyY2g9cG9pbnRlciUyMGV2ZW50Pi5cbiAgICAgICAgICAgIHBvaW50ZXJFdmVudHNTdXBwb3J0ZWQ6ICdvbnBvaW50ZXJkb3duJyBpbiB3aW5kb3dcbiAgICAgICAgICAgICAgICAvLyBGaXJlZm94IHN1cHBvcnRzIHBvaW50ZXIgYnV0IG5vdCBieSBkZWZhdWx0LCBvbmx5IE1TIGJyb3dzZXJzIGFyZSByZWxpYWJsZSBvbiBwb2ludGVyXG4gICAgICAgICAgICAgICAgLy8gZXZlbnRzIGN1cnJlbnRseS4gU28gd2UgZG9udCB1c2UgdGhhdCBvbiBvdGhlciBicm93c2VycyB1bmxlc3MgdGVzdGVkIHN1ZmZpY2llbnRseS5cbiAgICAgICAgICAgICAgICAvLyBBbHRob3VnaCBJRSAxMCBzdXBwb3J0cyBwb2ludGVyIGV2ZW50LCBpdCB1c2Ugb2xkIHN0eWxlIGFuZCBpcyBkaWZmZXJlbnQgZnJvbSB0aGVcbiAgICAgICAgICAgICAgICAvLyBzdGFuZGFyZC4gU28gd2UgZXhjbHVkZSB0aGF0LiAoSUUgMTAgaXMgaGFyZGx5IHVzZWQgb24gdG91Y2ggZGV2aWNlKVxuICAgICAgICAgICAgICAgICYmIChicm93c2VyLmVkZ2UgfHwgKGJyb3dzZXIuaWUgJiYgYnJvd3Nlci52ZXJzaW9uID49IDExKSlcbiAgICAgICAgfTtcbiAgICB9XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS95eC9+L3pyZW5kZXIvbGliL2NvcmUvZW52LmpzXG4vLyBtb2R1bGUgaWQgPSA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 9 */
/* unknown exports provided */
/* all exports used */
/*!****************************!*\
  !*** ./lib/model/Model.js ***!
  \****************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * @module echarts/model/Model\n */\n\n\n    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 0);\n    var clazzUtil = __webpack_require__(/*! ../util/clazz */ 14);\n    var env = __webpack_require__(/*! zrender/lib/core/env */ 8);\n\n    /**\n     * @alias module:echarts/model/Model\n     * @constructor\n     * @param {Object} option\n     * @param {module:echarts/model/Model} [parentModel]\n     * @param {module:echarts/model/Global} [ecModel]\n     */\n    function Model(option, parentModel, ecModel) {\n        /**\n         * @type {module:echarts/model/Model}\n         * @readOnly\n         */\n        this.parentModel = parentModel;\n\n        /**\n         * @type {module:echarts/model/Global}\n         * @readOnly\n         */\n        this.ecModel = ecModel;\n\n        /**\n         * @type {Object}\n         * @protected\n         */\n        this.option = option;\n\n        // Simple optimization\n        // if (this.init) {\n        //     if (arguments.length <= 4) {\n        //         this.init(option, parentModel, ecModel, extraOpt);\n        //     }\n        //     else {\n        //         this.init.apply(this, arguments);\n        //     }\n        // }\n    }\n\n    Model.prototype = {\n\n        constructor: Model,\n\n        /**\n         * Model 的初始化函数\n         * @param {Object} option\n         */\n        init: null,\n\n        /**\n         * 从新的 Option merge\n         */\n        mergeOption: function (option) {\n            zrUtil.merge(this.option, option, true);\n        },\n\n        /**\n         * @param {string|Array.<string>} path\n         * @param {boolean} [ignoreParent=false]\n         * @return {*}\n         */\n        get: function (path, ignoreParent) {\n            if (path == null) {\n                return this.option;\n            }\n\n            return doGet(\n                this.option,\n                this.parsePath(path),\n                !ignoreParent && getParent(this, path)\n            );\n        },\n\n        /**\n         * @param {string} key\n         * @param {boolean} [ignoreParent=false]\n         * @return {*}\n         */\n        getShallow: function (key, ignoreParent) {\n            var option = this.option;\n\n            var val = option == null ? option : option[key];\n            var parentModel = !ignoreParent && getParent(this, key);\n            if (val == null && parentModel) {\n                val = parentModel.getShallow(key);\n            }\n            return val;\n        },\n\n        /**\n         * @param {string|Array.<string>} path\n         * @param {module:echarts/model/Model} [parentModel]\n         * @return {module:echarts/model/Model}\n         */\n        getModel: function (path, parentModel) {\n            var obj = path == null\n                ? this.option\n                : doGet(this.option, path = this.parsePath(path));\n\n            var thisParentModel;\n            parentModel = parentModel || (\n                (thisParentModel = getParent(this, path))\n                    && thisParentModel.getModel(path)\n            );\n\n            return new Model(obj, parentModel, this.ecModel);\n        },\n\n        /**\n         * If model has option\n         */\n        isEmpty: function () {\n            return this.option == null;\n        },\n\n        restoreData: function () {},\n\n        // Pending\n        clone: function () {\n            var Ctor = this.constructor;\n            return new Ctor(zrUtil.clone(this.option));\n        },\n\n        setReadOnly: function (properties) {\n            clazzUtil.setReadOnly(this, properties);\n        },\n\n        // If path is null/undefined, return null/undefined.\n        parsePath: function(path) {\n            if (typeof path === 'string') {\n                path = path.split('.');\n            }\n            return path;\n        },\n\n        /**\n         * @param {Function} getParentMethod\n         *        param {Array.<string>|string} path\n         *        return {module:echarts/model/Model}\n         */\n        customizeGetParent: function (getParentMethod) {\n            clazzUtil.set(this, 'getParent', getParentMethod);\n        },\n\n        isAnimationEnabled: function () {\n            if (!env.node) {\n                if (this.option.animation != null) {\n                    return !!this.option.animation;\n                }\n                else if (this.parentModel) {\n                    return this.parentModel.isAnimationEnabled();\n                }\n            }\n        }\n    };\n\n    function doGet(obj, pathArr, parentModel) {\n        for (var i = 0; i < pathArr.length; i++) {\n            // Ignore empty\n            if (!pathArr[i]) {\n                continue;\n            }\n            // obj could be number/string/... (like 0)\n            obj = (obj && typeof obj === 'object') ? obj[pathArr[i]] : null;\n            if (obj == null) {\n                break;\n            }\n        }\n        if (obj == null && parentModel) {\n            obj = parentModel.get(pathArr);\n        }\n        return obj;\n    }\n\n    function getParent(model, path) {\n        var getParentMethod = clazzUtil.get(model, 'getParent');\n        return getParentMethod ? getParentMethod.call(model, path) : model.parentModel;\n    }\n\n    // Enable Model.extend.\n    clazzUtil.enableClassExtend(Model);\n\n    var mixin = zrUtil.mixin;\n    mixin(Model, __webpack_require__(/*! ./mixin/lineStyle */ 173));\n    mixin(Model, __webpack_require__(/*! ./mixin/areaStyle */ 170));\n    mixin(Model, __webpack_require__(/*! ./mixin/textStyle */ 174));\n    mixin(Model, __webpack_require__(/*! ./mixin/itemStyle */ 172));\n\n    module.exports = Model;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2xpYi9tb2RlbC9Nb2RlbC5qcz9jMjRiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQG1vZHVsZSBlY2hhcnRzL21vZGVsL01vZGVsXG4gKi9cblxuXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuICAgIHZhciBjbGF6elV0aWwgPSByZXF1aXJlKCcuLi91dGlsL2NsYXp6Jyk7XG4gICAgdmFyIGVudiA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvZW52Jyk7XG5cbiAgICAvKipcbiAgICAgKiBAYWxpYXMgbW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWxcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uXG4gICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH0gW3BhcmVudE1vZGVsXVxuICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvR2xvYmFsfSBbZWNNb2RlbF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNb2RlbChvcHRpb24sIHBhcmVudE1vZGVsLCBlY01vZGVsKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWx9XG4gICAgICAgICAqIEByZWFkT25seVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wYXJlbnRNb2RlbCA9IHBhcmVudE1vZGVsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvR2xvYmFsfVxuICAgICAgICAgKiBAcmVhZE9ubHlcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZWNNb2RlbCA9IGVjTW9kZWw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub3B0aW9uID0gb3B0aW9uO1xuXG4gICAgICAgIC8vIFNpbXBsZSBvcHRpbWl6YXRpb25cbiAgICAgICAgLy8gaWYgKHRoaXMuaW5pdCkge1xuICAgICAgICAvLyAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPD0gNCkge1xuICAgICAgICAvLyAgICAgICAgIHRoaXMuaW5pdChvcHRpb24sIHBhcmVudE1vZGVsLCBlY01vZGVsLCBleHRyYU9wdCk7XG4gICAgICAgIC8vICAgICB9XG4gICAgICAgIC8vICAgICBlbHNlIHtcbiAgICAgICAgLy8gICAgICAgICB0aGlzLmluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgLy8gICAgIH1cbiAgICAgICAgLy8gfVxuICAgIH1cblxuICAgIE1vZGVsLnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogTW9kZWwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1vZGVsIOeahOWIneWni+WMluWHveaVsFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBpbml0OiBudWxsLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDku47mlrDnmoQgT3B0aW9uIG1lcmdlXG4gICAgICAgICAqL1xuICAgICAgICBtZXJnZU9wdGlvbjogZnVuY3Rpb24gKG9wdGlvbikge1xuICAgICAgICAgICAgenJVdGlsLm1lcmdlKHRoaXMub3B0aW9uLCBvcHRpb24sIHRydWUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ3xBcnJheS48c3RyaW5nPn0gcGF0aFxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpZ25vcmVQYXJlbnQ9ZmFsc2VdXG4gICAgICAgICAqIEByZXR1cm4geyp9XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIChwYXRoLCBpZ25vcmVQYXJlbnQpIHtcbiAgICAgICAgICAgIGlmIChwYXRoID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb247XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBkb0dldChcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbixcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnNlUGF0aChwYXRoKSxcbiAgICAgICAgICAgICAgICAhaWdub3JlUGFyZW50ICYmIGdldFBhcmVudCh0aGlzLCBwYXRoKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpZ25vcmVQYXJlbnQ9ZmFsc2VdXG4gICAgICAgICAqIEByZXR1cm4geyp9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRTaGFsbG93OiBmdW5jdGlvbiAoa2V5LCBpZ25vcmVQYXJlbnQpIHtcbiAgICAgICAgICAgIHZhciBvcHRpb24gPSB0aGlzLm9wdGlvbjtcblxuICAgICAgICAgICAgdmFyIHZhbCA9IG9wdGlvbiA9PSBudWxsID8gb3B0aW9uIDogb3B0aW9uW2tleV07XG4gICAgICAgICAgICB2YXIgcGFyZW50TW9kZWwgPSAhaWdub3JlUGFyZW50ICYmIGdldFBhcmVudCh0aGlzLCBrZXkpO1xuICAgICAgICAgICAgaWYgKHZhbCA9PSBudWxsICYmIHBhcmVudE1vZGVsKSB7XG4gICAgICAgICAgICAgICAgdmFsID0gcGFyZW50TW9kZWwuZ2V0U2hhbGxvdyhrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd8QXJyYXkuPHN0cmluZz59IHBhdGhcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH0gW3BhcmVudE1vZGVsXVxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH1cbiAgICAgICAgICovXG4gICAgICAgIGdldE1vZGVsOiBmdW5jdGlvbiAocGF0aCwgcGFyZW50TW9kZWwpIHtcbiAgICAgICAgICAgIHZhciBvYmogPSBwYXRoID09IG51bGxcbiAgICAgICAgICAgICAgICA/IHRoaXMub3B0aW9uXG4gICAgICAgICAgICAgICAgOiBkb0dldCh0aGlzLm9wdGlvbiwgcGF0aCA9IHRoaXMucGFyc2VQYXRoKHBhdGgpKTtcblxuICAgICAgICAgICAgdmFyIHRoaXNQYXJlbnRNb2RlbDtcbiAgICAgICAgICAgIHBhcmVudE1vZGVsID0gcGFyZW50TW9kZWwgfHwgKFxuICAgICAgICAgICAgICAgICh0aGlzUGFyZW50TW9kZWwgPSBnZXRQYXJlbnQodGhpcywgcGF0aCkpXG4gICAgICAgICAgICAgICAgICAgICYmIHRoaXNQYXJlbnRNb2RlbC5nZXRNb2RlbChwYXRoKVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgcmV0dXJuIG5ldyBNb2RlbChvYmosIHBhcmVudE1vZGVsLCB0aGlzLmVjTW9kZWwpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBtb2RlbCBoYXMgb3B0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBpc0VtcHR5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb24gPT0gbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICByZXN0b3JlRGF0YTogZnVuY3Rpb24gKCkge30sXG5cbiAgICAgICAgLy8gUGVuZGluZ1xuICAgICAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIEN0b3IgPSB0aGlzLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDdG9yKHpyVXRpbC5jbG9uZSh0aGlzLm9wdGlvbikpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldFJlYWRPbmx5OiBmdW5jdGlvbiAocHJvcGVydGllcykge1xuICAgICAgICAgICAgY2xhenpVdGlsLnNldFJlYWRPbmx5KHRoaXMsIHByb3BlcnRpZXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIElmIHBhdGggaXMgbnVsbC91bmRlZmluZWQsIHJldHVybiBudWxsL3VuZGVmaW5lZC5cbiAgICAgICAgcGFyc2VQYXRoOiBmdW5jdGlvbihwYXRoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcGF0aCA9IHBhdGguc3BsaXQoJy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBnZXRQYXJlbnRNZXRob2RcbiAgICAgICAgICogICAgICAgIHBhcmFtIHtBcnJheS48c3RyaW5nPnxzdHJpbmd9IHBhdGhcbiAgICAgICAgICogICAgICAgIHJldHVybiB7bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWx9XG4gICAgICAgICAqL1xuICAgICAgICBjdXN0b21pemVHZXRQYXJlbnQ6IGZ1bmN0aW9uIChnZXRQYXJlbnRNZXRob2QpIHtcbiAgICAgICAgICAgIGNsYXp6VXRpbC5zZXQodGhpcywgJ2dldFBhcmVudCcsIGdldFBhcmVudE1ldGhvZCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNBbmltYXRpb25FbmFibGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIWVudi5ub2RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9uLmFuaW1hdGlvbiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhIXRoaXMub3B0aW9uLmFuaW1hdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5wYXJlbnRNb2RlbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnRNb2RlbC5pc0FuaW1hdGlvbkVuYWJsZWQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZG9HZXQob2JqLCBwYXRoQXJyLCBwYXJlbnRNb2RlbCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGhBcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIC8vIElnbm9yZSBlbXB0eVxuICAgICAgICAgICAgaWYgKCFwYXRoQXJyW2ldKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBvYmogY291bGQgYmUgbnVtYmVyL3N0cmluZy8uLi4gKGxpa2UgMClcbiAgICAgICAgICAgIG9iaiA9IChvYmogJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpID8gb2JqW3BhdGhBcnJbaV1dIDogbnVsbDtcbiAgICAgICAgICAgIGlmIChvYmogPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvYmogPT0gbnVsbCAmJiBwYXJlbnRNb2RlbCkge1xuICAgICAgICAgICAgb2JqID0gcGFyZW50TW9kZWwuZ2V0KHBhdGhBcnIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0UGFyZW50KG1vZGVsLCBwYXRoKSB7XG4gICAgICAgIHZhciBnZXRQYXJlbnRNZXRob2QgPSBjbGF6elV0aWwuZ2V0KG1vZGVsLCAnZ2V0UGFyZW50Jyk7XG4gICAgICAgIHJldHVybiBnZXRQYXJlbnRNZXRob2QgPyBnZXRQYXJlbnRNZXRob2QuY2FsbChtb2RlbCwgcGF0aCkgOiBtb2RlbC5wYXJlbnRNb2RlbDtcbiAgICB9XG5cbiAgICAvLyBFbmFibGUgTW9kZWwuZXh0ZW5kLlxuICAgIGNsYXp6VXRpbC5lbmFibGVDbGFzc0V4dGVuZChNb2RlbCk7XG5cbiAgICB2YXIgbWl4aW4gPSB6clV0aWwubWl4aW47XG4gICAgbWl4aW4oTW9kZWwsIHJlcXVpcmUoJy4vbWl4aW4vbGluZVN0eWxlJykpO1xuICAgIG1peGluKE1vZGVsLCByZXF1aXJlKCcuL21peGluL2FyZWFTdHlsZScpKTtcbiAgICBtaXhpbihNb2RlbCwgcmVxdWlyZSgnLi9taXhpbi90ZXh0U3R5bGUnKSk7XG4gICAgbWl4aW4oTW9kZWwsIHJlcXVpcmUoJy4vbWl4aW4vaXRlbVN0eWxlJykpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBNb2RlbDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL21vZGVsL01vZGVsLmpzXG4vLyBtb2R1bGUgaWQgPSA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 10 */
/* unknown exports provided */
/* all exports used */
/*!***************************************************!*\
  !*** /home/yx/~/zrender/lib/core/BoundingRect.js ***!
  \***************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * @module echarts/core/BoundingRect\n */\n\n\n    var vec2 = __webpack_require__(/*! ./vector */ 4);\n    var matrix = __webpack_require__(/*! ./matrix */ 18);\n\n    var v2ApplyTransform = vec2.applyTransform;\n    var mathMin = Math.min;\n    var mathMax = Math.max;\n    /**\n     * @alias module:echarts/core/BoundingRect\n     */\n    function BoundingRect(x, y, width, height) {\n\n        if (width < 0) {\n            x = x + width;\n            width = -width;\n        }\n        if (height < 0) {\n            y = y + height;\n            height = -height;\n        }\n\n        /**\n         * @type {number}\n         */\n        this.x = x;\n        /**\n         * @type {number}\n         */\n        this.y = y;\n        /**\n         * @type {number}\n         */\n        this.width = width;\n        /**\n         * @type {number}\n         */\n        this.height = height;\n    }\n\n    BoundingRect.prototype = {\n\n        constructor: BoundingRect,\n\n        /**\n         * @param {module:echarts/core/BoundingRect} other\n         */\n        union: function (other) {\n            var x = mathMin(other.x, this.x);\n            var y = mathMin(other.y, this.y);\n\n            this.width = mathMax(\n                    other.x + other.width,\n                    this.x + this.width\n                ) - x;\n            this.height = mathMax(\n                    other.y + other.height,\n                    this.y + this.height\n                ) - y;\n            this.x = x;\n            this.y = y;\n        },\n\n        /**\n         * @param {Array.<number>} m\n         * @methods\n         */\n        applyTransform: (function () {\n            var lt = [];\n            var rb = [];\n            var lb = [];\n            var rt = [];\n            return function (m) {\n                // In case usage like this\n                // el.getBoundingRect().applyTransform(el.transform)\n                // And element has no transform\n                if (!m) {\n                    return;\n                }\n                lt[0] = lb[0] = this.x;\n                lt[1] = rt[1] = this.y;\n                rb[0] = rt[0] = this.x + this.width;\n                rb[1] = lb[1] = this.y + this.height;\n\n                v2ApplyTransform(lt, lt, m);\n                v2ApplyTransform(rb, rb, m);\n                v2ApplyTransform(lb, lb, m);\n                v2ApplyTransform(rt, rt, m);\n\n                this.x = mathMin(lt[0], rb[0], lb[0], rt[0]);\n                this.y = mathMin(lt[1], rb[1], lb[1], rt[1]);\n                var maxX = mathMax(lt[0], rb[0], lb[0], rt[0]);\n                var maxY = mathMax(lt[1], rb[1], lb[1], rt[1]);\n                this.width = maxX - this.x;\n                this.height = maxY - this.y;\n            };\n        })(),\n\n        /**\n         * Calculate matrix of transforming from self to target rect\n         * @param  {module:zrender/core/BoundingRect} b\n         * @return {Array.<number>}\n         */\n        calculateTransform: function (b) {\n            var a = this;\n            var sx = b.width / a.width;\n            var sy = b.height / a.height;\n\n            var m = matrix.create();\n\n            // 矩阵右乘\n            matrix.translate(m, m, [-a.x, -a.y]);\n            matrix.scale(m, m, [sx, sy]);\n            matrix.translate(m, m, [b.x, b.y]);\n\n            return m;\n        },\n\n        /**\n         * @param {(module:echarts/core/BoundingRect|Object)} b\n         * @return {boolean}\n         */\n        intersect: function (b) {\n            if (!b) {\n                return false;\n            }\n\n            if (!(b instanceof BoundingRect)) {\n                // Normalize negative width/height.\n                b = BoundingRect.create(b);\n            }\n\n            var a = this;\n            var ax0 = a.x;\n            var ax1 = a.x + a.width;\n            var ay0 = a.y;\n            var ay1 = a.y + a.height;\n\n            var bx0 = b.x;\n            var bx1 = b.x + b.width;\n            var by0 = b.y;\n            var by1 = b.y + b.height;\n\n            return ! (ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);\n        },\n\n        contain: function (x, y) {\n            var rect = this;\n            return x >= rect.x\n                && x <= (rect.x + rect.width)\n                && y >= rect.y\n                && y <= (rect.y + rect.height);\n        },\n\n        /**\n         * @return {module:echarts/core/BoundingRect}\n         */\n        clone: function () {\n            return new BoundingRect(this.x, this.y, this.width, this.height);\n        },\n\n        /**\n         * Copy from another rect\n         */\n        copy: function (other) {\n            this.x = other.x;\n            this.y = other.y;\n            this.width = other.width;\n            this.height = other.height;\n        },\n\n        plain: function () {\n            return {\n                x: this.x,\n                y: this.y,\n                width: this.width,\n                height: this.height\n            };\n        }\n    };\n\n    /**\n     * @param {Object|module:zrender/core/BoundingRect} rect\n     * @param {number} rect.x\n     * @param {number} rect.y\n     * @param {number} rect.width\n     * @param {number} rect.height\n     * @return {module:zrender/core/BoundingRect}\n     */\n    BoundingRect.create = function (rect) {\n        return new BoundingRect(rect.x, rect.y, rect.width, rect.height);\n    };\n\n    module.exports = BoundingRect;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL2hvbWUveXgvfi96cmVuZGVyL2xpYi9jb3JlL0JvdW5kaW5nUmVjdC5qcz8zNDk0Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbi8qKlxuICogQG1vZHVsZSBlY2hhcnRzL2NvcmUvQm91bmRpbmdSZWN0XG4gKi9cblxuXG4gICAgdmFyIHZlYzIgPSByZXF1aXJlKCcuL3ZlY3RvcicpO1xuICAgIHZhciBtYXRyaXggPSByZXF1aXJlKCcuL21hdHJpeCcpO1xuXG4gICAgdmFyIHYyQXBwbHlUcmFuc2Zvcm0gPSB2ZWMyLmFwcGx5VHJhbnNmb3JtO1xuICAgIHZhciBtYXRoTWluID0gTWF0aC5taW47XG4gICAgdmFyIG1hdGhNYXggPSBNYXRoLm1heDtcbiAgICAvKipcbiAgICAgKiBAYWxpYXMgbW9kdWxlOmVjaGFydHMvY29yZS9Cb3VuZGluZ1JlY3RcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBCb3VuZGluZ1JlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuXG4gICAgICAgIGlmICh3aWR0aCA8IDApIHtcbiAgICAgICAgICAgIHggPSB4ICsgd2lkdGg7XG4gICAgICAgICAgICB3aWR0aCA9IC13aWR0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVpZ2h0IDwgMCkge1xuICAgICAgICAgICAgeSA9IHkgKyBoZWlnaHQ7XG4gICAgICAgICAgICBoZWlnaHQgPSAtaGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIH1cblxuICAgIEJvdW5kaW5nUmVjdC5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IEJvdW5kaW5nUmVjdCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9jb3JlL0JvdW5kaW5nUmVjdH0gb3RoZXJcbiAgICAgICAgICovXG4gICAgICAgIHVuaW9uOiBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgICAgIHZhciB4ID0gbWF0aE1pbihvdGhlci54LCB0aGlzLngpO1xuICAgICAgICAgICAgdmFyIHkgPSBtYXRoTWluKG90aGVyLnksIHRoaXMueSk7XG5cbiAgICAgICAgICAgIHRoaXMud2lkdGggPSBtYXRoTWF4KFxuICAgICAgICAgICAgICAgICAgICBvdGhlci54ICsgb3RoZXIud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMueCArIHRoaXMud2lkdGhcbiAgICAgICAgICAgICAgICApIC0geDtcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gbWF0aE1heChcbiAgICAgICAgICAgICAgICAgICAgb3RoZXIueSArIG90aGVyLmhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy55ICsgdGhpcy5oZWlnaHRcbiAgICAgICAgICAgICAgICApIC0geTtcbiAgICAgICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBtXG4gICAgICAgICAqIEBtZXRob2RzXG4gICAgICAgICAqL1xuICAgICAgICBhcHBseVRyYW5zZm9ybTogKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBsdCA9IFtdO1xuICAgICAgICAgICAgdmFyIHJiID0gW107XG4gICAgICAgICAgICB2YXIgbGIgPSBbXTtcbiAgICAgICAgICAgIHZhciBydCA9IFtdO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgICAgICAgLy8gSW4gY2FzZSB1c2FnZSBsaWtlIHRoaXNcbiAgICAgICAgICAgICAgICAvLyBlbC5nZXRCb3VuZGluZ1JlY3QoKS5hcHBseVRyYW5zZm9ybShlbC50cmFuc2Zvcm0pXG4gICAgICAgICAgICAgICAgLy8gQW5kIGVsZW1lbnQgaGFzIG5vIHRyYW5zZm9ybVxuICAgICAgICAgICAgICAgIGlmICghbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGx0WzBdID0gbGJbMF0gPSB0aGlzLng7XG4gICAgICAgICAgICAgICAgbHRbMV0gPSBydFsxXSA9IHRoaXMueTtcbiAgICAgICAgICAgICAgICByYlswXSA9IHJ0WzBdID0gdGhpcy54ICsgdGhpcy53aWR0aDtcbiAgICAgICAgICAgICAgICByYlsxXSA9IGxiWzFdID0gdGhpcy55ICsgdGhpcy5oZWlnaHQ7XG5cbiAgICAgICAgICAgICAgICB2MkFwcGx5VHJhbnNmb3JtKGx0LCBsdCwgbSk7XG4gICAgICAgICAgICAgICAgdjJBcHBseVRyYW5zZm9ybShyYiwgcmIsIG0pO1xuICAgICAgICAgICAgICAgIHYyQXBwbHlUcmFuc2Zvcm0obGIsIGxiLCBtKTtcbiAgICAgICAgICAgICAgICB2MkFwcGx5VHJhbnNmb3JtKHJ0LCBydCwgbSk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnggPSBtYXRoTWluKGx0WzBdLCByYlswXSwgbGJbMF0sIHJ0WzBdKTtcbiAgICAgICAgICAgICAgICB0aGlzLnkgPSBtYXRoTWluKGx0WzFdLCByYlsxXSwgbGJbMV0sIHJ0WzFdKTtcbiAgICAgICAgICAgICAgICB2YXIgbWF4WCA9IG1hdGhNYXgobHRbMF0sIHJiWzBdLCBsYlswXSwgcnRbMF0pO1xuICAgICAgICAgICAgICAgIHZhciBtYXhZID0gbWF0aE1heChsdFsxXSwgcmJbMV0sIGxiWzFdLCBydFsxXSk7XG4gICAgICAgICAgICAgICAgdGhpcy53aWR0aCA9IG1heFggLSB0aGlzLng7XG4gICAgICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSBtYXhZIC0gdGhpcy55O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkoKSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsY3VsYXRlIG1hdHJpeCBvZiB0cmFuc2Zvcm1pbmcgZnJvbSBzZWxmIHRvIHRhcmdldCByZWN0XG4gICAgICAgICAqIEBwYXJhbSAge21vZHVsZTp6cmVuZGVyL2NvcmUvQm91bmRpbmdSZWN0fSBiXG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICAgICAgICAgKi9cbiAgICAgICAgY2FsY3VsYXRlVHJhbnNmb3JtOiBmdW5jdGlvbiAoYikge1xuICAgICAgICAgICAgdmFyIGEgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIHN4ID0gYi53aWR0aCAvIGEud2lkdGg7XG4gICAgICAgICAgICB2YXIgc3kgPSBiLmhlaWdodCAvIGEuaGVpZ2h0O1xuXG4gICAgICAgICAgICB2YXIgbSA9IG1hdHJpeC5jcmVhdGUoKTtcblxuICAgICAgICAgICAgLy8g55+p6Zi15Y+z5LmYXG4gICAgICAgICAgICBtYXRyaXgudHJhbnNsYXRlKG0sIG0sIFstYS54LCAtYS55XSk7XG4gICAgICAgICAgICBtYXRyaXguc2NhbGUobSwgbSwgW3N4LCBzeV0pO1xuICAgICAgICAgICAgbWF0cml4LnRyYW5zbGF0ZShtLCBtLCBbYi54LCBiLnldKTtcblxuICAgICAgICAgICAgcmV0dXJuIG07XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7KG1vZHVsZTplY2hhcnRzL2NvcmUvQm91bmRpbmdSZWN0fE9iamVjdCl9IGJcbiAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGludGVyc2VjdDogZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICAgIGlmICghYikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCEoYiBpbnN0YW5jZW9mIEJvdW5kaW5nUmVjdCkpIHtcbiAgICAgICAgICAgICAgICAvLyBOb3JtYWxpemUgbmVnYXRpdmUgd2lkdGgvaGVpZ2h0LlxuICAgICAgICAgICAgICAgIGIgPSBCb3VuZGluZ1JlY3QuY3JlYXRlKGIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgYSA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgYXgwID0gYS54O1xuICAgICAgICAgICAgdmFyIGF4MSA9IGEueCArIGEud2lkdGg7XG4gICAgICAgICAgICB2YXIgYXkwID0gYS55O1xuICAgICAgICAgICAgdmFyIGF5MSA9IGEueSArIGEuaGVpZ2h0O1xuXG4gICAgICAgICAgICB2YXIgYngwID0gYi54O1xuICAgICAgICAgICAgdmFyIGJ4MSA9IGIueCArIGIud2lkdGg7XG4gICAgICAgICAgICB2YXIgYnkwID0gYi55O1xuICAgICAgICAgICAgdmFyIGJ5MSA9IGIueSArIGIuaGVpZ2h0O1xuXG4gICAgICAgICAgICByZXR1cm4gISAoYXgxIDwgYngwIHx8IGJ4MSA8IGF4MCB8fCBheTEgPCBieTAgfHwgYnkxIDwgYXkwKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjb250YWluOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgdmFyIHJlY3QgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIHggPj0gcmVjdC54XG4gICAgICAgICAgICAgICAgJiYgeCA8PSAocmVjdC54ICsgcmVjdC53aWR0aClcbiAgICAgICAgICAgICAgICAmJiB5ID49IHJlY3QueVxuICAgICAgICAgICAgICAgICYmIHkgPD0gKHJlY3QueSArIHJlY3QuaGVpZ2h0KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOmVjaGFydHMvY29yZS9Cb3VuZGluZ1JlY3R9XG4gICAgICAgICAqL1xuICAgICAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCb3VuZGluZ1JlY3QodGhpcy54LCB0aGlzLnksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29weSBmcm9tIGFub3RoZXIgcmVjdFxuICAgICAgICAgKi9cbiAgICAgICAgY29weTogZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgICAgICAgICB0aGlzLnggPSBvdGhlci54O1xuICAgICAgICAgICAgdGhpcy55ID0gb3RoZXIueTtcbiAgICAgICAgICAgIHRoaXMud2lkdGggPSBvdGhlci53aWR0aDtcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gb3RoZXIuaGVpZ2h0O1xuICAgICAgICB9LFxuXG4gICAgICAgIHBsYWluOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHg6IHRoaXMueCxcbiAgICAgICAgICAgICAgICB5OiB0aGlzLnksXG4gICAgICAgICAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdHxtb2R1bGU6enJlbmRlci9jb3JlL0JvdW5kaW5nUmVjdH0gcmVjdFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByZWN0LnhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmVjdC55XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJlY3Qud2lkdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmVjdC5oZWlnaHRcbiAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL0JvdW5kaW5nUmVjdH1cbiAgICAgKi9cbiAgICBCb3VuZGluZ1JlY3QuY3JlYXRlID0gZnVuY3Rpb24gKHJlY3QpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCb3VuZGluZ1JlY3QocmVjdC54LCByZWN0LnksIHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0KTtcbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBCb3VuZGluZ1JlY3Q7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS95eC9+L3pyZW5kZXIvbGliL2NvcmUvQm91bmRpbmdSZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 11 */
/* unknown exports provided */
/* all exports used */
/*!****************************!*\
  !*** ./lib/util/layout.js ***!
  \****************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n// Layout helpers for each component positioning\n\n\n    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 0);\n    var BoundingRect = __webpack_require__(/*! zrender/lib/core/BoundingRect */ 10);\n    var numberUtil = __webpack_require__(/*! ./number */ 3);\n    var formatUtil = __webpack_require__(/*! ./format */ 6);\n    var parsePercent = numberUtil.parsePercent;\n    var each = zrUtil.each;\n\n    var layout = {};\n\n    /**\n     * @public\n     */\n    var LOCATION_PARAMS = layout.LOCATION_PARAMS = [\n        'left', 'right', 'top', 'bottom', 'width', 'height'\n    ];\n\n    /**\n     * @public\n     */\n    var HV_NAMES = layout.HV_NAMES = [\n        ['width', 'left', 'right'],\n        ['height', 'top', 'bottom']\n    ];\n\n    function boxLayout(orient, group, gap, maxWidth, maxHeight) {\n        var x = 0;\n        var y = 0;\n        if (maxWidth == null) {\n            maxWidth = Infinity;\n        }\n        if (maxHeight == null) {\n            maxHeight = Infinity;\n        }\n        var currentLineMaxSize = 0;\n        group.eachChild(function (child, idx) {\n            var position = child.position;\n            var rect = child.getBoundingRect();\n            var nextChild = group.childAt(idx + 1);\n            var nextChildRect = nextChild && nextChild.getBoundingRect();\n            var nextX;\n            var nextY;\n            if (orient === 'horizontal') {\n                var moveX = rect.width + (nextChildRect ? (-nextChildRect.x + rect.x) : 0);\n                nextX = x + moveX;\n                // Wrap when width exceeds maxWidth or meet a `newline` group\n                if (nextX > maxWidth || child.newline) {\n                    x = 0;\n                    nextX = moveX;\n                    y += currentLineMaxSize + gap;\n                    currentLineMaxSize = rect.height;\n                }\n                else {\n                    currentLineMaxSize = Math.max(currentLineMaxSize, rect.height);\n                }\n            }\n            else {\n                var moveY = rect.height + (nextChildRect ? (-nextChildRect.y + rect.y) : 0);\n                nextY = y + moveY;\n                // Wrap when width exceeds maxHeight or meet a `newline` group\n                if (nextY > maxHeight || child.newline) {\n                    x += currentLineMaxSize + gap;\n                    y = 0;\n                    nextY = moveY;\n                    currentLineMaxSize = rect.width;\n                }\n                else {\n                    currentLineMaxSize = Math.max(currentLineMaxSize, rect.width);\n                }\n            }\n\n            if (child.newline) {\n                return;\n            }\n\n            position[0] = x;\n            position[1] = y;\n\n            orient === 'horizontal'\n                ? (x = nextX + gap)\n                : (y = nextY + gap);\n        });\n    }\n\n    /**\n     * VBox or HBox layouting\n     * @param {string} orient\n     * @param {module:zrender/container/Group} group\n     * @param {number} gap\n     * @param {number} [width=Infinity]\n     * @param {number} [height=Infinity]\n     */\n    layout.box = boxLayout;\n\n    /**\n     * VBox layouting\n     * @param {module:zrender/container/Group} group\n     * @param {number} gap\n     * @param {number} [width=Infinity]\n     * @param {number} [height=Infinity]\n     */\n    layout.vbox = zrUtil.curry(boxLayout, 'vertical');\n\n    /**\n     * HBox layouting\n     * @param {module:zrender/container/Group} group\n     * @param {number} gap\n     * @param {number} [width=Infinity]\n     * @param {number} [height=Infinity]\n     */\n    layout.hbox = zrUtil.curry(boxLayout, 'horizontal');\n\n    /**\n     * If x or x2 is not specified or 'center' 'left' 'right',\n     * the width would be as long as possible.\n     * If y or y2 is not specified or 'middle' 'top' 'bottom',\n     * the height would be as long as possible.\n     *\n     * @param {Object} positionInfo\n     * @param {number|string} [positionInfo.x]\n     * @param {number|string} [positionInfo.y]\n     * @param {number|string} [positionInfo.x2]\n     * @param {number|string} [positionInfo.y2]\n     * @param {Object} containerRect\n     * @param {string|number} margin\n     * @return {Object} {width, height}\n     */\n    layout.getAvailableSize = function (positionInfo, containerRect, margin) {\n        var containerWidth = containerRect.width;\n        var containerHeight = containerRect.height;\n\n        var x = parsePercent(positionInfo.x, containerWidth);\n        var y = parsePercent(positionInfo.y, containerHeight);\n        var x2 = parsePercent(positionInfo.x2, containerWidth);\n        var y2 = parsePercent(positionInfo.y2, containerHeight);\n\n        (isNaN(x) || isNaN(parseFloat(positionInfo.x))) && (x = 0);\n        (isNaN(x2) || isNaN(parseFloat(positionInfo.x2))) && (x2 = containerWidth);\n        (isNaN(y) || isNaN(parseFloat(positionInfo.y))) && (y = 0);\n        (isNaN(y2) || isNaN(parseFloat(positionInfo.y2))) && (y2 = containerHeight);\n\n        margin = formatUtil.normalizeCssArray(margin || 0);\n\n        return {\n            width: Math.max(x2 - x - margin[1] - margin[3], 0),\n            height: Math.max(y2 - y - margin[0] - margin[2], 0)\n        };\n    };\n\n    /**\n     * Parse position info.\n     *\n     * @param {Object} positionInfo\n     * @param {number|string} [positionInfo.left]\n     * @param {number|string} [positionInfo.top]\n     * @param {number|string} [positionInfo.right]\n     * @param {number|string} [positionInfo.bottom]\n     * @param {number|string} [positionInfo.width]\n     * @param {number|string} [positionInfo.height]\n     * @param {number|string} [positionInfo.aspect] Aspect is width / height\n     * @param {Object} containerRect\n     * @param {string|number} [margin]\n     *\n     * @return {module:zrender/core/BoundingRect}\n     */\n    layout.getLayoutRect = function (\n        positionInfo, containerRect, margin\n    ) {\n        margin = formatUtil.normalizeCssArray(margin || 0);\n\n        var containerWidth = containerRect.width;\n        var containerHeight = containerRect.height;\n\n        var left = parsePercent(positionInfo.left, containerWidth);\n        var top = parsePercent(positionInfo.top, containerHeight);\n        var right = parsePercent(positionInfo.right, containerWidth);\n        var bottom = parsePercent(positionInfo.bottom, containerHeight);\n        var width = parsePercent(positionInfo.width, containerWidth);\n        var height = parsePercent(positionInfo.height, containerHeight);\n\n        var verticalMargin = margin[2] + margin[0];\n        var horizontalMargin = margin[1] + margin[3];\n        var aspect = positionInfo.aspect;\n\n        // If width is not specified, calculate width from left and right\n        if (isNaN(width)) {\n            width = containerWidth - right - horizontalMargin - left;\n        }\n        if (isNaN(height)) {\n            height = containerHeight - bottom - verticalMargin - top;\n        }\n\n        // If width and height are not given\n        // 1. Graph should not exceeds the container\n        // 2. Aspect must be keeped\n        // 3. Graph should take the space as more as possible\n        if (isNaN(width) && isNaN(height)) {\n            if (aspect > containerWidth / containerHeight) {\n                width = containerWidth * 0.8;\n            }\n            else {\n                height = containerHeight * 0.8;\n            }\n        }\n\n        if (aspect != null) {\n            // Calculate width or height with given aspect\n            if (isNaN(width)) {\n                width = aspect * height;\n            }\n            if (isNaN(height)) {\n                height = width / aspect;\n            }\n        }\n\n        // If left is not specified, calculate left from right and width\n        if (isNaN(left)) {\n            left = containerWidth - right - width - horizontalMargin;\n        }\n        if (isNaN(top)) {\n            top = containerHeight - bottom - height - verticalMargin;\n        }\n\n        // Align left and top\n        switch (positionInfo.left || positionInfo.right) {\n            case 'center':\n                left = containerWidth / 2 - width / 2 - margin[3];\n                break;\n            case 'right':\n                left = containerWidth - width - horizontalMargin;\n                break;\n        }\n        switch (positionInfo.top || positionInfo.bottom) {\n            case 'middle':\n            case 'center':\n                top = containerHeight / 2 - height / 2 - margin[0];\n                break;\n            case 'bottom':\n                top = containerHeight - height - verticalMargin;\n                break;\n        }\n        // If something is wrong and left, top, width, height are calculated as NaN\n        left = left || 0;\n        top = top || 0;\n        if (isNaN(width)) {\n            // Width may be NaN if only one value is given except width\n            width = containerWidth - left - (right || 0);\n        }\n        if (isNaN(height)) {\n            // Height may be NaN if only one value is given except height\n            height = containerHeight - top - (bottom || 0);\n        }\n\n        var rect = new BoundingRect(left + margin[3], top + margin[0], width, height);\n        rect.margin = margin;\n        return rect;\n    };\n\n\n    /**\n     * Position a zr element in viewport\n     *  Group position is specified by either\n     *  {left, top}, {right, bottom}\n     *  If all properties exists, right and bottom will be igonred.\n     *\n     * Logic:\n     *     1. Scale (against origin point in parent coord)\n     *     2. Rotate (against origin point in parent coord)\n     *     3. Traslate (with el.position by this method)\n     * So this method only fixes the last step 'Traslate', which does not affect\n     * scaling and rotating.\n     *\n     * If be called repeatly with the same input el, the same result will be gotten.\n     *\n     * @param {module:zrender/Element} el Should have `getBoundingRect` method.\n     * @param {Object} positionInfo\n     * @param {number|string} [positionInfo.left]\n     * @param {number|string} [positionInfo.top]\n     * @param {number|string} [positionInfo.right]\n     * @param {number|string} [positionInfo.bottom]\n     * @param {Object} containerRect\n     * @param {string|number} margin\n     * @param {Object} [opt]\n     * @param {Array.<number>} [opt.hv=[1,1]] Only horizontal or only vertical.\n     * @param {Array.<number>} [opt.boundingMode='all']\n     *        Specify how to calculate boundingRect when locating.\n     *        'all': Position the boundingRect that is transformed and uioned\n     *               both itself and its descendants.\n     *               This mode simplies confine the elements in the bounding\n     *               of their container (e.g., using 'right: 0').\n     *        'raw': Position the boundingRect that is not transformed and only itself.\n     *               This mode is useful when you want a element can overflow its\n     *               container. (Consider a rotated circle needs to be located in a corner.)\n     *               In this mode positionInfo.width/height can only be number.\n     */\n    layout.positionElement = function (el, positionInfo, containerRect, margin, opt) {\n        var h = !opt || !opt.hv || opt.hv[0];\n        var v = !opt || !opt.hv || opt.hv[1];\n        var boundingMode = opt && opt.boundingMode || 'all';\n\n        if (!h && !v) {\n            return;\n        }\n\n        var rect;\n        if (boundingMode === 'raw') {\n            rect = el.type === 'group'\n                ? new BoundingRect(0, 0, +positionInfo.width || 0, +positionInfo.height || 0)\n                : el.getBoundingRect();\n        }\n        else {\n            rect = el.getBoundingRect();\n            if (el.needLocalTransform()) {\n                var transform = el.getLocalTransform();\n                // Notice: raw rect may be inner object of el,\n                // which should not be modified.\n                rect = rect.clone();\n                rect.applyTransform(transform);\n            }\n        }\n\n        positionInfo = layout.getLayoutRect(\n            zrUtil.defaults(\n                {width: rect.width, height: rect.height},\n                positionInfo\n            ),\n            containerRect,\n            margin\n        );\n\n        // Because 'tranlate' is the last step in transform\n        // (see zrender/core/Transformable#getLocalTransfrom),\n        // we can just only modify el.position to get final result.\n        var elPos = el.position;\n        var dx = h ? positionInfo.x - rect.x : 0;\n        var dy = v ? positionInfo.y - rect.y : 0;\n\n        el.attr('position', boundingMode === 'raw' ? [dx, dy] : [elPos[0] + dx, elPos[1] + dy]);\n    };\n\n    /**\n     * @param {Object} option Contains some of the properties in HV_NAMES.\n     * @param {number} hvIdx 0: horizontal; 1: vertical.\n     */\n    layout.sizeCalculable = function (option, hvIdx) {\n        return option[HV_NAMES[hvIdx][0]] != null\n            || (option[HV_NAMES[hvIdx][1]] != null && option[HV_NAMES[hvIdx][2]] != null);\n    };\n\n    /**\n     * Consider Case:\n     * When defulat option has {left: 0, width: 100}, and we set {right: 0}\n     * through setOption or media query, using normal zrUtil.merge will cause\n     * {right: 0} does not take effect.\n     *\n     * @example\n     * ComponentModel.extend({\n     *     init: function () {\n     *         ...\n     *         var inputPositionParams = layout.getLayoutParams(option);\n     *         this.mergeOption(inputPositionParams);\n     *     },\n     *     mergeOption: function (newOption) {\n     *         newOption && zrUtil.merge(thisOption, newOption, true);\n     *         layout.mergeLayoutParam(thisOption, newOption);\n     *     }\n     * });\n     *\n     * @param {Object} targetOption\n     * @param {Object} newOption\n     * @param {Object|string} [opt]\n     * @param {boolean|Array.<boolean>} [opt.ignoreSize=false] Some component must has width and height.\n     */\n    layout.mergeLayoutParam = function (targetOption, newOption, opt) {\n        !zrUtil.isObject(opt) && (opt = {});\n\n        var ignoreSize = opt.ignoreSize;\n        !zrUtil.isArray(ignoreSize) && (ignoreSize = [ignoreSize, ignoreSize]);\n\n        var hResult = merge(HV_NAMES[0], 0);\n        var vResult = merge(HV_NAMES[1], 1);\n\n        copy(HV_NAMES[0], targetOption, hResult);\n        copy(HV_NAMES[1], targetOption, vResult);\n\n        function merge(names, hvIdx) {\n            var newParams = {};\n            var newValueCount = 0;\n            var merged = {};\n            var mergedValueCount = 0;\n            var enoughParamNumber = 2;\n\n            each(names, function (name) {\n                merged[name] = targetOption[name];\n            });\n            each(names, function (name) {\n                // Consider case: newOption.width is null, which is\n                // set by user for removing width setting.\n                hasProp(newOption, name) && (newParams[name] = merged[name] = newOption[name]);\n                hasValue(newParams, name) && newValueCount++;\n                hasValue(merged, name) && mergedValueCount++;\n            });\n\n            if (ignoreSize[hvIdx]) {\n                // Only one of left/right is premitted to exist.\n                if (hasValue(newOption, names[1])) {\n                    merged[names[2]] = null;\n                }\n                else if (hasValue(newOption, names[2])) {\n                    merged[names[1]] = null;\n                }\n                return merged;\n            }\n\n            // Case: newOption: {width: ..., right: ...},\n            // or targetOption: {right: ...} and newOption: {width: ...},\n            // There is no conflict when merged only has params count\n            // little than enoughParamNumber.\n            if (mergedValueCount === enoughParamNumber || !newValueCount) {\n                return merged;\n            }\n            // Case: newOption: {width: ..., right: ...},\n            // Than we can make sure user only want those two, and ignore\n            // all origin params in targetOption.\n            else if (newValueCount >= enoughParamNumber) {\n                return newParams;\n            }\n            else {\n                // Chose another param from targetOption by priority.\n                for (var i = 0; i < names.length; i++) {\n                    var name = names[i];\n                    if (!hasProp(newParams, name) && hasProp(targetOption, name)) {\n                        newParams[name] = targetOption[name];\n                        break;\n                    }\n                }\n                return newParams;\n            }\n        }\n\n        function hasProp(obj, name) {\n            return obj.hasOwnProperty(name);\n        }\n\n        function hasValue(obj, name) {\n            return obj[name] != null && obj[name] !== 'auto';\n        }\n\n        function copy(names, target, source) {\n            each(names, function (name) {\n                target[name] = source[name];\n            });\n        }\n    };\n\n    /**\n     * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.\n     * @param {Object} source\n     * @return {Object} Result contains those props.\n     */\n    layout.getLayoutParams = function (source) {\n        return layout.copyLayoutParams({}, source);\n    };\n\n    /**\n     * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.\n     * @param {Object} source\n     * @return {Object} Result contains those props.\n     */\n    layout.copyLayoutParams = function (target, source) {\n        source && target && each(LOCATION_PARAMS, function (name) {\n            source.hasOwnProperty(name) && (target[name] = source[name]);\n        });\n        return target;\n    };\n\n    module.exports = layout;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvdXRpbC9sYXlvdXQuanM/ZmQ5MiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG4vLyBMYXlvdXQgaGVscGVycyBmb3IgZWFjaCBjb21wb25lbnQgcG9zaXRpb25pbmdcblxuXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuICAgIHZhciBCb3VuZGluZ1JlY3QgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL0JvdW5kaW5nUmVjdCcpO1xuICAgIHZhciBudW1iZXJVdGlsID0gcmVxdWlyZSgnLi9udW1iZXInKTtcbiAgICB2YXIgZm9ybWF0VXRpbCA9IHJlcXVpcmUoJy4vZm9ybWF0Jyk7XG4gICAgdmFyIHBhcnNlUGVyY2VudCA9IG51bWJlclV0aWwucGFyc2VQZXJjZW50O1xuICAgIHZhciBlYWNoID0genJVdGlsLmVhY2g7XG5cbiAgICB2YXIgbGF5b3V0ID0ge307XG5cbiAgICAvKipcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgdmFyIExPQ0FUSU9OX1BBUkFNUyA9IGxheW91dC5MT0NBVElPTl9QQVJBTVMgPSBbXG4gICAgICAgICdsZWZ0JywgJ3JpZ2h0JywgJ3RvcCcsICdib3R0b20nLCAnd2lkdGgnLCAnaGVpZ2h0J1xuICAgIF07XG5cbiAgICAvKipcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgdmFyIEhWX05BTUVTID0gbGF5b3V0LkhWX05BTUVTID0gW1xuICAgICAgICBbJ3dpZHRoJywgJ2xlZnQnLCAncmlnaHQnXSxcbiAgICAgICAgWydoZWlnaHQnLCAndG9wJywgJ2JvdHRvbSddXG4gICAgXTtcblxuICAgIGZ1bmN0aW9uIGJveExheW91dChvcmllbnQsIGdyb3VwLCBnYXAsIG1heFdpZHRoLCBtYXhIZWlnaHQpIHtcbiAgICAgICAgdmFyIHggPSAwO1xuICAgICAgICB2YXIgeSA9IDA7XG4gICAgICAgIGlmIChtYXhXaWR0aCA9PSBudWxsKSB7XG4gICAgICAgICAgICBtYXhXaWR0aCA9IEluZmluaXR5O1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXhIZWlnaHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgbWF4SGVpZ2h0ID0gSW5maW5pdHk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGN1cnJlbnRMaW5lTWF4U2l6ZSA9IDA7XG4gICAgICAgIGdyb3VwLmVhY2hDaGlsZChmdW5jdGlvbiAoY2hpbGQsIGlkeCkge1xuICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gY2hpbGQucG9zaXRpb247XG4gICAgICAgICAgICB2YXIgcmVjdCA9IGNoaWxkLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgICAgICAgICAgdmFyIG5leHRDaGlsZCA9IGdyb3VwLmNoaWxkQXQoaWR4ICsgMSk7XG4gICAgICAgICAgICB2YXIgbmV4dENoaWxkUmVjdCA9IG5leHRDaGlsZCAmJiBuZXh0Q2hpbGQuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgICAgICAgICB2YXIgbmV4dFg7XG4gICAgICAgICAgICB2YXIgbmV4dFk7XG4gICAgICAgICAgICBpZiAob3JpZW50ID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgICAgICAgICAgICB2YXIgbW92ZVggPSByZWN0LndpZHRoICsgKG5leHRDaGlsZFJlY3QgPyAoLW5leHRDaGlsZFJlY3QueCArIHJlY3QueCkgOiAwKTtcbiAgICAgICAgICAgICAgICBuZXh0WCA9IHggKyBtb3ZlWDtcbiAgICAgICAgICAgICAgICAvLyBXcmFwIHdoZW4gd2lkdGggZXhjZWVkcyBtYXhXaWR0aCBvciBtZWV0IGEgYG5ld2xpbmVgIGdyb3VwXG4gICAgICAgICAgICAgICAgaWYgKG5leHRYID4gbWF4V2lkdGggfHwgY2hpbGQubmV3bGluZSkge1xuICAgICAgICAgICAgICAgICAgICB4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFggPSBtb3ZlWDtcbiAgICAgICAgICAgICAgICAgICAgeSArPSBjdXJyZW50TGluZU1heFNpemUgKyBnYXA7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRMaW5lTWF4U2l6ZSA9IHJlY3QuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudExpbmVNYXhTaXplID0gTWF0aC5tYXgoY3VycmVudExpbmVNYXhTaXplLCByZWN0LmhlaWdodCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIG1vdmVZID0gcmVjdC5oZWlnaHQgKyAobmV4dENoaWxkUmVjdCA/ICgtbmV4dENoaWxkUmVjdC55ICsgcmVjdC55KSA6IDApO1xuICAgICAgICAgICAgICAgIG5leHRZID0geSArIG1vdmVZO1xuICAgICAgICAgICAgICAgIC8vIFdyYXAgd2hlbiB3aWR0aCBleGNlZWRzIG1heEhlaWdodCBvciBtZWV0IGEgYG5ld2xpbmVgIGdyb3VwXG4gICAgICAgICAgICAgICAgaWYgKG5leHRZID4gbWF4SGVpZ2h0IHx8IGNoaWxkLm5ld2xpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgeCArPSBjdXJyZW50TGluZU1heFNpemUgKyBnYXA7XG4gICAgICAgICAgICAgICAgICAgIHkgPSAwO1xuICAgICAgICAgICAgICAgICAgICBuZXh0WSA9IG1vdmVZO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50TGluZU1heFNpemUgPSByZWN0LndpZHRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudExpbmVNYXhTaXplID0gTWF0aC5tYXgoY3VycmVudExpbmVNYXhTaXplLCByZWN0LndpZHRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjaGlsZC5uZXdsaW5lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwb3NpdGlvblswXSA9IHg7XG4gICAgICAgICAgICBwb3NpdGlvblsxXSA9IHk7XG5cbiAgICAgICAgICAgIG9yaWVudCA9PT0gJ2hvcml6b250YWwnXG4gICAgICAgICAgICAgICAgPyAoeCA9IG5leHRYICsgZ2FwKVxuICAgICAgICAgICAgICAgIDogKHkgPSBuZXh0WSArIGdhcCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFZCb3ggb3IgSEJveCBsYXlvdXRpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3JpZW50XG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9jb250YWluZXIvR3JvdXB9IGdyb3VwXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGdhcFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbd2lkdGg9SW5maW5pdHldXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtoZWlnaHQ9SW5maW5pdHldXG4gICAgICovXG4gICAgbGF5b3V0LmJveCA9IGJveExheW91dDtcblxuICAgIC8qKlxuICAgICAqIFZCb3ggbGF5b3V0aW5nXG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9jb250YWluZXIvR3JvdXB9IGdyb3VwXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGdhcFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbd2lkdGg9SW5maW5pdHldXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtoZWlnaHQ9SW5maW5pdHldXG4gICAgICovXG4gICAgbGF5b3V0LnZib3ggPSB6clV0aWwuY3VycnkoYm94TGF5b3V0LCAndmVydGljYWwnKTtcblxuICAgIC8qKlxuICAgICAqIEhCb3ggbGF5b3V0aW5nXG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9jb250YWluZXIvR3JvdXB9IGdyb3VwXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGdhcFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbd2lkdGg9SW5maW5pdHldXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtoZWlnaHQ9SW5maW5pdHldXG4gICAgICovXG4gICAgbGF5b3V0Lmhib3ggPSB6clV0aWwuY3VycnkoYm94TGF5b3V0LCAnaG9yaXpvbnRhbCcpO1xuXG4gICAgLyoqXG4gICAgICogSWYgeCBvciB4MiBpcyBub3Qgc3BlY2lmaWVkIG9yICdjZW50ZXInICdsZWZ0JyAncmlnaHQnLFxuICAgICAqIHRoZSB3aWR0aCB3b3VsZCBiZSBhcyBsb25nIGFzIHBvc3NpYmxlLlxuICAgICAqIElmIHkgb3IgeTIgaXMgbm90IHNwZWNpZmllZCBvciAnbWlkZGxlJyAndG9wJyAnYm90dG9tJyxcbiAgICAgKiB0aGUgaGVpZ2h0IHdvdWxkIGJlIGFzIGxvbmcgYXMgcG9zc2libGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcG9zaXRpb25JbmZvXG4gICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbcG9zaXRpb25JbmZvLnhdXG4gICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbcG9zaXRpb25JbmZvLnldXG4gICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbcG9zaXRpb25JbmZvLngyXVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW3Bvc2l0aW9uSW5mby55Ml1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29udGFpbmVyUmVjdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gbWFyZ2luXG4gICAgICogQHJldHVybiB7T2JqZWN0fSB7d2lkdGgsIGhlaWdodH1cbiAgICAgKi9cbiAgICBsYXlvdXQuZ2V0QXZhaWxhYmxlU2l6ZSA9IGZ1bmN0aW9uIChwb3NpdGlvbkluZm8sIGNvbnRhaW5lclJlY3QsIG1hcmdpbikge1xuICAgICAgICB2YXIgY29udGFpbmVyV2lkdGggPSBjb250YWluZXJSZWN0LndpZHRoO1xuICAgICAgICB2YXIgY29udGFpbmVySGVpZ2h0ID0gY29udGFpbmVyUmVjdC5oZWlnaHQ7XG5cbiAgICAgICAgdmFyIHggPSBwYXJzZVBlcmNlbnQocG9zaXRpb25JbmZvLngsIGNvbnRhaW5lcldpZHRoKTtcbiAgICAgICAgdmFyIHkgPSBwYXJzZVBlcmNlbnQocG9zaXRpb25JbmZvLnksIGNvbnRhaW5lckhlaWdodCk7XG4gICAgICAgIHZhciB4MiA9IHBhcnNlUGVyY2VudChwb3NpdGlvbkluZm8ueDIsIGNvbnRhaW5lcldpZHRoKTtcbiAgICAgICAgdmFyIHkyID0gcGFyc2VQZXJjZW50KHBvc2l0aW9uSW5mby55MiwgY29udGFpbmVySGVpZ2h0KTtcblxuICAgICAgICAoaXNOYU4oeCkgfHwgaXNOYU4ocGFyc2VGbG9hdChwb3NpdGlvbkluZm8ueCkpKSAmJiAoeCA9IDApO1xuICAgICAgICAoaXNOYU4oeDIpIHx8IGlzTmFOKHBhcnNlRmxvYXQocG9zaXRpb25JbmZvLngyKSkpICYmICh4MiA9IGNvbnRhaW5lcldpZHRoKTtcbiAgICAgICAgKGlzTmFOKHkpIHx8IGlzTmFOKHBhcnNlRmxvYXQocG9zaXRpb25JbmZvLnkpKSkgJiYgKHkgPSAwKTtcbiAgICAgICAgKGlzTmFOKHkyKSB8fCBpc05hTihwYXJzZUZsb2F0KHBvc2l0aW9uSW5mby55MikpKSAmJiAoeTIgPSBjb250YWluZXJIZWlnaHQpO1xuXG4gICAgICAgIG1hcmdpbiA9IGZvcm1hdFV0aWwubm9ybWFsaXplQ3NzQXJyYXkobWFyZ2luIHx8IDApO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3aWR0aDogTWF0aC5tYXgoeDIgLSB4IC0gbWFyZ2luWzFdIC0gbWFyZ2luWzNdLCAwKSxcbiAgICAgICAgICAgIGhlaWdodDogTWF0aC5tYXgoeTIgLSB5IC0gbWFyZ2luWzBdIC0gbWFyZ2luWzJdLCAwKVxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBQYXJzZSBwb3NpdGlvbiBpbmZvLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBvc2l0aW9uSW5mb1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW3Bvc2l0aW9uSW5mby5sZWZ0XVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW3Bvc2l0aW9uSW5mby50b3BdXG4gICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbcG9zaXRpb25JbmZvLnJpZ2h0XVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW3Bvc2l0aW9uSW5mby5ib3R0b21dXG4gICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbcG9zaXRpb25JbmZvLndpZHRoXVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW3Bvc2l0aW9uSW5mby5oZWlnaHRdXG4gICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbcG9zaXRpb25JbmZvLmFzcGVjdF0gQXNwZWN0IGlzIHdpZHRoIC8gaGVpZ2h0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbnRhaW5lclJlY3RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IFttYXJnaW5dXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL0JvdW5kaW5nUmVjdH1cbiAgICAgKi9cbiAgICBsYXlvdXQuZ2V0TGF5b3V0UmVjdCA9IGZ1bmN0aW9uIChcbiAgICAgICAgcG9zaXRpb25JbmZvLCBjb250YWluZXJSZWN0LCBtYXJnaW5cbiAgICApIHtcbiAgICAgICAgbWFyZ2luID0gZm9ybWF0VXRpbC5ub3JtYWxpemVDc3NBcnJheShtYXJnaW4gfHwgMCk7XG5cbiAgICAgICAgdmFyIGNvbnRhaW5lcldpZHRoID0gY29udGFpbmVyUmVjdC53aWR0aDtcbiAgICAgICAgdmFyIGNvbnRhaW5lckhlaWdodCA9IGNvbnRhaW5lclJlY3QuaGVpZ2h0O1xuXG4gICAgICAgIHZhciBsZWZ0ID0gcGFyc2VQZXJjZW50KHBvc2l0aW9uSW5mby5sZWZ0LCBjb250YWluZXJXaWR0aCk7XG4gICAgICAgIHZhciB0b3AgPSBwYXJzZVBlcmNlbnQocG9zaXRpb25JbmZvLnRvcCwgY29udGFpbmVySGVpZ2h0KTtcbiAgICAgICAgdmFyIHJpZ2h0ID0gcGFyc2VQZXJjZW50KHBvc2l0aW9uSW5mby5yaWdodCwgY29udGFpbmVyV2lkdGgpO1xuICAgICAgICB2YXIgYm90dG9tID0gcGFyc2VQZXJjZW50KHBvc2l0aW9uSW5mby5ib3R0b20sIGNvbnRhaW5lckhlaWdodCk7XG4gICAgICAgIHZhciB3aWR0aCA9IHBhcnNlUGVyY2VudChwb3NpdGlvbkluZm8ud2lkdGgsIGNvbnRhaW5lcldpZHRoKTtcbiAgICAgICAgdmFyIGhlaWdodCA9IHBhcnNlUGVyY2VudChwb3NpdGlvbkluZm8uaGVpZ2h0LCBjb250YWluZXJIZWlnaHQpO1xuXG4gICAgICAgIHZhciB2ZXJ0aWNhbE1hcmdpbiA9IG1hcmdpblsyXSArIG1hcmdpblswXTtcbiAgICAgICAgdmFyIGhvcml6b250YWxNYXJnaW4gPSBtYXJnaW5bMV0gKyBtYXJnaW5bM107XG4gICAgICAgIHZhciBhc3BlY3QgPSBwb3NpdGlvbkluZm8uYXNwZWN0O1xuXG4gICAgICAgIC8vIElmIHdpZHRoIGlzIG5vdCBzcGVjaWZpZWQsIGNhbGN1bGF0ZSB3aWR0aCBmcm9tIGxlZnQgYW5kIHJpZ2h0XG4gICAgICAgIGlmIChpc05hTih3aWR0aCkpIHtcbiAgICAgICAgICAgIHdpZHRoID0gY29udGFpbmVyV2lkdGggLSByaWdodCAtIGhvcml6b250YWxNYXJnaW4gLSBsZWZ0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc05hTihoZWlnaHQpKSB7XG4gICAgICAgICAgICBoZWlnaHQgPSBjb250YWluZXJIZWlnaHQgLSBib3R0b20gLSB2ZXJ0aWNhbE1hcmdpbiAtIHRvcDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHdpZHRoIGFuZCBoZWlnaHQgYXJlIG5vdCBnaXZlblxuICAgICAgICAvLyAxLiBHcmFwaCBzaG91bGQgbm90IGV4Y2VlZHMgdGhlIGNvbnRhaW5lclxuICAgICAgICAvLyAyLiBBc3BlY3QgbXVzdCBiZSBrZWVwZWRcbiAgICAgICAgLy8gMy4gR3JhcGggc2hvdWxkIHRha2UgdGhlIHNwYWNlIGFzIG1vcmUgYXMgcG9zc2libGVcbiAgICAgICAgaWYgKGlzTmFOKHdpZHRoKSAmJiBpc05hTihoZWlnaHQpKSB7XG4gICAgICAgICAgICBpZiAoYXNwZWN0ID4gY29udGFpbmVyV2lkdGggLyBjb250YWluZXJIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICB3aWR0aCA9IGNvbnRhaW5lcldpZHRoICogMC44O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gY29udGFpbmVySGVpZ2h0ICogMC44O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFzcGVjdCAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgd2lkdGggb3IgaGVpZ2h0IHdpdGggZ2l2ZW4gYXNwZWN0XG4gICAgICAgICAgICBpZiAoaXNOYU4od2lkdGgpKSB7XG4gICAgICAgICAgICAgICAgd2lkdGggPSBhc3BlY3QgKiBoZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNOYU4oaGVpZ2h0KSkge1xuICAgICAgICAgICAgICAgIGhlaWdodCA9IHdpZHRoIC8gYXNwZWN0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgbGVmdCBpcyBub3Qgc3BlY2lmaWVkLCBjYWxjdWxhdGUgbGVmdCBmcm9tIHJpZ2h0IGFuZCB3aWR0aFxuICAgICAgICBpZiAoaXNOYU4obGVmdCkpIHtcbiAgICAgICAgICAgIGxlZnQgPSBjb250YWluZXJXaWR0aCAtIHJpZ2h0IC0gd2lkdGggLSBob3Jpem9udGFsTWFyZ2luO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc05hTih0b3ApKSB7XG4gICAgICAgICAgICB0b3AgPSBjb250YWluZXJIZWlnaHQgLSBib3R0b20gLSBoZWlnaHQgLSB2ZXJ0aWNhbE1hcmdpbjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFsaWduIGxlZnQgYW5kIHRvcFxuICAgICAgICBzd2l0Y2ggKHBvc2l0aW9uSW5mby5sZWZ0IHx8IHBvc2l0aW9uSW5mby5yaWdodCkge1xuICAgICAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICAgICAgICBsZWZ0ID0gY29udGFpbmVyV2lkdGggLyAyIC0gd2lkdGggLyAyIC0gbWFyZ2luWzNdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgICAgIGxlZnQgPSBjb250YWluZXJXaWR0aCAtIHdpZHRoIC0gaG9yaXpvbnRhbE1hcmdpbjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHBvc2l0aW9uSW5mby50b3AgfHwgcG9zaXRpb25JbmZvLmJvdHRvbSkge1xuICAgICAgICAgICAgY2FzZSAnbWlkZGxlJzpcbiAgICAgICAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgICAgICAgICAgdG9wID0gY29udGFpbmVySGVpZ2h0IC8gMiAtIGhlaWdodCAvIDIgLSBtYXJnaW5bMF07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgICAgICAgIHRvcCA9IGNvbnRhaW5lckhlaWdodCAtIGhlaWdodCAtIHZlcnRpY2FsTWFyZ2luO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHNvbWV0aGluZyBpcyB3cm9uZyBhbmQgbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0IGFyZSBjYWxjdWxhdGVkIGFzIE5hTlxuICAgICAgICBsZWZ0ID0gbGVmdCB8fCAwO1xuICAgICAgICB0b3AgPSB0b3AgfHwgMDtcbiAgICAgICAgaWYgKGlzTmFOKHdpZHRoKSkge1xuICAgICAgICAgICAgLy8gV2lkdGggbWF5IGJlIE5hTiBpZiBvbmx5IG9uZSB2YWx1ZSBpcyBnaXZlbiBleGNlcHQgd2lkdGhcbiAgICAgICAgICAgIHdpZHRoID0gY29udGFpbmVyV2lkdGggLSBsZWZ0IC0gKHJpZ2h0IHx8IDApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc05hTihoZWlnaHQpKSB7XG4gICAgICAgICAgICAvLyBIZWlnaHQgbWF5IGJlIE5hTiBpZiBvbmx5IG9uZSB2YWx1ZSBpcyBnaXZlbiBleGNlcHQgaGVpZ2h0XG4gICAgICAgICAgICBoZWlnaHQgPSBjb250YWluZXJIZWlnaHQgLSB0b3AgLSAoYm90dG9tIHx8IDApO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlY3QgPSBuZXcgQm91bmRpbmdSZWN0KGxlZnQgKyBtYXJnaW5bM10sIHRvcCArIG1hcmdpblswXSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHJlY3QubWFyZ2luID0gbWFyZ2luO1xuICAgICAgICByZXR1cm4gcmVjdDtcbiAgICB9O1xuXG5cbiAgICAvKipcbiAgICAgKiBQb3NpdGlvbiBhIHpyIGVsZW1lbnQgaW4gdmlld3BvcnRcbiAgICAgKiAgR3JvdXAgcG9zaXRpb24gaXMgc3BlY2lmaWVkIGJ5IGVpdGhlclxuICAgICAqICB7bGVmdCwgdG9wfSwge3JpZ2h0LCBib3R0b219XG4gICAgICogIElmIGFsbCBwcm9wZXJ0aWVzIGV4aXN0cywgcmlnaHQgYW5kIGJvdHRvbSB3aWxsIGJlIGlnb25yZWQuXG4gICAgICpcbiAgICAgKiBMb2dpYzpcbiAgICAgKiAgICAgMS4gU2NhbGUgKGFnYWluc3Qgb3JpZ2luIHBvaW50IGluIHBhcmVudCBjb29yZClcbiAgICAgKiAgICAgMi4gUm90YXRlIChhZ2FpbnN0IG9yaWdpbiBwb2ludCBpbiBwYXJlbnQgY29vcmQpXG4gICAgICogICAgIDMuIFRyYXNsYXRlICh3aXRoIGVsLnBvc2l0aW9uIGJ5IHRoaXMgbWV0aG9kKVxuICAgICAqIFNvIHRoaXMgbWV0aG9kIG9ubHkgZml4ZXMgdGhlIGxhc3Qgc3RlcCAnVHJhc2xhdGUnLCB3aGljaCBkb2VzIG5vdCBhZmZlY3RcbiAgICAgKiBzY2FsaW5nIGFuZCByb3RhdGluZy5cbiAgICAgKlxuICAgICAqIElmIGJlIGNhbGxlZCByZXBlYXRseSB3aXRoIHRoZSBzYW1lIGlucHV0IGVsLCB0aGUgc2FtZSByZXN1bHQgd2lsbCBiZSBnb3R0ZW4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGVsIFNob3VsZCBoYXZlIGBnZXRCb3VuZGluZ1JlY3RgIG1ldGhvZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcG9zaXRpb25JbmZvXG4gICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbcG9zaXRpb25JbmZvLmxlZnRdXG4gICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbcG9zaXRpb25JbmZvLnRvcF1cbiAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtwb3NpdGlvbkluZm8ucmlnaHRdXG4gICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbcG9zaXRpb25JbmZvLmJvdHRvbV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29udGFpbmVyUmVjdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gbWFyZ2luXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRdXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gW29wdC5odj1bMSwxXV0gT25seSBob3Jpem9udGFsIG9yIG9ubHkgdmVydGljYWwuXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gW29wdC5ib3VuZGluZ01vZGU9J2FsbCddXG4gICAgICogICAgICAgIFNwZWNpZnkgaG93IHRvIGNhbGN1bGF0ZSBib3VuZGluZ1JlY3Qgd2hlbiBsb2NhdGluZy5cbiAgICAgKiAgICAgICAgJ2FsbCc6IFBvc2l0aW9uIHRoZSBib3VuZGluZ1JlY3QgdGhhdCBpcyB0cmFuc2Zvcm1lZCBhbmQgdWlvbmVkXG4gICAgICogICAgICAgICAgICAgICBib3RoIGl0c2VsZiBhbmQgaXRzIGRlc2NlbmRhbnRzLlxuICAgICAqICAgICAgICAgICAgICAgVGhpcyBtb2RlIHNpbXBsaWVzIGNvbmZpbmUgdGhlIGVsZW1lbnRzIGluIHRoZSBib3VuZGluZ1xuICAgICAqICAgICAgICAgICAgICAgb2YgdGhlaXIgY29udGFpbmVyIChlLmcuLCB1c2luZyAncmlnaHQ6IDAnKS5cbiAgICAgKiAgICAgICAgJ3Jhdyc6IFBvc2l0aW9uIHRoZSBib3VuZGluZ1JlY3QgdGhhdCBpcyBub3QgdHJhbnNmb3JtZWQgYW5kIG9ubHkgaXRzZWxmLlxuICAgICAqICAgICAgICAgICAgICAgVGhpcyBtb2RlIGlzIHVzZWZ1bCB3aGVuIHlvdSB3YW50IGEgZWxlbWVudCBjYW4gb3ZlcmZsb3cgaXRzXG4gICAgICogICAgICAgICAgICAgICBjb250YWluZXIuIChDb25zaWRlciBhIHJvdGF0ZWQgY2lyY2xlIG5lZWRzIHRvIGJlIGxvY2F0ZWQgaW4gYSBjb3JuZXIuKVxuICAgICAqICAgICAgICAgICAgICAgSW4gdGhpcyBtb2RlIHBvc2l0aW9uSW5mby53aWR0aC9oZWlnaHQgY2FuIG9ubHkgYmUgbnVtYmVyLlxuICAgICAqL1xuICAgIGxheW91dC5wb3NpdGlvbkVsZW1lbnQgPSBmdW5jdGlvbiAoZWwsIHBvc2l0aW9uSW5mbywgY29udGFpbmVyUmVjdCwgbWFyZ2luLCBvcHQpIHtcbiAgICAgICAgdmFyIGggPSAhb3B0IHx8ICFvcHQuaHYgfHwgb3B0Lmh2WzBdO1xuICAgICAgICB2YXIgdiA9ICFvcHQgfHwgIW9wdC5odiB8fCBvcHQuaHZbMV07XG4gICAgICAgIHZhciBib3VuZGluZ01vZGUgPSBvcHQgJiYgb3B0LmJvdW5kaW5nTW9kZSB8fCAnYWxsJztcblxuICAgICAgICBpZiAoIWggJiYgIXYpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZWN0O1xuICAgICAgICBpZiAoYm91bmRpbmdNb2RlID09PSAncmF3Jykge1xuICAgICAgICAgICAgcmVjdCA9IGVsLnR5cGUgPT09ICdncm91cCdcbiAgICAgICAgICAgICAgICA/IG5ldyBCb3VuZGluZ1JlY3QoMCwgMCwgK3Bvc2l0aW9uSW5mby53aWR0aCB8fCAwLCArcG9zaXRpb25JbmZvLmhlaWdodCB8fCAwKVxuICAgICAgICAgICAgICAgIDogZWwuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZWN0ID0gZWwuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgICAgICAgICBpZiAoZWwubmVlZExvY2FsVHJhbnNmb3JtKCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdHJhbnNmb3JtID0gZWwuZ2V0TG9jYWxUcmFuc2Zvcm0oKTtcbiAgICAgICAgICAgICAgICAvLyBOb3RpY2U6IHJhdyByZWN0IG1heSBiZSBpbm5lciBvYmplY3Qgb2YgZWwsXG4gICAgICAgICAgICAgICAgLy8gd2hpY2ggc2hvdWxkIG5vdCBiZSBtb2RpZmllZC5cbiAgICAgICAgICAgICAgICByZWN0ID0gcmVjdC5jbG9uZSgpO1xuICAgICAgICAgICAgICAgIHJlY3QuYXBwbHlUcmFuc2Zvcm0odHJhbnNmb3JtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHBvc2l0aW9uSW5mbyA9IGxheW91dC5nZXRMYXlvdXRSZWN0KFxuICAgICAgICAgICAgenJVdGlsLmRlZmF1bHRzKFxuICAgICAgICAgICAgICAgIHt3aWR0aDogcmVjdC53aWR0aCwgaGVpZ2h0OiByZWN0LmhlaWdodH0sXG4gICAgICAgICAgICAgICAgcG9zaXRpb25JbmZvXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgY29udGFpbmVyUmVjdCxcbiAgICAgICAgICAgIG1hcmdpblxuICAgICAgICApO1xuXG4gICAgICAgIC8vIEJlY2F1c2UgJ3RyYW5sYXRlJyBpcyB0aGUgbGFzdCBzdGVwIGluIHRyYW5zZm9ybVxuICAgICAgICAvLyAoc2VlIHpyZW5kZXIvY29yZS9UcmFuc2Zvcm1hYmxlI2dldExvY2FsVHJhbnNmcm9tKSxcbiAgICAgICAgLy8gd2UgY2FuIGp1c3Qgb25seSBtb2RpZnkgZWwucG9zaXRpb24gdG8gZ2V0IGZpbmFsIHJlc3VsdC5cbiAgICAgICAgdmFyIGVsUG9zID0gZWwucG9zaXRpb247XG4gICAgICAgIHZhciBkeCA9IGggPyBwb3NpdGlvbkluZm8ueCAtIHJlY3QueCA6IDA7XG4gICAgICAgIHZhciBkeSA9IHYgPyBwb3NpdGlvbkluZm8ueSAtIHJlY3QueSA6IDA7XG5cbiAgICAgICAgZWwuYXR0cigncG9zaXRpb24nLCBib3VuZGluZ01vZGUgPT09ICdyYXcnID8gW2R4LCBkeV0gOiBbZWxQb3NbMF0gKyBkeCwgZWxQb3NbMV0gKyBkeV0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uIENvbnRhaW5zIHNvbWUgb2YgdGhlIHByb3BlcnRpZXMgaW4gSFZfTkFNRVMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGh2SWR4IDA6IGhvcml6b250YWw7IDE6IHZlcnRpY2FsLlxuICAgICAqL1xuICAgIGxheW91dC5zaXplQ2FsY3VsYWJsZSA9IGZ1bmN0aW9uIChvcHRpb24sIGh2SWR4KSB7XG4gICAgICAgIHJldHVybiBvcHRpb25bSFZfTkFNRVNbaHZJZHhdWzBdXSAhPSBudWxsXG4gICAgICAgICAgICB8fCAob3B0aW9uW0hWX05BTUVTW2h2SWR4XVsxXV0gIT0gbnVsbCAmJiBvcHRpb25bSFZfTkFNRVNbaHZJZHhdWzJdXSAhPSBudWxsKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ29uc2lkZXIgQ2FzZTpcbiAgICAgKiBXaGVuIGRlZnVsYXQgb3B0aW9uIGhhcyB7bGVmdDogMCwgd2lkdGg6IDEwMH0sIGFuZCB3ZSBzZXQge3JpZ2h0OiAwfVxuICAgICAqIHRocm91Z2ggc2V0T3B0aW9uIG9yIG1lZGlhIHF1ZXJ5LCB1c2luZyBub3JtYWwgenJVdGlsLm1lcmdlIHdpbGwgY2F1c2VcbiAgICAgKiB7cmlnaHQ6IDB9IGRvZXMgbm90IHRha2UgZWZmZWN0LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBDb21wb25lbnRNb2RlbC5leHRlbmQoe1xuICAgICAqICAgICBpbml0OiBmdW5jdGlvbiAoKSB7XG4gICAgICogICAgICAgICAuLi5cbiAgICAgKiAgICAgICAgIHZhciBpbnB1dFBvc2l0aW9uUGFyYW1zID0gbGF5b3V0LmdldExheW91dFBhcmFtcyhvcHRpb24pO1xuICAgICAqICAgICAgICAgdGhpcy5tZXJnZU9wdGlvbihpbnB1dFBvc2l0aW9uUGFyYW1zKTtcbiAgICAgKiAgICAgfSxcbiAgICAgKiAgICAgbWVyZ2VPcHRpb246IGZ1bmN0aW9uIChuZXdPcHRpb24pIHtcbiAgICAgKiAgICAgICAgIG5ld09wdGlvbiAmJiB6clV0aWwubWVyZ2UodGhpc09wdGlvbiwgbmV3T3B0aW9uLCB0cnVlKTtcbiAgICAgKiAgICAgICAgIGxheW91dC5tZXJnZUxheW91dFBhcmFtKHRoaXNPcHRpb24sIG5ld09wdGlvbik7XG4gICAgICogICAgIH1cbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRPcHRpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbmV3T3B0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R8c3RyaW5nfSBbb3B0XVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbnxBcnJheS48Ym9vbGVhbj59IFtvcHQuaWdub3JlU2l6ZT1mYWxzZV0gU29tZSBjb21wb25lbnQgbXVzdCBoYXMgd2lkdGggYW5kIGhlaWdodC5cbiAgICAgKi9cbiAgICBsYXlvdXQubWVyZ2VMYXlvdXRQYXJhbSA9IGZ1bmN0aW9uICh0YXJnZXRPcHRpb24sIG5ld09wdGlvbiwgb3B0KSB7XG4gICAgICAgICF6clV0aWwuaXNPYmplY3Qob3B0KSAmJiAob3B0ID0ge30pO1xuXG4gICAgICAgIHZhciBpZ25vcmVTaXplID0gb3B0Lmlnbm9yZVNpemU7XG4gICAgICAgICF6clV0aWwuaXNBcnJheShpZ25vcmVTaXplKSAmJiAoaWdub3JlU2l6ZSA9IFtpZ25vcmVTaXplLCBpZ25vcmVTaXplXSk7XG5cbiAgICAgICAgdmFyIGhSZXN1bHQgPSBtZXJnZShIVl9OQU1FU1swXSwgMCk7XG4gICAgICAgIHZhciB2UmVzdWx0ID0gbWVyZ2UoSFZfTkFNRVNbMV0sIDEpO1xuXG4gICAgICAgIGNvcHkoSFZfTkFNRVNbMF0sIHRhcmdldE9wdGlvbiwgaFJlc3VsdCk7XG4gICAgICAgIGNvcHkoSFZfTkFNRVNbMV0sIHRhcmdldE9wdGlvbiwgdlJlc3VsdCk7XG5cbiAgICAgICAgZnVuY3Rpb24gbWVyZ2UobmFtZXMsIGh2SWR4KSB7XG4gICAgICAgICAgICB2YXIgbmV3UGFyYW1zID0ge307XG4gICAgICAgICAgICB2YXIgbmV3VmFsdWVDb3VudCA9IDA7XG4gICAgICAgICAgICB2YXIgbWVyZ2VkID0ge307XG4gICAgICAgICAgICB2YXIgbWVyZ2VkVmFsdWVDb3VudCA9IDA7XG4gICAgICAgICAgICB2YXIgZW5vdWdoUGFyYW1OdW1iZXIgPSAyO1xuXG4gICAgICAgICAgICBlYWNoKG5hbWVzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICAgIG1lcmdlZFtuYW1lXSA9IHRhcmdldE9wdGlvbltuYW1lXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZWFjaChuYW1lcywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgICAgICAvLyBDb25zaWRlciBjYXNlOiBuZXdPcHRpb24ud2lkdGggaXMgbnVsbCwgd2hpY2ggaXNcbiAgICAgICAgICAgICAgICAvLyBzZXQgYnkgdXNlciBmb3IgcmVtb3Zpbmcgd2lkdGggc2V0dGluZy5cbiAgICAgICAgICAgICAgICBoYXNQcm9wKG5ld09wdGlvbiwgbmFtZSkgJiYgKG5ld1BhcmFtc1tuYW1lXSA9IG1lcmdlZFtuYW1lXSA9IG5ld09wdGlvbltuYW1lXSk7XG4gICAgICAgICAgICAgICAgaGFzVmFsdWUobmV3UGFyYW1zLCBuYW1lKSAmJiBuZXdWYWx1ZUNvdW50Kys7XG4gICAgICAgICAgICAgICAgaGFzVmFsdWUobWVyZ2VkLCBuYW1lKSAmJiBtZXJnZWRWYWx1ZUNvdW50Kys7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKGlnbm9yZVNpemVbaHZJZHhdKSB7XG4gICAgICAgICAgICAgICAgLy8gT25seSBvbmUgb2YgbGVmdC9yaWdodCBpcyBwcmVtaXR0ZWQgdG8gZXhpc3QuXG4gICAgICAgICAgICAgICAgaWYgKGhhc1ZhbHVlKG5ld09wdGlvbiwgbmFtZXNbMV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lcmdlZFtuYW1lc1syXV0gPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChoYXNWYWx1ZShuZXdPcHRpb24sIG5hbWVzWzJdKSkge1xuICAgICAgICAgICAgICAgICAgICBtZXJnZWRbbmFtZXNbMV1dID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lcmdlZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ2FzZTogbmV3T3B0aW9uOiB7d2lkdGg6IC4uLiwgcmlnaHQ6IC4uLn0sXG4gICAgICAgICAgICAvLyBvciB0YXJnZXRPcHRpb246IHtyaWdodDogLi4ufSBhbmQgbmV3T3B0aW9uOiB7d2lkdGg6IC4uLn0sXG4gICAgICAgICAgICAvLyBUaGVyZSBpcyBubyBjb25mbGljdCB3aGVuIG1lcmdlZCBvbmx5IGhhcyBwYXJhbXMgY291bnRcbiAgICAgICAgICAgIC8vIGxpdHRsZSB0aGFuIGVub3VnaFBhcmFtTnVtYmVyLlxuICAgICAgICAgICAgaWYgKG1lcmdlZFZhbHVlQ291bnQgPT09IGVub3VnaFBhcmFtTnVtYmVyIHx8ICFuZXdWYWx1ZUNvdW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lcmdlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENhc2U6IG5ld09wdGlvbjoge3dpZHRoOiAuLi4sIHJpZ2h0OiAuLi59LFxuICAgICAgICAgICAgLy8gVGhhbiB3ZSBjYW4gbWFrZSBzdXJlIHVzZXIgb25seSB3YW50IHRob3NlIHR3bywgYW5kIGlnbm9yZVxuICAgICAgICAgICAgLy8gYWxsIG9yaWdpbiBwYXJhbXMgaW4gdGFyZ2V0T3B0aW9uLlxuICAgICAgICAgICAgZWxzZSBpZiAobmV3VmFsdWVDb3VudCA+PSBlbm91Z2hQYXJhbU51bWJlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXdQYXJhbXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBDaG9zZSBhbm90aGVyIHBhcmFtIGZyb20gdGFyZ2V0T3B0aW9uIGJ5IHByaW9yaXR5LlxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBuYW1lc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFoYXNQcm9wKG5ld1BhcmFtcywgbmFtZSkgJiYgaGFzUHJvcCh0YXJnZXRPcHRpb24sIG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdQYXJhbXNbbmFtZV0gPSB0YXJnZXRPcHRpb25bbmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3UGFyYW1zO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaGFzUHJvcChvYmosIG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmouaGFzT3duUHJvcGVydHkobmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBoYXNWYWx1ZShvYmosIG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmpbbmFtZV0gIT0gbnVsbCAmJiBvYmpbbmFtZV0gIT09ICdhdXRvJztcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGNvcHkobmFtZXMsIHRhcmdldCwgc291cmNlKSB7XG4gICAgICAgICAgICBlYWNoKG5hbWVzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICAgIHRhcmdldFtuYW1lXSA9IHNvdXJjZVtuYW1lXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlICdsZWZ0JywgJ3JpZ2h0JywgJ3RvcCcsICdib3R0b20nLCAnd2lkdGgnLCAnaGVpZ2h0JyBmcm9tIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBSZXN1bHQgY29udGFpbnMgdGhvc2UgcHJvcHMuXG4gICAgICovXG4gICAgbGF5b3V0LmdldExheW91dFBhcmFtcyA9IGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIGxheW91dC5jb3B5TGF5b3V0UGFyYW1zKHt9LCBzb3VyY2UpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSAnbGVmdCcsICdyaWdodCcsICd0b3AnLCAnYm90dG9tJywgJ3dpZHRoJywgJ2hlaWdodCcgZnJvbSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gUmVzdWx0IGNvbnRhaW5zIHRob3NlIHByb3BzLlxuICAgICAqL1xuICAgIGxheW91dC5jb3B5TGF5b3V0UGFyYW1zID0gZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKSB7XG4gICAgICAgIHNvdXJjZSAmJiB0YXJnZXQgJiYgZWFjaChMT0NBVElPTl9QQVJBTVMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICBzb3VyY2UuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgKHRhcmdldFtuYW1lXSA9IHNvdXJjZVtuYW1lXSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGxheW91dDtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvdXRpbC9sYXlvdXQuanNcbi8vIG1vZHVsZSBpZCA9IDExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 12 */
/* unknown exports provided */
/* all exports used */
/*!********************************!*\
  !*** ./lib/model/Component.js ***!
  \********************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Component model\n *\n * @module echarts/model/Component\n */\n\n\n    var Model = __webpack_require__(/*! ./Model */ 9);\n    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 0);\n    var arrayPush = Array.prototype.push;\n    var componentUtil = __webpack_require__(/*! ../util/component */ 49);\n    var clazzUtil = __webpack_require__(/*! ../util/clazz */ 14);\n    var layout = __webpack_require__(/*! ../util/layout */ 11);\n\n    /**\n     * @alias module:echarts/model/Component\n     * @constructor\n     * @param {Object} option\n     * @param {module:echarts/model/Model} parentModel\n     * @param {module:echarts/model/Model} ecModel\n     */\n    var ComponentModel = Model.extend({\n\n        type: 'component',\n\n        /**\n         * @readOnly\n         * @type {string}\n         */\n        id: '',\n\n        /**\n         * @readOnly\n         */\n        name: '',\n\n        /**\n         * @readOnly\n         * @type {string}\n         */\n        mainType: '',\n\n        /**\n         * @readOnly\n         * @type {string}\n         */\n        subType: '',\n\n        /**\n         * @readOnly\n         * @type {number}\n         */\n        componentIndex: 0,\n\n        /**\n         * @type {Object}\n         * @protected\n         */\n        defaultOption: null,\n\n        /**\n         * @type {module:echarts/model/Global}\n         * @readOnly\n         */\n        ecModel: null,\n\n        /**\n         * key: componentType\n         * value:  Component model list, can not be null.\n         * @type {Object.<string, Array.<module:echarts/model/Model>>}\n         * @readOnly\n         */\n        dependentModels: [],\n\n        /**\n         * @type {string}\n         * @readOnly\n         */\n        uid: null,\n\n        /**\n         * Support merge layout params.\n         * Only support 'box' now (left/right/top/bottom/width/height).\n         * @type {string|Object} Object can be {ignoreSize: true}\n         * @readOnly\n         */\n        layoutMode: null,\n\n        $constructor: function (option, parentModel, ecModel, extraOpt) {\n            Model.call(this, option, parentModel, ecModel, extraOpt);\n\n            this.uid = componentUtil.getUID('componentModel');\n        },\n\n\n        init: function (option, parentModel, ecModel, extraOpt) {\n            this.mergeDefaultAndTheme(option, ecModel);\n        },\n\n        mergeDefaultAndTheme: function (option, ecModel) {\n            var layoutMode = this.layoutMode;\n            var inputPositionParams = layoutMode\n                ? layout.getLayoutParams(option) : {};\n\n            var themeModel = ecModel.getTheme();\n            zrUtil.merge(option, themeModel.get(this.mainType));\n            zrUtil.merge(option, this.getDefaultOption());\n\n            if (layoutMode) {\n                layout.mergeLayoutParam(option, inputPositionParams, layoutMode);\n            }\n        },\n\n        mergeOption: function (option, extraOpt) {\n            zrUtil.merge(this.option, option, true);\n\n            var layoutMode = this.layoutMode;\n            if (layoutMode) {\n                layout.mergeLayoutParam(this.option, option, layoutMode);\n            }\n        },\n\n        // Hooker after init or mergeOption\n        optionUpdated: function (newCptOption, isInit) {},\n\n        getDefaultOption: function () {\n            if (!clazzUtil.hasOwn(this, '__defaultOption')) {\n                var optList = [];\n                var Class = this.constructor;\n                while (Class) {\n                    var opt = Class.prototype.defaultOption;\n                    opt && optList.push(opt);\n                    Class = Class.superClass;\n                }\n\n                var defaultOption = {};\n                for (var i = optList.length - 1; i >= 0; i--) {\n                    defaultOption = zrUtil.merge(defaultOption, optList[i], true);\n                }\n                clazzUtil.set(this, '__defaultOption', defaultOption);\n            }\n            return clazzUtil.get(this, '__defaultOption');\n        },\n\n        getReferringComponents: function (mainType) {\n            return this.ecModel.queryComponents({\n                mainType: mainType,\n                index: this.get(mainType + 'Index', true),\n                id: this.get(mainType + 'Id', true)\n            });\n        }\n\n    });\n\n    // Reset ComponentModel.extend, add preConstruct.\n    // clazzUtil.enableClassExtend(\n    //     ComponentModel,\n    //     function (option, parentModel, ecModel, extraOpt) {\n    //         // Set dependentModels, componentIndex, name, id, mainType, subType.\n    //         zrUtil.extend(this, extraOpt);\n\n    //         this.uid = componentUtil.getUID('componentModel');\n\n    //         // this.setReadOnly([\n    //         //     'type', 'id', 'uid', 'name', 'mainType', 'subType',\n    //         //     'dependentModels', 'componentIndex'\n    //         // ]);\n    //     }\n    // );\n\n    // Add capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n    clazzUtil.enableClassManagement(\n        ComponentModel, {registerWhenExtend: true}\n    );\n    componentUtil.enableSubTypeDefaulter(ComponentModel);\n\n    // Add capability of ComponentModel.topologicalTravel.\n    componentUtil.enableTopologicalTravel(ComponentModel, getDependencies);\n\n    function getDependencies(componentType) {\n        var deps = [];\n        zrUtil.each(ComponentModel.getClassesByMainType(componentType), function (Clazz) {\n            arrayPush.apply(deps, Clazz.prototype.dependencies || []);\n        });\n        // Ensure main type\n        return zrUtil.map(deps, function (type) {\n            return clazzUtil.parseClassType(type).main;\n        });\n    }\n\n    zrUtil.mixin(ComponentModel, __webpack_require__(/*! ./mixin/boxLayout */ 171));\n\n    module.exports = ComponentModel;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvbW9kZWwvQ29tcG9uZW50LmpzPzQ5NjgiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb21wb25lbnQgbW9kZWxcbiAqXG4gKiBAbW9kdWxlIGVjaGFydHMvbW9kZWwvQ29tcG9uZW50XG4gKi9cblxuXG4gICAgdmFyIE1vZGVsID0gcmVxdWlyZSgnLi9Nb2RlbCcpO1xuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgYXJyYXlQdXNoID0gQXJyYXkucHJvdG90eXBlLnB1c2g7XG4gICAgdmFyIGNvbXBvbmVudFV0aWwgPSByZXF1aXJlKCcuLi91dGlsL2NvbXBvbmVudCcpO1xuICAgIHZhciBjbGF6elV0aWwgPSByZXF1aXJlKCcuLi91dGlsL2NsYXp6Jyk7XG4gICAgdmFyIGxheW91dCA9IHJlcXVpcmUoJy4uL3V0aWwvbGF5b3V0Jyk7XG5cbiAgICAvKipcbiAgICAgKiBAYWxpYXMgbW9kdWxlOmVjaGFydHMvbW9kZWwvQ29tcG9uZW50XG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvblxuICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWx9IHBhcmVudE1vZGVsXG4gICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH0gZWNNb2RlbFxuICAgICAqL1xuICAgIHZhciBDb21wb25lbnRNb2RlbCA9IE1vZGVsLmV4dGVuZCh7XG5cbiAgICAgICAgdHlwZTogJ2NvbXBvbmVudCcsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZWFkT25seVxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgaWQ6ICcnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmVhZE9ubHlcbiAgICAgICAgICovXG4gICAgICAgIG5hbWU6ICcnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmVhZE9ubHlcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIG1haW5UeXBlOiAnJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJlYWRPbmx5XG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICBzdWJUeXBlOiAnJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJlYWRPbmx5XG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBjb21wb25lbnRJbmRleDogMCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgZGVmYXVsdE9wdGlvbjogbnVsbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge21vZHVsZTplY2hhcnRzL21vZGVsL0dsb2JhbH1cbiAgICAgICAgICogQHJlYWRPbmx5XG4gICAgICAgICAqL1xuICAgICAgICBlY01vZGVsOiBudWxsLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBrZXk6IGNvbXBvbmVudFR5cGVcbiAgICAgICAgICogdmFsdWU6ICBDb21wb25lbnQgbW9kZWwgbGlzdCwgY2FuIG5vdCBiZSBudWxsLlxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsIEFycmF5Ljxtb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbD4+fVxuICAgICAgICAgKiBAcmVhZE9ubHlcbiAgICAgICAgICovXG4gICAgICAgIGRlcGVuZGVudE1vZGVsczogW10sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqIEByZWFkT25seVxuICAgICAgICAgKi9cbiAgICAgICAgdWlkOiBudWxsLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdXBwb3J0IG1lcmdlIGxheW91dCBwYXJhbXMuXG4gICAgICAgICAqIE9ubHkgc3VwcG9ydCAnYm94JyBub3cgKGxlZnQvcmlnaHQvdG9wL2JvdHRvbS93aWR0aC9oZWlnaHQpLlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfE9iamVjdH0gT2JqZWN0IGNhbiBiZSB7aWdub3JlU2l6ZTogdHJ1ZX1cbiAgICAgICAgICogQHJlYWRPbmx5XG4gICAgICAgICAqL1xuICAgICAgICBsYXlvdXRNb2RlOiBudWxsLFxuXG4gICAgICAgICRjb25zdHJ1Y3RvcjogZnVuY3Rpb24gKG9wdGlvbiwgcGFyZW50TW9kZWwsIGVjTW9kZWwsIGV4dHJhT3B0KSB7XG4gICAgICAgICAgICBNb2RlbC5jYWxsKHRoaXMsIG9wdGlvbiwgcGFyZW50TW9kZWwsIGVjTW9kZWwsIGV4dHJhT3B0KTtcblxuICAgICAgICAgICAgdGhpcy51aWQgPSBjb21wb25lbnRVdGlsLmdldFVJRCgnY29tcG9uZW50TW9kZWwnKTtcbiAgICAgICAgfSxcblxuXG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uIChvcHRpb24sIHBhcmVudE1vZGVsLCBlY01vZGVsLCBleHRyYU9wdCkge1xuICAgICAgICAgICAgdGhpcy5tZXJnZURlZmF1bHRBbmRUaGVtZShvcHRpb24sIGVjTW9kZWwpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG1lcmdlRGVmYXVsdEFuZFRoZW1lOiBmdW5jdGlvbiAob3B0aW9uLCBlY01vZGVsKSB7XG4gICAgICAgICAgICB2YXIgbGF5b3V0TW9kZSA9IHRoaXMubGF5b3V0TW9kZTtcbiAgICAgICAgICAgIHZhciBpbnB1dFBvc2l0aW9uUGFyYW1zID0gbGF5b3V0TW9kZVxuICAgICAgICAgICAgICAgID8gbGF5b3V0LmdldExheW91dFBhcmFtcyhvcHRpb24pIDoge307XG5cbiAgICAgICAgICAgIHZhciB0aGVtZU1vZGVsID0gZWNNb2RlbC5nZXRUaGVtZSgpO1xuICAgICAgICAgICAgenJVdGlsLm1lcmdlKG9wdGlvbiwgdGhlbWVNb2RlbC5nZXQodGhpcy5tYWluVHlwZSkpO1xuICAgICAgICAgICAgenJVdGlsLm1lcmdlKG9wdGlvbiwgdGhpcy5nZXREZWZhdWx0T3B0aW9uKCkpO1xuXG4gICAgICAgICAgICBpZiAobGF5b3V0TW9kZSkge1xuICAgICAgICAgICAgICAgIGxheW91dC5tZXJnZUxheW91dFBhcmFtKG9wdGlvbiwgaW5wdXRQb3NpdGlvblBhcmFtcywgbGF5b3V0TW9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgbWVyZ2VPcHRpb246IGZ1bmN0aW9uIChvcHRpb24sIGV4dHJhT3B0KSB7XG4gICAgICAgICAgICB6clV0aWwubWVyZ2UodGhpcy5vcHRpb24sIG9wdGlvbiwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIHZhciBsYXlvdXRNb2RlID0gdGhpcy5sYXlvdXRNb2RlO1xuICAgICAgICAgICAgaWYgKGxheW91dE1vZGUpIHtcbiAgICAgICAgICAgICAgICBsYXlvdXQubWVyZ2VMYXlvdXRQYXJhbSh0aGlzLm9wdGlvbiwgb3B0aW9uLCBsYXlvdXRNb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBIb29rZXIgYWZ0ZXIgaW5pdCBvciBtZXJnZU9wdGlvblxuICAgICAgICBvcHRpb25VcGRhdGVkOiBmdW5jdGlvbiAobmV3Q3B0T3B0aW9uLCBpc0luaXQpIHt9LFxuXG4gICAgICAgIGdldERlZmF1bHRPcHRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghY2xhenpVdGlsLmhhc093bih0aGlzLCAnX19kZWZhdWx0T3B0aW9uJykpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3B0TGlzdCA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBDbGFzcyA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgICAgICAgICAgICAgd2hpbGUgKENsYXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvcHQgPSBDbGFzcy5wcm90b3R5cGUuZGVmYXVsdE9wdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgb3B0ICYmIG9wdExpc3QucHVzaChvcHQpO1xuICAgICAgICAgICAgICAgICAgICBDbGFzcyA9IENsYXNzLnN1cGVyQ2xhc3M7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGRlZmF1bHRPcHRpb24gPSB7fTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gb3B0TGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0T3B0aW9uID0genJVdGlsLm1lcmdlKGRlZmF1bHRPcHRpb24sIG9wdExpc3RbaV0sIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjbGF6elV0aWwuc2V0KHRoaXMsICdfX2RlZmF1bHRPcHRpb24nLCBkZWZhdWx0T3B0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjbGF6elV0aWwuZ2V0KHRoaXMsICdfX2RlZmF1bHRPcHRpb24nKTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRSZWZlcnJpbmdDb21wb25lbnRzOiBmdW5jdGlvbiAobWFpblR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVjTW9kZWwucXVlcnlDb21wb25lbnRzKHtcbiAgICAgICAgICAgICAgICBtYWluVHlwZTogbWFpblR5cGUsXG4gICAgICAgICAgICAgICAgaW5kZXg6IHRoaXMuZ2V0KG1haW5UeXBlICsgJ0luZGV4JywgdHJ1ZSksXG4gICAgICAgICAgICAgICAgaWQ6IHRoaXMuZ2V0KG1haW5UeXBlICsgJ0lkJywgdHJ1ZSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICB9KTtcblxuICAgIC8vIFJlc2V0IENvbXBvbmVudE1vZGVsLmV4dGVuZCwgYWRkIHByZUNvbnN0cnVjdC5cbiAgICAvLyBjbGF6elV0aWwuZW5hYmxlQ2xhc3NFeHRlbmQoXG4gICAgLy8gICAgIENvbXBvbmVudE1vZGVsLFxuICAgIC8vICAgICBmdW5jdGlvbiAob3B0aW9uLCBwYXJlbnRNb2RlbCwgZWNNb2RlbCwgZXh0cmFPcHQpIHtcbiAgICAvLyAgICAgICAgIC8vIFNldCBkZXBlbmRlbnRNb2RlbHMsIGNvbXBvbmVudEluZGV4LCBuYW1lLCBpZCwgbWFpblR5cGUsIHN1YlR5cGUuXG4gICAgLy8gICAgICAgICB6clV0aWwuZXh0ZW5kKHRoaXMsIGV4dHJhT3B0KTtcblxuICAgIC8vICAgICAgICAgdGhpcy51aWQgPSBjb21wb25lbnRVdGlsLmdldFVJRCgnY29tcG9uZW50TW9kZWwnKTtcblxuICAgIC8vICAgICAgICAgLy8gdGhpcy5zZXRSZWFkT25seShbXG4gICAgLy8gICAgICAgICAvLyAgICAgJ3R5cGUnLCAnaWQnLCAndWlkJywgJ25hbWUnLCAnbWFpblR5cGUnLCAnc3ViVHlwZScsXG4gICAgLy8gICAgICAgICAvLyAgICAgJ2RlcGVuZGVudE1vZGVscycsICdjb21wb25lbnRJbmRleCdcbiAgICAvLyAgICAgICAgIC8vIF0pO1xuICAgIC8vICAgICB9XG4gICAgLy8gKTtcblxuICAgIC8vIEFkZCBjYXBhYmlsaXR5IG9mIHJlZ2lzdGVyQ2xhc3MsIGdldENsYXNzLCBoYXNDbGFzcywgcmVnaXN0ZXJTdWJUeXBlRGVmYXVsdGVyIGFuZCBzbyBvbi5cbiAgICBjbGF6elV0aWwuZW5hYmxlQ2xhc3NNYW5hZ2VtZW50KFxuICAgICAgICBDb21wb25lbnRNb2RlbCwge3JlZ2lzdGVyV2hlbkV4dGVuZDogdHJ1ZX1cbiAgICApO1xuICAgIGNvbXBvbmVudFV0aWwuZW5hYmxlU3ViVHlwZURlZmF1bHRlcihDb21wb25lbnRNb2RlbCk7XG5cbiAgICAvLyBBZGQgY2FwYWJpbGl0eSBvZiBDb21wb25lbnRNb2RlbC50b3BvbG9naWNhbFRyYXZlbC5cbiAgICBjb21wb25lbnRVdGlsLmVuYWJsZVRvcG9sb2dpY2FsVHJhdmVsKENvbXBvbmVudE1vZGVsLCBnZXREZXBlbmRlbmNpZXMpO1xuXG4gICAgZnVuY3Rpb24gZ2V0RGVwZW5kZW5jaWVzKGNvbXBvbmVudFR5cGUpIHtcbiAgICAgICAgdmFyIGRlcHMgPSBbXTtcbiAgICAgICAgenJVdGlsLmVhY2goQ29tcG9uZW50TW9kZWwuZ2V0Q2xhc3Nlc0J5TWFpblR5cGUoY29tcG9uZW50VHlwZSksIGZ1bmN0aW9uIChDbGF6eikge1xuICAgICAgICAgICAgYXJyYXlQdXNoLmFwcGx5KGRlcHMsIENsYXp6LnByb3RvdHlwZS5kZXBlbmRlbmNpZXMgfHwgW10pO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gRW5zdXJlIG1haW4gdHlwZVxuICAgICAgICByZXR1cm4genJVdGlsLm1hcChkZXBzLCBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIGNsYXp6VXRpbC5wYXJzZUNsYXNzVHlwZSh0eXBlKS5tYWluO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB6clV0aWwubWl4aW4oQ29tcG9uZW50TW9kZWwsIHJlcXVpcmUoJy4vbWl4aW4vYm94TGF5b3V0JykpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBDb21wb25lbnRNb2RlbDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL21vZGVsL0NvbXBvbmVudC5qc1xuLy8gbW9kdWxlIGlkID0gMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 13 */
/* unknown exports provided */
/* all exports used */
/*!**************************!*\
  !*** ./lib/data/List.js ***!
  \**************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {/**\n * List for data storage\n * @module echarts/data/List\n */\n\n\n    var UNDEFINED = 'undefined';\n    var globalObj = typeof window === 'undefined' ? global : window;\n    var Float64Array = typeof globalObj.Float64Array === UNDEFINED\n        ? Array : globalObj.Float64Array;\n    var Int32Array = typeof globalObj.Int32Array === UNDEFINED\n        ? Array : globalObj.Int32Array;\n\n    var dataCtors = {\n        'float': Float64Array,\n        'int': Int32Array,\n        // Ordinal data type can be string or int\n        'ordinal': Array,\n        'number': Array,\n        'time': Array\n    };\n\n    var Model = __webpack_require__(/*! ../model/Model */ 9);\n    var DataDiffer = __webpack_require__(/*! ./DataDiffer */ 48);\n\n    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 0);\n    var modelUtil = __webpack_require__(/*! ../util/model */ 5);\n    var isObject = zrUtil.isObject;\n\n    var TRANSFERABLE_PROPERTIES = [\n        'stackedOn', 'hasItemOption', '_nameList', '_idList', '_rawData'\n    ];\n\n    var transferProperties = function (a, b) {\n        zrUtil.each(TRANSFERABLE_PROPERTIES.concat(b.__wrappedMethods || []), function (propName) {\n            if (b.hasOwnProperty(propName)) {\n                a[propName] = b[propName];\n            }\n        });\n\n        a.__wrappedMethods = b.__wrappedMethods;\n    };\n\n    /**\n     * @constructor\n     * @alias module:echarts/data/List\n     *\n     * @param {Array.<string|Object>} dimensions\n     *      For example, ['someDimName', {name: 'someDimName', type: 'someDimType'}, ...].\n     *      Dimensions should be concrete names like x, y, z, lng, lat, angle, radius\n     * @param {module:echarts/model/Model} hostModel\n     */\n    var List = function (dimensions, hostModel) {\n\n        dimensions = dimensions || ['x', 'y'];\n\n        var dimensionInfos = {};\n        var dimensionNames = [];\n        for (var i = 0; i < dimensions.length; i++) {\n            var dimensionName;\n            var dimensionInfo = {};\n            if (typeof dimensions[i] === 'string') {\n                dimensionName = dimensions[i];\n                dimensionInfo = {\n                    name: dimensionName,\n                    stackable: false,\n                    // Type can be 'float', 'int', 'number'\n                    // Default is number, Precision of float may not enough\n                    type: 'number'\n                };\n            }\n            else {\n                dimensionInfo = dimensions[i];\n                dimensionName = dimensionInfo.name;\n                dimensionInfo.type = dimensionInfo.type || 'number';\n            }\n            dimensionNames.push(dimensionName);\n            dimensionInfos[dimensionName] = dimensionInfo;\n        }\n        /**\n         * @readOnly\n         * @type {Array.<string>}\n         */\n        this.dimensions = dimensionNames;\n\n        /**\n         * Infomation of each data dimension, like data type.\n         * @type {Object}\n         */\n        this._dimensionInfos = dimensionInfos;\n\n        /**\n         * @type {module:echarts/model/Model}\n         */\n        this.hostModel = hostModel;\n\n        /**\n         * @type {module:echarts/model/Model}\n         */\n        this.dataType;\n\n        /**\n         * Indices stores the indices of data subset after filtered.\n         * This data subset will be used in chart.\n         * @type {Array.<number>}\n         * @readOnly\n         */\n        this.indices = [];\n\n        /**\n         * Data storage\n         * @type {Object.<key, TypedArray|Array>}\n         * @private\n         */\n        this._storage = {};\n\n        /**\n         * @type {Array.<string>}\n         */\n        this._nameList = [];\n        /**\n         * @type {Array.<string>}\n         */\n        this._idList = [];\n        /**\n         * Models of data option is stored sparse for optimizing memory cost\n         * @type {Array.<module:echarts/model/Model>}\n         * @private\n         */\n        this._optionModels = [];\n\n        /**\n         * @param {module:echarts/data/List}\n         */\n        this.stackedOn = null;\n\n        /**\n         * Global visual properties after visual coding\n         * @type {Object}\n         * @private\n         */\n        this._visual = {};\n\n        /**\n         * Globel layout properties.\n         * @type {Object}\n         * @private\n         */\n        this._layout = {};\n\n        /**\n         * Item visual properties after visual coding\n         * @type {Array.<Object>}\n         * @private\n         */\n        this._itemVisuals = [];\n\n        /**\n         * Item layout properties after layout\n         * @type {Array.<Object>}\n         * @private\n         */\n        this._itemLayouts = [];\n\n        /**\n         * Graphic elemnents\n         * @type {Array.<module:zrender/Element>}\n         * @private\n         */\n        this._graphicEls = [];\n\n        /**\n         * @type {Array.<Array|Object>}\n         * @private\n         */\n        this._rawData;\n\n        /**\n         * @type {Object}\n         * @private\n         */\n        this._extent;\n    };\n\n    var listProto = List.prototype;\n\n    listProto.type = 'list';\n    /**\n     * If each data item has it's own option\n     * @type {boolean}\n     */\n    listProto.hasItemOption = true;\n\n    /**\n     * Get dimension name\n     * @param {string|number} dim\n     *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n     *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n     * @return {string} Concrete dim name.\n     */\n    listProto.getDimension = function (dim) {\n        if (!isNaN(dim)) {\n            dim = this.dimensions[dim] || dim;\n        }\n        return dim;\n    };\n    /**\n     * Get type and stackable info of particular dimension\n     * @param {string|number} dim\n     *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n     *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n     */\n    listProto.getDimensionInfo = function (dim) {\n        return zrUtil.clone(this._dimensionInfos[this.getDimension(dim)]);\n    };\n\n    /**\n     * Initialize from data\n     * @param {Array.<Object|number|Array>} data\n     * @param {Array.<string>} [nameList]\n     * @param {Function} [dimValueGetter] (dataItem, dimName, dataIndex, dimIndex) => number\n     */\n    listProto.initData = function (data, nameList, dimValueGetter) {\n        data = data || [];\n\n        if (true) {\n            if (!zrUtil.isArray(data)) {\n                throw new Error('Invalid data.');\n            }\n        }\n\n        this._rawData = data;\n\n        // Clear\n        var storage = this._storage = {};\n        var indices = this.indices = [];\n\n        var dimensions = this.dimensions;\n        var size = data.length;\n        var dimensionInfoMap = this._dimensionInfos;\n\n        var idList = [];\n        var nameRepeatCount = {};\n\n        nameList = nameList || [];\n\n        // Init storage\n        for (var i = 0; i < dimensions.length; i++) {\n            var dimInfo = dimensionInfoMap[dimensions[i]];\n            var DataCtor = dataCtors[dimInfo.type];\n            storage[dimensions[i]] = new DataCtor(size);\n        }\n\n        var self = this;\n        if (!dimValueGetter) {\n            self.hasItemOption = false;\n        }\n        // Default dim value getter\n        dimValueGetter = dimValueGetter || function (dataItem, dimName, dataIndex, dimIndex) {\n            var value = modelUtil.getDataItemValue(dataItem);\n            // If any dataItem is like { value: 10 }\n            if (modelUtil.isDataItemOption(dataItem)) {\n                self.hasItemOption = true;\n            }\n            return modelUtil.converDataValue(\n                (value instanceof Array)\n                    ? value[dimIndex]\n                    // If value is a single number or something else not array.\n                    : value,\n                dimensionInfoMap[dimName]\n            );\n        };\n\n        for (var idx = 0; idx < data.length; idx++) {\n            var dataItem = data[idx];\n            // Each data item is value\n            // [1, 2]\n            // 2\n            // Bar chart, line chart which uses category axis\n            // only gives the 'y' value. 'x' value is the indices of cateogry\n            // Use a tempValue to normalize the value to be a (x, y) value\n\n            // Store the data by dimensions\n            for (var k = 0; k < dimensions.length; k++) {\n                var dim = dimensions[k];\n                var dimStorage = storage[dim];\n                // PENDING NULL is empty or zero\n                dimStorage[idx] = dimValueGetter(dataItem, dim, idx, k);\n            }\n\n            indices.push(idx);\n        }\n\n        // Use the name in option and create id\n        for (var i = 0; i < data.length; i++) {\n            if (!nameList[i]) {\n                if (data[i] && data[i].name != null) {\n                    nameList[i] = data[i].name;\n                }\n            }\n            var name = nameList[i] || '';\n            // Try using the id in option\n            var id = data[i] && data[i].id;\n\n            if (!id && name) {\n                // Use name as id and add counter to avoid same name\n                nameRepeatCount[name] = nameRepeatCount[name] || 0;\n                id = name;\n                if (nameRepeatCount[name] > 0) {\n                    id += '__ec__' + nameRepeatCount[name];\n                }\n                nameRepeatCount[name]++;\n            }\n            id && (idList[i] = id);\n        }\n\n        this._nameList = nameList;\n        this._idList = idList;\n    };\n\n    /**\n     * @return {number}\n     */\n    listProto.count = function () {\n        return this.indices.length;\n    };\n\n    /**\n     * Get value. Return NaN if idx is out of range.\n     * @param {string} dim Dim must be concrete name.\n     * @param {number} idx\n     * @param {boolean} stack\n     * @return {number}\n     */\n    listProto.get = function (dim, idx, stack) {\n        var storage = this._storage;\n        var dataIndex = this.indices[idx];\n\n        // If value not exists\n        if (dataIndex == null) {\n            return NaN;\n        }\n\n        var value = storage[dim] && storage[dim][dataIndex];\n        // FIXME ordinal data type is not stackable\n        if (stack) {\n            var dimensionInfo = this._dimensionInfos[dim];\n            if (dimensionInfo && dimensionInfo.stackable) {\n                var stackedOn = this.stackedOn;\n                while (stackedOn) {\n                    // Get no stacked data of stacked on\n                    var stackedValue = stackedOn.get(dim, idx);\n                    // Considering positive stack, negative stack and empty data\n                    if ((value >= 0 && stackedValue > 0)  // Positive stack\n                        || (value <= 0 && stackedValue < 0) // Negative stack\n                    ) {\n                        value += stackedValue;\n                    }\n                    stackedOn = stackedOn.stackedOn;\n                }\n            }\n        }\n        return value;\n    };\n\n    /**\n     * Get value for multi dimensions.\n     * @param {Array.<string>} [dimensions] If ignored, using all dimensions.\n     * @param {number} idx\n     * @param {boolean} stack\n     * @return {number}\n     */\n    listProto.getValues = function (dimensions, idx, stack) {\n        var values = [];\n\n        if (!zrUtil.isArray(dimensions)) {\n            stack = idx;\n            idx = dimensions;\n            dimensions = this.dimensions;\n        }\n\n        for (var i = 0, len = dimensions.length; i < len; i++) {\n            values.push(this.get(dimensions[i], idx, stack));\n        }\n\n        return values;\n    };\n\n    /**\n     * If value is NaN. Inlcuding '-'\n     * @param {string} dim\n     * @param {number} idx\n     * @return {number}\n     */\n    listProto.hasValue = function (idx) {\n        var dimensions = this.dimensions;\n        var dimensionInfos = this._dimensionInfos;\n        for (var i = 0, len = dimensions.length; i < len; i++) {\n            if (\n                // Ordinal type can be string or number\n                dimensionInfos[dimensions[i]].type !== 'ordinal'\n                && isNaN(this.get(dimensions[i], idx))\n            ) {\n                return false;\n            }\n        }\n        return true;\n    };\n\n    /**\n     * Get extent of data in one dimension\n     * @param {string} dim\n     * @param {boolean} stack\n     * @param {Function} filter\n     */\n    listProto.getDataExtent = function (dim, stack, filter) {\n        dim = this.getDimension(dim);\n        var dimData = this._storage[dim];\n        var dimInfo = this.getDimensionInfo(dim);\n        stack = (dimInfo && dimInfo.stackable) && stack;\n        var dimExtent = (this._extent || (this._extent = {}))[dim + (!!stack)];\n        var value;\n        if (dimExtent) {\n            return dimExtent;\n        }\n        // var dimInfo = this._dimensionInfos[dim];\n        if (dimData) {\n            var min = Infinity;\n            var max = -Infinity;\n            // var isOrdinal = dimInfo.type === 'ordinal';\n            for (var i = 0, len = this.count(); i < len; i++) {\n                value = this.get(dim, i, stack);\n                // FIXME\n                // if (isOrdinal && typeof value === 'string') {\n                //     value = zrUtil.indexOf(dimData, value);\n                // }\n                if (!filter || filter(value, dim, i)) {\n                    value < min && (min = value);\n                    value > max && (max = value);\n                }\n            }\n            return (this._extent[dim + !!stack] = [min, max]);\n        }\n        else {\n            return [Infinity, -Infinity];\n        }\n    };\n\n    /**\n     * Get sum of data in one dimension\n     * @param {string} dim\n     * @param {boolean} stack\n     */\n    listProto.getSum = function (dim, stack) {\n        var dimData = this._storage[dim];\n        var sum = 0;\n        if (dimData) {\n            for (var i = 0, len = this.count(); i < len; i++) {\n                var value = this.get(dim, i, stack);\n                if (!isNaN(value)) {\n                    sum += value;\n                }\n            }\n        }\n        return sum;\n    };\n\n    /**\n     * Retreive the index with given value\n     * @param {number} idx\n     * @param {number} value\n     * @return {number}\n     */\n    // FIXME Precision of float value\n    listProto.indexOf = function (dim, value) {\n        var storage = this._storage;\n        var dimData = storage[dim];\n        var indices = this.indices;\n\n        if (dimData) {\n            for (var i = 0, len = indices.length; i < len; i++) {\n                var rawIndex = indices[i];\n                if (dimData[rawIndex] === value) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    };\n\n    /**\n     * Retreive the index with given name\n     * @param {number} idx\n     * @param {number} name\n     * @return {number}\n     */\n    listProto.indexOfName = function (name) {\n        var indices = this.indices;\n        var nameList = this._nameList;\n\n        for (var i = 0, len = indices.length; i < len; i++) {\n            var rawIndex = indices[i];\n            if (nameList[rawIndex] === name) {\n                return i;\n            }\n        }\n\n        return -1;\n    };\n\n    /**\n     * Retreive the index with given raw data index\n     * @param {number} idx\n     * @param {number} name\n     * @return {number}\n     */\n    listProto.indexOfRawIndex = function (rawIndex) {\n        // Indices are ascending\n        var indices = this.indices;\n\n        // If rawIndex === dataIndex\n        var rawDataIndex = indices[rawIndex];\n        if (rawDataIndex != null && rawDataIndex === rawIndex) {\n            return rawIndex;\n        }\n\n        var left = 0;\n        var right = indices.length - 1;\n        while (left <= right) {\n            var mid = (left + right) / 2 | 0;\n            if (indices[mid] < rawIndex) {\n                left = mid + 1;\n            }\n            else if (indices[mid] > rawIndex) {\n                right = mid - 1;\n            }\n            else {\n                return mid;\n            }\n        }\n        return -1;\n    };\n\n    /**\n     * Retreive the index of nearest value\n     * @param {string} dim\n     * @param {number} value\n     * @param {boolean} stack If given value is after stacked\n     * @param {number} [maxDistance=Infinity]\n     * @return {Array.<number>} Considere multiple points has the same value.\n     */\n    listProto.indicesOfNearest = function (dim, value, stack, maxDistance) {\n        var storage = this._storage;\n        var dimData = storage[dim];\n        var nearestIndices = [];\n\n        if (!dimData) {\n            return nearestIndices;\n        }\n\n        if (maxDistance == null) {\n            maxDistance = Infinity;\n        }\n\n        var minDist = Number.MAX_VALUE;\n        var minDiff = -1;\n        for (var i = 0, len = this.count(); i < len; i++) {\n            var diff = value - this.get(dim, i, stack);\n            var dist = Math.abs(diff);\n            if (diff <= maxDistance && dist <= minDist) {\n                // For the case of two data are same on xAxis, which has sequence data.\n                // Show the nearest index\n                // https://github.com/ecomfe/echarts/issues/2869\n                if (dist < minDist || (diff >= 0 && minDiff < 0)) {\n                    minDist = dist;\n                    minDiff = diff;\n                    nearestIndices.length = 0;\n                }\n                nearestIndices.push(i);\n            }\n        }\n        return nearestIndices;\n    };\n\n    /**\n     * Get raw data index\n     * @param {number} idx\n     * @return {number}\n     */\n    listProto.getRawIndex = function (idx) {\n        var rawIdx = this.indices[idx];\n        return rawIdx == null ? -1 : rawIdx;\n    };\n\n    /**\n     * Get raw data item\n     * @param {number} idx\n     * @return {number}\n     */\n    listProto.getRawDataItem = function (idx) {\n        return this._rawData[this.getRawIndex(idx)];\n    };\n\n    /**\n     * @param {number} idx\n     * @param {boolean} [notDefaultIdx=false]\n     * @return {string}\n     */\n    listProto.getName = function (idx) {\n        return this._nameList[this.indices[idx]] || '';\n    };\n\n    /**\n     * @param {number} idx\n     * @param {boolean} [notDefaultIdx=false]\n     * @return {string}\n     */\n    listProto.getId = function (idx) {\n        return this._idList[this.indices[idx]] || (this.getRawIndex(idx) + '');\n    };\n\n\n    function normalizeDimensions(dimensions) {\n        if (!zrUtil.isArray(dimensions)) {\n            dimensions = [dimensions];\n        }\n        return dimensions;\n    }\n\n    /**\n     * Data iteration\n     * @param {string|Array.<string>}\n     * @param {Function} cb\n     * @param {boolean} [stack=false]\n     * @param {*} [context=this]\n     *\n     * @example\n     *  list.each('x', function (x, idx) {});\n     *  list.each(['x', 'y'], function (x, y, idx) {});\n     *  list.each(function (idx) {})\n     */\n    listProto.each = function (dims, cb, stack, context) {\n        if (typeof dims === 'function') {\n            context = stack;\n            stack = cb;\n            cb = dims;\n            dims = [];\n        }\n\n        dims = zrUtil.map(normalizeDimensions(dims), this.getDimension, this);\n\n        var value = [];\n        var dimSize = dims.length;\n        var indices = this.indices;\n\n        context = context || this;\n\n        for (var i = 0; i < indices.length; i++) {\n            // Simple optimization\n            switch (dimSize) {\n                case 0:\n                    cb.call(context, i);\n                    break;\n                case 1:\n                    cb.call(context, this.get(dims[0], i, stack), i);\n                    break;\n                case 2:\n                    cb.call(context, this.get(dims[0], i, stack), this.get(dims[1], i, stack), i);\n                    break;\n                default:\n                    for (var k = 0; k < dimSize; k++) {\n                        value[k] = this.get(dims[k], i, stack);\n                    }\n                    // Index\n                    value[k] = i;\n                    cb.apply(context, value);\n            }\n        }\n    };\n\n    /**\n     * Data filter\n     * @param {string|Array.<string>}\n     * @param {Function} cb\n     * @param {boolean} [stack=false]\n     * @param {*} [context=this]\n     */\n    listProto.filterSelf = function (dimensions, cb, stack, context) {\n        if (typeof dimensions === 'function') {\n            context = stack;\n            stack = cb;\n            cb = dimensions;\n            dimensions = [];\n        }\n\n        dimensions = zrUtil.map(\n            normalizeDimensions(dimensions), this.getDimension, this\n        );\n\n        var newIndices = [];\n        var value = [];\n        var dimSize = dimensions.length;\n        var indices = this.indices;\n\n        context = context || this;\n\n        for (var i = 0; i < indices.length; i++) {\n            var keep;\n            // Simple optimization\n            if (dimSize === 1) {\n                keep = cb.call(\n                    context, this.get(dimensions[0], i, stack), i\n                );\n            }\n            else {\n                for (var k = 0; k < dimSize; k++) {\n                    value[k] = this.get(dimensions[k], i, stack);\n                }\n                value[k] = i;\n                keep = cb.apply(context, value);\n            }\n            if (keep) {\n                newIndices.push(indices[i]);\n            }\n        }\n\n        this.indices = newIndices;\n\n        // Reset data extent\n        this._extent = {};\n\n        return this;\n    };\n\n    /**\n     * Data mapping to a plain array\n     * @param {string|Array.<string>} [dimensions]\n     * @param {Function} cb\n     * @param {boolean} [stack=false]\n     * @param {*} [context=this]\n     * @return {Array}\n     */\n    listProto.mapArray = function (dimensions, cb, stack, context) {\n        if (typeof dimensions === 'function') {\n            context = stack;\n            stack = cb;\n            cb = dimensions;\n            dimensions = [];\n        }\n\n        var result = [];\n        this.each(dimensions, function () {\n            result.push(cb && cb.apply(this, arguments));\n        }, stack, context);\n        return result;\n    };\n\n    function cloneListForMapAndSample(original, excludeDimensions) {\n        var allDimensions = original.dimensions;\n        var list = new List(\n            zrUtil.map(allDimensions, original.getDimensionInfo, original),\n            original.hostModel\n        );\n        // FIXME If needs stackedOn, value may already been stacked\n        transferProperties(list, original);\n\n        var storage = list._storage = {};\n        var originalStorage = original._storage;\n        // Init storage\n        for (var i = 0; i < allDimensions.length; i++) {\n            var dim = allDimensions[i];\n            var dimStore = originalStorage[dim];\n            if (zrUtil.indexOf(excludeDimensions, dim) >= 0) {\n                storage[dim] = new dimStore.constructor(\n                    originalStorage[dim].length\n                );\n            }\n            else {\n                // Direct reference for other dimensions\n                storage[dim] = originalStorage[dim];\n            }\n        }\n        return list;\n    }\n\n    /**\n     * Data mapping to a new List with given dimensions\n     * @param {string|Array.<string>} dimensions\n     * @param {Function} cb\n     * @param {boolean} [stack=false]\n     * @param {*} [context=this]\n     * @return {Array}\n     */\n    listProto.map = function (dimensions, cb, stack, context) {\n        dimensions = zrUtil.map(\n            normalizeDimensions(dimensions), this.getDimension, this\n        );\n\n        var list = cloneListForMapAndSample(this, dimensions);\n        // Following properties are all immutable.\n        // So we can reference to the same value\n        var indices = list.indices = this.indices;\n\n        var storage = list._storage;\n\n        var tmpRetValue = [];\n        this.each(dimensions, function () {\n            var idx = arguments[arguments.length - 1];\n            var retValue = cb && cb.apply(this, arguments);\n            if (retValue != null) {\n                // a number\n                if (typeof retValue === 'number') {\n                    tmpRetValue[0] = retValue;\n                    retValue = tmpRetValue;\n                }\n                for (var i = 0; i < retValue.length; i++) {\n                    var dim = dimensions[i];\n                    var dimStore = storage[dim];\n                    var rawIdx = indices[idx];\n                    if (dimStore) {\n                        dimStore[rawIdx] = retValue[i];\n                    }\n                }\n            }\n        }, stack, context);\n\n        return list;\n    };\n\n    /**\n     * Large data down sampling on given dimension\n     * @param {string} dimension\n     * @param {number} rate\n     * @param {Function} sampleValue\n     * @param {Function} sampleIndex Sample index for name and id\n     */\n    listProto.downSample = function (dimension, rate, sampleValue, sampleIndex) {\n        var list = cloneListForMapAndSample(this, [dimension]);\n        var storage = this._storage;\n        var targetStorage = list._storage;\n\n        var originalIndices = this.indices;\n        var indices = list.indices = [];\n\n        var frameValues = [];\n        var frameIndices = [];\n        var frameSize = Math.floor(1 / rate);\n\n        var dimStore = targetStorage[dimension];\n        var len = this.count();\n        // Copy data from original data\n        for (var i = 0; i < storage[dimension].length; i++) {\n            targetStorage[dimension][i] = storage[dimension][i];\n        }\n        for (var i = 0; i < len; i += frameSize) {\n            // Last frame\n            if (frameSize > len - i) {\n                frameSize = len - i;\n                frameValues.length = frameSize;\n            }\n            for (var k = 0; k < frameSize; k++) {\n                var idx = originalIndices[i + k];\n                frameValues[k] = dimStore[idx];\n                frameIndices[k] = idx;\n            }\n            var value = sampleValue(frameValues);\n            var idx = frameIndices[sampleIndex(frameValues, value) || 0];\n            // Only write value on the filtered data\n            dimStore[idx] = value;\n            indices.push(idx);\n        }\n\n        return list;\n    };\n\n    /**\n     * Get model of one data item.\n     *\n     * @param {number} idx\n     */\n    // FIXME Model proxy ?\n    listProto.getItemModel = function (idx) {\n        var hostModel = this.hostModel;\n        idx = this.indices[idx];\n        return new Model(this._rawData[idx], hostModel, hostModel && hostModel.ecModel);\n    };\n\n    /**\n     * Create a data differ\n     * @param {module:echarts/data/List} otherList\n     * @return {module:echarts/data/DataDiffer}\n     */\n    listProto.diff = function (otherList) {\n        var idList = this._idList;\n        var otherIdList = otherList && otherList._idList;\n        var val;\n        // Use prefix to avoid index to be the same as otherIdList[idx],\n        // which will cause weird udpate animation.\n        var prefix = 'e\\0\\0';\n\n        return new DataDiffer(\n            otherList ? otherList.indices : [],\n            this.indices,\n            function (idx) {\n                return (val = otherIdList[idx]) != null ? val : prefix + idx;\n            },\n            function (idx) {\n                return (val = idList[idx]) != null ? val : prefix + idx;\n            }\n        );\n    };\n    /**\n     * Get visual property.\n     * @param {string} key\n     */\n    listProto.getVisual = function (key) {\n        var visual = this._visual;\n        return visual && visual[key];\n    };\n\n    /**\n     * Set visual property\n     * @param {string|Object} key\n     * @param {*} [value]\n     *\n     * @example\n     *  setVisual('color', color);\n     *  setVisual({\n     *      'color': color\n     *  });\n     */\n    listProto.setVisual = function (key, val) {\n        if (isObject(key)) {\n            for (var name in key) {\n                if (key.hasOwnProperty(name)) {\n                    this.setVisual(name, key[name]);\n                }\n            }\n            return;\n        }\n        this._visual = this._visual || {};\n        this._visual[key] = val;\n    };\n\n    /**\n     * Set layout property.\n     * @param {string} key\n     * @param {*} [val]\n     */\n    listProto.setLayout = function (key, val) {\n        if (isObject(key)) {\n            for (var name in key) {\n                if (key.hasOwnProperty(name)) {\n                    this.setLayout(name, key[name]);\n                }\n            }\n            return;\n        }\n        this._layout[key] = val;\n    };\n\n    /**\n     * Get layout property.\n     * @param  {string} key.\n     * @return {*}\n     */\n    listProto.getLayout = function (key) {\n        return this._layout[key];\n    };\n\n    /**\n     * Get layout of single data item\n     * @param {number} idx\n     */\n    listProto.getItemLayout = function (idx) {\n        return this._itemLayouts[idx];\n    };\n\n    /**\n     * Set layout of single data item\n     * @param {number} idx\n     * @param {Object} layout\n     * @param {boolean=} [merge=false]\n     */\n    listProto.setItemLayout = function (idx, layout, merge) {\n        this._itemLayouts[idx] = merge\n            ? zrUtil.extend(this._itemLayouts[idx] || {}, layout)\n            : layout;\n    };\n\n    /**\n     * Clear all layout of single data item\n     */\n    listProto.clearItemLayouts = function () {\n        this._itemLayouts.length = 0;\n    };\n\n    /**\n     * Get visual property of single data item\n     * @param {number} idx\n     * @param {string} key\n     * @param {boolean} ignoreParent\n     */\n    listProto.getItemVisual = function (idx, key, ignoreParent) {\n        var itemVisual = this._itemVisuals[idx];\n        var val = itemVisual && itemVisual[key];\n        if (val == null && !ignoreParent) {\n            // Use global visual property\n            return this.getVisual(key);\n        }\n        return val;\n    };\n\n    /**\n     * Set visual property of single data item\n     *\n     * @param {number} idx\n     * @param {string|Object} key\n     * @param {*} [value]\n     *\n     * @example\n     *  setItemVisual(0, 'color', color);\n     *  setItemVisual(0, {\n     *      'color': color\n     *  });\n     */\n    listProto.setItemVisual = function (idx, key, value) {\n        var itemVisual = this._itemVisuals[idx] || {};\n        this._itemVisuals[idx] = itemVisual;\n\n        if (isObject(key)) {\n            for (var name in key) {\n                if (key.hasOwnProperty(name)) {\n                    itemVisual[name] = key[name];\n                }\n            }\n            return;\n        }\n        itemVisual[key] = value;\n    };\n\n    /**\n     * Clear itemVisuals and list visual.\n     */\n    listProto.clearAllVisual = function () {\n        this._visual = {};\n        this._itemVisuals = [];\n    };\n\n    var setItemDataAndSeriesIndex = function (child) {\n        child.seriesIndex = this.seriesIndex;\n        child.dataIndex = this.dataIndex;\n        child.dataType = this.dataType;\n    };\n    /**\n     * Set graphic element relative to data. It can be set as null\n     * @param {number} idx\n     * @param {module:zrender/Element} [el]\n     */\n    listProto.setItemGraphicEl = function (idx, el) {\n        var hostModel = this.hostModel;\n\n        if (el) {\n            // Add data index and series index for indexing the data by element\n            // Useful in tooltip\n            el.dataIndex = idx;\n            el.dataType = this.dataType;\n            el.seriesIndex = hostModel && hostModel.seriesIndex;\n            if (el.type === 'group') {\n                el.traverse(setItemDataAndSeriesIndex, el);\n            }\n        }\n\n        this._graphicEls[idx] = el;\n    };\n\n    /**\n     * @param {number} idx\n     * @return {module:zrender/Element}\n     */\n    listProto.getItemGraphicEl = function (idx) {\n        return this._graphicEls[idx];\n    };\n\n    /**\n     * @param {Function} cb\n     * @param {*} context\n     */\n    listProto.eachItemGraphicEl = function (cb, context) {\n        zrUtil.each(this._graphicEls, function (el, idx) {\n            if (el) {\n                cb && cb.call(context, el, idx);\n            }\n        });\n    };\n\n    /**\n     * Shallow clone a new list except visual and layout properties, and graph elements.\n     * New list only change the indices.\n     */\n    listProto.cloneShallow = function () {\n        var dimensionInfoList = zrUtil.map(this.dimensions, this.getDimensionInfo, this);\n        var list = new List(dimensionInfoList, this.hostModel);\n\n        // FIXME\n        list._storage = this._storage;\n\n        transferProperties(list, this);\n\n\n        // Clone will not change the data extent and indices\n        list.indices = this.indices.slice();\n\n        if (this._extent) {\n            list._extent = zrUtil.extend({}, this._extent);\n        }\n\n        return list;\n    };\n\n    /**\n     * Wrap some method to add more feature\n     * @param {string} methodName\n     * @param {Function} injectFunction\n     */\n    listProto.wrapMethod = function (methodName, injectFunction) {\n        var originalMethod = this[methodName];\n        if (typeof originalMethod !== 'function') {\n            return;\n        }\n        this.__wrappedMethods = this.__wrappedMethods || [];\n        this.__wrappedMethods.push(methodName);\n        this[methodName] = function () {\n            var res = originalMethod.apply(this, arguments);\n            return injectFunction.apply(this, [res].concat(zrUtil.slice(arguments)));\n        };\n    };\n\n    // Methods that create a new list based on this list should be listed here.\n    // Notice that those method should `RETURN` the new list.\n    listProto.TRANSFERABLE_METHODS = ['cloneShallow', 'downSample', 'map'];\n    // Methods that change indices of this list should be listed here.\n    listProto.CHANGABLE_METHODS = ['filterSelf'];\n\n    module.exports = List;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./../../~/webpack/buildin/global.js */ 182)))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvZGF0YS9MaXN0LmpzP2EzZjAiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBMaXN0IGZvciBkYXRhIHN0b3JhZ2VcbiAqIEBtb2R1bGUgZWNoYXJ0cy9kYXRhL0xpc3RcbiAqL1xuXG5cbiAgICB2YXIgVU5ERUZJTkVEID0gJ3VuZGVmaW5lZCc7XG4gICAgdmFyIGdsb2JhbE9iaiA9IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogd2luZG93O1xuICAgIHZhciBGbG9hdDY0QXJyYXkgPSB0eXBlb2YgZ2xvYmFsT2JqLkZsb2F0NjRBcnJheSA9PT0gVU5ERUZJTkVEXG4gICAgICAgID8gQXJyYXkgOiBnbG9iYWxPYmouRmxvYXQ2NEFycmF5O1xuICAgIHZhciBJbnQzMkFycmF5ID0gdHlwZW9mIGdsb2JhbE9iai5JbnQzMkFycmF5ID09PSBVTkRFRklORURcbiAgICAgICAgPyBBcnJheSA6IGdsb2JhbE9iai5JbnQzMkFycmF5O1xuXG4gICAgdmFyIGRhdGFDdG9ycyA9IHtcbiAgICAgICAgJ2Zsb2F0JzogRmxvYXQ2NEFycmF5LFxuICAgICAgICAnaW50JzogSW50MzJBcnJheSxcbiAgICAgICAgLy8gT3JkaW5hbCBkYXRhIHR5cGUgY2FuIGJlIHN0cmluZyBvciBpbnRcbiAgICAgICAgJ29yZGluYWwnOiBBcnJheSxcbiAgICAgICAgJ251bWJlcic6IEFycmF5LFxuICAgICAgICAndGltZSc6IEFycmF5XG4gICAgfTtcblxuICAgIHZhciBNb2RlbCA9IHJlcXVpcmUoJy4uL21vZGVsL01vZGVsJyk7XG4gICAgdmFyIERhdGFEaWZmZXIgPSByZXF1aXJlKCcuL0RhdGFEaWZmZXInKTtcblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgbW9kZWxVdGlsID0gcmVxdWlyZSgnLi4vdXRpbC9tb2RlbCcpO1xuICAgIHZhciBpc09iamVjdCA9IHpyVXRpbC5pc09iamVjdDtcblxuICAgIHZhciBUUkFOU0ZFUkFCTEVfUFJPUEVSVElFUyA9IFtcbiAgICAgICAgJ3N0YWNrZWRPbicsICdoYXNJdGVtT3B0aW9uJywgJ19uYW1lTGlzdCcsICdfaWRMaXN0JywgJ19yYXdEYXRhJ1xuICAgIF07XG5cbiAgICB2YXIgdHJhbnNmZXJQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgenJVdGlsLmVhY2goVFJBTlNGRVJBQkxFX1BST1BFUlRJRVMuY29uY2F0KGIuX193cmFwcGVkTWV0aG9kcyB8fCBbXSksIGZ1bmN0aW9uIChwcm9wTmFtZSkge1xuICAgICAgICAgICAgaWYgKGIuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgYVtwcm9wTmFtZV0gPSBiW3Byb3BOYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgYS5fX3dyYXBwZWRNZXRob2RzID0gYi5fX3dyYXBwZWRNZXRob2RzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAYWxpYXMgbW9kdWxlOmVjaGFydHMvZGF0YS9MaXN0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxzdHJpbmd8T2JqZWN0Pn0gZGltZW5zaW9uc1xuICAgICAqICAgICAgRm9yIGV4YW1wbGUsIFsnc29tZURpbU5hbWUnLCB7bmFtZTogJ3NvbWVEaW1OYW1lJywgdHlwZTogJ3NvbWVEaW1UeXBlJ30sIC4uLl0uXG4gICAgICogICAgICBEaW1lbnNpb25zIHNob3VsZCBiZSBjb25jcmV0ZSBuYW1lcyBsaWtlIHgsIHksIHosIGxuZywgbGF0LCBhbmdsZSwgcmFkaXVzXG4gICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH0gaG9zdE1vZGVsXG4gICAgICovXG4gICAgdmFyIExpc3QgPSBmdW5jdGlvbiAoZGltZW5zaW9ucywgaG9zdE1vZGVsKSB7XG5cbiAgICAgICAgZGltZW5zaW9ucyA9IGRpbWVuc2lvbnMgfHwgWyd4JywgJ3knXTtcblxuICAgICAgICB2YXIgZGltZW5zaW9uSW5mb3MgPSB7fTtcbiAgICAgICAgdmFyIGRpbWVuc2lvbk5hbWVzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGltZW5zaW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGRpbWVuc2lvbk5hbWU7XG4gICAgICAgICAgICB2YXIgZGltZW5zaW9uSW5mbyA9IHt9O1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBkaW1lbnNpb25zW2ldID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGRpbWVuc2lvbk5hbWUgPSBkaW1lbnNpb25zW2ldO1xuICAgICAgICAgICAgICAgIGRpbWVuc2lvbkluZm8gPSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IGRpbWVuc2lvbk5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIC8vIFR5cGUgY2FuIGJlICdmbG9hdCcsICdpbnQnLCAnbnVtYmVyJ1xuICAgICAgICAgICAgICAgICAgICAvLyBEZWZhdWx0IGlzIG51bWJlciwgUHJlY2lzaW9uIG9mIGZsb2F0IG1heSBub3QgZW5vdWdoXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdudW1iZXInXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRpbWVuc2lvbkluZm8gPSBkaW1lbnNpb25zW2ldO1xuICAgICAgICAgICAgICAgIGRpbWVuc2lvbk5hbWUgPSBkaW1lbnNpb25JbmZvLm5hbWU7XG4gICAgICAgICAgICAgICAgZGltZW5zaW9uSW5mby50eXBlID0gZGltZW5zaW9uSW5mby50eXBlIHx8ICdudW1iZXInO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGltZW5zaW9uTmFtZXMucHVzaChkaW1lbnNpb25OYW1lKTtcbiAgICAgICAgICAgIGRpbWVuc2lvbkluZm9zW2RpbWVuc2lvbk5hbWVdID0gZGltZW5zaW9uSW5mbztcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHJlYWRPbmx5XG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48c3RyaW5nPn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGltZW5zaW9ucyA9IGRpbWVuc2lvbk5hbWVzO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmZvbWF0aW9uIG9mIGVhY2ggZGF0YSBkaW1lbnNpb24sIGxpa2UgZGF0YSB0eXBlLlxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fZGltZW5zaW9uSW5mb3MgPSBkaW1lbnNpb25JbmZvcztcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ob3N0TW9kZWwgPSBob3N0TW9kZWw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGF0YVR5cGU7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluZGljZXMgc3RvcmVzIHRoZSBpbmRpY2VzIG9mIGRhdGEgc3Vic2V0IGFmdGVyIGZpbHRlcmVkLlxuICAgICAgICAgKiBUaGlzIGRhdGEgc3Vic2V0IHdpbGwgYmUgdXNlZCBpbiBjaGFydC5cbiAgICAgICAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICAgICAgICAgKiBAcmVhZE9ubHlcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaW5kaWNlcyA9IFtdO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEYXRhIHN0b3JhZ2VcbiAgICAgICAgICogQHR5cGUge09iamVjdC48a2V5LCBUeXBlZEFycmF5fEFycmF5Pn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3N0b3JhZ2UgPSB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge0FycmF5LjxzdHJpbmc+fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbmFtZUxpc3QgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48c3RyaW5nPn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2lkTGlzdCA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogTW9kZWxzIG9mIGRhdGEgb3B0aW9uIGlzIHN0b3JlZCBzcGFyc2UgZm9yIG9wdGltaXppbmcgbWVtb3J5IGNvc3RcbiAgICAgICAgICogQHR5cGUge0FycmF5Ljxtb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbD59XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9vcHRpb25Nb2RlbHMgPSBbXTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9kYXRhL0xpc3R9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YWNrZWRPbiA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdsb2JhbCB2aXN1YWwgcHJvcGVydGllcyBhZnRlciB2aXN1YWwgY29kaW5nXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl92aXN1YWwgPSB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2xvYmVsIGxheW91dCBwcm9wZXJ0aWVzLlxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbGF5b3V0ID0ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEl0ZW0gdmlzdWFsIHByb3BlcnRpZXMgYWZ0ZXIgdmlzdWFsIGNvZGluZ1xuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPE9iamVjdD59XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9pdGVtVmlzdWFscyA9IFtdO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJdGVtIGxheW91dCBwcm9wZXJ0aWVzIGFmdGVyIGxheW91dFxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPE9iamVjdD59XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9pdGVtTGF5b3V0cyA9IFtdO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHcmFwaGljIGVsZW1uZW50c1xuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPG1vZHVsZTp6cmVuZGVyL0VsZW1lbnQ+fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fZ3JhcGhpY0VscyA9IFtdO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPEFycmF5fE9iamVjdD59XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9yYXdEYXRhO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fZXh0ZW50O1xuICAgIH07XG5cbiAgICB2YXIgbGlzdFByb3RvID0gTGlzdC5wcm90b3R5cGU7XG5cbiAgICBsaXN0UHJvdG8udHlwZSA9ICdsaXN0JztcbiAgICAvKipcbiAgICAgKiBJZiBlYWNoIGRhdGEgaXRlbSBoYXMgaXQncyBvd24gb3B0aW9uXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgbGlzdFByb3RvLmhhc0l0ZW1PcHRpb24gPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogR2V0IGRpbWVuc2lvbiBuYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBkaW1cbiAgICAgKiAgICAgICAgRGltZW5zaW9uIGNhbiBiZSBjb25jcmV0ZSBuYW1lcyBsaWtlIHgsIHksIHosIGxuZywgbGF0LCBhbmdsZSwgcmFkaXVzXG4gICAgICogICAgICAgIE9yIGEgb3JkaW5hbCBudW1iZXIuIEZvciBleGFtcGxlIGdldERpbWVuc2lvbkluZm8oMCkgd2lsbCByZXR1cm4gJ3gnIG9yICdsbmcnIG9yICdyYWRpdXMnXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBDb25jcmV0ZSBkaW0gbmFtZS5cbiAgICAgKi9cbiAgICBsaXN0UHJvdG8uZ2V0RGltZW5zaW9uID0gZnVuY3Rpb24gKGRpbSkge1xuICAgICAgICBpZiAoIWlzTmFOKGRpbSkpIHtcbiAgICAgICAgICAgIGRpbSA9IHRoaXMuZGltZW5zaW9uc1tkaW1dIHx8IGRpbTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGltO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IHR5cGUgYW5kIHN0YWNrYWJsZSBpbmZvIG9mIHBhcnRpY3VsYXIgZGltZW5zaW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBkaW1cbiAgICAgKiAgICAgICAgRGltZW5zaW9uIGNhbiBiZSBjb25jcmV0ZSBuYW1lcyBsaWtlIHgsIHksIHosIGxuZywgbGF0LCBhbmdsZSwgcmFkaXVzXG4gICAgICogICAgICAgIE9yIGEgb3JkaW5hbCBudW1iZXIuIEZvciBleGFtcGxlIGdldERpbWVuc2lvbkluZm8oMCkgd2lsbCByZXR1cm4gJ3gnIG9yICdsbmcnIG9yICdyYWRpdXMnXG4gICAgICovXG4gICAgbGlzdFByb3RvLmdldERpbWVuc2lvbkluZm8gPSBmdW5jdGlvbiAoZGltKSB7XG4gICAgICAgIHJldHVybiB6clV0aWwuY2xvbmUodGhpcy5fZGltZW5zaW9uSW5mb3NbdGhpcy5nZXREaW1lbnNpb24oZGltKV0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIGZyb20gZGF0YVxuICAgICAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdHxudW1iZXJ8QXJyYXk+fSBkYXRhXG4gICAgICogQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gW25hbWVMaXN0XVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtkaW1WYWx1ZUdldHRlcl0gKGRhdGFJdGVtLCBkaW1OYW1lLCBkYXRhSW5kZXgsIGRpbUluZGV4KSA9PiBudW1iZXJcbiAgICAgKi9cbiAgICBsaXN0UHJvdG8uaW5pdERhdGEgPSBmdW5jdGlvbiAoZGF0YSwgbmFtZUxpc3QsIGRpbVZhbHVlR2V0dGVyKSB7XG4gICAgICAgIGRhdGEgPSBkYXRhIHx8IFtdO1xuXG4gICAgICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgICAgICBpZiAoIXpyVXRpbC5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGRhdGEuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9yYXdEYXRhID0gZGF0YTtcblxuICAgICAgICAvLyBDbGVhclxuICAgICAgICB2YXIgc3RvcmFnZSA9IHRoaXMuX3N0b3JhZ2UgPSB7fTtcbiAgICAgICAgdmFyIGluZGljZXMgPSB0aGlzLmluZGljZXMgPSBbXTtcblxuICAgICAgICB2YXIgZGltZW5zaW9ucyA9IHRoaXMuZGltZW5zaW9ucztcbiAgICAgICAgdmFyIHNpemUgPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgdmFyIGRpbWVuc2lvbkluZm9NYXAgPSB0aGlzLl9kaW1lbnNpb25JbmZvcztcblxuICAgICAgICB2YXIgaWRMaXN0ID0gW107XG4gICAgICAgIHZhciBuYW1lUmVwZWF0Q291bnQgPSB7fTtcblxuICAgICAgICBuYW1lTGlzdCA9IG5hbWVMaXN0IHx8IFtdO1xuXG4gICAgICAgIC8vIEluaXQgc3RvcmFnZVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpbWVuc2lvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBkaW1JbmZvID0gZGltZW5zaW9uSW5mb01hcFtkaW1lbnNpb25zW2ldXTtcbiAgICAgICAgICAgIHZhciBEYXRhQ3RvciA9IGRhdGFDdG9yc1tkaW1JbmZvLnR5cGVdO1xuICAgICAgICAgICAgc3RvcmFnZVtkaW1lbnNpb25zW2ldXSA9IG5ldyBEYXRhQ3RvcihzaXplKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgaWYgKCFkaW1WYWx1ZUdldHRlcikge1xuICAgICAgICAgICAgc2VsZi5oYXNJdGVtT3B0aW9uID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRGVmYXVsdCBkaW0gdmFsdWUgZ2V0dGVyXG4gICAgICAgIGRpbVZhbHVlR2V0dGVyID0gZGltVmFsdWVHZXR0ZXIgfHwgZnVuY3Rpb24gKGRhdGFJdGVtLCBkaW1OYW1lLCBkYXRhSW5kZXgsIGRpbUluZGV4KSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBtb2RlbFV0aWwuZ2V0RGF0YUl0ZW1WYWx1ZShkYXRhSXRlbSk7XG4gICAgICAgICAgICAvLyBJZiBhbnkgZGF0YUl0ZW0gaXMgbGlrZSB7IHZhbHVlOiAxMCB9XG4gICAgICAgICAgICBpZiAobW9kZWxVdGlsLmlzRGF0YUl0ZW1PcHRpb24oZGF0YUl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5oYXNJdGVtT3B0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtb2RlbFV0aWwuY29udmVyRGF0YVZhbHVlKFxuICAgICAgICAgICAgICAgICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KVxuICAgICAgICAgICAgICAgICAgICA/IHZhbHVlW2RpbUluZGV4XVxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB2YWx1ZSBpcyBhIHNpbmdsZSBudW1iZXIgb3Igc29tZXRoaW5nIGVsc2Ugbm90IGFycmF5LlxuICAgICAgICAgICAgICAgICAgICA6IHZhbHVlLFxuICAgICAgICAgICAgICAgIGRpbWVuc2lvbkluZm9NYXBbZGltTmFtZV1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgZGF0YS5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgICAgICB2YXIgZGF0YUl0ZW0gPSBkYXRhW2lkeF07XG4gICAgICAgICAgICAvLyBFYWNoIGRhdGEgaXRlbSBpcyB2YWx1ZVxuICAgICAgICAgICAgLy8gWzEsIDJdXG4gICAgICAgICAgICAvLyAyXG4gICAgICAgICAgICAvLyBCYXIgY2hhcnQsIGxpbmUgY2hhcnQgd2hpY2ggdXNlcyBjYXRlZ29yeSBheGlzXG4gICAgICAgICAgICAvLyBvbmx5IGdpdmVzIHRoZSAneScgdmFsdWUuICd4JyB2YWx1ZSBpcyB0aGUgaW5kaWNlcyBvZiBjYXRlb2dyeVxuICAgICAgICAgICAgLy8gVXNlIGEgdGVtcFZhbHVlIHRvIG5vcm1hbGl6ZSB0aGUgdmFsdWUgdG8gYmUgYSAoeCwgeSkgdmFsdWVcblxuICAgICAgICAgICAgLy8gU3RvcmUgdGhlIGRhdGEgYnkgZGltZW5zaW9uc1xuICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBkaW1lbnNpb25zLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRpbSA9IGRpbWVuc2lvbnNba107XG4gICAgICAgICAgICAgICAgdmFyIGRpbVN0b3JhZ2UgPSBzdG9yYWdlW2RpbV07XG4gICAgICAgICAgICAgICAgLy8gUEVORElORyBOVUxMIGlzIGVtcHR5IG9yIHplcm9cbiAgICAgICAgICAgICAgICBkaW1TdG9yYWdlW2lkeF0gPSBkaW1WYWx1ZUdldHRlcihkYXRhSXRlbSwgZGltLCBpZHgsIGspO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpbmRpY2VzLnB1c2goaWR4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVzZSB0aGUgbmFtZSBpbiBvcHRpb24gYW5kIGNyZWF0ZSBpZFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghbmFtZUxpc3RbaV0pIHtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YVtpXSAmJiBkYXRhW2ldLm5hbWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBuYW1lTGlzdFtpXSA9IGRhdGFbaV0ubmFtZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbmFtZSA9IG5hbWVMaXN0W2ldIHx8ICcnO1xuICAgICAgICAgICAgLy8gVHJ5IHVzaW5nIHRoZSBpZCBpbiBvcHRpb25cbiAgICAgICAgICAgIHZhciBpZCA9IGRhdGFbaV0gJiYgZGF0YVtpXS5pZDtcblxuICAgICAgICAgICAgaWYgKCFpZCAmJiBuYW1lKSB7XG4gICAgICAgICAgICAgICAgLy8gVXNlIG5hbWUgYXMgaWQgYW5kIGFkZCBjb3VudGVyIHRvIGF2b2lkIHNhbWUgbmFtZVxuICAgICAgICAgICAgICAgIG5hbWVSZXBlYXRDb3VudFtuYW1lXSA9IG5hbWVSZXBlYXRDb3VudFtuYW1lXSB8fCAwO1xuICAgICAgICAgICAgICAgIGlkID0gbmFtZTtcbiAgICAgICAgICAgICAgICBpZiAobmFtZVJlcGVhdENvdW50W25hbWVdID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZCArPSAnX19lY19fJyArIG5hbWVSZXBlYXRDb3VudFtuYW1lXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmFtZVJlcGVhdENvdW50W25hbWVdKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZCAmJiAoaWRMaXN0W2ldID0gaWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbmFtZUxpc3QgPSBuYW1lTGlzdDtcbiAgICAgICAgdGhpcy5faWRMaXN0ID0gaWRMaXN0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgbGlzdFByb3RvLmNvdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmRpY2VzLmxlbmd0aDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHZhbHVlLiBSZXR1cm4gTmFOIGlmIGlkeCBpcyBvdXQgb2YgcmFuZ2UuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRpbSBEaW0gbXVzdCBiZSBjb25jcmV0ZSBuYW1lLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpZHhcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHN0YWNrXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIGxpc3RQcm90by5nZXQgPSBmdW5jdGlvbiAoZGltLCBpZHgsIHN0YWNrKSB7XG4gICAgICAgIHZhciBzdG9yYWdlID0gdGhpcy5fc3RvcmFnZTtcbiAgICAgICAgdmFyIGRhdGFJbmRleCA9IHRoaXMuaW5kaWNlc1tpZHhdO1xuXG4gICAgICAgIC8vIElmIHZhbHVlIG5vdCBleGlzdHNcbiAgICAgICAgaWYgKGRhdGFJbmRleCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHZhbHVlID0gc3RvcmFnZVtkaW1dICYmIHN0b3JhZ2VbZGltXVtkYXRhSW5kZXhdO1xuICAgICAgICAvLyBGSVhNRSBvcmRpbmFsIGRhdGEgdHlwZSBpcyBub3Qgc3RhY2thYmxlXG4gICAgICAgIGlmIChzdGFjaykge1xuICAgICAgICAgICAgdmFyIGRpbWVuc2lvbkluZm8gPSB0aGlzLl9kaW1lbnNpb25JbmZvc1tkaW1dO1xuICAgICAgICAgICAgaWYgKGRpbWVuc2lvbkluZm8gJiYgZGltZW5zaW9uSW5mby5zdGFja2FibGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhY2tlZE9uID0gdGhpcy5zdGFja2VkT247XG4gICAgICAgICAgICAgICAgd2hpbGUgKHN0YWNrZWRPbikge1xuICAgICAgICAgICAgICAgICAgICAvLyBHZXQgbm8gc3RhY2tlZCBkYXRhIG9mIHN0YWNrZWQgb25cbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YWNrZWRWYWx1ZSA9IHN0YWNrZWRPbi5nZXQoZGltLCBpZHgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBDb25zaWRlcmluZyBwb3NpdGl2ZSBzdGFjaywgbmVnYXRpdmUgc3RhY2sgYW5kIGVtcHR5IGRhdGFcbiAgICAgICAgICAgICAgICAgICAgaWYgKCh2YWx1ZSA+PSAwICYmIHN0YWNrZWRWYWx1ZSA+IDApICAvLyBQb3NpdGl2ZSBzdGFja1xuICAgICAgICAgICAgICAgICAgICAgICAgfHwgKHZhbHVlIDw9IDAgJiYgc3RhY2tlZFZhbHVlIDwgMCkgLy8gTmVnYXRpdmUgc3RhY2tcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBzdGFja2VkVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3RhY2tlZE9uID0gc3RhY2tlZE9uLnN0YWNrZWRPbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdmFsdWUgZm9yIG11bHRpIGRpbWVuc2lvbnMuXG4gICAgICogQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gW2RpbWVuc2lvbnNdIElmIGlnbm9yZWQsIHVzaW5nIGFsbCBkaW1lbnNpb25zLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpZHhcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHN0YWNrXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIGxpc3RQcm90by5nZXRWYWx1ZXMgPSBmdW5jdGlvbiAoZGltZW5zaW9ucywgaWR4LCBzdGFjaykge1xuICAgICAgICB2YXIgdmFsdWVzID0gW107XG5cbiAgICAgICAgaWYgKCF6clV0aWwuaXNBcnJheShkaW1lbnNpb25zKSkge1xuICAgICAgICAgICAgc3RhY2sgPSBpZHg7XG4gICAgICAgICAgICBpZHggPSBkaW1lbnNpb25zO1xuICAgICAgICAgICAgZGltZW5zaW9ucyA9IHRoaXMuZGltZW5zaW9ucztcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBkaW1lbnNpb25zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB2YWx1ZXMucHVzaCh0aGlzLmdldChkaW1lbnNpb25zW2ldLCBpZHgsIHN0YWNrKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJZiB2YWx1ZSBpcyBOYU4uIElubGN1ZGluZyAnLSdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGltXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGlkeFxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBsaXN0UHJvdG8uaGFzVmFsdWUgPSBmdW5jdGlvbiAoaWR4KSB7XG4gICAgICAgIHZhciBkaW1lbnNpb25zID0gdGhpcy5kaW1lbnNpb25zO1xuICAgICAgICB2YXIgZGltZW5zaW9uSW5mb3MgPSB0aGlzLl9kaW1lbnNpb25JbmZvcztcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRpbWVuc2lvbnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAvLyBPcmRpbmFsIHR5cGUgY2FuIGJlIHN0cmluZyBvciBudW1iZXJcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25JbmZvc1tkaW1lbnNpb25zW2ldXS50eXBlICE9PSAnb3JkaW5hbCdcbiAgICAgICAgICAgICAgICAmJiBpc05hTih0aGlzLmdldChkaW1lbnNpb25zW2ldLCBpZHgpKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgZXh0ZW50IG9mIGRhdGEgaW4gb25lIGRpbWVuc2lvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkaW1cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHN0YWNrXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZmlsdGVyXG4gICAgICovXG4gICAgbGlzdFByb3RvLmdldERhdGFFeHRlbnQgPSBmdW5jdGlvbiAoZGltLCBzdGFjaywgZmlsdGVyKSB7XG4gICAgICAgIGRpbSA9IHRoaXMuZ2V0RGltZW5zaW9uKGRpbSk7XG4gICAgICAgIHZhciBkaW1EYXRhID0gdGhpcy5fc3RvcmFnZVtkaW1dO1xuICAgICAgICB2YXIgZGltSW5mbyA9IHRoaXMuZ2V0RGltZW5zaW9uSW5mbyhkaW0pO1xuICAgICAgICBzdGFjayA9IChkaW1JbmZvICYmIGRpbUluZm8uc3RhY2thYmxlKSAmJiBzdGFjaztcbiAgICAgICAgdmFyIGRpbUV4dGVudCA9ICh0aGlzLl9leHRlbnQgfHwgKHRoaXMuX2V4dGVudCA9IHt9KSlbZGltICsgKCEhc3RhY2spXTtcbiAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICBpZiAoZGltRXh0ZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gZGltRXh0ZW50O1xuICAgICAgICB9XG4gICAgICAgIC8vIHZhciBkaW1JbmZvID0gdGhpcy5fZGltZW5zaW9uSW5mb3NbZGltXTtcbiAgICAgICAgaWYgKGRpbURhdGEpIHtcbiAgICAgICAgICAgIHZhciBtaW4gPSBJbmZpbml0eTtcbiAgICAgICAgICAgIHZhciBtYXggPSAtSW5maW5pdHk7XG4gICAgICAgICAgICAvLyB2YXIgaXNPcmRpbmFsID0gZGltSW5mby50eXBlID09PSAnb3JkaW5hbCc7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5jb3VudCgpOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuZ2V0KGRpbSwgaSwgc3RhY2spO1xuICAgICAgICAgICAgICAgIC8vIEZJWE1FXG4gICAgICAgICAgICAgICAgLy8gaWYgKGlzT3JkaW5hbCAmJiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgLy8gICAgIHZhbHVlID0genJVdGlsLmluZGV4T2YoZGltRGF0YSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICBpZiAoIWZpbHRlciB8fCBmaWx0ZXIodmFsdWUsIGRpbSwgaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPCBtaW4gJiYgKG1pbiA9IHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPiBtYXggJiYgKG1heCA9IHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuX2V4dGVudFtkaW0gKyAhIXN0YWNrXSA9IFttaW4sIG1heF0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFtJbmZpbml0eSwgLUluZmluaXR5XTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgc3VtIG9mIGRhdGEgaW4gb25lIGRpbWVuc2lvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkaW1cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHN0YWNrXG4gICAgICovXG4gICAgbGlzdFByb3RvLmdldFN1bSA9IGZ1bmN0aW9uIChkaW0sIHN0YWNrKSB7XG4gICAgICAgIHZhciBkaW1EYXRhID0gdGhpcy5fc3RvcmFnZVtkaW1dO1xuICAgICAgICB2YXIgc3VtID0gMDtcbiAgICAgICAgaWYgKGRpbURhdGEpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmNvdW50KCk7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0KGRpbSwgaSwgc3RhY2spO1xuICAgICAgICAgICAgICAgIGlmICghaXNOYU4odmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1bSArPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1bTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0cmVpdmUgdGhlIGluZGV4IHdpdGggZ2l2ZW4gdmFsdWVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaWR4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIC8vIEZJWE1FIFByZWNpc2lvbiBvZiBmbG9hdCB2YWx1ZVxuICAgIGxpc3RQcm90by5pbmRleE9mID0gZnVuY3Rpb24gKGRpbSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIHN0b3JhZ2UgPSB0aGlzLl9zdG9yYWdlO1xuICAgICAgICB2YXIgZGltRGF0YSA9IHN0b3JhZ2VbZGltXTtcbiAgICAgICAgdmFyIGluZGljZXMgPSB0aGlzLmluZGljZXM7XG5cbiAgICAgICAgaWYgKGRpbURhdGEpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBpbmRpY2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJhd0luZGV4ID0gaW5kaWNlc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoZGltRGF0YVtyYXdJbmRleF0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHJlaXZlIHRoZSBpbmRleCB3aXRoIGdpdmVuIG5hbWVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaWR4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG5hbWVcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgbGlzdFByb3RvLmluZGV4T2ZOYW1lID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdmFyIGluZGljZXMgPSB0aGlzLmluZGljZXM7XG4gICAgICAgIHZhciBuYW1lTGlzdCA9IHRoaXMuX25hbWVMaXN0O1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBpbmRpY2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcmF3SW5kZXggPSBpbmRpY2VzW2ldO1xuICAgICAgICAgICAgaWYgKG5hbWVMaXN0W3Jhd0luZGV4XSA9PT0gbmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXRyZWl2ZSB0aGUgaW5kZXggd2l0aCBnaXZlbiByYXcgZGF0YSBpbmRleFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpZHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbmFtZVxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBsaXN0UHJvdG8uaW5kZXhPZlJhd0luZGV4ID0gZnVuY3Rpb24gKHJhd0luZGV4KSB7XG4gICAgICAgIC8vIEluZGljZXMgYXJlIGFzY2VuZGluZ1xuICAgICAgICB2YXIgaW5kaWNlcyA9IHRoaXMuaW5kaWNlcztcblxuICAgICAgICAvLyBJZiByYXdJbmRleCA9PT0gZGF0YUluZGV4XG4gICAgICAgIHZhciByYXdEYXRhSW5kZXggPSBpbmRpY2VzW3Jhd0luZGV4XTtcbiAgICAgICAgaWYgKHJhd0RhdGFJbmRleCAhPSBudWxsICYmIHJhd0RhdGFJbmRleCA9PT0gcmF3SW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiByYXdJbmRleDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsZWZ0ID0gMDtcbiAgICAgICAgdmFyIHJpZ2h0ID0gaW5kaWNlcy5sZW5ndGggLSAxO1xuICAgICAgICB3aGlsZSAobGVmdCA8PSByaWdodCkge1xuICAgICAgICAgICAgdmFyIG1pZCA9IChsZWZ0ICsgcmlnaHQpIC8gMiB8IDA7XG4gICAgICAgICAgICBpZiAoaW5kaWNlc1ttaWRdIDwgcmF3SW5kZXgpIHtcbiAgICAgICAgICAgICAgICBsZWZ0ID0gbWlkICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGluZGljZXNbbWlkXSA+IHJhd0luZGV4KSB7XG4gICAgICAgICAgICAgICAgcmlnaHQgPSBtaWQgLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHJlaXZlIHRoZSBpbmRleCBvZiBuZWFyZXN0IHZhbHVlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRpbVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc3RhY2sgSWYgZ2l2ZW4gdmFsdWUgaXMgYWZ0ZXIgc3RhY2tlZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbWF4RGlzdGFuY2U9SW5maW5pdHldXG4gICAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59IENvbnNpZGVyZSBtdWx0aXBsZSBwb2ludHMgaGFzIHRoZSBzYW1lIHZhbHVlLlxuICAgICAqL1xuICAgIGxpc3RQcm90by5pbmRpY2VzT2ZOZWFyZXN0ID0gZnVuY3Rpb24gKGRpbSwgdmFsdWUsIHN0YWNrLCBtYXhEaXN0YW5jZSkge1xuICAgICAgICB2YXIgc3RvcmFnZSA9IHRoaXMuX3N0b3JhZ2U7XG4gICAgICAgIHZhciBkaW1EYXRhID0gc3RvcmFnZVtkaW1dO1xuICAgICAgICB2YXIgbmVhcmVzdEluZGljZXMgPSBbXTtcblxuICAgICAgICBpZiAoIWRpbURhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBuZWFyZXN0SW5kaWNlcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXhEaXN0YW5jZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBtYXhEaXN0YW5jZSA9IEluZmluaXR5O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1pbkRpc3QgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICB2YXIgbWluRGlmZiA9IC0xO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5jb3VudCgpOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBkaWZmID0gdmFsdWUgLSB0aGlzLmdldChkaW0sIGksIHN0YWNrKTtcbiAgICAgICAgICAgIHZhciBkaXN0ID0gTWF0aC5hYnMoZGlmZik7XG4gICAgICAgICAgICBpZiAoZGlmZiA8PSBtYXhEaXN0YW5jZSAmJiBkaXN0IDw9IG1pbkRpc3QpIHtcbiAgICAgICAgICAgICAgICAvLyBGb3IgdGhlIGNhc2Ugb2YgdHdvIGRhdGEgYXJlIHNhbWUgb24geEF4aXMsIHdoaWNoIGhhcyBzZXF1ZW5jZSBkYXRhLlxuICAgICAgICAgICAgICAgIC8vIFNob3cgdGhlIG5lYXJlc3QgaW5kZXhcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZWNvbWZlL2VjaGFydHMvaXNzdWVzLzI4NjlcbiAgICAgICAgICAgICAgICBpZiAoZGlzdCA8IG1pbkRpc3QgfHwgKGRpZmYgPj0gMCAmJiBtaW5EaWZmIDwgMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWluRGlzdCA9IGRpc3Q7XG4gICAgICAgICAgICAgICAgICAgIG1pbkRpZmYgPSBkaWZmO1xuICAgICAgICAgICAgICAgICAgICBuZWFyZXN0SW5kaWNlcy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZWFyZXN0SW5kaWNlcy5wdXNoKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZWFyZXN0SW5kaWNlcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHJhdyBkYXRhIGluZGV4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGlkeFxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBsaXN0UHJvdG8uZ2V0UmF3SW5kZXggPSBmdW5jdGlvbiAoaWR4KSB7XG4gICAgICAgIHZhciByYXdJZHggPSB0aGlzLmluZGljZXNbaWR4XTtcbiAgICAgICAgcmV0dXJuIHJhd0lkeCA9PSBudWxsID8gLTEgOiByYXdJZHg7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCByYXcgZGF0YSBpdGVtXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGlkeFxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBsaXN0UHJvdG8uZ2V0UmF3RGF0YUl0ZW0gPSBmdW5jdGlvbiAoaWR4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yYXdEYXRhW3RoaXMuZ2V0UmF3SW5kZXgoaWR4KV07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpZHhcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtub3REZWZhdWx0SWR4PWZhbHNlXVxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKi9cbiAgICBsaXN0UHJvdG8uZ2V0TmFtZSA9IGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25hbWVMaXN0W3RoaXMuaW5kaWNlc1tpZHhdXSB8fCAnJztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGlkeFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW25vdERlZmF1bHRJZHg9ZmFsc2VdXG4gICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAqL1xuICAgIGxpc3RQcm90by5nZXRJZCA9IGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lkTGlzdFt0aGlzLmluZGljZXNbaWR4XV0gfHwgKHRoaXMuZ2V0UmF3SW5kZXgoaWR4KSArICcnKTtcbiAgICB9O1xuXG5cbiAgICBmdW5jdGlvbiBub3JtYWxpemVEaW1lbnNpb25zKGRpbWVuc2lvbnMpIHtcbiAgICAgICAgaWYgKCF6clV0aWwuaXNBcnJheShkaW1lbnNpb25zKSkge1xuICAgICAgICAgICAgZGltZW5zaW9ucyA9IFtkaW1lbnNpb25zXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGltZW5zaW9ucztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEYXRhIGl0ZXJhdGlvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfEFycmF5LjxzdHJpbmc+fVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbc3RhY2s9ZmFsc2VdXG4gICAgICogQHBhcmFtIHsqfSBbY29udGV4dD10aGlzXVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgbGlzdC5lYWNoKCd4JywgZnVuY3Rpb24gKHgsIGlkeCkge30pO1xuICAgICAqICBsaXN0LmVhY2goWyd4JywgJ3knXSwgZnVuY3Rpb24gKHgsIHksIGlkeCkge30pO1xuICAgICAqICBsaXN0LmVhY2goZnVuY3Rpb24gKGlkeCkge30pXG4gICAgICovXG4gICAgbGlzdFByb3RvLmVhY2ggPSBmdW5jdGlvbiAoZGltcywgY2IsIHN0YWNrLCBjb250ZXh0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgZGltcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY29udGV4dCA9IHN0YWNrO1xuICAgICAgICAgICAgc3RhY2sgPSBjYjtcbiAgICAgICAgICAgIGNiID0gZGltcztcbiAgICAgICAgICAgIGRpbXMgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRpbXMgPSB6clV0aWwubWFwKG5vcm1hbGl6ZURpbWVuc2lvbnMoZGltcyksIHRoaXMuZ2V0RGltZW5zaW9uLCB0aGlzKTtcblxuICAgICAgICB2YXIgdmFsdWUgPSBbXTtcbiAgICAgICAgdmFyIGRpbVNpemUgPSBkaW1zLmxlbmd0aDtcbiAgICAgICAgdmFyIGluZGljZXMgPSB0aGlzLmluZGljZXM7XG5cbiAgICAgICAgY29udGV4dCA9IGNvbnRleHQgfHwgdGhpcztcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIC8vIFNpbXBsZSBvcHRpbWl6YXRpb25cbiAgICAgICAgICAgIHN3aXRjaCAoZGltU2l6ZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgY2IuY2FsbChjb250ZXh0LCBpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBjYi5jYWxsKGNvbnRleHQsIHRoaXMuZ2V0KGRpbXNbMF0sIGksIHN0YWNrKSwgaSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgY2IuY2FsbChjb250ZXh0LCB0aGlzLmdldChkaW1zWzBdLCBpLCBzdGFjayksIHRoaXMuZ2V0KGRpbXNbMV0sIGksIHN0YWNrKSwgaSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgZGltU2l6ZTsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVtrXSA9IHRoaXMuZ2V0KGRpbXNba10sIGksIHN0YWNrKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBJbmRleFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZVtrXSA9IGk7XG4gICAgICAgICAgICAgICAgICAgIGNiLmFwcGx5KGNvbnRleHQsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEYXRhIGZpbHRlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfEFycmF5LjxzdHJpbmc+fVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbc3RhY2s9ZmFsc2VdXG4gICAgICogQHBhcmFtIHsqfSBbY29udGV4dD10aGlzXVxuICAgICAqL1xuICAgIGxpc3RQcm90by5maWx0ZXJTZWxmID0gZnVuY3Rpb24gKGRpbWVuc2lvbnMsIGNiLCBzdGFjaywgY29udGV4dCkge1xuICAgICAgICBpZiAodHlwZW9mIGRpbWVuc2lvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNvbnRleHQgPSBzdGFjaztcbiAgICAgICAgICAgIHN0YWNrID0gY2I7XG4gICAgICAgICAgICBjYiA9IGRpbWVuc2lvbnM7XG4gICAgICAgICAgICBkaW1lbnNpb25zID0gW107XG4gICAgICAgIH1cblxuICAgICAgICBkaW1lbnNpb25zID0genJVdGlsLm1hcChcbiAgICAgICAgICAgIG5vcm1hbGl6ZURpbWVuc2lvbnMoZGltZW5zaW9ucyksIHRoaXMuZ2V0RGltZW5zaW9uLCB0aGlzXG4gICAgICAgICk7XG5cbiAgICAgICAgdmFyIG5ld0luZGljZXMgPSBbXTtcbiAgICAgICAgdmFyIHZhbHVlID0gW107XG4gICAgICAgIHZhciBkaW1TaXplID0gZGltZW5zaW9ucy5sZW5ndGg7XG4gICAgICAgIHZhciBpbmRpY2VzID0gdGhpcy5pbmRpY2VzO1xuXG4gICAgICAgIGNvbnRleHQgPSBjb250ZXh0IHx8IHRoaXM7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIga2VlcDtcbiAgICAgICAgICAgIC8vIFNpbXBsZSBvcHRpbWl6YXRpb25cbiAgICAgICAgICAgIGlmIChkaW1TaXplID09PSAxKSB7XG4gICAgICAgICAgICAgICAga2VlcCA9IGNiLmNhbGwoXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQsIHRoaXMuZ2V0KGRpbWVuc2lvbnNbMF0sIGksIHN0YWNrKSwgaVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGRpbVNpemU7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZVtrXSA9IHRoaXMuZ2V0KGRpbWVuc2lvbnNba10sIGksIHN0YWNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFsdWVba10gPSBpO1xuICAgICAgICAgICAgICAgIGtlZXAgPSBjYi5hcHBseShjb250ZXh0LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoa2VlcCkge1xuICAgICAgICAgICAgICAgIG5ld0luZGljZXMucHVzaChpbmRpY2VzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaW5kaWNlcyA9IG5ld0luZGljZXM7XG5cbiAgICAgICAgLy8gUmVzZXQgZGF0YSBleHRlbnRcbiAgICAgICAgdGhpcy5fZXh0ZW50ID0ge307XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERhdGEgbWFwcGluZyB0byBhIHBsYWluIGFycmF5XG4gICAgICogQHBhcmFtIHtzdHJpbmd8QXJyYXkuPHN0cmluZz59IFtkaW1lbnNpb25zXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbc3RhY2s9ZmFsc2VdXG4gICAgICogQHBhcmFtIHsqfSBbY29udGV4dD10aGlzXVxuICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAqL1xuICAgIGxpc3RQcm90by5tYXBBcnJheSA9IGZ1bmN0aW9uIChkaW1lbnNpb25zLCBjYiwgc3RhY2ssIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkaW1lbnNpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjb250ZXh0ID0gc3RhY2s7XG4gICAgICAgICAgICBzdGFjayA9IGNiO1xuICAgICAgICAgICAgY2IgPSBkaW1lbnNpb25zO1xuICAgICAgICAgICAgZGltZW5zaW9ucyA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICB0aGlzLmVhY2goZGltZW5zaW9ucywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goY2IgJiYgY2IuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgICAgIH0sIHN0YWNrLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gY2xvbmVMaXN0Rm9yTWFwQW5kU2FtcGxlKG9yaWdpbmFsLCBleGNsdWRlRGltZW5zaW9ucykge1xuICAgICAgICB2YXIgYWxsRGltZW5zaW9ucyA9IG9yaWdpbmFsLmRpbWVuc2lvbnM7XG4gICAgICAgIHZhciBsaXN0ID0gbmV3IExpc3QoXG4gICAgICAgICAgICB6clV0aWwubWFwKGFsbERpbWVuc2lvbnMsIG9yaWdpbmFsLmdldERpbWVuc2lvbkluZm8sIG9yaWdpbmFsKSxcbiAgICAgICAgICAgIG9yaWdpbmFsLmhvc3RNb2RlbFxuICAgICAgICApO1xuICAgICAgICAvLyBGSVhNRSBJZiBuZWVkcyBzdGFja2VkT24sIHZhbHVlIG1heSBhbHJlYWR5IGJlZW4gc3RhY2tlZFxuICAgICAgICB0cmFuc2ZlclByb3BlcnRpZXMobGlzdCwgb3JpZ2luYWwpO1xuXG4gICAgICAgIHZhciBzdG9yYWdlID0gbGlzdC5fc3RvcmFnZSA9IHt9O1xuICAgICAgICB2YXIgb3JpZ2luYWxTdG9yYWdlID0gb3JpZ2luYWwuX3N0b3JhZ2U7XG4gICAgICAgIC8vIEluaXQgc3RvcmFnZVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbERpbWVuc2lvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBkaW0gPSBhbGxEaW1lbnNpb25zW2ldO1xuICAgICAgICAgICAgdmFyIGRpbVN0b3JlID0gb3JpZ2luYWxTdG9yYWdlW2RpbV07XG4gICAgICAgICAgICBpZiAoenJVdGlsLmluZGV4T2YoZXhjbHVkZURpbWVuc2lvbnMsIGRpbSkgPj0gMCkge1xuICAgICAgICAgICAgICAgIHN0b3JhZ2VbZGltXSA9IG5ldyBkaW1TdG9yZS5jb25zdHJ1Y3RvcihcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxTdG9yYWdlW2RpbV0ubGVuZ3RoXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIERpcmVjdCByZWZlcmVuY2UgZm9yIG90aGVyIGRpbWVuc2lvbnNcbiAgICAgICAgICAgICAgICBzdG9yYWdlW2RpbV0gPSBvcmlnaW5hbFN0b3JhZ2VbZGltXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGlzdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEYXRhIG1hcHBpbmcgdG8gYSBuZXcgTGlzdCB3aXRoIGdpdmVuIGRpbWVuc2lvbnNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xBcnJheS48c3RyaW5nPn0gZGltZW5zaW9uc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbc3RhY2s9ZmFsc2VdXG4gICAgICogQHBhcmFtIHsqfSBbY29udGV4dD10aGlzXVxuICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAqL1xuICAgIGxpc3RQcm90by5tYXAgPSBmdW5jdGlvbiAoZGltZW5zaW9ucywgY2IsIHN0YWNrLCBjb250ZXh0KSB7XG4gICAgICAgIGRpbWVuc2lvbnMgPSB6clV0aWwubWFwKFxuICAgICAgICAgICAgbm9ybWFsaXplRGltZW5zaW9ucyhkaW1lbnNpb25zKSwgdGhpcy5nZXREaW1lbnNpb24sIHRoaXNcbiAgICAgICAgKTtcblxuICAgICAgICB2YXIgbGlzdCA9IGNsb25lTGlzdEZvck1hcEFuZFNhbXBsZSh0aGlzLCBkaW1lbnNpb25zKTtcbiAgICAgICAgLy8gRm9sbG93aW5nIHByb3BlcnRpZXMgYXJlIGFsbCBpbW11dGFibGUuXG4gICAgICAgIC8vIFNvIHdlIGNhbiByZWZlcmVuY2UgdG8gdGhlIHNhbWUgdmFsdWVcbiAgICAgICAgdmFyIGluZGljZXMgPSBsaXN0LmluZGljZXMgPSB0aGlzLmluZGljZXM7XG5cbiAgICAgICAgdmFyIHN0b3JhZ2UgPSBsaXN0Ll9zdG9yYWdlO1xuXG4gICAgICAgIHZhciB0bXBSZXRWYWx1ZSA9IFtdO1xuICAgICAgICB0aGlzLmVhY2goZGltZW5zaW9ucywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGlkeCA9IGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICB2YXIgcmV0VmFsdWUgPSBjYiAmJiBjYi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgaWYgKHJldFZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBhIG51bWJlclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmV0VmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIHRtcFJldFZhbHVlWzBdID0gcmV0VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHJldFZhbHVlID0gdG1wUmV0VmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmV0VmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpbSA9IGRpbWVuc2lvbnNbaV07XG4gICAgICAgICAgICAgICAgICAgIHZhciBkaW1TdG9yZSA9IHN0b3JhZ2VbZGltXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJhd0lkeCA9IGluZGljZXNbaWR4XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpbVN0b3JlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaW1TdG9yZVtyYXdJZHhdID0gcmV0VmFsdWVbaV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHN0YWNrLCBjb250ZXh0KTtcblxuICAgICAgICByZXR1cm4gbGlzdDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTGFyZ2UgZGF0YSBkb3duIHNhbXBsaW5nIG9uIGdpdmVuIGRpbWVuc2lvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkaW1lbnNpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHNhbXBsZVZhbHVlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc2FtcGxlSW5kZXggU2FtcGxlIGluZGV4IGZvciBuYW1lIGFuZCBpZFxuICAgICAqL1xuICAgIGxpc3RQcm90by5kb3duU2FtcGxlID0gZnVuY3Rpb24gKGRpbWVuc2lvbiwgcmF0ZSwgc2FtcGxlVmFsdWUsIHNhbXBsZUluZGV4KSB7XG4gICAgICAgIHZhciBsaXN0ID0gY2xvbmVMaXN0Rm9yTWFwQW5kU2FtcGxlKHRoaXMsIFtkaW1lbnNpb25dKTtcbiAgICAgICAgdmFyIHN0b3JhZ2UgPSB0aGlzLl9zdG9yYWdlO1xuICAgICAgICB2YXIgdGFyZ2V0U3RvcmFnZSA9IGxpc3QuX3N0b3JhZ2U7XG5cbiAgICAgICAgdmFyIG9yaWdpbmFsSW5kaWNlcyA9IHRoaXMuaW5kaWNlcztcbiAgICAgICAgdmFyIGluZGljZXMgPSBsaXN0LmluZGljZXMgPSBbXTtcblxuICAgICAgICB2YXIgZnJhbWVWYWx1ZXMgPSBbXTtcbiAgICAgICAgdmFyIGZyYW1lSW5kaWNlcyA9IFtdO1xuICAgICAgICB2YXIgZnJhbWVTaXplID0gTWF0aC5mbG9vcigxIC8gcmF0ZSk7XG5cbiAgICAgICAgdmFyIGRpbVN0b3JlID0gdGFyZ2V0U3RvcmFnZVtkaW1lbnNpb25dO1xuICAgICAgICB2YXIgbGVuID0gdGhpcy5jb3VudCgpO1xuICAgICAgICAvLyBDb3B5IGRhdGEgZnJvbSBvcmlnaW5hbCBkYXRhXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RvcmFnZVtkaW1lbnNpb25dLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0YXJnZXRTdG9yYWdlW2RpbWVuc2lvbl1baV0gPSBzdG9yYWdlW2RpbWVuc2lvbl1baV07XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gZnJhbWVTaXplKSB7XG4gICAgICAgICAgICAvLyBMYXN0IGZyYW1lXG4gICAgICAgICAgICBpZiAoZnJhbWVTaXplID4gbGVuIC0gaSkge1xuICAgICAgICAgICAgICAgIGZyYW1lU2l6ZSA9IGxlbiAtIGk7XG4gICAgICAgICAgICAgICAgZnJhbWVWYWx1ZXMubGVuZ3RoID0gZnJhbWVTaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBmcmFtZVNpemU7IGsrKykge1xuICAgICAgICAgICAgICAgIHZhciBpZHggPSBvcmlnaW5hbEluZGljZXNbaSArIGtdO1xuICAgICAgICAgICAgICAgIGZyYW1lVmFsdWVzW2tdID0gZGltU3RvcmVbaWR4XTtcbiAgICAgICAgICAgICAgICBmcmFtZUluZGljZXNba10gPSBpZHg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBzYW1wbGVWYWx1ZShmcmFtZVZhbHVlcyk7XG4gICAgICAgICAgICB2YXIgaWR4ID0gZnJhbWVJbmRpY2VzW3NhbXBsZUluZGV4KGZyYW1lVmFsdWVzLCB2YWx1ZSkgfHwgMF07XG4gICAgICAgICAgICAvLyBPbmx5IHdyaXRlIHZhbHVlIG9uIHRoZSBmaWx0ZXJlZCBkYXRhXG4gICAgICAgICAgICBkaW1TdG9yZVtpZHhdID0gdmFsdWU7XG4gICAgICAgICAgICBpbmRpY2VzLnB1c2goaWR4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsaXN0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgbW9kZWwgb2Ygb25lIGRhdGEgaXRlbS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpZHhcbiAgICAgKi9cbiAgICAvLyBGSVhNRSBNb2RlbCBwcm94eSA/XG4gICAgbGlzdFByb3RvLmdldEl0ZW1Nb2RlbCA9IGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgdmFyIGhvc3RNb2RlbCA9IHRoaXMuaG9zdE1vZGVsO1xuICAgICAgICBpZHggPSB0aGlzLmluZGljZXNbaWR4XTtcbiAgICAgICAgcmV0dXJuIG5ldyBNb2RlbCh0aGlzLl9yYXdEYXRhW2lkeF0sIGhvc3RNb2RlbCwgaG9zdE1vZGVsICYmIGhvc3RNb2RlbC5lY01vZGVsKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgZGF0YSBkaWZmZXJcbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2RhdGEvTGlzdH0gb3RoZXJMaXN0XG4gICAgICogQHJldHVybiB7bW9kdWxlOmVjaGFydHMvZGF0YS9EYXRhRGlmZmVyfVxuICAgICAqL1xuICAgIGxpc3RQcm90by5kaWZmID0gZnVuY3Rpb24gKG90aGVyTGlzdCkge1xuICAgICAgICB2YXIgaWRMaXN0ID0gdGhpcy5faWRMaXN0O1xuICAgICAgICB2YXIgb3RoZXJJZExpc3QgPSBvdGhlckxpc3QgJiYgb3RoZXJMaXN0Ll9pZExpc3Q7XG4gICAgICAgIHZhciB2YWw7XG4gICAgICAgIC8vIFVzZSBwcmVmaXggdG8gYXZvaWQgaW5kZXggdG8gYmUgdGhlIHNhbWUgYXMgb3RoZXJJZExpc3RbaWR4XSxcbiAgICAgICAgLy8gd2hpY2ggd2lsbCBjYXVzZSB3ZWlyZCB1ZHBhdGUgYW5pbWF0aW9uLlxuICAgICAgICB2YXIgcHJlZml4ID0gJ2VcXDBcXDAnO1xuXG4gICAgICAgIHJldHVybiBuZXcgRGF0YURpZmZlcihcbiAgICAgICAgICAgIG90aGVyTGlzdCA/IG90aGVyTGlzdC5pbmRpY2VzIDogW10sXG4gICAgICAgICAgICB0aGlzLmluZGljZXMsXG4gICAgICAgICAgICBmdW5jdGlvbiAoaWR4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh2YWwgPSBvdGhlcklkTGlzdFtpZHhdKSAhPSBudWxsID8gdmFsIDogcHJlZml4ICsgaWR4O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHZhbCA9IGlkTGlzdFtpZHhdKSAhPSBudWxsID8gdmFsIDogcHJlZml4ICsgaWR4O1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IHZpc3VhbCBwcm9wZXJ0eS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAgICovXG4gICAgbGlzdFByb3RvLmdldFZpc3VhbCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIHZpc3VhbCA9IHRoaXMuX3Zpc3VhbDtcbiAgICAgICAgcmV0dXJuIHZpc3VhbCAmJiB2aXN1YWxba2V5XTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0IHZpc3VhbCBwcm9wZXJ0eVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0ga2V5XG4gICAgICogQHBhcmFtIHsqfSBbdmFsdWVdXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICBzZXRWaXN1YWwoJ2NvbG9yJywgY29sb3IpO1xuICAgICAqICBzZXRWaXN1YWwoe1xuICAgICAqICAgICAgJ2NvbG9yJzogY29sb3JcbiAgICAgKiAgfSk7XG4gICAgICovXG4gICAgbGlzdFByb3RvLnNldFZpc3VhbCA9IGZ1bmN0aW9uIChrZXksIHZhbCkge1xuICAgICAgICBpZiAoaXNPYmplY3Qoa2V5KSkge1xuICAgICAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBrZXkpIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5Lmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0VmlzdWFsKG5hbWUsIGtleVtuYW1lXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Zpc3VhbCA9IHRoaXMuX3Zpc3VhbCB8fCB7fTtcbiAgICAgICAgdGhpcy5fdmlzdWFsW2tleV0gPSB2YWw7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldCBsYXlvdXQgcHJvcGVydHkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgICAqIEBwYXJhbSB7Kn0gW3ZhbF1cbiAgICAgKi9cbiAgICBsaXN0UHJvdG8uc2V0TGF5b3V0ID0gZnVuY3Rpb24gKGtleSwgdmFsKSB7XG4gICAgICAgIGlmIChpc09iamVjdChrZXkpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBuYW1lIGluIGtleSkge1xuICAgICAgICAgICAgICAgIGlmIChrZXkuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRMYXlvdXQobmFtZSwga2V5W25hbWVdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbGF5b3V0W2tleV0gPSB2YWw7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBsYXlvdXQgcHJvcGVydHkuXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBrZXkuXG4gICAgICogQHJldHVybiB7Kn1cbiAgICAgKi9cbiAgICBsaXN0UHJvdG8uZ2V0TGF5b3V0ID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGF5b3V0W2tleV07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBsYXlvdXQgb2Ygc2luZ2xlIGRhdGEgaXRlbVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpZHhcbiAgICAgKi9cbiAgICBsaXN0UHJvdG8uZ2V0SXRlbUxheW91dCA9IGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2l0ZW1MYXlvdXRzW2lkeF07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldCBsYXlvdXQgb2Ygc2luZ2xlIGRhdGEgaXRlbVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpZHhcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbGF5b3V0XG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gW21lcmdlPWZhbHNlXVxuICAgICAqL1xuICAgIGxpc3RQcm90by5zZXRJdGVtTGF5b3V0ID0gZnVuY3Rpb24gKGlkeCwgbGF5b3V0LCBtZXJnZSkge1xuICAgICAgICB0aGlzLl9pdGVtTGF5b3V0c1tpZHhdID0gbWVyZ2VcbiAgICAgICAgICAgID8genJVdGlsLmV4dGVuZCh0aGlzLl9pdGVtTGF5b3V0c1tpZHhdIHx8IHt9LCBsYXlvdXQpXG4gICAgICAgICAgICA6IGxheW91dDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2xlYXIgYWxsIGxheW91dCBvZiBzaW5nbGUgZGF0YSBpdGVtXG4gICAgICovXG4gICAgbGlzdFByb3RvLmNsZWFySXRlbUxheW91dHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2l0ZW1MYXlvdXRzLmxlbmd0aCA9IDA7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB2aXN1YWwgcHJvcGVydHkgb2Ygc2luZ2xlIGRhdGEgaXRlbVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpZHhcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAgICogQHBhcmFtIHtib29sZWFufSBpZ25vcmVQYXJlbnRcbiAgICAgKi9cbiAgICBsaXN0UHJvdG8uZ2V0SXRlbVZpc3VhbCA9IGZ1bmN0aW9uIChpZHgsIGtleSwgaWdub3JlUGFyZW50KSB7XG4gICAgICAgIHZhciBpdGVtVmlzdWFsID0gdGhpcy5faXRlbVZpc3VhbHNbaWR4XTtcbiAgICAgICAgdmFyIHZhbCA9IGl0ZW1WaXN1YWwgJiYgaXRlbVZpc3VhbFtrZXldO1xuICAgICAgICBpZiAodmFsID09IG51bGwgJiYgIWlnbm9yZVBhcmVudCkge1xuICAgICAgICAgICAgLy8gVXNlIGdsb2JhbCB2aXN1YWwgcHJvcGVydHlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFZpc3VhbChrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldCB2aXN1YWwgcHJvcGVydHkgb2Ygc2luZ2xlIGRhdGEgaXRlbVxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGlkeFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0ga2V5XG4gICAgICogQHBhcmFtIHsqfSBbdmFsdWVdXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICBzZXRJdGVtVmlzdWFsKDAsICdjb2xvcicsIGNvbG9yKTtcbiAgICAgKiAgc2V0SXRlbVZpc3VhbCgwLCB7XG4gICAgICogICAgICAnY29sb3InOiBjb2xvclxuICAgICAqICB9KTtcbiAgICAgKi9cbiAgICBsaXN0UHJvdG8uc2V0SXRlbVZpc3VhbCA9IGZ1bmN0aW9uIChpZHgsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGl0ZW1WaXN1YWwgPSB0aGlzLl9pdGVtVmlzdWFsc1tpZHhdIHx8IHt9O1xuICAgICAgICB0aGlzLl9pdGVtVmlzdWFsc1tpZHhdID0gaXRlbVZpc3VhbDtcblxuICAgICAgICBpZiAoaXNPYmplY3Qoa2V5KSkge1xuICAgICAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBrZXkpIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5Lmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1WaXN1YWxbbmFtZV0gPSBrZXlbbmFtZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGl0ZW1WaXN1YWxba2V5XSA9IHZhbHVlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDbGVhciBpdGVtVmlzdWFscyBhbmQgbGlzdCB2aXN1YWwuXG4gICAgICovXG4gICAgbGlzdFByb3RvLmNsZWFyQWxsVmlzdWFsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl92aXN1YWwgPSB7fTtcbiAgICAgICAgdGhpcy5faXRlbVZpc3VhbHMgPSBbXTtcbiAgICB9O1xuXG4gICAgdmFyIHNldEl0ZW1EYXRhQW5kU2VyaWVzSW5kZXggPSBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgY2hpbGQuc2VyaWVzSW5kZXggPSB0aGlzLnNlcmllc0luZGV4O1xuICAgICAgICBjaGlsZC5kYXRhSW5kZXggPSB0aGlzLmRhdGFJbmRleDtcbiAgICAgICAgY2hpbGQuZGF0YVR5cGUgPSB0aGlzLmRhdGFUeXBlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0IGdyYXBoaWMgZWxlbWVudCByZWxhdGl2ZSB0byBkYXRhLiBJdCBjYW4gYmUgc2V0IGFzIG51bGxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaWR4XG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBbZWxdXG4gICAgICovXG4gICAgbGlzdFByb3RvLnNldEl0ZW1HcmFwaGljRWwgPSBmdW5jdGlvbiAoaWR4LCBlbCkge1xuICAgICAgICB2YXIgaG9zdE1vZGVsID0gdGhpcy5ob3N0TW9kZWw7XG5cbiAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgICAvLyBBZGQgZGF0YSBpbmRleCBhbmQgc2VyaWVzIGluZGV4IGZvciBpbmRleGluZyB0aGUgZGF0YSBieSBlbGVtZW50XG4gICAgICAgICAgICAvLyBVc2VmdWwgaW4gdG9vbHRpcFxuICAgICAgICAgICAgZWwuZGF0YUluZGV4ID0gaWR4O1xuICAgICAgICAgICAgZWwuZGF0YVR5cGUgPSB0aGlzLmRhdGFUeXBlO1xuICAgICAgICAgICAgZWwuc2VyaWVzSW5kZXggPSBob3N0TW9kZWwgJiYgaG9zdE1vZGVsLnNlcmllc0luZGV4O1xuICAgICAgICAgICAgaWYgKGVsLnR5cGUgPT09ICdncm91cCcpIHtcbiAgICAgICAgICAgICAgICBlbC50cmF2ZXJzZShzZXRJdGVtRGF0YUFuZFNlcmllc0luZGV4LCBlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9ncmFwaGljRWxzW2lkeF0gPSBlbDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGlkeFxuICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9XG4gICAgICovXG4gICAgbGlzdFByb3RvLmdldEl0ZW1HcmFwaGljRWwgPSBmdW5jdGlvbiAoaWR4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ncmFwaGljRWxzW2lkeF07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gICAgICogQHBhcmFtIHsqfSBjb250ZXh0XG4gICAgICovXG4gICAgbGlzdFByb3RvLmVhY2hJdGVtR3JhcGhpY0VsID0gZnVuY3Rpb24gKGNiLCBjb250ZXh0KSB7XG4gICAgICAgIHpyVXRpbC5lYWNoKHRoaXMuX2dyYXBoaWNFbHMsIGZ1bmN0aW9uIChlbCwgaWR4KSB7XG4gICAgICAgICAgICBpZiAoZWwpIHtcbiAgICAgICAgICAgICAgICBjYiAmJiBjYi5jYWxsKGNvbnRleHQsIGVsLCBpZHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2hhbGxvdyBjbG9uZSBhIG5ldyBsaXN0IGV4Y2VwdCB2aXN1YWwgYW5kIGxheW91dCBwcm9wZXJ0aWVzLCBhbmQgZ3JhcGggZWxlbWVudHMuXG4gICAgICogTmV3IGxpc3Qgb25seSBjaGFuZ2UgdGhlIGluZGljZXMuXG4gICAgICovXG4gICAgbGlzdFByb3RvLmNsb25lU2hhbGxvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRpbWVuc2lvbkluZm9MaXN0ID0genJVdGlsLm1hcCh0aGlzLmRpbWVuc2lvbnMsIHRoaXMuZ2V0RGltZW5zaW9uSW5mbywgdGhpcyk7XG4gICAgICAgIHZhciBsaXN0ID0gbmV3IExpc3QoZGltZW5zaW9uSW5mb0xpc3QsIHRoaXMuaG9zdE1vZGVsKTtcblxuICAgICAgICAvLyBGSVhNRVxuICAgICAgICBsaXN0Ll9zdG9yYWdlID0gdGhpcy5fc3RvcmFnZTtcblxuICAgICAgICB0cmFuc2ZlclByb3BlcnRpZXMobGlzdCwgdGhpcyk7XG5cblxuICAgICAgICAvLyBDbG9uZSB3aWxsIG5vdCBjaGFuZ2UgdGhlIGRhdGEgZXh0ZW50IGFuZCBpbmRpY2VzXG4gICAgICAgIGxpc3QuaW5kaWNlcyA9IHRoaXMuaW5kaWNlcy5zbGljZSgpO1xuXG4gICAgICAgIGlmICh0aGlzLl9leHRlbnQpIHtcbiAgICAgICAgICAgIGxpc3QuX2V4dGVudCA9IHpyVXRpbC5leHRlbmQoe30sIHRoaXMuX2V4dGVudCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGlzdDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogV3JhcCBzb21lIG1ldGhvZCB0byBhZGQgbW9yZSBmZWF0dXJlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZE5hbWVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpbmplY3RGdW5jdGlvblxuICAgICAqL1xuICAgIGxpc3RQcm90by53cmFwTWV0aG9kID0gZnVuY3Rpb24gKG1ldGhvZE5hbWUsIGluamVjdEZ1bmN0aW9uKSB7XG4gICAgICAgIHZhciBvcmlnaW5hbE1ldGhvZCA9IHRoaXNbbWV0aG9kTmFtZV07XG4gICAgICAgIGlmICh0eXBlb2Ygb3JpZ2luYWxNZXRob2QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9fd3JhcHBlZE1ldGhvZHMgPSB0aGlzLl9fd3JhcHBlZE1ldGhvZHMgfHwgW107XG4gICAgICAgIHRoaXMuX193cmFwcGVkTWV0aG9kcy5wdXNoKG1ldGhvZE5hbWUpO1xuICAgICAgICB0aGlzW21ldGhvZE5hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJlcyA9IG9yaWdpbmFsTWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICByZXR1cm4gaW5qZWN0RnVuY3Rpb24uYXBwbHkodGhpcywgW3Jlc10uY29uY2F0KHpyVXRpbC5zbGljZShhcmd1bWVudHMpKSk7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIC8vIE1ldGhvZHMgdGhhdCBjcmVhdGUgYSBuZXcgbGlzdCBiYXNlZCBvbiB0aGlzIGxpc3Qgc2hvdWxkIGJlIGxpc3RlZCBoZXJlLlxuICAgIC8vIE5vdGljZSB0aGF0IHRob3NlIG1ldGhvZCBzaG91bGQgYFJFVFVSTmAgdGhlIG5ldyBsaXN0LlxuICAgIGxpc3RQcm90by5UUkFOU0ZFUkFCTEVfTUVUSE9EUyA9IFsnY2xvbmVTaGFsbG93JywgJ2Rvd25TYW1wbGUnLCAnbWFwJ107XG4gICAgLy8gTWV0aG9kcyB0aGF0IGNoYW5nZSBpbmRpY2VzIG9mIHRoaXMgbGlzdCBzaG91bGQgYmUgbGlzdGVkIGhlcmUuXG4gICAgbGlzdFByb3RvLkNIQU5HQUJMRV9NRVRIT0RTID0gWydmaWx0ZXJTZWxmJ107XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IExpc3Q7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9kYXRhL0xpc3QuanNcbi8vIG1vZHVsZSBpZCA9IDEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0EiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 14 */
/* unknown exports provided */
/* all exports used */
/*!***************************!*\
  !*** ./lib/util/clazz.js ***!
  \***************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 0);\n\n    var clazz = {};\n\n    var TYPE_DELIMITER = '.';\n    var IS_CONTAINER = '___EC__COMPONENT__CONTAINER___';\n    var MEMBER_PRIFIX = '\\0ec_\\0';\n\n    /**\n     * Hide private class member.\n     * The same behavior as `host[name] = value;` (can be right-value)\n     * @public\n     */\n    clazz.set = function (host, name, value) {\n        return (host[MEMBER_PRIFIX + name] = value);\n    };\n\n    /**\n     * Hide private class member.\n     * The same behavior as `host[name];`\n     * @public\n     */\n    clazz.get = function (host, name) {\n        return host[MEMBER_PRIFIX + name];\n    };\n\n    /**\n     * For hidden private class member.\n     * The same behavior as `host.hasOwnProperty(name);`\n     * @public\n     */\n    clazz.hasOwn = function (host, name) {\n        return host.hasOwnProperty(MEMBER_PRIFIX + name);\n    };\n\n    /**\n     * Notice, parseClassType('') should returns {main: '', sub: ''}\n     * @public\n     */\n    var parseClassType = clazz.parseClassType = function (componentType) {\n        var ret = {main: '', sub: ''};\n        if (componentType) {\n            componentType = componentType.split(TYPE_DELIMITER);\n            ret.main = componentType[0] || '';\n            ret.sub = componentType[1] || '';\n        }\n        return ret;\n    };\n\n    /**\n     * @public\n     */\n    function checkClassType(componentType) {\n        zrUtil.assert(\n            /^[a-zA-Z0-9_]+([.][a-zA-Z0-9_]+)?$/.test(componentType),\n            'componentType \"' + componentType + '\" illegal'\n        );\n    }\n\n    /**\n     * @public\n     */\n    clazz.enableClassExtend = function (RootClass, mandatoryMethods) {\n\n        RootClass.$constructor = RootClass;\n        RootClass.extend = function (proto) {\n\n            if (true) {\n                zrUtil.each(mandatoryMethods, function (method) {\n                    if (!proto[method]) {\n                        console.warn(\n                            'Method `' + method + '` should be implemented'\n                            + (proto.type ? ' in ' + proto.type : '') + '.'\n                        );\n                    }\n                });\n            }\n\n            var superClass = this;\n            var ExtendedClass = function () {\n                if (!proto.$constructor) {\n                    superClass.apply(this, arguments);\n                }\n                else {\n                    proto.$constructor.apply(this, arguments);\n                }\n            };\n\n            zrUtil.extend(ExtendedClass.prototype, proto);\n\n            ExtendedClass.extend = this.extend;\n            ExtendedClass.superCall = superCall;\n            ExtendedClass.superApply = superApply;\n            zrUtil.inherits(ExtendedClass, this);\n            ExtendedClass.superClass = superClass;\n\n            return ExtendedClass;\n        };\n    };\n\n    // superCall should have class info, which can not be fetch from 'this'.\n    // Consider this case:\n    // class A has method f,\n    // class B inherits class A, overrides method f, f call superApply('f'),\n    // class C inherits class B, do not overrides method f,\n    // then when method of class C is called, dead loop occured.\n    function superCall(context, methodName) {\n        var args = zrUtil.slice(arguments, 2);\n        return this.superClass.prototype[methodName].apply(context, args);\n    }\n\n    function superApply(context, methodName, args) {\n        return this.superClass.prototype[methodName].apply(context, args);\n    }\n\n    /**\n     * @param {Object} entity\n     * @param {Object} options\n     * @param {boolean} [options.registerWhenExtend]\n     * @public\n     */\n    clazz.enableClassManagement = function (entity, options) {\n        options = options || {};\n\n        /**\n         * Component model classes\n         * key: componentType,\n         * value:\n         *     componentClass, when componentType is 'xxx'\n         *     or Object.<subKey, componentClass>, when componentType is 'xxx.yy'\n         * @type {Object}\n         */\n        var storage = {};\n\n        entity.registerClass = function (Clazz, componentType) {\n            if (componentType) {\n                checkClassType(componentType);\n                componentType = parseClassType(componentType);\n\n                if (!componentType.sub) {\n                    if (true) {\n                        if (storage[componentType.main]) {\n                            console.warn(componentType.main + ' exists.');\n                        }\n                    }\n                    storage[componentType.main] = Clazz;\n                }\n                else if (componentType.sub !== IS_CONTAINER) {\n                    var container = makeContainer(componentType);\n                    container[componentType.sub] = Clazz;\n                }\n            }\n            return Clazz;\n        };\n\n        entity.getClass = function (componentMainType, subType, throwWhenNotFound) {\n            var Clazz = storage[componentMainType];\n\n            if (Clazz && Clazz[IS_CONTAINER]) {\n                Clazz = subType ? Clazz[subType] : null;\n            }\n\n            if (throwWhenNotFound && !Clazz) {\n                throw new Error(\n                    !subType\n                        ? componentMainType + '.' + 'type should be specified.'\n                        : 'Component ' + componentMainType + '.' + (subType || '') + ' not exists. Load it first.'\n                );\n            }\n\n            return Clazz;\n        };\n\n        entity.getClassesByMainType = function (componentType) {\n            componentType = parseClassType(componentType);\n\n            var result = [];\n            var obj = storage[componentType.main];\n\n            if (obj && obj[IS_CONTAINER]) {\n                zrUtil.each(obj, function (o, type) {\n                    type !== IS_CONTAINER && result.push(o);\n                });\n            }\n            else {\n                result.push(obj);\n            }\n\n            return result;\n        };\n\n        entity.hasClass = function (componentType) {\n            // Just consider componentType.main.\n            componentType = parseClassType(componentType);\n            return !!storage[componentType.main];\n        };\n\n        /**\n         * @return {Array.<string>} Like ['aa', 'bb'], but can not be ['aa.xx']\n         */\n        entity.getAllClassMainTypes = function () {\n            var types = [];\n            zrUtil.each(storage, function (obj, type) {\n                types.push(type);\n            });\n            return types;\n        };\n\n        /**\n         * If a main type is container and has sub types\n         * @param  {string}  mainType\n         * @return {boolean}\n         */\n        entity.hasSubTypes = function (componentType) {\n            componentType = parseClassType(componentType);\n            var obj = storage[componentType.main];\n            return obj && obj[IS_CONTAINER];\n        };\n\n        entity.parseClassType = parseClassType;\n\n        function makeContainer(componentType) {\n            var container = storage[componentType.main];\n            if (!container || !container[IS_CONTAINER]) {\n                container = storage[componentType.main] = {};\n                container[IS_CONTAINER] = true;\n            }\n            return container;\n        }\n\n        if (options.registerWhenExtend) {\n            var originalExtend = entity.extend;\n            if (originalExtend) {\n                entity.extend = function (proto) {\n                    var ExtendedClass = originalExtend.call(this, proto);\n                    return entity.registerClass(ExtendedClass, proto.type);\n                };\n            }\n        }\n\n        return entity;\n    };\n\n    /**\n     * @param {string|Array.<string>} properties\n     */\n    clazz.setReadOnly = function (obj, properties) {\n        // FIXME It seems broken in IE8 simulation of IE11\n        // if (!zrUtil.isArray(properties)) {\n        //     properties = properties != null ? [properties] : [];\n        // }\n        // zrUtil.each(properties, function (prop) {\n        //     var value = obj[prop];\n\n        //     Object.defineProperty\n        //         && Object.defineProperty(obj, prop, {\n        //             value: value, writable: false\n        //         });\n        //     zrUtil.isArray(obj[prop])\n        //         && Object.freeze\n        //         && Object.freeze(obj[prop]);\n        // });\n    };\n\n    module.exports = clazz;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvdXRpbC9jbGF6ei5qcz83ZjJjIl0sInNvdXJjZXNDb250ZW50IjpbIlxuXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuXG4gICAgdmFyIGNsYXp6ID0ge307XG5cbiAgICB2YXIgVFlQRV9ERUxJTUlURVIgPSAnLic7XG4gICAgdmFyIElTX0NPTlRBSU5FUiA9ICdfX19FQ19fQ09NUE9ORU5UX19DT05UQUlORVJfX18nO1xuICAgIHZhciBNRU1CRVJfUFJJRklYID0gJ1xcMGVjX1xcMCc7XG5cbiAgICAvKipcbiAgICAgKiBIaWRlIHByaXZhdGUgY2xhc3MgbWVtYmVyLlxuICAgICAqIFRoZSBzYW1lIGJlaGF2aW9yIGFzIGBob3N0W25hbWVdID0gdmFsdWU7YCAoY2FuIGJlIHJpZ2h0LXZhbHVlKVxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBjbGF6ei5zZXQgPSBmdW5jdGlvbiAoaG9zdCwgbmFtZSwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIChob3N0W01FTUJFUl9QUklGSVggKyBuYW1lXSA9IHZhbHVlKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSGlkZSBwcml2YXRlIGNsYXNzIG1lbWJlci5cbiAgICAgKiBUaGUgc2FtZSBiZWhhdmlvciBhcyBgaG9zdFtuYW1lXTtgXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGNsYXp6LmdldCA9IGZ1bmN0aW9uIChob3N0LCBuYW1lKSB7XG4gICAgICAgIHJldHVybiBob3N0W01FTUJFUl9QUklGSVggKyBuYW1lXTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRm9yIGhpZGRlbiBwcml2YXRlIGNsYXNzIG1lbWJlci5cbiAgICAgKiBUaGUgc2FtZSBiZWhhdmlvciBhcyBgaG9zdC5oYXNPd25Qcm9wZXJ0eShuYW1lKTtgXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGNsYXp6Lmhhc093biA9IGZ1bmN0aW9uIChob3N0LCBuYW1lKSB7XG4gICAgICAgIHJldHVybiBob3N0Lmhhc093blByb3BlcnR5KE1FTUJFUl9QUklGSVggKyBuYW1lKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTm90aWNlLCBwYXJzZUNsYXNzVHlwZSgnJykgc2hvdWxkIHJldHVybnMge21haW46ICcnLCBzdWI6ICcnfVxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICB2YXIgcGFyc2VDbGFzc1R5cGUgPSBjbGF6ei5wYXJzZUNsYXNzVHlwZSA9IGZ1bmN0aW9uIChjb21wb25lbnRUeXBlKSB7XG4gICAgICAgIHZhciByZXQgPSB7bWFpbjogJycsIHN1YjogJyd9O1xuICAgICAgICBpZiAoY29tcG9uZW50VHlwZSkge1xuICAgICAgICAgICAgY29tcG9uZW50VHlwZSA9IGNvbXBvbmVudFR5cGUuc3BsaXQoVFlQRV9ERUxJTUlURVIpO1xuICAgICAgICAgICAgcmV0Lm1haW4gPSBjb21wb25lbnRUeXBlWzBdIHx8ICcnO1xuICAgICAgICAgICAgcmV0LnN1YiA9IGNvbXBvbmVudFR5cGVbMV0gfHwgJyc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNoZWNrQ2xhc3NUeXBlKGNvbXBvbmVudFR5cGUpIHtcbiAgICAgICAgenJVdGlsLmFzc2VydChcbiAgICAgICAgICAgIC9eW2EtekEtWjAtOV9dKyhbLl1bYS16QS1aMC05X10rKT8kLy50ZXN0KGNvbXBvbmVudFR5cGUpLFxuICAgICAgICAgICAgJ2NvbXBvbmVudFR5cGUgXCInICsgY29tcG9uZW50VHlwZSArICdcIiBpbGxlZ2FsJ1xuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBjbGF6ei5lbmFibGVDbGFzc0V4dGVuZCA9IGZ1bmN0aW9uIChSb290Q2xhc3MsIG1hbmRhdG9yeU1ldGhvZHMpIHtcblxuICAgICAgICBSb290Q2xhc3MuJGNvbnN0cnVjdG9yID0gUm9vdENsYXNzO1xuICAgICAgICBSb290Q2xhc3MuZXh0ZW5kID0gZnVuY3Rpb24gKHByb3RvKSB7XG5cbiAgICAgICAgICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgICAgICAgICAgenJVdGlsLmVhY2gobWFuZGF0b3J5TWV0aG9kcywgZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXByb3RvW21ldGhvZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnTWV0aG9kIGAnICsgbWV0aG9kICsgJ2Agc2hvdWxkIGJlIGltcGxlbWVudGVkJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgKHByb3RvLnR5cGUgPyAnIGluICcgKyBwcm90by50eXBlIDogJycpICsgJy4nXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzdXBlckNsYXNzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBFeHRlbmRlZENsYXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICghcHJvdG8uJGNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1cGVyQ2xhc3MuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3RvLiRjb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHpyVXRpbC5leHRlbmQoRXh0ZW5kZWRDbGFzcy5wcm90b3R5cGUsIHByb3RvKTtcblxuICAgICAgICAgICAgRXh0ZW5kZWRDbGFzcy5leHRlbmQgPSB0aGlzLmV4dGVuZDtcbiAgICAgICAgICAgIEV4dGVuZGVkQ2xhc3Muc3VwZXJDYWxsID0gc3VwZXJDYWxsO1xuICAgICAgICAgICAgRXh0ZW5kZWRDbGFzcy5zdXBlckFwcGx5ID0gc3VwZXJBcHBseTtcbiAgICAgICAgICAgIHpyVXRpbC5pbmhlcml0cyhFeHRlbmRlZENsYXNzLCB0aGlzKTtcbiAgICAgICAgICAgIEV4dGVuZGVkQ2xhc3Muc3VwZXJDbGFzcyA9IHN1cGVyQ2xhc3M7XG5cbiAgICAgICAgICAgIHJldHVybiBFeHRlbmRlZENsYXNzO1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICAvLyBzdXBlckNhbGwgc2hvdWxkIGhhdmUgY2xhc3MgaW5mbywgd2hpY2ggY2FuIG5vdCBiZSBmZXRjaCBmcm9tICd0aGlzJy5cbiAgICAvLyBDb25zaWRlciB0aGlzIGNhc2U6XG4gICAgLy8gY2xhc3MgQSBoYXMgbWV0aG9kIGYsXG4gICAgLy8gY2xhc3MgQiBpbmhlcml0cyBjbGFzcyBBLCBvdmVycmlkZXMgbWV0aG9kIGYsIGYgY2FsbCBzdXBlckFwcGx5KCdmJyksXG4gICAgLy8gY2xhc3MgQyBpbmhlcml0cyBjbGFzcyBCLCBkbyBub3Qgb3ZlcnJpZGVzIG1ldGhvZCBmLFxuICAgIC8vIHRoZW4gd2hlbiBtZXRob2Qgb2YgY2xhc3MgQyBpcyBjYWxsZWQsIGRlYWQgbG9vcCBvY2N1cmVkLlxuICAgIGZ1bmN0aW9uIHN1cGVyQ2FsbChjb250ZXh0LCBtZXRob2ROYW1lKSB7XG4gICAgICAgIHZhciBhcmdzID0genJVdGlsLnNsaWNlKGFyZ3VtZW50cywgMik7XG4gICAgICAgIHJldHVybiB0aGlzLnN1cGVyQ2xhc3MucHJvdG90eXBlW21ldGhvZE5hbWVdLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN1cGVyQXBwbHkoY29udGV4dCwgbWV0aG9kTmFtZSwgYXJncykge1xuICAgICAgICByZXR1cm4gdGhpcy5zdXBlckNsYXNzLnByb3RvdHlwZVttZXRob2ROYW1lXS5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZW50aXR5XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnJlZ2lzdGVyV2hlbkV4dGVuZF1cbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgY2xhenouZW5hYmxlQ2xhc3NNYW5hZ2VtZW50ID0gZnVuY3Rpb24gKGVudGl0eSwgb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29tcG9uZW50IG1vZGVsIGNsYXNzZXNcbiAgICAgICAgICoga2V5OiBjb21wb25lbnRUeXBlLFxuICAgICAgICAgKiB2YWx1ZTpcbiAgICAgICAgICogICAgIGNvbXBvbmVudENsYXNzLCB3aGVuIGNvbXBvbmVudFR5cGUgaXMgJ3h4eCdcbiAgICAgICAgICogICAgIG9yIE9iamVjdC48c3ViS2V5LCBjb21wb25lbnRDbGFzcz4sIHdoZW4gY29tcG9uZW50VHlwZSBpcyAneHh4Lnl5J1xuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIHN0b3JhZ2UgPSB7fTtcblxuICAgICAgICBlbnRpdHkucmVnaXN0ZXJDbGFzcyA9IGZ1bmN0aW9uIChDbGF6eiwgY29tcG9uZW50VHlwZSkge1xuICAgICAgICAgICAgaWYgKGNvbXBvbmVudFR5cGUpIHtcbiAgICAgICAgICAgICAgICBjaGVja0NsYXNzVHlwZShjb21wb25lbnRUeXBlKTtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRUeXBlID0gcGFyc2VDbGFzc1R5cGUoY29tcG9uZW50VHlwZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWNvbXBvbmVudFR5cGUuc3ViKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RvcmFnZVtjb21wb25lbnRUeXBlLm1haW5dKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGNvbXBvbmVudFR5cGUubWFpbiArICcgZXhpc3RzLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN0b3JhZ2VbY29tcG9uZW50VHlwZS5tYWluXSA9IENsYXp6O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjb21wb25lbnRUeXBlLnN1YiAhPT0gSVNfQ09OVEFJTkVSKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250YWluZXIgPSBtYWtlQ29udGFpbmVyKGNvbXBvbmVudFR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBjb250YWluZXJbY29tcG9uZW50VHlwZS5zdWJdID0gQ2xheno7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIENsYXp6O1xuICAgICAgICB9O1xuXG4gICAgICAgIGVudGl0eS5nZXRDbGFzcyA9IGZ1bmN0aW9uIChjb21wb25lbnRNYWluVHlwZSwgc3ViVHlwZSwgdGhyb3dXaGVuTm90Rm91bmQpIHtcbiAgICAgICAgICAgIHZhciBDbGF6eiA9IHN0b3JhZ2VbY29tcG9uZW50TWFpblR5cGVdO1xuXG4gICAgICAgICAgICBpZiAoQ2xhenogJiYgQ2xhenpbSVNfQ09OVEFJTkVSXSkge1xuICAgICAgICAgICAgICAgIENsYXp6ID0gc3ViVHlwZSA/IENsYXp6W3N1YlR5cGVdIDogbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRocm93V2hlbk5vdEZvdW5kICYmICFDbGF6eikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgIXN1YlR5cGVcbiAgICAgICAgICAgICAgICAgICAgICAgID8gY29tcG9uZW50TWFpblR5cGUgKyAnLicgKyAndHlwZSBzaG91bGQgYmUgc3BlY2lmaWVkLidcbiAgICAgICAgICAgICAgICAgICAgICAgIDogJ0NvbXBvbmVudCAnICsgY29tcG9uZW50TWFpblR5cGUgKyAnLicgKyAoc3ViVHlwZSB8fCAnJykgKyAnIG5vdCBleGlzdHMuIExvYWQgaXQgZmlyc3QuJ1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBDbGF6ejtcbiAgICAgICAgfTtcblxuICAgICAgICBlbnRpdHkuZ2V0Q2xhc3Nlc0J5TWFpblR5cGUgPSBmdW5jdGlvbiAoY29tcG9uZW50VHlwZSkge1xuICAgICAgICAgICAgY29tcG9uZW50VHlwZSA9IHBhcnNlQ2xhc3NUeXBlKGNvbXBvbmVudFR5cGUpO1xuXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgICAgICB2YXIgb2JqID0gc3RvcmFnZVtjb21wb25lbnRUeXBlLm1haW5dO1xuXG4gICAgICAgICAgICBpZiAob2JqICYmIG9ialtJU19DT05UQUlORVJdKSB7XG4gICAgICAgICAgICAgICAgenJVdGlsLmVhY2gob2JqLCBmdW5jdGlvbiAobywgdHlwZSkge1xuICAgICAgICAgICAgICAgICAgICB0eXBlICE9PSBJU19DT05UQUlORVIgJiYgcmVzdWx0LnB1c2gobyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChvYmopO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuXG4gICAgICAgIGVudGl0eS5oYXNDbGFzcyA9IGZ1bmN0aW9uIChjb21wb25lbnRUeXBlKSB7XG4gICAgICAgICAgICAvLyBKdXN0IGNvbnNpZGVyIGNvbXBvbmVudFR5cGUubWFpbi5cbiAgICAgICAgICAgIGNvbXBvbmVudFR5cGUgPSBwYXJzZUNsYXNzVHlwZShjb21wb25lbnRUeXBlKTtcbiAgICAgICAgICAgIHJldHVybiAhIXN0b3JhZ2VbY29tcG9uZW50VHlwZS5tYWluXTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7QXJyYXkuPHN0cmluZz59IExpa2UgWydhYScsICdiYiddLCBidXQgY2FuIG5vdCBiZSBbJ2FhLnh4J11cbiAgICAgICAgICovXG4gICAgICAgIGVudGl0eS5nZXRBbGxDbGFzc01haW5UeXBlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB0eXBlcyA9IFtdO1xuICAgICAgICAgICAgenJVdGlsLmVhY2goc3RvcmFnZSwgZnVuY3Rpb24gKG9iaiwgdHlwZSkge1xuICAgICAgICAgICAgICAgIHR5cGVzLnB1c2godHlwZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0eXBlcztcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgYSBtYWluIHR5cGUgaXMgY29udGFpbmVyIGFuZCBoYXMgc3ViIHR5cGVzXG4gICAgICAgICAqIEBwYXJhbSAge3N0cmluZ30gIG1haW5UeXBlXG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBlbnRpdHkuaGFzU3ViVHlwZXMgPSBmdW5jdGlvbiAoY29tcG9uZW50VHlwZSkge1xuICAgICAgICAgICAgY29tcG9uZW50VHlwZSA9IHBhcnNlQ2xhc3NUeXBlKGNvbXBvbmVudFR5cGUpO1xuICAgICAgICAgICAgdmFyIG9iaiA9IHN0b3JhZ2VbY29tcG9uZW50VHlwZS5tYWluXTtcbiAgICAgICAgICAgIHJldHVybiBvYmogJiYgb2JqW0lTX0NPTlRBSU5FUl07XG4gICAgICAgIH07XG5cbiAgICAgICAgZW50aXR5LnBhcnNlQ2xhc3NUeXBlID0gcGFyc2VDbGFzc1R5cGU7XG5cbiAgICAgICAgZnVuY3Rpb24gbWFrZUNvbnRhaW5lcihjb21wb25lbnRUeXBlKSB7XG4gICAgICAgICAgICB2YXIgY29udGFpbmVyID0gc3RvcmFnZVtjb21wb25lbnRUeXBlLm1haW5dO1xuICAgICAgICAgICAgaWYgKCFjb250YWluZXIgfHwgIWNvbnRhaW5lcltJU19DT05UQUlORVJdKSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyID0gc3RvcmFnZVtjb21wb25lbnRUeXBlLm1haW5dID0ge307XG4gICAgICAgICAgICAgICAgY29udGFpbmVyW0lTX0NPTlRBSU5FUl0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLnJlZ2lzdGVyV2hlbkV4dGVuZCkge1xuICAgICAgICAgICAgdmFyIG9yaWdpbmFsRXh0ZW5kID0gZW50aXR5LmV4dGVuZDtcbiAgICAgICAgICAgIGlmIChvcmlnaW5hbEV4dGVuZCkge1xuICAgICAgICAgICAgICAgIGVudGl0eS5leHRlbmQgPSBmdW5jdGlvbiAocHJvdG8pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIEV4dGVuZGVkQ2xhc3MgPSBvcmlnaW5hbEV4dGVuZC5jYWxsKHRoaXMsIHByb3RvKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVudGl0eS5yZWdpc3RlckNsYXNzKEV4dGVuZGVkQ2xhc3MsIHByb3RvLnR5cGUpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZW50aXR5O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xBcnJheS48c3RyaW5nPn0gcHJvcGVydGllc1xuICAgICAqL1xuICAgIGNsYXp6LnNldFJlYWRPbmx5ID0gZnVuY3Rpb24gKG9iaiwgcHJvcGVydGllcykge1xuICAgICAgICAvLyBGSVhNRSBJdCBzZWVtcyBicm9rZW4gaW4gSUU4IHNpbXVsYXRpb24gb2YgSUUxMVxuICAgICAgICAvLyBpZiAoIXpyVXRpbC5pc0FycmF5KHByb3BlcnRpZXMpKSB7XG4gICAgICAgIC8vICAgICBwcm9wZXJ0aWVzID0gcHJvcGVydGllcyAhPSBudWxsID8gW3Byb3BlcnRpZXNdIDogW107XG4gICAgICAgIC8vIH1cbiAgICAgICAgLy8genJVdGlsLmVhY2gocHJvcGVydGllcywgZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgLy8gICAgIHZhciB2YWx1ZSA9IG9ialtwcm9wXTtcblxuICAgICAgICAvLyAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5XG4gICAgICAgIC8vICAgICAgICAgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgcHJvcCwge1xuICAgICAgICAvLyAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsIHdyaXRhYmxlOiBmYWxzZVxuICAgICAgICAvLyAgICAgICAgIH0pO1xuICAgICAgICAvLyAgICAgenJVdGlsLmlzQXJyYXkob2JqW3Byb3BdKVxuICAgICAgICAvLyAgICAgICAgICYmIE9iamVjdC5mcmVlemVcbiAgICAgICAgLy8gICAgICAgICAmJiBPYmplY3QuZnJlZXplKG9ialtwcm9wXSk7XG4gICAgICAgIC8vIH0pO1xuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGNsYXp6O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvdXRpbC9jbGF6ei5qc1xuLy8gbW9kdWxlIGlkID0gMTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 15 */
/* unknown exports provided */
/* all exports used */
/*!**********************************************!*\
  !*** /home/yx/~/zrender/lib/contain/text.js ***!
  \**********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var textWidthCache = {};\n    var textWidthCacheCounter = 0;\n    var TEXT_CACHE_MAX = 5000;\n\n    var util = __webpack_require__(/*! ../core/util */ 0);\n    var BoundingRect = __webpack_require__(/*! ../core/BoundingRect */ 10);\n    var retrieve = util.retrieve;\n\n    function getTextWidth(text, textFont) {\n        var key = text + ':' + textFont;\n        if (textWidthCache[key]) {\n            return textWidthCache[key];\n        }\n\n        var textLines = (text + '').split('\\n');\n        var width = 0;\n\n        for (var i = 0, l = textLines.length; i < l; i++) {\n            // measureText 可以被覆盖以兼容不支持 Canvas 的环境\n            width = Math.max(textContain.measureText(textLines[i], textFont).width, width);\n        }\n\n        if (textWidthCacheCounter > TEXT_CACHE_MAX) {\n            textWidthCacheCounter = 0;\n            textWidthCache = {};\n        }\n        textWidthCacheCounter++;\n        textWidthCache[key] = width;\n\n        return width;\n    }\n\n    function getTextRect(text, textFont, textAlign, textBaseline) {\n        var textLineLen = ((text || '') + '').split('\\n').length;\n\n        var width = getTextWidth(text, textFont);\n        // FIXME 高度计算比较粗暴\n        var lineHeight = getTextWidth('国', textFont);\n        var height = textLineLen * lineHeight;\n\n        var rect = new BoundingRect(0, 0, width, height);\n        // Text has a special line height property\n        rect.lineHeight = lineHeight;\n\n        switch (textBaseline) {\n            case 'bottom':\n            case 'alphabetic':\n                rect.y -= lineHeight;\n                break;\n            case 'middle':\n                rect.y -= lineHeight / 2;\n                break;\n            // case 'hanging':\n            // case 'top':\n        }\n\n        // FIXME Right to left language\n        switch (textAlign) {\n            case 'end':\n            case 'right':\n                rect.x -= rect.width;\n                break;\n            case 'center':\n                rect.x -= rect.width / 2;\n                break;\n            // case 'start':\n            // case 'left':\n        }\n\n        return rect;\n    }\n\n    function adjustTextPositionOnRect(textPosition, rect, textRect, distance) {\n\n        var x = rect.x;\n        var y = rect.y;\n\n        var height = rect.height;\n        var width = rect.width;\n\n        var textHeight = textRect.height;\n\n        var lineHeight = textRect.lineHeight;\n        var halfHeight = height / 2 - textHeight / 2 + lineHeight;\n\n        var textAlign = 'left';\n\n        switch (textPosition) {\n            case 'left':\n                x -= distance;\n                y += halfHeight;\n                textAlign = 'right';\n                break;\n            case 'right':\n                x += distance + width;\n                y += halfHeight;\n                textAlign = 'left';\n                break;\n            case 'top':\n                x += width / 2;\n                y -= distance + textHeight - lineHeight;\n                textAlign = 'center';\n                break;\n            case 'bottom':\n                x += width / 2;\n                y += height + distance + lineHeight;\n                textAlign = 'center';\n                break;\n            case 'inside':\n                x += width / 2;\n                y += halfHeight;\n                textAlign = 'center';\n                break;\n            case 'insideLeft':\n                x += distance;\n                y += halfHeight;\n                textAlign = 'left';\n                break;\n            case 'insideRight':\n                x += width - distance;\n                y += halfHeight;\n                textAlign = 'right';\n                break;\n            case 'insideTop':\n                x += width / 2;\n                y += distance + lineHeight;\n                textAlign = 'center';\n                break;\n            case 'insideBottom':\n                x += width / 2;\n                y += height - textHeight - distance + lineHeight;\n                textAlign = 'center';\n                break;\n            case 'insideTopLeft':\n                x += distance;\n                y += distance + lineHeight;\n                textAlign = 'left';\n                break;\n            case 'insideTopRight':\n                x += width - distance;\n                y += distance + lineHeight;\n                textAlign = 'right';\n                break;\n            case 'insideBottomLeft':\n                x += distance;\n                y += height - textHeight - distance + lineHeight;\n                break;\n            case 'insideBottomRight':\n                x += width - distance;\n                y += height - textHeight - distance + lineHeight;\n                textAlign = 'right';\n                break;\n        }\n\n        return {\n            x: x,\n            y: y,\n            textAlign: textAlign,\n            textBaseline: 'alphabetic'\n        };\n    }\n\n    /**\n     * Show ellipsis if overflow.\n     *\n     * @param  {string} text\n     * @param  {string} containerWidth\n     * @param  {string} textFont\n     * @param  {number} [ellipsis='...']\n     * @param  {Object} [options]\n     * @param  {number} [options.maxIterations=3]\n     * @param  {number} [options.minChar=0] If truncate result are less\n     *                  then minChar, ellipsis will not show, which is\n     *                  better for user hint in some cases.\n     * @param  {number} [options.placeholder=''] When all truncated, use the placeholder.\n     * @return {string}\n     */\n    function truncateText(text, containerWidth, textFont, ellipsis, options) {\n        if (!containerWidth) {\n            return '';\n        }\n\n        options = options || {};\n\n        ellipsis = retrieve(ellipsis, '...');\n        var maxIterations = retrieve(options.maxIterations, 2);\n        var minChar = retrieve(options.minChar, 0);\n        // FIXME\n        // Other languages?\n        var cnCharWidth = getTextWidth('国', textFont);\n        // FIXME\n        // Consider proportional font?\n        var ascCharWidth = getTextWidth('a', textFont);\n        var placeholder = retrieve(options.placeholder, '');\n\n        // Example 1: minChar: 3, text: 'asdfzxcv', truncate result: 'asdf', but not: 'a...'.\n        // Example 2: minChar: 3, text: '维度', truncate result: '维', but not: '...'.\n        var contentWidth = containerWidth = Math.max(0, containerWidth - 1); // Reserve some gap.\n        for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {\n            contentWidth -= ascCharWidth;\n        }\n\n        var ellipsisWidth = getTextWidth(ellipsis);\n        if (ellipsisWidth > contentWidth) {\n            ellipsis = '';\n            ellipsisWidth = 0;\n        }\n\n        contentWidth = containerWidth - ellipsisWidth;\n\n        var textLines = (text + '').split('\\n');\n\n        for (var i = 0, len = textLines.length; i < len; i++) {\n            var textLine = textLines[i];\n            var lineWidth = getTextWidth(textLine, textFont);\n\n            if (lineWidth <= containerWidth) {\n                continue;\n            }\n\n            for (var j = 0;; j++) {\n                if (lineWidth <= contentWidth || j >= maxIterations) {\n                    textLine += ellipsis;\n                    break;\n                }\n\n                var subLength = j === 0\n                    ? estimateLength(textLine, contentWidth, ascCharWidth, cnCharWidth)\n                    : lineWidth > 0\n                    ? Math.floor(textLine.length * contentWidth / lineWidth)\n                    : 0;\n\n                textLine = textLine.substr(0, subLength);\n                lineWidth = getTextWidth(textLine, textFont);\n            }\n\n            if (textLine === '') {\n                textLine = placeholder;\n            }\n\n            textLines[i] = textLine;\n        }\n\n        return textLines.join('\\n');\n    }\n\n    function estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {\n        var width = 0;\n        var i = 0;\n        for (var len = text.length; i < len && width < contentWidth; i++) {\n            var charCode = text.charCodeAt(i);\n            width += (0 <= charCode && charCode <= 127) ? ascCharWidth : cnCharWidth;\n        }\n        return i;\n    }\n\n    var textContain = {\n\n        getWidth: getTextWidth,\n\n        getBoundingRect: getTextRect,\n\n        adjustTextPositionOnRect: adjustTextPositionOnRect,\n\n        truncateText: truncateText,\n\n        measureText: function (text, textFont) {\n            var ctx = util.getContext();\n            ctx.font = textFont || '12px sans-serif';\n            return ctx.measureText(text);\n        }\n    };\n\n    module.exports = textContain;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL2hvbWUveXgvfi96cmVuZGVyL2xpYi9jb250YWluL3RleHQuanM/OTkxZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcblxuICAgIHZhciB0ZXh0V2lkdGhDYWNoZSA9IHt9O1xuICAgIHZhciB0ZXh0V2lkdGhDYWNoZUNvdW50ZXIgPSAwO1xuICAgIHZhciBURVhUX0NBQ0hFX01BWCA9IDUwMDA7XG5cbiAgICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpO1xuICAgIHZhciBCb3VuZGluZ1JlY3QgPSByZXF1aXJlKCcuLi9jb3JlL0JvdW5kaW5nUmVjdCcpO1xuICAgIHZhciByZXRyaWV2ZSA9IHV0aWwucmV0cmlldmU7XG5cbiAgICBmdW5jdGlvbiBnZXRUZXh0V2lkdGgodGV4dCwgdGV4dEZvbnQpIHtcbiAgICAgICAgdmFyIGtleSA9IHRleHQgKyAnOicgKyB0ZXh0Rm9udDtcbiAgICAgICAgaWYgKHRleHRXaWR0aENhY2hlW2tleV0pIHtcbiAgICAgICAgICAgIHJldHVybiB0ZXh0V2lkdGhDYWNoZVtrZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRleHRMaW5lcyA9ICh0ZXh0ICsgJycpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgdmFyIHdpZHRoID0gMDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRleHRMaW5lcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIC8vIG1lYXN1cmVUZXh0IOWPr+S7peiiq+imhuebluS7peWFvOWuueS4jeaUr+aMgSBDYW52YXMg55qE546v5aKDXG4gICAgICAgICAgICB3aWR0aCA9IE1hdGgubWF4KHRleHRDb250YWluLm1lYXN1cmVUZXh0KHRleHRMaW5lc1tpXSwgdGV4dEZvbnQpLndpZHRoLCB3aWR0aCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGV4dFdpZHRoQ2FjaGVDb3VudGVyID4gVEVYVF9DQUNIRV9NQVgpIHtcbiAgICAgICAgICAgIHRleHRXaWR0aENhY2hlQ291bnRlciA9IDA7XG4gICAgICAgICAgICB0ZXh0V2lkdGhDYWNoZSA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHRleHRXaWR0aENhY2hlQ291bnRlcisrO1xuICAgICAgICB0ZXh0V2lkdGhDYWNoZVtrZXldID0gd2lkdGg7XG5cbiAgICAgICAgcmV0dXJuIHdpZHRoO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFRleHRSZWN0KHRleHQsIHRleHRGb250LCB0ZXh0QWxpZ24sIHRleHRCYXNlbGluZSkge1xuICAgICAgICB2YXIgdGV4dExpbmVMZW4gPSAoKHRleHQgfHwgJycpICsgJycpLnNwbGl0KCdcXG4nKS5sZW5ndGg7XG5cbiAgICAgICAgdmFyIHdpZHRoID0gZ2V0VGV4dFdpZHRoKHRleHQsIHRleHRGb250KTtcbiAgICAgICAgLy8gRklYTUUg6auY5bqm6K6h566X5q+U6L6D57KX5pq0XG4gICAgICAgIHZhciBsaW5lSGVpZ2h0ID0gZ2V0VGV4dFdpZHRoKCflm70nLCB0ZXh0Rm9udCk7XG4gICAgICAgIHZhciBoZWlnaHQgPSB0ZXh0TGluZUxlbiAqIGxpbmVIZWlnaHQ7XG5cbiAgICAgICAgdmFyIHJlY3QgPSBuZXcgQm91bmRpbmdSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAvLyBUZXh0IGhhcyBhIHNwZWNpYWwgbGluZSBoZWlnaHQgcHJvcGVydHlcbiAgICAgICAgcmVjdC5saW5lSGVpZ2h0ID0gbGluZUhlaWdodDtcblxuICAgICAgICBzd2l0Y2ggKHRleHRCYXNlbGluZSkge1xuICAgICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgIGNhc2UgJ2FscGhhYmV0aWMnOlxuICAgICAgICAgICAgICAgIHJlY3QueSAtPSBsaW5lSGVpZ2h0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbWlkZGxlJzpcbiAgICAgICAgICAgICAgICByZWN0LnkgLT0gbGluZUhlaWdodCAvIDI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBjYXNlICdoYW5naW5nJzpcbiAgICAgICAgICAgIC8vIGNhc2UgJ3RvcCc6XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGSVhNRSBSaWdodCB0byBsZWZ0IGxhbmd1YWdlXG4gICAgICAgIHN3aXRjaCAodGV4dEFsaWduKSB7XG4gICAgICAgICAgICBjYXNlICdlbmQnOlxuICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgICAgIHJlY3QueCAtPSByZWN0LndpZHRoO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICAgICAgICByZWN0LnggLT0gcmVjdC53aWR0aCAvIDI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBjYXNlICdzdGFydCc6XG4gICAgICAgICAgICAvLyBjYXNlICdsZWZ0JzpcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZWN0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkanVzdFRleHRQb3NpdGlvbk9uUmVjdCh0ZXh0UG9zaXRpb24sIHJlY3QsIHRleHRSZWN0LCBkaXN0YW5jZSkge1xuXG4gICAgICAgIHZhciB4ID0gcmVjdC54O1xuICAgICAgICB2YXIgeSA9IHJlY3QueTtcblxuICAgICAgICB2YXIgaGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XG4gICAgICAgIHZhciB3aWR0aCA9IHJlY3Qud2lkdGg7XG5cbiAgICAgICAgdmFyIHRleHRIZWlnaHQgPSB0ZXh0UmVjdC5oZWlnaHQ7XG5cbiAgICAgICAgdmFyIGxpbmVIZWlnaHQgPSB0ZXh0UmVjdC5saW5lSGVpZ2h0O1xuICAgICAgICB2YXIgaGFsZkhlaWdodCA9IGhlaWdodCAvIDIgLSB0ZXh0SGVpZ2h0IC8gMiArIGxpbmVIZWlnaHQ7XG5cbiAgICAgICAgdmFyIHRleHRBbGlnbiA9ICdsZWZ0JztcblxuICAgICAgICBzd2l0Y2ggKHRleHRQb3NpdGlvbikge1xuICAgICAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgICAgICAgeCAtPSBkaXN0YW5jZTtcbiAgICAgICAgICAgICAgICB5ICs9IGhhbGZIZWlnaHQ7XG4gICAgICAgICAgICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgICAgICB4ICs9IGRpc3RhbmNlICsgd2lkdGg7XG4gICAgICAgICAgICAgICAgeSArPSBoYWxmSGVpZ2h0O1xuICAgICAgICAgICAgICAgIHRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICAgICAgeCArPSB3aWR0aCAvIDI7XG4gICAgICAgICAgICAgICAgeSAtPSBkaXN0YW5jZSArIHRleHRIZWlnaHQgLSBsaW5lSGVpZ2h0O1xuICAgICAgICAgICAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgICAgICB4ICs9IHdpZHRoIC8gMjtcbiAgICAgICAgICAgICAgICB5ICs9IGhlaWdodCArIGRpc3RhbmNlICsgbGluZUhlaWdodDtcbiAgICAgICAgICAgICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2luc2lkZSc6XG4gICAgICAgICAgICAgICAgeCArPSB3aWR0aCAvIDI7XG4gICAgICAgICAgICAgICAgeSArPSBoYWxmSGVpZ2h0O1xuICAgICAgICAgICAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaW5zaWRlTGVmdCc6XG4gICAgICAgICAgICAgICAgeCArPSBkaXN0YW5jZTtcbiAgICAgICAgICAgICAgICB5ICs9IGhhbGZIZWlnaHQ7XG4gICAgICAgICAgICAgICAgdGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaW5zaWRlUmlnaHQnOlxuICAgICAgICAgICAgICAgIHggKz0gd2lkdGggLSBkaXN0YW5jZTtcbiAgICAgICAgICAgICAgICB5ICs9IGhhbGZIZWlnaHQ7XG4gICAgICAgICAgICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2luc2lkZVRvcCc6XG4gICAgICAgICAgICAgICAgeCArPSB3aWR0aCAvIDI7XG4gICAgICAgICAgICAgICAgeSArPSBkaXN0YW5jZSArIGxpbmVIZWlnaHQ7XG4gICAgICAgICAgICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdpbnNpZGVCb3R0b20nOlxuICAgICAgICAgICAgICAgIHggKz0gd2lkdGggLyAyO1xuICAgICAgICAgICAgICAgIHkgKz0gaGVpZ2h0IC0gdGV4dEhlaWdodCAtIGRpc3RhbmNlICsgbGluZUhlaWdodDtcbiAgICAgICAgICAgICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2luc2lkZVRvcExlZnQnOlxuICAgICAgICAgICAgICAgIHggKz0gZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgeSArPSBkaXN0YW5jZSArIGxpbmVIZWlnaHQ7XG4gICAgICAgICAgICAgICAgdGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaW5zaWRlVG9wUmlnaHQnOlxuICAgICAgICAgICAgICAgIHggKz0gd2lkdGggLSBkaXN0YW5jZTtcbiAgICAgICAgICAgICAgICB5ICs9IGRpc3RhbmNlICsgbGluZUhlaWdodDtcbiAgICAgICAgICAgICAgICB0ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaW5zaWRlQm90dG9tTGVmdCc6XG4gICAgICAgICAgICAgICAgeCArPSBkaXN0YW5jZTtcbiAgICAgICAgICAgICAgICB5ICs9IGhlaWdodCAtIHRleHRIZWlnaHQgLSBkaXN0YW5jZSArIGxpbmVIZWlnaHQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdpbnNpZGVCb3R0b21SaWdodCc6XG4gICAgICAgICAgICAgICAgeCArPSB3aWR0aCAtIGRpc3RhbmNlO1xuICAgICAgICAgICAgICAgIHkgKz0gaGVpZ2h0IC0gdGV4dEhlaWdodCAtIGRpc3RhbmNlICsgbGluZUhlaWdodDtcbiAgICAgICAgICAgICAgICB0ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICB5OiB5LFxuICAgICAgICAgICAgdGV4dEFsaWduOiB0ZXh0QWxpZ24sXG4gICAgICAgICAgICB0ZXh0QmFzZWxpbmU6ICdhbHBoYWJldGljJ1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNob3cgZWxsaXBzaXMgaWYgb3ZlcmZsb3cuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IHRleHRcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IGNvbnRhaW5lcldpZHRoXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSB0ZXh0Rm9udFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gW2VsbGlwc2lzPScuLi4nXVxuICAgICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBbb3B0aW9ucy5tYXhJdGVyYXRpb25zPTNdXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBbb3B0aW9ucy5taW5DaGFyPTBdIElmIHRydW5jYXRlIHJlc3VsdCBhcmUgbGVzc1xuICAgICAqICAgICAgICAgICAgICAgICAgdGhlbiBtaW5DaGFyLCBlbGxpcHNpcyB3aWxsIG5vdCBzaG93LCB3aGljaCBpc1xuICAgICAqICAgICAgICAgICAgICAgICAgYmV0dGVyIGZvciB1c2VyIGhpbnQgaW4gc29tZSBjYXNlcy5cbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IFtvcHRpb25zLnBsYWNlaG9sZGVyPScnXSBXaGVuIGFsbCB0cnVuY2F0ZWQsIHVzZSB0aGUgcGxhY2Vob2xkZXIuXG4gICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRydW5jYXRlVGV4dCh0ZXh0LCBjb250YWluZXJXaWR0aCwgdGV4dEZvbnQsIGVsbGlwc2lzLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICghY29udGFpbmVyV2lkdGgpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIGVsbGlwc2lzID0gcmV0cmlldmUoZWxsaXBzaXMsICcuLi4nKTtcbiAgICAgICAgdmFyIG1heEl0ZXJhdGlvbnMgPSByZXRyaWV2ZShvcHRpb25zLm1heEl0ZXJhdGlvbnMsIDIpO1xuICAgICAgICB2YXIgbWluQ2hhciA9IHJldHJpZXZlKG9wdGlvbnMubWluQ2hhciwgMCk7XG4gICAgICAgIC8vIEZJWE1FXG4gICAgICAgIC8vIE90aGVyIGxhbmd1YWdlcz9cbiAgICAgICAgdmFyIGNuQ2hhcldpZHRoID0gZ2V0VGV4dFdpZHRoKCflm70nLCB0ZXh0Rm9udCk7XG4gICAgICAgIC8vIEZJWE1FXG4gICAgICAgIC8vIENvbnNpZGVyIHByb3BvcnRpb25hbCBmb250P1xuICAgICAgICB2YXIgYXNjQ2hhcldpZHRoID0gZ2V0VGV4dFdpZHRoKCdhJywgdGV4dEZvbnQpO1xuICAgICAgICB2YXIgcGxhY2Vob2xkZXIgPSByZXRyaWV2ZShvcHRpb25zLnBsYWNlaG9sZGVyLCAnJyk7XG5cbiAgICAgICAgLy8gRXhhbXBsZSAxOiBtaW5DaGFyOiAzLCB0ZXh0OiAnYXNkZnp4Y3YnLCB0cnVuY2F0ZSByZXN1bHQ6ICdhc2RmJywgYnV0IG5vdDogJ2EuLi4nLlxuICAgICAgICAvLyBFeGFtcGxlIDI6IG1pbkNoYXI6IDMsIHRleHQ6ICfnu7TluqYnLCB0cnVuY2F0ZSByZXN1bHQ6ICfnu7QnLCBidXQgbm90OiAnLi4uJy5cbiAgICAgICAgdmFyIGNvbnRlbnRXaWR0aCA9IGNvbnRhaW5lcldpZHRoID0gTWF0aC5tYXgoMCwgY29udGFpbmVyV2lkdGggLSAxKTsgLy8gUmVzZXJ2ZSBzb21lIGdhcC5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtaW5DaGFyICYmIGNvbnRlbnRXaWR0aCA+PSBhc2NDaGFyV2lkdGg7IGkrKykge1xuICAgICAgICAgICAgY29udGVudFdpZHRoIC09IGFzY0NoYXJXaWR0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlbGxpcHNpc1dpZHRoID0gZ2V0VGV4dFdpZHRoKGVsbGlwc2lzKTtcbiAgICAgICAgaWYgKGVsbGlwc2lzV2lkdGggPiBjb250ZW50V2lkdGgpIHtcbiAgICAgICAgICAgIGVsbGlwc2lzID0gJyc7XG4gICAgICAgICAgICBlbGxpcHNpc1dpZHRoID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRlbnRXaWR0aCA9IGNvbnRhaW5lcldpZHRoIC0gZWxsaXBzaXNXaWR0aDtcblxuICAgICAgICB2YXIgdGV4dExpbmVzID0gKHRleHQgKyAnJykuc3BsaXQoJ1xcbicpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0ZXh0TGluZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB0ZXh0TGluZSA9IHRleHRMaW5lc1tpXTtcbiAgICAgICAgICAgIHZhciBsaW5lV2lkdGggPSBnZXRUZXh0V2lkdGgodGV4dExpbmUsIHRleHRGb250KTtcblxuICAgICAgICAgICAgaWYgKGxpbmVXaWR0aCA8PSBjb250YWluZXJXaWR0aCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDs7IGorKykge1xuICAgICAgICAgICAgICAgIGlmIChsaW5lV2lkdGggPD0gY29udGVudFdpZHRoIHx8IGogPj0gbWF4SXRlcmF0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0TGluZSArPSBlbGxpcHNpcztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHN1Ykxlbmd0aCA9IGogPT09IDBcbiAgICAgICAgICAgICAgICAgICAgPyBlc3RpbWF0ZUxlbmd0aCh0ZXh0TGluZSwgY29udGVudFdpZHRoLCBhc2NDaGFyV2lkdGgsIGNuQ2hhcldpZHRoKVxuICAgICAgICAgICAgICAgICAgICA6IGxpbmVXaWR0aCA+IDBcbiAgICAgICAgICAgICAgICAgICAgPyBNYXRoLmZsb29yKHRleHRMaW5lLmxlbmd0aCAqIGNvbnRlbnRXaWR0aCAvIGxpbmVXaWR0aClcbiAgICAgICAgICAgICAgICAgICAgOiAwO1xuXG4gICAgICAgICAgICAgICAgdGV4dExpbmUgPSB0ZXh0TGluZS5zdWJzdHIoMCwgc3ViTGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBsaW5lV2lkdGggPSBnZXRUZXh0V2lkdGgodGV4dExpbmUsIHRleHRGb250KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRleHRMaW5lID09PSAnJykge1xuICAgICAgICAgICAgICAgIHRleHRMaW5lID0gcGxhY2Vob2xkZXI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRleHRMaW5lc1tpXSA9IHRleHRMaW5lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRleHRMaW5lcy5qb2luKCdcXG4nKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlc3RpbWF0ZUxlbmd0aCh0ZXh0LCBjb250ZW50V2lkdGgsIGFzY0NoYXJXaWR0aCwgY25DaGFyV2lkdGgpIHtcbiAgICAgICAgdmFyIHdpZHRoID0gMDtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICBmb3IgKHZhciBsZW4gPSB0ZXh0Lmxlbmd0aDsgaSA8IGxlbiAmJiB3aWR0aCA8IGNvbnRlbnRXaWR0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2hhckNvZGUgPSB0ZXh0LmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICB3aWR0aCArPSAoMCA8PSBjaGFyQ29kZSAmJiBjaGFyQ29kZSA8PSAxMjcpID8gYXNjQ2hhcldpZHRoIDogY25DaGFyV2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGk7XG4gICAgfVxuXG4gICAgdmFyIHRleHRDb250YWluID0ge1xuXG4gICAgICAgIGdldFdpZHRoOiBnZXRUZXh0V2lkdGgsXG5cbiAgICAgICAgZ2V0Qm91bmRpbmdSZWN0OiBnZXRUZXh0UmVjdCxcblxuICAgICAgICBhZGp1c3RUZXh0UG9zaXRpb25PblJlY3Q6IGFkanVzdFRleHRQb3NpdGlvbk9uUmVjdCxcblxuICAgICAgICB0cnVuY2F0ZVRleHQ6IHRydW5jYXRlVGV4dCxcblxuICAgICAgICBtZWFzdXJlVGV4dDogZnVuY3Rpb24gKHRleHQsIHRleHRGb250KSB7XG4gICAgICAgICAgICB2YXIgY3R4ID0gdXRpbC5nZXRDb250ZXh0KCk7XG4gICAgICAgICAgICBjdHguZm9udCA9IHRleHRGb250IHx8ICcxMnB4IHNhbnMtc2VyaWYnO1xuICAgICAgICAgICAgcmV0dXJuIGN0eC5tZWFzdXJlVGV4dCh0ZXh0KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHRleHRDb250YWluO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2hvbWUveXgvfi96cmVuZGVyL2xpYi9jb250YWluL3RleHQuanNcbi8vIG1vZHVsZSBpZCA9IDE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 16 */
/* unknown exports provided */
/* all exports used */
/*!*********************************!*\
  !*** ./lib/coord/axisHelper.js ***!
  \*********************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var OrdinalScale = __webpack_require__(/*! ../scale/Ordinal */ 179);\n    var IntervalScale = __webpack_require__(/*! ../scale/Interval */ 42);\n    __webpack_require__(/*! ../scale/Time */ 180);\n    __webpack_require__(/*! ../scale/Log */ 178);\n    var Scale = __webpack_require__(/*! ../scale/Scale */ 35);\n\n    var numberUtil = __webpack_require__(/*! ../util/number */ 3);\n    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 0);\n    var textContain = __webpack_require__(/*! zrender/lib/contain/text */ 15);\n    var axisHelper = {};\n\n    /**\n     * Get axis scale extent before niced.\n     * Item of returned array can only be number (including Infinity and NaN).\n     */\n    axisHelper.getScaleExtent = function (scale, model) {\n        var scaleType = scale.type;\n\n        var min = model.getMin();\n        var max = model.getMax();\n        var fixMin = min != null;\n        var fixMax = max != null;\n        var originalExtent = scale.getExtent();\n\n        var axisDataLen;\n        var boundaryGap;\n        var span;\n        if (scaleType === 'ordinal') {\n            axisDataLen = (model.get('data') || []).length;\n        }\n        else {\n            boundaryGap = model.get('boundaryGap');\n            if (!zrUtil.isArray(boundaryGap)) {\n                boundaryGap = [boundaryGap || 0, boundaryGap || 0];\n            }\n            if (typeof boundaryGap[0] === 'boolean') {\n                if (true) {\n                    console.warn('Boolean type for boundaryGap is only '\n                        + 'allowed for ordinal axis. Please use string in '\n                        + 'percentage instead, e.g., \"20%\". Currently, '\n                        + 'boundaryGap is set to be 0.');\n                }\n                boundaryGap = [0, 0];\n            }\n            boundaryGap[0] = numberUtil.parsePercent(boundaryGap[0], 1);\n            boundaryGap[1] = numberUtil.parsePercent(boundaryGap[1], 1);\n            span = (originalExtent[1] - originalExtent[0])\n                || Math.abs(originalExtent[0]);\n        }\n\n        // Notice: When min/max is not set (that is, when there are null/undefined,\n        // which is the most common case), these cases should be ensured:\n        // (1) For 'ordinal', show all axis.data.\n        // (2) For others:\n        //      + `boundaryGap` is applied (if min/max set, boundaryGap is\n        //      disabled).\n        //      + If `needCrossZero`, min/max should be zero, otherwise, min/max should\n        //      be the result that originalExtent enlarged by boundaryGap.\n        // (3) If no data, it should be ensured that `scale.setBlank` is set.\n\n        // FIXME\n        // (1) When min/max is 'dataMin' or 'dataMax', should boundaryGap be able to used?\n        // (2) When `needCrossZero` and all data is positive/negative, should it be ensured\n        // that the results processed by boundaryGap are positive/negative?\n\n        if (min == null) {\n            min = scaleType === 'ordinal'\n                ? (axisDataLen ? 0 : NaN)\n                : originalExtent[0] - boundaryGap[0] * span;\n        }\n        if (max == null) {\n            max = scaleType === 'ordinal'\n                ? (axisDataLen ? axisDataLen - 1 : NaN)\n                : originalExtent[1] + boundaryGap[1] * span;\n        }\n\n        if (min === 'dataMin') {\n            min = originalExtent[0];\n        }\n        if (max === 'dataMax') {\n            max = originalExtent[1];\n        }\n\n        (min == null || !isFinite(min)) && (min = NaN);\n        (max == null || !isFinite(max)) && (max = NaN);\n\n        scale.setBlank(zrUtil.eqNaN(min) || zrUtil.eqNaN(max));\n\n        // Evaluate if axis needs cross zero\n        if (model.getNeedCrossZero()) {\n            // Axis is over zero and min is not set\n            if (min > 0 && max > 0 && !fixMin) {\n                min = 0;\n            }\n            // Axis is under zero and max is not set\n            if (min < 0 && max < 0 && !fixMax) {\n                max = 0;\n            }\n        }\n\n        return [min, max];\n    };\n\n    axisHelper.niceScaleExtent = function (scale, model) {\n        var extent = axisHelper.getScaleExtent(scale, model);\n        var fixMin = model.getMin() != null;\n        var fixMax = model.getMax() != null;\n        var splitNumber = model.get('splitNumber');\n\n        if (scale.type === 'log') {\n            scale.base = model.get('logBase');\n        }\n\n        scale.setExtent(extent[0], extent[1]);\n        scale.niceExtent(splitNumber, fixMin, fixMax);\n\n        // Use minInterval to constraint the calculated interval.\n        // If calculated interval is less than minInterval. increase the interval quantity until\n        // it is larger than minInterval.\n        // For example:\n        //  minInterval is 1, calculated interval is 0.2, so increase it to be 1. In this way we can get\n        //  an integer axis.\n        var minInterval = model.get('minInterval');\n        if (isFinite(minInterval) && !fixMin && !fixMax && scale.type === 'interval') {\n            var interval = scale.getInterval();\n            var intervalScale = Math.max(Math.abs(interval), minInterval) / interval;\n            // while (interval < minInterval) {\n            //     var quantity = numberUtil.quantity(interval);\n            //     interval = quantity * 10;\n            //     scaleQuantity *= 10;\n            // }\n            extent = scale.getExtent();\n            var origin = (extent[1] + extent[0]) / 2;\n            scale.setExtent(\n                intervalScale * (extent[0] - origin) + origin,\n                intervalScale * (extent[1] - origin) + origin\n            );\n            scale.niceExtent(splitNumber);\n        }\n\n        // If some one specified the min, max. And the default calculated interval\n        // is not good enough. He can specify the interval. It is often appeared\n        // in angle axis with angle 0 - 360. Interval calculated in interval scale is hard\n        // to be 60.\n        // FIXME\n        var interval = model.get('interval');\n        if (interval != null) {\n            scale.setInterval && scale.setInterval(interval);\n        }\n    };\n\n    /**\n     * @param {module:echarts/model/Model} model\n     * @param {string} [axisType] Default retrieve from model.type\n     * @return {module:echarts/scale/*}\n     */\n    axisHelper.createScaleByModel = function(model, axisType) {\n        axisType = axisType || model.get('type');\n        if (axisType) {\n            switch (axisType) {\n                // Buildin scale\n                case 'category':\n                    return new OrdinalScale(\n                        model.getCategories(), [Infinity, -Infinity]\n                    );\n                case 'value':\n                    return new IntervalScale();\n                // Extended scale, like time and log\n                default:\n                    return (Scale.getClass(axisType) || IntervalScale).create(model);\n            }\n        }\n    };\n\n    /**\n     * Check if the axis corss 0\n     */\n    axisHelper.ifAxisCrossZero = function (axis) {\n        var dataExtent = axis.scale.getExtent();\n        var min = dataExtent[0];\n        var max = dataExtent[1];\n        return !((min > 0 && max > 0) || (min < 0 && max < 0));\n    };\n\n    /**\n     * @param {Array.<number>} tickCoords In axis self coordinate.\n     * @param {Array.<string>} labels\n     * @param {string} font\n     * @param {boolean} isAxisHorizontal\n     * @return {number}\n     */\n    axisHelper.getAxisLabelInterval = function (tickCoords, labels, font, isAxisHorizontal) {\n        // FIXME\n        // 不同角的axis和label，不只是horizontal和vertical.\n\n        var textSpaceTakenRect;\n        var autoLabelInterval = 0;\n        var accumulatedLabelInterval = 0;\n\n        var step = 1;\n        if (labels.length > 40) {\n            // Simple optimization for large amount of labels\n            step = Math.floor(labels.length / 40);\n        }\n\n        for (var i = 0; i < tickCoords.length; i += step) {\n            var tickCoord = tickCoords[i];\n            var rect = textContain.getBoundingRect(\n                labels[i], font, 'center', 'top'\n            );\n            rect[isAxisHorizontal ? 'x' : 'y'] += tickCoord;\n            // FIXME Magic number 1.5\n            rect[isAxisHorizontal ? 'width' : 'height'] *= 1.3;\n            if (!textSpaceTakenRect) {\n                textSpaceTakenRect = rect.clone();\n            }\n            // There is no space for current label;\n            else if (textSpaceTakenRect.intersect(rect)) {\n                accumulatedLabelInterval++;\n                autoLabelInterval = Math.max(autoLabelInterval, accumulatedLabelInterval);\n            }\n            else {\n                textSpaceTakenRect.union(rect);\n                // Reset\n                accumulatedLabelInterval = 0;\n            }\n        }\n        if (autoLabelInterval === 0 && step > 1) {\n            return step;\n        }\n        return (autoLabelInterval + 1) * step - 1;\n    };\n\n    /**\n     * @param {Object} axis\n     * @param {Function} labelFormatter\n     * @return {Array.<string>}\n     */\n    axisHelper.getFormattedLabels = function (axis, labelFormatter) {\n        var scale = axis.scale;\n        var labels = scale.getTicksLabels();\n        var ticks = scale.getTicks();\n        if (typeof labelFormatter === 'string') {\n            labelFormatter = (function (tpl) {\n                return function (val) {\n                    return tpl.replace('{value}', val != null ? val : '');\n                };\n            })(labelFormatter);\n            // Consider empty array\n            return zrUtil.map(labels, labelFormatter);\n        }\n        else if (typeof labelFormatter === 'function') {\n            return zrUtil.map(ticks, function (tick, idx) {\n                return labelFormatter(\n                    axisHelper.getAxisRawValue(axis, tick),\n                    idx\n                );\n            }, this);\n        }\n        else {\n            return labels;\n        }\n    };\n\n    axisHelper.getAxisRawValue = function (axis, value) {\n        // In category axis with data zoom, tick is not the original\n        // index of axis.data. So tick should not be exposed to user\n        // in category axis.\n        return axis.type === 'category' ? axis.scale.getLabel(value) : value;\n    };\n\n    module.exports = axisHelper;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvY29vcmQvYXhpc0hlbHBlci5qcz9kYjZlIl0sInNvdXJjZXNDb250ZW50IjpbIlxuXG4gICAgdmFyIE9yZGluYWxTY2FsZSA9IHJlcXVpcmUoJy4uL3NjYWxlL09yZGluYWwnKTtcbiAgICB2YXIgSW50ZXJ2YWxTY2FsZSA9IHJlcXVpcmUoJy4uL3NjYWxlL0ludGVydmFsJyk7XG4gICAgcmVxdWlyZSgnLi4vc2NhbGUvVGltZScpO1xuICAgIHJlcXVpcmUoJy4uL3NjYWxlL0xvZycpO1xuICAgIHZhciBTY2FsZSA9IHJlcXVpcmUoJy4uL3NjYWxlL1NjYWxlJyk7XG5cbiAgICB2YXIgbnVtYmVyVXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvbnVtYmVyJyk7XG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuICAgIHZhciB0ZXh0Q29udGFpbiA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvbnRhaW4vdGV4dCcpO1xuICAgIHZhciBheGlzSGVscGVyID0ge307XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYXhpcyBzY2FsZSBleHRlbnQgYmVmb3JlIG5pY2VkLlxuICAgICAqIEl0ZW0gb2YgcmV0dXJuZWQgYXJyYXkgY2FuIG9ubHkgYmUgbnVtYmVyIChpbmNsdWRpbmcgSW5maW5pdHkgYW5kIE5hTikuXG4gICAgICovXG4gICAgYXhpc0hlbHBlci5nZXRTY2FsZUV4dGVudCA9IGZ1bmN0aW9uIChzY2FsZSwgbW9kZWwpIHtcbiAgICAgICAgdmFyIHNjYWxlVHlwZSA9IHNjYWxlLnR5cGU7XG5cbiAgICAgICAgdmFyIG1pbiA9IG1vZGVsLmdldE1pbigpO1xuICAgICAgICB2YXIgbWF4ID0gbW9kZWwuZ2V0TWF4KCk7XG4gICAgICAgIHZhciBmaXhNaW4gPSBtaW4gIT0gbnVsbDtcbiAgICAgICAgdmFyIGZpeE1heCA9IG1heCAhPSBudWxsO1xuICAgICAgICB2YXIgb3JpZ2luYWxFeHRlbnQgPSBzY2FsZS5nZXRFeHRlbnQoKTtcblxuICAgICAgICB2YXIgYXhpc0RhdGFMZW47XG4gICAgICAgIHZhciBib3VuZGFyeUdhcDtcbiAgICAgICAgdmFyIHNwYW47XG4gICAgICAgIGlmIChzY2FsZVR5cGUgPT09ICdvcmRpbmFsJykge1xuICAgICAgICAgICAgYXhpc0RhdGFMZW4gPSAobW9kZWwuZ2V0KCdkYXRhJykgfHwgW10pLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJvdW5kYXJ5R2FwID0gbW9kZWwuZ2V0KCdib3VuZGFyeUdhcCcpO1xuICAgICAgICAgICAgaWYgKCF6clV0aWwuaXNBcnJheShib3VuZGFyeUdhcCkpIHtcbiAgICAgICAgICAgICAgICBib3VuZGFyeUdhcCA9IFtib3VuZGFyeUdhcCB8fCAwLCBib3VuZGFyeUdhcCB8fCAwXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgYm91bmRhcnlHYXBbMF0gPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignQm9vbGVhbiB0eXBlIGZvciBib3VuZGFyeUdhcCBpcyBvbmx5ICdcbiAgICAgICAgICAgICAgICAgICAgICAgICsgJ2FsbG93ZWQgZm9yIG9yZGluYWwgYXhpcy4gUGxlYXNlIHVzZSBzdHJpbmcgaW4gJ1xuICAgICAgICAgICAgICAgICAgICAgICAgKyAncGVyY2VudGFnZSBpbnN0ZWFkLCBlLmcuLCBcIjIwJVwiLiBDdXJyZW50bHksICdcbiAgICAgICAgICAgICAgICAgICAgICAgICsgJ2JvdW5kYXJ5R2FwIGlzIHNldCB0byBiZSAwLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBib3VuZGFyeUdhcCA9IFswLCAwXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJvdW5kYXJ5R2FwWzBdID0gbnVtYmVyVXRpbC5wYXJzZVBlcmNlbnQoYm91bmRhcnlHYXBbMF0sIDEpO1xuICAgICAgICAgICAgYm91bmRhcnlHYXBbMV0gPSBudW1iZXJVdGlsLnBhcnNlUGVyY2VudChib3VuZGFyeUdhcFsxXSwgMSk7XG4gICAgICAgICAgICBzcGFuID0gKG9yaWdpbmFsRXh0ZW50WzFdIC0gb3JpZ2luYWxFeHRlbnRbMF0pXG4gICAgICAgICAgICAgICAgfHwgTWF0aC5hYnMob3JpZ2luYWxFeHRlbnRbMF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTm90aWNlOiBXaGVuIG1pbi9tYXggaXMgbm90IHNldCAodGhhdCBpcywgd2hlbiB0aGVyZSBhcmUgbnVsbC91bmRlZmluZWQsXG4gICAgICAgIC8vIHdoaWNoIGlzIHRoZSBtb3N0IGNvbW1vbiBjYXNlKSwgdGhlc2UgY2FzZXMgc2hvdWxkIGJlIGVuc3VyZWQ6XG4gICAgICAgIC8vICgxKSBGb3IgJ29yZGluYWwnLCBzaG93IGFsbCBheGlzLmRhdGEuXG4gICAgICAgIC8vICgyKSBGb3Igb3RoZXJzOlxuICAgICAgICAvLyAgICAgICsgYGJvdW5kYXJ5R2FwYCBpcyBhcHBsaWVkIChpZiBtaW4vbWF4IHNldCwgYm91bmRhcnlHYXAgaXNcbiAgICAgICAgLy8gICAgICBkaXNhYmxlZCkuXG4gICAgICAgIC8vICAgICAgKyBJZiBgbmVlZENyb3NzWmVyb2AsIG1pbi9tYXggc2hvdWxkIGJlIHplcm8sIG90aGVyd2lzZSwgbWluL21heCBzaG91bGRcbiAgICAgICAgLy8gICAgICBiZSB0aGUgcmVzdWx0IHRoYXQgb3JpZ2luYWxFeHRlbnQgZW5sYXJnZWQgYnkgYm91bmRhcnlHYXAuXG4gICAgICAgIC8vICgzKSBJZiBubyBkYXRhLCBpdCBzaG91bGQgYmUgZW5zdXJlZCB0aGF0IGBzY2FsZS5zZXRCbGFua2AgaXMgc2V0LlxuXG4gICAgICAgIC8vIEZJWE1FXG4gICAgICAgIC8vICgxKSBXaGVuIG1pbi9tYXggaXMgJ2RhdGFNaW4nIG9yICdkYXRhTWF4Jywgc2hvdWxkIGJvdW5kYXJ5R2FwIGJlIGFibGUgdG8gdXNlZD9cbiAgICAgICAgLy8gKDIpIFdoZW4gYG5lZWRDcm9zc1plcm9gIGFuZCBhbGwgZGF0YSBpcyBwb3NpdGl2ZS9uZWdhdGl2ZSwgc2hvdWxkIGl0IGJlIGVuc3VyZWRcbiAgICAgICAgLy8gdGhhdCB0aGUgcmVzdWx0cyBwcm9jZXNzZWQgYnkgYm91bmRhcnlHYXAgYXJlIHBvc2l0aXZlL25lZ2F0aXZlP1xuXG4gICAgICAgIGlmIChtaW4gPT0gbnVsbCkge1xuICAgICAgICAgICAgbWluID0gc2NhbGVUeXBlID09PSAnb3JkaW5hbCdcbiAgICAgICAgICAgICAgICA/IChheGlzRGF0YUxlbiA/IDAgOiBOYU4pXG4gICAgICAgICAgICAgICAgOiBvcmlnaW5hbEV4dGVudFswXSAtIGJvdW5kYXJ5R2FwWzBdICogc3BhbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF4ID09IG51bGwpIHtcbiAgICAgICAgICAgIG1heCA9IHNjYWxlVHlwZSA9PT0gJ29yZGluYWwnXG4gICAgICAgICAgICAgICAgPyAoYXhpc0RhdGFMZW4gPyBheGlzRGF0YUxlbiAtIDEgOiBOYU4pXG4gICAgICAgICAgICAgICAgOiBvcmlnaW5hbEV4dGVudFsxXSArIGJvdW5kYXJ5R2FwWzFdICogc3BhbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtaW4gPT09ICdkYXRhTWluJykge1xuICAgICAgICAgICAgbWluID0gb3JpZ2luYWxFeHRlbnRbMF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1heCA9PT0gJ2RhdGFNYXgnKSB7XG4gICAgICAgICAgICBtYXggPSBvcmlnaW5hbEV4dGVudFsxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIChtaW4gPT0gbnVsbCB8fCAhaXNGaW5pdGUobWluKSkgJiYgKG1pbiA9IE5hTik7XG4gICAgICAgIChtYXggPT0gbnVsbCB8fCAhaXNGaW5pdGUobWF4KSkgJiYgKG1heCA9IE5hTik7XG5cbiAgICAgICAgc2NhbGUuc2V0QmxhbmsoenJVdGlsLmVxTmFOKG1pbikgfHwgenJVdGlsLmVxTmFOKG1heCkpO1xuXG4gICAgICAgIC8vIEV2YWx1YXRlIGlmIGF4aXMgbmVlZHMgY3Jvc3MgemVyb1xuICAgICAgICBpZiAobW9kZWwuZ2V0TmVlZENyb3NzWmVybygpKSB7XG4gICAgICAgICAgICAvLyBBeGlzIGlzIG92ZXIgemVybyBhbmQgbWluIGlzIG5vdCBzZXRcbiAgICAgICAgICAgIGlmIChtaW4gPiAwICYmIG1heCA+IDAgJiYgIWZpeE1pbikge1xuICAgICAgICAgICAgICAgIG1pbiA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBeGlzIGlzIHVuZGVyIHplcm8gYW5kIG1heCBpcyBub3Qgc2V0XG4gICAgICAgICAgICBpZiAobWluIDwgMCAmJiBtYXggPCAwICYmICFmaXhNYXgpIHtcbiAgICAgICAgICAgICAgICBtYXggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFttaW4sIG1heF07XG4gICAgfTtcblxuICAgIGF4aXNIZWxwZXIubmljZVNjYWxlRXh0ZW50ID0gZnVuY3Rpb24gKHNjYWxlLCBtb2RlbCkge1xuICAgICAgICB2YXIgZXh0ZW50ID0gYXhpc0hlbHBlci5nZXRTY2FsZUV4dGVudChzY2FsZSwgbW9kZWwpO1xuICAgICAgICB2YXIgZml4TWluID0gbW9kZWwuZ2V0TWluKCkgIT0gbnVsbDtcbiAgICAgICAgdmFyIGZpeE1heCA9IG1vZGVsLmdldE1heCgpICE9IG51bGw7XG4gICAgICAgIHZhciBzcGxpdE51bWJlciA9IG1vZGVsLmdldCgnc3BsaXROdW1iZXInKTtcblxuICAgICAgICBpZiAoc2NhbGUudHlwZSA9PT0gJ2xvZycpIHtcbiAgICAgICAgICAgIHNjYWxlLmJhc2UgPSBtb2RlbC5nZXQoJ2xvZ0Jhc2UnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNjYWxlLnNldEV4dGVudChleHRlbnRbMF0sIGV4dGVudFsxXSk7XG4gICAgICAgIHNjYWxlLm5pY2VFeHRlbnQoc3BsaXROdW1iZXIsIGZpeE1pbiwgZml4TWF4KTtcblxuICAgICAgICAvLyBVc2UgbWluSW50ZXJ2YWwgdG8gY29uc3RyYWludCB0aGUgY2FsY3VsYXRlZCBpbnRlcnZhbC5cbiAgICAgICAgLy8gSWYgY2FsY3VsYXRlZCBpbnRlcnZhbCBpcyBsZXNzIHRoYW4gbWluSW50ZXJ2YWwuIGluY3JlYXNlIHRoZSBpbnRlcnZhbCBxdWFudGl0eSB1bnRpbFxuICAgICAgICAvLyBpdCBpcyBsYXJnZXIgdGhhbiBtaW5JbnRlcnZhbC5cbiAgICAgICAgLy8gRm9yIGV4YW1wbGU6XG4gICAgICAgIC8vICBtaW5JbnRlcnZhbCBpcyAxLCBjYWxjdWxhdGVkIGludGVydmFsIGlzIDAuMiwgc28gaW5jcmVhc2UgaXQgdG8gYmUgMS4gSW4gdGhpcyB3YXkgd2UgY2FuIGdldFxuICAgICAgICAvLyAgYW4gaW50ZWdlciBheGlzLlxuICAgICAgICB2YXIgbWluSW50ZXJ2YWwgPSBtb2RlbC5nZXQoJ21pbkludGVydmFsJyk7XG4gICAgICAgIGlmIChpc0Zpbml0ZShtaW5JbnRlcnZhbCkgJiYgIWZpeE1pbiAmJiAhZml4TWF4ICYmIHNjYWxlLnR5cGUgPT09ICdpbnRlcnZhbCcpIHtcbiAgICAgICAgICAgIHZhciBpbnRlcnZhbCA9IHNjYWxlLmdldEludGVydmFsKCk7XG4gICAgICAgICAgICB2YXIgaW50ZXJ2YWxTY2FsZSA9IE1hdGgubWF4KE1hdGguYWJzKGludGVydmFsKSwgbWluSW50ZXJ2YWwpIC8gaW50ZXJ2YWw7XG4gICAgICAgICAgICAvLyB3aGlsZSAoaW50ZXJ2YWwgPCBtaW5JbnRlcnZhbCkge1xuICAgICAgICAgICAgLy8gICAgIHZhciBxdWFudGl0eSA9IG51bWJlclV0aWwucXVhbnRpdHkoaW50ZXJ2YWwpO1xuICAgICAgICAgICAgLy8gICAgIGludGVydmFsID0gcXVhbnRpdHkgKiAxMDtcbiAgICAgICAgICAgIC8vICAgICBzY2FsZVF1YW50aXR5ICo9IDEwO1xuICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgZXh0ZW50ID0gc2NhbGUuZ2V0RXh0ZW50KCk7XG4gICAgICAgICAgICB2YXIgb3JpZ2luID0gKGV4dGVudFsxXSArIGV4dGVudFswXSkgLyAyO1xuICAgICAgICAgICAgc2NhbGUuc2V0RXh0ZW50KFxuICAgICAgICAgICAgICAgIGludGVydmFsU2NhbGUgKiAoZXh0ZW50WzBdIC0gb3JpZ2luKSArIG9yaWdpbixcbiAgICAgICAgICAgICAgICBpbnRlcnZhbFNjYWxlICogKGV4dGVudFsxXSAtIG9yaWdpbikgKyBvcmlnaW5cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBzY2FsZS5uaWNlRXh0ZW50KHNwbGl0TnVtYmVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHNvbWUgb25lIHNwZWNpZmllZCB0aGUgbWluLCBtYXguIEFuZCB0aGUgZGVmYXVsdCBjYWxjdWxhdGVkIGludGVydmFsXG4gICAgICAgIC8vIGlzIG5vdCBnb29kIGVub3VnaC4gSGUgY2FuIHNwZWNpZnkgdGhlIGludGVydmFsLiBJdCBpcyBvZnRlbiBhcHBlYXJlZFxuICAgICAgICAvLyBpbiBhbmdsZSBheGlzIHdpdGggYW5nbGUgMCAtIDM2MC4gSW50ZXJ2YWwgY2FsY3VsYXRlZCBpbiBpbnRlcnZhbCBzY2FsZSBpcyBoYXJkXG4gICAgICAgIC8vIHRvIGJlIDYwLlxuICAgICAgICAvLyBGSVhNRVxuICAgICAgICB2YXIgaW50ZXJ2YWwgPSBtb2RlbC5nZXQoJ2ludGVydmFsJyk7XG4gICAgICAgIGlmIChpbnRlcnZhbCAhPSBudWxsKSB7XG4gICAgICAgICAgICBzY2FsZS5zZXRJbnRlcnZhbCAmJiBzY2FsZS5zZXRJbnRlcnZhbChpbnRlcnZhbCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH0gbW9kZWxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2F4aXNUeXBlXSBEZWZhdWx0IHJldHJpZXZlIGZyb20gbW9kZWwudHlwZVxuICAgICAqIEByZXR1cm4ge21vZHVsZTplY2hhcnRzL3NjYWxlLyp9XG4gICAgICovXG4gICAgYXhpc0hlbHBlci5jcmVhdGVTY2FsZUJ5TW9kZWwgPSBmdW5jdGlvbihtb2RlbCwgYXhpc1R5cGUpIHtcbiAgICAgICAgYXhpc1R5cGUgPSBheGlzVHlwZSB8fCBtb2RlbC5nZXQoJ3R5cGUnKTtcbiAgICAgICAgaWYgKGF4aXNUeXBlKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGF4aXNUeXBlKSB7XG4gICAgICAgICAgICAgICAgLy8gQnVpbGRpbiBzY2FsZVxuICAgICAgICAgICAgICAgIGNhc2UgJ2NhdGVnb3J5JzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBPcmRpbmFsU2NhbGUoXG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlbC5nZXRDYXRlZ29yaWVzKCksIFtJbmZpbml0eSwgLUluZmluaXR5XVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3ZhbHVlJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnRlcnZhbFNjYWxlKCk7XG4gICAgICAgICAgICAgICAgLy8gRXh0ZW5kZWQgc2NhbGUsIGxpa2UgdGltZSBhbmQgbG9nXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChTY2FsZS5nZXRDbGFzcyhheGlzVHlwZSkgfHwgSW50ZXJ2YWxTY2FsZSkuY3JlYXRlKG1vZGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGUgYXhpcyBjb3JzcyAwXG4gICAgICovXG4gICAgYXhpc0hlbHBlci5pZkF4aXNDcm9zc1plcm8gPSBmdW5jdGlvbiAoYXhpcykge1xuICAgICAgICB2YXIgZGF0YUV4dGVudCA9IGF4aXMuc2NhbGUuZ2V0RXh0ZW50KCk7XG4gICAgICAgIHZhciBtaW4gPSBkYXRhRXh0ZW50WzBdO1xuICAgICAgICB2YXIgbWF4ID0gZGF0YUV4dGVudFsxXTtcbiAgICAgICAgcmV0dXJuICEoKG1pbiA+IDAgJiYgbWF4ID4gMCkgfHwgKG1pbiA8IDAgJiYgbWF4IDwgMCkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB0aWNrQ29vcmRzIEluIGF4aXMgc2VsZiBjb29yZGluYXRlLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IGxhYmVsc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmb250XG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc0F4aXNIb3Jpem9udGFsXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIGF4aXNIZWxwZXIuZ2V0QXhpc0xhYmVsSW50ZXJ2YWwgPSBmdW5jdGlvbiAodGlja0Nvb3JkcywgbGFiZWxzLCBmb250LCBpc0F4aXNIb3Jpem9udGFsKSB7XG4gICAgICAgIC8vIEZJWE1FXG4gICAgICAgIC8vIOS4jeWQjOinkueahGF4aXPlkoxsYWJlbO+8jOS4jeWPquaYr2hvcml6b250YWzlkox2ZXJ0aWNhbC5cblxuICAgICAgICB2YXIgdGV4dFNwYWNlVGFrZW5SZWN0O1xuICAgICAgICB2YXIgYXV0b0xhYmVsSW50ZXJ2YWwgPSAwO1xuICAgICAgICB2YXIgYWNjdW11bGF0ZWRMYWJlbEludGVydmFsID0gMDtcblxuICAgICAgICB2YXIgc3RlcCA9IDE7XG4gICAgICAgIGlmIChsYWJlbHMubGVuZ3RoID4gNDApIHtcbiAgICAgICAgICAgIC8vIFNpbXBsZSBvcHRpbWl6YXRpb24gZm9yIGxhcmdlIGFtb3VudCBvZiBsYWJlbHNcbiAgICAgICAgICAgIHN0ZXAgPSBNYXRoLmZsb29yKGxhYmVscy5sZW5ndGggLyA0MCk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRpY2tDb29yZHMubGVuZ3RoOyBpICs9IHN0ZXApIHtcbiAgICAgICAgICAgIHZhciB0aWNrQ29vcmQgPSB0aWNrQ29vcmRzW2ldO1xuICAgICAgICAgICAgdmFyIHJlY3QgPSB0ZXh0Q29udGFpbi5nZXRCb3VuZGluZ1JlY3QoXG4gICAgICAgICAgICAgICAgbGFiZWxzW2ldLCBmb250LCAnY2VudGVyJywgJ3RvcCdcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZWN0W2lzQXhpc0hvcml6b250YWwgPyAneCcgOiAneSddICs9IHRpY2tDb29yZDtcbiAgICAgICAgICAgIC8vIEZJWE1FIE1hZ2ljIG51bWJlciAxLjVcbiAgICAgICAgICAgIHJlY3RbaXNBeGlzSG9yaXpvbnRhbCA/ICd3aWR0aCcgOiAnaGVpZ2h0J10gKj0gMS4zO1xuICAgICAgICAgICAgaWYgKCF0ZXh0U3BhY2VUYWtlblJlY3QpIHtcbiAgICAgICAgICAgICAgICB0ZXh0U3BhY2VUYWtlblJlY3QgPSByZWN0LmNsb25lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUaGVyZSBpcyBubyBzcGFjZSBmb3IgY3VycmVudCBsYWJlbDtcbiAgICAgICAgICAgIGVsc2UgaWYgKHRleHRTcGFjZVRha2VuUmVjdC5pbnRlcnNlY3QocmVjdCkpIHtcbiAgICAgICAgICAgICAgICBhY2N1bXVsYXRlZExhYmVsSW50ZXJ2YWwrKztcbiAgICAgICAgICAgICAgICBhdXRvTGFiZWxJbnRlcnZhbCA9IE1hdGgubWF4KGF1dG9MYWJlbEludGVydmFsLCBhY2N1bXVsYXRlZExhYmVsSW50ZXJ2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGV4dFNwYWNlVGFrZW5SZWN0LnVuaW9uKHJlY3QpO1xuICAgICAgICAgICAgICAgIC8vIFJlc2V0XG4gICAgICAgICAgICAgICAgYWNjdW11bGF0ZWRMYWJlbEludGVydmFsID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYXV0b0xhYmVsSW50ZXJ2YWwgPT09IDAgJiYgc3RlcCA+IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGVwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoYXV0b0xhYmVsSW50ZXJ2YWwgKyAxKSAqIHN0ZXAgLSAxO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXhpc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGxhYmVsRm9ybWF0dGVyXG4gICAgICogQHJldHVybiB7QXJyYXkuPHN0cmluZz59XG4gICAgICovXG4gICAgYXhpc0hlbHBlci5nZXRGb3JtYXR0ZWRMYWJlbHMgPSBmdW5jdGlvbiAoYXhpcywgbGFiZWxGb3JtYXR0ZXIpIHtcbiAgICAgICAgdmFyIHNjYWxlID0gYXhpcy5zY2FsZTtcbiAgICAgICAgdmFyIGxhYmVscyA9IHNjYWxlLmdldFRpY2tzTGFiZWxzKCk7XG4gICAgICAgIHZhciB0aWNrcyA9IHNjYWxlLmdldFRpY2tzKCk7XG4gICAgICAgIGlmICh0eXBlb2YgbGFiZWxGb3JtYXR0ZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBsYWJlbEZvcm1hdHRlciA9IChmdW5jdGlvbiAodHBsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRwbC5yZXBsYWNlKCd7dmFsdWV9JywgdmFsICE9IG51bGwgPyB2YWwgOiAnJyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pKGxhYmVsRm9ybWF0dGVyKTtcbiAgICAgICAgICAgIC8vIENvbnNpZGVyIGVtcHR5IGFycmF5XG4gICAgICAgICAgICByZXR1cm4genJVdGlsLm1hcChsYWJlbHMsIGxhYmVsRm9ybWF0dGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgbGFiZWxGb3JtYXR0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiB6clV0aWwubWFwKHRpY2tzLCBmdW5jdGlvbiAodGljaywgaWR4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxhYmVsRm9ybWF0dGVyKFxuICAgICAgICAgICAgICAgICAgICBheGlzSGVscGVyLmdldEF4aXNSYXdWYWx1ZShheGlzLCB0aWNrKSxcbiAgICAgICAgICAgICAgICAgICAgaWR4XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGxhYmVscztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBheGlzSGVscGVyLmdldEF4aXNSYXdWYWx1ZSA9IGZ1bmN0aW9uIChheGlzLCB2YWx1ZSkge1xuICAgICAgICAvLyBJbiBjYXRlZ29yeSBheGlzIHdpdGggZGF0YSB6b29tLCB0aWNrIGlzIG5vdCB0aGUgb3JpZ2luYWxcbiAgICAgICAgLy8gaW5kZXggb2YgYXhpcy5kYXRhLiBTbyB0aWNrIHNob3VsZCBub3QgYmUgZXhwb3NlZCB0byB1c2VyXG4gICAgICAgIC8vIGluIGNhdGVnb3J5IGF4aXMuXG4gICAgICAgIHJldHVybiBheGlzLnR5cGUgPT09ICdjYXRlZ29yeScgPyBheGlzLnNjYWxlLmdldExhYmVsKHZhbHVlKSA6IHZhbHVlO1xuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGF4aXNIZWxwZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9jb29yZC9heGlzSGVscGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 17 */
/* unknown exports provided */
/* all exports used */
/*!*****************************!*\
  !*** ./lib/model/Series.js ***!
  \*****************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\n    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 0);\n    var formatUtil = __webpack_require__(/*! ../util/format */ 6);\n    var classUtil = __webpack_require__(/*! ../util/clazz */ 14);\n    var modelUtil = __webpack_require__(/*! ../util/model */ 5);\n    var ComponentModel = __webpack_require__(/*! ./Component */ 12);\n    var colorPaletteMixin = __webpack_require__(/*! ./mixin/colorPalette */ 69);\n    var env = __webpack_require__(/*! zrender/lib/core/env */ 8);\n    var layout = __webpack_require__(/*! ../util/layout */ 11);\n\n    var set = classUtil.set;\n    var get = classUtil.get;\n    var encodeHTML = formatUtil.encodeHTML;\n    var addCommas = formatUtil.addCommas;\n\n    var SeriesModel = ComponentModel.extend({\n\n        type: 'series.__base__',\n\n        /**\n         * @readOnly\n         */\n        seriesIndex: 0,\n\n        // coodinateSystem will be injected in the echarts/CoordinateSystem\n        coordinateSystem: null,\n\n        /**\n         * @type {Object}\n         * @protected\n         */\n        defaultOption: null,\n\n        /**\n         * Data provided for legend\n         * @type {Function}\n         */\n        // PENDING\n        legendDataProvider: null,\n\n        /**\n         * Access path of color for visual\n         */\n        visualColorAccessPath: 'itemStyle.normal.color',\n\n        /**\n         * Support merge layout params.\n         * Only support 'box' now (left/right/top/bottom/width/height).\n         * @type {string|Object} Object can be {ignoreSize: true}\n         * @readOnly\n         */\n        layoutMode: null,\n\n        init: function (option, parentModel, ecModel, extraOpt) {\n\n            /**\n             * @type {number}\n             * @readOnly\n             */\n            this.seriesIndex = this.componentIndex;\n\n            this.mergeDefaultAndTheme(option, ecModel);\n\n            var data = this.getInitialData(option, ecModel);\n            if (true) {\n                zrUtil.assert(data, 'getInitialData returned invalid data.');\n            }\n            /**\n             * @type {module:echarts/data/List|module:echarts/data/Tree|module:echarts/data/Graph}\n             * @private\n             */\n            set(this, 'dataBeforeProcessed', data);\n\n            // If we reverse the order (make data firstly, and then make\n            // dataBeforeProcessed by cloneShallow), cloneShallow will\n            // cause data.graph.data !== data when using\n            // module:echarts/data/Graph or module:echarts/data/Tree.\n            // See module:echarts/data/helper/linkList\n            this.restoreData();\n        },\n\n        /**\n         * Util for merge default and theme to option\n         * @param  {Object} option\n         * @param  {module:echarts/model/Global} ecModel\n         */\n        mergeDefaultAndTheme: function (option, ecModel) {\n            var layoutMode = this.layoutMode;\n            var inputPositionParams = layoutMode\n                ? layout.getLayoutParams(option) : {};\n\n            zrUtil.merge(\n                option,\n                ecModel.getTheme().get(this.subType)\n            );\n            zrUtil.merge(option, this.getDefaultOption());\n\n            // Default label emphasis `position` and `show`\n            // FIXME Set label in mergeOption\n            modelUtil.defaultEmphasis(option.label, modelUtil.LABEL_OPTIONS);\n\n            this.fillDataTextStyle(option.data);\n\n            if (layoutMode) {\n                layout.mergeLayoutParam(option, inputPositionParams, layoutMode);\n            }\n        },\n\n        mergeOption: function (newSeriesOption, ecModel) {\n            newSeriesOption = zrUtil.merge(this.option, newSeriesOption, true);\n            this.fillDataTextStyle(newSeriesOption.data);\n\n            var layoutMode = this.layoutMode;\n            if (layoutMode) {\n                layout.mergeLayoutParam(this.option, newSeriesOption, layoutMode);\n            }\n\n            var data = this.getInitialData(newSeriesOption, ecModel);\n            // TODO Merge data?\n            if (data) {\n                set(this, 'data', data);\n                set(this, 'dataBeforeProcessed', data.cloneShallow());\n            }\n        },\n\n        fillDataTextStyle: function (data) {\n            // Default data label emphasis `position` and `show`\n            // FIXME Tree structure data ?\n            // FIXME Performance ?\n            if (data) {\n                for (var i = 0; i < data.length; i++) {\n                    if (data[i] && data[i].label) {\n                        modelUtil.defaultEmphasis(data[i].label, modelUtil.LABEL_OPTIONS);\n                    }\n                }\n            }\n        },\n\n        /**\n         * Init a data structure from data related option in series\n         * Must be overwritten\n         */\n        getInitialData: function () {},\n\n        /**\n         * @param {string} [dataType]\n         * @return {module:echarts/data/List}\n         */\n        getData: function (dataType) {\n            var data = get(this, 'data');\n            return dataType == null ? data : data.getLinkedData(dataType);\n        },\n\n        /**\n         * @param {module:echarts/data/List} data\n         */\n        setData: function (data) {\n            set(this, 'data', data);\n        },\n\n        /**\n         * Get data before processed\n         * @return {module:echarts/data/List}\n         */\n        getRawData: function () {\n            return get(this, 'dataBeforeProcessed');\n        },\n\n        /**\n         * Coord dimension to data dimension.\n         *\n         * By default the result is the same as dimensions of series data.\n         * But in some series data dimensions are different from coord dimensions (i.e.\n         * candlestick and boxplot). Override this method to handle those cases.\n         *\n         * Coord dimension to data dimension can be one-to-many\n         *\n         * @param {string} coordDim\n         * @return {Array.<string>} dimensions on the axis.\n         */\n        coordDimToDataDim: function (coordDim) {\n            return [coordDim];\n        },\n\n        /**\n         * Convert data dimension to coord dimension.\n         *\n         * @param {string|number} dataDim\n         * @return {string}\n         */\n        dataDimToCoordDim: function (dataDim) {\n            return dataDim;\n        },\n\n        /**\n         * Get base axis if has coordinate system and has axis.\n         * By default use coordSys.getBaseAxis();\n         * Can be overrided for some chart.\n         * @return {type} description\n         */\n        getBaseAxis: function () {\n            var coordSys = this.coordinateSystem;\n            return coordSys && coordSys.getBaseAxis && coordSys.getBaseAxis();\n        },\n\n        // FIXME\n        /**\n         * Default tooltip formatter\n         *\n         * @param {number} dataIndex\n         * @param {boolean} [multipleSeries=false]\n         * @param {number} [dataType]\n         */\n        formatTooltip: function (dataIndex, multipleSeries, dataType) {\n            function formatArrayValue(value) {\n                var result = [];\n\n                zrUtil.each(value, function (val, idx) {\n                    var dimInfo = data.getDimensionInfo(idx);\n                    var dimType = dimInfo && dimInfo.type;\n                    var valStr;\n\n                    if (dimType === 'ordinal') {\n                        valStr = val + '';\n                    }\n                    else if (dimType === 'time') {\n                        valStr = multipleSeries ? '' : formatUtil.formatTime('yyyy/MM/dd hh:mm:ss', val);\n                    }\n                    else {\n                        valStr = addCommas(val);\n                    }\n\n                    valStr && result.push(valStr);\n                });\n\n                return result.join(', ');\n            }\n\n            var data = get(this, 'data');\n\n            var value = this.getRawValue(dataIndex);\n            var formattedValue = encodeHTML(\n                zrUtil.isArray(value) ? formatArrayValue(value) : addCommas(value)\n            );\n            var name = data.getName(dataIndex);\n\n            var color = data.getItemVisual(dataIndex, 'color');\n            if (zrUtil.isObject(color) && color.colorStops) {\n                color = (color.colorStops[0] || {}).color;\n            }\n            color = color || 'transparent';\n\n            var colorEl = '<span style=\"display:inline-block;margin-right:5px;'\n                + 'border-radius:10px;width:9px;height:9px;background-color:' + encodeHTML(color) + '\"></span>';\n\n            var seriesName = this.name;\n            // FIXME\n            if (seriesName === '\\0-') {\n                // Not show '-'\n                seriesName = '';\n            }\n            return !multipleSeries\n                ? ((seriesName && encodeHTML(seriesName) + '<br />') + colorEl\n                    + (name\n                        ? encodeHTML(name) + ' : ' + formattedValue\n                        : formattedValue\n                    )\n                  )\n                : (colorEl + encodeHTML(this.name) + ' : ' + formattedValue);\n        },\n\n        /**\n         * @return {boolean}\n         */\n        isAnimationEnabled: function () {\n            if (env.node) {\n                return false;\n            }\n\n            var animationEnabled = this.getShallow('animation');\n            if (animationEnabled) {\n                if (this.getData().count() > this.getShallow('animationThreshold')) {\n                    animationEnabled = false;\n                }\n            }\n            return animationEnabled;\n        },\n\n        restoreData: function () {\n            set(this, 'data', get(this, 'dataBeforeProcessed').cloneShallow());\n        },\n\n        getColorFromPalette: function (name, scope) {\n            var ecModel = this.ecModel;\n            // PENDING\n            var color = colorPaletteMixin.getColorFromPalette.call(this, name, scope);\n            if (!color) {\n                color = ecModel.getColorFromPalette(name, scope);\n            }\n            return color;\n        },\n\n        /**\n         * Get data indices for show tooltip content. See tooltip.\n         * @abstract\n         * @param {Array.<string>|string} dim\n         * @param {Array.<number>} value\n         * @param {module:echarts/coord/single/SingleAxis} baseAxis\n         * @return {Object} {dataIndices, nestestValue}.\n         */\n        getAxisTooltipData: null,\n\n        /**\n         * See tooltip.\n         * @abstract\n         * @param {number} dataIndex\n         * @return {Array.<number>} Point of tooltip. null/undefined can be returned.\n         */\n        getTooltipPosition: null\n    });\n\n    zrUtil.mixin(SeriesModel, modelUtil.dataFormatMixin);\n    zrUtil.mixin(SeriesModel, colorPaletteMixin);\n\n    module.exports = SeriesModel;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvbW9kZWwvU2VyaWVzLmpzPzc4NjIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG4gICAgdmFyIGZvcm1hdFV0aWwgPSByZXF1aXJlKCcuLi91dGlsL2Zvcm1hdCcpO1xuICAgIHZhciBjbGFzc1V0aWwgPSByZXF1aXJlKCcuLi91dGlsL2NsYXp6Jyk7XG4gICAgdmFyIG1vZGVsVXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvbW9kZWwnKTtcbiAgICB2YXIgQ29tcG9uZW50TW9kZWwgPSByZXF1aXJlKCcuL0NvbXBvbmVudCcpO1xuICAgIHZhciBjb2xvclBhbGV0dGVNaXhpbiA9IHJlcXVpcmUoJy4vbWl4aW4vY29sb3JQYWxldHRlJyk7XG4gICAgdmFyIGVudiA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvZW52Jyk7XG4gICAgdmFyIGxheW91dCA9IHJlcXVpcmUoJy4uL3V0aWwvbGF5b3V0Jyk7XG5cbiAgICB2YXIgc2V0ID0gY2xhc3NVdGlsLnNldDtcbiAgICB2YXIgZ2V0ID0gY2xhc3NVdGlsLmdldDtcbiAgICB2YXIgZW5jb2RlSFRNTCA9IGZvcm1hdFV0aWwuZW5jb2RlSFRNTDtcbiAgICB2YXIgYWRkQ29tbWFzID0gZm9ybWF0VXRpbC5hZGRDb21tYXM7XG5cbiAgICB2YXIgU2VyaWVzTW9kZWwgPSBDb21wb25lbnRNb2RlbC5leHRlbmQoe1xuXG4gICAgICAgIHR5cGU6ICdzZXJpZXMuX19iYXNlX18nLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmVhZE9ubHlcbiAgICAgICAgICovXG4gICAgICAgIHNlcmllc0luZGV4OiAwLFxuXG4gICAgICAgIC8vIGNvb2RpbmF0ZVN5c3RlbSB3aWxsIGJlIGluamVjdGVkIGluIHRoZSBlY2hhcnRzL0Nvb3JkaW5hdGVTeXN0ZW1cbiAgICAgICAgY29vcmRpbmF0ZVN5c3RlbTogbnVsbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgZGVmYXVsdE9wdGlvbjogbnVsbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGF0YSBwcm92aWRlZCBmb3IgbGVnZW5kXG4gICAgICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgICAgICovXG4gICAgICAgIC8vIFBFTkRJTkdcbiAgICAgICAgbGVnZW5kRGF0YVByb3ZpZGVyOiBudWxsLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBY2Nlc3MgcGF0aCBvZiBjb2xvciBmb3IgdmlzdWFsXG4gICAgICAgICAqL1xuICAgICAgICB2aXN1YWxDb2xvckFjY2Vzc1BhdGg6ICdpdGVtU3R5bGUubm9ybWFsLmNvbG9yJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU3VwcG9ydCBtZXJnZSBsYXlvdXQgcGFyYW1zLlxuICAgICAgICAgKiBPbmx5IHN1cHBvcnQgJ2JveCcgbm93IChsZWZ0L3JpZ2h0L3RvcC9ib3R0b20vd2lkdGgvaGVpZ2h0KS5cbiAgICAgICAgICogQHR5cGUge3N0cmluZ3xPYmplY3R9IE9iamVjdCBjYW4gYmUge2lnbm9yZVNpemU6IHRydWV9XG4gICAgICAgICAqIEByZWFkT25seVxuICAgICAgICAgKi9cbiAgICAgICAgbGF5b3V0TW9kZTogbnVsbCxcblxuICAgICAgICBpbml0OiBmdW5jdGlvbiAob3B0aW9uLCBwYXJlbnRNb2RlbCwgZWNNb2RlbCwgZXh0cmFPcHQpIHtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgICAgICogQHJlYWRPbmx5XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuc2VyaWVzSW5kZXggPSB0aGlzLmNvbXBvbmVudEluZGV4O1xuXG4gICAgICAgICAgICB0aGlzLm1lcmdlRGVmYXVsdEFuZFRoZW1lKG9wdGlvbiwgZWNNb2RlbCk7XG5cbiAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5nZXRJbml0aWFsRGF0YShvcHRpb24sIGVjTW9kZWwpO1xuICAgICAgICAgICAgaWYgKF9fREVWX18pIHtcbiAgICAgICAgICAgICAgICB6clV0aWwuYXNzZXJ0KGRhdGEsICdnZXRJbml0aWFsRGF0YSByZXR1cm5lZCBpbnZhbGlkIGRhdGEuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEB0eXBlIHttb2R1bGU6ZWNoYXJ0cy9kYXRhL0xpc3R8bW9kdWxlOmVjaGFydHMvZGF0YS9UcmVlfG1vZHVsZTplY2hhcnRzL2RhdGEvR3JhcGh9XG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBzZXQodGhpcywgJ2RhdGFCZWZvcmVQcm9jZXNzZWQnLCBkYXRhKTtcblxuICAgICAgICAgICAgLy8gSWYgd2UgcmV2ZXJzZSB0aGUgb3JkZXIgKG1ha2UgZGF0YSBmaXJzdGx5LCBhbmQgdGhlbiBtYWtlXG4gICAgICAgICAgICAvLyBkYXRhQmVmb3JlUHJvY2Vzc2VkIGJ5IGNsb25lU2hhbGxvdyksIGNsb25lU2hhbGxvdyB3aWxsXG4gICAgICAgICAgICAvLyBjYXVzZSBkYXRhLmdyYXBoLmRhdGEgIT09IGRhdGEgd2hlbiB1c2luZ1xuICAgICAgICAgICAgLy8gbW9kdWxlOmVjaGFydHMvZGF0YS9HcmFwaCBvciBtb2R1bGU6ZWNoYXJ0cy9kYXRhL1RyZWUuXG4gICAgICAgICAgICAvLyBTZWUgbW9kdWxlOmVjaGFydHMvZGF0YS9oZWxwZXIvbGlua0xpc3RcbiAgICAgICAgICAgIHRoaXMucmVzdG9yZURhdGEoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVXRpbCBmb3IgbWVyZ2UgZGVmYXVsdCBhbmQgdGhlbWUgdG8gb3B0aW9uXG4gICAgICAgICAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9uXG4gICAgICAgICAqIEBwYXJhbSAge21vZHVsZTplY2hhcnRzL21vZGVsL0dsb2JhbH0gZWNNb2RlbFxuICAgICAgICAgKi9cbiAgICAgICAgbWVyZ2VEZWZhdWx0QW5kVGhlbWU6IGZ1bmN0aW9uIChvcHRpb24sIGVjTW9kZWwpIHtcbiAgICAgICAgICAgIHZhciBsYXlvdXRNb2RlID0gdGhpcy5sYXlvdXRNb2RlO1xuICAgICAgICAgICAgdmFyIGlucHV0UG9zaXRpb25QYXJhbXMgPSBsYXlvdXRNb2RlXG4gICAgICAgICAgICAgICAgPyBsYXlvdXQuZ2V0TGF5b3V0UGFyYW1zKG9wdGlvbikgOiB7fTtcblxuICAgICAgICAgICAgenJVdGlsLm1lcmdlKFxuICAgICAgICAgICAgICAgIG9wdGlvbixcbiAgICAgICAgICAgICAgICBlY01vZGVsLmdldFRoZW1lKCkuZ2V0KHRoaXMuc3ViVHlwZSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB6clV0aWwubWVyZ2Uob3B0aW9uLCB0aGlzLmdldERlZmF1bHRPcHRpb24oKSk7XG5cbiAgICAgICAgICAgIC8vIERlZmF1bHQgbGFiZWwgZW1waGFzaXMgYHBvc2l0aW9uYCBhbmQgYHNob3dgXG4gICAgICAgICAgICAvLyBGSVhNRSBTZXQgbGFiZWwgaW4gbWVyZ2VPcHRpb25cbiAgICAgICAgICAgIG1vZGVsVXRpbC5kZWZhdWx0RW1waGFzaXMob3B0aW9uLmxhYmVsLCBtb2RlbFV0aWwuTEFCRUxfT1BUSU9OUyk7XG5cbiAgICAgICAgICAgIHRoaXMuZmlsbERhdGFUZXh0U3R5bGUob3B0aW9uLmRhdGEpO1xuXG4gICAgICAgICAgICBpZiAobGF5b3V0TW9kZSkge1xuICAgICAgICAgICAgICAgIGxheW91dC5tZXJnZUxheW91dFBhcmFtKG9wdGlvbiwgaW5wdXRQb3NpdGlvblBhcmFtcywgbGF5b3V0TW9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgbWVyZ2VPcHRpb246IGZ1bmN0aW9uIChuZXdTZXJpZXNPcHRpb24sIGVjTW9kZWwpIHtcbiAgICAgICAgICAgIG5ld1Nlcmllc09wdGlvbiA9IHpyVXRpbC5tZXJnZSh0aGlzLm9wdGlvbiwgbmV3U2VyaWVzT3B0aW9uLCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuZmlsbERhdGFUZXh0U3R5bGUobmV3U2VyaWVzT3B0aW9uLmRhdGEpO1xuXG4gICAgICAgICAgICB2YXIgbGF5b3V0TW9kZSA9IHRoaXMubGF5b3V0TW9kZTtcbiAgICAgICAgICAgIGlmIChsYXlvdXRNb2RlKSB7XG4gICAgICAgICAgICAgICAgbGF5b3V0Lm1lcmdlTGF5b3V0UGFyYW0odGhpcy5vcHRpb24sIG5ld1Nlcmllc09wdGlvbiwgbGF5b3V0TW9kZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5nZXRJbml0aWFsRGF0YShuZXdTZXJpZXNPcHRpb24sIGVjTW9kZWwpO1xuICAgICAgICAgICAgLy8gVE9ETyBNZXJnZSBkYXRhP1xuICAgICAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgICAgICBzZXQodGhpcywgJ2RhdGEnLCBkYXRhKTtcbiAgICAgICAgICAgICAgICBzZXQodGhpcywgJ2RhdGFCZWZvcmVQcm9jZXNzZWQnLCBkYXRhLmNsb25lU2hhbGxvdygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBmaWxsRGF0YVRleHRTdHlsZTogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIC8vIERlZmF1bHQgZGF0YSBsYWJlbCBlbXBoYXNpcyBgcG9zaXRpb25gIGFuZCBgc2hvd2BcbiAgICAgICAgICAgIC8vIEZJWE1FIFRyZWUgc3RydWN0dXJlIGRhdGEgP1xuICAgICAgICAgICAgLy8gRklYTUUgUGVyZm9ybWFuY2UgP1xuICAgICAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFbaV0gJiYgZGF0YVtpXS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWxVdGlsLmRlZmF1bHRFbXBoYXNpcyhkYXRhW2ldLmxhYmVsLCBtb2RlbFV0aWwuTEFCRUxfT1BUSU9OUyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluaXQgYSBkYXRhIHN0cnVjdHVyZSBmcm9tIGRhdGEgcmVsYXRlZCBvcHRpb24gaW4gc2VyaWVzXG4gICAgICAgICAqIE11c3QgYmUgb3ZlcndyaXR0ZW5cbiAgICAgICAgICovXG4gICAgICAgIGdldEluaXRpYWxEYXRhOiBmdW5jdGlvbiAoKSB7fSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtkYXRhVHlwZV1cbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOmVjaGFydHMvZGF0YS9MaXN0fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0RGF0YTogZnVuY3Rpb24gKGRhdGFUeXBlKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IGdldCh0aGlzLCAnZGF0YScpO1xuICAgICAgICAgICAgcmV0dXJuIGRhdGFUeXBlID09IG51bGwgPyBkYXRhIDogZGF0YS5nZXRMaW5rZWREYXRhKGRhdGFUeXBlKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9kYXRhL0xpc3R9IGRhdGFcbiAgICAgICAgICovXG4gICAgICAgIHNldERhdGE6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICBzZXQodGhpcywgJ2RhdGEnLCBkYXRhKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGRhdGEgYmVmb3JlIHByb2Nlc3NlZFxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6ZWNoYXJ0cy9kYXRhL0xpc3R9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRSYXdEYXRhOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0KHRoaXMsICdkYXRhQmVmb3JlUHJvY2Vzc2VkJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvb3JkIGRpbWVuc2lvbiB0byBkYXRhIGRpbWVuc2lvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQnkgZGVmYXVsdCB0aGUgcmVzdWx0IGlzIHRoZSBzYW1lIGFzIGRpbWVuc2lvbnMgb2Ygc2VyaWVzIGRhdGEuXG4gICAgICAgICAqIEJ1dCBpbiBzb21lIHNlcmllcyBkYXRhIGRpbWVuc2lvbnMgYXJlIGRpZmZlcmVudCBmcm9tIGNvb3JkIGRpbWVuc2lvbnMgKGkuZS5cbiAgICAgICAgICogY2FuZGxlc3RpY2sgYW5kIGJveHBsb3QpLiBPdmVycmlkZSB0aGlzIG1ldGhvZCB0byBoYW5kbGUgdGhvc2UgY2FzZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIENvb3JkIGRpbWVuc2lvbiB0byBkYXRhIGRpbWVuc2lvbiBjYW4gYmUgb25lLXRvLW1hbnlcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNvb3JkRGltXG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5LjxzdHJpbmc+fSBkaW1lbnNpb25zIG9uIHRoZSBheGlzLlxuICAgICAgICAgKi9cbiAgICAgICAgY29vcmREaW1Ub0RhdGFEaW06IGZ1bmN0aW9uIChjb29yZERpbSkge1xuICAgICAgICAgICAgcmV0dXJuIFtjb29yZERpbV07XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnQgZGF0YSBkaW1lbnNpb24gdG8gY29vcmQgZGltZW5zaW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IGRhdGFEaW1cbiAgICAgICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgZGF0YURpbVRvQ29vcmREaW06IGZ1bmN0aW9uIChkYXRhRGltKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YURpbTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGJhc2UgYXhpcyBpZiBoYXMgY29vcmRpbmF0ZSBzeXN0ZW0gYW5kIGhhcyBheGlzLlxuICAgICAgICAgKiBCeSBkZWZhdWx0IHVzZSBjb29yZFN5cy5nZXRCYXNlQXhpcygpO1xuICAgICAgICAgKiBDYW4gYmUgb3ZlcnJpZGVkIGZvciBzb21lIGNoYXJ0LlxuICAgICAgICAgKiBAcmV0dXJuIHt0eXBlfSBkZXNjcmlwdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0QmFzZUF4aXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjb29yZFN5cyA9IHRoaXMuY29vcmRpbmF0ZVN5c3RlbTtcbiAgICAgICAgICAgIHJldHVybiBjb29yZFN5cyAmJiBjb29yZFN5cy5nZXRCYXNlQXhpcyAmJiBjb29yZFN5cy5nZXRCYXNlQXhpcygpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIEZJWE1FXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWZhdWx0IHRvb2x0aXAgZm9ybWF0dGVyXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkYXRhSW5kZXhcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbbXVsdGlwbGVTZXJpZXM9ZmFsc2VdXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZGF0YVR5cGVdXG4gICAgICAgICAqL1xuICAgICAgICBmb3JtYXRUb29sdGlwOiBmdW5jdGlvbiAoZGF0YUluZGV4LCBtdWx0aXBsZVNlcmllcywgZGF0YVR5cGUpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGZvcm1hdEFycmF5VmFsdWUodmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgICAgICAgICAgICB6clV0aWwuZWFjaCh2YWx1ZSwgZnVuY3Rpb24gKHZhbCwgaWR4KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkaW1JbmZvID0gZGF0YS5nZXREaW1lbnNpb25JbmZvKGlkeCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkaW1UeXBlID0gZGltSW5mbyAmJiBkaW1JbmZvLnR5cGU7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWxTdHI7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpbVR5cGUgPT09ICdvcmRpbmFsJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsU3RyID0gdmFsICsgJyc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZGltVHlwZSA9PT0gJ3RpbWUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxTdHIgPSBtdWx0aXBsZVNlcmllcyA/ICcnIDogZm9ybWF0VXRpbC5mb3JtYXRUaW1lKCd5eXl5L01NL2RkIGhoOm1tOnNzJywgdmFsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbFN0ciA9IGFkZENvbW1hcyh2YWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFsU3RyICYmIHJlc3VsdC5wdXNoKHZhbFN0cik7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LmpvaW4oJywgJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBkYXRhID0gZ2V0KHRoaXMsICdkYXRhJyk7XG5cbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0UmF3VmFsdWUoZGF0YUluZGV4KTtcbiAgICAgICAgICAgIHZhciBmb3JtYXR0ZWRWYWx1ZSA9IGVuY29kZUhUTUwoXG4gICAgICAgICAgICAgICAgenJVdGlsLmlzQXJyYXkodmFsdWUpID8gZm9ybWF0QXJyYXlWYWx1ZSh2YWx1ZSkgOiBhZGRDb21tYXModmFsdWUpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBkYXRhLmdldE5hbWUoZGF0YUluZGV4KTtcblxuICAgICAgICAgICAgdmFyIGNvbG9yID0gZGF0YS5nZXRJdGVtVmlzdWFsKGRhdGFJbmRleCwgJ2NvbG9yJyk7XG4gICAgICAgICAgICBpZiAoenJVdGlsLmlzT2JqZWN0KGNvbG9yKSAmJiBjb2xvci5jb2xvclN0b3BzKSB7XG4gICAgICAgICAgICAgICAgY29sb3IgPSAoY29sb3IuY29sb3JTdG9wc1swXSB8fCB7fSkuY29sb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb2xvciA9IGNvbG9yIHx8ICd0cmFuc3BhcmVudCc7XG5cbiAgICAgICAgICAgIHZhciBjb2xvckVsID0gJzxzcGFuIHN0eWxlPVwiZGlzcGxheTppbmxpbmUtYmxvY2s7bWFyZ2luLXJpZ2h0OjVweDsnXG4gICAgICAgICAgICAgICAgKyAnYm9yZGVyLXJhZGl1czoxMHB4O3dpZHRoOjlweDtoZWlnaHQ6OXB4O2JhY2tncm91bmQtY29sb3I6JyArIGVuY29kZUhUTUwoY29sb3IpICsgJ1wiPjwvc3Bhbj4nO1xuXG4gICAgICAgICAgICB2YXIgc2VyaWVzTmFtZSA9IHRoaXMubmFtZTtcbiAgICAgICAgICAgIC8vIEZJWE1FXG4gICAgICAgICAgICBpZiAoc2VyaWVzTmFtZSA9PT0gJ1xcMC0nKSB7XG4gICAgICAgICAgICAgICAgLy8gTm90IHNob3cgJy0nXG4gICAgICAgICAgICAgICAgc2VyaWVzTmFtZSA9ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICFtdWx0aXBsZVNlcmllc1xuICAgICAgICAgICAgICAgID8gKChzZXJpZXNOYW1lICYmIGVuY29kZUhUTUwoc2VyaWVzTmFtZSkgKyAnPGJyIC8+JykgKyBjb2xvckVsXG4gICAgICAgICAgICAgICAgICAgICsgKG5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgID8gZW5jb2RlSFRNTChuYW1lKSArICcgOiAnICsgZm9ybWF0dGVkVmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIDogZm9ybWF0dGVkVmFsdWVcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIDogKGNvbG9yRWwgKyBlbmNvZGVIVE1MKHRoaXMubmFtZSkgKyAnIDogJyArIGZvcm1hdHRlZFZhbHVlKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGlzQW5pbWF0aW9uRW5hYmxlZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGVudi5ub2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgYW5pbWF0aW9uRW5hYmxlZCA9IHRoaXMuZ2V0U2hhbGxvdygnYW5pbWF0aW9uJyk7XG4gICAgICAgICAgICBpZiAoYW5pbWF0aW9uRW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmdldERhdGEoKS5jb3VudCgpID4gdGhpcy5nZXRTaGFsbG93KCdhbmltYXRpb25UaHJlc2hvbGQnKSkge1xuICAgICAgICAgICAgICAgICAgICBhbmltYXRpb25FbmFibGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFuaW1hdGlvbkVuYWJsZWQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVzdG9yZURhdGE6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNldCh0aGlzLCAnZGF0YScsIGdldCh0aGlzLCAnZGF0YUJlZm9yZVByb2Nlc3NlZCcpLmNsb25lU2hhbGxvdygpKTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRDb2xvckZyb21QYWxldHRlOiBmdW5jdGlvbiAobmFtZSwgc2NvcGUpIHtcbiAgICAgICAgICAgIHZhciBlY01vZGVsID0gdGhpcy5lY01vZGVsO1xuICAgICAgICAgICAgLy8gUEVORElOR1xuICAgICAgICAgICAgdmFyIGNvbG9yID0gY29sb3JQYWxldHRlTWl4aW4uZ2V0Q29sb3JGcm9tUGFsZXR0ZS5jYWxsKHRoaXMsIG5hbWUsIHNjb3BlKTtcbiAgICAgICAgICAgIGlmICghY29sb3IpIHtcbiAgICAgICAgICAgICAgICBjb2xvciA9IGVjTW9kZWwuZ2V0Q29sb3JGcm9tUGFsZXR0ZShuYW1lLCBzY29wZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29sb3I7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBkYXRhIGluZGljZXMgZm9yIHNob3cgdG9vbHRpcCBjb250ZW50LiBTZWUgdG9vbHRpcC5cbiAgICAgICAgICogQGFic3RyYWN0XG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz58c3RyaW5nfSBkaW1cbiAgICAgICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gdmFsdWVcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9jb29yZC9zaW5nbGUvU2luZ2xlQXhpc30gYmFzZUF4aXNcbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSB7ZGF0YUluZGljZXMsIG5lc3Rlc3RWYWx1ZX0uXG4gICAgICAgICAqL1xuICAgICAgICBnZXRBeGlzVG9vbHRpcERhdGE6IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNlZSB0b29sdGlwLlxuICAgICAgICAgKiBAYWJzdHJhY3RcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGRhdGFJbmRleFxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn0gUG9pbnQgb2YgdG9vbHRpcC4gbnVsbC91bmRlZmluZWQgY2FuIGJlIHJldHVybmVkLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0VG9vbHRpcFBvc2l0aW9uOiBudWxsXG4gICAgfSk7XG5cbiAgICB6clV0aWwubWl4aW4oU2VyaWVzTW9kZWwsIG1vZGVsVXRpbC5kYXRhRm9ybWF0TWl4aW4pO1xuICAgIHpyVXRpbC5taXhpbihTZXJpZXNNb2RlbCwgY29sb3JQYWxldHRlTWl4aW4pO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBTZXJpZXNNb2RlbDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL21vZGVsL1Nlcmllcy5qc1xuLy8gbW9kdWxlIGlkID0gMTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 18 */
/* unknown exports provided */
/* all exports used */
/*!*********************************************!*\
  !*** /home/yx/~/zrender/lib/core/matrix.js ***!
  \*********************************************/
/***/ (function(module, exports) {

eval("\n    var ArrayCtor = typeof Float32Array === 'undefined'\n        ? Array\n        : Float32Array;\n    /**\n     * 3x2矩阵操作类\n     * @exports zrender/tool/matrix\n     */\n    var matrix = {\n        /**\n         * 创建一个单位矩阵\n         * @return {Float32Array|Array.<number>}\n         */\n        create : function() {\n            var out = new ArrayCtor(6);\n            matrix.identity(out);\n\n            return out;\n        },\n        /**\n         * 设置矩阵为单位矩阵\n         * @param {Float32Array|Array.<number>} out\n         */\n        identity : function(out) {\n            out[0] = 1;\n            out[1] = 0;\n            out[2] = 0;\n            out[3] = 1;\n            out[4] = 0;\n            out[5] = 0;\n            return out;\n        },\n        /**\n         * 复制矩阵\n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} m\n         */\n        copy: function(out, m) {\n            out[0] = m[0];\n            out[1] = m[1];\n            out[2] = m[2];\n            out[3] = m[3];\n            out[4] = m[4];\n            out[5] = m[5];\n            return out;\n        },\n        /**\n         * 矩阵相乘\n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} m1\n         * @param {Float32Array|Array.<number>} m2\n         */\n        mul : function (out, m1, m2) {\n            // Consider matrix.mul(m, m2, m);\n            // where out is the same as m2.\n            // So use temp variable to escape error.\n            var out0 = m1[0] * m2[0] + m1[2] * m2[1];\n            var out1 = m1[1] * m2[0] + m1[3] * m2[1];\n            var out2 = m1[0] * m2[2] + m1[2] * m2[3];\n            var out3 = m1[1] * m2[2] + m1[3] * m2[3];\n            var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];\n            var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];\n            out[0] = out0;\n            out[1] = out1;\n            out[2] = out2;\n            out[3] = out3;\n            out[4] = out4;\n            out[5] = out5;\n            return out;\n        },\n        /**\n         * 平移变换\n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         * @param {Float32Array|Array.<number>} v\n         */\n        translate : function(out, a, v) {\n            out[0] = a[0];\n            out[1] = a[1];\n            out[2] = a[2];\n            out[3] = a[3];\n            out[4] = a[4] + v[0];\n            out[5] = a[5] + v[1];\n            return out;\n        },\n        /**\n         * 旋转变换\n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         * @param {number} rad\n         */\n        rotate : function(out, a, rad) {\n            var aa = a[0];\n            var ac = a[2];\n            var atx = a[4];\n            var ab = a[1];\n            var ad = a[3];\n            var aty = a[5];\n            var st = Math.sin(rad);\n            var ct = Math.cos(rad);\n\n            out[0] = aa * ct + ab * st;\n            out[1] = -aa * st + ab * ct;\n            out[2] = ac * ct + ad * st;\n            out[3] = -ac * st + ct * ad;\n            out[4] = ct * atx + st * aty;\n            out[5] = ct * aty - st * atx;\n            return out;\n        },\n        /**\n         * 缩放变换\n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         * @param {Float32Array|Array.<number>} v\n         */\n        scale : function(out, a, v) {\n            var vx = v[0];\n            var vy = v[1];\n            out[0] = a[0] * vx;\n            out[1] = a[1] * vy;\n            out[2] = a[2] * vx;\n            out[3] = a[3] * vy;\n            out[4] = a[4] * vx;\n            out[5] = a[5] * vy;\n            return out;\n        },\n        /**\n         * 求逆矩阵\n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         */\n        invert : function(out, a) {\n\n            var aa = a[0];\n            var ac = a[2];\n            var atx = a[4];\n            var ab = a[1];\n            var ad = a[3];\n            var aty = a[5];\n\n            var det = aa * ad - ab * ac;\n            if (!det) {\n                return null;\n            }\n            det = 1.0 / det;\n\n            out[0] = ad * det;\n            out[1] = -ab * det;\n            out[2] = -ac * det;\n            out[3] = aa * det;\n            out[4] = (ac * aty - ad * atx) * det;\n            out[5] = (ab * atx - aa * aty) * det;\n            return out;\n        }\n    };\n\n    module.exports = matrix;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL2hvbWUveXgvfi96cmVuZGVyL2xpYi9jb3JlL21hdHJpeC5qcz82YjBiIl0sInNvdXJjZXNDb250ZW50IjpbIlxuICAgIHZhciBBcnJheUN0b3IgPSB0eXBlb2YgRmxvYXQzMkFycmF5ID09PSAndW5kZWZpbmVkJ1xuICAgICAgICA/IEFycmF5XG4gICAgICAgIDogRmxvYXQzMkFycmF5O1xuICAgIC8qKlxuICAgICAqIDN4MuefqemYteaTjeS9nOexu1xuICAgICAqIEBleHBvcnRzIHpyZW5kZXIvdG9vbC9tYXRyaXhcbiAgICAgKi9cbiAgICB2YXIgbWF0cml4ID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICog5Yib5bu65LiA5Liq5Y2V5L2N55+p6Zi1XG4gICAgICAgICAqIEByZXR1cm4ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn1cbiAgICAgICAgICovXG4gICAgICAgIGNyZWF0ZSA6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIG91dCA9IG5ldyBBcnJheUN0b3IoNik7XG4gICAgICAgICAgICBtYXRyaXguaWRlbnRpdHkob3V0KTtcblxuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiuvue9ruefqemYteS4uuWNleS9jeefqemYtVxuICAgICAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gb3V0XG4gICAgICAgICAqL1xuICAgICAgICBpZGVudGl0eSA6IGZ1bmN0aW9uKG91dCkge1xuICAgICAgICAgICAgb3V0WzBdID0gMTtcbiAgICAgICAgICAgIG91dFsxXSA9IDA7XG4gICAgICAgICAgICBvdXRbMl0gPSAwO1xuICAgICAgICAgICAgb3V0WzNdID0gMTtcbiAgICAgICAgICAgIG91dFs0XSA9IDA7XG4gICAgICAgICAgICBvdXRbNV0gPSAwO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWkjeWItuefqemYtVxuICAgICAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gb3V0XG4gICAgICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBtXG4gICAgICAgICAqL1xuICAgICAgICBjb3B5OiBmdW5jdGlvbihvdXQsIG0pIHtcbiAgICAgICAgICAgIG91dFswXSA9IG1bMF07XG4gICAgICAgICAgICBvdXRbMV0gPSBtWzFdO1xuICAgICAgICAgICAgb3V0WzJdID0gbVsyXTtcbiAgICAgICAgICAgIG91dFszXSA9IG1bM107XG4gICAgICAgICAgICBvdXRbNF0gPSBtWzRdO1xuICAgICAgICAgICAgb3V0WzVdID0gbVs1XTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDnn6npmLXnm7jkuZhcbiAgICAgICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IG91dFxuICAgICAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gbTFcbiAgICAgICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IG0yXG4gICAgICAgICAqL1xuICAgICAgICBtdWwgOiBmdW5jdGlvbiAob3V0LCBtMSwgbTIpIHtcbiAgICAgICAgICAgIC8vIENvbnNpZGVyIG1hdHJpeC5tdWwobSwgbTIsIG0pO1xuICAgICAgICAgICAgLy8gd2hlcmUgb3V0IGlzIHRoZSBzYW1lIGFzIG0yLlxuICAgICAgICAgICAgLy8gU28gdXNlIHRlbXAgdmFyaWFibGUgdG8gZXNjYXBlIGVycm9yLlxuICAgICAgICAgICAgdmFyIG91dDAgPSBtMVswXSAqIG0yWzBdICsgbTFbMl0gKiBtMlsxXTtcbiAgICAgICAgICAgIHZhciBvdXQxID0gbTFbMV0gKiBtMlswXSArIG0xWzNdICogbTJbMV07XG4gICAgICAgICAgICB2YXIgb3V0MiA9IG0xWzBdICogbTJbMl0gKyBtMVsyXSAqIG0yWzNdO1xuICAgICAgICAgICAgdmFyIG91dDMgPSBtMVsxXSAqIG0yWzJdICsgbTFbM10gKiBtMlszXTtcbiAgICAgICAgICAgIHZhciBvdXQ0ID0gbTFbMF0gKiBtMls0XSArIG0xWzJdICogbTJbNV0gKyBtMVs0XTtcbiAgICAgICAgICAgIHZhciBvdXQ1ID0gbTFbMV0gKiBtMls0XSArIG0xWzNdICogbTJbNV0gKyBtMVs1XTtcbiAgICAgICAgICAgIG91dFswXSA9IG91dDA7XG4gICAgICAgICAgICBvdXRbMV0gPSBvdXQxO1xuICAgICAgICAgICAgb3V0WzJdID0gb3V0MjtcbiAgICAgICAgICAgIG91dFszXSA9IG91dDM7XG4gICAgICAgICAgICBvdXRbNF0gPSBvdXQ0O1xuICAgICAgICAgICAgb3V0WzVdID0gb3V0NTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlubPnp7vlj5jmjaJcbiAgICAgICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IG91dFxuICAgICAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gYVxuICAgICAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gdlxuICAgICAgICAgKi9cbiAgICAgICAgdHJhbnNsYXRlIDogZnVuY3Rpb24ob3V0LCBhLCB2KSB7XG4gICAgICAgICAgICBvdXRbMF0gPSBhWzBdO1xuICAgICAgICAgICAgb3V0WzFdID0gYVsxXTtcbiAgICAgICAgICAgIG91dFsyXSA9IGFbMl07XG4gICAgICAgICAgICBvdXRbM10gPSBhWzNdO1xuICAgICAgICAgICAgb3V0WzRdID0gYVs0XSArIHZbMF07XG4gICAgICAgICAgICBvdXRbNV0gPSBhWzVdICsgdlsxXTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDml4vovazlj5jmjaJcbiAgICAgICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IG91dFxuICAgICAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gYVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gcmFkXG4gICAgICAgICAqL1xuICAgICAgICByb3RhdGUgOiBmdW5jdGlvbihvdXQsIGEsIHJhZCkge1xuICAgICAgICAgICAgdmFyIGFhID0gYVswXTtcbiAgICAgICAgICAgIHZhciBhYyA9IGFbMl07XG4gICAgICAgICAgICB2YXIgYXR4ID0gYVs0XTtcbiAgICAgICAgICAgIHZhciBhYiA9IGFbMV07XG4gICAgICAgICAgICB2YXIgYWQgPSBhWzNdO1xuICAgICAgICAgICAgdmFyIGF0eSA9IGFbNV07XG4gICAgICAgICAgICB2YXIgc3QgPSBNYXRoLnNpbihyYWQpO1xuICAgICAgICAgICAgdmFyIGN0ID0gTWF0aC5jb3MocmFkKTtcblxuICAgICAgICAgICAgb3V0WzBdID0gYWEgKiBjdCArIGFiICogc3Q7XG4gICAgICAgICAgICBvdXRbMV0gPSAtYWEgKiBzdCArIGFiICogY3Q7XG4gICAgICAgICAgICBvdXRbMl0gPSBhYyAqIGN0ICsgYWQgKiBzdDtcbiAgICAgICAgICAgIG91dFszXSA9IC1hYyAqIHN0ICsgY3QgKiBhZDtcbiAgICAgICAgICAgIG91dFs0XSA9IGN0ICogYXR4ICsgc3QgKiBhdHk7XG4gICAgICAgICAgICBvdXRbNV0gPSBjdCAqIGF0eSAtIHN0ICogYXR4O1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOe8qeaUvuWPmOaNolxuICAgICAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gb3V0XG4gICAgICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBhXG4gICAgICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSB2XG4gICAgICAgICAqL1xuICAgICAgICBzY2FsZSA6IGZ1bmN0aW9uKG91dCwgYSwgdikge1xuICAgICAgICAgICAgdmFyIHZ4ID0gdlswXTtcbiAgICAgICAgICAgIHZhciB2eSA9IHZbMV07XG4gICAgICAgICAgICBvdXRbMF0gPSBhWzBdICogdng7XG4gICAgICAgICAgICBvdXRbMV0gPSBhWzFdICogdnk7XG4gICAgICAgICAgICBvdXRbMl0gPSBhWzJdICogdng7XG4gICAgICAgICAgICBvdXRbM10gPSBhWzNdICogdnk7XG4gICAgICAgICAgICBvdXRbNF0gPSBhWzRdICogdng7XG4gICAgICAgICAgICBvdXRbNV0gPSBhWzVdICogdnk7XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICog5rGC6YCG55+p6Zi1XG4gICAgICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBvdXRcbiAgICAgICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IGFcbiAgICAgICAgICovXG4gICAgICAgIGludmVydCA6IGZ1bmN0aW9uKG91dCwgYSkge1xuXG4gICAgICAgICAgICB2YXIgYWEgPSBhWzBdO1xuICAgICAgICAgICAgdmFyIGFjID0gYVsyXTtcbiAgICAgICAgICAgIHZhciBhdHggPSBhWzRdO1xuICAgICAgICAgICAgdmFyIGFiID0gYVsxXTtcbiAgICAgICAgICAgIHZhciBhZCA9IGFbM107XG4gICAgICAgICAgICB2YXIgYXR5ID0gYVs1XTtcblxuICAgICAgICAgICAgdmFyIGRldCA9IGFhICogYWQgLSBhYiAqIGFjO1xuICAgICAgICAgICAgaWYgKCFkZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRldCA9IDEuMCAvIGRldDtcblxuICAgICAgICAgICAgb3V0WzBdID0gYWQgKiBkZXQ7XG4gICAgICAgICAgICBvdXRbMV0gPSAtYWIgKiBkZXQ7XG4gICAgICAgICAgICBvdXRbMl0gPSAtYWMgKiBkZXQ7XG4gICAgICAgICAgICBvdXRbM10gPSBhYSAqIGRldDtcbiAgICAgICAgICAgIG91dFs0XSA9IChhYyAqIGF0eSAtIGFkICogYXR4KSAqIGRldDtcbiAgICAgICAgICAgIG91dFs1XSA9IChhYiAqIGF0eCAtIGFhICogYXR5KSAqIGRldDtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBtYXRyaXg7XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9ob21lL3l4L34venJlbmRlci9saWIvY29yZS9tYXRyaXguanNcbi8vIG1vZHVsZSBpZCA9IDE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 19 */
/* unknown exports provided */
/* all exports used */
/*!********************************************!*\
  !*** /home/yx/~/zrender/lib/core/curve.js ***!
  \********************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * 曲线辅助模块\n * @module zrender/core/curve\n * @author pissang(https://www.github.com/pissang)\n */\n\n\n    var vec2 = __webpack_require__(/*! ./vector */ 4);\n    var v2Create = vec2.create;\n    var v2DistSquare = vec2.distSquare;\n    var mathPow = Math.pow;\n    var mathSqrt = Math.sqrt;\n\n    var EPSILON = 1e-8;\n    var EPSILON_NUMERIC = 1e-4;\n\n    var THREE_SQRT = mathSqrt(3);\n    var ONE_THIRD = 1 / 3;\n\n    // 临时变量\n    var _v0 = v2Create();\n    var _v1 = v2Create();\n    var _v2 = v2Create();\n    // var _v3 = vec2.create();\n\n    function isAroundZero(val) {\n        return val > -EPSILON && val < EPSILON;\n    }\n    function isNotAroundZero(val) {\n        return val > EPSILON || val < -EPSILON;\n    }\n    /**\n     * 计算三次贝塞尔值\n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @return {number}\n     */\n    function cubicAt(p0, p1, p2, p3, t) {\n        var onet = 1 - t;\n        return onet * onet * (onet * p0 + 3 * t * p1)\n             + t * t * (t * p3 + 3 * onet * p2);\n    }\n\n    /**\n     * 计算三次贝塞尔导数值\n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @return {number}\n     */\n    function cubicDerivativeAt(p0, p1, p2, p3, t) {\n        var onet = 1 - t;\n        return 3 * (\n            ((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet\n            + (p3 - p2) * t * t\n        );\n    }\n\n    /**\n     * 计算三次贝塞尔方程根，使用盛金公式\n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} val\n     * @param  {Array.<number>} roots\n     * @return {number} 有效根数目\n     */\n    function cubicRootAt(p0, p1, p2, p3, val, roots) {\n        // Evaluate roots of cubic functions\n        var a = p3 + 3 * (p1 - p2) - p0;\n        var b = 3 * (p2 - p1 * 2 + p0);\n        var c = 3 * (p1  - p0);\n        var d = p0 - val;\n\n        var A = b * b - 3 * a * c;\n        var B = b * c - 9 * a * d;\n        var C = c * c - 3 * b * d;\n\n        var n = 0;\n\n        if (isAroundZero(A) && isAroundZero(B)) {\n            if (isAroundZero(b)) {\n                roots[0] = 0;\n            }\n            else {\n                var t1 = -c / b;  //t1, t2, t3, b is not zero\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n        }\n        else {\n            var disc = B * B - 4 * A * C;\n\n            if (isAroundZero(disc)) {\n                var K = B / A;\n                var t1 = -b / a + K;  // t1, a is not zero\n                var t2 = -K / 2;  // t2, t3\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    roots[n++] = t2;\n                }\n            }\n            else if (disc > 0) {\n                var discSqrt = mathSqrt(disc);\n                var Y1 = A * b + 1.5 * a * (-B + discSqrt);\n                var Y2 = A * b + 1.5 * a * (-B - discSqrt);\n                if (Y1 < 0) {\n                    Y1 = -mathPow(-Y1, ONE_THIRD);\n                }\n                else {\n                    Y1 = mathPow(Y1, ONE_THIRD);\n                }\n                if (Y2 < 0) {\n                    Y2 = -mathPow(-Y2, ONE_THIRD);\n                }\n                else {\n                    Y2 = mathPow(Y2, ONE_THIRD);\n                }\n                var t1 = (-b - (Y1 + Y2)) / (3 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n            else {\n                var T = (2 * A * b - 3 * a * B) / (2 * mathSqrt(A * A * A));\n                var theta = Math.acos(T) / 3;\n                var ASqrt = mathSqrt(A);\n                var tmp = Math.cos(theta);\n\n                var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);\n                var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);\n                var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    roots[n++] = t2;\n                }\n                if (t3 >= 0 && t3 <= 1) {\n                    roots[n++] = t3;\n                }\n            }\n        }\n        return n;\n    }\n\n    /**\n     * 计算三次贝塞尔方程极限值的位置\n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {Array.<number>} extrema\n     * @return {number} 有效数目\n     */\n    function cubicExtrema(p0, p1, p2, p3, extrema) {\n        var b = 6 * p2 - 12 * p1 + 6 * p0;\n        var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;\n        var c = 3 * p1 - 3 * p0;\n\n        var n = 0;\n        if (isAroundZero(a)) {\n            if (isNotAroundZero(b)) {\n                var t1 = -c / b;\n                if (t1 >= 0 && t1 <=1) {\n                    extrema[n++] = t1;\n                }\n            }\n        }\n        else {\n            var disc = b * b - 4 * a * c;\n            if (isAroundZero(disc)) {\n                extrema[0] = -b / (2 * a);\n            }\n            else if (disc > 0) {\n                var discSqrt = mathSqrt(disc);\n                var t1 = (-b + discSqrt) / (2 * a);\n                var t2 = (-b - discSqrt) / (2 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    extrema[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    extrema[n++] = t2;\n                }\n            }\n        }\n        return n;\n    }\n\n    /**\n     * 细分三次贝塞尔曲线\n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @param  {Array.<number>} out\n     */\n    function cubicSubdivide(p0, p1, p2, p3, t, out) {\n        var p01 = (p1 - p0) * t + p0;\n        var p12 = (p2 - p1) * t + p1;\n        var p23 = (p3 - p2) * t + p2;\n\n        var p012 = (p12 - p01) * t + p01;\n        var p123 = (p23 - p12) * t + p12;\n\n        var p0123 = (p123 - p012) * t + p012;\n        // Seg0\n        out[0] = p0;\n        out[1] = p01;\n        out[2] = p012;\n        out[3] = p0123;\n        // Seg1\n        out[4] = p0123;\n        out[5] = p123;\n        out[6] = p23;\n        out[7] = p3;\n    }\n\n    /**\n     * 投射点到三次贝塞尔曲线上，返回投射距离。\n     * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {number} x3\n     * @param {number} y3\n     * @param {number} x\n     * @param {number} y\n     * @param {Array.<number>} [out] 投射点\n     * @return {number}\n     */\n    function cubicProjectPoint(\n        x0, y0, x1, y1, x2, y2, x3, y3,\n        x, y, out\n    ) {\n        // http://pomax.github.io/bezierinfo/#projections\n        var t;\n        var interval = 0.005;\n        var d = Infinity;\n        var prev;\n        var next;\n        var d1;\n        var d2;\n\n        _v0[0] = x;\n        _v0[1] = y;\n\n        // 先粗略估计一下可能的最小距离的 t 值\n        // PENDING\n        for (var _t = 0; _t < 1; _t += 0.05) {\n            _v1[0] = cubicAt(x0, x1, x2, x3, _t);\n            _v1[1] = cubicAt(y0, y1, y2, y3, _t);\n            d1 = v2DistSquare(_v0, _v1);\n            if (d1 < d) {\n                t = _t;\n                d = d1;\n            }\n        }\n        d = Infinity;\n\n        // At most 32 iteration\n        for (var i = 0; i < 32; i++) {\n            if (interval < EPSILON_NUMERIC) {\n                break;\n            }\n            prev = t - interval;\n            next = t + interval;\n            // t - interval\n            _v1[0] = cubicAt(x0, x1, x2, x3, prev);\n            _v1[1] = cubicAt(y0, y1, y2, y3, prev);\n\n            d1 = v2DistSquare(_v1, _v0);\n\n            if (prev >= 0 && d1 < d) {\n                t = prev;\n                d = d1;\n            }\n            else {\n                // t + interval\n                _v2[0] = cubicAt(x0, x1, x2, x3, next);\n                _v2[1] = cubicAt(y0, y1, y2, y3, next);\n                d2 = v2DistSquare(_v2, _v0);\n\n                if (next <= 1 && d2 < d) {\n                    t = next;\n                    d = d2;\n                }\n                else {\n                    interval *= 0.5;\n                }\n            }\n        }\n        // t\n        if (out) {\n            out[0] = cubicAt(x0, x1, x2, x3, t);\n            out[1] = cubicAt(y0, y1, y2, y3, t);\n        }\n        // console.log(interval, i);\n        return mathSqrt(d);\n    }\n\n    /**\n     * 计算二次方贝塞尔值\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @return {number}\n     */\n    function quadraticAt(p0, p1, p2, t) {\n        var onet = 1 - t;\n        return onet * (onet * p0 + 2 * t * p1) + t * t * p2;\n    }\n\n    /**\n     * 计算二次方贝塞尔导数值\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @return {number}\n     */\n    function quadraticDerivativeAt(p0, p1, p2, t) {\n        return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));\n    }\n\n    /**\n     * 计算二次方贝塞尔方程根\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @param  {Array.<number>} roots\n     * @return {number} 有效根数目\n     */\n    function quadraticRootAt(p0, p1, p2, val, roots) {\n        var a = p0 - 2 * p1 + p2;\n        var b = 2 * (p1 - p0);\n        var c = p0 - val;\n\n        var n = 0;\n        if (isAroundZero(a)) {\n            if (isNotAroundZero(b)) {\n                var t1 = -c / b;\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n        }\n        else {\n            var disc = b * b - 4 * a * c;\n            if (isAroundZero(disc)) {\n                var t1 = -b / (2 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n            else if (disc > 0) {\n                var discSqrt = mathSqrt(disc);\n                var t1 = (-b + discSqrt) / (2 * a);\n                var t2 = (-b - discSqrt) / (2 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    roots[n++] = t2;\n                }\n            }\n        }\n        return n;\n    }\n\n    /**\n     * 计算二次贝塞尔方程极限值\n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @return {number}\n     */\n    function quadraticExtremum(p0, p1, p2) {\n        var divider = p0 + p2 - 2 * p1;\n        if (divider === 0) {\n            // p1 is center of p0 and p2\n            return 0.5;\n        }\n        else {\n            return (p0 - p1) / divider;\n        }\n    }\n\n    /**\n     * 细分二次贝塞尔曲线\n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @param  {Array.<number>} out\n     */\n    function quadraticSubdivide(p0, p1, p2, t, out) {\n        var p01 = (p1 - p0) * t + p0;\n        var p12 = (p2 - p1) * t + p1;\n        var p012 = (p12 - p01) * t + p01;\n\n        // Seg0\n        out[0] = p0;\n        out[1] = p01;\n        out[2] = p012;\n\n        // Seg1\n        out[3] = p012;\n        out[4] = p12;\n        out[5] = p2;\n    }\n\n    /**\n     * 投射点到二次贝塞尔曲线上，返回投射距离。\n     * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {number} x\n     * @param {number} y\n     * @param {Array.<number>} out 投射点\n     * @return {number}\n     */\n    function quadraticProjectPoint(\n        x0, y0, x1, y1, x2, y2,\n        x, y, out\n    ) {\n        // http://pomax.github.io/bezierinfo/#projections\n        var t;\n        var interval = 0.005;\n        var d = Infinity;\n\n        _v0[0] = x;\n        _v0[1] = y;\n\n        // 先粗略估计一下可能的最小距离的 t 值\n        // PENDING\n        for (var _t = 0; _t < 1; _t += 0.05) {\n            _v1[0] = quadraticAt(x0, x1, x2, _t);\n            _v1[1] = quadraticAt(y0, y1, y2, _t);\n            var d1 = v2DistSquare(_v0, _v1);\n            if (d1 < d) {\n                t = _t;\n                d = d1;\n            }\n        }\n        d = Infinity;\n\n        // At most 32 iteration\n        for (var i = 0; i < 32; i++) {\n            if (interval < EPSILON_NUMERIC) {\n                break;\n            }\n            var prev = t - interval;\n            var next = t + interval;\n            // t - interval\n            _v1[0] = quadraticAt(x0, x1, x2, prev);\n            _v1[1] = quadraticAt(y0, y1, y2, prev);\n\n            var d1 = v2DistSquare(_v1, _v0);\n\n            if (prev >= 0 && d1 < d) {\n                t = prev;\n                d = d1;\n            }\n            else {\n                // t + interval\n                _v2[0] = quadraticAt(x0, x1, x2, next);\n                _v2[1] = quadraticAt(y0, y1, y2, next);\n                var d2 = v2DistSquare(_v2, _v0);\n                if (next <= 1 && d2 < d) {\n                    t = next;\n                    d = d2;\n                }\n                else {\n                    interval *= 0.5;\n                }\n            }\n        }\n        // t\n        if (out) {\n            out[0] = quadraticAt(x0, x1, x2, t);\n            out[1] = quadraticAt(y0, y1, y2, t);\n        }\n        // console.log(interval, i);\n        return mathSqrt(d);\n    }\n\n    module.exports = {\n\n        cubicAt: cubicAt,\n\n        cubicDerivativeAt: cubicDerivativeAt,\n\n        cubicRootAt: cubicRootAt,\n\n        cubicExtrema: cubicExtrema,\n\n        cubicSubdivide: cubicSubdivide,\n\n        cubicProjectPoint: cubicProjectPoint,\n\n        quadraticAt: quadraticAt,\n\n        quadraticDerivativeAt: quadraticDerivativeAt,\n\n        quadraticRootAt: quadraticRootAt,\n\n        quadraticExtremum: quadraticExtremum,\n\n        quadraticSubdivide: quadraticSubdivide,\n\n        quadraticProjectPoint: quadraticProjectPoint\n    };\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL2hvbWUveXgvfi96cmVuZGVyL2xpYi9jb3JlL2N1cnZlLmpzPzhjZGUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuLyoqXG4gKiDmm7Lnur/ovoXliqnmqKHlnZdcbiAqIEBtb2R1bGUgenJlbmRlci9jb3JlL2N1cnZlXG4gKiBAYXV0aG9yIHBpc3NhbmcoaHR0cHM6Ly93d3cuZ2l0aHViLmNvbS9waXNzYW5nKVxuICovXG5cblxuICAgIHZhciB2ZWMyID0gcmVxdWlyZSgnLi92ZWN0b3InKTtcbiAgICB2YXIgdjJDcmVhdGUgPSB2ZWMyLmNyZWF0ZTtcbiAgICB2YXIgdjJEaXN0U3F1YXJlID0gdmVjMi5kaXN0U3F1YXJlO1xuICAgIHZhciBtYXRoUG93ID0gTWF0aC5wb3c7XG4gICAgdmFyIG1hdGhTcXJ0ID0gTWF0aC5zcXJ0O1xuXG4gICAgdmFyIEVQU0lMT04gPSAxZS04O1xuICAgIHZhciBFUFNJTE9OX05VTUVSSUMgPSAxZS00O1xuXG4gICAgdmFyIFRIUkVFX1NRUlQgPSBtYXRoU3FydCgzKTtcbiAgICB2YXIgT05FX1RISVJEID0gMSAvIDM7XG5cbiAgICAvLyDkuLTml7blj5jph49cbiAgICB2YXIgX3YwID0gdjJDcmVhdGUoKTtcbiAgICB2YXIgX3YxID0gdjJDcmVhdGUoKTtcbiAgICB2YXIgX3YyID0gdjJDcmVhdGUoKTtcbiAgICAvLyB2YXIgX3YzID0gdmVjMi5jcmVhdGUoKTtcblxuICAgIGZ1bmN0aW9uIGlzQXJvdW5kWmVybyh2YWwpIHtcbiAgICAgICAgcmV0dXJuIHZhbCA+IC1FUFNJTE9OICYmIHZhbCA8IEVQU0lMT047XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzTm90QXJvdW5kWmVybyh2YWwpIHtcbiAgICAgICAgcmV0dXJuIHZhbCA+IEVQU0lMT04gfHwgdmFsIDwgLUVQU0lMT047XG4gICAgfVxuICAgIC8qKlxuICAgICAqIOiuoeeul+S4ieasoei0neWhnuWwlOWAvFxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL2N1cnZlXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAyXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwM1xuICAgICAqIEBwYXJhbSAge251bWJlcn0gdFxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjdWJpY0F0KHAwLCBwMSwgcDIsIHAzLCB0KSB7XG4gICAgICAgIHZhciBvbmV0ID0gMSAtIHQ7XG4gICAgICAgIHJldHVybiBvbmV0ICogb25ldCAqIChvbmV0ICogcDAgKyAzICogdCAqIHAxKVxuICAgICAgICAgICAgICsgdCAqIHQgKiAodCAqIHAzICsgMyAqIG9uZXQgKiBwMik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog6K6h566X5LiJ5qyh6LSd5aGe5bCU5a+85pWw5YC8XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvY3VydmVcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDJcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAzXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSB0XG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGN1YmljRGVyaXZhdGl2ZUF0KHAwLCBwMSwgcDIsIHAzLCB0KSB7XG4gICAgICAgIHZhciBvbmV0ID0gMSAtIHQ7XG4gICAgICAgIHJldHVybiAzICogKFxuICAgICAgICAgICAgKChwMSAtIHAwKSAqIG9uZXQgKyAyICogKHAyIC0gcDEpICogdCkgKiBvbmV0XG4gICAgICAgICAgICArIChwMyAtIHAyKSAqIHQgKiB0XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog6K6h566X5LiJ5qyh6LSd5aGe5bCU5pa556iL5qC577yM5L2/55So55ub6YeR5YWs5byPXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvY3VydmVcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDJcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAzXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSB2YWxcbiAgICAgKiBAcGFyYW0gIHtBcnJheS48bnVtYmVyPn0gcm9vdHNcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IOacieaViOagueaVsOebrlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGN1YmljUm9vdEF0KHAwLCBwMSwgcDIsIHAzLCB2YWwsIHJvb3RzKSB7XG4gICAgICAgIC8vIEV2YWx1YXRlIHJvb3RzIG9mIGN1YmljIGZ1bmN0aW9uc1xuICAgICAgICB2YXIgYSA9IHAzICsgMyAqIChwMSAtIHAyKSAtIHAwO1xuICAgICAgICB2YXIgYiA9IDMgKiAocDIgLSBwMSAqIDIgKyBwMCk7XG4gICAgICAgIHZhciBjID0gMyAqIChwMSAgLSBwMCk7XG4gICAgICAgIHZhciBkID0gcDAgLSB2YWw7XG5cbiAgICAgICAgdmFyIEEgPSBiICogYiAtIDMgKiBhICogYztcbiAgICAgICAgdmFyIEIgPSBiICogYyAtIDkgKiBhICogZDtcbiAgICAgICAgdmFyIEMgPSBjICogYyAtIDMgKiBiICogZDtcblxuICAgICAgICB2YXIgbiA9IDA7XG5cbiAgICAgICAgaWYgKGlzQXJvdW5kWmVybyhBKSAmJiBpc0Fyb3VuZFplcm8oQikpIHtcbiAgICAgICAgICAgIGlmIChpc0Fyb3VuZFplcm8oYikpIHtcbiAgICAgICAgICAgICAgICByb290c1swXSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgdDEgPSAtYyAvIGI7ICAvL3QxLCB0MiwgdDMsIGIgaXMgbm90IHplcm9cbiAgICAgICAgICAgICAgICBpZiAodDEgPj0gMCAmJiB0MSA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3RzW24rK10gPSB0MTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgZGlzYyA9IEIgKiBCIC0gNCAqIEEgKiBDO1xuXG4gICAgICAgICAgICBpZiAoaXNBcm91bmRaZXJvKGRpc2MpKSB7XG4gICAgICAgICAgICAgICAgdmFyIEsgPSBCIC8gQTtcbiAgICAgICAgICAgICAgICB2YXIgdDEgPSAtYiAvIGEgKyBLOyAgLy8gdDEsIGEgaXMgbm90IHplcm9cbiAgICAgICAgICAgICAgICB2YXIgdDIgPSAtSyAvIDI7ICAvLyB0MiwgdDNcbiAgICAgICAgICAgICAgICBpZiAodDEgPj0gMCAmJiB0MSA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3RzW24rK10gPSB0MTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHQyID49IDAgJiYgdDIgPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICByb290c1tuKytdID0gdDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGlzYyA+IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgZGlzY1NxcnQgPSBtYXRoU3FydChkaXNjKTtcbiAgICAgICAgICAgICAgICB2YXIgWTEgPSBBICogYiArIDEuNSAqIGEgKiAoLUIgKyBkaXNjU3FydCk7XG4gICAgICAgICAgICAgICAgdmFyIFkyID0gQSAqIGIgKyAxLjUgKiBhICogKC1CIC0gZGlzY1NxcnQpO1xuICAgICAgICAgICAgICAgIGlmIChZMSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgWTEgPSAtbWF0aFBvdygtWTEsIE9ORV9USElSRCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBZMSA9IG1hdGhQb3coWTEsIE9ORV9USElSRCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChZMiA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgWTIgPSAtbWF0aFBvdygtWTIsIE9ORV9USElSRCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBZMiA9IG1hdGhQb3coWTIsIE9ORV9USElSRCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciB0MSA9ICgtYiAtIChZMSArIFkyKSkgLyAoMyAqIGEpO1xuICAgICAgICAgICAgICAgIGlmICh0MSA+PSAwICYmIHQxIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcm9vdHNbbisrXSA9IHQxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBUID0gKDIgKiBBICogYiAtIDMgKiBhICogQikgLyAoMiAqIG1hdGhTcXJ0KEEgKiBBICogQSkpO1xuICAgICAgICAgICAgICAgIHZhciB0aGV0YSA9IE1hdGguYWNvcyhUKSAvIDM7XG4gICAgICAgICAgICAgICAgdmFyIEFTcXJ0ID0gbWF0aFNxcnQoQSk7XG4gICAgICAgICAgICAgICAgdmFyIHRtcCA9IE1hdGguY29zKHRoZXRhKTtcblxuICAgICAgICAgICAgICAgIHZhciB0MSA9ICgtYiAtIDIgKiBBU3FydCAqIHRtcCkgLyAoMyAqIGEpO1xuICAgICAgICAgICAgICAgIHZhciB0MiA9ICgtYiArIEFTcXJ0ICogKHRtcCArIFRIUkVFX1NRUlQgKiBNYXRoLnNpbih0aGV0YSkpKSAvICgzICogYSk7XG4gICAgICAgICAgICAgICAgdmFyIHQzID0gKC1iICsgQVNxcnQgKiAodG1wIC0gVEhSRUVfU1FSVCAqIE1hdGguc2luKHRoZXRhKSkpIC8gKDMgKiBhKTtcbiAgICAgICAgICAgICAgICBpZiAodDEgPj0gMCAmJiB0MSA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3RzW24rK10gPSB0MTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHQyID49IDAgJiYgdDIgPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICByb290c1tuKytdID0gdDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0MyA+PSAwICYmIHQzIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcm9vdHNbbisrXSA9IHQzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDorqHnrpfkuInmrKHotJ3loZ7lsJTmlrnnqIvmnoHpmZDlgLznmoTkvY3nva5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9jdXJ2ZVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDBcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAxXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMlxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDNcbiAgICAgKiBAcGFyYW0gIHtBcnJheS48bnVtYmVyPn0gZXh0cmVtYVxuICAgICAqIEByZXR1cm4ge251bWJlcn0g5pyJ5pWI5pWw55uuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3ViaWNFeHRyZW1hKHAwLCBwMSwgcDIsIHAzLCBleHRyZW1hKSB7XG4gICAgICAgIHZhciBiID0gNiAqIHAyIC0gMTIgKiBwMSArIDYgKiBwMDtcbiAgICAgICAgdmFyIGEgPSA5ICogcDEgKyAzICogcDMgLSAzICogcDAgLSA5ICogcDI7XG4gICAgICAgIHZhciBjID0gMyAqIHAxIC0gMyAqIHAwO1xuXG4gICAgICAgIHZhciBuID0gMDtcbiAgICAgICAgaWYgKGlzQXJvdW5kWmVybyhhKSkge1xuICAgICAgICAgICAgaWYgKGlzTm90QXJvdW5kWmVybyhiKSkge1xuICAgICAgICAgICAgICAgIHZhciB0MSA9IC1jIC8gYjtcbiAgICAgICAgICAgICAgICBpZiAodDEgPj0gMCAmJiB0MSA8PTEpIHtcbiAgICAgICAgICAgICAgICAgICAgZXh0cmVtYVtuKytdID0gdDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGRpc2MgPSBiICogYiAtIDQgKiBhICogYztcbiAgICAgICAgICAgIGlmIChpc0Fyb3VuZFplcm8oZGlzYykpIHtcbiAgICAgICAgICAgICAgICBleHRyZW1hWzBdID0gLWIgLyAoMiAqIGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGlzYyA+IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgZGlzY1NxcnQgPSBtYXRoU3FydChkaXNjKTtcbiAgICAgICAgICAgICAgICB2YXIgdDEgPSAoLWIgKyBkaXNjU3FydCkgLyAoMiAqIGEpO1xuICAgICAgICAgICAgICAgIHZhciB0MiA9ICgtYiAtIGRpc2NTcXJ0KSAvICgyICogYSk7XG4gICAgICAgICAgICAgICAgaWYgKHQxID49IDAgJiYgdDEgPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICBleHRyZW1hW24rK10gPSB0MTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHQyID49IDAgJiYgdDIgPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICBleHRyZW1hW24rK10gPSB0MjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG47XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog57uG5YiG5LiJ5qyh6LSd5aGe5bCU5puy57q/XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvY3VydmVcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDJcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAzXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSB0XG4gICAgICogQHBhcmFtICB7QXJyYXkuPG51bWJlcj59IG91dFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGN1YmljU3ViZGl2aWRlKHAwLCBwMSwgcDIsIHAzLCB0LCBvdXQpIHtcbiAgICAgICAgdmFyIHAwMSA9IChwMSAtIHAwKSAqIHQgKyBwMDtcbiAgICAgICAgdmFyIHAxMiA9IChwMiAtIHAxKSAqIHQgKyBwMTtcbiAgICAgICAgdmFyIHAyMyA9IChwMyAtIHAyKSAqIHQgKyBwMjtcblxuICAgICAgICB2YXIgcDAxMiA9IChwMTIgLSBwMDEpICogdCArIHAwMTtcbiAgICAgICAgdmFyIHAxMjMgPSAocDIzIC0gcDEyKSAqIHQgKyBwMTI7XG5cbiAgICAgICAgdmFyIHAwMTIzID0gKHAxMjMgLSBwMDEyKSAqIHQgKyBwMDEyO1xuICAgICAgICAvLyBTZWcwXG4gICAgICAgIG91dFswXSA9IHAwO1xuICAgICAgICBvdXRbMV0gPSBwMDE7XG4gICAgICAgIG91dFsyXSA9IHAwMTI7XG4gICAgICAgIG91dFszXSA9IHAwMTIzO1xuICAgICAgICAvLyBTZWcxXG4gICAgICAgIG91dFs0XSA9IHAwMTIzO1xuICAgICAgICBvdXRbNV0gPSBwMTIzO1xuICAgICAgICBvdXRbNl0gPSBwMjM7XG4gICAgICAgIG91dFs3XSA9IHAzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOaKleWwhOeCueWIsOS4ieasoei0neWhnuWwlOabsue6v+S4iu+8jOi/lOWbnuaKleWwhOi3neemu+OAglxuICAgICAqIOaKleWwhOeCueacieWPr+iDveS8muacieS4gOS4quaIluiAheWkmuS4qu+8jOi/memHjOWPqui/lOWbnuWFtuS4rei3neemu+acgOefreeahOS4gOS4quOAglxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4M1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5M1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBbb3V0XSDmipXlsITngrlcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgZnVuY3Rpb24gY3ViaWNQcm9qZWN0UG9pbnQoXG4gICAgICAgIHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5MyxcbiAgICAgICAgeCwgeSwgb3V0XG4gICAgKSB7XG4gICAgICAgIC8vIGh0dHA6Ly9wb21heC5naXRodWIuaW8vYmV6aWVyaW5mby8jcHJvamVjdGlvbnNcbiAgICAgICAgdmFyIHQ7XG4gICAgICAgIHZhciBpbnRlcnZhbCA9IDAuMDA1O1xuICAgICAgICB2YXIgZCA9IEluZmluaXR5O1xuICAgICAgICB2YXIgcHJldjtcbiAgICAgICAgdmFyIG5leHQ7XG4gICAgICAgIHZhciBkMTtcbiAgICAgICAgdmFyIGQyO1xuXG4gICAgICAgIF92MFswXSA9IHg7XG4gICAgICAgIF92MFsxXSA9IHk7XG5cbiAgICAgICAgLy8g5YWI57KX55Wl5Lyw6K6h5LiA5LiL5Y+v6IO955qE5pyA5bCP6Led56a755qEIHQg5YC8XG4gICAgICAgIC8vIFBFTkRJTkdcbiAgICAgICAgZm9yICh2YXIgX3QgPSAwOyBfdCA8IDE7IF90ICs9IDAuMDUpIHtcbiAgICAgICAgICAgIF92MVswXSA9IGN1YmljQXQoeDAsIHgxLCB4MiwgeDMsIF90KTtcbiAgICAgICAgICAgIF92MVsxXSA9IGN1YmljQXQoeTAsIHkxLCB5MiwgeTMsIF90KTtcbiAgICAgICAgICAgIGQxID0gdjJEaXN0U3F1YXJlKF92MCwgX3YxKTtcbiAgICAgICAgICAgIGlmIChkMSA8IGQpIHtcbiAgICAgICAgICAgICAgICB0ID0gX3Q7XG4gICAgICAgICAgICAgICAgZCA9IGQxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGQgPSBJbmZpbml0eTtcblxuICAgICAgICAvLyBBdCBtb3N0IDMyIGl0ZXJhdGlvblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDMyOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpbnRlcnZhbCA8IEVQU0lMT05fTlVNRVJJQykge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJldiA9IHQgLSBpbnRlcnZhbDtcbiAgICAgICAgICAgIG5leHQgPSB0ICsgaW50ZXJ2YWw7XG4gICAgICAgICAgICAvLyB0IC0gaW50ZXJ2YWxcbiAgICAgICAgICAgIF92MVswXSA9IGN1YmljQXQoeDAsIHgxLCB4MiwgeDMsIHByZXYpO1xuICAgICAgICAgICAgX3YxWzFdID0gY3ViaWNBdCh5MCwgeTEsIHkyLCB5MywgcHJldik7XG5cbiAgICAgICAgICAgIGQxID0gdjJEaXN0U3F1YXJlKF92MSwgX3YwKTtcblxuICAgICAgICAgICAgaWYgKHByZXYgPj0gMCAmJiBkMSA8IGQpIHtcbiAgICAgICAgICAgICAgICB0ID0gcHJldjtcbiAgICAgICAgICAgICAgICBkID0gZDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB0ICsgaW50ZXJ2YWxcbiAgICAgICAgICAgICAgICBfdjJbMF0gPSBjdWJpY0F0KHgwLCB4MSwgeDIsIHgzLCBuZXh0KTtcbiAgICAgICAgICAgICAgICBfdjJbMV0gPSBjdWJpY0F0KHkwLCB5MSwgeTIsIHkzLCBuZXh0KTtcbiAgICAgICAgICAgICAgICBkMiA9IHYyRGlzdFNxdWFyZShfdjIsIF92MCk7XG5cbiAgICAgICAgICAgICAgICBpZiAobmV4dCA8PSAxICYmIGQyIDwgZCkge1xuICAgICAgICAgICAgICAgICAgICB0ID0gbmV4dDtcbiAgICAgICAgICAgICAgICAgICAgZCA9IGQyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJ2YWwgKj0gMC41O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyB0XG4gICAgICAgIGlmIChvdXQpIHtcbiAgICAgICAgICAgIG91dFswXSA9IGN1YmljQXQoeDAsIHgxLCB4MiwgeDMsIHQpO1xuICAgICAgICAgICAgb3V0WzFdID0gY3ViaWNBdCh5MCwgeTEsIHkyLCB5MywgdCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29uc29sZS5sb2coaW50ZXJ2YWwsIGkpO1xuICAgICAgICByZXR1cm4gbWF0aFNxcnQoZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog6K6h566X5LqM5qyh5pa56LSd5aGe5bCU5YC8XG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAyXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSB0XG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHF1YWRyYXRpY0F0KHAwLCBwMSwgcDIsIHQpIHtcbiAgICAgICAgdmFyIG9uZXQgPSAxIC0gdDtcbiAgICAgICAgcmV0dXJuIG9uZXQgKiAob25ldCAqIHAwICsgMiAqIHQgKiBwMSkgKyB0ICogdCAqIHAyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOiuoeeul+S6jOasoeaWuei0neWhnuWwlOWvvOaVsOWAvFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDBcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAxXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMlxuICAgICAqIEBwYXJhbSAge251bWJlcn0gdFxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBxdWFkcmF0aWNEZXJpdmF0aXZlQXQocDAsIHAxLCBwMiwgdCkge1xuICAgICAgICByZXR1cm4gMiAqICgoMSAtIHQpICogKHAxIC0gcDApICsgdCAqIChwMiAtIHAxKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog6K6h566X5LqM5qyh5pa56LSd5aGe5bCU5pa556iL5qC5XG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAyXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSB0XG4gICAgICogQHBhcmFtICB7QXJyYXkuPG51bWJlcj59IHJvb3RzXG4gICAgICogQHJldHVybiB7bnVtYmVyfSDmnInmlYjmoLnmlbDnm65cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBxdWFkcmF0aWNSb290QXQocDAsIHAxLCBwMiwgdmFsLCByb290cykge1xuICAgICAgICB2YXIgYSA9IHAwIC0gMiAqIHAxICsgcDI7XG4gICAgICAgIHZhciBiID0gMiAqIChwMSAtIHAwKTtcbiAgICAgICAgdmFyIGMgPSBwMCAtIHZhbDtcblxuICAgICAgICB2YXIgbiA9IDA7XG4gICAgICAgIGlmIChpc0Fyb3VuZFplcm8oYSkpIHtcbiAgICAgICAgICAgIGlmIChpc05vdEFyb3VuZFplcm8oYikpIHtcbiAgICAgICAgICAgICAgICB2YXIgdDEgPSAtYyAvIGI7XG4gICAgICAgICAgICAgICAgaWYgKHQxID49IDAgJiYgdDEgPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICByb290c1tuKytdID0gdDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGRpc2MgPSBiICogYiAtIDQgKiBhICogYztcbiAgICAgICAgICAgIGlmIChpc0Fyb3VuZFplcm8oZGlzYykpIHtcbiAgICAgICAgICAgICAgICB2YXIgdDEgPSAtYiAvICgyICogYSk7XG4gICAgICAgICAgICAgICAgaWYgKHQxID49IDAgJiYgdDEgPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICByb290c1tuKytdID0gdDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGlzYyA+IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgZGlzY1NxcnQgPSBtYXRoU3FydChkaXNjKTtcbiAgICAgICAgICAgICAgICB2YXIgdDEgPSAoLWIgKyBkaXNjU3FydCkgLyAoMiAqIGEpO1xuICAgICAgICAgICAgICAgIHZhciB0MiA9ICgtYiAtIGRpc2NTcXJ0KSAvICgyICogYSk7XG4gICAgICAgICAgICAgICAgaWYgKHQxID49IDAgJiYgdDEgPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICByb290c1tuKytdID0gdDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0MiA+PSAwICYmIHQyIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcm9vdHNbbisrXSA9IHQyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDorqHnrpfkuozmrKHotJ3loZ7lsJTmlrnnqIvmnoHpmZDlgLxcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9jdXJ2ZVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDBcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAxXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMlxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBxdWFkcmF0aWNFeHRyZW11bShwMCwgcDEsIHAyKSB7XG4gICAgICAgIHZhciBkaXZpZGVyID0gcDAgKyBwMiAtIDIgKiBwMTtcbiAgICAgICAgaWYgKGRpdmlkZXIgPT09IDApIHtcbiAgICAgICAgICAgIC8vIHAxIGlzIGNlbnRlciBvZiBwMCBhbmQgcDJcbiAgICAgICAgICAgIHJldHVybiAwLjU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gKHAwIC0gcDEpIC8gZGl2aWRlcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOe7huWIhuS6jOasoei0neWhnuWwlOabsue6v1xuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL2N1cnZlXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAyXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSB0XG4gICAgICogQHBhcmFtICB7QXJyYXkuPG51bWJlcj59IG91dFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHF1YWRyYXRpY1N1YmRpdmlkZShwMCwgcDEsIHAyLCB0LCBvdXQpIHtcbiAgICAgICAgdmFyIHAwMSA9IChwMSAtIHAwKSAqIHQgKyBwMDtcbiAgICAgICAgdmFyIHAxMiA9IChwMiAtIHAxKSAqIHQgKyBwMTtcbiAgICAgICAgdmFyIHAwMTIgPSAocDEyIC0gcDAxKSAqIHQgKyBwMDE7XG5cbiAgICAgICAgLy8gU2VnMFxuICAgICAgICBvdXRbMF0gPSBwMDtcbiAgICAgICAgb3V0WzFdID0gcDAxO1xuICAgICAgICBvdXRbMl0gPSBwMDEyO1xuXG4gICAgICAgIC8vIFNlZzFcbiAgICAgICAgb3V0WzNdID0gcDAxMjtcbiAgICAgICAgb3V0WzRdID0gcDEyO1xuICAgICAgICBvdXRbNV0gPSBwMjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDmipXlsITngrnliLDkuozmrKHotJ3loZ7lsJTmm7Lnur/kuIrvvIzov5Tlm57mipXlsITot53nprvjgIJcbiAgICAgKiDmipXlsITngrnmnInlj6/og73kvJrmnInkuIDkuKrmiJbogIXlpJrkuKrvvIzov5nph4zlj6rov5Tlm57lhbbkuK3ot53nprvmnIDnn63nmoTkuIDkuKrjgIJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geDBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geTBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geDFcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geTFcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geDJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geTJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gb3V0IOaKleWwhOeCuVxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBxdWFkcmF0aWNQcm9qZWN0UG9pbnQoXG4gICAgICAgIHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsXG4gICAgICAgIHgsIHksIG91dFxuICAgICkge1xuICAgICAgICAvLyBodHRwOi8vcG9tYXguZ2l0aHViLmlvL2JlemllcmluZm8vI3Byb2plY3Rpb25zXG4gICAgICAgIHZhciB0O1xuICAgICAgICB2YXIgaW50ZXJ2YWwgPSAwLjAwNTtcbiAgICAgICAgdmFyIGQgPSBJbmZpbml0eTtcblxuICAgICAgICBfdjBbMF0gPSB4O1xuICAgICAgICBfdjBbMV0gPSB5O1xuXG4gICAgICAgIC8vIOWFiOeyl+eVpeS8sOiuoeS4gOS4i+WPr+iDveeahOacgOWwj+i3neemu+eahCB0IOWAvFxuICAgICAgICAvLyBQRU5ESU5HXG4gICAgICAgIGZvciAodmFyIF90ID0gMDsgX3QgPCAxOyBfdCArPSAwLjA1KSB7XG4gICAgICAgICAgICBfdjFbMF0gPSBxdWFkcmF0aWNBdCh4MCwgeDEsIHgyLCBfdCk7XG4gICAgICAgICAgICBfdjFbMV0gPSBxdWFkcmF0aWNBdCh5MCwgeTEsIHkyLCBfdCk7XG4gICAgICAgICAgICB2YXIgZDEgPSB2MkRpc3RTcXVhcmUoX3YwLCBfdjEpO1xuICAgICAgICAgICAgaWYgKGQxIDwgZCkge1xuICAgICAgICAgICAgICAgIHQgPSBfdDtcbiAgICAgICAgICAgICAgICBkID0gZDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZCA9IEluZmluaXR5O1xuXG4gICAgICAgIC8vIEF0IG1vc3QgMzIgaXRlcmF0aW9uXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzI7IGkrKykge1xuICAgICAgICAgICAgaWYgKGludGVydmFsIDwgRVBTSUxPTl9OVU1FUklDKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcHJldiA9IHQgLSBpbnRlcnZhbDtcbiAgICAgICAgICAgIHZhciBuZXh0ID0gdCArIGludGVydmFsO1xuICAgICAgICAgICAgLy8gdCAtIGludGVydmFsXG4gICAgICAgICAgICBfdjFbMF0gPSBxdWFkcmF0aWNBdCh4MCwgeDEsIHgyLCBwcmV2KTtcbiAgICAgICAgICAgIF92MVsxXSA9IHF1YWRyYXRpY0F0KHkwLCB5MSwgeTIsIHByZXYpO1xuXG4gICAgICAgICAgICB2YXIgZDEgPSB2MkRpc3RTcXVhcmUoX3YxLCBfdjApO1xuXG4gICAgICAgICAgICBpZiAocHJldiA+PSAwICYmIGQxIDwgZCkge1xuICAgICAgICAgICAgICAgIHQgPSBwcmV2O1xuICAgICAgICAgICAgICAgIGQgPSBkMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHQgKyBpbnRlcnZhbFxuICAgICAgICAgICAgICAgIF92MlswXSA9IHF1YWRyYXRpY0F0KHgwLCB4MSwgeDIsIG5leHQpO1xuICAgICAgICAgICAgICAgIF92MlsxXSA9IHF1YWRyYXRpY0F0KHkwLCB5MSwgeTIsIG5leHQpO1xuICAgICAgICAgICAgICAgIHZhciBkMiA9IHYyRGlzdFNxdWFyZShfdjIsIF92MCk7XG4gICAgICAgICAgICAgICAgaWYgKG5leHQgPD0gMSAmJiBkMiA8IGQpIHtcbiAgICAgICAgICAgICAgICAgICAgdCA9IG5leHQ7XG4gICAgICAgICAgICAgICAgICAgIGQgPSBkMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGludGVydmFsICo9IDAuNTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gdFxuICAgICAgICBpZiAob3V0KSB7XG4gICAgICAgICAgICBvdXRbMF0gPSBxdWFkcmF0aWNBdCh4MCwgeDEsIHgyLCB0KTtcbiAgICAgICAgICAgIG91dFsxXSA9IHF1YWRyYXRpY0F0KHkwLCB5MSwgeTIsIHQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGludGVydmFsLCBpKTtcbiAgICAgICAgcmV0dXJuIG1hdGhTcXJ0KGQpO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuXG4gICAgICAgIGN1YmljQXQ6IGN1YmljQXQsXG5cbiAgICAgICAgY3ViaWNEZXJpdmF0aXZlQXQ6IGN1YmljRGVyaXZhdGl2ZUF0LFxuXG4gICAgICAgIGN1YmljUm9vdEF0OiBjdWJpY1Jvb3RBdCxcblxuICAgICAgICBjdWJpY0V4dHJlbWE6IGN1YmljRXh0cmVtYSxcblxuICAgICAgICBjdWJpY1N1YmRpdmlkZTogY3ViaWNTdWJkaXZpZGUsXG5cbiAgICAgICAgY3ViaWNQcm9qZWN0UG9pbnQ6IGN1YmljUHJvamVjdFBvaW50LFxuXG4gICAgICAgIHF1YWRyYXRpY0F0OiBxdWFkcmF0aWNBdCxcblxuICAgICAgICBxdWFkcmF0aWNEZXJpdmF0aXZlQXQ6IHF1YWRyYXRpY0Rlcml2YXRpdmVBdCxcblxuICAgICAgICBxdWFkcmF0aWNSb290QXQ6IHF1YWRyYXRpY1Jvb3RBdCxcblxuICAgICAgICBxdWFkcmF0aWNFeHRyZW11bTogcXVhZHJhdGljRXh0cmVtdW0sXG5cbiAgICAgICAgcXVhZHJhdGljU3ViZGl2aWRlOiBxdWFkcmF0aWNTdWJkaXZpZGUsXG5cbiAgICAgICAgcXVhZHJhdGljUHJvamVjdFBvaW50OiBxdWFkcmF0aWNQcm9qZWN0UG9pbnRcbiAgICB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2hvbWUveXgvfi96cmVuZGVyL2xpYi9jb3JlL2N1cnZlLmpzXG4vLyBtb2R1bGUgaWQgPSAxOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 20 */
/* unknown exports provided */
/* all exports used */
/*!********************************************!*\
  !*** /home/yx/~/zrender/lib/core/event.js ***!
  \********************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * 事件辅助类\n * @module zrender/core/event\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n */\n\n\n    var Eventful = __webpack_require__(/*! ../mixin/Eventful */ 22);\n    var env = __webpack_require__(/*! ./env */ 8);\n\n    var isDomLevel2 = (typeof window !== 'undefined') && !!window.addEventListener;\n\n    function getBoundingClientRect(el) {\n        // BlackBerry 5, iOS 3 (original iPhone) don't have getBoundingRect\n        return el.getBoundingClientRect ? el.getBoundingClientRect() : {left: 0, top: 0};\n    }\n\n    // `calculate` is optional, default false\n    function clientToLocal(el, e, out, calculate) {\n        out = out || {};\n\n        // According to the W3C Working Draft, offsetX and offsetY should be relative\n        // to the padding edge of the target element. The only browser using this convention\n        // is IE. Webkit uses the border edge, Opera uses the content edge, and FireFox does\n        // not support the properties.\n        // (see http://www.jacklmoore.com/notes/mouse-position/)\n        // In zr painter.dom, padding edge equals to border edge.\n\n        // FIXME\n        // When mousemove event triggered on ec tooltip, target is not zr painter.dom, and\n        // offsetX/Y is relative to e.target, where the calculation of zrX/Y via offsetX/Y\n        // is too complex. So css-transfrom dont support in this case temporarily.\n        if (calculate || !env.canvasSupported) {\n            defaultGetZrXY(el, e, out);\n        }\n        // Caution: In FireFox, layerX/layerY Mouse position relative to the closest positioned\n        // ancestor element, so we should make sure el is positioned (e.g., not position:static).\n        // BTW1, Webkit don't return the same results as FF in non-simple cases (like add\n        // zoom-factor, overflow / opacity layers, transforms ...)\n        // BTW2, (ev.offsetY || ev.pageY - $(ev.target).offset().top) is not correct in preserve-3d.\n        // <https://bugs.jquery.com/ticket/8523#comment:14>\n        // BTW3, In ff, offsetX/offsetY is always 0.\n        else if (env.browser.firefox && e.layerX != null && e.layerX !== e.offsetX) {\n            out.zrX = e.layerX;\n            out.zrY = e.layerY;\n        }\n        // For IE6+, chrome, safari, opera. (When will ff support offsetX?)\n        else if (e.offsetX != null) {\n            out.zrX = e.offsetX;\n            out.zrY = e.offsetY;\n        }\n        // For some other device, e.g., IOS safari.\n        else {\n            defaultGetZrXY(el, e, out);\n        }\n\n        return out;\n    }\n\n    function defaultGetZrXY(el, e, out) {\n        // This well-known method below does not support css transform.\n        var box = getBoundingClientRect(el);\n        out.zrX = e.clientX - box.left;\n        out.zrY = e.clientY - box.top;\n    }\n\n    /**\n     * 如果存在第三方嵌入的一些dom触发的事件，或touch事件，需要转换一下事件坐标.\n     * `calculate` is optional, default false.\n     */\n    function normalizeEvent(el, e, calculate) {\n\n        e = e || window.event;\n\n        if (e.zrX != null) {\n            return e;\n        }\n\n        var eventType = e.type;\n        var isTouch = eventType && eventType.indexOf('touch') >= 0;\n\n        if (!isTouch) {\n            clientToLocal(el, e, e, calculate);\n            e.zrDelta = (e.wheelDelta) ? e.wheelDelta / 120 : -(e.detail || 0) / 3;\n        }\n        else {\n            var touch = eventType != 'touchend'\n                ? e.targetTouches[0]\n                : e.changedTouches[0];\n            touch && clientToLocal(el, touch, e, calculate);\n        }\n\n        return e;\n    }\n\n    function addEventListener(el, name, handler) {\n        if (isDomLevel2) {\n            el.addEventListener(name, handler);\n        }\n        else {\n            el.attachEvent('on' + name, handler);\n        }\n    }\n\n    function removeEventListener(el, name, handler) {\n        if (isDomLevel2) {\n            el.removeEventListener(name, handler);\n        }\n        else {\n            el.detachEvent('on' + name, handler);\n        }\n    }\n\n    /**\n     * preventDefault and stopPropagation.\n     * Notice: do not do that in zrender. Upper application\n     * do that if necessary.\n     *\n     * @memberOf module:zrender/core/event\n     * @method\n     * @param {Event} e : event对象\n     */\n    var stop = isDomLevel2\n        ? function (e) {\n            e.preventDefault();\n            e.stopPropagation();\n            e.cancelBubble = true;\n        }\n        : function (e) {\n            e.returnValue = false;\n            e.cancelBubble = true;\n        };\n\n    module.exports = {\n        clientToLocal: clientToLocal,\n        normalizeEvent: normalizeEvent,\n        addEventListener: addEventListener,\n        removeEventListener: removeEventListener,\n\n        stop: stop,\n        // 做向上兼容\n        Dispatcher: Eventful\n    };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL2hvbWUveXgvfi96cmVuZGVyL2xpYi9jb3JlL2V2ZW50LmpzP2ViOTEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuLyoqXG4gKiDkuovku7bovoXliqnnsbtcbiAqIEBtb2R1bGUgenJlbmRlci9jb3JlL2V2ZW50XG4gKiBAYXV0aG9yIEtlbmVyIChAS2VuZXIt5p6X5bOwLCBrZW5lci5saW5mZW5nQGdtYWlsLmNvbSlcbiAqL1xuXG5cbiAgICB2YXIgRXZlbnRmdWwgPSByZXF1aXJlKCcuLi9taXhpbi9FdmVudGZ1bCcpO1xuICAgIHZhciBlbnYgPSByZXF1aXJlKCcuL2VudicpO1xuXG4gICAgdmFyIGlzRG9tTGV2ZWwyID0gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSAmJiAhIXdpbmRvdy5hZGRFdmVudExpc3RlbmVyO1xuXG4gICAgZnVuY3Rpb24gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsKSB7XG4gICAgICAgIC8vIEJsYWNrQmVycnkgNSwgaU9TIDMgKG9yaWdpbmFsIGlQaG9uZSkgZG9uJ3QgaGF2ZSBnZXRCb3VuZGluZ1JlY3RcbiAgICAgICAgcmV0dXJuIGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCA/IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIDoge2xlZnQ6IDAsIHRvcDogMH07XG4gICAgfVxuXG4gICAgLy8gYGNhbGN1bGF0ZWAgaXMgb3B0aW9uYWwsIGRlZmF1bHQgZmFsc2VcbiAgICBmdW5jdGlvbiBjbGllbnRUb0xvY2FsKGVsLCBlLCBvdXQsIGNhbGN1bGF0ZSkge1xuICAgICAgICBvdXQgPSBvdXQgfHwge307XG5cbiAgICAgICAgLy8gQWNjb3JkaW5nIHRvIHRoZSBXM0MgV29ya2luZyBEcmFmdCwgb2Zmc2V0WCBhbmQgb2Zmc2V0WSBzaG91bGQgYmUgcmVsYXRpdmVcbiAgICAgICAgLy8gdG8gdGhlIHBhZGRpbmcgZWRnZSBvZiB0aGUgdGFyZ2V0IGVsZW1lbnQuIFRoZSBvbmx5IGJyb3dzZXIgdXNpbmcgdGhpcyBjb252ZW50aW9uXG4gICAgICAgIC8vIGlzIElFLiBXZWJraXQgdXNlcyB0aGUgYm9yZGVyIGVkZ2UsIE9wZXJhIHVzZXMgdGhlIGNvbnRlbnQgZWRnZSwgYW5kIEZpcmVGb3ggZG9lc1xuICAgICAgICAvLyBub3Qgc3VwcG9ydCB0aGUgcHJvcGVydGllcy5cbiAgICAgICAgLy8gKHNlZSBodHRwOi8vd3d3LmphY2tsbW9vcmUuY29tL25vdGVzL21vdXNlLXBvc2l0aW9uLylcbiAgICAgICAgLy8gSW4genIgcGFpbnRlci5kb20sIHBhZGRpbmcgZWRnZSBlcXVhbHMgdG8gYm9yZGVyIGVkZ2UuXG5cbiAgICAgICAgLy8gRklYTUVcbiAgICAgICAgLy8gV2hlbiBtb3VzZW1vdmUgZXZlbnQgdHJpZ2dlcmVkIG9uIGVjIHRvb2x0aXAsIHRhcmdldCBpcyBub3QgenIgcGFpbnRlci5kb20sIGFuZFxuICAgICAgICAvLyBvZmZzZXRYL1kgaXMgcmVsYXRpdmUgdG8gZS50YXJnZXQsIHdoZXJlIHRoZSBjYWxjdWxhdGlvbiBvZiB6clgvWSB2aWEgb2Zmc2V0WC9ZXG4gICAgICAgIC8vIGlzIHRvbyBjb21wbGV4LiBTbyBjc3MtdHJhbnNmcm9tIGRvbnQgc3VwcG9ydCBpbiB0aGlzIGNhc2UgdGVtcG9yYXJpbHkuXG4gICAgICAgIGlmIChjYWxjdWxhdGUgfHwgIWVudi5jYW52YXNTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgIGRlZmF1bHRHZXRaclhZKGVsLCBlLCBvdXQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENhdXRpb246IEluIEZpcmVGb3gsIGxheWVyWC9sYXllclkgTW91c2UgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIGNsb3Nlc3QgcG9zaXRpb25lZFxuICAgICAgICAvLyBhbmNlc3RvciBlbGVtZW50LCBzbyB3ZSBzaG91bGQgbWFrZSBzdXJlIGVsIGlzIHBvc2l0aW9uZWQgKGUuZy4sIG5vdCBwb3NpdGlvbjpzdGF0aWMpLlxuICAgICAgICAvLyBCVFcxLCBXZWJraXQgZG9uJ3QgcmV0dXJuIHRoZSBzYW1lIHJlc3VsdHMgYXMgRkYgaW4gbm9uLXNpbXBsZSBjYXNlcyAobGlrZSBhZGRcbiAgICAgICAgLy8gem9vbS1mYWN0b3IsIG92ZXJmbG93IC8gb3BhY2l0eSBsYXllcnMsIHRyYW5zZm9ybXMgLi4uKVxuICAgICAgICAvLyBCVFcyLCAoZXYub2Zmc2V0WSB8fCBldi5wYWdlWSAtICQoZXYudGFyZ2V0KS5vZmZzZXQoKS50b3ApIGlzIG5vdCBjb3JyZWN0IGluIHByZXNlcnZlLTNkLlxuICAgICAgICAvLyA8aHR0cHM6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0Lzg1MjMjY29tbWVudDoxND5cbiAgICAgICAgLy8gQlRXMywgSW4gZmYsIG9mZnNldFgvb2Zmc2V0WSBpcyBhbHdheXMgMC5cbiAgICAgICAgZWxzZSBpZiAoZW52LmJyb3dzZXIuZmlyZWZveCAmJiBlLmxheWVyWCAhPSBudWxsICYmIGUubGF5ZXJYICE9PSBlLm9mZnNldFgpIHtcbiAgICAgICAgICAgIG91dC56clggPSBlLmxheWVyWDtcbiAgICAgICAgICAgIG91dC56clkgPSBlLmxheWVyWTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGb3IgSUU2KywgY2hyb21lLCBzYWZhcmksIG9wZXJhLiAoV2hlbiB3aWxsIGZmIHN1cHBvcnQgb2Zmc2V0WD8pXG4gICAgICAgIGVsc2UgaWYgKGUub2Zmc2V0WCAhPSBudWxsKSB7XG4gICAgICAgICAgICBvdXQuenJYID0gZS5vZmZzZXRYO1xuICAgICAgICAgICAgb3V0LnpyWSA9IGUub2Zmc2V0WTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGb3Igc29tZSBvdGhlciBkZXZpY2UsIGUuZy4sIElPUyBzYWZhcmkuXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVmYXVsdEdldFpyWFkoZWwsIGUsIG91dCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlZmF1bHRHZXRaclhZKGVsLCBlLCBvdXQpIHtcbiAgICAgICAgLy8gVGhpcyB3ZWxsLWtub3duIG1ldGhvZCBiZWxvdyBkb2VzIG5vdCBzdXBwb3J0IGNzcyB0cmFuc2Zvcm0uXG4gICAgICAgIHZhciBib3ggPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWwpO1xuICAgICAgICBvdXQuenJYID0gZS5jbGllbnRYIC0gYm94LmxlZnQ7XG4gICAgICAgIG91dC56clkgPSBlLmNsaWVudFkgLSBib3gudG9wO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOWmguaenOWtmOWcqOesrOS4ieaWueW1jOWFpeeahOS4gOS6m2RvbeinpuWPkeeahOS6i+S7tu+8jOaIlnRvdWNo5LqL5Lu277yM6ZyA6KaB6L2s5o2i5LiA5LiL5LqL5Lu25Z2Q5qCHLlxuICAgICAqIGBjYWxjdWxhdGVgIGlzIG9wdGlvbmFsLCBkZWZhdWx0IGZhbHNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZUV2ZW50KGVsLCBlLCBjYWxjdWxhdGUpIHtcblxuICAgICAgICBlID0gZSB8fCB3aW5kb3cuZXZlbnQ7XG5cbiAgICAgICAgaWYgKGUuenJYICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGV2ZW50VHlwZSA9IGUudHlwZTtcbiAgICAgICAgdmFyIGlzVG91Y2ggPSBldmVudFR5cGUgJiYgZXZlbnRUeXBlLmluZGV4T2YoJ3RvdWNoJykgPj0gMDtcblxuICAgICAgICBpZiAoIWlzVG91Y2gpIHtcbiAgICAgICAgICAgIGNsaWVudFRvTG9jYWwoZWwsIGUsIGUsIGNhbGN1bGF0ZSk7XG4gICAgICAgICAgICBlLnpyRGVsdGEgPSAoZS53aGVlbERlbHRhKSA/IGUud2hlZWxEZWx0YSAvIDEyMCA6IC0oZS5kZXRhaWwgfHwgMCkgLyAzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRvdWNoID0gZXZlbnRUeXBlICE9ICd0b3VjaGVuZCdcbiAgICAgICAgICAgICAgICA/IGUudGFyZ2V0VG91Y2hlc1swXVxuICAgICAgICAgICAgICAgIDogZS5jaGFuZ2VkVG91Y2hlc1swXTtcbiAgICAgICAgICAgIHRvdWNoICYmIGNsaWVudFRvTG9jYWwoZWwsIHRvdWNoLCBlLCBjYWxjdWxhdGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcihlbCwgbmFtZSwgaGFuZGxlcikge1xuICAgICAgICBpZiAoaXNEb21MZXZlbDIpIHtcbiAgICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgaGFuZGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbC5hdHRhY2hFdmVudCgnb24nICsgbmFtZSwgaGFuZGxlcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVyKGVsLCBuYW1lLCBoYW5kbGVyKSB7XG4gICAgICAgIGlmIChpc0RvbUxldmVsMikge1xuICAgICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCBoYW5kbGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVsLmRldGFjaEV2ZW50KCdvbicgKyBuYW1lLCBoYW5kbGVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHByZXZlbnREZWZhdWx0IGFuZCBzdG9wUHJvcGFnYXRpb24uXG4gICAgICogTm90aWNlOiBkbyBub3QgZG8gdGhhdCBpbiB6cmVuZGVyLiBVcHBlciBhcHBsaWNhdGlvblxuICAgICAqIGRvIHRoYXQgaWYgbmVjZXNzYXJ5LlxuICAgICAqXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvZXZlbnRcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSA6IGV2ZW505a+56LGhXG4gICAgICovXG4gICAgdmFyIHN0b3AgPSBpc0RvbUxldmVsMlxuICAgICAgICA/IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgZS5jYW5jZWxCdWJibGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGUucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgIGUuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbiAgICAgICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBjbGllbnRUb0xvY2FsOiBjbGllbnRUb0xvY2FsLFxuICAgICAgICBub3JtYWxpemVFdmVudDogbm9ybWFsaXplRXZlbnQsXG4gICAgICAgIGFkZEV2ZW50TGlzdGVuZXI6IGFkZEV2ZW50TGlzdGVuZXIsXG4gICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXI6IHJlbW92ZUV2ZW50TGlzdGVuZXIsXG5cbiAgICAgICAgc3RvcDogc3RvcCxcbiAgICAgICAgLy8g5YGa5ZCR5LiK5YW85a65XG4gICAgICAgIERpc3BhdGNoZXI6IEV2ZW50ZnVsXG4gICAgfTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2hvbWUveXgvfi96cmVuZGVyL2xpYi9jb3JlL2V2ZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAyMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 21 */
/* unknown exports provided */
/* all exports used */
/*!********************************************!*\
  !*** /home/yx/~/zrender/lib/tool/color.js ***!
  \********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * @module zrender/tool/color\n */\n\n\n    var LRU = __webpack_require__(/*! ../core/LRU */ 61);\n\n    var kCSSColorTable = {\n        'transparent': [0,0,0,0], 'aliceblue': [240,248,255,1],\n        'antiquewhite': [250,235,215,1], 'aqua': [0,255,255,1],\n        'aquamarine': [127,255,212,1], 'azure': [240,255,255,1],\n        'beige': [245,245,220,1], 'bisque': [255,228,196,1],\n        'black': [0,0,0,1], 'blanchedalmond': [255,235,205,1],\n        'blue': [0,0,255,1], 'blueviolet': [138,43,226,1],\n        'brown': [165,42,42,1], 'burlywood': [222,184,135,1],\n        'cadetblue': [95,158,160,1], 'chartreuse': [127,255,0,1],\n        'chocolate': [210,105,30,1], 'coral': [255,127,80,1],\n        'cornflowerblue': [100,149,237,1], 'cornsilk': [255,248,220,1],\n        'crimson': [220,20,60,1], 'cyan': [0,255,255,1],\n        'darkblue': [0,0,139,1], 'darkcyan': [0,139,139,1],\n        'darkgoldenrod': [184,134,11,1], 'darkgray': [169,169,169,1],\n        'darkgreen': [0,100,0,1], 'darkgrey': [169,169,169,1],\n        'darkkhaki': [189,183,107,1], 'darkmagenta': [139,0,139,1],\n        'darkolivegreen': [85,107,47,1], 'darkorange': [255,140,0,1],\n        'darkorchid': [153,50,204,1], 'darkred': [139,0,0,1],\n        'darksalmon': [233,150,122,1], 'darkseagreen': [143,188,143,1],\n        'darkslateblue': [72,61,139,1], 'darkslategray': [47,79,79,1],\n        'darkslategrey': [47,79,79,1], 'darkturquoise': [0,206,209,1],\n        'darkviolet': [148,0,211,1], 'deeppink': [255,20,147,1],\n        'deepskyblue': [0,191,255,1], 'dimgray': [105,105,105,1],\n        'dimgrey': [105,105,105,1], 'dodgerblue': [30,144,255,1],\n        'firebrick': [178,34,34,1], 'floralwhite': [255,250,240,1],\n        'forestgreen': [34,139,34,1], 'fuchsia': [255,0,255,1],\n        'gainsboro': [220,220,220,1], 'ghostwhite': [248,248,255,1],\n        'gold': [255,215,0,1], 'goldenrod': [218,165,32,1],\n        'gray': [128,128,128,1], 'green': [0,128,0,1],\n        'greenyellow': [173,255,47,1], 'grey': [128,128,128,1],\n        'honeydew': [240,255,240,1], 'hotpink': [255,105,180,1],\n        'indianred': [205,92,92,1], 'indigo': [75,0,130,1],\n        'ivory': [255,255,240,1], 'khaki': [240,230,140,1],\n        'lavender': [230,230,250,1], 'lavenderblush': [255,240,245,1],\n        'lawngreen': [124,252,0,1], 'lemonchiffon': [255,250,205,1],\n        'lightblue': [173,216,230,1], 'lightcoral': [240,128,128,1],\n        'lightcyan': [224,255,255,1], 'lightgoldenrodyellow': [250,250,210,1],\n        'lightgray': [211,211,211,1], 'lightgreen': [144,238,144,1],\n        'lightgrey': [211,211,211,1], 'lightpink': [255,182,193,1],\n        'lightsalmon': [255,160,122,1], 'lightseagreen': [32,178,170,1],\n        'lightskyblue': [135,206,250,1], 'lightslategray': [119,136,153,1],\n        'lightslategrey': [119,136,153,1], 'lightsteelblue': [176,196,222,1],\n        'lightyellow': [255,255,224,1], 'lime': [0,255,0,1],\n        'limegreen': [50,205,50,1], 'linen': [250,240,230,1],\n        'magenta': [255,0,255,1], 'maroon': [128,0,0,1],\n        'mediumaquamarine': [102,205,170,1], 'mediumblue': [0,0,205,1],\n        'mediumorchid': [186,85,211,1], 'mediumpurple': [147,112,219,1],\n        'mediumseagreen': [60,179,113,1], 'mediumslateblue': [123,104,238,1],\n        'mediumspringgreen': [0,250,154,1], 'mediumturquoise': [72,209,204,1],\n        'mediumvioletred': [199,21,133,1], 'midnightblue': [25,25,112,1],\n        'mintcream': [245,255,250,1], 'mistyrose': [255,228,225,1],\n        'moccasin': [255,228,181,1], 'navajowhite': [255,222,173,1],\n        'navy': [0,0,128,1], 'oldlace': [253,245,230,1],\n        'olive': [128,128,0,1], 'olivedrab': [107,142,35,1],\n        'orange': [255,165,0,1], 'orangered': [255,69,0,1],\n        'orchid': [218,112,214,1], 'palegoldenrod': [238,232,170,1],\n        'palegreen': [152,251,152,1], 'paleturquoise': [175,238,238,1],\n        'palevioletred': [219,112,147,1], 'papayawhip': [255,239,213,1],\n        'peachpuff': [255,218,185,1], 'peru': [205,133,63,1],\n        'pink': [255,192,203,1], 'plum': [221,160,221,1],\n        'powderblue': [176,224,230,1], 'purple': [128,0,128,1],\n        'red': [255,0,0,1], 'rosybrown': [188,143,143,1],\n        'royalblue': [65,105,225,1], 'saddlebrown': [139,69,19,1],\n        'salmon': [250,128,114,1], 'sandybrown': [244,164,96,1],\n        'seagreen': [46,139,87,1], 'seashell': [255,245,238,1],\n        'sienna': [160,82,45,1], 'silver': [192,192,192,1],\n        'skyblue': [135,206,235,1], 'slateblue': [106,90,205,1],\n        'slategray': [112,128,144,1], 'slategrey': [112,128,144,1],\n        'snow': [255,250,250,1], 'springgreen': [0,255,127,1],\n        'steelblue': [70,130,180,1], 'tan': [210,180,140,1],\n        'teal': [0,128,128,1], 'thistle': [216,191,216,1],\n        'tomato': [255,99,71,1], 'turquoise': [64,224,208,1],\n        'violet': [238,130,238,1], 'wheat': [245,222,179,1],\n        'white': [255,255,255,1], 'whitesmoke': [245,245,245,1],\n        'yellow': [255,255,0,1], 'yellowgreen': [154,205,50,1]\n    };\n\n    function clampCssByte(i) {  // Clamp to integer 0 .. 255.\n        i = Math.round(i);  // Seems to be what Chrome does (vs truncation).\n        return i < 0 ? 0 : i > 255 ? 255 : i;\n    }\n\n    function clampCssAngle(i) {  // Clamp to integer 0 .. 360.\n        i = Math.round(i);  // Seems to be what Chrome does (vs truncation).\n        return i < 0 ? 0 : i > 360 ? 360 : i;\n    }\n\n    function clampCssFloat(f) {  // Clamp to float 0.0 .. 1.0.\n        return f < 0 ? 0 : f > 1 ? 1 : f;\n    }\n\n    function parseCssInt(str) {  // int or percentage.\n        if (str.length && str.charAt(str.length - 1) === '%') {\n            return clampCssByte(parseFloat(str) / 100 * 255);\n        }\n        return clampCssByte(parseInt(str, 10));\n    }\n\n    function parseCssFloat(str) {  // float or percentage.\n        if (str.length && str.charAt(str.length - 1) === '%') {\n            return clampCssFloat(parseFloat(str) / 100);\n        }\n        return clampCssFloat(parseFloat(str));\n    }\n\n    function cssHueToRgb(m1, m2, h) {\n        if (h < 0) {\n            h += 1;\n        }\n        else if (h > 1) {\n            h -= 1;\n        }\n\n        if (h * 6 < 1) {\n            return m1 + (m2 - m1) * h * 6;\n        }\n        if (h * 2 < 1) {\n            return m2;\n        }\n        if (h * 3 < 2) {\n            return m1 + (m2 - m1) * (2/3 - h) * 6;\n        }\n        return m1;\n    }\n\n    function lerp(a, b, p) {\n        return a + (b - a) * p;\n    }\n\n    function setRgba(out, r, g, b, a) {\n        out[0] = r; out[1] = g; out[2] = b; out[3] = a;\n        return out;\n    }\n    function copyRgba(out, a) {\n        out[0] = a[0]; out[1] = a[1]; out[2] = a[2]; out[3] = a[3];\n        return out;\n    }\n    var colorCache = new LRU(20);\n    var lastRemovedArr = null;\n    function putToCache(colorStr, rgbaArr) {\n        // Reuse removed array\n        if (lastRemovedArr) {\n            copyRgba(lastRemovedArr, rgbaArr);\n        }\n        lastRemovedArr = colorCache.put(colorStr, lastRemovedArr || (rgbaArr.slice()));\n    }\n    /**\n     * @param {string} colorStr\n     * @param {Array.<number>} out\n     * @return {Array.<number>}\n     * @memberOf module:zrender/util/color\n     */\n    function parse(colorStr, rgbaArr) {\n        if (!colorStr) {\n            return;\n        }\n        rgbaArr = rgbaArr || [];\n\n        var cached = colorCache.get(colorStr);\n        if (cached) {\n            return copyRgba(rgbaArr, cached);\n        }\n\n        // colorStr may be not string\n        colorStr = colorStr + '';\n        // Remove all whitespace, not compliant, but should just be more accepting.\n        var str = colorStr.replace(/ /g, '').toLowerCase();\n\n        // Color keywords (and transparent) lookup.\n        if (str in kCSSColorTable) {\n            copyRgba(rgbaArr, kCSSColorTable[str]);\n            putToCache(colorStr, rgbaArr);\n            return rgbaArr;\n        }\n\n        // #abc and #abc123 syntax.\n        if (str.charAt(0) === '#') {\n            if (str.length === 4) {\n                var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.\n                if (!(iv >= 0 && iv <= 0xfff)) {\n                    setRgba(rgbaArr, 0, 0, 0, 1);\n                    return;  // Covers NaN.\n                }\n                setRgba(rgbaArr,\n                    ((iv & 0xf00) >> 4) | ((iv & 0xf00) >> 8),\n                    (iv & 0xf0) | ((iv & 0xf0) >> 4),\n                    (iv & 0xf) | ((iv & 0xf) << 4),\n                    1\n                );\n                putToCache(colorStr, rgbaArr);\n                return rgbaArr;\n            }\n            else if (str.length === 7) {\n                var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.\n                if (!(iv >= 0 && iv <= 0xffffff)) {\n                    setRgba(rgbaArr, 0, 0, 0, 1);\n                    return;  // Covers NaN.\n                }\n                setRgba(rgbaArr,\n                    (iv & 0xff0000) >> 16,\n                    (iv & 0xff00) >> 8,\n                    iv & 0xff,\n                    1\n                );\n                putToCache(colorStr, rgbaArr);\n                return rgbaArr;\n            }\n\n            return;\n        }\n        var op = str.indexOf('('), ep = str.indexOf(')');\n        if (op !== -1 && ep + 1 === str.length) {\n            var fname = str.substr(0, op);\n            var params = str.substr(op + 1, ep - (op + 1)).split(',');\n            var alpha = 1;  // To allow case fallthrough.\n            switch (fname) {\n                case 'rgba':\n                    if (params.length !== 4) {\n                        setRgba(rgbaArr, 0, 0, 0, 1);\n                        return;\n                    }\n                    alpha = parseCssFloat(params.pop()); // jshint ignore:line\n                // Fall through.\n                case 'rgb':\n                    if (params.length !== 3) {\n                        setRgba(rgbaArr, 0, 0, 0, 1);\n                        return;\n                    }\n                    setRgba(rgbaArr,\n                        parseCssInt(params[0]),\n                        parseCssInt(params[1]),\n                        parseCssInt(params[2]),\n                        alpha\n                    );\n                    putToCache(colorStr, rgbaArr);\n                    return rgbaArr;\n                case 'hsla':\n                    if (params.length !== 4) {\n                        setRgba(rgbaArr, 0, 0, 0, 1);\n                        return;\n                    }\n                    params[3] = parseCssFloat(params[3]);\n                    hsla2rgba(params, rgbaArr);\n                    putToCache(colorStr, rgbaArr);\n                    return rgbaArr;\n                case 'hsl':\n                    if (params.length !== 3) {\n                        setRgba(rgbaArr, 0, 0, 0, 1);\n                        return;\n                    }\n                    hsla2rgba(params, rgbaArr);\n                    putToCache(colorStr, rgbaArr);\n                    return rgbaArr;\n                default:\n                    return;\n            }\n        }\n\n        setRgba(rgbaArr, 0, 0, 0, 1);\n        return;\n    }\n\n    /**\n     * @param {Array.<number>} hsla\n     * @param {Array.<number>} rgba\n     * @return {Array.<number>} rgba\n     */\n    function hsla2rgba(hsla, rgba) {\n        var h = (((parseFloat(hsla[0]) % 360) + 360) % 360) / 360;  // 0 .. 1\n        // NOTE(deanm): According to the CSS spec s/l should only be\n        // percentages, but we don't bother and let float or percentage.\n        var s = parseCssFloat(hsla[1]);\n        var l = parseCssFloat(hsla[2]);\n        var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;\n        var m1 = l * 2 - m2;\n\n        rgba = rgba || [];\n        setRgba(rgba,\n            clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255),\n            clampCssByte(cssHueToRgb(m1, m2, h) * 255),\n            clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255),\n            1\n        );\n\n        if (hsla.length === 4) {\n            rgba[3] = hsla[3];\n        }\n\n        return rgba;\n    }\n\n    /**\n     * @param {Array.<number>} rgba\n     * @return {Array.<number>} hsla\n     */\n    function rgba2hsla(rgba) {\n        if (!rgba) {\n            return;\n        }\n\n        // RGB from 0 to 255\n        var R = rgba[0] / 255;\n        var G = rgba[1] / 255;\n        var B = rgba[2] / 255;\n\n        var vMin = Math.min(R, G, B); // Min. value of RGB\n        var vMax = Math.max(R, G, B); // Max. value of RGB\n        var delta = vMax - vMin; // Delta RGB value\n\n        var L = (vMax + vMin) / 2;\n        var H;\n        var S;\n        // HSL results from 0 to 1\n        if (delta === 0) {\n            H = 0;\n            S = 0;\n        }\n        else {\n            if (L < 0.5) {\n                S = delta / (vMax + vMin);\n            }\n            else {\n                S = delta / (2 - vMax - vMin);\n            }\n\n            var deltaR = (((vMax - R) / 6) + (delta / 2)) / delta;\n            var deltaG = (((vMax - G) / 6) + (delta / 2)) / delta;\n            var deltaB = (((vMax - B) / 6) + (delta / 2)) / delta;\n\n            if (R === vMax) {\n                H = deltaB - deltaG;\n            }\n            else if (G === vMax) {\n                H = (1 / 3) + deltaR - deltaB;\n            }\n            else if (B === vMax) {\n                H = (2 / 3) + deltaG - deltaR;\n            }\n\n            if (H < 0) {\n                H += 1;\n            }\n\n            if (H > 1) {\n                H -= 1;\n            }\n        }\n\n        var hsla = [H * 360, S, L];\n\n        if (rgba[3] != null) {\n            hsla.push(rgba[3]);\n        }\n\n        return hsla;\n    }\n\n    /**\n     * @param {string} color\n     * @param {number} level\n     * @return {string}\n     * @memberOf module:zrender/util/color\n     */\n    function lift(color, level) {\n        var colorArr = parse(color);\n        if (colorArr) {\n            for (var i = 0; i < 3; i++) {\n                if (level < 0) {\n                    colorArr[i] = colorArr[i] * (1 - level) | 0;\n                }\n                else {\n                    colorArr[i] = ((255 - colorArr[i]) * level + colorArr[i]) | 0;\n                }\n            }\n            return stringify(colorArr, colorArr.length === 4 ? 'rgba' : 'rgb');\n        }\n    }\n\n    /**\n     * @param {string} color\n     * @return {string}\n     * @memberOf module:zrender/util/color\n     */\n    function toHex(color, level) {\n        var colorArr = parse(color);\n        if (colorArr) {\n            return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + (+colorArr[2])).toString(16).slice(1);\n        }\n    }\n\n    /**\n     * Map value to color. Faster than mapToColor methods because color is represented by rgba array.\n     * @param {number} normalizedValue A float between 0 and 1.\n     * @param {Array.<Array.<number>>} colors List of rgba color array\n     * @param {Array.<number>} [out] Mapped gba color array\n     * @return {Array.<number>} will be null/undefined if input illegal.\n     */\n    function fastMapToColor(normalizedValue, colors, out) {\n        if (!(colors && colors.length)\n            || !(normalizedValue >= 0 && normalizedValue <= 1)\n        ) {\n            return;\n        }\n\n        out = out || [];\n\n        var value = normalizedValue * (colors.length - 1);\n        var leftIndex = Math.floor(value);\n        var rightIndex = Math.ceil(value);\n        var leftColor = colors[leftIndex];\n        var rightColor = colors[rightIndex];\n        var dv = value - leftIndex;\n        out[0] = clampCssByte(lerp(leftColor[0], rightColor[0], dv));\n        out[1] = clampCssByte(lerp(leftColor[1], rightColor[1], dv));\n        out[2] = clampCssByte(lerp(leftColor[2], rightColor[2], dv));\n        out[3] = clampCssFloat(lerp(leftColor[3], rightColor[3], dv));\n\n        return out;\n    }\n    /**\n     * @param {number} normalizedValue A float between 0 and 1.\n     * @param {Array.<string>} colors Color list.\n     * @param {boolean=} fullOutput Default false.\n     * @return {(string|Object)} Result color. If fullOutput,\n     *                           return {color: ..., leftIndex: ..., rightIndex: ..., value: ...},\n     * @memberOf module:zrender/util/color\n     */\n    function mapToColor(normalizedValue, colors, fullOutput) {\n        if (!(colors && colors.length)\n            || !(normalizedValue >= 0 && normalizedValue <= 1)\n        ) {\n            return;\n        }\n\n        var value = normalizedValue * (colors.length - 1);\n        var leftIndex = Math.floor(value);\n        var rightIndex = Math.ceil(value);\n        var leftColor = parse(colors[leftIndex]);\n        var rightColor = parse(colors[rightIndex]);\n        var dv = value - leftIndex;\n\n        var color = stringify(\n            [\n                clampCssByte(lerp(leftColor[0], rightColor[0], dv)),\n                clampCssByte(lerp(leftColor[1], rightColor[1], dv)),\n                clampCssByte(lerp(leftColor[2], rightColor[2], dv)),\n                clampCssFloat(lerp(leftColor[3], rightColor[3], dv))\n            ],\n            'rgba'\n        );\n\n        return fullOutput\n            ? {\n                color: color,\n                leftIndex: leftIndex,\n                rightIndex: rightIndex,\n                value: value\n            }\n            : color;\n    }\n\n    /**\n     * @param {string} color\n     * @param {number=} h 0 ~ 360, ignore when null.\n     * @param {number=} s 0 ~ 1, ignore when null.\n     * @param {number=} l 0 ~ 1, ignore when null.\n     * @return {string} Color string in rgba format.\n     * @memberOf module:zrender/util/color\n     */\n    function modifyHSL(color, h, s, l) {\n        color = parse(color);\n\n        if (color) {\n            color = rgba2hsla(color);\n            h != null && (color[0] = clampCssAngle(h));\n            s != null && (color[1] = parseCssFloat(s));\n            l != null && (color[2] = parseCssFloat(l));\n\n            return stringify(hsla2rgba(color), 'rgba');\n        }\n    }\n\n    /**\n     * @param {string} color\n     * @param {number=} alpha 0 ~ 1\n     * @return {string} Color string in rgba format.\n     * @memberOf module:zrender/util/color\n     */\n    function modifyAlpha(color, alpha) {\n        color = parse(color);\n\n        if (color && alpha != null) {\n            color[3] = clampCssFloat(alpha);\n            return stringify(color, 'rgba');\n        }\n    }\n\n    /**\n     * @param {Array.<number>} arrColor like [12,33,44,0.4]\n     * @param {string} type 'rgba', 'hsva', ...\n     * @return {string} Result color. (If input illegal, return undefined).\n     */\n    function stringify(arrColor, type) {\n        if (!arrColor || !arrColor.length) {\n            return;\n        }\n        var colorStr = arrColor[0] + ',' + arrColor[1] + ',' + arrColor[2];\n        if (type === 'rgba' || type === 'hsva' || type === 'hsla') {\n            colorStr += ',' + arrColor[3];\n        }\n        return type + '(' + colorStr + ')';\n    }\n\n    module.exports = {\n        parse: parse,\n        lift: lift,\n        toHex: toHex,\n        fastMapToColor: fastMapToColor,\n        mapToColor: mapToColor,\n        modifyHSL: modifyHSL,\n        modifyAlpha: modifyAlpha,\n        stringify: stringify\n    };\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL2hvbWUveXgvfi96cmVuZGVyL2xpYi90b29sL2NvbG9yLmpzPzZlZGYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9kdWxlIHpyZW5kZXIvdG9vbC9jb2xvclxuICovXG5cblxuICAgIHZhciBMUlUgPSByZXF1aXJlKCcuLi9jb3JlL0xSVScpO1xuXG4gICAgdmFyIGtDU1NDb2xvclRhYmxlID0ge1xuICAgICAgICAndHJhbnNwYXJlbnQnOiBbMCwwLDAsMF0sICdhbGljZWJsdWUnOiBbMjQwLDI0OCwyNTUsMV0sXG4gICAgICAgICdhbnRpcXVld2hpdGUnOiBbMjUwLDIzNSwyMTUsMV0sICdhcXVhJzogWzAsMjU1LDI1NSwxXSxcbiAgICAgICAgJ2FxdWFtYXJpbmUnOiBbMTI3LDI1NSwyMTIsMV0sICdhenVyZSc6IFsyNDAsMjU1LDI1NSwxXSxcbiAgICAgICAgJ2JlaWdlJzogWzI0NSwyNDUsMjIwLDFdLCAnYmlzcXVlJzogWzI1NSwyMjgsMTk2LDFdLFxuICAgICAgICAnYmxhY2snOiBbMCwwLDAsMV0sICdibGFuY2hlZGFsbW9uZCc6IFsyNTUsMjM1LDIwNSwxXSxcbiAgICAgICAgJ2JsdWUnOiBbMCwwLDI1NSwxXSwgJ2JsdWV2aW9sZXQnOiBbMTM4LDQzLDIyNiwxXSxcbiAgICAgICAgJ2Jyb3duJzogWzE2NSw0Miw0MiwxXSwgJ2J1cmx5d29vZCc6IFsyMjIsMTg0LDEzNSwxXSxcbiAgICAgICAgJ2NhZGV0Ymx1ZSc6IFs5NSwxNTgsMTYwLDFdLCAnY2hhcnRyZXVzZSc6IFsxMjcsMjU1LDAsMV0sXG4gICAgICAgICdjaG9jb2xhdGUnOiBbMjEwLDEwNSwzMCwxXSwgJ2NvcmFsJzogWzI1NSwxMjcsODAsMV0sXG4gICAgICAgICdjb3JuZmxvd2VyYmx1ZSc6IFsxMDAsMTQ5LDIzNywxXSwgJ2Nvcm5zaWxrJzogWzI1NSwyNDgsMjIwLDFdLFxuICAgICAgICAnY3JpbXNvbic6IFsyMjAsMjAsNjAsMV0sICdjeWFuJzogWzAsMjU1LDI1NSwxXSxcbiAgICAgICAgJ2RhcmtibHVlJzogWzAsMCwxMzksMV0sICdkYXJrY3lhbic6IFswLDEzOSwxMzksMV0sXG4gICAgICAgICdkYXJrZ29sZGVucm9kJzogWzE4NCwxMzQsMTEsMV0sICdkYXJrZ3JheSc6IFsxNjksMTY5LDE2OSwxXSxcbiAgICAgICAgJ2RhcmtncmVlbic6IFswLDEwMCwwLDFdLCAnZGFya2dyZXknOiBbMTY5LDE2OSwxNjksMV0sXG4gICAgICAgICdkYXJra2hha2knOiBbMTg5LDE4MywxMDcsMV0sICdkYXJrbWFnZW50YSc6IFsxMzksMCwxMzksMV0sXG4gICAgICAgICdkYXJrb2xpdmVncmVlbic6IFs4NSwxMDcsNDcsMV0sICdkYXJrb3JhbmdlJzogWzI1NSwxNDAsMCwxXSxcbiAgICAgICAgJ2RhcmtvcmNoaWQnOiBbMTUzLDUwLDIwNCwxXSwgJ2RhcmtyZWQnOiBbMTM5LDAsMCwxXSxcbiAgICAgICAgJ2RhcmtzYWxtb24nOiBbMjMzLDE1MCwxMjIsMV0sICdkYXJrc2VhZ3JlZW4nOiBbMTQzLDE4OCwxNDMsMV0sXG4gICAgICAgICdkYXJrc2xhdGVibHVlJzogWzcyLDYxLDEzOSwxXSwgJ2RhcmtzbGF0ZWdyYXknOiBbNDcsNzksNzksMV0sXG4gICAgICAgICdkYXJrc2xhdGVncmV5JzogWzQ3LDc5LDc5LDFdLCAnZGFya3R1cnF1b2lzZSc6IFswLDIwNiwyMDksMV0sXG4gICAgICAgICdkYXJrdmlvbGV0JzogWzE0OCwwLDIxMSwxXSwgJ2RlZXBwaW5rJzogWzI1NSwyMCwxNDcsMV0sXG4gICAgICAgICdkZWVwc2t5Ymx1ZSc6IFswLDE5MSwyNTUsMV0sICdkaW1ncmF5JzogWzEwNSwxMDUsMTA1LDFdLFxuICAgICAgICAnZGltZ3JleSc6IFsxMDUsMTA1LDEwNSwxXSwgJ2RvZGdlcmJsdWUnOiBbMzAsMTQ0LDI1NSwxXSxcbiAgICAgICAgJ2ZpcmVicmljayc6IFsxNzgsMzQsMzQsMV0sICdmbG9yYWx3aGl0ZSc6IFsyNTUsMjUwLDI0MCwxXSxcbiAgICAgICAgJ2ZvcmVzdGdyZWVuJzogWzM0LDEzOSwzNCwxXSwgJ2Z1Y2hzaWEnOiBbMjU1LDAsMjU1LDFdLFxuICAgICAgICAnZ2FpbnNib3JvJzogWzIyMCwyMjAsMjIwLDFdLCAnZ2hvc3R3aGl0ZSc6IFsyNDgsMjQ4LDI1NSwxXSxcbiAgICAgICAgJ2dvbGQnOiBbMjU1LDIxNSwwLDFdLCAnZ29sZGVucm9kJzogWzIxOCwxNjUsMzIsMV0sXG4gICAgICAgICdncmF5JzogWzEyOCwxMjgsMTI4LDFdLCAnZ3JlZW4nOiBbMCwxMjgsMCwxXSxcbiAgICAgICAgJ2dyZWVueWVsbG93JzogWzE3MywyNTUsNDcsMV0sICdncmV5JzogWzEyOCwxMjgsMTI4LDFdLFxuICAgICAgICAnaG9uZXlkZXcnOiBbMjQwLDI1NSwyNDAsMV0sICdob3RwaW5rJzogWzI1NSwxMDUsMTgwLDFdLFxuICAgICAgICAnaW5kaWFucmVkJzogWzIwNSw5Miw5MiwxXSwgJ2luZGlnbyc6IFs3NSwwLDEzMCwxXSxcbiAgICAgICAgJ2l2b3J5JzogWzI1NSwyNTUsMjQwLDFdLCAna2hha2knOiBbMjQwLDIzMCwxNDAsMV0sXG4gICAgICAgICdsYXZlbmRlcic6IFsyMzAsMjMwLDI1MCwxXSwgJ2xhdmVuZGVyYmx1c2gnOiBbMjU1LDI0MCwyNDUsMV0sXG4gICAgICAgICdsYXduZ3JlZW4nOiBbMTI0LDI1MiwwLDFdLCAnbGVtb25jaGlmZm9uJzogWzI1NSwyNTAsMjA1LDFdLFxuICAgICAgICAnbGlnaHRibHVlJzogWzE3MywyMTYsMjMwLDFdLCAnbGlnaHRjb3JhbCc6IFsyNDAsMTI4LDEyOCwxXSxcbiAgICAgICAgJ2xpZ2h0Y3lhbic6IFsyMjQsMjU1LDI1NSwxXSwgJ2xpZ2h0Z29sZGVucm9keWVsbG93JzogWzI1MCwyNTAsMjEwLDFdLFxuICAgICAgICAnbGlnaHRncmF5JzogWzIxMSwyMTEsMjExLDFdLCAnbGlnaHRncmVlbic6IFsxNDQsMjM4LDE0NCwxXSxcbiAgICAgICAgJ2xpZ2h0Z3JleSc6IFsyMTEsMjExLDIxMSwxXSwgJ2xpZ2h0cGluayc6IFsyNTUsMTgyLDE5MywxXSxcbiAgICAgICAgJ2xpZ2h0c2FsbW9uJzogWzI1NSwxNjAsMTIyLDFdLCAnbGlnaHRzZWFncmVlbic6IFszMiwxNzgsMTcwLDFdLFxuICAgICAgICAnbGlnaHRza3libHVlJzogWzEzNSwyMDYsMjUwLDFdLCAnbGlnaHRzbGF0ZWdyYXknOiBbMTE5LDEzNiwxNTMsMV0sXG4gICAgICAgICdsaWdodHNsYXRlZ3JleSc6IFsxMTksMTM2LDE1MywxXSwgJ2xpZ2h0c3RlZWxibHVlJzogWzE3NiwxOTYsMjIyLDFdLFxuICAgICAgICAnbGlnaHR5ZWxsb3cnOiBbMjU1LDI1NSwyMjQsMV0sICdsaW1lJzogWzAsMjU1LDAsMV0sXG4gICAgICAgICdsaW1lZ3JlZW4nOiBbNTAsMjA1LDUwLDFdLCAnbGluZW4nOiBbMjUwLDI0MCwyMzAsMV0sXG4gICAgICAgICdtYWdlbnRhJzogWzI1NSwwLDI1NSwxXSwgJ21hcm9vbic6IFsxMjgsMCwwLDFdLFxuICAgICAgICAnbWVkaXVtYXF1YW1hcmluZSc6IFsxMDIsMjA1LDE3MCwxXSwgJ21lZGl1bWJsdWUnOiBbMCwwLDIwNSwxXSxcbiAgICAgICAgJ21lZGl1bW9yY2hpZCc6IFsxODYsODUsMjExLDFdLCAnbWVkaXVtcHVycGxlJzogWzE0NywxMTIsMjE5LDFdLFxuICAgICAgICAnbWVkaXVtc2VhZ3JlZW4nOiBbNjAsMTc5LDExMywxXSwgJ21lZGl1bXNsYXRlYmx1ZSc6IFsxMjMsMTA0LDIzOCwxXSxcbiAgICAgICAgJ21lZGl1bXNwcmluZ2dyZWVuJzogWzAsMjUwLDE1NCwxXSwgJ21lZGl1bXR1cnF1b2lzZSc6IFs3MiwyMDksMjA0LDFdLFxuICAgICAgICAnbWVkaXVtdmlvbGV0cmVkJzogWzE5OSwyMSwxMzMsMV0sICdtaWRuaWdodGJsdWUnOiBbMjUsMjUsMTEyLDFdLFxuICAgICAgICAnbWludGNyZWFtJzogWzI0NSwyNTUsMjUwLDFdLCAnbWlzdHlyb3NlJzogWzI1NSwyMjgsMjI1LDFdLFxuICAgICAgICAnbW9jY2FzaW4nOiBbMjU1LDIyOCwxODEsMV0sICduYXZham93aGl0ZSc6IFsyNTUsMjIyLDE3MywxXSxcbiAgICAgICAgJ25hdnknOiBbMCwwLDEyOCwxXSwgJ29sZGxhY2UnOiBbMjUzLDI0NSwyMzAsMV0sXG4gICAgICAgICdvbGl2ZSc6IFsxMjgsMTI4LDAsMV0sICdvbGl2ZWRyYWInOiBbMTA3LDE0MiwzNSwxXSxcbiAgICAgICAgJ29yYW5nZSc6IFsyNTUsMTY1LDAsMV0sICdvcmFuZ2VyZWQnOiBbMjU1LDY5LDAsMV0sXG4gICAgICAgICdvcmNoaWQnOiBbMjE4LDExMiwyMTQsMV0sICdwYWxlZ29sZGVucm9kJzogWzIzOCwyMzIsMTcwLDFdLFxuICAgICAgICAncGFsZWdyZWVuJzogWzE1MiwyNTEsMTUyLDFdLCAncGFsZXR1cnF1b2lzZSc6IFsxNzUsMjM4LDIzOCwxXSxcbiAgICAgICAgJ3BhbGV2aW9sZXRyZWQnOiBbMjE5LDExMiwxNDcsMV0sICdwYXBheWF3aGlwJzogWzI1NSwyMzksMjEzLDFdLFxuICAgICAgICAncGVhY2hwdWZmJzogWzI1NSwyMTgsMTg1LDFdLCAncGVydSc6IFsyMDUsMTMzLDYzLDFdLFxuICAgICAgICAncGluayc6IFsyNTUsMTkyLDIwMywxXSwgJ3BsdW0nOiBbMjIxLDE2MCwyMjEsMV0sXG4gICAgICAgICdwb3dkZXJibHVlJzogWzE3NiwyMjQsMjMwLDFdLCAncHVycGxlJzogWzEyOCwwLDEyOCwxXSxcbiAgICAgICAgJ3JlZCc6IFsyNTUsMCwwLDFdLCAncm9zeWJyb3duJzogWzE4OCwxNDMsMTQzLDFdLFxuICAgICAgICAncm95YWxibHVlJzogWzY1LDEwNSwyMjUsMV0sICdzYWRkbGVicm93bic6IFsxMzksNjksMTksMV0sXG4gICAgICAgICdzYWxtb24nOiBbMjUwLDEyOCwxMTQsMV0sICdzYW5keWJyb3duJzogWzI0NCwxNjQsOTYsMV0sXG4gICAgICAgICdzZWFncmVlbic6IFs0NiwxMzksODcsMV0sICdzZWFzaGVsbCc6IFsyNTUsMjQ1LDIzOCwxXSxcbiAgICAgICAgJ3NpZW5uYSc6IFsxNjAsODIsNDUsMV0sICdzaWx2ZXInOiBbMTkyLDE5MiwxOTIsMV0sXG4gICAgICAgICdza3libHVlJzogWzEzNSwyMDYsMjM1LDFdLCAnc2xhdGVibHVlJzogWzEwNiw5MCwyMDUsMV0sXG4gICAgICAgICdzbGF0ZWdyYXknOiBbMTEyLDEyOCwxNDQsMV0sICdzbGF0ZWdyZXknOiBbMTEyLDEyOCwxNDQsMV0sXG4gICAgICAgICdzbm93JzogWzI1NSwyNTAsMjUwLDFdLCAnc3ByaW5nZ3JlZW4nOiBbMCwyNTUsMTI3LDFdLFxuICAgICAgICAnc3RlZWxibHVlJzogWzcwLDEzMCwxODAsMV0sICd0YW4nOiBbMjEwLDE4MCwxNDAsMV0sXG4gICAgICAgICd0ZWFsJzogWzAsMTI4LDEyOCwxXSwgJ3RoaXN0bGUnOiBbMjE2LDE5MSwyMTYsMV0sXG4gICAgICAgICd0b21hdG8nOiBbMjU1LDk5LDcxLDFdLCAndHVycXVvaXNlJzogWzY0LDIyNCwyMDgsMV0sXG4gICAgICAgICd2aW9sZXQnOiBbMjM4LDEzMCwyMzgsMV0sICd3aGVhdCc6IFsyNDUsMjIyLDE3OSwxXSxcbiAgICAgICAgJ3doaXRlJzogWzI1NSwyNTUsMjU1LDFdLCAnd2hpdGVzbW9rZSc6IFsyNDUsMjQ1LDI0NSwxXSxcbiAgICAgICAgJ3llbGxvdyc6IFsyNTUsMjU1LDAsMV0sICd5ZWxsb3dncmVlbic6IFsxNTQsMjA1LDUwLDFdXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGNsYW1wQ3NzQnl0ZShpKSB7ICAvLyBDbGFtcCB0byBpbnRlZ2VyIDAgLi4gMjU1LlxuICAgICAgICBpID0gTWF0aC5yb3VuZChpKTsgIC8vIFNlZW1zIHRvIGJlIHdoYXQgQ2hyb21lIGRvZXMgKHZzIHRydW5jYXRpb24pLlxuICAgICAgICByZXR1cm4gaSA8IDAgPyAwIDogaSA+IDI1NSA/IDI1NSA6IGk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xhbXBDc3NBbmdsZShpKSB7ICAvLyBDbGFtcCB0byBpbnRlZ2VyIDAgLi4gMzYwLlxuICAgICAgICBpID0gTWF0aC5yb3VuZChpKTsgIC8vIFNlZW1zIHRvIGJlIHdoYXQgQ2hyb21lIGRvZXMgKHZzIHRydW5jYXRpb24pLlxuICAgICAgICByZXR1cm4gaSA8IDAgPyAwIDogaSA+IDM2MCA/IDM2MCA6IGk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xhbXBDc3NGbG9hdChmKSB7ICAvLyBDbGFtcCB0byBmbG9hdCAwLjAgLi4gMS4wLlxuICAgICAgICByZXR1cm4gZiA8IDAgPyAwIDogZiA+IDEgPyAxIDogZjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUNzc0ludChzdHIpIHsgIC8vIGludCBvciBwZXJjZW50YWdlLlxuICAgICAgICBpZiAoc3RyLmxlbmd0aCAmJiBzdHIuY2hhckF0KHN0ci5sZW5ndGggLSAxKSA9PT0gJyUnKSB7XG4gICAgICAgICAgICByZXR1cm4gY2xhbXBDc3NCeXRlKHBhcnNlRmxvYXQoc3RyKSAvIDEwMCAqIDI1NSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNsYW1wQ3NzQnl0ZShwYXJzZUludChzdHIsIDEwKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VDc3NGbG9hdChzdHIpIHsgIC8vIGZsb2F0IG9yIHBlcmNlbnRhZ2UuXG4gICAgICAgIGlmIChzdHIubGVuZ3RoICYmIHN0ci5jaGFyQXQoc3RyLmxlbmd0aCAtIDEpID09PSAnJScpIHtcbiAgICAgICAgICAgIHJldHVybiBjbGFtcENzc0Zsb2F0KHBhcnNlRmxvYXQoc3RyKSAvIDEwMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNsYW1wQ3NzRmxvYXQocGFyc2VGbG9hdChzdHIpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjc3NIdWVUb1JnYihtMSwgbTIsIGgpIHtcbiAgICAgICAgaWYgKGggPCAwKSB7XG4gICAgICAgICAgICBoICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaCA+IDEpIHtcbiAgICAgICAgICAgIGggLT0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoICogNiA8IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBtMSArIChtMiAtIG0xKSAqIGggKiA2O1xuICAgICAgICB9XG4gICAgICAgIGlmIChoICogMiA8IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBtMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaCAqIDMgPCAyKSB7XG4gICAgICAgICAgICByZXR1cm4gbTEgKyAobTIgLSBtMSkgKiAoMi8zIC0gaCkgKiA2O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtMTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsZXJwKGEsIGIsIHApIHtcbiAgICAgICAgcmV0dXJuIGEgKyAoYiAtIGEpICogcDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRSZ2JhKG91dCwgciwgZywgYiwgYSkge1xuICAgICAgICBvdXRbMF0gPSByOyBvdXRbMV0gPSBnOyBvdXRbMl0gPSBiOyBvdXRbM10gPSBhO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb3B5UmdiYShvdXQsIGEpIHtcbiAgICAgICAgb3V0WzBdID0gYVswXTsgb3V0WzFdID0gYVsxXTsgb3V0WzJdID0gYVsyXTsgb3V0WzNdID0gYVszXTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgdmFyIGNvbG9yQ2FjaGUgPSBuZXcgTFJVKDIwKTtcbiAgICB2YXIgbGFzdFJlbW92ZWRBcnIgPSBudWxsO1xuICAgIGZ1bmN0aW9uIHB1dFRvQ2FjaGUoY29sb3JTdHIsIHJnYmFBcnIpIHtcbiAgICAgICAgLy8gUmV1c2UgcmVtb3ZlZCBhcnJheVxuICAgICAgICBpZiAobGFzdFJlbW92ZWRBcnIpIHtcbiAgICAgICAgICAgIGNvcHlSZ2JhKGxhc3RSZW1vdmVkQXJyLCByZ2JhQXJyKTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0UmVtb3ZlZEFyciA9IGNvbG9yQ2FjaGUucHV0KGNvbG9yU3RyLCBsYXN0UmVtb3ZlZEFyciB8fCAocmdiYUFyci5zbGljZSgpKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvclN0clxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IG91dFxuICAgICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci91dGlsL2NvbG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFyc2UoY29sb3JTdHIsIHJnYmFBcnIpIHtcbiAgICAgICAgaWYgKCFjb2xvclN0cikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJnYmFBcnIgPSByZ2JhQXJyIHx8IFtdO1xuXG4gICAgICAgIHZhciBjYWNoZWQgPSBjb2xvckNhY2hlLmdldChjb2xvclN0cik7XG4gICAgICAgIGlmIChjYWNoZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBjb3B5UmdiYShyZ2JhQXJyLCBjYWNoZWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY29sb3JTdHIgbWF5IGJlIG5vdCBzdHJpbmdcbiAgICAgICAgY29sb3JTdHIgPSBjb2xvclN0ciArICcnO1xuICAgICAgICAvLyBSZW1vdmUgYWxsIHdoaXRlc3BhY2UsIG5vdCBjb21wbGlhbnQsIGJ1dCBzaG91bGQganVzdCBiZSBtb3JlIGFjY2VwdGluZy5cbiAgICAgICAgdmFyIHN0ciA9IGNvbG9yU3RyLnJlcGxhY2UoLyAvZywgJycpLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgLy8gQ29sb3Iga2V5d29yZHMgKGFuZCB0cmFuc3BhcmVudCkgbG9va3VwLlxuICAgICAgICBpZiAoc3RyIGluIGtDU1NDb2xvclRhYmxlKSB7XG4gICAgICAgICAgICBjb3B5UmdiYShyZ2JhQXJyLCBrQ1NTQ29sb3JUYWJsZVtzdHJdKTtcbiAgICAgICAgICAgIHB1dFRvQ2FjaGUoY29sb3JTdHIsIHJnYmFBcnIpO1xuICAgICAgICAgICAgcmV0dXJuIHJnYmFBcnI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAjYWJjIGFuZCAjYWJjMTIzIHN5bnRheC5cbiAgICAgICAgaWYgKHN0ci5jaGFyQXQoMCkgPT09ICcjJykge1xuICAgICAgICAgICAgaWYgKHN0ci5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXYgPSBwYXJzZUludChzdHIuc3Vic3RyKDEpLCAxNik7ICAvLyBUT0RPKGRlYW5tKTogU3RyaWN0ZXIgcGFyc2luZy5cbiAgICAgICAgICAgICAgICBpZiAoIShpdiA+PSAwICYmIGl2IDw9IDB4ZmZmKSkge1xuICAgICAgICAgICAgICAgICAgICBzZXRSZ2JhKHJnYmFBcnIsIDAsIDAsIDAsIDEpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47ICAvLyBDb3ZlcnMgTmFOLlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZXRSZ2JhKHJnYmFBcnIsXG4gICAgICAgICAgICAgICAgICAgICgoaXYgJiAweGYwMCkgPj4gNCkgfCAoKGl2ICYgMHhmMDApID4+IDgpLFxuICAgICAgICAgICAgICAgICAgICAoaXYgJiAweGYwKSB8ICgoaXYgJiAweGYwKSA+PiA0KSxcbiAgICAgICAgICAgICAgICAgICAgKGl2ICYgMHhmKSB8ICgoaXYgJiAweGYpIDw8IDQpLFxuICAgICAgICAgICAgICAgICAgICAxXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBwdXRUb0NhY2hlKGNvbG9yU3RyLCByZ2JhQXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmdiYUFycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHN0ci5sZW5ndGggPT09IDcpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXYgPSBwYXJzZUludChzdHIuc3Vic3RyKDEpLCAxNik7ICAvLyBUT0RPKGRlYW5tKTogU3RyaWN0ZXIgcGFyc2luZy5cbiAgICAgICAgICAgICAgICBpZiAoIShpdiA+PSAwICYmIGl2IDw9IDB4ZmZmZmZmKSkge1xuICAgICAgICAgICAgICAgICAgICBzZXRSZ2JhKHJnYmFBcnIsIDAsIDAsIDAsIDEpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47ICAvLyBDb3ZlcnMgTmFOLlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZXRSZ2JhKHJnYmFBcnIsXG4gICAgICAgICAgICAgICAgICAgIChpdiAmIDB4ZmYwMDAwKSA+PiAxNixcbiAgICAgICAgICAgICAgICAgICAgKGl2ICYgMHhmZjAwKSA+PiA4LFxuICAgICAgICAgICAgICAgICAgICBpdiAmIDB4ZmYsXG4gICAgICAgICAgICAgICAgICAgIDFcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHB1dFRvQ2FjaGUoY29sb3JTdHIsIHJnYmFBcnIpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZ2JhQXJyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9wID0gc3RyLmluZGV4T2YoJygnKSwgZXAgPSBzdHIuaW5kZXhPZignKScpO1xuICAgICAgICBpZiAob3AgIT09IC0xICYmIGVwICsgMSA9PT0gc3RyLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGZuYW1lID0gc3RyLnN1YnN0cigwLCBvcCk7XG4gICAgICAgICAgICB2YXIgcGFyYW1zID0gc3RyLnN1YnN0cihvcCArIDEsIGVwIC0gKG9wICsgMSkpLnNwbGl0KCcsJyk7XG4gICAgICAgICAgICB2YXIgYWxwaGEgPSAxOyAgLy8gVG8gYWxsb3cgY2FzZSBmYWxsdGhyb3VnaC5cbiAgICAgICAgICAgIHN3aXRjaCAoZm5hbWUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdyZ2JhJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggIT09IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFJnYmEocmdiYUFyciwgMCwgMCwgMCwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYWxwaGEgPSBwYXJzZUNzc0Zsb2F0KHBhcmFtcy5wb3AoKSk7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgICAgICAgICAgICAgIC8vIEZhbGwgdGhyb3VnaC5cbiAgICAgICAgICAgICAgICBjYXNlICdyZ2InOlxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCAhPT0gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0UmdiYShyZ2JhQXJyLCAwLCAwLCAwLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZXRSZ2JhKHJnYmFBcnIsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUNzc0ludChwYXJhbXNbMF0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VDc3NJbnQocGFyYW1zWzFdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlQ3NzSW50KHBhcmFtc1syXSksXG4gICAgICAgICAgICAgICAgICAgICAgICBhbHBoYVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBwdXRUb0NhY2hlKGNvbG9yU3RyLCByZ2JhQXJyKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJnYmFBcnI7XG4gICAgICAgICAgICAgICAgY2FzZSAnaHNsYSc6XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMubGVuZ3RoICE9PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRSZ2JhKHJnYmFBcnIsIDAsIDAsIDAsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtc1szXSA9IHBhcnNlQ3NzRmxvYXQocGFyYW1zWzNdKTtcbiAgICAgICAgICAgICAgICAgICAgaHNsYTJyZ2JhKHBhcmFtcywgcmdiYUFycik7XG4gICAgICAgICAgICAgICAgICAgIHB1dFRvQ2FjaGUoY29sb3JTdHIsIHJnYmFBcnIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmdiYUFycjtcbiAgICAgICAgICAgICAgICBjYXNlICdoc2wnOlxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCAhPT0gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0UmdiYShyZ2JhQXJyLCAwLCAwLCAwLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBoc2xhMnJnYmEocGFyYW1zLCByZ2JhQXJyKTtcbiAgICAgICAgICAgICAgICAgICAgcHV0VG9DYWNoZShjb2xvclN0ciwgcmdiYUFycik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZ2JhQXJyO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHNldFJnYmEocmdiYUFyciwgMCwgMCwgMCwgMSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBoc2xhXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gcmdiYVxuICAgICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fSByZ2JhXG4gICAgICovXG4gICAgZnVuY3Rpb24gaHNsYTJyZ2JhKGhzbGEsIHJnYmEpIHtcbiAgICAgICAgdmFyIGggPSAoKChwYXJzZUZsb2F0KGhzbGFbMF0pICUgMzYwKSArIDM2MCkgJSAzNjApIC8gMzYwOyAgLy8gMCAuLiAxXG4gICAgICAgIC8vIE5PVEUoZGVhbm0pOiBBY2NvcmRpbmcgdG8gdGhlIENTUyBzcGVjIHMvbCBzaG91bGQgb25seSBiZVxuICAgICAgICAvLyBwZXJjZW50YWdlcywgYnV0IHdlIGRvbid0IGJvdGhlciBhbmQgbGV0IGZsb2F0IG9yIHBlcmNlbnRhZ2UuXG4gICAgICAgIHZhciBzID0gcGFyc2VDc3NGbG9hdChoc2xhWzFdKTtcbiAgICAgICAgdmFyIGwgPSBwYXJzZUNzc0Zsb2F0KGhzbGFbMl0pO1xuICAgICAgICB2YXIgbTIgPSBsIDw9IDAuNSA/IGwgKiAocyArIDEpIDogbCArIHMgLSBsICogcztcbiAgICAgICAgdmFyIG0xID0gbCAqIDIgLSBtMjtcblxuICAgICAgICByZ2JhID0gcmdiYSB8fCBbXTtcbiAgICAgICAgc2V0UmdiYShyZ2JhLFxuICAgICAgICAgICAgY2xhbXBDc3NCeXRlKGNzc0h1ZVRvUmdiKG0xLCBtMiwgaCArIDEgLyAzKSAqIDI1NSksXG4gICAgICAgICAgICBjbGFtcENzc0J5dGUoY3NzSHVlVG9SZ2IobTEsIG0yLCBoKSAqIDI1NSksXG4gICAgICAgICAgICBjbGFtcENzc0J5dGUoY3NzSHVlVG9SZ2IobTEsIG0yLCBoIC0gMSAvIDMpICogMjU1KSxcbiAgICAgICAgICAgIDFcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAoaHNsYS5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgICAgIHJnYmFbM10gPSBoc2xhWzNdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJnYmE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gcmdiYVxuICAgICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fSBoc2xhXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmdiYTJoc2xhKHJnYmEpIHtcbiAgICAgICAgaWYgKCFyZ2JhKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSR0IgZnJvbSAwIHRvIDI1NVxuICAgICAgICB2YXIgUiA9IHJnYmFbMF0gLyAyNTU7XG4gICAgICAgIHZhciBHID0gcmdiYVsxXSAvIDI1NTtcbiAgICAgICAgdmFyIEIgPSByZ2JhWzJdIC8gMjU1O1xuXG4gICAgICAgIHZhciB2TWluID0gTWF0aC5taW4oUiwgRywgQik7IC8vIE1pbi4gdmFsdWUgb2YgUkdCXG4gICAgICAgIHZhciB2TWF4ID0gTWF0aC5tYXgoUiwgRywgQik7IC8vIE1heC4gdmFsdWUgb2YgUkdCXG4gICAgICAgIHZhciBkZWx0YSA9IHZNYXggLSB2TWluOyAvLyBEZWx0YSBSR0IgdmFsdWVcblxuICAgICAgICB2YXIgTCA9ICh2TWF4ICsgdk1pbikgLyAyO1xuICAgICAgICB2YXIgSDtcbiAgICAgICAgdmFyIFM7XG4gICAgICAgIC8vIEhTTCByZXN1bHRzIGZyb20gMCB0byAxXG4gICAgICAgIGlmIChkZWx0YSA9PT0gMCkge1xuICAgICAgICAgICAgSCA9IDA7XG4gICAgICAgICAgICBTID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChMIDwgMC41KSB7XG4gICAgICAgICAgICAgICAgUyA9IGRlbHRhIC8gKHZNYXggKyB2TWluKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIFMgPSBkZWx0YSAvICgyIC0gdk1heCAtIHZNaW4pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZGVsdGFSID0gKCgodk1heCAtIFIpIC8gNikgKyAoZGVsdGEgLyAyKSkgLyBkZWx0YTtcbiAgICAgICAgICAgIHZhciBkZWx0YUcgPSAoKCh2TWF4IC0gRykgLyA2KSArIChkZWx0YSAvIDIpKSAvIGRlbHRhO1xuICAgICAgICAgICAgdmFyIGRlbHRhQiA9ICgoKHZNYXggLSBCKSAvIDYpICsgKGRlbHRhIC8gMikpIC8gZGVsdGE7XG5cbiAgICAgICAgICAgIGlmIChSID09PSB2TWF4KSB7XG4gICAgICAgICAgICAgICAgSCA9IGRlbHRhQiAtIGRlbHRhRztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEcgPT09IHZNYXgpIHtcbiAgICAgICAgICAgICAgICBIID0gKDEgLyAzKSArIGRlbHRhUiAtIGRlbHRhQjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEIgPT09IHZNYXgpIHtcbiAgICAgICAgICAgICAgICBIID0gKDIgLyAzKSArIGRlbHRhRyAtIGRlbHRhUjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKEggPCAwKSB7XG4gICAgICAgICAgICAgICAgSCArPSAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoSCA+IDEpIHtcbiAgICAgICAgICAgICAgICBIIC09IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaHNsYSA9IFtIICogMzYwLCBTLCBMXTtcblxuICAgICAgICBpZiAocmdiYVszXSAhPSBudWxsKSB7XG4gICAgICAgICAgICBoc2xhLnB1c2gocmdiYVszXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaHNsYTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sb3JcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGV2ZWxcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL3V0aWwvY29sb3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsaWZ0KGNvbG9yLCBsZXZlbCkge1xuICAgICAgICB2YXIgY29sb3JBcnIgPSBwYXJzZShjb2xvcik7XG4gICAgICAgIGlmIChjb2xvckFycikge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAobGV2ZWwgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yQXJyW2ldID0gY29sb3JBcnJbaV0gKiAoMSAtIGxldmVsKSB8IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb2xvckFycltpXSA9ICgoMjU1IC0gY29sb3JBcnJbaV0pICogbGV2ZWwgKyBjb2xvckFycltpXSkgfCAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdHJpbmdpZnkoY29sb3JBcnIsIGNvbG9yQXJyLmxlbmd0aCA9PT0gNCA/ICdyZ2JhJyA6ICdyZ2InKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvclxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvdXRpbC9jb2xvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvSGV4KGNvbG9yLCBsZXZlbCkge1xuICAgICAgICB2YXIgY29sb3JBcnIgPSBwYXJzZShjb2xvcik7XG4gICAgICAgIGlmIChjb2xvckFycikge1xuICAgICAgICAgICAgcmV0dXJuICgoMSA8PCAyNCkgKyAoY29sb3JBcnJbMF0gPDwgMTYpICsgKGNvbG9yQXJyWzFdIDw8IDgpICsgKCtjb2xvckFyclsyXSkpLnRvU3RyaW5nKDE2KS5zbGljZSgxKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1hcCB2YWx1ZSB0byBjb2xvci4gRmFzdGVyIHRoYW4gbWFwVG9Db2xvciBtZXRob2RzIGJlY2F1c2UgY29sb3IgaXMgcmVwcmVzZW50ZWQgYnkgcmdiYSBhcnJheS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbm9ybWFsaXplZFZhbHVlIEEgZmxvYXQgYmV0d2VlbiAwIGFuZCAxLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPEFycmF5LjxudW1iZXI+Pn0gY29sb3JzIExpc3Qgb2YgcmdiYSBjb2xvciBhcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IFtvdXRdIE1hcHBlZCBnYmEgY29sb3IgYXJyYXlcbiAgICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn0gd2lsbCBiZSBudWxsL3VuZGVmaW5lZCBpZiBpbnB1dCBpbGxlZ2FsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZhc3RNYXBUb0NvbG9yKG5vcm1hbGl6ZWRWYWx1ZSwgY29sb3JzLCBvdXQpIHtcbiAgICAgICAgaWYgKCEoY29sb3JzICYmIGNvbG9ycy5sZW5ndGgpXG4gICAgICAgICAgICB8fCAhKG5vcm1hbGl6ZWRWYWx1ZSA+PSAwICYmIG5vcm1hbGl6ZWRWYWx1ZSA8PSAxKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIG91dCA9IG91dCB8fCBbXTtcblxuICAgICAgICB2YXIgdmFsdWUgPSBub3JtYWxpemVkVmFsdWUgKiAoY29sb3JzLmxlbmd0aCAtIDEpO1xuICAgICAgICB2YXIgbGVmdEluZGV4ID0gTWF0aC5mbG9vcih2YWx1ZSk7XG4gICAgICAgIHZhciByaWdodEluZGV4ID0gTWF0aC5jZWlsKHZhbHVlKTtcbiAgICAgICAgdmFyIGxlZnRDb2xvciA9IGNvbG9yc1tsZWZ0SW5kZXhdO1xuICAgICAgICB2YXIgcmlnaHRDb2xvciA9IGNvbG9yc1tyaWdodEluZGV4XTtcbiAgICAgICAgdmFyIGR2ID0gdmFsdWUgLSBsZWZ0SW5kZXg7XG4gICAgICAgIG91dFswXSA9IGNsYW1wQ3NzQnl0ZShsZXJwKGxlZnRDb2xvclswXSwgcmlnaHRDb2xvclswXSwgZHYpKTtcbiAgICAgICAgb3V0WzFdID0gY2xhbXBDc3NCeXRlKGxlcnAobGVmdENvbG9yWzFdLCByaWdodENvbG9yWzFdLCBkdikpO1xuICAgICAgICBvdXRbMl0gPSBjbGFtcENzc0J5dGUobGVycChsZWZ0Q29sb3JbMl0sIHJpZ2h0Q29sb3JbMl0sIGR2KSk7XG4gICAgICAgIG91dFszXSA9IGNsYW1wQ3NzRmxvYXQobGVycChsZWZ0Q29sb3JbM10sIHJpZ2h0Q29sb3JbM10sIGR2KSk7XG5cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG5vcm1hbGl6ZWRWYWx1ZSBBIGZsb2F0IGJldHdlZW4gMCBhbmQgMS5cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBjb2xvcnMgQ29sb3IgbGlzdC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBmdWxsT3V0cHV0IERlZmF1bHQgZmFsc2UuXG4gICAgICogQHJldHVybiB7KHN0cmluZ3xPYmplY3QpfSBSZXN1bHQgY29sb3IuIElmIGZ1bGxPdXRwdXQsXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge2NvbG9yOiAuLi4sIGxlZnRJbmRleDogLi4uLCByaWdodEluZGV4OiAuLi4sIHZhbHVlOiAuLi59LFxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci91dGlsL2NvbG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwVG9Db2xvcihub3JtYWxpemVkVmFsdWUsIGNvbG9ycywgZnVsbE91dHB1dCkge1xuICAgICAgICBpZiAoIShjb2xvcnMgJiYgY29sb3JzLmxlbmd0aClcbiAgICAgICAgICAgIHx8ICEobm9ybWFsaXplZFZhbHVlID49IDAgJiYgbm9ybWFsaXplZFZhbHVlIDw9IDEpXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHZhbHVlID0gbm9ybWFsaXplZFZhbHVlICogKGNvbG9ycy5sZW5ndGggLSAxKTtcbiAgICAgICAgdmFyIGxlZnRJbmRleCA9IE1hdGguZmxvb3IodmFsdWUpO1xuICAgICAgICB2YXIgcmlnaHRJbmRleCA9IE1hdGguY2VpbCh2YWx1ZSk7XG4gICAgICAgIHZhciBsZWZ0Q29sb3IgPSBwYXJzZShjb2xvcnNbbGVmdEluZGV4XSk7XG4gICAgICAgIHZhciByaWdodENvbG9yID0gcGFyc2UoY29sb3JzW3JpZ2h0SW5kZXhdKTtcbiAgICAgICAgdmFyIGR2ID0gdmFsdWUgLSBsZWZ0SW5kZXg7XG5cbiAgICAgICAgdmFyIGNvbG9yID0gc3RyaW5naWZ5KFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIGNsYW1wQ3NzQnl0ZShsZXJwKGxlZnRDb2xvclswXSwgcmlnaHRDb2xvclswXSwgZHYpKSxcbiAgICAgICAgICAgICAgICBjbGFtcENzc0J5dGUobGVycChsZWZ0Q29sb3JbMV0sIHJpZ2h0Q29sb3JbMV0sIGR2KSksXG4gICAgICAgICAgICAgICAgY2xhbXBDc3NCeXRlKGxlcnAobGVmdENvbG9yWzJdLCByaWdodENvbG9yWzJdLCBkdikpLFxuICAgICAgICAgICAgICAgIGNsYW1wQ3NzRmxvYXQobGVycChsZWZ0Q29sb3JbM10sIHJpZ2h0Q29sb3JbM10sIGR2KSlcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAncmdiYSdcbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4gZnVsbE91dHB1dFxuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgY29sb3I6IGNvbG9yLFxuICAgICAgICAgICAgICAgIGxlZnRJbmRleDogbGVmdEluZGV4LFxuICAgICAgICAgICAgICAgIHJpZ2h0SW5kZXg6IHJpZ2h0SW5kZXgsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA6IGNvbG9yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gaCAwIH4gMzYwLCBpZ25vcmUgd2hlbiBudWxsLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gcyAwIH4gMSwgaWdub3JlIHdoZW4gbnVsbC5cbiAgICAgKiBAcGFyYW0ge251bWJlcj19IGwgMCB+IDEsIGlnbm9yZSB3aGVuIG51bGwuXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBDb2xvciBzdHJpbmcgaW4gcmdiYSBmb3JtYXQuXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL3V0aWwvY29sb3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtb2RpZnlIU0woY29sb3IsIGgsIHMsIGwpIHtcbiAgICAgICAgY29sb3IgPSBwYXJzZShjb2xvcik7XG5cbiAgICAgICAgaWYgKGNvbG9yKSB7XG4gICAgICAgICAgICBjb2xvciA9IHJnYmEyaHNsYShjb2xvcik7XG4gICAgICAgICAgICBoICE9IG51bGwgJiYgKGNvbG9yWzBdID0gY2xhbXBDc3NBbmdsZShoKSk7XG4gICAgICAgICAgICBzICE9IG51bGwgJiYgKGNvbG9yWzFdID0gcGFyc2VDc3NGbG9hdChzKSk7XG4gICAgICAgICAgICBsICE9IG51bGwgJiYgKGNvbG9yWzJdID0gcGFyc2VDc3NGbG9hdChsKSk7XG5cbiAgICAgICAgICAgIHJldHVybiBzdHJpbmdpZnkoaHNsYTJyZ2JhKGNvbG9yKSwgJ3JnYmEnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gYWxwaGEgMCB+IDFcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IENvbG9yIHN0cmluZyBpbiByZ2JhIGZvcm1hdC5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvdXRpbC9jb2xvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1vZGlmeUFscGhhKGNvbG9yLCBhbHBoYSkge1xuICAgICAgICBjb2xvciA9IHBhcnNlKGNvbG9yKTtcblxuICAgICAgICBpZiAoY29sb3IgJiYgYWxwaGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgY29sb3JbM10gPSBjbGFtcENzc0Zsb2F0KGFscGhhKTtcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmdpZnkoY29sb3IsICdyZ2JhJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBhcnJDb2xvciBsaWtlIFsxMiwzMyw0NCwwLjRdXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgJ3JnYmEnLCAnaHN2YScsIC4uLlxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gUmVzdWx0IGNvbG9yLiAoSWYgaW5wdXQgaWxsZWdhbCwgcmV0dXJuIHVuZGVmaW5lZCkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RyaW5naWZ5KGFyckNvbG9yLCB0eXBlKSB7XG4gICAgICAgIGlmICghYXJyQ29sb3IgfHwgIWFyckNvbG9yLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb2xvclN0ciA9IGFyckNvbG9yWzBdICsgJywnICsgYXJyQ29sb3JbMV0gKyAnLCcgKyBhcnJDb2xvclsyXTtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdyZ2JhJyB8fCB0eXBlID09PSAnaHN2YScgfHwgdHlwZSA9PT0gJ2hzbGEnKSB7XG4gICAgICAgICAgICBjb2xvclN0ciArPSAnLCcgKyBhcnJDb2xvclszXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHlwZSArICcoJyArIGNvbG9yU3RyICsgJyknO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBwYXJzZTogcGFyc2UsXG4gICAgICAgIGxpZnQ6IGxpZnQsXG4gICAgICAgIHRvSGV4OiB0b0hleCxcbiAgICAgICAgZmFzdE1hcFRvQ29sb3I6IGZhc3RNYXBUb0NvbG9yLFxuICAgICAgICBtYXBUb0NvbG9yOiBtYXBUb0NvbG9yLFxuICAgICAgICBtb2RpZnlIU0w6IG1vZGlmeUhTTCxcbiAgICAgICAgbW9kaWZ5QWxwaGE6IG1vZGlmeUFscGhhLFxuICAgICAgICBzdHJpbmdpZnk6IHN0cmluZ2lmeVxuICAgIH07XG5cblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2hvbWUveXgvfi96cmVuZGVyL2xpYi90b29sL2NvbG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAyMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 22 */
/* unknown exports provided */
/* all exports used */
/*!************************************************!*\
  !*** /home/yx/~/zrender/lib/mixin/Eventful.js ***!
  \************************************************/
/***/ (function(module, exports) {

eval("/**\n * 事件扩展\n * @module zrender/mixin/Eventful\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n *         pissang (https://www.github.com/pissang)\n */\n\n\n    var arrySlice = Array.prototype.slice;\n\n    /**\n     * 事件分发器\n     * @alias module:zrender/mixin/Eventful\n     * @constructor\n     */\n    var Eventful = function () {\n        this._$handlers = {};\n    };\n\n    Eventful.prototype = {\n\n        constructor: Eventful,\n\n        /**\n         * 单次触发绑定，trigger后销毁\n         *\n         * @param {string} event 事件名\n         * @param {Function} handler 响应函数\n         * @param {Object} context\n         */\n        one: function (event, handler, context) {\n            var _h = this._$handlers;\n\n            if (!handler || !event) {\n                return this;\n            }\n\n            if (!_h[event]) {\n                _h[event] = [];\n            }\n\n            for (var i = 0; i < _h[event].length; i++) {\n                if (_h[event][i].h === handler) {\n                    return this;\n                }\n            }\n\n            _h[event].push({\n                h: handler,\n                one: true,\n                ctx: context || this\n            });\n\n            return this;\n        },\n\n        /**\n         * 绑定事件\n         * @param {string} event 事件名\n         * @param {Function} handler 事件处理函数\n         * @param {Object} [context]\n         */\n        on: function (event, handler, context) {\n            var _h = this._$handlers;\n\n            if (!handler || !event) {\n                return this;\n            }\n\n            if (!_h[event]) {\n                _h[event] = [];\n            }\n\n            for (var i = 0; i < _h[event].length; i++) {\n                if (_h[event][i].h === handler) {\n                    return this;\n                }\n            }\n\n            _h[event].push({\n                h: handler,\n                one: false,\n                ctx: context || this\n            });\n\n            return this;\n        },\n\n        /**\n         * 是否绑定了事件\n         * @param  {string}  event\n         * @return {boolean}\n         */\n        isSilent: function (event) {\n            var _h = this._$handlers;\n            return _h[event] && _h[event].length;\n        },\n\n        /**\n         * 解绑事件\n         * @param {string} event 事件名\n         * @param {Function} [handler] 事件处理函数\n         */\n        off: function (event, handler) {\n            var _h = this._$handlers;\n\n            if (!event) {\n                this._$handlers = {};\n                return this;\n            }\n\n            if (handler) {\n                if (_h[event]) {\n                    var newList = [];\n                    for (var i = 0, l = _h[event].length; i < l; i++) {\n                        if (_h[event][i]['h'] != handler) {\n                            newList.push(_h[event][i]);\n                        }\n                    }\n                    _h[event] = newList;\n                }\n\n                if (_h[event] && _h[event].length === 0) {\n                    delete _h[event];\n                }\n            }\n            else {\n                delete _h[event];\n            }\n\n            return this;\n        },\n\n        /**\n         * 事件分发\n         *\n         * @param {string} type 事件类型\n         */\n        trigger: function (type) {\n            if (this._$handlers[type]) {\n                var args = arguments;\n                var argLen = args.length;\n\n                if (argLen > 3) {\n                    args = arrySlice.call(args, 1);\n                }\n\n                var _h = this._$handlers[type];\n                var len = _h.length;\n                for (var i = 0; i < len;) {\n                    // Optimize advise from backbone\n                    switch (argLen) {\n                        case 1:\n                            _h[i]['h'].call(_h[i]['ctx']);\n                            break;\n                        case 2:\n                            _h[i]['h'].call(_h[i]['ctx'], args[1]);\n                            break;\n                        case 3:\n                            _h[i]['h'].call(_h[i]['ctx'], args[1], args[2]);\n                            break;\n                        default:\n                            // have more than 2 given arguments\n                            _h[i]['h'].apply(_h[i]['ctx'], args);\n                            break;\n                    }\n\n                    if (_h[i]['one']) {\n                        _h.splice(i, 1);\n                        len--;\n                    }\n                    else {\n                        i++;\n                    }\n                }\n            }\n\n            return this;\n        },\n\n        /**\n         * 带有context的事件分发, 最后一个参数是事件回调的context\n         * @param {string} type 事件类型\n         */\n        triggerWithContext: function (type) {\n            if (this._$handlers[type]) {\n                var args = arguments;\n                var argLen = args.length;\n\n                if (argLen > 4) {\n                    args = arrySlice.call(args, 1, args.length - 1);\n                }\n                var ctx = args[args.length - 1];\n\n                var _h = this._$handlers[type];\n                var len = _h.length;\n                for (var i = 0; i < len;) {\n                    // Optimize advise from backbone\n                    switch (argLen) {\n                        case 1:\n                            _h[i]['h'].call(ctx);\n                            break;\n                        case 2:\n                            _h[i]['h'].call(ctx, args[1]);\n                            break;\n                        case 3:\n                            _h[i]['h'].call(ctx, args[1], args[2]);\n                            break;\n                        default:\n                            // have more than 2 given arguments\n                            _h[i]['h'].apply(ctx, args);\n                            break;\n                    }\n\n                    if (_h[i]['one']) {\n                        _h.splice(i, 1);\n                        len--;\n                    }\n                    else {\n                        i++;\n                    }\n                }\n            }\n\n            return this;\n        }\n    };\n\n    // 对象可以通过 onxxxx 绑定事件\n    /**\n     * @event module:zrender/mixin/Eventful#onclick\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmouseover\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmouseout\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmousemove\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmousewheel\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmousedown\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmouseup\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondrag\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragstart\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragend\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragenter\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragleave\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragover\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondrop\n     * @type {Function}\n     * @default null\n     */\n\n    module.exports = Eventful;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL2hvbWUveXgvfi96cmVuZGVyL2xpYi9taXhpbi9FdmVudGZ1bC5qcz9lNDdlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICog5LqL5Lu25omp5bGVXG4gKiBAbW9kdWxlIHpyZW5kZXIvbWl4aW4vRXZlbnRmdWxcbiAqIEBhdXRob3IgS2VuZXIgKEBLZW5lci3mnpfls7AsIGtlbmVyLmxpbmZlbmdAZ21haWwuY29tKVxuICogICAgICAgICBwaXNzYW5nIChodHRwczovL3d3dy5naXRodWIuY29tL3Bpc3NhbmcpXG4gKi9cblxuXG4gICAgdmFyIGFycnlTbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuICAgIC8qKlxuICAgICAqIOS6i+S7tuWIhuWPkeWZqFxuICAgICAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIHZhciBFdmVudGZ1bCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fJGhhbmRsZXJzID0ge307XG4gICAgfTtcblxuICAgIEV2ZW50ZnVsLnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogRXZlbnRmdWwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWNleasoeinpuWPkee7keWumu+8jHRyaWdnZXLlkI7plIDmr4FcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50IOS6i+S7tuWQjVxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIOWTjeW6lOWHveaVsFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICAgICAgICAgKi9cbiAgICAgICAgb25lOiBmdW5jdGlvbiAoZXZlbnQsIGhhbmRsZXIsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciBfaCA9IHRoaXMuXyRoYW5kbGVycztcblxuICAgICAgICAgICAgaWYgKCFoYW5kbGVyIHx8ICFldmVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIV9oW2V2ZW50XSkge1xuICAgICAgICAgICAgICAgIF9oW2V2ZW50XSA9IFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF9oW2V2ZW50XS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChfaFtldmVudF1baV0uaCA9PT0gaGFuZGxlcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9oW2V2ZW50XS5wdXNoKHtcbiAgICAgICAgICAgICAgICBoOiBoYW5kbGVyLFxuICAgICAgICAgICAgICAgIG9uZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjdHg6IGNvbnRleHQgfHwgdGhpc1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDnu5Hlrprkuovku7ZcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50IOS6i+S7tuWQjVxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIOS6i+S7tuWkhOeQhuWHveaVsFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbnRleHRdXG4gICAgICAgICAqL1xuICAgICAgICBvbjogZnVuY3Rpb24gKGV2ZW50LCBoYW5kbGVyLCBjb250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgX2ggPSB0aGlzLl8kaGFuZGxlcnM7XG5cbiAgICAgICAgICAgIGlmICghaGFuZGxlciB8fCAhZXZlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFfaFtldmVudF0pIHtcbiAgICAgICAgICAgICAgICBfaFtldmVudF0gPSBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfaFtldmVudF0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoX2hbZXZlbnRdW2ldLmggPT09IGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfaFtldmVudF0ucHVzaCh7XG4gICAgICAgICAgICAgICAgaDogaGFuZGxlcixcbiAgICAgICAgICAgICAgICBvbmU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGN0eDogY29udGV4dCB8fCB0aGlzXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaYr+WQpue7keWumuS6huS6i+S7tlxuICAgICAgICAgKiBAcGFyYW0gIHtzdHJpbmd9ICBldmVudFxuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgaXNTaWxlbnQ6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdmFyIF9oID0gdGhpcy5fJGhhbmRsZXJzO1xuICAgICAgICAgICAgcmV0dXJuIF9oW2V2ZW50XSAmJiBfaFtldmVudF0ubGVuZ3RoO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDop6Pnu5Hkuovku7ZcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50IOS6i+S7tuWQjVxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaGFuZGxlcl0g5LqL5Lu25aSE55CG5Ye95pWwXG4gICAgICAgICAqL1xuICAgICAgICBvZmY6IGZ1bmN0aW9uIChldmVudCwgaGFuZGxlcikge1xuICAgICAgICAgICAgdmFyIF9oID0gdGhpcy5fJGhhbmRsZXJzO1xuXG4gICAgICAgICAgICBpZiAoIWV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fJGhhbmRsZXJzID0ge307XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKF9oW2V2ZW50XSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3TGlzdCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IF9oW2V2ZW50XS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaFtldmVudF1baV1bJ2gnXSAhPSBoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3TGlzdC5wdXNoKF9oW2V2ZW50XVtpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgX2hbZXZlbnRdID0gbmV3TGlzdDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoX2hbZXZlbnRdICYmIF9oW2V2ZW50XS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIF9oW2V2ZW50XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgX2hbZXZlbnRdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5LqL5Lu25YiG5Y+RXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIOS6i+S7tuexu+Wei1xuICAgICAgICAgKi9cbiAgICAgICAgdHJpZ2dlcjogZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl8kaGFuZGxlcnNbdHlwZV0pIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgICAgICB2YXIgYXJnTGVuID0gYXJncy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICBpZiAoYXJnTGVuID4gMykge1xuICAgICAgICAgICAgICAgICAgICBhcmdzID0gYXJyeVNsaWNlLmNhbGwoYXJncywgMSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIF9oID0gdGhpcy5fJGhhbmRsZXJzW3R5cGVdO1xuICAgICAgICAgICAgICAgIHZhciBsZW4gPSBfaC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE9wdGltaXplIGFkdmlzZSBmcm9tIGJhY2tib25lXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoYXJnTGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2hbaV1bJ2gnXS5jYWxsKF9oW2ldWydjdHgnXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2hbaV1bJ2gnXS5jYWxsKF9oW2ldWydjdHgnXSwgYXJnc1sxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2hbaV1bJ2gnXS5jYWxsKF9oW2ldWydjdHgnXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGhhdmUgbW9yZSB0aGFuIDIgZ2l2ZW4gYXJndW1lbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2hbaV1bJ2gnXS5hcHBseShfaFtpXVsnY3R4J10sIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKF9oW2ldWydvbmUnXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2guc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVuLS07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDluKbmnIljb250ZXh055qE5LqL5Lu25YiG5Y+RLCDmnIDlkI7kuIDkuKrlj4LmlbDmmK/kuovku7blm57osIPnmoRjb250ZXh0XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIOS6i+S7tuexu+Wei1xuICAgICAgICAgKi9cbiAgICAgICAgdHJpZ2dlcldpdGhDb250ZXh0OiBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuXyRoYW5kbGVyc1t0eXBlXSkge1xuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgICAgIHZhciBhcmdMZW4gPSBhcmdzLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgIGlmIChhcmdMZW4gPiA0KSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBhcnJ5U2xpY2UuY2FsbChhcmdzLCAxLCBhcmdzLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgY3R4ID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgICAgICAgICAgdmFyIF9oID0gdGhpcy5fJGhhbmRsZXJzW3R5cGVdO1xuICAgICAgICAgICAgICAgIHZhciBsZW4gPSBfaC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE9wdGltaXplIGFkdmlzZSBmcm9tIGJhY2tib25lXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoYXJnTGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2hbaV1bJ2gnXS5jYWxsKGN0eCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2hbaV1bJ2gnXS5jYWxsKGN0eCwgYXJnc1sxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2hbaV1bJ2gnXS5jYWxsKGN0eCwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGhhdmUgbW9yZSB0aGFuIDIgZ2l2ZW4gYXJndW1lbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2hbaV1bJ2gnXS5hcHBseShjdHgsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKF9oW2ldWydvbmUnXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2guc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVuLS07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIOWvueixoeWPr+S7pemAmui/hyBvbnh4eHgg57uR5a6a5LqL5Lu2XG4gICAgLyoqXG4gICAgICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29uY2xpY2tcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbm1vdXNlb3ZlclxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29ubW91c2VvdXRcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbm1vdXNlbW92ZVxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29ubW91c2V3aGVlbFxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29ubW91c2Vkb3duXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25tb3VzZXVwXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25kcmFnXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25kcmFnc3RhcnRcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbmRyYWdlbmRcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbmRyYWdlbnRlclxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29uZHJhZ2xlYXZlXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25kcmFnb3ZlclxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29uZHJvcFxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IEV2ZW50ZnVsO1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS95eC9+L3pyZW5kZXIvbGliL21peGluL0V2ZW50ZnVsLmpzXG4vLyBtb2R1bGUgaWQgPSAyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 23 */
/* unknown exports provided */
/* all exports used */
/*!****************************!*\
  !*** ./lib/util/symbol.js ***!
  \****************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n// Symbol factory\n\n\n    var graphic = __webpack_require__(/*! ./graphic */ 2);\n    var BoundingRect = __webpack_require__(/*! zrender/lib/core/BoundingRect */ 10);\n\n    /**\n     * Triangle shape\n     * @inner\n     */\n    var Triangle = graphic.extendShape({\n        type: 'triangle',\n        shape: {\n            cx: 0,\n            cy: 0,\n            width: 0,\n            height: 0\n        },\n        buildPath: function (path, shape) {\n            var cx = shape.cx;\n            var cy = shape.cy;\n            var width = shape.width / 2;\n            var height = shape.height / 2;\n            path.moveTo(cx, cy - height);\n            path.lineTo(cx + width, cy + height);\n            path.lineTo(cx - width, cy + height);\n            path.closePath();\n        }\n    });\n    /**\n     * Diamond shape\n     * @inner\n     */\n    var Diamond = graphic.extendShape({\n        type: 'diamond',\n        shape: {\n            cx: 0,\n            cy: 0,\n            width: 0,\n            height: 0\n        },\n        buildPath: function (path, shape) {\n            var cx = shape.cx;\n            var cy = shape.cy;\n            var width = shape.width / 2;\n            var height = shape.height / 2;\n            path.moveTo(cx, cy - height);\n            path.lineTo(cx + width, cy);\n            path.lineTo(cx, cy + height);\n            path.lineTo(cx - width, cy);\n            path.closePath();\n        }\n    });\n\n    /**\n     * Pin shape\n     * @inner\n     */\n    var Pin = graphic.extendShape({\n        type: 'pin',\n        shape: {\n            // x, y on the cusp\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        },\n\n        buildPath: function (path, shape) {\n            var x = shape.x;\n            var y = shape.y;\n            var w = shape.width / 5 * 3;\n            // Height must be larger than width\n            var h = Math.max(w, shape.height);\n            var r = w / 2;\n\n            // Dist on y with tangent point and circle center\n            var dy = r * r / (h - r);\n            var cy = y - h + r + dy;\n            var angle = Math.asin(dy / r);\n            // Dist on x with tangent point and circle center\n            var dx = Math.cos(angle) * r;\n\n            var tanX = Math.sin(angle);\n            var tanY = Math.cos(angle);\n\n            path.arc(\n                x, cy, r,\n                Math.PI - angle,\n                Math.PI * 2 + angle\n            );\n\n            var cpLen = r * 0.6;\n            var cpLen2 = r * 0.7;\n            path.bezierCurveTo(\n                x + dx - tanX * cpLen, cy + dy + tanY * cpLen,\n                x, y - cpLen2,\n                x, y\n            );\n            path.bezierCurveTo(\n                x, y - cpLen2,\n                x - dx + tanX * cpLen, cy + dy + tanY * cpLen,\n                x - dx, cy + dy\n            );\n            path.closePath();\n        }\n    });\n\n    /**\n     * Arrow shape\n     * @inner\n     */\n    var Arrow = graphic.extendShape({\n\n        type: 'arrow',\n\n        shape: {\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        },\n\n        buildPath: function (ctx, shape) {\n            var height = shape.height;\n            var width = shape.width;\n            var x = shape.x;\n            var y = shape.y;\n            var dx = width / 3 * 2;\n            ctx.moveTo(x, y);\n            ctx.lineTo(x + dx, y + height);\n            ctx.lineTo(x, y + height / 4 * 3);\n            ctx.lineTo(x - dx, y + height);\n            ctx.lineTo(x, y);\n            ctx.closePath();\n        }\n    });\n\n    /**\n     * Map of path contructors\n     * @type {Object.<string, module:zrender/graphic/Path>}\n     */\n    var symbolCtors = {\n        line: graphic.Line,\n\n        rect: graphic.Rect,\n\n        roundRect: graphic.Rect,\n\n        square: graphic.Rect,\n\n        circle: graphic.Circle,\n\n        diamond: Diamond,\n\n        pin: Pin,\n\n        arrow: Arrow,\n\n        triangle: Triangle\n    };\n\n    var symbolShapeMakers = {\n\n        line: function (x, y, w, h, shape) {\n            // FIXME\n            shape.x1 = x;\n            shape.y1 = y + h / 2;\n            shape.x2 = x + w;\n            shape.y2 = y + h / 2;\n        },\n\n        rect: function (x, y, w, h, shape) {\n            shape.x = x;\n            shape.y = y;\n            shape.width = w;\n            shape.height = h;\n        },\n\n        roundRect: function (x, y, w, h, shape) {\n            shape.x = x;\n            shape.y = y;\n            shape.width = w;\n            shape.height = h;\n            shape.r = Math.min(w, h) / 4;\n        },\n\n        square: function (x, y, w, h, shape) {\n            var size = Math.min(w, h);\n            shape.x = x;\n            shape.y = y;\n            shape.width = size;\n            shape.height = size;\n        },\n\n        circle: function (x, y, w, h, shape) {\n            // Put circle in the center of square\n            shape.cx = x + w / 2;\n            shape.cy = y + h / 2;\n            shape.r = Math.min(w, h) / 2;\n        },\n\n        diamond: function (x, y, w, h, shape) {\n            shape.cx = x + w / 2;\n            shape.cy = y + h / 2;\n            shape.width = w;\n            shape.height = h;\n        },\n\n        pin: function (x, y, w, h, shape) {\n            shape.x = x + w / 2;\n            shape.y = y + h / 2;\n            shape.width = w;\n            shape.height = h;\n        },\n\n        arrow: function (x, y, w, h, shape) {\n            shape.x = x + w / 2;\n            shape.y = y + h / 2;\n            shape.width = w;\n            shape.height = h;\n        },\n\n        triangle: function (x, y, w, h, shape) {\n            shape.cx = x + w / 2;\n            shape.cy = y + h / 2;\n            shape.width = w;\n            shape.height = h;\n        }\n    };\n\n    var symbolBuildProxies = {};\n    for (var name in symbolCtors) {\n        if (symbolCtors.hasOwnProperty(name)) {\n            symbolBuildProxies[name] = new symbolCtors[name]();\n        }\n    }\n\n    var Symbol = graphic.extendShape({\n\n        type: 'symbol',\n\n        shape: {\n            symbolType: '',\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        },\n\n        beforeBrush: function () {\n            var style = this.style;\n            var shape = this.shape;\n            // FIXME\n            if (shape.symbolType === 'pin' && style.textPosition === 'inside') {\n                style.textPosition = ['50%', '40%'];\n                style.textAlign = 'center';\n                style.textVerticalAlign = 'middle';\n            }\n        },\n\n        buildPath: function (ctx, shape, inBundle) {\n            var symbolType = shape.symbolType;\n            var proxySymbol = symbolBuildProxies[symbolType];\n            if (shape.symbolType !== 'none') {\n                if (!proxySymbol) {\n                    // Default rect\n                    symbolType = 'rect';\n                    proxySymbol = symbolBuildProxies[symbolType];\n                }\n                symbolShapeMakers[symbolType](\n                    shape.x, shape.y, shape.width, shape.height, proxySymbol.shape\n                );\n                proxySymbol.buildPath(ctx, proxySymbol.shape, inBundle);\n            }\n        }\n    });\n\n    // Provide setColor helper method to avoid determine if set the fill or stroke outside\n    var symbolPathSetColor = function (color) {\n        if (this.type !== 'image') {\n            var symbolStyle = this.style;\n            var symbolShape = this.shape;\n            if (symbolShape && symbolShape.symbolType === 'line') {\n                symbolStyle.stroke = color;\n            }\n            else if (this.__isEmptyBrush) {\n                symbolStyle.stroke = color;\n                symbolStyle.fill = '#fff';\n            }\n            else {\n                // FIXME 判断图形默认是填充还是描边，使用 onlyStroke ?\n                symbolStyle.fill && (symbolStyle.fill = color);\n                symbolStyle.stroke && (symbolStyle.stroke = color);\n            }\n            this.dirty(false);\n        }\n    };\n\n    var symbolUtil = {\n        /**\n         * Create a symbol element with given symbol configuration: shape, x, y, width, height, color\n         * @param {string} symbolType\n         * @param {number} x\n         * @param {number} y\n         * @param {number} w\n         * @param {number} h\n         * @param {string} color\n         */\n        createSymbol: function (symbolType, x, y, w, h, color) {\n            // TODO Support image object, DynamicImage.\n\n            var isEmpty = symbolType.indexOf('empty') === 0;\n            if (isEmpty) {\n                symbolType = symbolType.substr(5, 1).toLowerCase() + symbolType.substr(6);\n            }\n            var symbolPath;\n\n            if (symbolType.indexOf('image://') === 0) {\n                symbolPath = new graphic.Image({\n                    style: {\n                        image: symbolType.slice(8),\n                        x: x,\n                        y: y,\n                        width: w,\n                        height: h\n                    }\n                });\n            }\n            else if (symbolType.indexOf('path://') === 0) {\n                symbolPath = graphic.makePath(symbolType.slice(7), {}, new BoundingRect(x, y, w, h));\n            }\n            else {\n                symbolPath = new Symbol({\n                    shape: {\n                        symbolType: symbolType,\n                        x: x,\n                        y: y,\n                        width: w,\n                        height: h\n                    }\n                });\n            }\n\n            symbolPath.__isEmptyBrush = isEmpty;\n\n            symbolPath.setColor = symbolPathSetColor;\n\n            symbolPath.setColor(color);\n\n            return symbolPath;\n        }\n    };\n\n    module.exports = symbolUtil;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvdXRpbC9zeW1ib2wuanM/NzE0YiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG4vLyBTeW1ib2wgZmFjdG9yeVxuXG5cbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoJy4vZ3JhcGhpYycpO1xuICAgIHZhciBCb3VuZGluZ1JlY3QgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL0JvdW5kaW5nUmVjdCcpO1xuXG4gICAgLyoqXG4gICAgICogVHJpYW5nbGUgc2hhcGVcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICB2YXIgVHJpYW5nbGUgPSBncmFwaGljLmV4dGVuZFNoYXBlKHtcbiAgICAgICAgdHlwZTogJ3RyaWFuZ2xlJyxcbiAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgIGN4OiAwLFxuICAgICAgICAgICAgY3k6IDAsXG4gICAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICAgIGhlaWdodDogMFxuICAgICAgICB9LFxuICAgICAgICBidWlsZFBhdGg6IGZ1bmN0aW9uIChwYXRoLCBzaGFwZSkge1xuICAgICAgICAgICAgdmFyIGN4ID0gc2hhcGUuY3g7XG4gICAgICAgICAgICB2YXIgY3kgPSBzaGFwZS5jeTtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHNoYXBlLndpZHRoIC8gMjtcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSBzaGFwZS5oZWlnaHQgLyAyO1xuICAgICAgICAgICAgcGF0aC5tb3ZlVG8oY3gsIGN5IC0gaGVpZ2h0KTtcbiAgICAgICAgICAgIHBhdGgubGluZVRvKGN4ICsgd2lkdGgsIGN5ICsgaGVpZ2h0KTtcbiAgICAgICAgICAgIHBhdGgubGluZVRvKGN4IC0gd2lkdGgsIGN5ICsgaGVpZ2h0KTtcbiAgICAgICAgICAgIHBhdGguY2xvc2VQYXRoKCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBEaWFtb25kIHNoYXBlXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgdmFyIERpYW1vbmQgPSBncmFwaGljLmV4dGVuZFNoYXBlKHtcbiAgICAgICAgdHlwZTogJ2RpYW1vbmQnLFxuICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgY3g6IDAsXG4gICAgICAgICAgICBjeTogMCxcbiAgICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgICAgaGVpZ2h0OiAwXG4gICAgICAgIH0sXG4gICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKHBhdGgsIHNoYXBlKSB7XG4gICAgICAgICAgICB2YXIgY3ggPSBzaGFwZS5jeDtcbiAgICAgICAgICAgIHZhciBjeSA9IHNoYXBlLmN5O1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gc2hhcGUud2lkdGggLyAyO1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IHNoYXBlLmhlaWdodCAvIDI7XG4gICAgICAgICAgICBwYXRoLm1vdmVUbyhjeCwgY3kgLSBoZWlnaHQpO1xuICAgICAgICAgICAgcGF0aC5saW5lVG8oY3ggKyB3aWR0aCwgY3kpO1xuICAgICAgICAgICAgcGF0aC5saW5lVG8oY3gsIGN5ICsgaGVpZ2h0KTtcbiAgICAgICAgICAgIHBhdGgubGluZVRvKGN4IC0gd2lkdGgsIGN5KTtcbiAgICAgICAgICAgIHBhdGguY2xvc2VQYXRoKCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFBpbiBzaGFwZVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIHZhciBQaW4gPSBncmFwaGljLmV4dGVuZFNoYXBlKHtcbiAgICAgICAgdHlwZTogJ3BpbicsXG4gICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgICAvLyB4LCB5IG9uIHRoZSBjdXNwXG4gICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgeTogMCxcbiAgICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgICAgaGVpZ2h0OiAwXG4gICAgICAgIH0sXG5cbiAgICAgICAgYnVpbGRQYXRoOiBmdW5jdGlvbiAocGF0aCwgc2hhcGUpIHtcbiAgICAgICAgICAgIHZhciB4ID0gc2hhcGUueDtcbiAgICAgICAgICAgIHZhciB5ID0gc2hhcGUueTtcbiAgICAgICAgICAgIHZhciB3ID0gc2hhcGUud2lkdGggLyA1ICogMztcbiAgICAgICAgICAgIC8vIEhlaWdodCBtdXN0IGJlIGxhcmdlciB0aGFuIHdpZHRoXG4gICAgICAgICAgICB2YXIgaCA9IE1hdGgubWF4KHcsIHNoYXBlLmhlaWdodCk7XG4gICAgICAgICAgICB2YXIgciA9IHcgLyAyO1xuXG4gICAgICAgICAgICAvLyBEaXN0IG9uIHkgd2l0aCB0YW5nZW50IHBvaW50IGFuZCBjaXJjbGUgY2VudGVyXG4gICAgICAgICAgICB2YXIgZHkgPSByICogciAvIChoIC0gcik7XG4gICAgICAgICAgICB2YXIgY3kgPSB5IC0gaCArIHIgKyBkeTtcbiAgICAgICAgICAgIHZhciBhbmdsZSA9IE1hdGguYXNpbihkeSAvIHIpO1xuICAgICAgICAgICAgLy8gRGlzdCBvbiB4IHdpdGggdGFuZ2VudCBwb2ludCBhbmQgY2lyY2xlIGNlbnRlclxuICAgICAgICAgICAgdmFyIGR4ID0gTWF0aC5jb3MoYW5nbGUpICogcjtcblxuICAgICAgICAgICAgdmFyIHRhblggPSBNYXRoLnNpbihhbmdsZSk7XG4gICAgICAgICAgICB2YXIgdGFuWSA9IE1hdGguY29zKGFuZ2xlKTtcblxuICAgICAgICAgICAgcGF0aC5hcmMoXG4gICAgICAgICAgICAgICAgeCwgY3ksIHIsXG4gICAgICAgICAgICAgICAgTWF0aC5QSSAtIGFuZ2xlLFxuICAgICAgICAgICAgICAgIE1hdGguUEkgKiAyICsgYW5nbGVcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHZhciBjcExlbiA9IHIgKiAwLjY7XG4gICAgICAgICAgICB2YXIgY3BMZW4yID0gciAqIDAuNztcbiAgICAgICAgICAgIHBhdGguYmV6aWVyQ3VydmVUbyhcbiAgICAgICAgICAgICAgICB4ICsgZHggLSB0YW5YICogY3BMZW4sIGN5ICsgZHkgKyB0YW5ZICogY3BMZW4sXG4gICAgICAgICAgICAgICAgeCwgeSAtIGNwTGVuMixcbiAgICAgICAgICAgICAgICB4LCB5XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcGF0aC5iZXppZXJDdXJ2ZVRvKFxuICAgICAgICAgICAgICAgIHgsIHkgLSBjcExlbjIsXG4gICAgICAgICAgICAgICAgeCAtIGR4ICsgdGFuWCAqIGNwTGVuLCBjeSArIGR5ICsgdGFuWSAqIGNwTGVuLFxuICAgICAgICAgICAgICAgIHggLSBkeCwgY3kgKyBkeVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHBhdGguY2xvc2VQYXRoKCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEFycm93IHNoYXBlXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgdmFyIEFycm93ID0gZ3JhcGhpYy5leHRlbmRTaGFwZSh7XG5cbiAgICAgICAgdHlwZTogJ2Fycm93JyxcblxuICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICAgIGhlaWdodDogMFxuICAgICAgICB9LFxuXG4gICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSBzaGFwZS5oZWlnaHQ7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSBzaGFwZS53aWR0aDtcbiAgICAgICAgICAgIHZhciB4ID0gc2hhcGUueDtcbiAgICAgICAgICAgIHZhciB5ID0gc2hhcGUueTtcbiAgICAgICAgICAgIHZhciBkeCA9IHdpZHRoIC8gMyAqIDI7XG4gICAgICAgICAgICBjdHgubW92ZVRvKHgsIHkpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4ICsgZHgsIHkgKyBoZWlnaHQpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4LCB5ICsgaGVpZ2h0IC8gNCAqIDMpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4IC0gZHgsIHkgKyBoZWlnaHQpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4LCB5KTtcbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogTWFwIG9mIHBhdGggY29udHJ1Y3RvcnNcbiAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsIG1vZHVsZTp6cmVuZGVyL2dyYXBoaWMvUGF0aD59XG4gICAgICovXG4gICAgdmFyIHN5bWJvbEN0b3JzID0ge1xuICAgICAgICBsaW5lOiBncmFwaGljLkxpbmUsXG5cbiAgICAgICAgcmVjdDogZ3JhcGhpYy5SZWN0LFxuXG4gICAgICAgIHJvdW5kUmVjdDogZ3JhcGhpYy5SZWN0LFxuXG4gICAgICAgIHNxdWFyZTogZ3JhcGhpYy5SZWN0LFxuXG4gICAgICAgIGNpcmNsZTogZ3JhcGhpYy5DaXJjbGUsXG5cbiAgICAgICAgZGlhbW9uZDogRGlhbW9uZCxcblxuICAgICAgICBwaW46IFBpbixcblxuICAgICAgICBhcnJvdzogQXJyb3csXG5cbiAgICAgICAgdHJpYW5nbGU6IFRyaWFuZ2xlXG4gICAgfTtcblxuICAgIHZhciBzeW1ib2xTaGFwZU1ha2VycyA9IHtcblxuICAgICAgICBsaW5lOiBmdW5jdGlvbiAoeCwgeSwgdywgaCwgc2hhcGUpIHtcbiAgICAgICAgICAgIC8vIEZJWE1FXG4gICAgICAgICAgICBzaGFwZS54MSA9IHg7XG4gICAgICAgICAgICBzaGFwZS55MSA9IHkgKyBoIC8gMjtcbiAgICAgICAgICAgIHNoYXBlLngyID0geCArIHc7XG4gICAgICAgICAgICBzaGFwZS55MiA9IHkgKyBoIC8gMjtcbiAgICAgICAgfSxcblxuICAgICAgICByZWN0OiBmdW5jdGlvbiAoeCwgeSwgdywgaCwgc2hhcGUpIHtcbiAgICAgICAgICAgIHNoYXBlLnggPSB4O1xuICAgICAgICAgICAgc2hhcGUueSA9IHk7XG4gICAgICAgICAgICBzaGFwZS53aWR0aCA9IHc7XG4gICAgICAgICAgICBzaGFwZS5oZWlnaHQgPSBoO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJvdW5kUmVjdDogZnVuY3Rpb24gKHgsIHksIHcsIGgsIHNoYXBlKSB7XG4gICAgICAgICAgICBzaGFwZS54ID0geDtcbiAgICAgICAgICAgIHNoYXBlLnkgPSB5O1xuICAgICAgICAgICAgc2hhcGUud2lkdGggPSB3O1xuICAgICAgICAgICAgc2hhcGUuaGVpZ2h0ID0gaDtcbiAgICAgICAgICAgIHNoYXBlLnIgPSBNYXRoLm1pbih3LCBoKSAvIDQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc3F1YXJlOiBmdW5jdGlvbiAoeCwgeSwgdywgaCwgc2hhcGUpIHtcbiAgICAgICAgICAgIHZhciBzaXplID0gTWF0aC5taW4odywgaCk7XG4gICAgICAgICAgICBzaGFwZS54ID0geDtcbiAgICAgICAgICAgIHNoYXBlLnkgPSB5O1xuICAgICAgICAgICAgc2hhcGUud2lkdGggPSBzaXplO1xuICAgICAgICAgICAgc2hhcGUuaGVpZ2h0ID0gc2l6ZTtcbiAgICAgICAgfSxcblxuICAgICAgICBjaXJjbGU6IGZ1bmN0aW9uICh4LCB5LCB3LCBoLCBzaGFwZSkge1xuICAgICAgICAgICAgLy8gUHV0IGNpcmNsZSBpbiB0aGUgY2VudGVyIG9mIHNxdWFyZVxuICAgICAgICAgICAgc2hhcGUuY3ggPSB4ICsgdyAvIDI7XG4gICAgICAgICAgICBzaGFwZS5jeSA9IHkgKyBoIC8gMjtcbiAgICAgICAgICAgIHNoYXBlLnIgPSBNYXRoLm1pbih3LCBoKSAvIDI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGlhbW9uZDogZnVuY3Rpb24gKHgsIHksIHcsIGgsIHNoYXBlKSB7XG4gICAgICAgICAgICBzaGFwZS5jeCA9IHggKyB3IC8gMjtcbiAgICAgICAgICAgIHNoYXBlLmN5ID0geSArIGggLyAyO1xuICAgICAgICAgICAgc2hhcGUud2lkdGggPSB3O1xuICAgICAgICAgICAgc2hhcGUuaGVpZ2h0ID0gaDtcbiAgICAgICAgfSxcblxuICAgICAgICBwaW46IGZ1bmN0aW9uICh4LCB5LCB3LCBoLCBzaGFwZSkge1xuICAgICAgICAgICAgc2hhcGUueCA9IHggKyB3IC8gMjtcbiAgICAgICAgICAgIHNoYXBlLnkgPSB5ICsgaCAvIDI7XG4gICAgICAgICAgICBzaGFwZS53aWR0aCA9IHc7XG4gICAgICAgICAgICBzaGFwZS5oZWlnaHQgPSBoO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFycm93OiBmdW5jdGlvbiAoeCwgeSwgdywgaCwgc2hhcGUpIHtcbiAgICAgICAgICAgIHNoYXBlLnggPSB4ICsgdyAvIDI7XG4gICAgICAgICAgICBzaGFwZS55ID0geSArIGggLyAyO1xuICAgICAgICAgICAgc2hhcGUud2lkdGggPSB3O1xuICAgICAgICAgICAgc2hhcGUuaGVpZ2h0ID0gaDtcbiAgICAgICAgfSxcblxuICAgICAgICB0cmlhbmdsZTogZnVuY3Rpb24gKHgsIHksIHcsIGgsIHNoYXBlKSB7XG4gICAgICAgICAgICBzaGFwZS5jeCA9IHggKyB3IC8gMjtcbiAgICAgICAgICAgIHNoYXBlLmN5ID0geSArIGggLyAyO1xuICAgICAgICAgICAgc2hhcGUud2lkdGggPSB3O1xuICAgICAgICAgICAgc2hhcGUuaGVpZ2h0ID0gaDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgc3ltYm9sQnVpbGRQcm94aWVzID0ge307XG4gICAgZm9yICh2YXIgbmFtZSBpbiBzeW1ib2xDdG9ycykge1xuICAgICAgICBpZiAoc3ltYm9sQ3RvcnMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgIHN5bWJvbEJ1aWxkUHJveGllc1tuYW1lXSA9IG5ldyBzeW1ib2xDdG9yc1tuYW1lXSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIFN5bWJvbCA9IGdyYXBoaWMuZXh0ZW5kU2hhcGUoe1xuXG4gICAgICAgIHR5cGU6ICdzeW1ib2wnLFxuXG4gICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgICBzeW1ib2xUeXBlOiAnJyxcbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgICAgICBoZWlnaHQ6IDBcbiAgICAgICAgfSxcblxuICAgICAgICBiZWZvcmVCcnVzaDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTtcbiAgICAgICAgICAgIHZhciBzaGFwZSA9IHRoaXMuc2hhcGU7XG4gICAgICAgICAgICAvLyBGSVhNRVxuICAgICAgICAgICAgaWYgKHNoYXBlLnN5bWJvbFR5cGUgPT09ICdwaW4nICYmIHN0eWxlLnRleHRQb3NpdGlvbiA9PT0gJ2luc2lkZScpIHtcbiAgICAgICAgICAgICAgICBzdHlsZS50ZXh0UG9zaXRpb24gPSBbJzUwJScsICc0MCUnXTtcbiAgICAgICAgICAgICAgICBzdHlsZS50ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICAgICAgICBzdHlsZS50ZXh0VmVydGljYWxBbGlnbiA9ICdtaWRkbGUnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUsIGluQnVuZGxlKSB7XG4gICAgICAgICAgICB2YXIgc3ltYm9sVHlwZSA9IHNoYXBlLnN5bWJvbFR5cGU7XG4gICAgICAgICAgICB2YXIgcHJveHlTeW1ib2wgPSBzeW1ib2xCdWlsZFByb3hpZXNbc3ltYm9sVHlwZV07XG4gICAgICAgICAgICBpZiAoc2hhcGUuc3ltYm9sVHlwZSAhPT0gJ25vbmUnKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFwcm94eVN5bWJvbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBEZWZhdWx0IHJlY3RcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sVHlwZSA9ICdyZWN0JztcbiAgICAgICAgICAgICAgICAgICAgcHJveHlTeW1ib2wgPSBzeW1ib2xCdWlsZFByb3hpZXNbc3ltYm9sVHlwZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN5bWJvbFNoYXBlTWFrZXJzW3N5bWJvbFR5cGVdKFxuICAgICAgICAgICAgICAgICAgICBzaGFwZS54LCBzaGFwZS55LCBzaGFwZS53aWR0aCwgc2hhcGUuaGVpZ2h0LCBwcm94eVN5bWJvbC5zaGFwZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcHJveHlTeW1ib2wuYnVpbGRQYXRoKGN0eCwgcHJveHlTeW1ib2wuc2hhcGUsIGluQnVuZGxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gUHJvdmlkZSBzZXRDb2xvciBoZWxwZXIgbWV0aG9kIHRvIGF2b2lkIGRldGVybWluZSBpZiBzZXQgdGhlIGZpbGwgb3Igc3Ryb2tlIG91dHNpZGVcbiAgICB2YXIgc3ltYm9sUGF0aFNldENvbG9yID0gZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgIT09ICdpbWFnZScpIHtcbiAgICAgICAgICAgIHZhciBzeW1ib2xTdHlsZSA9IHRoaXMuc3R5bGU7XG4gICAgICAgICAgICB2YXIgc3ltYm9sU2hhcGUgPSB0aGlzLnNoYXBlO1xuICAgICAgICAgICAgaWYgKHN5bWJvbFNoYXBlICYmIHN5bWJvbFNoYXBlLnN5bWJvbFR5cGUgPT09ICdsaW5lJykge1xuICAgICAgICAgICAgICAgIHN5bWJvbFN0eWxlLnN0cm9rZSA9IGNvbG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fX2lzRW1wdHlCcnVzaCkge1xuICAgICAgICAgICAgICAgIHN5bWJvbFN0eWxlLnN0cm9rZSA9IGNvbG9yO1xuICAgICAgICAgICAgICAgIHN5bWJvbFN0eWxlLmZpbGwgPSAnI2ZmZic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBGSVhNRSDliKTmlq3lm77lvaLpu5jorqTmmK/loavlhYXov5jmmK/mj4/ovrnvvIzkvb/nlKggb25seVN0cm9rZSA/XG4gICAgICAgICAgICAgICAgc3ltYm9sU3R5bGUuZmlsbCAmJiAoc3ltYm9sU3R5bGUuZmlsbCA9IGNvbG9yKTtcbiAgICAgICAgICAgICAgICBzeW1ib2xTdHlsZS5zdHJva2UgJiYgKHN5bWJvbFN0eWxlLnN0cm9rZSA9IGNvbG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZGlydHkoZmFsc2UpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBzeW1ib2xVdGlsID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgc3ltYm9sIGVsZW1lbnQgd2l0aCBnaXZlbiBzeW1ib2wgY29uZmlndXJhdGlvbjogc2hhcGUsIHgsIHksIHdpZHRoLCBoZWlnaHQsIGNvbG9yXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzeW1ib2xUeXBlXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3XG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvclxuICAgICAgICAgKi9cbiAgICAgICAgY3JlYXRlU3ltYm9sOiBmdW5jdGlvbiAoc3ltYm9sVHlwZSwgeCwgeSwgdywgaCwgY29sb3IpIHtcbiAgICAgICAgICAgIC8vIFRPRE8gU3VwcG9ydCBpbWFnZSBvYmplY3QsIER5bmFtaWNJbWFnZS5cblxuICAgICAgICAgICAgdmFyIGlzRW1wdHkgPSBzeW1ib2xUeXBlLmluZGV4T2YoJ2VtcHR5JykgPT09IDA7XG4gICAgICAgICAgICBpZiAoaXNFbXB0eSkge1xuICAgICAgICAgICAgICAgIHN5bWJvbFR5cGUgPSBzeW1ib2xUeXBlLnN1YnN0cig1LCAxKS50b0xvd2VyQ2FzZSgpICsgc3ltYm9sVHlwZS5zdWJzdHIoNik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc3ltYm9sUGF0aDtcblxuICAgICAgICAgICAgaWYgKHN5bWJvbFR5cGUuaW5kZXhPZignaW1hZ2U6Ly8nKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHN5bWJvbFBhdGggPSBuZXcgZ3JhcGhpYy5JbWFnZSh7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZTogc3ltYm9sVHlwZS5zbGljZSg4KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiB5LFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHcsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGhcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc3ltYm9sVHlwZS5pbmRleE9mKCdwYXRoOi8vJykgPT09IDApIHtcbiAgICAgICAgICAgICAgICBzeW1ib2xQYXRoID0gZ3JhcGhpYy5tYWtlUGF0aChzeW1ib2xUeXBlLnNsaWNlKDcpLCB7fSwgbmV3IEJvdW5kaW5nUmVjdCh4LCB5LCB3LCBoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzeW1ib2xQYXRoID0gbmV3IFN5bWJvbCh7XG4gICAgICAgICAgICAgICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2xUeXBlOiBzeW1ib2xUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IHksXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogdyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogaFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHN5bWJvbFBhdGguX19pc0VtcHR5QnJ1c2ggPSBpc0VtcHR5O1xuXG4gICAgICAgICAgICBzeW1ib2xQYXRoLnNldENvbG9yID0gc3ltYm9sUGF0aFNldENvbG9yO1xuXG4gICAgICAgICAgICBzeW1ib2xQYXRoLnNldENvbG9yKGNvbG9yKTtcblxuICAgICAgICAgICAgcmV0dXJuIHN5bWJvbFBhdGg7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBzeW1ib2xVdGlsO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvdXRpbC9zeW1ib2wuanNcbi8vIG1vZHVsZSBpZCA9IDIzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 24 */
/* unknown exports provided */
/* all exports used */
/*!***********************************************!*\
  !*** ./lib/data/helper/completeDimensions.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Complete dimensions by data (guess dimension).\n */\n\n\n    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 0);\n\n    /**\n     * Complete the dimensions array guessed from the data structure.\n     * @param  {Array.<string>} dimensions Necessary dimensions, like ['x', 'y']\n     * @param  {Array} data Data list. [[1, 2, 3], [2, 3, 4]]\n     * @param  {Object} [opt]\n     * @param  {Array.<string>} [opt.defaultNames] Default names to fill not necessary dimensions, like ['value']\n     * @param  {string} [opt.extraPrefix] Prefix of name when filling the left dimensions.\n     * @param  {number} [opt.dimCount] If not specified, guess by the first data item.\n     * @return {Array.<string>}\n     */\n    function completeDimensions(dimensions, data, opt) {\n        if (!data) {\n            return dimensions;\n        }\n\n        opt = opt || {};\n\n        var dimCount = opt.dimCount;\n        if (dimCount == null) {\n            var value0 = retrieveValue(data[0]);\n            dimCount = zrUtil.isArray(value0) && value0.length || 1;\n        }\n\n        var defaultNames = opt.defaultNames || [];\n        var extraPrefix = opt.extraPrefix || 'extra';\n        for (var i = 0; i < dimCount; i++) {\n            if (!dimensions[i]) {\n                var name = defaultNames[i] || (extraPrefix + (i - defaultNames.length));\n                dimensions[i] = guessOrdinal(data, i)\n                    ? {type: 'ordinal', name: name}\n                    : name;\n            }\n        }\n\n        return dimensions;\n    }\n\n    // The rule should not be complex, otherwise user might not\n    // be able to known where the data is wrong.\n    var guessOrdinal = completeDimensions.guessOrdinal = function (data, dimIndex) {\n        for (var i = 0, len = data.length; i < len; i++) {\n            var value = retrieveValue(data[i]);\n\n            if (!zrUtil.isArray(value)) {\n                return false;\n            }\n\n            var value = value[dimIndex];\n            if (value != null && isFinite(value)) {\n                return false;\n            }\n            else if (zrUtil.isString(value) && value !== '-') {\n                return true;\n            }\n        }\n        return false;\n    };\n\n    function retrieveValue(o) {\n        return zrUtil.isArray(o) ? o : zrUtil.isObject(o) ? o.value: o;\n    }\n\n    module.exports = completeDimensions;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvZGF0YS9oZWxwZXIvY29tcGxldGVEaW1lbnNpb25zLmpzPzlkYzgiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb21wbGV0ZSBkaW1lbnNpb25zIGJ5IGRhdGEgKGd1ZXNzIGRpbWVuc2lvbikuXG4gKi9cblxuXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuXG4gICAgLyoqXG4gICAgICogQ29tcGxldGUgdGhlIGRpbWVuc2lvbnMgYXJyYXkgZ3Vlc3NlZCBmcm9tIHRoZSBkYXRhIHN0cnVjdHVyZS5cbiAgICAgKiBAcGFyYW0gIHtBcnJheS48c3RyaW5nPn0gZGltZW5zaW9ucyBOZWNlc3NhcnkgZGltZW5zaW9ucywgbGlrZSBbJ3gnLCAneSddXG4gICAgICogQHBhcmFtICB7QXJyYXl9IGRhdGEgRGF0YSBsaXN0LiBbWzEsIDIsIDNdLCBbMiwgMywgNF1dXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0XVxuICAgICAqIEBwYXJhbSAge0FycmF5LjxzdHJpbmc+fSBbb3B0LmRlZmF1bHROYW1lc10gRGVmYXVsdCBuYW1lcyB0byBmaWxsIG5vdCBuZWNlc3NhcnkgZGltZW5zaW9ucywgbGlrZSBbJ3ZhbHVlJ11cbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IFtvcHQuZXh0cmFQcmVmaXhdIFByZWZpeCBvZiBuYW1lIHdoZW4gZmlsbGluZyB0aGUgbGVmdCBkaW1lbnNpb25zLlxuICAgICAqIEBwYXJhbSAge251bWJlcn0gW29wdC5kaW1Db3VudF0gSWYgbm90IHNwZWNpZmllZCwgZ3Vlc3MgYnkgdGhlIGZpcnN0IGRhdGEgaXRlbS5cbiAgICAgKiBAcmV0dXJuIHtBcnJheS48c3RyaW5nPn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb21wbGV0ZURpbWVuc2lvbnMoZGltZW5zaW9ucywgZGF0YSwgb3B0KSB7XG4gICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIGRpbWVuc2lvbnM7XG4gICAgICAgIH1cblxuICAgICAgICBvcHQgPSBvcHQgfHwge307XG5cbiAgICAgICAgdmFyIGRpbUNvdW50ID0gb3B0LmRpbUNvdW50O1xuICAgICAgICBpZiAoZGltQ291bnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlMCA9IHJldHJpZXZlVmFsdWUoZGF0YVswXSk7XG4gICAgICAgICAgICBkaW1Db3VudCA9IHpyVXRpbC5pc0FycmF5KHZhbHVlMCkgJiYgdmFsdWUwLmxlbmd0aCB8fCAxO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRlZmF1bHROYW1lcyA9IG9wdC5kZWZhdWx0TmFtZXMgfHwgW107XG4gICAgICAgIHZhciBleHRyYVByZWZpeCA9IG9wdC5leHRyYVByZWZpeCB8fCAnZXh0cmEnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpbUNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGlmICghZGltZW5zaW9uc1tpXSkge1xuICAgICAgICAgICAgICAgIHZhciBuYW1lID0gZGVmYXVsdE5hbWVzW2ldIHx8IChleHRyYVByZWZpeCArIChpIC0gZGVmYXVsdE5hbWVzLmxlbmd0aCkpO1xuICAgICAgICAgICAgICAgIGRpbWVuc2lvbnNbaV0gPSBndWVzc09yZGluYWwoZGF0YSwgaSlcbiAgICAgICAgICAgICAgICAgICAgPyB7dHlwZTogJ29yZGluYWwnLCBuYW1lOiBuYW1lfVxuICAgICAgICAgICAgICAgICAgICA6IG5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGltZW5zaW9ucztcbiAgICB9XG5cbiAgICAvLyBUaGUgcnVsZSBzaG91bGQgbm90IGJlIGNvbXBsZXgsIG90aGVyd2lzZSB1c2VyIG1pZ2h0IG5vdFxuICAgIC8vIGJlIGFibGUgdG8ga25vd24gd2hlcmUgdGhlIGRhdGEgaXMgd3JvbmcuXG4gICAgdmFyIGd1ZXNzT3JkaW5hbCA9IGNvbXBsZXRlRGltZW5zaW9ucy5ndWVzc09yZGluYWwgPSBmdW5jdGlvbiAoZGF0YSwgZGltSW5kZXgpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRhdGEubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHJldHJpZXZlVmFsdWUoZGF0YVtpXSk7XG5cbiAgICAgICAgICAgIGlmICghenJVdGlsLmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB2YWx1ZVtkaW1JbmRleF07XG4gICAgICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCAmJiBpc0Zpbml0ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh6clV0aWwuaXNTdHJpbmcodmFsdWUpICYmIHZhbHVlICE9PSAnLScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHJldHJpZXZlVmFsdWUobykge1xuICAgICAgICByZXR1cm4genJVdGlsLmlzQXJyYXkobykgPyBvIDogenJVdGlsLmlzT2JqZWN0KG8pID8gby52YWx1ZTogbztcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGNvbXBsZXRlRGltZW5zaW9ucztcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZGF0YS9oZWxwZXIvY29tcGxldGVEaW1lbnNpb25zLmpzXG4vLyBtb2R1bGUgaWQgPSAyNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 25 */
/* unknown exports provided */
/* all exports used */
/*!************************************************!*\
  !*** /home/yx/~/zrender/lib/core/PathProxy.js ***!
  \************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Path 代理，可以在`buildPath`中用于替代`ctx`, 会保存每个path操作的命令到pathCommands属性中\n * 可以用于 isInsidePath 判断以及获取boundingRect\n *\n * @module zrender/core/PathProxy\n * @author Yi Shen (http://www.github.com/pissang)\n */\n\n // TODO getTotalLength, getPointAtLength\n\n\n    var curve = __webpack_require__(/*! ./curve */ 19);\n    var vec2 = __webpack_require__(/*! ./vector */ 4);\n    var bbox = __webpack_require__(/*! ./bbox */ 76);\n    var BoundingRect = __webpack_require__(/*! ./BoundingRect */ 10);\n    var dpr = __webpack_require__(/*! ../config */ 32).devicePixelRatio;\n\n    var CMD = {\n        M: 1,\n        L: 2,\n        C: 3,\n        Q: 4,\n        A: 5,\n        Z: 6,\n        // Rect\n        R: 7\n    };\n\n    // var CMD_MEM_SIZE = {\n    //     M: 3,\n    //     L: 3,\n    //     C: 7,\n    //     Q: 5,\n    //     A: 9,\n    //     R: 5,\n    //     Z: 1\n    // };\n\n    var min = [];\n    var max = [];\n    var min2 = [];\n    var max2 = [];\n    var mathMin = Math.min;\n    var mathMax = Math.max;\n    var mathCos = Math.cos;\n    var mathSin = Math.sin;\n    var mathSqrt = Math.sqrt;\n    var mathAbs = Math.abs;\n\n    var hasTypedArray = typeof Float32Array != 'undefined';\n\n    /**\n     * @alias module:zrender/core/PathProxy\n     * @constructor\n     */\n    var PathProxy = function (notSaveData) {\n\n        this._saveData = !(notSaveData || false);\n\n        if (this._saveData) {\n            /**\n             * Path data. Stored as flat array\n             * @type {Array.<Object>}\n             */\n            this.data = [];\n        }\n\n        this._ctx = null;\n    };\n\n    /**\n     * 快速计算Path包围盒（并不是最小包围盒）\n     * @return {Object}\n     */\n    PathProxy.prototype = {\n\n        constructor: PathProxy,\n\n        _xi: 0,\n        _yi: 0,\n\n        _x0: 0,\n        _y0: 0,\n        // Unit x, Unit y. Provide for avoiding drawing that too short line segment\n        _ux: 0,\n        _uy: 0,\n\n        _len: 0,\n\n        _lineDash: null,\n\n        _dashOffset: 0,\n\n        _dashIdx: 0,\n\n        _dashSum: 0,\n\n        /**\n         * @readOnly\n         */\n        setScale: function (sx, sy) {\n            this._ux = mathAbs(1 / dpr / sx) || 0;\n            this._uy = mathAbs(1 / dpr / sy) || 0;\n        },\n\n        getContext: function () {\n            return this._ctx;\n        },\n\n        /**\n         * @param  {CanvasRenderingContext2D} ctx\n         * @return {module:zrender/core/PathProxy}\n         */\n        beginPath: function (ctx) {\n\n            this._ctx = ctx;\n\n            ctx && ctx.beginPath();\n\n            ctx && (this.dpr = ctx.dpr);\n\n            // Reset\n            if (this._saveData) {\n                this._len = 0;\n            }\n\n            if (this._lineDash) {\n                this._lineDash = null;\n\n                this._dashOffset = 0;\n            }\n\n            return this;\n        },\n\n        /**\n         * @param  {number} x\n         * @param  {number} y\n         * @return {module:zrender/core/PathProxy}\n         */\n        moveTo: function (x, y) {\n            this.addData(CMD.M, x, y);\n            this._ctx && this._ctx.moveTo(x, y);\n\n            // x0, y0, xi, yi 是记录在 _dashedXXXXTo 方法中使用\n            // xi, yi 记录当前点, x0, y0 在 closePath 的时候回到起始点。\n            // 有可能在 beginPath 之后直接调用 lineTo，这时候 x0, y0 需要\n            // 在 lineTo 方法中记录，这里先不考虑这种情况，dashed line 也只在 IE10- 中不支持\n            this._x0 = x;\n            this._y0 = y;\n\n            this._xi = x;\n            this._yi = y;\n\n            return this;\n        },\n\n        /**\n         * @param  {number} x\n         * @param  {number} y\n         * @return {module:zrender/core/PathProxy}\n         */\n        lineTo: function (x, y) {\n            var exceedUnit = mathAbs(x - this._xi) > this._ux\n                || mathAbs(y - this._yi) > this._uy\n                // Force draw the first segment\n                || this._len < 5;\n\n            this.addData(CMD.L, x, y);\n\n            if (this._ctx && exceedUnit) {\n                this._needsDash() ? this._dashedLineTo(x, y)\n                    : this._ctx.lineTo(x, y);\n            }\n            if (exceedUnit) {\n                this._xi = x;\n                this._yi = y;\n            }\n\n            return this;\n        },\n\n        /**\n         * @param  {number} x1\n         * @param  {number} y1\n         * @param  {number} x2\n         * @param  {number} y2\n         * @param  {number} x3\n         * @param  {number} y3\n         * @return {module:zrender/core/PathProxy}\n         */\n        bezierCurveTo: function (x1, y1, x2, y2, x3, y3) {\n            this.addData(CMD.C, x1, y1, x2, y2, x3, y3);\n            if (this._ctx) {\n                this._needsDash() ? this._dashedBezierTo(x1, y1, x2, y2, x3, y3)\n                    : this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);\n            }\n            this._xi = x3;\n            this._yi = y3;\n            return this;\n        },\n\n        /**\n         * @param  {number} x1\n         * @param  {number} y1\n         * @param  {number} x2\n         * @param  {number} y2\n         * @return {module:zrender/core/PathProxy}\n         */\n        quadraticCurveTo: function (x1, y1, x2, y2) {\n            this.addData(CMD.Q, x1, y1, x2, y2);\n            if (this._ctx) {\n                this._needsDash() ? this._dashedQuadraticTo(x1, y1, x2, y2)\n                    : this._ctx.quadraticCurveTo(x1, y1, x2, y2);\n            }\n            this._xi = x2;\n            this._yi = y2;\n            return this;\n        },\n\n        /**\n         * @param  {number} cx\n         * @param  {number} cy\n         * @param  {number} r\n         * @param  {number} startAngle\n         * @param  {number} endAngle\n         * @param  {boolean} anticlockwise\n         * @return {module:zrender/core/PathProxy}\n         */\n        arc: function (cx, cy, r, startAngle, endAngle, anticlockwise) {\n            this.addData(\n                CMD.A, cx, cy, r, r, startAngle, endAngle - startAngle, 0, anticlockwise ? 0 : 1\n            );\n            this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);\n\n            this._xi = mathCos(endAngle) * r + cx;\n            this._yi = mathSin(endAngle) * r + cx;\n            return this;\n        },\n\n        // TODO\n        arcTo: function (x1, y1, x2, y2, radius) {\n            if (this._ctx) {\n                this._ctx.arcTo(x1, y1, x2, y2, radius);\n            }\n            return this;\n        },\n\n        // TODO\n        rect: function (x, y, w, h) {\n            this._ctx && this._ctx.rect(x, y, w, h);\n            this.addData(CMD.R, x, y, w, h);\n            return this;\n        },\n\n        /**\n         * @return {module:zrender/core/PathProxy}\n         */\n        closePath: function () {\n            this.addData(CMD.Z);\n\n            var ctx = this._ctx;\n            var x0 = this._x0;\n            var y0 = this._y0;\n            if (ctx) {\n                this._needsDash() && this._dashedLineTo(x0, y0);\n                ctx.closePath();\n            }\n\n            this._xi = x0;\n            this._yi = y0;\n            return this;\n        },\n\n        /**\n         * Context 从外部传入，因为有可能是 rebuildPath 完之后再 fill。\n         * stroke 同样\n         * @param {CanvasRenderingContext2D} ctx\n         * @return {module:zrender/core/PathProxy}\n         */\n        fill: function (ctx) {\n            ctx && ctx.fill();\n            this.toStatic();\n        },\n\n        /**\n         * @param {CanvasRenderingContext2D} ctx\n         * @return {module:zrender/core/PathProxy}\n         */\n        stroke: function (ctx) {\n            ctx && ctx.stroke();\n            this.toStatic();\n        },\n\n        /**\n         * 必须在其它绘制命令前调用\n         * Must be invoked before all other path drawing methods\n         * @return {module:zrender/core/PathProxy}\n         */\n        setLineDash: function (lineDash) {\n            if (lineDash instanceof Array) {\n                this._lineDash = lineDash;\n\n                this._dashIdx = 0;\n\n                var lineDashSum = 0;\n                for (var i = 0; i < lineDash.length; i++) {\n                    lineDashSum += lineDash[i];\n                }\n                this._dashSum = lineDashSum;\n            }\n            return this;\n        },\n\n        /**\n         * 必须在其它绘制命令前调用\n         * Must be invoked before all other path drawing methods\n         * @return {module:zrender/core/PathProxy}\n         */\n        setLineDashOffset: function (offset) {\n            this._dashOffset = offset;\n            return this;\n        },\n\n        /**\n         *\n         * @return {boolean}\n         */\n        len: function () {\n            return this._len;\n        },\n\n        /**\n         * 直接设置 Path 数据\n         */\n        setData: function (data) {\n\n            var len = data.length;\n\n            if (! (this.data && this.data.length == len) && hasTypedArray) {\n                this.data = new Float32Array(len);\n            }\n\n            for (var i = 0; i < len; i++) {\n                this.data[i] = data[i];\n            }\n\n            this._len = len;\n        },\n\n        /**\n         * 添加子路径\n         * @param {module:zrender/core/PathProxy|Array.<module:zrender/core/PathProxy>} path\n         */\n        appendPath: function (path) {\n            if (!(path instanceof Array)) {\n                path = [path];\n            }\n            var len = path.length;\n            var appendSize = 0;\n            var offset = this._len;\n            for (var i = 0; i < len; i++) {\n                appendSize += path[i].len();\n            }\n            if (hasTypedArray && (this.data instanceof Float32Array)) {\n                this.data = new Float32Array(offset + appendSize);\n            }\n            for (var i = 0; i < len; i++) {\n                var appendPathData = path[i].data;\n                for (var k = 0; k < appendPathData.length; k++) {\n                    this.data[offset++] = appendPathData[k];\n                }\n            }\n            this._len = offset;\n        },\n\n        /**\n         * 填充 Path 数据。\n         * 尽量复用而不申明新的数组。大部分图形重绘的指令数据长度都是不变的。\n         */\n        addData: function (cmd) {\n            if (!this._saveData) {\n                return;\n            }\n\n            var data = this.data;\n            if (this._len + arguments.length > data.length) {\n                // 因为之前的数组已经转换成静态的 Float32Array\n                // 所以不够用时需要扩展一个新的动态数组\n                this._expandData();\n                data = this.data;\n            }\n            for (var i = 0; i < arguments.length; i++) {\n                data[this._len++] = arguments[i];\n            }\n\n            this._prevCmd = cmd;\n        },\n\n        _expandData: function () {\n            // Only if data is Float32Array\n            if (!(this.data instanceof Array)) {\n                var newData = [];\n                for (var i = 0; i < this._len; i++) {\n                    newData[i] = this.data[i];\n                }\n                this.data = newData;\n            }\n        },\n\n        /**\n         * If needs js implemented dashed line\n         * @return {boolean}\n         * @private\n         */\n        _needsDash: function () {\n            return this._lineDash;\n        },\n\n        _dashedLineTo: function (x1, y1) {\n            var dashSum = this._dashSum;\n            var offset = this._dashOffset;\n            var lineDash = this._lineDash;\n            var ctx = this._ctx;\n\n            var x0 = this._xi;\n            var y0 = this._yi;\n            var dx = x1 - x0;\n            var dy = y1 - y0;\n            var dist = mathSqrt(dx * dx + dy * dy);\n            var x = x0;\n            var y = y0;\n            var dash;\n            var nDash = lineDash.length;\n            var idx;\n            dx /= dist;\n            dy /= dist;\n\n            if (offset < 0) {\n                // Convert to positive offset\n                offset = dashSum + offset;\n            }\n            offset %= dashSum;\n            x -= offset * dx;\n            y -= offset * dy;\n\n            while ((dx > 0 && x <= x1) || (dx < 0 && x >= x1)\n            || (dx == 0 && ((dy > 0 && y <= y1) || (dy < 0 && y >= y1)))) {\n                idx = this._dashIdx;\n                dash = lineDash[idx];\n                x += dx * dash;\n                y += dy * dash;\n                this._dashIdx = (idx + 1) % nDash;\n                // Skip positive offset\n                if ((dx > 0 && x < x0) || (dx < 0 && x > x0) || (dy > 0 && y < y0) || (dy < 0 && y > y0)) {\n                    continue;\n                }\n                ctx[idx % 2 ? 'moveTo' : 'lineTo'](\n                    dx >= 0 ? mathMin(x, x1) : mathMax(x, x1),\n                    dy >= 0 ? mathMin(y, y1) : mathMax(y, y1)\n                );\n            }\n            // Offset for next lineTo\n            dx = x - x1;\n            dy = y - y1;\n            this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n        },\n\n        // Not accurate dashed line to\n        _dashedBezierTo: function (x1, y1, x2, y2, x3, y3) {\n            var dashSum = this._dashSum;\n            var offset = this._dashOffset;\n            var lineDash = this._lineDash;\n            var ctx = this._ctx;\n\n            var x0 = this._xi;\n            var y0 = this._yi;\n            var t;\n            var dx;\n            var dy;\n            var cubicAt = curve.cubicAt;\n            var bezierLen = 0;\n            var idx = this._dashIdx;\n            var nDash = lineDash.length;\n\n            var x;\n            var y;\n\n            var tmpLen = 0;\n\n            if (offset < 0) {\n                // Convert to positive offset\n                offset = dashSum + offset;\n            }\n            offset %= dashSum;\n            // Bezier approx length\n            for (t = 0; t < 1; t += 0.1) {\n                dx = cubicAt(x0, x1, x2, x3, t + 0.1)\n                    - cubicAt(x0, x1, x2, x3, t);\n                dy = cubicAt(y0, y1, y2, y3, t + 0.1)\n                    - cubicAt(y0, y1, y2, y3, t);\n                bezierLen += mathSqrt(dx * dx + dy * dy);\n            }\n\n            // Find idx after add offset\n            for (; idx < nDash; idx++) {\n                tmpLen += lineDash[idx];\n                if (tmpLen > offset) {\n                    break;\n                }\n            }\n            t = (tmpLen - offset) / bezierLen;\n\n            while (t <= 1) {\n\n                x = cubicAt(x0, x1, x2, x3, t);\n                y = cubicAt(y0, y1, y2, y3, t);\n\n                // Use line to approximate dashed bezier\n                // Bad result if dash is long\n                idx % 2 ? ctx.moveTo(x, y)\n                    : ctx.lineTo(x, y);\n\n                t += lineDash[idx] / bezierLen;\n\n                idx = (idx + 1) % nDash;\n            }\n\n            // Finish the last segment and calculate the new offset\n            (idx % 2 !== 0) && ctx.lineTo(x3, y3);\n            dx = x3 - x;\n            dy = y3 - y;\n            this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n        },\n\n        _dashedQuadraticTo: function (x1, y1, x2, y2) {\n            // Convert quadratic to cubic using degree elevation\n            var x3 = x2;\n            var y3 = y2;\n            x2 = (x2 + 2 * x1) / 3;\n            y2 = (y2 + 2 * y1) / 3;\n            x1 = (this._xi + 2 * x1) / 3;\n            y1 = (this._yi + 2 * y1) / 3;\n\n            this._dashedBezierTo(x1, y1, x2, y2, x3, y3);\n        },\n\n        /**\n         * 转成静态的 Float32Array 减少堆内存占用\n         * Convert dynamic array to static Float32Array\n         */\n        toStatic: function () {\n            var data = this.data;\n            if (data instanceof Array) {\n                data.length = this._len;\n                if (hasTypedArray) {\n                    this.data = new Float32Array(data);\n                }\n            }\n        },\n\n        /**\n         * @return {module:zrender/core/BoundingRect}\n         */\n        getBoundingRect: function () {\n            min[0] = min[1] = min2[0] = min2[1] = Number.MAX_VALUE;\n            max[0] = max[1] = max2[0] = max2[1] = -Number.MAX_VALUE;\n\n            var data = this.data;\n            var xi = 0;\n            var yi = 0;\n            var x0 = 0;\n            var y0 = 0;\n\n            for (var i = 0; i < data.length;) {\n                var cmd = data[i++];\n\n                if (i == 1) {\n                    // 如果第一个命令是 L, C, Q\n                    // 则 previous point 同绘制命令的第一个 point\n                    //\n                    // 第一个命令为 Arc 的情况下会在后面特殊处理\n                    xi = data[i];\n                    yi = data[i + 1];\n\n                    x0 = xi;\n                    y0 = yi;\n                }\n\n                switch (cmd) {\n                    case CMD.M:\n                        // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点\n                        // 在 closePath 的时候使用\n                        x0 = data[i++];\n                        y0 = data[i++];\n                        xi = x0;\n                        yi = y0;\n                        min2[0] = x0;\n                        min2[1] = y0;\n                        max2[0] = x0;\n                        max2[1] = y0;\n                        break;\n                    case CMD.L:\n                        bbox.fromLine(xi, yi, data[i], data[i + 1], min2, max2);\n                        xi = data[i++];\n                        yi = data[i++];\n                        break;\n                    case CMD.C:\n                        bbox.fromCubic(\n                            xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n                            min2, max2\n                        );\n                        xi = data[i++];\n                        yi = data[i++];\n                        break;\n                    case CMD.Q:\n                        bbox.fromQuadratic(\n                            xi, yi, data[i++], data[i++], data[i], data[i + 1],\n                            min2, max2\n                        );\n                        xi = data[i++];\n                        yi = data[i++];\n                        break;\n                    case CMD.A:\n                        // TODO Arc 判断的开销比较大\n                        var cx = data[i++];\n                        var cy = data[i++];\n                        var rx = data[i++];\n                        var ry = data[i++];\n                        var startAngle = data[i++];\n                        var endAngle = data[i++] + startAngle;\n                        // TODO Arc 旋转\n                        var psi = data[i++];\n                        var anticlockwise = 1 - data[i++];\n\n                        if (i == 1) {\n                            // 直接使用 arc 命令\n                            // 第一个命令起点还未定义\n                            x0 = mathCos(startAngle) * rx + cx;\n                            y0 = mathSin(startAngle) * ry + cy;\n                        }\n\n                        bbox.fromArc(\n                            cx, cy, rx, ry, startAngle, endAngle,\n                            anticlockwise, min2, max2\n                        );\n\n                        xi = mathCos(endAngle) * rx + cx;\n                        yi = mathSin(endAngle) * ry + cy;\n                        break;\n                    case CMD.R:\n                        x0 = xi = data[i++];\n                        y0 = yi = data[i++];\n                        var width = data[i++];\n                        var height = data[i++];\n                        // Use fromLine\n                        bbox.fromLine(x0, y0, x0 + width, y0 + height, min2, max2);\n                        break;\n                    case CMD.Z:\n                        xi = x0;\n                        yi = y0;\n                        break;\n                }\n\n                // Union\n                vec2.min(min, min, min2);\n                vec2.max(max, max, max2);\n            }\n\n            // No data\n            if (i === 0) {\n                min[0] = min[1] = max[0] = max[1] = 0;\n            }\n\n            return new BoundingRect(\n                min[0], min[1], max[0] - min[0], max[1] - min[1]\n            );\n        },\n\n        /**\n         * Rebuild path from current data\n         * Rebuild path will not consider javascript implemented line dash.\n         * @param {CanvasRenderingContext} ctx\n         */\n        rebuildPath: function (ctx) {\n            var d = this.data;\n            var x0, y0;\n            var xi, yi;\n            var x, y;\n            var ux = this._ux;\n            var uy = this._uy;\n            var len = this._len;\n            for (var i = 0; i < len;) {\n                var cmd = d[i++];\n\n                if (i == 1) {\n                    // 如果第一个命令是 L, C, Q\n                    // 则 previous point 同绘制命令的第一个 point\n                    //\n                    // 第一个命令为 Arc 的情况下会在后面特殊处理\n                    xi = d[i];\n                    yi = d[i + 1];\n\n                    x0 = xi;\n                    y0 = yi;\n                }\n                switch (cmd) {\n                    case CMD.M:\n                        x0 = xi = d[i++];\n                        y0 = yi = d[i++];\n                        ctx.moveTo(xi, yi);\n                        break;\n                    case CMD.L:\n                        x = d[i++];\n                        y = d[i++];\n                        // Not draw too small seg between\n                        if (mathAbs(x - xi) > ux || mathAbs(y - yi) > uy || i === len - 1) {\n                            ctx.lineTo(x, y);\n                            xi = x;\n                            yi = y;\n                        }\n                        break;\n                    case CMD.C:\n                        ctx.bezierCurveTo(\n                            d[i++], d[i++], d[i++], d[i++], d[i++], d[i++]\n                        );\n                        xi = d[i - 2];\n                        yi = d[i - 1];\n                        break;\n                    case CMD.Q:\n                        ctx.quadraticCurveTo(d[i++], d[i++], d[i++], d[i++]);\n                        xi = d[i - 2];\n                        yi = d[i - 1];\n                        break;\n                    case CMD.A:\n                        var cx = d[i++];\n                        var cy = d[i++];\n                        var rx = d[i++];\n                        var ry = d[i++];\n                        var theta = d[i++];\n                        var dTheta = d[i++];\n                        var psi = d[i++];\n                        var fs = d[i++];\n                        var r = (rx > ry) ? rx : ry;\n                        var scaleX = (rx > ry) ? 1 : rx / ry;\n                        var scaleY = (rx > ry) ? ry / rx : 1;\n                        var isEllipse = Math.abs(rx - ry) > 1e-3;\n                        var endAngle = theta + dTheta;\n                        if (isEllipse) {\n                            ctx.translate(cx, cy);\n                            ctx.rotate(psi);\n                            ctx.scale(scaleX, scaleY);\n                            ctx.arc(0, 0, r, theta, endAngle, 1 - fs);\n                            ctx.scale(1 / scaleX, 1 / scaleY);\n                            ctx.rotate(-psi);\n                            ctx.translate(-cx, -cy);\n                        }\n                        else {\n                            ctx.arc(cx, cy, r, theta, endAngle, 1 - fs);\n                        }\n\n                        if (i == 1) {\n                            // 直接使用 arc 命令\n                            // 第一个命令起点还未定义\n                            x0 = mathCos(theta) * rx + cx;\n                            y0 = mathSin(theta) * ry + cy;\n                        }\n                        xi = mathCos(endAngle) * rx + cx;\n                        yi = mathSin(endAngle) * ry + cy;\n                        break;\n                    case CMD.R:\n                        x0 = xi = d[i];\n                        y0 = yi = d[i + 1];\n                        ctx.rect(d[i++], d[i++], d[i++], d[i++]);\n                        break;\n                    case CMD.Z:\n                        ctx.closePath();\n                        xi = x0;\n                        yi = y0;\n                }\n            }\n        }\n    };\n\n    PathProxy.CMD = CMD;\n\n    module.exports = PathProxy;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL2hvbWUveXgvfi96cmVuZGVyL2xpYi9jb3JlL1BhdGhQcm94eS5qcz80ZmMyIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbi8qKlxuICogUGF0aCDku6PnkIbvvIzlj6/ku6XlnKhgYnVpbGRQYXRoYOS4reeUqOS6juabv+S7o2BjdHhgLCDkvJrkv53lrZjmr4/kuKpwYXRo5pON5L2c55qE5ZG95Luk5YiwcGF0aENvbW1hbmRz5bGe5oCn5LitXG4gKiDlj6/ku6XnlKjkuo4gaXNJbnNpZGVQYXRoIOWIpOaWreS7peWPiuiOt+WPlmJvdW5kaW5nUmVjdFxuICpcbiAqIEBtb2R1bGUgenJlbmRlci9jb3JlL1BhdGhQcm94eVxuICogQGF1dGhvciBZaSBTaGVuIChodHRwOi8vd3d3LmdpdGh1Yi5jb20vcGlzc2FuZylcbiAqL1xuXG4gLy8gVE9ETyBnZXRUb3RhbExlbmd0aCwgZ2V0UG9pbnRBdExlbmd0aFxuXG5cbiAgICB2YXIgY3VydmUgPSByZXF1aXJlKCcuL2N1cnZlJyk7XG4gICAgdmFyIHZlYzIgPSByZXF1aXJlKCcuL3ZlY3RvcicpO1xuICAgIHZhciBiYm94ID0gcmVxdWlyZSgnLi9iYm94Jyk7XG4gICAgdmFyIEJvdW5kaW5nUmVjdCA9IHJlcXVpcmUoJy4vQm91bmRpbmdSZWN0Jyk7XG4gICAgdmFyIGRwciA9IHJlcXVpcmUoJy4uL2NvbmZpZycpLmRldmljZVBpeGVsUmF0aW87XG5cbiAgICB2YXIgQ01EID0ge1xuICAgICAgICBNOiAxLFxuICAgICAgICBMOiAyLFxuICAgICAgICBDOiAzLFxuICAgICAgICBROiA0LFxuICAgICAgICBBOiA1LFxuICAgICAgICBaOiA2LFxuICAgICAgICAvLyBSZWN0XG4gICAgICAgIFI6IDdcbiAgICB9O1xuXG4gICAgLy8gdmFyIENNRF9NRU1fU0laRSA9IHtcbiAgICAvLyAgICAgTTogMyxcbiAgICAvLyAgICAgTDogMyxcbiAgICAvLyAgICAgQzogNyxcbiAgICAvLyAgICAgUTogNSxcbiAgICAvLyAgICAgQTogOSxcbiAgICAvLyAgICAgUjogNSxcbiAgICAvLyAgICAgWjogMVxuICAgIC8vIH07XG5cbiAgICB2YXIgbWluID0gW107XG4gICAgdmFyIG1heCA9IFtdO1xuICAgIHZhciBtaW4yID0gW107XG4gICAgdmFyIG1heDIgPSBbXTtcbiAgICB2YXIgbWF0aE1pbiA9IE1hdGgubWluO1xuICAgIHZhciBtYXRoTWF4ID0gTWF0aC5tYXg7XG4gICAgdmFyIG1hdGhDb3MgPSBNYXRoLmNvcztcbiAgICB2YXIgbWF0aFNpbiA9IE1hdGguc2luO1xuICAgIHZhciBtYXRoU3FydCA9IE1hdGguc3FydDtcbiAgICB2YXIgbWF0aEFicyA9IE1hdGguYWJzO1xuXG4gICAgdmFyIGhhc1R5cGVkQXJyYXkgPSB0eXBlb2YgRmxvYXQzMkFycmF5ICE9ICd1bmRlZmluZWQnO1xuXG4gICAgLyoqXG4gICAgICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5XG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgdmFyIFBhdGhQcm94eSA9IGZ1bmN0aW9uIChub3RTYXZlRGF0YSkge1xuXG4gICAgICAgIHRoaXMuX3NhdmVEYXRhID0gIShub3RTYXZlRGF0YSB8fCBmYWxzZSk7XG5cbiAgICAgICAgaWYgKHRoaXMuX3NhdmVEYXRhKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFBhdGggZGF0YS4gU3RvcmVkIGFzIGZsYXQgYXJyYXlcbiAgICAgICAgICAgICAqIEB0eXBlIHtBcnJheS48T2JqZWN0Pn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5kYXRhID0gW107XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9jdHggPSBudWxsO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiDlv6vpgJ/orqHnrpdQYXRo5YyF5Zu055uS77yI5bm25LiN5piv5pyA5bCP5YyF5Zu055uS77yJXG4gICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAqL1xuICAgIFBhdGhQcm94eS5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IFBhdGhQcm94eSxcblxuICAgICAgICBfeGk6IDAsXG4gICAgICAgIF95aTogMCxcblxuICAgICAgICBfeDA6IDAsXG4gICAgICAgIF95MDogMCxcbiAgICAgICAgLy8gVW5pdCB4LCBVbml0IHkuIFByb3ZpZGUgZm9yIGF2b2lkaW5nIGRyYXdpbmcgdGhhdCB0b28gc2hvcnQgbGluZSBzZWdtZW50XG4gICAgICAgIF91eDogMCxcbiAgICAgICAgX3V5OiAwLFxuXG4gICAgICAgIF9sZW46IDAsXG5cbiAgICAgICAgX2xpbmVEYXNoOiBudWxsLFxuXG4gICAgICAgIF9kYXNoT2Zmc2V0OiAwLFxuXG4gICAgICAgIF9kYXNoSWR4OiAwLFxuXG4gICAgICAgIF9kYXNoU3VtOiAwLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmVhZE9ubHlcbiAgICAgICAgICovXG4gICAgICAgIHNldFNjYWxlOiBmdW5jdGlvbiAoc3gsIHN5KSB7XG4gICAgICAgICAgICB0aGlzLl91eCA9IG1hdGhBYnMoMSAvIGRwciAvIHN4KSB8fCAwO1xuICAgICAgICAgICAgdGhpcy5fdXkgPSBtYXRoQWJzKDEgLyBkcHIgLyBzeSkgfHwgMDtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRDb250ZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY3R4O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICAgICAgICovXG4gICAgICAgIGJlZ2luUGF0aDogZnVuY3Rpb24gKGN0eCkge1xuXG4gICAgICAgICAgICB0aGlzLl9jdHggPSBjdHg7XG5cbiAgICAgICAgICAgIGN0eCAmJiBjdHguYmVnaW5QYXRoKCk7XG5cbiAgICAgICAgICAgIGN0eCAmJiAodGhpcy5kcHIgPSBjdHguZHByKTtcblxuICAgICAgICAgICAgLy8gUmVzZXRcbiAgICAgICAgICAgIGlmICh0aGlzLl9zYXZlRGF0YSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xlbiA9IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9saW5lRGFzaCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xpbmVEYXNoID0gbnVsbDtcblxuICAgICAgICAgICAgICAgIHRoaXMuX2Rhc2hPZmZzZXQgPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB4XG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0geVxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICAgICAgICovXG4gICAgICAgIG1vdmVUbzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkRGF0YShDTUQuTSwgeCwgeSk7XG4gICAgICAgICAgICB0aGlzLl9jdHggJiYgdGhpcy5fY3R4Lm1vdmVUbyh4LCB5KTtcblxuICAgICAgICAgICAgLy8geDAsIHkwLCB4aSwgeWkg5piv6K6w5b2V5ZyoIF9kYXNoZWRYWFhYVG8g5pa55rOV5Lit5L2/55SoXG4gICAgICAgICAgICAvLyB4aSwgeWkg6K6w5b2V5b2T5YmN54K5LCB4MCwgeTAg5ZyoIGNsb3NlUGF0aCDnmoTml7blgJnlm57liLDotbflp4vngrnjgIJcbiAgICAgICAgICAgIC8vIOacieWPr+iDveWcqCBiZWdpblBhdGgg5LmL5ZCO55u05o6l6LCD55SoIGxpbmVUb++8jOi/meaXtuWAmSB4MCwgeTAg6ZyA6KaBXG4gICAgICAgICAgICAvLyDlnKggbGluZVRvIOaWueazleS4reiusOW9le+8jOi/memHjOWFiOS4jeiAg+iZkei/meenjeaDheWGte+8jGRhc2hlZCBsaW5lIOS5n+WPquWcqCBJRTEwLSDkuK3kuI3mlK/mjIFcbiAgICAgICAgICAgIHRoaXMuX3gwID0geDtcbiAgICAgICAgICAgIHRoaXMuX3kwID0geTtcblxuICAgICAgICAgICAgdGhpcy5feGkgPSB4O1xuICAgICAgICAgICAgdGhpcy5feWkgPSB5O1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB4XG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0geVxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICAgICAgICovXG4gICAgICAgIGxpbmVUbzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgIHZhciBleGNlZWRVbml0ID0gbWF0aEFicyh4IC0gdGhpcy5feGkpID4gdGhpcy5fdXhcbiAgICAgICAgICAgICAgICB8fCBtYXRoQWJzKHkgLSB0aGlzLl95aSkgPiB0aGlzLl91eVxuICAgICAgICAgICAgICAgIC8vIEZvcmNlIGRyYXcgdGhlIGZpcnN0IHNlZ21lbnRcbiAgICAgICAgICAgICAgICB8fCB0aGlzLl9sZW4gPCA1O1xuXG4gICAgICAgICAgICB0aGlzLmFkZERhdGEoQ01ELkwsIHgsIHkpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fY3R4ICYmIGV4Y2VlZFVuaXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9uZWVkc0Rhc2goKSA/IHRoaXMuX2Rhc2hlZExpbmVUbyh4LCB5KVxuICAgICAgICAgICAgICAgICAgICA6IHRoaXMuX2N0eC5saW5lVG8oeCwgeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXhjZWVkVW5pdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3hpID0geDtcbiAgICAgICAgICAgICAgICB0aGlzLl95aSA9IHk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgxXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0geTFcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB4MlxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkyXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0geDNcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB5M1xuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICAgICAgICovXG4gICAgICAgIGJlemllckN1cnZlVG86IGZ1bmN0aW9uICh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKSB7XG4gICAgICAgICAgICB0aGlzLmFkZERhdGEoQ01ELkMsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2N0eCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX25lZWRzRGFzaCgpID8gdGhpcy5fZGFzaGVkQmV6aWVyVG8oeDEsIHkxLCB4MiwgeTIsIHgzLCB5MylcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLl9jdHguYmV6aWVyQ3VydmVUbyh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3hpID0geDM7XG4gICAgICAgICAgICB0aGlzLl95aSA9IHkzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0geDFcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB5MVxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgyXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0geTJcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl9XG4gICAgICAgICAqL1xuICAgICAgICBxdWFkcmF0aWNDdXJ2ZVRvOiBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkRGF0YShDTUQuUSwgeDEsIHkxLCB4MiwgeTIpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2N0eCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX25lZWRzRGFzaCgpID8gdGhpcy5fZGFzaGVkUXVhZHJhdGljVG8oeDEsIHkxLCB4MiwgeTIpXG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy5fY3R4LnF1YWRyYXRpY0N1cnZlVG8oeDEsIHkxLCB4MiwgeTIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5feGkgPSB4MjtcbiAgICAgICAgICAgIHRoaXMuX3lpID0geTI7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSBjeFxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IGN5XG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gclxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHN0YXJ0QW5nbGVcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSBlbmRBbmdsZVxuICAgICAgICAgKiBAcGFyYW0gIHtib29sZWFufSBhbnRpY2xvY2t3aXNlXG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5fVxuICAgICAgICAgKi9cbiAgICAgICAgYXJjOiBmdW5jdGlvbiAoY3gsIGN5LCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYW50aWNsb2Nrd2lzZSkge1xuICAgICAgICAgICAgdGhpcy5hZGREYXRhKFxuICAgICAgICAgICAgICAgIENNRC5BLCBjeCwgY3ksIHIsIHIsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlIC0gc3RhcnRBbmdsZSwgMCwgYW50aWNsb2Nrd2lzZSA/IDAgOiAxXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy5fY3R4ICYmIHRoaXMuX2N0eC5hcmMoY3gsIGN5LCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYW50aWNsb2Nrd2lzZSk7XG5cbiAgICAgICAgICAgIHRoaXMuX3hpID0gbWF0aENvcyhlbmRBbmdsZSkgKiByICsgY3g7XG4gICAgICAgICAgICB0aGlzLl95aSA9IG1hdGhTaW4oZW5kQW5nbGUpICogciArIGN4O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gVE9ET1xuICAgICAgICBhcmNUbzogZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyLCByYWRpdXMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jdHgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jdHguYXJjVG8oeDEsIHkxLCB4MiwgeTIsIHJhZGl1cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBUT0RPXG4gICAgICAgIHJlY3Q6IGZ1bmN0aW9uICh4LCB5LCB3LCBoKSB7XG4gICAgICAgICAgICB0aGlzLl9jdHggJiYgdGhpcy5fY3R4LnJlY3QoeCwgeSwgdywgaCk7XG4gICAgICAgICAgICB0aGlzLmFkZERhdGEoQ01ELlIsIHgsIHksIHcsIGgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5fVxuICAgICAgICAgKi9cbiAgICAgICAgY2xvc2VQYXRoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmFkZERhdGEoQ01ELlopO1xuXG4gICAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuICAgICAgICAgICAgdmFyIHgwID0gdGhpcy5feDA7XG4gICAgICAgICAgICB2YXIgeTAgPSB0aGlzLl95MDtcbiAgICAgICAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9uZWVkc0Rhc2goKSAmJiB0aGlzLl9kYXNoZWRMaW5lVG8oeDAsIHkwKTtcbiAgICAgICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX3hpID0geDA7XG4gICAgICAgICAgICB0aGlzLl95aSA9IHkwO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnRleHQg5LuO5aSW6YOo5Lyg5YWl77yM5Zug5Li65pyJ5Y+v6IO95pivIHJlYnVpbGRQYXRoIOWujOS5i+WQjuWGjSBmaWxs44CCXG4gICAgICAgICAqIHN0cm9rZSDlkIzmoLdcbiAgICAgICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICAgICAgICovXG4gICAgICAgIGZpbGw6IGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgICAgIGN0eCAmJiBjdHguZmlsbCgpO1xuICAgICAgICAgICAgdGhpcy50b1N0YXRpYygpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5fVxuICAgICAgICAgKi9cbiAgICAgICAgc3Ryb2tlOiBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgICAgICBjdHggJiYgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgICAgdGhpcy50b1N0YXRpYygpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlv4XpobvlnKjlhbblroPnu5jliLblkb3ku6TliY3osIPnlKhcbiAgICAgICAgICogTXVzdCBiZSBpbnZva2VkIGJlZm9yZSBhbGwgb3RoZXIgcGF0aCBkcmF3aW5nIG1ldGhvZHNcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl9XG4gICAgICAgICAqL1xuICAgICAgICBzZXRMaW5lRGFzaDogZnVuY3Rpb24gKGxpbmVEYXNoKSB7XG4gICAgICAgICAgICBpZiAobGluZURhc2ggaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xpbmVEYXNoID0gbGluZURhc2g7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9kYXNoSWR4ID0gMDtcblxuICAgICAgICAgICAgICAgIHZhciBsaW5lRGFzaFN1bSA9IDA7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lRGFzaC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBsaW5lRGFzaFN1bSArPSBsaW5lRGFzaFtpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fZGFzaFN1bSA9IGxpbmVEYXNoU3VtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOW/hemhu+WcqOWFtuWug+e7mOWItuWRveS7pOWJjeiwg+eUqFxuICAgICAgICAgKiBNdXN0IGJlIGludm9rZWQgYmVmb3JlIGFsbCBvdGhlciBwYXRoIGRyYXdpbmcgbWV0aG9kc1xuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICAgICAgICovXG4gICAgICAgIHNldExpbmVEYXNoT2Zmc2V0OiBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICAgICAgICB0aGlzLl9kYXNoT2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBsZW46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sZW47XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOebtOaOpeiuvue9riBQYXRoIOaVsOaNrlxuICAgICAgICAgKi9cbiAgICAgICAgc2V0RGF0YTogZnVuY3Rpb24gKGRhdGEpIHtcblxuICAgICAgICAgICAgdmFyIGxlbiA9IGRhdGEubGVuZ3RoO1xuXG4gICAgICAgICAgICBpZiAoISAodGhpcy5kYXRhICYmIHRoaXMuZGF0YS5sZW5ndGggPT0gbGVuKSAmJiBoYXNUeXBlZEFycmF5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhID0gbmV3IEZsb2F0MzJBcnJheShsZW4pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhW2ldID0gZGF0YVtpXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fbGVuID0gbGVuO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmt7vliqDlrZDot6/lvoRcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eXxBcnJheS48bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHk+fSBwYXRoXG4gICAgICAgICAqL1xuICAgICAgICBhcHBlbmRQYXRoOiBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICAgICAgaWYgKCEocGF0aCBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgICAgICAgICAgIHBhdGggPSBbcGF0aF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbGVuID0gcGF0aC5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgYXBwZW5kU2l6ZSA9IDA7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5fbGVuO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGFwcGVuZFNpemUgKz0gcGF0aFtpXS5sZW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoYXNUeXBlZEFycmF5ICYmICh0aGlzLmRhdGEgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhID0gbmV3IEZsb2F0MzJBcnJheShvZmZzZXQgKyBhcHBlbmRTaXplKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgYXBwZW5kUGF0aERhdGEgPSBwYXRoW2ldLmRhdGE7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBhcHBlbmRQYXRoRGF0YS5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGFbb2Zmc2V0KytdID0gYXBwZW5kUGF0aERhdGFba107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbGVuID0gb2Zmc2V0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDloavlhYUgUGF0aCDmlbDmja7jgIJcbiAgICAgICAgICog5bC96YeP5aSN55So6ICM5LiN55Sz5piO5paw55qE5pWw57uE44CC5aSn6YOo5YiG5Zu+5b2i6YeN57uY55qE5oyH5Luk5pWw5o2u6ZW/5bqm6YO95piv5LiN5Y+Y55qE44CCXG4gICAgICAgICAqL1xuICAgICAgICBhZGREYXRhOiBmdW5jdGlvbiAoY21kKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3NhdmVEYXRhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9sZW4gKyBhcmd1bWVudHMubGVuZ3RoID4gZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyDlm6DkuLrkuYvliY3nmoTmlbDnu4Tlt7Lnu4/ovazmjaLmiJDpnZnmgIHnmoQgRmxvYXQzMkFycmF5XG4gICAgICAgICAgICAgICAgLy8g5omA5Lul5LiN5aSf55So5pe26ZyA6KaB5omp5bGV5LiA5Liq5paw55qE5Yqo5oCB5pWw57uEXG4gICAgICAgICAgICAgICAgdGhpcy5fZXhwYW5kRGF0YSgpO1xuICAgICAgICAgICAgICAgIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGRhdGFbdGhpcy5fbGVuKytdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9wcmV2Q21kID0gY21kO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9leHBhbmREYXRhOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBPbmx5IGlmIGRhdGEgaXMgRmxvYXQzMkFycmF5XG4gICAgICAgICAgICBpZiAoISh0aGlzLmRhdGEgaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV3RGF0YSA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3RGF0YVtpXSA9IHRoaXMuZGF0YVtpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhID0gbmV3RGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgbmVlZHMganMgaW1wbGVtZW50ZWQgZGFzaGVkIGxpbmVcbiAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF9uZWVkc0Rhc2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9saW5lRGFzaDtcbiAgICAgICAgfSxcblxuICAgICAgICBfZGFzaGVkTGluZVRvOiBmdW5jdGlvbiAoeDEsIHkxKSB7XG4gICAgICAgICAgICB2YXIgZGFzaFN1bSA9IHRoaXMuX2Rhc2hTdW07XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5fZGFzaE9mZnNldDtcbiAgICAgICAgICAgIHZhciBsaW5lRGFzaCA9IHRoaXMuX2xpbmVEYXNoO1xuICAgICAgICAgICAgdmFyIGN0eCA9IHRoaXMuX2N0eDtcblxuICAgICAgICAgICAgdmFyIHgwID0gdGhpcy5feGk7XG4gICAgICAgICAgICB2YXIgeTAgPSB0aGlzLl95aTtcbiAgICAgICAgICAgIHZhciBkeCA9IHgxIC0geDA7XG4gICAgICAgICAgICB2YXIgZHkgPSB5MSAtIHkwO1xuICAgICAgICAgICAgdmFyIGRpc3QgPSBtYXRoU3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICAgICAgICB2YXIgeCA9IHgwO1xuICAgICAgICAgICAgdmFyIHkgPSB5MDtcbiAgICAgICAgICAgIHZhciBkYXNoO1xuICAgICAgICAgICAgdmFyIG5EYXNoID0gbGluZURhc2gubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGlkeDtcbiAgICAgICAgICAgIGR4IC89IGRpc3Q7XG4gICAgICAgICAgICBkeSAvPSBkaXN0O1xuXG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgdG8gcG9zaXRpdmUgb2Zmc2V0XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gZGFzaFN1bSArIG9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9mZnNldCAlPSBkYXNoU3VtO1xuICAgICAgICAgICAgeCAtPSBvZmZzZXQgKiBkeDtcbiAgICAgICAgICAgIHkgLT0gb2Zmc2V0ICogZHk7XG5cbiAgICAgICAgICAgIHdoaWxlICgoZHggPiAwICYmIHggPD0geDEpIHx8IChkeCA8IDAgJiYgeCA+PSB4MSlcbiAgICAgICAgICAgIHx8IChkeCA9PSAwICYmICgoZHkgPiAwICYmIHkgPD0geTEpIHx8IChkeSA8IDAgJiYgeSA+PSB5MSkpKSkge1xuICAgICAgICAgICAgICAgIGlkeCA9IHRoaXMuX2Rhc2hJZHg7XG4gICAgICAgICAgICAgICAgZGFzaCA9IGxpbmVEYXNoW2lkeF07XG4gICAgICAgICAgICAgICAgeCArPSBkeCAqIGRhc2g7XG4gICAgICAgICAgICAgICAgeSArPSBkeSAqIGRhc2g7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGFzaElkeCA9IChpZHggKyAxKSAlIG5EYXNoO1xuICAgICAgICAgICAgICAgIC8vIFNraXAgcG9zaXRpdmUgb2Zmc2V0XG4gICAgICAgICAgICAgICAgaWYgKChkeCA+IDAgJiYgeCA8IHgwKSB8fCAoZHggPCAwICYmIHggPiB4MCkgfHwgKGR5ID4gMCAmJiB5IDwgeTApIHx8IChkeSA8IDAgJiYgeSA+IHkwKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3R4W2lkeCAlIDIgPyAnbW92ZVRvJyA6ICdsaW5lVG8nXShcbiAgICAgICAgICAgICAgICAgICAgZHggPj0gMCA/IG1hdGhNaW4oeCwgeDEpIDogbWF0aE1heCh4LCB4MSksXG4gICAgICAgICAgICAgICAgICAgIGR5ID49IDAgPyBtYXRoTWluKHksIHkxKSA6IG1hdGhNYXgoeSwgeTEpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE9mZnNldCBmb3IgbmV4dCBsaW5lVG9cbiAgICAgICAgICAgIGR4ID0geCAtIHgxO1xuICAgICAgICAgICAgZHkgPSB5IC0geTE7XG4gICAgICAgICAgICB0aGlzLl9kYXNoT2Zmc2V0ID0gLW1hdGhTcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBOb3QgYWNjdXJhdGUgZGFzaGVkIGxpbmUgdG9cbiAgICAgICAgX2Rhc2hlZEJlemllclRvOiBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIsIHgzLCB5Mykge1xuICAgICAgICAgICAgdmFyIGRhc2hTdW0gPSB0aGlzLl9kYXNoU3VtO1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMuX2Rhc2hPZmZzZXQ7XG4gICAgICAgICAgICB2YXIgbGluZURhc2ggPSB0aGlzLl9saW5lRGFzaDtcbiAgICAgICAgICAgIHZhciBjdHggPSB0aGlzLl9jdHg7XG5cbiAgICAgICAgICAgIHZhciB4MCA9IHRoaXMuX3hpO1xuICAgICAgICAgICAgdmFyIHkwID0gdGhpcy5feWk7XG4gICAgICAgICAgICB2YXIgdDtcbiAgICAgICAgICAgIHZhciBkeDtcbiAgICAgICAgICAgIHZhciBkeTtcbiAgICAgICAgICAgIHZhciBjdWJpY0F0ID0gY3VydmUuY3ViaWNBdDtcbiAgICAgICAgICAgIHZhciBiZXppZXJMZW4gPSAwO1xuICAgICAgICAgICAgdmFyIGlkeCA9IHRoaXMuX2Rhc2hJZHg7XG4gICAgICAgICAgICB2YXIgbkRhc2ggPSBsaW5lRGFzaC5sZW5ndGg7XG5cbiAgICAgICAgICAgIHZhciB4O1xuICAgICAgICAgICAgdmFyIHk7XG5cbiAgICAgICAgICAgIHZhciB0bXBMZW4gPSAwO1xuXG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgdG8gcG9zaXRpdmUgb2Zmc2V0XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gZGFzaFN1bSArIG9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9mZnNldCAlPSBkYXNoU3VtO1xuICAgICAgICAgICAgLy8gQmV6aWVyIGFwcHJveCBsZW5ndGhcbiAgICAgICAgICAgIGZvciAodCA9IDA7IHQgPCAxOyB0ICs9IDAuMSkge1xuICAgICAgICAgICAgICAgIGR4ID0gY3ViaWNBdCh4MCwgeDEsIHgyLCB4MywgdCArIDAuMSlcbiAgICAgICAgICAgICAgICAgICAgLSBjdWJpY0F0KHgwLCB4MSwgeDIsIHgzLCB0KTtcbiAgICAgICAgICAgICAgICBkeSA9IGN1YmljQXQoeTAsIHkxLCB5MiwgeTMsIHQgKyAwLjEpXG4gICAgICAgICAgICAgICAgICAgIC0gY3ViaWNBdCh5MCwgeTEsIHkyLCB5MywgdCk7XG4gICAgICAgICAgICAgICAgYmV6aWVyTGVuICs9IG1hdGhTcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRmluZCBpZHggYWZ0ZXIgYWRkIG9mZnNldFxuICAgICAgICAgICAgZm9yICg7IGlkeCA8IG5EYXNoOyBpZHgrKykge1xuICAgICAgICAgICAgICAgIHRtcExlbiArPSBsaW5lRGFzaFtpZHhdO1xuICAgICAgICAgICAgICAgIGlmICh0bXBMZW4gPiBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdCA9ICh0bXBMZW4gLSBvZmZzZXQpIC8gYmV6aWVyTGVuO1xuXG4gICAgICAgICAgICB3aGlsZSAodCA8PSAxKSB7XG5cbiAgICAgICAgICAgICAgICB4ID0gY3ViaWNBdCh4MCwgeDEsIHgyLCB4MywgdCk7XG4gICAgICAgICAgICAgICAgeSA9IGN1YmljQXQoeTAsIHkxLCB5MiwgeTMsIHQpO1xuXG4gICAgICAgICAgICAgICAgLy8gVXNlIGxpbmUgdG8gYXBwcm94aW1hdGUgZGFzaGVkIGJlemllclxuICAgICAgICAgICAgICAgIC8vIEJhZCByZXN1bHQgaWYgZGFzaCBpcyBsb25nXG4gICAgICAgICAgICAgICAgaWR4ICUgMiA/IGN0eC5tb3ZlVG8oeCwgeSlcbiAgICAgICAgICAgICAgICAgICAgOiBjdHgubGluZVRvKHgsIHkpO1xuXG4gICAgICAgICAgICAgICAgdCArPSBsaW5lRGFzaFtpZHhdIC8gYmV6aWVyTGVuO1xuXG4gICAgICAgICAgICAgICAgaWR4ID0gKGlkeCArIDEpICUgbkRhc2g7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZpbmlzaCB0aGUgbGFzdCBzZWdtZW50IGFuZCBjYWxjdWxhdGUgdGhlIG5ldyBvZmZzZXRcbiAgICAgICAgICAgIChpZHggJSAyICE9PSAwKSAmJiBjdHgubGluZVRvKHgzLCB5Myk7XG4gICAgICAgICAgICBkeCA9IHgzIC0geDtcbiAgICAgICAgICAgIGR5ID0geTMgLSB5O1xuICAgICAgICAgICAgdGhpcy5fZGFzaE9mZnNldCA9IC1tYXRoU3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2Rhc2hlZFF1YWRyYXRpY1RvOiBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIpIHtcbiAgICAgICAgICAgIC8vIENvbnZlcnQgcXVhZHJhdGljIHRvIGN1YmljIHVzaW5nIGRlZ3JlZSBlbGV2YXRpb25cbiAgICAgICAgICAgIHZhciB4MyA9IHgyO1xuICAgICAgICAgICAgdmFyIHkzID0geTI7XG4gICAgICAgICAgICB4MiA9ICh4MiArIDIgKiB4MSkgLyAzO1xuICAgICAgICAgICAgeTIgPSAoeTIgKyAyICogeTEpIC8gMztcbiAgICAgICAgICAgIHgxID0gKHRoaXMuX3hpICsgMiAqIHgxKSAvIDM7XG4gICAgICAgICAgICB5MSA9ICh0aGlzLl95aSArIDIgKiB5MSkgLyAzO1xuXG4gICAgICAgICAgICB0aGlzLl9kYXNoZWRCZXppZXJUbyh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog6L2s5oiQ6Z2Z5oCB55qEIEZsb2F0MzJBcnJheSDlh4/lsJHloIblhoXlrZjljaDnlKhcbiAgICAgICAgICogQ29udmVydCBkeW5hbWljIGFycmF5IHRvIHN0YXRpYyBGbG9hdDMyQXJyYXlcbiAgICAgICAgICovXG4gICAgICAgIHRvU3RhdGljOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgICAgICAgIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICBkYXRhLmxlbmd0aCA9IHRoaXMuX2xlbjtcbiAgICAgICAgICAgICAgICBpZiAoaGFzVHlwZWRBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGEgPSBuZXcgRmxvYXQzMkFycmF5KGRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9Cb3VuZGluZ1JlY3R9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRCb3VuZGluZ1JlY3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIG1pblswXSA9IG1pblsxXSA9IG1pbjJbMF0gPSBtaW4yWzFdID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgICAgIG1heFswXSA9IG1heFsxXSA9IG1heDJbMF0gPSBtYXgyWzFdID0gLU51bWJlci5NQVhfVkFMVUU7XG5cbiAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICAgICAgICAgICAgdmFyIHhpID0gMDtcbiAgICAgICAgICAgIHZhciB5aSA9IDA7XG4gICAgICAgICAgICB2YXIgeDAgPSAwO1xuICAgICAgICAgICAgdmFyIHkwID0gMDtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDspIHtcbiAgICAgICAgICAgICAgICB2YXIgY21kID0gZGF0YVtpKytdO1xuXG4gICAgICAgICAgICAgICAgaWYgKGkgPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyDlpoLmnpznrKzkuIDkuKrlkb3ku6TmmK8gTCwgQywgUVxuICAgICAgICAgICAgICAgICAgICAvLyDliJkgcHJldmlvdXMgcG9pbnQg5ZCM57uY5Yi25ZG95Luk55qE56ys5LiA5LiqIHBvaW50XG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vIOesrOS4gOS4quWRveS7pOS4uiBBcmMg55qE5oOF5Ya15LiL5Lya5Zyo5ZCO6Z2i54m55q6K5aSE55CGXG4gICAgICAgICAgICAgICAgICAgIHhpID0gZGF0YVtpXTtcbiAgICAgICAgICAgICAgICAgICAgeWkgPSBkYXRhW2kgKyAxXTtcblxuICAgICAgICAgICAgICAgICAgICB4MCA9IHhpO1xuICAgICAgICAgICAgICAgICAgICB5MCA9IHlpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHN3aXRjaCAoY21kKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgQ01ELk06XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtb3ZlVG8g5ZG95Luk6YeN5paw5Yib5bu65LiA5Liq5paw55qEIHN1YnBhdGgsIOW5tuS4lOabtOaWsOaWsOeahOi1t+eCuVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8g5ZyoIGNsb3NlUGF0aCDnmoTml7blgJnkvb/nlKhcbiAgICAgICAgICAgICAgICAgICAgICAgIHgwID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgeTAgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB4aSA9IHgwO1xuICAgICAgICAgICAgICAgICAgICAgICAgeWkgPSB5MDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbjJbMF0gPSB4MDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbjJbMV0gPSB5MDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heDJbMF0gPSB4MDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heDJbMV0gPSB5MDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIENNRC5MOlxuICAgICAgICAgICAgICAgICAgICAgICAgYmJveC5mcm9tTGluZSh4aSwgeWksIGRhdGFbaV0sIGRhdGFbaSArIDFdLCBtaW4yLCBtYXgyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhpID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgeWkgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBDTUQuQzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGJib3guZnJvbUN1YmljKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhpLCB5aSwgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW4yLCBtYXgyXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgeGkgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB5aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIENNRC5ROlxuICAgICAgICAgICAgICAgICAgICAgICAgYmJveC5mcm9tUXVhZHJhdGljKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhpLCB5aSwgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaV0sIGRhdGFbaSArIDFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbjIsIG1heDJcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB4aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgQ01ELkE6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIEFyYyDliKTmlq3nmoTlvIDplIDmr5TovoPlpKdcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjeCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjeSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByeCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByeSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdGFydEFuZ2xlID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVuZEFuZ2xlID0gZGF0YVtpKytdICsgc3RhcnRBbmdsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gQXJjIOaXi+i9rFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBzaSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhbnRpY2xvY2t3aXNlID0gMSAtIGRhdGFbaSsrXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIOebtOaOpeS9v+eUqCBhcmMg5ZG95LukXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8g56ys5LiA5Liq5ZG95Luk6LW354K56L+Y5pyq5a6a5LmJXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDAgPSBtYXRoQ29zKHN0YXJ0QW5nbGUpICogcnggKyBjeDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5MCA9IG1hdGhTaW4oc3RhcnRBbmdsZSkgKiByeSArIGN5O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBiYm94LmZyb21BcmMoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3gsIGN5LCByeCwgcnksIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFudGljbG9ja3dpc2UsIG1pbjIsIG1heDJcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHhpID0gbWF0aENvcyhlbmRBbmdsZSkgKiByeCArIGN4O1xuICAgICAgICAgICAgICAgICAgICAgICAgeWkgPSBtYXRoU2luKGVuZEFuZ2xlKSAqIHJ5ICsgY3k7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBDTUQuUjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHgwID0geGkgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB5MCA9IHlpID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhlaWdodCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZSBmcm9tTGluZVxuICAgICAgICAgICAgICAgICAgICAgICAgYmJveC5mcm9tTGluZSh4MCwgeTAsIHgwICsgd2lkdGgsIHkwICsgaGVpZ2h0LCBtaW4yLCBtYXgyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIENNRC5aOlxuICAgICAgICAgICAgICAgICAgICAgICAgeGkgPSB4MDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpID0geTA7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBVbmlvblxuICAgICAgICAgICAgICAgIHZlYzIubWluKG1pbiwgbWluLCBtaW4yKTtcbiAgICAgICAgICAgICAgICB2ZWMyLm1heChtYXgsIG1heCwgbWF4Mik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE5vIGRhdGFcbiAgICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbWluWzBdID0gbWluWzFdID0gbWF4WzBdID0gbWF4WzFdID0gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG5ldyBCb3VuZGluZ1JlY3QoXG4gICAgICAgICAgICAgICAgbWluWzBdLCBtaW5bMV0sIG1heFswXSAtIG1pblswXSwgbWF4WzFdIC0gbWluWzFdXG4gICAgICAgICAgICApO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWJ1aWxkIHBhdGggZnJvbSBjdXJyZW50IGRhdGFcbiAgICAgICAgICogUmVidWlsZCBwYXRoIHdpbGwgbm90IGNvbnNpZGVyIGphdmFzY3JpcHQgaW1wbGVtZW50ZWQgbGluZSBkYXNoLlxuICAgICAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHR9IGN0eFxuICAgICAgICAgKi9cbiAgICAgICAgcmVidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgICAgIHZhciBkID0gdGhpcy5kYXRhO1xuICAgICAgICAgICAgdmFyIHgwLCB5MDtcbiAgICAgICAgICAgIHZhciB4aSwgeWk7XG4gICAgICAgICAgICB2YXIgeCwgeTtcbiAgICAgICAgICAgIHZhciB1eCA9IHRoaXMuX3V4O1xuICAgICAgICAgICAgdmFyIHV5ID0gdGhpcy5fdXk7XG4gICAgICAgICAgICB2YXIgbGVuID0gdGhpcy5fbGVuO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47KSB7XG4gICAgICAgICAgICAgICAgdmFyIGNtZCA9IGRbaSsrXTtcblxuICAgICAgICAgICAgICAgIGlmIChpID09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8g5aaC5p6c56ys5LiA5Liq5ZG95Luk5pivIEwsIEMsIFFcbiAgICAgICAgICAgICAgICAgICAgLy8g5YiZIHByZXZpb3VzIHBvaW50IOWQjOe7mOWItuWRveS7pOeahOesrOS4gOS4qiBwb2ludFxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyDnrKzkuIDkuKrlkb3ku6TkuLogQXJjIOeahOaDheWGteS4i+S8muWcqOWQjumdoueJueauiuWkhOeQhlxuICAgICAgICAgICAgICAgICAgICB4aSA9IGRbaV07XG4gICAgICAgICAgICAgICAgICAgIHlpID0gZFtpICsgMV07XG5cbiAgICAgICAgICAgICAgICAgICAgeDAgPSB4aTtcbiAgICAgICAgICAgICAgICAgICAgeTAgPSB5aTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3dpdGNoIChjbWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBDTUQuTTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHgwID0geGkgPSBkW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB5MCA9IHlpID0gZFtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyh4aSwgeWkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgQ01ELkw6XG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gZFtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IGRbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdCBkcmF3IHRvbyBzbWFsbCBzZWcgYmV0d2VlblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGhBYnMoeCAtIHhpKSA+IHV4IHx8IG1hdGhBYnMoeSAtIHlpKSA+IHV5IHx8IGkgPT09IGxlbiAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhpID0geDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5aSA9IHk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBDTUQuQzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRbaSsrXSwgZFtpKytdLCBkW2krK10sIGRbaSsrXSwgZFtpKytdLCBkW2krK11cbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB4aSA9IGRbaSAtIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgeWkgPSBkW2kgLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIENNRC5ROlxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oZFtpKytdLCBkW2krK10sIGRbaSsrXSwgZFtpKytdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhpID0gZFtpIC0gMl07XG4gICAgICAgICAgICAgICAgICAgICAgICB5aSA9IGRbaSAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgQ01ELkE6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3ggPSBkW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3kgPSBkW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcnggPSBkW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcnkgPSBkW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGhldGEgPSBkW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZFRoZXRhID0gZFtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBzaSA9IGRbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmcyA9IGRbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByID0gKHJ4ID4gcnkpID8gcnggOiByeTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY2FsZVggPSAocnggPiByeSkgPyAxIDogcnggLyByeTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY2FsZVkgPSAocnggPiByeSkgPyByeSAvIHJ4IDogMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpc0VsbGlwc2UgPSBNYXRoLmFicyhyeCAtIHJ5KSA+IDFlLTM7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW5kQW5nbGUgPSB0aGV0YSArIGRUaGV0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0VsbGlwc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKGN4LCBjeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnJvdGF0ZShwc2kpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5zY2FsZShzY2FsZVgsIHNjYWxlWSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmFyYygwLCAwLCByLCB0aGV0YSwgZW5kQW5nbGUsIDEgLSBmcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnNjYWxlKDEgLyBzY2FsZVgsIDEgLyBzY2FsZVkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5yb3RhdGUoLXBzaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSgtY3gsIC1jeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHguYXJjKGN4LCBjeSwgciwgdGhldGEsIGVuZEFuZ2xlLCAxIC0gZnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8g55u05o6l5L2/55SoIGFyYyDlkb3ku6RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyDnrKzkuIDkuKrlkb3ku6Totbfngrnov5jmnKrlrprkuYlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4MCA9IG1hdGhDb3ModGhldGEpICogcnggKyBjeDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5MCA9IG1hdGhTaW4odGhldGEpICogcnkgKyBjeTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHhpID0gbWF0aENvcyhlbmRBbmdsZSkgKiByeCArIGN4O1xuICAgICAgICAgICAgICAgICAgICAgICAgeWkgPSBtYXRoU2luKGVuZEFuZ2xlKSAqIHJ5ICsgY3k7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBDTUQuUjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHgwID0geGkgPSBkW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgeTAgPSB5aSA9IGRbaSArIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnJlY3QoZFtpKytdLCBkW2krK10sIGRbaSsrXSwgZFtpKytdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIENNRC5aOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgeGkgPSB4MDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpID0geTA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIFBhdGhQcm94eS5DTUQgPSBDTUQ7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFBhdGhQcm94eTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9ob21lL3l4L34venJlbmRlci9saWIvY29yZS9QYXRoUHJveHkuanNcbi8vIG1vZHVsZSBpZCA9IDI1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 26 */
/* unknown exports provided */
/* all exports used */
/*!*********************************!*\
  !*** ./lib/CoordinateSystem.js ***!
  \*********************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\n    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 0);\n\n    var coordinateSystemCreators = {};\n\n    function CoordinateSystemManager() {\n\n        this._coordinateSystems = [];\n    }\n\n    CoordinateSystemManager.prototype = {\n\n        constructor: CoordinateSystemManager,\n\n        create: function (ecModel, api) {\n            var coordinateSystems = [];\n            zrUtil.each(coordinateSystemCreators, function (creater, type) {\n                var list = creater.create(ecModel, api);\n                coordinateSystems = coordinateSystems.concat(list || []);\n            });\n\n            this._coordinateSystems = coordinateSystems;\n        },\n\n        update: function (ecModel, api) {\n            zrUtil.each(this._coordinateSystems, function (coordSys) {\n                // FIXME MUST have\n                coordSys.update && coordSys.update(ecModel, api);\n            });\n        },\n\n        getCoordinateSystems: function () {\n            return this._coordinateSystems.slice();\n        }\n    };\n\n    CoordinateSystemManager.register = function (type, coordinateSystemCreator) {\n        coordinateSystemCreators[type] = coordinateSystemCreator;\n    };\n\n    CoordinateSystemManager.get = function (type) {\n        return coordinateSystemCreators[type];\n    };\n\n    module.exports = CoordinateSystemManager;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvQ29vcmRpbmF0ZVN5c3RlbS5qcz9kMjA4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuXG4gICAgdmFyIGNvb3JkaW5hdGVTeXN0ZW1DcmVhdG9ycyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gQ29vcmRpbmF0ZVN5c3RlbU1hbmFnZXIoKSB7XG5cbiAgICAgICAgdGhpcy5fY29vcmRpbmF0ZVN5c3RlbXMgPSBbXTtcbiAgICB9XG5cbiAgICBDb29yZGluYXRlU3lzdGVtTWFuYWdlci5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IENvb3JkaW5hdGVTeXN0ZW1NYW5hZ2VyLFxuXG4gICAgICAgIGNyZWF0ZTogZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICAgICAgICAgICAgdmFyIGNvb3JkaW5hdGVTeXN0ZW1zID0gW107XG4gICAgICAgICAgICB6clV0aWwuZWFjaChjb29yZGluYXRlU3lzdGVtQ3JlYXRvcnMsIGZ1bmN0aW9uIChjcmVhdGVyLCB0eXBlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxpc3QgPSBjcmVhdGVyLmNyZWF0ZShlY01vZGVsLCBhcGkpO1xuICAgICAgICAgICAgICAgIGNvb3JkaW5hdGVTeXN0ZW1zID0gY29vcmRpbmF0ZVN5c3RlbXMuY29uY2F0KGxpc3QgfHwgW10pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRoaXMuX2Nvb3JkaW5hdGVTeXN0ZW1zID0gY29vcmRpbmF0ZVN5c3RlbXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdXBkYXRlOiBmdW5jdGlvbiAoZWNNb2RlbCwgYXBpKSB7XG4gICAgICAgICAgICB6clV0aWwuZWFjaCh0aGlzLl9jb29yZGluYXRlU3lzdGVtcywgZnVuY3Rpb24gKGNvb3JkU3lzKSB7XG4gICAgICAgICAgICAgICAgLy8gRklYTUUgTVVTVCBoYXZlXG4gICAgICAgICAgICAgICAgY29vcmRTeXMudXBkYXRlICYmIGNvb3JkU3lzLnVwZGF0ZShlY01vZGVsLCBhcGkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0Q29vcmRpbmF0ZVN5c3RlbXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb29yZGluYXRlU3lzdGVtcy5zbGljZSgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIENvb3JkaW5hdGVTeXN0ZW1NYW5hZ2VyLnJlZ2lzdGVyID0gZnVuY3Rpb24gKHR5cGUsIGNvb3JkaW5hdGVTeXN0ZW1DcmVhdG9yKSB7XG4gICAgICAgIGNvb3JkaW5hdGVTeXN0ZW1DcmVhdG9yc1t0eXBlXSA9IGNvb3JkaW5hdGVTeXN0ZW1DcmVhdG9yO1xuICAgIH07XG5cbiAgICBDb29yZGluYXRlU3lzdGVtTWFuYWdlci5nZXQgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICByZXR1cm4gY29vcmRpbmF0ZVN5c3RlbUNyZWF0b3JzW3R5cGVdO1xuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IENvb3JkaW5hdGVTeXN0ZW1NYW5hZ2VyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvQ29vcmRpbmF0ZVN5c3RlbS5qc1xuLy8gbW9kdWxlIGlkID0gMjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 27 */
/* unknown exports provided */
/* all exports used */
/*!*************************************************!*\
  !*** ./lib/chart/helper/createListFromArray.js ***!
  \*************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\n    var List = __webpack_require__(/*! ../../data/List */ 13);\n    var completeDimensions = __webpack_require__(/*! ../../data/helper/completeDimensions */ 24);\n    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 0);\n    var modelUtil = __webpack_require__(/*! ../../util/model */ 5);\n    var CoordinateSystem = __webpack_require__(/*! ../../CoordinateSystem */ 26);\n    var getDataItemValue = modelUtil.getDataItemValue;\n    var converDataValue = modelUtil.converDataValue;\n\n    function firstDataNotNull(data) {\n        var i = 0;\n        while (i < data.length && data[i] == null) {\n            i++;\n        }\n        return data[i];\n    }\n    function ifNeedCompleteOrdinalData(data) {\n        var sampleItem = firstDataNotNull(data);\n        return sampleItem != null\n            && !zrUtil.isArray(getDataItemValue(sampleItem));\n    }\n\n    /**\n     * Helper function to create a list from option data\n     */\n    function createListFromArray(data, seriesModel, ecModel) {\n        // If data is undefined\n        data = data || [];\n\n        if (true) {\n            if (!zrUtil.isArray(data)) {\n                throw new Error('Invalid data.');\n            }\n        }\n\n        var coordSysName = seriesModel.get('coordinateSystem');\n        var creator = creators[coordSysName];\n        var registeredCoordSys = CoordinateSystem.get(coordSysName);\n        // FIXME\n        var axesInfo = creator && creator(data, seriesModel, ecModel);\n        var dimensions = axesInfo && axesInfo.dimensions;\n        if (!dimensions) {\n            // Get dimensions from registered coordinate system\n            dimensions = (registeredCoordSys && (\n                registeredCoordSys.getDimensionsInfo\n                    ? registeredCoordSys.getDimensionsInfo()\n                    : registeredCoordSys.dimensions.slice()\n            )) || ['x', 'y'];\n            dimensions = completeDimensions(dimensions, data, {defaultNames: dimensions.concat(['value'])});\n        }\n\n        var categoryIndex = axesInfo ? axesInfo.categoryIndex : -1;\n\n        var list = new List(dimensions, seriesModel);\n\n        var nameList = createNameList(axesInfo, data);\n\n        var categories = {};\n        var dimValueGetter = (categoryIndex >= 0 && ifNeedCompleteOrdinalData(data))\n            ? function (itemOpt, dimName, dataIndex, dimIndex) {\n                // If any dataItem is like { value: 10 }\n                if (modelUtil.isDataItemOption(itemOpt)) {\n                    list.hasItemOption = true;\n                }\n\n                // Use dataIndex as ordinal value in categoryAxis\n                return dimIndex === categoryIndex\n                    ? dataIndex\n                    : converDataValue(getDataItemValue(itemOpt), dimensions[dimIndex]);\n            }\n            : function (itemOpt, dimName, dataIndex, dimIndex) {\n                var value = getDataItemValue(itemOpt);\n                var val = converDataValue(value && value[dimIndex], dimensions[dimIndex]);\n                // If any dataItem is like { value: 10 }\n                if (modelUtil.isDataItemOption(itemOpt)) {\n                    list.hasItemOption = true;\n                }\n\n                var categoryAxesModels = axesInfo && axesInfo.categoryAxesModels;\n                if (categoryAxesModels && categoryAxesModels[dimName]) {\n                    // If given value is a category string\n                    if (typeof val === 'string') {\n                        // Lazy get categories\n                        categories[dimName] = categories[dimName]\n                            || categoryAxesModels[dimName].getCategories();\n                        val = zrUtil.indexOf(categories[dimName], val);\n                        if (val < 0 && !isNaN(val)) {\n                            // In case some one write '1', '2' istead of 1, 2\n                            val = +val;\n                        }\n                    }\n                }\n                return val;\n            };\n\n        list.hasItemOption = false;\n        list.initData(data, nameList, dimValueGetter);\n\n        return list;\n    }\n\n    function isStackable(axisType) {\n        return axisType !== 'category' && axisType !== 'time';\n    }\n\n    function getDimTypeByAxis(axisType) {\n        return axisType === 'category'\n            ? 'ordinal'\n            : axisType === 'time'\n            ? 'time'\n            : 'float';\n    }\n\n    /**\n     * Creaters for each coord system.\n     */\n    var creators = {\n\n        cartesian2d: function (data, seriesModel, ecModel) {\n\n            var axesModels = zrUtil.map(['xAxis', 'yAxis'], function (name) {\n                return ecModel.queryComponents({\n                    mainType: name,\n                    index: seriesModel.get(name + 'Index'),\n                    id: seriesModel.get(name + 'Id')\n                })[0];\n            });\n            var xAxisModel = axesModels[0];\n            var yAxisModel = axesModels[1];\n\n            if (true) {\n                if (!xAxisModel) {\n                    throw new Error('xAxis \"' + zrUtil.retrieve(\n                        seriesModel.get('xAxisIndex'),\n                        seriesModel.get('xAxisId'),\n                        0\n                    ) + '\" not found');\n                }\n                if (!yAxisModel) {\n                    throw new Error('yAxis \"' + zrUtil.retrieve(\n                        seriesModel.get('xAxisIndex'),\n                        seriesModel.get('yAxisId'),\n                        0\n                    ) + '\" not found');\n                }\n            }\n\n            var xAxisType = xAxisModel.get('type');\n            var yAxisType = yAxisModel.get('type');\n\n            var dimensions = [\n                {\n                    name: 'x',\n                    type: getDimTypeByAxis(xAxisType),\n                    stackable: isStackable(xAxisType)\n                },\n                {\n                    name: 'y',\n                    // If two category axes\n                    type: getDimTypeByAxis(yAxisType),\n                    stackable: isStackable(yAxisType)\n                }\n            ];\n\n            var isXAxisCateogry = xAxisType === 'category';\n            var isYAxisCategory = yAxisType === 'category';\n\n            completeDimensions(dimensions, data, {defaultNames: ['x', 'y', 'z']});\n\n            var categoryAxesModels = {};\n            if (isXAxisCateogry) {\n                categoryAxesModels.x = xAxisModel;\n            }\n            if (isYAxisCategory) {\n                categoryAxesModels.y = yAxisModel;\n            }\n            return {\n                dimensions: dimensions,\n                categoryIndex: isXAxisCateogry ? 0 : (isYAxisCategory ? 1 : -1),\n                categoryAxesModels: categoryAxesModels\n            };\n        },\n\n        singleAxis: function (data, seriesModel, ecModel) {\n\n            var singleAxisModel = ecModel.queryComponents({\n                mainType: 'singleAxis',\n                index: seriesModel.get('singleAxisIndex'),\n                id: seriesModel.get('singleAxisId')\n            })[0];\n\n            if (true) {\n                if (!singleAxisModel) {\n                    throw new Error('singleAxis should be specified.');\n                }\n            }\n\n            var singleAxisType = singleAxisModel.get('type');\n            var isCategory = singleAxisType === 'category';\n\n            var dimensions = [{\n                name: 'single',\n                type: getDimTypeByAxis(singleAxisType),\n                stackable: isStackable(singleAxisType)\n            }];\n\n            completeDimensions(dimensions, data);\n\n            var categoryAxesModels = {};\n            if (isCategory) {\n                categoryAxesModels.single = singleAxisModel;\n            }\n\n            return {\n                dimensions: dimensions,\n                categoryIndex: isCategory ? 0 : -1,\n                categoryAxesModels: categoryAxesModels\n            };\n        },\n\n        polar: function (data, seriesModel, ecModel) {\n            var polarModel = ecModel.queryComponents({\n                mainType: 'polar',\n                index: seriesModel.get('polarIndex'),\n                id: seriesModel.get('polarId')\n            })[0];\n\n            var angleAxisModel = polarModel.findAxisModel('angleAxis');\n            var radiusAxisModel = polarModel.findAxisModel('radiusAxis');\n\n            if (true) {\n                if (!angleAxisModel) {\n                    throw new Error('angleAxis option not found');\n                }\n                if (!radiusAxisModel) {\n                    throw new Error('radiusAxis option not found');\n                }\n            }\n\n            var radiusAxisType = radiusAxisModel.get('type');\n            var angleAxisType = angleAxisModel.get('type');\n\n            var dimensions = [\n                {\n                    name: 'radius',\n                    type: getDimTypeByAxis(radiusAxisType),\n                    stackable: isStackable(radiusAxisType)\n                },\n                {\n                    name: 'angle',\n                    type: getDimTypeByAxis(angleAxisType),\n                    stackable: isStackable(angleAxisType)\n                }\n            ];\n            var isAngleAxisCateogry = angleAxisType === 'category';\n            var isRadiusAxisCateogry = radiusAxisType === 'category';\n\n            completeDimensions(dimensions, data, {defaultNames: ['radius', 'angle', 'value']});\n\n            var categoryAxesModels = {};\n            if (isRadiusAxisCateogry) {\n                categoryAxesModels.radius = radiusAxisModel;\n            }\n            if (isAngleAxisCateogry) {\n                categoryAxesModels.angle = angleAxisModel;\n            }\n            return {\n                dimensions: dimensions,\n                categoryIndex: isAngleAxisCateogry ? 1 : (isRadiusAxisCateogry ? 0 : -1),\n                categoryAxesModels: categoryAxesModels\n            };\n        },\n\n        geo: function (data, seriesModel, ecModel) {\n            // TODO Region\n            // 多个散点图系列在同一个地区的时候\n            return {\n                dimensions: completeDimensions([\n                    {name: 'lng'},\n                    {name: 'lat'}\n                ], data, {defaultNames: ['lng', 'lat', 'value']})\n            };\n        }\n    };\n\n    function createNameList(result, data) {\n        var nameList = [];\n\n        var categoryDim = result && result.dimensions[result.categoryIndex];\n        var categoryAxisModel;\n        if (categoryDim) {\n            categoryAxisModel = result.categoryAxesModels[categoryDim.name];\n        }\n\n        if (categoryAxisModel) {\n            // FIXME Two category axis\n            var categories = categoryAxisModel.getCategories();\n            if (categories) {\n                var dataLen = data.length;\n                // Ordered data is given explicitly like\n                // [[3, 0.2], [1, 0.3], [2, 0.15]]\n                // or given scatter data,\n                // pick the category\n                if (zrUtil.isArray(data[0]) && data[0].length > 1) {\n                    nameList = [];\n                    for (var i = 0; i < dataLen; i++) {\n                        nameList[i] = categories[data[i][result.categoryIndex || 0]];\n                    }\n                }\n                else {\n                    nameList = categories.slice(0);\n                }\n            }\n        }\n\n        return nameList;\n    }\n\n    module.exports = createListFromArray;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvY2hhcnQvaGVscGVyL2NyZWF0ZUxpc3RGcm9tQXJyYXkuanM/YTJiMyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciBMaXN0ID0gcmVxdWlyZSgnLi4vLi4vZGF0YS9MaXN0Jyk7XG4gICAgdmFyIGNvbXBsZXRlRGltZW5zaW9ucyA9IHJlcXVpcmUoJy4uLy4uL2RhdGEvaGVscGVyL2NvbXBsZXRlRGltZW5zaW9ucycpO1xuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgbW9kZWxVdGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9tb2RlbCcpO1xuICAgIHZhciBDb29yZGluYXRlU3lzdGVtID0gcmVxdWlyZSgnLi4vLi4vQ29vcmRpbmF0ZVN5c3RlbScpO1xuICAgIHZhciBnZXREYXRhSXRlbVZhbHVlID0gbW9kZWxVdGlsLmdldERhdGFJdGVtVmFsdWU7XG4gICAgdmFyIGNvbnZlckRhdGFWYWx1ZSA9IG1vZGVsVXRpbC5jb252ZXJEYXRhVmFsdWU7XG5cbiAgICBmdW5jdGlvbiBmaXJzdERhdGFOb3ROdWxsKGRhdGEpIHtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB3aGlsZSAoaSA8IGRhdGEubGVuZ3RoICYmIGRhdGFbaV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhW2ldO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpZk5lZWRDb21wbGV0ZU9yZGluYWxEYXRhKGRhdGEpIHtcbiAgICAgICAgdmFyIHNhbXBsZUl0ZW0gPSBmaXJzdERhdGFOb3ROdWxsKGRhdGEpO1xuICAgICAgICByZXR1cm4gc2FtcGxlSXRlbSAhPSBudWxsXG4gICAgICAgICAgICAmJiAhenJVdGlsLmlzQXJyYXkoZ2V0RGF0YUl0ZW1WYWx1ZShzYW1wbGVJdGVtKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGVscGVyIGZ1bmN0aW9uIHRvIGNyZWF0ZSBhIGxpc3QgZnJvbSBvcHRpb24gZGF0YVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUxpc3RGcm9tQXJyYXkoZGF0YSwgc2VyaWVzTW9kZWwsIGVjTW9kZWwpIHtcbiAgICAgICAgLy8gSWYgZGF0YSBpcyB1bmRlZmluZWRcbiAgICAgICAgZGF0YSA9IGRhdGEgfHwgW107XG5cbiAgICAgICAgaWYgKF9fREVWX18pIHtcbiAgICAgICAgICAgIGlmICghenJVdGlsLmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZGF0YS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb29yZFN5c05hbWUgPSBzZXJpZXNNb2RlbC5nZXQoJ2Nvb3JkaW5hdGVTeXN0ZW0nKTtcbiAgICAgICAgdmFyIGNyZWF0b3IgPSBjcmVhdG9yc1tjb29yZFN5c05hbWVdO1xuICAgICAgICB2YXIgcmVnaXN0ZXJlZENvb3JkU3lzID0gQ29vcmRpbmF0ZVN5c3RlbS5nZXQoY29vcmRTeXNOYW1lKTtcbiAgICAgICAgLy8gRklYTUVcbiAgICAgICAgdmFyIGF4ZXNJbmZvID0gY3JlYXRvciAmJiBjcmVhdG9yKGRhdGEsIHNlcmllc01vZGVsLCBlY01vZGVsKTtcbiAgICAgICAgdmFyIGRpbWVuc2lvbnMgPSBheGVzSW5mbyAmJiBheGVzSW5mby5kaW1lbnNpb25zO1xuICAgICAgICBpZiAoIWRpbWVuc2lvbnMpIHtcbiAgICAgICAgICAgIC8vIEdldCBkaW1lbnNpb25zIGZyb20gcmVnaXN0ZXJlZCBjb29yZGluYXRlIHN5c3RlbVxuICAgICAgICAgICAgZGltZW5zaW9ucyA9IChyZWdpc3RlcmVkQ29vcmRTeXMgJiYgKFxuICAgICAgICAgICAgICAgIHJlZ2lzdGVyZWRDb29yZFN5cy5nZXREaW1lbnNpb25zSW5mb1xuICAgICAgICAgICAgICAgICAgICA/IHJlZ2lzdGVyZWRDb29yZFN5cy5nZXREaW1lbnNpb25zSW5mbygpXG4gICAgICAgICAgICAgICAgICAgIDogcmVnaXN0ZXJlZENvb3JkU3lzLmRpbWVuc2lvbnMuc2xpY2UoKVxuICAgICAgICAgICAgKSkgfHwgWyd4JywgJ3knXTtcbiAgICAgICAgICAgIGRpbWVuc2lvbnMgPSBjb21wbGV0ZURpbWVuc2lvbnMoZGltZW5zaW9ucywgZGF0YSwge2RlZmF1bHROYW1lczogZGltZW5zaW9ucy5jb25jYXQoWyd2YWx1ZSddKX0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNhdGVnb3J5SW5kZXggPSBheGVzSW5mbyA/IGF4ZXNJbmZvLmNhdGVnb3J5SW5kZXggOiAtMTtcblxuICAgICAgICB2YXIgbGlzdCA9IG5ldyBMaXN0KGRpbWVuc2lvbnMsIHNlcmllc01vZGVsKTtcblxuICAgICAgICB2YXIgbmFtZUxpc3QgPSBjcmVhdGVOYW1lTGlzdChheGVzSW5mbywgZGF0YSk7XG5cbiAgICAgICAgdmFyIGNhdGVnb3JpZXMgPSB7fTtcbiAgICAgICAgdmFyIGRpbVZhbHVlR2V0dGVyID0gKGNhdGVnb3J5SW5kZXggPj0gMCAmJiBpZk5lZWRDb21wbGV0ZU9yZGluYWxEYXRhKGRhdGEpKVxuICAgICAgICAgICAgPyBmdW5jdGlvbiAoaXRlbU9wdCwgZGltTmFtZSwgZGF0YUluZGV4LCBkaW1JbmRleCkge1xuICAgICAgICAgICAgICAgIC8vIElmIGFueSBkYXRhSXRlbSBpcyBsaWtlIHsgdmFsdWU6IDEwIH1cbiAgICAgICAgICAgICAgICBpZiAobW9kZWxVdGlsLmlzRGF0YUl0ZW1PcHRpb24oaXRlbU9wdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdC5oYXNJdGVtT3B0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBVc2UgZGF0YUluZGV4IGFzIG9yZGluYWwgdmFsdWUgaW4gY2F0ZWdvcnlBeGlzXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpbUluZGV4ID09PSBjYXRlZ29yeUluZGV4XG4gICAgICAgICAgICAgICAgICAgID8gZGF0YUluZGV4XG4gICAgICAgICAgICAgICAgICAgIDogY29udmVyRGF0YVZhbHVlKGdldERhdGFJdGVtVmFsdWUoaXRlbU9wdCksIGRpbWVuc2lvbnNbZGltSW5kZXhdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDogZnVuY3Rpb24gKGl0ZW1PcHQsIGRpbU5hbWUsIGRhdGFJbmRleCwgZGltSW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBnZXREYXRhSXRlbVZhbHVlKGl0ZW1PcHQpO1xuICAgICAgICAgICAgICAgIHZhciB2YWwgPSBjb252ZXJEYXRhVmFsdWUodmFsdWUgJiYgdmFsdWVbZGltSW5kZXhdLCBkaW1lbnNpb25zW2RpbUluZGV4XSk7XG4gICAgICAgICAgICAgICAgLy8gSWYgYW55IGRhdGFJdGVtIGlzIGxpa2UgeyB2YWx1ZTogMTAgfVxuICAgICAgICAgICAgICAgIGlmIChtb2RlbFV0aWwuaXNEYXRhSXRlbU9wdGlvbihpdGVtT3B0KSkge1xuICAgICAgICAgICAgICAgICAgICBsaXN0Lmhhc0l0ZW1PcHRpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBjYXRlZ29yeUF4ZXNNb2RlbHMgPSBheGVzSW5mbyAmJiBheGVzSW5mby5jYXRlZ29yeUF4ZXNNb2RlbHM7XG4gICAgICAgICAgICAgICAgaWYgKGNhdGVnb3J5QXhlc01vZGVscyAmJiBjYXRlZ29yeUF4ZXNNb2RlbHNbZGltTmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgZ2l2ZW4gdmFsdWUgaXMgYSBjYXRlZ29yeSBzdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBMYXp5IGdldCBjYXRlZ29yaWVzXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRlZ29yaWVzW2RpbU5hbWVdID0gY2F0ZWdvcmllc1tkaW1OYW1lXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IGNhdGVnb3J5QXhlc01vZGVsc1tkaW1OYW1lXS5nZXRDYXRlZ29yaWVzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSB6clV0aWwuaW5kZXhPZihjYXRlZ29yaWVzW2RpbU5hbWVdLCB2YWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbCA8IDAgJiYgIWlzTmFOKHZhbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJbiBjYXNlIHNvbWUgb25lIHdyaXRlICcxJywgJzInIGlzdGVhZCBvZiAxLCAyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gK3ZhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICBsaXN0Lmhhc0l0ZW1PcHRpb24gPSBmYWxzZTtcbiAgICAgICAgbGlzdC5pbml0RGF0YShkYXRhLCBuYW1lTGlzdCwgZGltVmFsdWVHZXR0ZXIpO1xuXG4gICAgICAgIHJldHVybiBsaXN0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzU3RhY2thYmxlKGF4aXNUeXBlKSB7XG4gICAgICAgIHJldHVybiBheGlzVHlwZSAhPT0gJ2NhdGVnb3J5JyAmJiBheGlzVHlwZSAhPT0gJ3RpbWUnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldERpbVR5cGVCeUF4aXMoYXhpc1R5cGUpIHtcbiAgICAgICAgcmV0dXJuIGF4aXNUeXBlID09PSAnY2F0ZWdvcnknXG4gICAgICAgICAgICA/ICdvcmRpbmFsJ1xuICAgICAgICAgICAgOiBheGlzVHlwZSA9PT0gJ3RpbWUnXG4gICAgICAgICAgICA/ICd0aW1lJ1xuICAgICAgICAgICAgOiAnZmxvYXQnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXJzIGZvciBlYWNoIGNvb3JkIHN5c3RlbS5cbiAgICAgKi9cbiAgICB2YXIgY3JlYXRvcnMgPSB7XG5cbiAgICAgICAgY2FydGVzaWFuMmQ6IGZ1bmN0aW9uIChkYXRhLCBzZXJpZXNNb2RlbCwgZWNNb2RlbCkge1xuXG4gICAgICAgICAgICB2YXIgYXhlc01vZGVscyA9IHpyVXRpbC5tYXAoWyd4QXhpcycsICd5QXhpcyddLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlY01vZGVsLnF1ZXJ5Q29tcG9uZW50cyh7XG4gICAgICAgICAgICAgICAgICAgIG1haW5UeXBlOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICBpbmRleDogc2VyaWVzTW9kZWwuZ2V0KG5hbWUgKyAnSW5kZXgnKSxcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHNlcmllc01vZGVsLmdldChuYW1lICsgJ0lkJylcbiAgICAgICAgICAgICAgICB9KVswXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIHhBeGlzTW9kZWwgPSBheGVzTW9kZWxzWzBdO1xuICAgICAgICAgICAgdmFyIHlBeGlzTW9kZWwgPSBheGVzTW9kZWxzWzFdO1xuXG4gICAgICAgICAgICBpZiAoX19ERVZfXykge1xuICAgICAgICAgICAgICAgIGlmICgheEF4aXNNb2RlbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3hBeGlzIFwiJyArIHpyVXRpbC5yZXRyaWV2ZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllc01vZGVsLmdldCgneEF4aXNJbmRleCcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzTW9kZWwuZ2V0KCd4QXhpc0lkJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAwXG4gICAgICAgICAgICAgICAgICAgICkgKyAnXCIgbm90IGZvdW5kJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgheUF4aXNNb2RlbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3lBeGlzIFwiJyArIHpyVXRpbC5yZXRyaWV2ZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllc01vZGVsLmdldCgneEF4aXNJbmRleCcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzTW9kZWwuZ2V0KCd5QXhpc0lkJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAwXG4gICAgICAgICAgICAgICAgICAgICkgKyAnXCIgbm90IGZvdW5kJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgeEF4aXNUeXBlID0geEF4aXNNb2RlbC5nZXQoJ3R5cGUnKTtcbiAgICAgICAgICAgIHZhciB5QXhpc1R5cGUgPSB5QXhpc01vZGVsLmdldCgndHlwZScpO1xuXG4gICAgICAgICAgICB2YXIgZGltZW5zaW9ucyA9IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICd4JyxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogZ2V0RGltVHlwZUJ5QXhpcyh4QXhpc1R5cGUpLFxuICAgICAgICAgICAgICAgICAgICBzdGFja2FibGU6IGlzU3RhY2thYmxlKHhBeGlzVHlwZSlcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3knLFxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0d28gY2F0ZWdvcnkgYXhlc1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBnZXREaW1UeXBlQnlBeGlzKHlBeGlzVHlwZSksXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrYWJsZTogaXNTdGFja2FibGUoeUF4aXNUeXBlKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgIHZhciBpc1hBeGlzQ2F0ZW9ncnkgPSB4QXhpc1R5cGUgPT09ICdjYXRlZ29yeSc7XG4gICAgICAgICAgICB2YXIgaXNZQXhpc0NhdGVnb3J5ID0geUF4aXNUeXBlID09PSAnY2F0ZWdvcnknO1xuXG4gICAgICAgICAgICBjb21wbGV0ZURpbWVuc2lvbnMoZGltZW5zaW9ucywgZGF0YSwge2RlZmF1bHROYW1lczogWyd4JywgJ3knLCAneiddfSk7XG5cbiAgICAgICAgICAgIHZhciBjYXRlZ29yeUF4ZXNNb2RlbHMgPSB7fTtcbiAgICAgICAgICAgIGlmIChpc1hBeGlzQ2F0ZW9ncnkpIHtcbiAgICAgICAgICAgICAgICBjYXRlZ29yeUF4ZXNNb2RlbHMueCA9IHhBeGlzTW9kZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNZQXhpc0NhdGVnb3J5KSB7XG4gICAgICAgICAgICAgICAgY2F0ZWdvcnlBeGVzTW9kZWxzLnkgPSB5QXhpc01vZGVsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25zOiBkaW1lbnNpb25zLFxuICAgICAgICAgICAgICAgIGNhdGVnb3J5SW5kZXg6IGlzWEF4aXNDYXRlb2dyeSA/IDAgOiAoaXNZQXhpc0NhdGVnb3J5ID8gMSA6IC0xKSxcbiAgICAgICAgICAgICAgICBjYXRlZ29yeUF4ZXNNb2RlbHM6IGNhdGVnb3J5QXhlc01vZGVsc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICBzaW5nbGVBeGlzOiBmdW5jdGlvbiAoZGF0YSwgc2VyaWVzTW9kZWwsIGVjTW9kZWwpIHtcblxuICAgICAgICAgICAgdmFyIHNpbmdsZUF4aXNNb2RlbCA9IGVjTW9kZWwucXVlcnlDb21wb25lbnRzKHtcbiAgICAgICAgICAgICAgICBtYWluVHlwZTogJ3NpbmdsZUF4aXMnLFxuICAgICAgICAgICAgICAgIGluZGV4OiBzZXJpZXNNb2RlbC5nZXQoJ3NpbmdsZUF4aXNJbmRleCcpLFxuICAgICAgICAgICAgICAgIGlkOiBzZXJpZXNNb2RlbC5nZXQoJ3NpbmdsZUF4aXNJZCcpXG4gICAgICAgICAgICB9KVswXTtcblxuICAgICAgICAgICAgaWYgKF9fREVWX18pIHtcbiAgICAgICAgICAgICAgICBpZiAoIXNpbmdsZUF4aXNNb2RlbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NpbmdsZUF4aXMgc2hvdWxkIGJlIHNwZWNpZmllZC4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzaW5nbGVBeGlzVHlwZSA9IHNpbmdsZUF4aXNNb2RlbC5nZXQoJ3R5cGUnKTtcbiAgICAgICAgICAgIHZhciBpc0NhdGVnb3J5ID0gc2luZ2xlQXhpc1R5cGUgPT09ICdjYXRlZ29yeSc7XG5cbiAgICAgICAgICAgIHZhciBkaW1lbnNpb25zID0gW3tcbiAgICAgICAgICAgICAgICBuYW1lOiAnc2luZ2xlJyxcbiAgICAgICAgICAgICAgICB0eXBlOiBnZXREaW1UeXBlQnlBeGlzKHNpbmdsZUF4aXNUeXBlKSxcbiAgICAgICAgICAgICAgICBzdGFja2FibGU6IGlzU3RhY2thYmxlKHNpbmdsZUF4aXNUeXBlKVxuICAgICAgICAgICAgfV07XG5cbiAgICAgICAgICAgIGNvbXBsZXRlRGltZW5zaW9ucyhkaW1lbnNpb25zLCBkYXRhKTtcblxuICAgICAgICAgICAgdmFyIGNhdGVnb3J5QXhlc01vZGVscyA9IHt9O1xuICAgICAgICAgICAgaWYgKGlzQ2F0ZWdvcnkpIHtcbiAgICAgICAgICAgICAgICBjYXRlZ29yeUF4ZXNNb2RlbHMuc2luZ2xlID0gc2luZ2xlQXhpc01vZGVsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRpbWVuc2lvbnM6IGRpbWVuc2lvbnMsXG4gICAgICAgICAgICAgICAgY2F0ZWdvcnlJbmRleDogaXNDYXRlZ29yeSA/IDAgOiAtMSxcbiAgICAgICAgICAgICAgICBjYXRlZ29yeUF4ZXNNb2RlbHM6IGNhdGVnb3J5QXhlc01vZGVsc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICBwb2xhcjogZnVuY3Rpb24gKGRhdGEsIHNlcmllc01vZGVsLCBlY01vZGVsKSB7XG4gICAgICAgICAgICB2YXIgcG9sYXJNb2RlbCA9IGVjTW9kZWwucXVlcnlDb21wb25lbnRzKHtcbiAgICAgICAgICAgICAgICBtYWluVHlwZTogJ3BvbGFyJyxcbiAgICAgICAgICAgICAgICBpbmRleDogc2VyaWVzTW9kZWwuZ2V0KCdwb2xhckluZGV4JyksXG4gICAgICAgICAgICAgICAgaWQ6IHNlcmllc01vZGVsLmdldCgncG9sYXJJZCcpXG4gICAgICAgICAgICB9KVswXTtcblxuICAgICAgICAgICAgdmFyIGFuZ2xlQXhpc01vZGVsID0gcG9sYXJNb2RlbC5maW5kQXhpc01vZGVsKCdhbmdsZUF4aXMnKTtcbiAgICAgICAgICAgIHZhciByYWRpdXNBeGlzTW9kZWwgPSBwb2xhck1vZGVsLmZpbmRBeGlzTW9kZWwoJ3JhZGl1c0F4aXMnKTtcblxuICAgICAgICAgICAgaWYgKF9fREVWX18pIHtcbiAgICAgICAgICAgICAgICBpZiAoIWFuZ2xlQXhpc01vZGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYW5nbGVBeGlzIG9wdGlvbiBub3QgZm91bmQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFyYWRpdXNBeGlzTW9kZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyYWRpdXNBeGlzIG9wdGlvbiBub3QgZm91bmQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciByYWRpdXNBeGlzVHlwZSA9IHJhZGl1c0F4aXNNb2RlbC5nZXQoJ3R5cGUnKTtcbiAgICAgICAgICAgIHZhciBhbmdsZUF4aXNUeXBlID0gYW5nbGVBeGlzTW9kZWwuZ2V0KCd0eXBlJyk7XG5cbiAgICAgICAgICAgIHZhciBkaW1lbnNpb25zID0gW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3JhZGl1cycsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IGdldERpbVR5cGVCeUF4aXMocmFkaXVzQXhpc1R5cGUpLFxuICAgICAgICAgICAgICAgICAgICBzdGFja2FibGU6IGlzU3RhY2thYmxlKHJhZGl1c0F4aXNUeXBlKVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnYW5nbGUnLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBnZXREaW1UeXBlQnlBeGlzKGFuZ2xlQXhpc1R5cGUpLFxuICAgICAgICAgICAgICAgICAgICBzdGFja2FibGU6IGlzU3RhY2thYmxlKGFuZ2xlQXhpc1R5cGUpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIHZhciBpc0FuZ2xlQXhpc0NhdGVvZ3J5ID0gYW5nbGVBeGlzVHlwZSA9PT0gJ2NhdGVnb3J5JztcbiAgICAgICAgICAgIHZhciBpc1JhZGl1c0F4aXNDYXRlb2dyeSA9IHJhZGl1c0F4aXNUeXBlID09PSAnY2F0ZWdvcnknO1xuXG4gICAgICAgICAgICBjb21wbGV0ZURpbWVuc2lvbnMoZGltZW5zaW9ucywgZGF0YSwge2RlZmF1bHROYW1lczogWydyYWRpdXMnLCAnYW5nbGUnLCAndmFsdWUnXX0pO1xuXG4gICAgICAgICAgICB2YXIgY2F0ZWdvcnlBeGVzTW9kZWxzID0ge307XG4gICAgICAgICAgICBpZiAoaXNSYWRpdXNBeGlzQ2F0ZW9ncnkpIHtcbiAgICAgICAgICAgICAgICBjYXRlZ29yeUF4ZXNNb2RlbHMucmFkaXVzID0gcmFkaXVzQXhpc01vZGVsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzQW5nbGVBeGlzQ2F0ZW9ncnkpIHtcbiAgICAgICAgICAgICAgICBjYXRlZ29yeUF4ZXNNb2RlbHMuYW5nbGUgPSBhbmdsZUF4aXNNb2RlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGltZW5zaW9uczogZGltZW5zaW9ucyxcbiAgICAgICAgICAgICAgICBjYXRlZ29yeUluZGV4OiBpc0FuZ2xlQXhpc0NhdGVvZ3J5ID8gMSA6IChpc1JhZGl1c0F4aXNDYXRlb2dyeSA/IDAgOiAtMSksXG4gICAgICAgICAgICAgICAgY2F0ZWdvcnlBeGVzTW9kZWxzOiBjYXRlZ29yeUF4ZXNNb2RlbHNcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2VvOiBmdW5jdGlvbiAoZGF0YSwgc2VyaWVzTW9kZWwsIGVjTW9kZWwpIHtcbiAgICAgICAgICAgIC8vIFRPRE8gUmVnaW9uXG4gICAgICAgICAgICAvLyDlpJrkuKrmlaPngrnlm77ns7vliJflnKjlkIzkuIDkuKrlnLDljLrnmoTml7blgJlcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGltZW5zaW9uczogY29tcGxldGVEaW1lbnNpb25zKFtcbiAgICAgICAgICAgICAgICAgICAge25hbWU6ICdsbmcnfSxcbiAgICAgICAgICAgICAgICAgICAge25hbWU6ICdsYXQnfVxuICAgICAgICAgICAgICAgIF0sIGRhdGEsIHtkZWZhdWx0TmFtZXM6IFsnbG5nJywgJ2xhdCcsICd2YWx1ZSddfSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlTmFtZUxpc3QocmVzdWx0LCBkYXRhKSB7XG4gICAgICAgIHZhciBuYW1lTGlzdCA9IFtdO1xuXG4gICAgICAgIHZhciBjYXRlZ29yeURpbSA9IHJlc3VsdCAmJiByZXN1bHQuZGltZW5zaW9uc1tyZXN1bHQuY2F0ZWdvcnlJbmRleF07XG4gICAgICAgIHZhciBjYXRlZ29yeUF4aXNNb2RlbDtcbiAgICAgICAgaWYgKGNhdGVnb3J5RGltKSB7XG4gICAgICAgICAgICBjYXRlZ29yeUF4aXNNb2RlbCA9IHJlc3VsdC5jYXRlZ29yeUF4ZXNNb2RlbHNbY2F0ZWdvcnlEaW0ubmFtZV07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2F0ZWdvcnlBeGlzTW9kZWwpIHtcbiAgICAgICAgICAgIC8vIEZJWE1FIFR3byBjYXRlZ29yeSBheGlzXG4gICAgICAgICAgICB2YXIgY2F0ZWdvcmllcyA9IGNhdGVnb3J5QXhpc01vZGVsLmdldENhdGVnb3JpZXMoKTtcbiAgICAgICAgICAgIGlmIChjYXRlZ29yaWVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGFMZW4gPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAvLyBPcmRlcmVkIGRhdGEgaXMgZ2l2ZW4gZXhwbGljaXRseSBsaWtlXG4gICAgICAgICAgICAgICAgLy8gW1szLCAwLjJdLCBbMSwgMC4zXSwgWzIsIDAuMTVdXVxuICAgICAgICAgICAgICAgIC8vIG9yIGdpdmVuIHNjYXR0ZXIgZGF0YSxcbiAgICAgICAgICAgICAgICAvLyBwaWNrIHRoZSBjYXRlZ29yeVxuICAgICAgICAgICAgICAgIGlmICh6clV0aWwuaXNBcnJheShkYXRhWzBdKSAmJiBkYXRhWzBdLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZUxpc3QgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhTGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVMaXN0W2ldID0gY2F0ZWdvcmllc1tkYXRhW2ldW3Jlc3VsdC5jYXRlZ29yeUluZGV4IHx8IDBdXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZUxpc3QgPSBjYXRlZ29yaWVzLnNsaWNlKDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuYW1lTGlzdDtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUxpc3RGcm9tQXJyYXk7XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2NoYXJ0L2hlbHBlci9jcmVhdGVMaXN0RnJvbUFycmF5LmpzXG4vLyBtb2R1bGUgaWQgPSAyN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 28 */
/* unknown exports provided */
/* all exports used */
/*!*************************************************!*\
  !*** ./lib/component/toolbox/featureManager.js ***!
  \*************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\n    var features = {};\n\n    module.exports = {\n        register: function (name, ctor) {\n            features[name] = ctor;\n        },\n\n        get: function (name) {\n            return features[name];\n        }\n    };\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvY29tcG9uZW50L3Rvb2xib3gvZmVhdHVyZU1hbmFnZXIuanM/NDM0YSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciBmZWF0dXJlcyA9IHt9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIHJlZ2lzdGVyOiBmdW5jdGlvbiAobmFtZSwgY3Rvcikge1xuICAgICAgICAgICAgZmVhdHVyZXNbbmFtZV0gPSBjdG9yO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldDogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBmZWF0dXJlc1tuYW1lXTtcbiAgICAgICAgfVxuICAgIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9jb21wb25lbnQvdG9vbGJveC9mZWF0dXJlTWFuYWdlci5qc1xuLy8gbW9kdWxlIGlkID0gMjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 29 */
/* unknown exports provided */
/* all exports used */
/*!***************************!*\
  !*** ./lib/view/Chart.js ***!
  \***************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var Group = __webpack_require__(/*! zrender/lib/container/Group */ 33);\n    var componentUtil = __webpack_require__(/*! ../util/component */ 49);\n    var clazzUtil = __webpack_require__(/*! ../util/clazz */ 14);\n    var modelUtil = __webpack_require__(/*! ../util/model */ 5);\n    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 0);\n\n    function Chart() {\n\n        /**\n         * @type {module:zrender/container/Group}\n         * @readOnly\n         */\n        this.group = new Group();\n\n        /**\n         * @type {string}\n         * @readOnly\n         */\n        this.uid = componentUtil.getUID('viewChart');\n    }\n\n    Chart.prototype = {\n\n        type: 'chart',\n\n        /**\n         * Init the chart\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         */\n        init: function (ecModel, api) {},\n\n        /**\n         * Render the chart\n         * @param  {module:echarts/model/Series} seriesModel\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         * @param  {Object} payload\n         */\n        render: function (seriesModel, ecModel, api, payload) {},\n\n        /**\n         * Highlight series or specified data item\n         * @param  {module:echarts/model/Series} seriesModel\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         * @param  {Object} payload\n         */\n        highlight: function (seriesModel, ecModel, api, payload) {\n            toggleHighlight(seriesModel.getData(), payload, 'emphasis');\n        },\n\n        /**\n         * Downplay series or specified data item\n         * @param  {module:echarts/model/Series} seriesModel\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         * @param  {Object} payload\n         */\n        downplay: function (seriesModel, ecModel, api, payload) {\n            toggleHighlight(seriesModel.getData(), payload, 'normal');\n        },\n\n        /**\n         * Remove self\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         */\n        remove: function (ecModel, api) {\n            this.group.removeAll();\n        },\n\n        /**\n         * Dispose self\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         */\n        dispose: function () {}\n\n        /**\n         * The view contains the given point.\n         * @interface\n         * @param {Array.<number>} point\n         * @return {boolean}\n         */\n        // containPoint: function () {}\n\n    };\n\n    var chartProto = Chart.prototype;\n    chartProto.updateView\n        = chartProto.updateLayout\n        = chartProto.updateVisual\n        = function (seriesModel, ecModel, api, payload) {\n            this.render(seriesModel, ecModel, api, payload);\n        };\n\n    /**\n     * Set state of single element\n     * @param  {module:zrender/Element} el\n     * @param  {string} state\n     */\n    function elSetState(el, state) {\n        if (el) {\n            el.trigger(state);\n            if (el.type === 'group') {\n                for (var i = 0; i < el.childCount(); i++) {\n                    elSetState(el.childAt(i), state);\n                }\n            }\n        }\n    }\n    /**\n     * @param  {module:echarts/data/List} data\n     * @param  {Object} payload\n     * @param  {string} state 'normal'|'emphasis'\n     * @inner\n     */\n    function toggleHighlight(data, payload, state) {\n        var dataIndex = modelUtil.queryDataIndex(data, payload);\n\n        if (dataIndex != null) {\n            zrUtil.each(modelUtil.normalizeToArray(dataIndex), function (dataIdx) {\n                elSetState(data.getItemGraphicEl(dataIdx), state);\n            });\n        }\n        else {\n            data.eachItemGraphicEl(function (el) {\n                elSetState(el, state);\n            });\n        }\n    }\n\n    // Enable Chart.extend.\n    clazzUtil.enableClassExtend(Chart, ['dispose']);\n\n    // Add capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n    clazzUtil.enableClassManagement(Chart, {registerWhenExtend: true});\n\n    module.exports = Chart;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvdmlldy9DaGFydC5qcz84MWFkIl0sInNvdXJjZXNDb250ZW50IjpbIlxuXG4gICAgdmFyIEdyb3VwID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29udGFpbmVyL0dyb3VwJyk7XG4gICAgdmFyIGNvbXBvbmVudFV0aWwgPSByZXF1aXJlKCcuLi91dGlsL2NvbXBvbmVudCcpO1xuICAgIHZhciBjbGF6elV0aWwgPSByZXF1aXJlKCcuLi91dGlsL2NsYXp6Jyk7XG4gICAgdmFyIG1vZGVsVXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvbW9kZWwnKTtcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG5cbiAgICBmdW5jdGlvbiBDaGFydCgpIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2NvbnRhaW5lci9Hcm91cH1cbiAgICAgICAgICogQHJlYWRPbmx5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdyb3VwID0gbmV3IEdyb3VwKCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqIEByZWFkT25seVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy51aWQgPSBjb21wb25lbnRVdGlsLmdldFVJRCgndmlld0NoYXJ0Jyk7XG4gICAgfVxuXG4gICAgQ2hhcnQucHJvdG90eXBlID0ge1xuXG4gICAgICAgIHR5cGU6ICdjaGFydCcsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluaXQgdGhlIGNoYXJ0XG4gICAgICAgICAqIEBwYXJhbSAge21vZHVsZTplY2hhcnRzL21vZGVsL0dsb2JhbH0gZWNNb2RlbFxuICAgICAgICAgKiBAcGFyYW0gIHttb2R1bGU6ZWNoYXJ0cy9FeHRlbnNpb25BUEl9IGFwaVxuICAgICAgICAgKi9cbiAgICAgICAgaW5pdDogZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge30sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbmRlciB0aGUgY2hhcnRcbiAgICAgICAgICogQHBhcmFtICB7bW9kdWxlOmVjaGFydHMvbW9kZWwvU2VyaWVzfSBzZXJpZXNNb2RlbFxuICAgICAgICAgKiBAcGFyYW0gIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9IGVjTW9kZWxcbiAgICAgICAgICogQHBhcmFtICB7bW9kdWxlOmVjaGFydHMvRXh0ZW5zaW9uQVBJfSBhcGlcbiAgICAgICAgICogQHBhcmFtICB7T2JqZWN0fSBwYXlsb2FkXG4gICAgICAgICAqL1xuICAgICAgICByZW5kZXI6IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKSB7fSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSGlnaGxpZ2h0IHNlcmllcyBvciBzcGVjaWZpZWQgZGF0YSBpdGVtXG4gICAgICAgICAqIEBwYXJhbSAge21vZHVsZTplY2hhcnRzL21vZGVsL1Nlcmllc30gc2VyaWVzTW9kZWxcbiAgICAgICAgICogQHBhcmFtICB7bW9kdWxlOmVjaGFydHMvbW9kZWwvR2xvYmFsfSBlY01vZGVsXG4gICAgICAgICAqIEBwYXJhbSAge21vZHVsZTplY2hhcnRzL0V4dGVuc2lvbkFQSX0gYXBpXG4gICAgICAgICAqIEBwYXJhbSAge09iamVjdH0gcGF5bG9hZFxuICAgICAgICAgKi9cbiAgICAgICAgaGlnaGxpZ2h0OiBmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCkge1xuICAgICAgICAgICAgdG9nZ2xlSGlnaGxpZ2h0KHNlcmllc01vZGVsLmdldERhdGEoKSwgcGF5bG9hZCwgJ2VtcGhhc2lzJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERvd25wbGF5IHNlcmllcyBvciBzcGVjaWZpZWQgZGF0YSBpdGVtXG4gICAgICAgICAqIEBwYXJhbSAge21vZHVsZTplY2hhcnRzL21vZGVsL1Nlcmllc30gc2VyaWVzTW9kZWxcbiAgICAgICAgICogQHBhcmFtICB7bW9kdWxlOmVjaGFydHMvbW9kZWwvR2xvYmFsfSBlY01vZGVsXG4gICAgICAgICAqIEBwYXJhbSAge21vZHVsZTplY2hhcnRzL0V4dGVuc2lvbkFQSX0gYXBpXG4gICAgICAgICAqIEBwYXJhbSAge09iamVjdH0gcGF5bG9hZFxuICAgICAgICAgKi9cbiAgICAgICAgZG93bnBsYXk6IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKSB7XG4gICAgICAgICAgICB0b2dnbGVIaWdobGlnaHQoc2VyaWVzTW9kZWwuZ2V0RGF0YSgpLCBwYXlsb2FkLCAnbm9ybWFsJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZSBzZWxmXG4gICAgICAgICAqIEBwYXJhbSAge21vZHVsZTplY2hhcnRzL21vZGVsL0dsb2JhbH0gZWNNb2RlbFxuICAgICAgICAgKiBAcGFyYW0gIHttb2R1bGU6ZWNoYXJ0cy9FeHRlbnNpb25BUEl9IGFwaVxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiAoZWNNb2RlbCwgYXBpKSB7XG4gICAgICAgICAgICB0aGlzLmdyb3VwLnJlbW92ZUFsbCgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNwb3NlIHNlbGZcbiAgICAgICAgICogQHBhcmFtICB7bW9kdWxlOmVjaGFydHMvbW9kZWwvR2xvYmFsfSBlY01vZGVsXG4gICAgICAgICAqIEBwYXJhbSAge21vZHVsZTplY2hhcnRzL0V4dGVuc2lvbkFQSX0gYXBpXG4gICAgICAgICAqL1xuICAgICAgICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7fVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdmlldyBjb250YWlucyB0aGUgZ2l2ZW4gcG9pbnQuXG4gICAgICAgICAqIEBpbnRlcmZhY2VcbiAgICAgICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gcG9pbnRcbiAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIC8vIGNvbnRhaW5Qb2ludDogZnVuY3Rpb24gKCkge31cblxuICAgIH07XG5cbiAgICB2YXIgY2hhcnRQcm90byA9IENoYXJ0LnByb3RvdHlwZTtcbiAgICBjaGFydFByb3RvLnVwZGF0ZVZpZXdcbiAgICAgICAgPSBjaGFydFByb3RvLnVwZGF0ZUxheW91dFxuICAgICAgICA9IGNoYXJ0UHJvdG8udXBkYXRlVmlzdWFsXG4gICAgICAgID0gZnVuY3Rpb24gKHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyKHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpO1xuICAgICAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0IHN0YXRlIG9mIHNpbmdsZSBlbGVtZW50XG4gICAgICogQHBhcmFtICB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gZWxcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IHN0YXRlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZWxTZXRTdGF0ZShlbCwgc3RhdGUpIHtcbiAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgICBlbC50cmlnZ2VyKHN0YXRlKTtcbiAgICAgICAgICAgIGlmIChlbC50eXBlID09PSAnZ3JvdXAnKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbC5jaGlsZENvdW50KCk7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBlbFNldFN0YXRlKGVsLmNoaWxkQXQoaSksIHN0YXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtICB7bW9kdWxlOmVjaGFydHMvZGF0YS9MaXN0fSBkYXRhXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBwYXlsb2FkXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBzdGF0ZSAnbm9ybWFsJ3wnZW1waGFzaXMnXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9nZ2xlSGlnaGxpZ2h0KGRhdGEsIHBheWxvYWQsIHN0YXRlKSB7XG4gICAgICAgIHZhciBkYXRhSW5kZXggPSBtb2RlbFV0aWwucXVlcnlEYXRhSW5kZXgoZGF0YSwgcGF5bG9hZCk7XG5cbiAgICAgICAgaWYgKGRhdGFJbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICB6clV0aWwuZWFjaChtb2RlbFV0aWwubm9ybWFsaXplVG9BcnJheShkYXRhSW5kZXgpLCBmdW5jdGlvbiAoZGF0YUlkeCkge1xuICAgICAgICAgICAgICAgIGVsU2V0U3RhdGUoZGF0YS5nZXRJdGVtR3JhcGhpY0VsKGRhdGFJZHgpLCBzdGF0ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRhdGEuZWFjaEl0ZW1HcmFwaGljRWwoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgZWxTZXRTdGF0ZShlbCwgc3RhdGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBFbmFibGUgQ2hhcnQuZXh0ZW5kLlxuICAgIGNsYXp6VXRpbC5lbmFibGVDbGFzc0V4dGVuZChDaGFydCwgWydkaXNwb3NlJ10pO1xuXG4gICAgLy8gQWRkIGNhcGFiaWxpdHkgb2YgcmVnaXN0ZXJDbGFzcywgZ2V0Q2xhc3MsIGhhc0NsYXNzLCByZWdpc3RlclN1YlR5cGVEZWZhdWx0ZXIgYW5kIHNvIG9uLlxuICAgIGNsYXp6VXRpbC5lbmFibGVDbGFzc01hbmFnZW1lbnQoQ2hhcnQsIHtyZWdpc3RlcldoZW5FeHRlbmQ6IHRydWV9KTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gQ2hhcnQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi92aWV3L0NoYXJ0LmpzXG4vLyBtb2R1bGUgaWQgPSAyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 30 */
/* unknown exports provided */
/* all exports used */
/*!********************************************!*\
  !*** ./lib/model/mixin/makeStyleMapper.js ***!
  \********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("// TODO Parse shadow style\n// TODO Only shallow path support\n\n    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 0);\n\n    module.exports = function (properties) {\n        // Normalize\n        for (var i = 0; i < properties.length; i++) {\n            if (!properties[i][1]) {\n               properties[i][1] = properties[i][0];\n            }\n        }\n        return function (excludes, includes) {\n            var style = {};\n            for (var i = 0; i < properties.length; i++) {\n                var propName = properties[i][1];\n                if ((excludes && zrUtil.indexOf(excludes, propName) >= 0)\n                    || (includes && zrUtil.indexOf(includes, propName) < 0)\n                ) {\n                    continue;\n                }\n                var val = this.getShallow(propName);\n                if (val != null) {\n                    style[properties[i][0]] = val;\n                }\n            }\n            return style;\n        };\n    };\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvbW9kZWwvbWl4aW4vbWFrZVN0eWxlTWFwcGVyLmpzP2FkOTQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVE9ETyBQYXJzZSBzaGFkb3cgc3R5bGVcbi8vIFRPRE8gT25seSBzaGFsbG93IHBhdGggc3VwcG9ydFxuXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocHJvcGVydGllcykge1xuICAgICAgICAvLyBOb3JtYWxpemVcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIXByb3BlcnRpZXNbaV1bMV0pIHtcbiAgICAgICAgICAgICAgIHByb3BlcnRpZXNbaV1bMV0gPSBwcm9wZXJ0aWVzW2ldWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZXhjbHVkZXMsIGluY2x1ZGVzKSB7XG4gICAgICAgICAgICB2YXIgc3R5bGUgPSB7fTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBwcm9wTmFtZSA9IHByb3BlcnRpZXNbaV1bMV07XG4gICAgICAgICAgICAgICAgaWYgKChleGNsdWRlcyAmJiB6clV0aWwuaW5kZXhPZihleGNsdWRlcywgcHJvcE5hbWUpID49IDApXG4gICAgICAgICAgICAgICAgICAgIHx8IChpbmNsdWRlcyAmJiB6clV0aWwuaW5kZXhPZihpbmNsdWRlcywgcHJvcE5hbWUpIDwgMClcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciB2YWwgPSB0aGlzLmdldFNoYWxsb3cocHJvcE5hbWUpO1xuICAgICAgICAgICAgICAgIGlmICh2YWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZVtwcm9wZXJ0aWVzW2ldWzBdXSA9IHZhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3R5bGU7XG4gICAgICAgIH07XG4gICAgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL21vZGVsL21peGluL21ha2VTdHlsZU1hcHBlci5qc1xuLy8gbW9kdWxlIGlkID0gMzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 31 */
/* unknown exports provided */
/* all exports used */
/*!*************************************!*\
  !*** ./lib/component/gridSimple.js ***!
  \*************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\n    var graphic = __webpack_require__(/*! ../util/graphic */ 2);\n    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 0);\n    var echarts = __webpack_require__(/*! ../echarts */ 1);\n\n    __webpack_require__(/*! ../coord/cartesian/Grid */ 56);\n\n    __webpack_require__(/*! ./axis */ 146);\n\n    // Grid view\n    echarts.extendComponentView({\n\n        type: 'grid',\n\n        render: function (gridModel, ecModel) {\n            this.group.removeAll();\n            if (gridModel.get('show')) {\n                this.group.add(new graphic.Rect({\n                    shape: gridModel.coordinateSystem.getRect(),\n                    style: zrUtil.defaults({\n                        fill: gridModel.get('backgroundColor')\n                    }, gridModel.getItemStyle()),\n                    silent: true,\n                    z2: -1\n                }));\n            }\n        }\n\n    });\n\n    echarts.registerPreprocessor(function (option) {\n        // Only create grid when need\n        if (option.xAxis && option.yAxis && !option.grid) {\n            option.grid = {};\n        }\n    });\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvY29tcG9uZW50L2dyaWRTaW1wbGUuanM/NDk2MiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciBncmFwaGljID0gcmVxdWlyZSgnLi4vdXRpbC9ncmFwaGljJyk7XG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuICAgIHZhciBlY2hhcnRzID0gcmVxdWlyZSgnLi4vZWNoYXJ0cycpO1xuXG4gICAgcmVxdWlyZSgnLi4vY29vcmQvY2FydGVzaWFuL0dyaWQnKTtcblxuICAgIHJlcXVpcmUoJy4vYXhpcycpO1xuXG4gICAgLy8gR3JpZCB2aWV3XG4gICAgZWNoYXJ0cy5leHRlbmRDb21wb25lbnRWaWV3KHtcblxuICAgICAgICB0eXBlOiAnZ3JpZCcsXG5cbiAgICAgICAgcmVuZGVyOiBmdW5jdGlvbiAoZ3JpZE1vZGVsLCBlY01vZGVsKSB7XG4gICAgICAgICAgICB0aGlzLmdyb3VwLnJlbW92ZUFsbCgpO1xuICAgICAgICAgICAgaWYgKGdyaWRNb2RlbC5nZXQoJ3Nob3cnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXAuYWRkKG5ldyBncmFwaGljLlJlY3Qoe1xuICAgICAgICAgICAgICAgICAgICBzaGFwZTogZ3JpZE1vZGVsLmNvb3JkaW5hdGVTeXN0ZW0uZ2V0UmVjdCgpLFxuICAgICAgICAgICAgICAgICAgICBzdHlsZTogenJVdGlsLmRlZmF1bHRzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGw6IGdyaWRNb2RlbC5nZXQoJ2JhY2tncm91bmRDb2xvcicpXG4gICAgICAgICAgICAgICAgICAgIH0sIGdyaWRNb2RlbC5nZXRJdGVtU3R5bGUoKSksXG4gICAgICAgICAgICAgICAgICAgIHNpbGVudDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgejI6IC0xXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9KTtcblxuICAgIGVjaGFydHMucmVnaXN0ZXJQcmVwcm9jZXNzb3IoZnVuY3Rpb24gKG9wdGlvbikge1xuICAgICAgICAvLyBPbmx5IGNyZWF0ZSBncmlkIHdoZW4gbmVlZFxuICAgICAgICBpZiAob3B0aW9uLnhBeGlzICYmIG9wdGlvbi55QXhpcyAmJiAhb3B0aW9uLmdyaWQpIHtcbiAgICAgICAgICAgIG9wdGlvbi5ncmlkID0ge307XG4gICAgICAgIH1cbiAgICB9KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2NvbXBvbmVudC9ncmlkU2ltcGxlLmpzXG4vLyBtb2R1bGUgaWQgPSAzMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 32 */
/* unknown exports provided */
/* all exports used */
/*!****************************************!*\
  !*** /home/yx/~/zrender/lib/config.js ***!
  \****************************************/
/***/ (function(module, exports) {

eval("\n    var dpr = 1;\n    // If in browser environment\n    if (typeof window !== 'undefined') {\n        dpr = Math.max(window.devicePixelRatio || 1, 1);\n    }\n    /**\n     * config默认配置项\n     * @exports zrender/config\n     * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n     */\n    var config = {\n        /**\n         * debug日志选项：catchBrushException为true下有效\n         * 0 : 不生成debug数据，发布用\n         * 1 : 异常抛出，调试用\n         * 2 : 控制台输出，调试用\n         */\n        debugMode: 0,\n\n        // retina 屏幕优化\n        devicePixelRatio: dpr\n    };\n    module.exports = config;\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL2hvbWUveXgvfi96cmVuZGVyL2xpYi9jb25maWcuanM/ZTQxNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcbiAgICB2YXIgZHByID0gMTtcbiAgICAvLyBJZiBpbiBicm93c2VyIGVudmlyb25tZW50XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGRwciA9IE1hdGgubWF4KHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEsIDEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBjb25maWfpu5jorqTphY3nva7poblcbiAgICAgKiBAZXhwb3J0cyB6cmVuZGVyL2NvbmZpZ1xuICAgICAqIEBhdXRob3IgS2VuZXIgKEBLZW5lci3mnpfls7AsIGtlbmVyLmxpbmZlbmdAZ21haWwuY29tKVxuICAgICAqL1xuICAgIHZhciBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBkZWJ1Z+aXpeW/l+mAiemhue+8mmNhdGNoQnJ1c2hFeGNlcHRpb27kuLp0cnVl5LiL5pyJ5pWIXG4gICAgICAgICAqIDAgOiDkuI3nlJ/miJBkZWJ1Z+aVsOaNru+8jOWPkeW4g+eUqFxuICAgICAgICAgKiAxIDog5byC5bi45oqb5Ye677yM6LCD6K+V55SoXG4gICAgICAgICAqIDIgOiDmjqfliLblj7DovpPlh7rvvIzosIPor5XnlKhcbiAgICAgICAgICovXG4gICAgICAgIGRlYnVnTW9kZTogMCxcblxuICAgICAgICAvLyByZXRpbmEg5bGP5bmV5LyY5YyWXG4gICAgICAgIGRldmljZVBpeGVsUmF0aW86IGRwclxuICAgIH07XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBjb25maWc7XG5cblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2hvbWUveXgvfi96cmVuZGVyL2xpYi9jb25maWcuanNcbi8vIG1vZHVsZSBpZCA9IDMyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 33 */
/* unknown exports provided */
/* all exports used */
/*!*************************************************!*\
  !*** /home/yx/~/zrender/lib/container/Group.js ***!
  \*************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Group是一个容器，可以插入子节点，Group的变换也会被应用到子节点上\n * @module zrender/graphic/Group\n * @example\n *     var Group = require('zrender/lib/container/Group');\n *     var Circle = require('zrender/lib/graphic/shape/Circle');\n *     var g = new Group();\n *     g.position[0] = 100;\n *     g.position[1] = 100;\n *     g.add(new Circle({\n *         style: {\n *             x: 100,\n *             y: 100,\n *             r: 20,\n *         }\n *     }));\n *     zr.add(g);\n */\n\n\n    var zrUtil = __webpack_require__(/*! ../core/util */ 0);\n    var Element = __webpack_require__(/*! ../Element */ 57);\n    var BoundingRect = __webpack_require__(/*! ../core/BoundingRect */ 10);\n\n    /**\n     * @alias module:zrender/graphic/Group\n     * @constructor\n     * @extends module:zrender/mixin/Transformable\n     * @extends module:zrender/mixin/Eventful\n     */\n    var Group = function (opts) {\n\n        opts = opts || {};\n\n        Element.call(this, opts);\n\n        for (var key in opts) {\n            if (opts.hasOwnProperty(key)) {\n                this[key] = opts[key];\n            }\n        }\n\n        this._children = [];\n\n        this.__storage = null;\n\n        this.__dirty = true;\n    };\n\n    Group.prototype = {\n\n        constructor: Group,\n\n        isGroup: true,\n\n        /**\n         * @type {string}\n         */\n        type: 'group',\n\n        /**\n         * 所有子孙元素是否响应鼠标事件\n         * @name module:/zrender/container/Group#silent\n         * @type {boolean}\n         * @default false\n         */\n        silent: false,\n\n        /**\n         * @return {Array.<module:zrender/Element>}\n         */\n        children: function () {\n            return this._children.slice();\n        },\n\n        /**\n         * 获取指定 index 的儿子节点\n         * @param  {number} idx\n         * @return {module:zrender/Element}\n         */\n        childAt: function (idx) {\n            return this._children[idx];\n        },\n\n        /**\n         * 获取指定名字的儿子节点\n         * @param  {string} name\n         * @return {module:zrender/Element}\n         */\n        childOfName: function (name) {\n            var children = this._children;\n            for (var i = 0; i < children.length; i++) {\n                if (children[i].name === name) {\n                    return children[i];\n                }\n             }\n        },\n\n        /**\n         * @return {number}\n         */\n        childCount: function () {\n            return this._children.length;\n        },\n\n        /**\n         * 添加子节点到最后\n         * @param {module:zrender/Element} child\n         */\n        add: function (child) {\n            if (child && child !== this && child.parent !== this) {\n\n                this._children.push(child);\n\n                this._doAdd(child);\n            }\n\n            return this;\n        },\n\n        /**\n         * 添加子节点在 nextSibling 之前\n         * @param {module:zrender/Element} child\n         * @param {module:zrender/Element} nextSibling\n         */\n        addBefore: function (child, nextSibling) {\n            if (child && child !== this && child.parent !== this\n                && nextSibling && nextSibling.parent === this) {\n\n                var children = this._children;\n                var idx = children.indexOf(nextSibling);\n\n                if (idx >= 0) {\n                    children.splice(idx, 0, child);\n                    this._doAdd(child);\n                }\n            }\n\n            return this;\n        },\n\n        _doAdd: function (child) {\n            if (child.parent) {\n                child.parent.remove(child);\n            }\n\n            child.parent = this;\n\n            var storage = this.__storage;\n            var zr = this.__zr;\n            if (storage && storage !== child.__storage) {\n\n                storage.addToStorage(child);\n\n                if (child instanceof Group) {\n                    child.addChildrenToStorage(storage);\n                }\n            }\n\n            zr && zr.refresh();\n        },\n\n        /**\n         * 移除子节点\n         * @param {module:zrender/Element} child\n         */\n        remove: function (child) {\n            var zr = this.__zr;\n            var storage = this.__storage;\n            var children = this._children;\n\n            var idx = zrUtil.indexOf(children, child);\n            if (idx < 0) {\n                return this;\n            }\n            children.splice(idx, 1);\n\n            child.parent = null;\n\n            if (storage) {\n\n                storage.delFromStorage(child);\n\n                if (child instanceof Group) {\n                    child.delChildrenFromStorage(storage);\n                }\n            }\n\n            zr && zr.refresh();\n\n            return this;\n        },\n\n        /**\n         * 移除所有子节点\n         */\n        removeAll: function () {\n            var children = this._children;\n            var storage = this.__storage;\n            var child;\n            var i;\n            for (i = 0; i < children.length; i++) {\n                child = children[i];\n                if (storage) {\n                    storage.delFromStorage(child);\n                    if (child instanceof Group) {\n                        child.delChildrenFromStorage(storage);\n                    }\n                }\n                child.parent = null;\n            }\n            children.length = 0;\n\n            return this;\n        },\n\n        /**\n         * 遍历所有子节点\n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        eachChild: function (cb, context) {\n            var children = this._children;\n            for (var i = 0; i < children.length; i++) {\n                var child = children[i];\n                cb.call(context, child, i);\n            }\n            return this;\n        },\n\n        /**\n         * 深度优先遍历所有子孙节点\n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        traverse: function (cb, context) {\n            for (var i = 0; i < this._children.length; i++) {\n                var child = this._children[i];\n                cb.call(context, child);\n\n                if (child.type === 'group') {\n                    child.traverse(cb, context);\n                }\n            }\n            return this;\n        },\n\n        addChildrenToStorage: function (storage) {\n            for (var i = 0; i < this._children.length; i++) {\n                var child = this._children[i];\n                storage.addToStorage(child);\n                if (child instanceof Group) {\n                    child.addChildrenToStorage(storage);\n                }\n            }\n        },\n\n        delChildrenFromStorage: function (storage) {\n            for (var i = 0; i < this._children.length; i++) {\n                var child = this._children[i];\n                storage.delFromStorage(child);\n                if (child instanceof Group) {\n                    child.delChildrenFromStorage(storage);\n                }\n            }\n        },\n\n        dirty: function () {\n            this.__dirty = true;\n            this.__zr && this.__zr.refresh();\n            return this;\n        },\n\n        /**\n         * @return {module:zrender/core/BoundingRect}\n         */\n        getBoundingRect: function (includeChildren) {\n            // TODO Caching\n            var rect = null;\n            var tmpRect = new BoundingRect(0, 0, 0, 0);\n            var children = includeChildren || this._children;\n            var tmpMat = [];\n\n            for (var i = 0; i < children.length; i++) {\n                var child = children[i];\n                if (child.ignore || child.invisible) {\n                    continue;\n                }\n\n                var childRect = child.getBoundingRect();\n                var transform = child.getLocalTransform(tmpMat);\n                // TODO\n                // The boundingRect cacluated by transforming original\n                // rect may be bigger than the actual bundingRect when rotation\n                // is used. (Consider a circle rotated aginst its center, where\n                // the actual boundingRect should be the same as that not be\n                // rotated.) But we can not find better approach to calculate\n                // actual boundingRect yet, considering performance.\n                if (transform) {\n                    tmpRect.copy(childRect);\n                    tmpRect.applyTransform(transform);\n                    rect = rect || tmpRect.clone();\n                    rect.union(tmpRect);\n                }\n                else {\n                    rect = rect || childRect.clone();\n                    rect.union(childRect);\n                }\n            }\n            return rect || tmpRect;\n        }\n    };\n\n    zrUtil.inherits(Group, Element);\n\n    module.exports = Group;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL2hvbWUveXgvfi96cmVuZGVyL2xpYi9jb250YWluZXIvR3JvdXAuanM/Yzk1ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEdyb3Vw5piv5LiA5Liq5a655Zmo77yM5Y+v5Lul5o+S5YWl5a2Q6IqC54K577yMR3JvdXDnmoTlj5jmjaLkuZ/kvJrooqvlupTnlKjliLDlrZDoioLngrnkuIpcbiAqIEBtb2R1bGUgenJlbmRlci9ncmFwaGljL0dyb3VwXG4gKiBAZXhhbXBsZVxuICogICAgIHZhciBHcm91cCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvbnRhaW5lci9Hcm91cCcpO1xuICogICAgIHZhciBDaXJjbGUgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL0NpcmNsZScpO1xuICogICAgIHZhciBnID0gbmV3IEdyb3VwKCk7XG4gKiAgICAgZy5wb3NpdGlvblswXSA9IDEwMDtcbiAqICAgICBnLnBvc2l0aW9uWzFdID0gMTAwO1xuICogICAgIGcuYWRkKG5ldyBDaXJjbGUoe1xuICogICAgICAgICBzdHlsZToge1xuICogICAgICAgICAgICAgeDogMTAwLFxuICogICAgICAgICAgICAgeTogMTAwLFxuICogICAgICAgICAgICAgcjogMjAsXG4gKiAgICAgICAgIH1cbiAqICAgICB9KSk7XG4gKiAgICAgenIuYWRkKGcpO1xuICovXG5cblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgRWxlbWVudCA9IHJlcXVpcmUoJy4uL0VsZW1lbnQnKTtcbiAgICB2YXIgQm91bmRpbmdSZWN0ID0gcmVxdWlyZSgnLi4vY29yZS9Cb3VuZGluZ1JlY3QnKTtcblxuICAgIC8qKlxuICAgICAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9ncmFwaGljL0dyb3VwXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGV4dGVuZHMgbW9kdWxlOnpyZW5kZXIvbWl4aW4vVHJhbnNmb3JtYWJsZVxuICAgICAqIEBleHRlbmRzIG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsXG4gICAgICovXG4gICAgdmFyIEdyb3VwID0gZnVuY3Rpb24gKG9wdHMpIHtcblxuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICAgICAgICBFbGVtZW50LmNhbGwodGhpcywgb3B0cyk7XG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9wdHMpIHtcbiAgICAgICAgICAgIGlmIChvcHRzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzW2tleV0gPSBvcHRzW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9jaGlsZHJlbiA9IFtdO1xuXG4gICAgICAgIHRoaXMuX19zdG9yYWdlID0gbnVsbDtcblxuICAgICAgICB0aGlzLl9fZGlydHkgPSB0cnVlO1xuICAgIH07XG5cbiAgICBHcm91cC5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IEdyb3VwLFxuXG4gICAgICAgIGlzR3JvdXA6IHRydWUsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0eXBlOiAnZ3JvdXAnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmiYDmnInlrZDlrZnlhYPntKDmmK/lkKblk43lupTpvKDmoIfkuovku7ZcbiAgICAgICAgICogQG5hbWUgbW9kdWxlOi96cmVuZGVyL2NvbnRhaW5lci9Hcm91cCNzaWxlbnRcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBzaWxlbnQ6IGZhbHNlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48bW9kdWxlOnpyZW5kZXIvRWxlbWVudD59XG4gICAgICAgICAqL1xuICAgICAgICBjaGlsZHJlbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NoaWxkcmVuLnNsaWNlKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiOt+WPluaMh+WumiBpbmRleCDnmoTlhL/lrZDoioLngrlcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSBpZHhcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH1cbiAgICAgICAgICovXG4gICAgICAgIGNoaWxkQXQ6IGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jaGlsZHJlbltpZHhdO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDojrflj5bmjIflrprlkI3lrZfnmoTlhL/lrZDoioLngrlcbiAgICAgICAgICogQHBhcmFtICB7c3RyaW5nfSBuYW1lXG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9XG4gICAgICAgICAqL1xuICAgICAgICBjaGlsZE9mTmFtZTogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZHJlbltpXS5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBjaGlsZENvdW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmt7vliqDlrZDoioLngrnliLDmnIDlkI5cbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBjaGlsZFxuICAgICAgICAgKi9cbiAgICAgICAgYWRkOiBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZCAmJiBjaGlsZCAhPT0gdGhpcyAmJiBjaGlsZC5wYXJlbnQgIT09IHRoaXMpIHtcblxuICAgICAgICAgICAgICAgIHRoaXMuX2NoaWxkcmVuLnB1c2goY2hpbGQpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fZG9BZGQoY2hpbGQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5re75Yqg5a2Q6IqC54K55ZyoIG5leHRTaWJsaW5nIOS5i+WJjVxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGNoaWxkXG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gbmV4dFNpYmxpbmdcbiAgICAgICAgICovXG4gICAgICAgIGFkZEJlZm9yZTogZnVuY3Rpb24gKGNoaWxkLCBuZXh0U2libGluZykge1xuICAgICAgICAgICAgaWYgKGNoaWxkICYmIGNoaWxkICE9PSB0aGlzICYmIGNoaWxkLnBhcmVudCAhPT0gdGhpc1xuICAgICAgICAgICAgICAgICYmIG5leHRTaWJsaW5nICYmIG5leHRTaWJsaW5nLnBhcmVudCA9PT0gdGhpcykge1xuXG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG4gICAgICAgICAgICAgICAgdmFyIGlkeCA9IGNoaWxkcmVuLmluZGV4T2YobmV4dFNpYmxpbmcpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuLnNwbGljZShpZHgsIDAsIGNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZG9BZGQoY2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2RvQWRkOiBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZC5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBjaGlsZC5wYXJlbnQucmVtb3ZlKGNoaWxkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2hpbGQucGFyZW50ID0gdGhpcztcblxuICAgICAgICAgICAgdmFyIHN0b3JhZ2UgPSB0aGlzLl9fc3RvcmFnZTtcbiAgICAgICAgICAgIHZhciB6ciA9IHRoaXMuX196cjtcbiAgICAgICAgICAgIGlmIChzdG9yYWdlICYmIHN0b3JhZ2UgIT09IGNoaWxkLl9fc3RvcmFnZSkge1xuXG4gICAgICAgICAgICAgICAgc3RvcmFnZS5hZGRUb1N0b3JhZ2UoY2hpbGQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgR3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuYWRkQ2hpbGRyZW5Ub1N0b3JhZ2Uoc3RvcmFnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB6ciAmJiB6ci5yZWZyZXNoKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOenu+mZpOWtkOiKgueCuVxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGNoaWxkXG4gICAgICAgICAqL1xuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgdmFyIHpyID0gdGhpcy5fX3pyO1xuICAgICAgICAgICAgdmFyIHN0b3JhZ2UgPSB0aGlzLl9fc3RvcmFnZTtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXG4gICAgICAgICAgICB2YXIgaWR4ID0genJVdGlsLmluZGV4T2YoY2hpbGRyZW4sIGNoaWxkKTtcbiAgICAgICAgICAgIGlmIChpZHggPCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGlsZHJlbi5zcGxpY2UoaWR4LCAxKTtcblxuICAgICAgICAgICAgY2hpbGQucGFyZW50ID0gbnVsbDtcblxuICAgICAgICAgICAgaWYgKHN0b3JhZ2UpIHtcblxuICAgICAgICAgICAgICAgIHN0b3JhZ2UuZGVsRnJvbVN0b3JhZ2UoY2hpbGQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgR3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuZGVsQ2hpbGRyZW5Gcm9tU3RvcmFnZShzdG9yYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHpyICYmIHpyLnJlZnJlc2goKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOenu+mZpOaJgOacieWtkOiKgueCuVxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3ZlQWxsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcbiAgICAgICAgICAgIHZhciBzdG9yYWdlID0gdGhpcy5fX3N0b3JhZ2U7XG4gICAgICAgICAgICB2YXIgY2hpbGQ7XG4gICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgaWYgKHN0b3JhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcmFnZS5kZWxGcm9tU3RvcmFnZShjaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZC5kZWxDaGlsZHJlbkZyb21TdG9yYWdlKHN0b3JhZ2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNoaWxkLnBhcmVudCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGlsZHJlbi5sZW5ndGggPSAwO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog6YGN5Y6G5omA5pyJ5a2Q6IqC54K5XG4gICAgICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYlxuICAgICAgICAgKiBAcGFyYW0gIHt9ICAgY29udGV4dFxuICAgICAgICAgKi9cbiAgICAgICAgZWFjaENoaWxkOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGNiLmNhbGwoY29udGV4dCwgY2hpbGQsIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOa3seW6puS8mOWFiOmBjeWOhuaJgOacieWtkOWtmeiKgueCuVxuICAgICAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2JcbiAgICAgICAgICogQHBhcmFtICB7fSAgIGNvbnRleHRcbiAgICAgICAgICovXG4gICAgICAgIHRyYXZlcnNlOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLl9jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBjYi5jYWxsKGNvbnRleHQsIGNoaWxkKTtcblxuICAgICAgICAgICAgICAgIGlmIChjaGlsZC50eXBlID09PSAnZ3JvdXAnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLnRyYXZlcnNlKGNiLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBhZGRDaGlsZHJlblRvU3RvcmFnZTogZnVuY3Rpb24gKHN0b3JhZ2UpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLl9jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBzdG9yYWdlLmFkZFRvU3RvcmFnZShjaGlsZCk7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgR3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuYWRkQ2hpbGRyZW5Ub1N0b3JhZ2Uoc3RvcmFnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGRlbENoaWxkcmVuRnJvbVN0b3JhZ2U6IGZ1bmN0aW9uIChzdG9yYWdlKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5fY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgc3RvcmFnZS5kZWxGcm9tU3RvcmFnZShjaGlsZCk7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgR3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuZGVsQ2hpbGRyZW5Gcm9tU3RvcmFnZShzdG9yYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGlydHk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX19kaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9fenIgJiYgdGhpcy5fX3pyLnJlZnJlc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL0JvdW5kaW5nUmVjdH1cbiAgICAgICAgICovXG4gICAgICAgIGdldEJvdW5kaW5nUmVjdDogZnVuY3Rpb24gKGluY2x1ZGVDaGlsZHJlbikge1xuICAgICAgICAgICAgLy8gVE9ETyBDYWNoaW5nXG4gICAgICAgICAgICB2YXIgcmVjdCA9IG51bGw7XG4gICAgICAgICAgICB2YXIgdG1wUmVjdCA9IG5ldyBCb3VuZGluZ1JlY3QoMCwgMCwgMCwgMCk7XG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBpbmNsdWRlQ2hpbGRyZW4gfHwgdGhpcy5fY2hpbGRyZW47XG4gICAgICAgICAgICB2YXIgdG1wTWF0ID0gW107XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQuaWdub3JlIHx8IGNoaWxkLmludmlzaWJsZSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRSZWN0ID0gY2hpbGQuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgICAgICAgICAgICAgdmFyIHRyYW5zZm9ybSA9IGNoaWxkLmdldExvY2FsVHJhbnNmb3JtKHRtcE1hdCk7XG4gICAgICAgICAgICAgICAgLy8gVE9ET1xuICAgICAgICAgICAgICAgIC8vIFRoZSBib3VuZGluZ1JlY3QgY2FjbHVhdGVkIGJ5IHRyYW5zZm9ybWluZyBvcmlnaW5hbFxuICAgICAgICAgICAgICAgIC8vIHJlY3QgbWF5IGJlIGJpZ2dlciB0aGFuIHRoZSBhY3R1YWwgYnVuZGluZ1JlY3Qgd2hlbiByb3RhdGlvblxuICAgICAgICAgICAgICAgIC8vIGlzIHVzZWQuIChDb25zaWRlciBhIGNpcmNsZSByb3RhdGVkIGFnaW5zdCBpdHMgY2VudGVyLCB3aGVyZVxuICAgICAgICAgICAgICAgIC8vIHRoZSBhY3R1YWwgYm91bmRpbmdSZWN0IHNob3VsZCBiZSB0aGUgc2FtZSBhcyB0aGF0IG5vdCBiZVxuICAgICAgICAgICAgICAgIC8vIHJvdGF0ZWQuKSBCdXQgd2UgY2FuIG5vdCBmaW5kIGJldHRlciBhcHByb2FjaCB0byBjYWxjdWxhdGVcbiAgICAgICAgICAgICAgICAvLyBhY3R1YWwgYm91bmRpbmdSZWN0IHlldCwgY29uc2lkZXJpbmcgcGVyZm9ybWFuY2UuXG4gICAgICAgICAgICAgICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgICAgICAgICAgICAgICB0bXBSZWN0LmNvcHkoY2hpbGRSZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgdG1wUmVjdC5hcHBseVRyYW5zZm9ybSh0cmFuc2Zvcm0pO1xuICAgICAgICAgICAgICAgICAgICByZWN0ID0gcmVjdCB8fCB0bXBSZWN0LmNsb25lKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlY3QudW5pb24odG1wUmVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZWN0ID0gcmVjdCB8fCBjaGlsZFJlY3QuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgcmVjdC51bmlvbihjaGlsZFJlY3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZWN0IHx8IHRtcFJlY3Q7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgenJVdGlsLmluaGVyaXRzKEdyb3VwLCBFbGVtZW50KTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gR3JvdXA7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS95eC9+L3pyZW5kZXIvbGliL2NvbnRhaW5lci9Hcm91cC5qc1xuLy8gbW9kdWxlIGlkID0gMzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 34 */
/* unknown exports provided */
/* all exports used */
/*!***************************!*\
  !*** ./lib/coord/Axis.js ***!
  \***************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var numberUtil = __webpack_require__(/*! ../util/number */ 3);\n    var linearMap = numberUtil.linearMap;\n    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 0);\n\n    function fixExtentWithBands(extent, nTick) {\n        var size = extent[1] - extent[0];\n        var len = nTick;\n        var margin = size / len / 2;\n        extent[0] += margin;\n        extent[1] -= margin;\n    }\n\n    var normalizedExtent = [0, 1];\n    /**\n     * @name module:echarts/coord/CartesianAxis\n     * @constructor\n     */\n    var Axis = function (dim, scale, extent) {\n\n        /**\n         * Axis dimension. Such as 'x', 'y', 'z', 'angle', 'radius'\n         * @type {string}\n         */\n        this.dim = dim;\n\n        /**\n         * Axis scale\n         * @type {module:echarts/coord/scale/*}\n         */\n        this.scale = scale;\n\n        /**\n         * @type {Array.<number>}\n         * @private\n         */\n        this._extent = extent || [0, 0];\n\n        /**\n         * @type {boolean}\n         */\n        this.inverse = false;\n\n        /**\n         * Usually true when axis has a ordinal scale\n         * @type {boolean}\n         */\n        this.onBand = false;\n    };\n\n    Axis.prototype = {\n\n        constructor: Axis,\n\n        /**\n         * If axis extent contain given coord\n         * @param {number} coord\n         * @return {boolean}\n         */\n        contain: function (coord) {\n            var extent = this._extent;\n            var min = Math.min(extent[0], extent[1]);\n            var max = Math.max(extent[0], extent[1]);\n            return coord >= min && coord <= max;\n        },\n\n        /**\n         * If axis extent contain given data\n         * @param {number} data\n         * @return {boolean}\n         */\n        containData: function (data) {\n            return this.contain(this.dataToCoord(data));\n        },\n\n        /**\n         * Get coord extent.\n         * @return {Array.<number>}\n         */\n        getExtent: function () {\n            var ret = this._extent.slice();\n            return ret;\n        },\n\n        /**\n         * Get precision used for formatting\n         * @param {Array.<number>} [dataExtent]\n         * @return {number}\n         */\n        getPixelPrecision: function (dataExtent) {\n            return numberUtil.getPixelPrecision(\n                dataExtent || this.scale.getExtent(),\n                this._extent\n            );\n        },\n\n        /**\n         * Set coord extent\n         * @param {number} start\n         * @param {number} end\n         */\n        setExtent: function (start, end) {\n            var extent = this._extent;\n            extent[0] = start;\n            extent[1] = end;\n        },\n\n        /**\n         * Convert data to coord. Data is the rank if it has a ordinal scale\n         * @param {number} data\n         * @param  {boolean} clamp\n         * @return {number}\n         */\n        dataToCoord: function (data, clamp) {\n            var extent = this._extent;\n            var scale = this.scale;\n            data = scale.normalize(data);\n\n            if (this.onBand && scale.type === 'ordinal') {\n                extent = extent.slice();\n                fixExtentWithBands(extent, scale.count());\n            }\n\n            return linearMap(data, normalizedExtent, extent, clamp);\n        },\n\n        /**\n         * Convert coord to data. Data is the rank if it has a ordinal scale\n         * @param {number} coord\n         * @param  {boolean} clamp\n         * @return {number}\n         */\n        coordToData: function (coord, clamp) {\n            var extent = this._extent;\n            var scale = this.scale;\n\n            if (this.onBand && scale.type === 'ordinal') {\n                extent = extent.slice();\n                fixExtentWithBands(extent, scale.count());\n            }\n\n            var t = linearMap(coord, extent, normalizedExtent, clamp);\n\n            return this.scale.scale(t);\n        },\n\n        /**\n         * Convert pixel point to data in axis\n         * @param {Array.<number>} point\n         * @param  {boolean} clamp\n         * @return {number} data\n         */\n        pointToData: function (point, clamp) {\n            // Should be implemented in derived class if necessary.\n        },\n\n        /**\n         * @return {Array.<number>}\n         */\n        getTicksCoords: function (alignWithLabel) {\n            if (this.onBand && !alignWithLabel) {\n                var bands = this.getBands();\n                var coords = [];\n                for (var i = 0; i < bands.length; i++) {\n                    coords.push(bands[i][0]);\n                }\n                if (bands[i - 1]) {\n                    coords.push(bands[i - 1][1]);\n                }\n                return coords;\n            }\n            else {\n                return zrUtil.map(this.scale.getTicks(), this.dataToCoord, this);\n            }\n        },\n\n        /**\n         * Coords of labels are on the ticks or on the middle of bands\n         * @return {Array.<number>}\n         */\n        getLabelsCoords: function () {\n            return zrUtil.map(this.scale.getTicks(), this.dataToCoord, this);\n        },\n\n        /**\n         * Get bands.\n         *\n         * If axis has labels [1, 2, 3, 4]. Bands on the axis are\n         * |---1---|---2---|---3---|---4---|.\n         *\n         * @return {Array}\n         */\n         // FIXME Situation when labels is on ticks\n        getBands: function () {\n            var extent = this.getExtent();\n            var bands = [];\n            var len = this.scale.count();\n            var start = extent[0];\n            var end = extent[1];\n            var span = end - start;\n\n            for (var i = 0; i < len; i++) {\n                bands.push([\n                    span * i / len + start,\n                    span * (i + 1) / len + start\n                ]);\n            }\n            return bands;\n        },\n\n        /**\n         * Get width of band\n         * @return {number}\n         */\n        getBandWidth: function () {\n            var axisExtent = this._extent;\n            var dataExtent = this.scale.getExtent();\n\n            var len = dataExtent[1] - dataExtent[0] + (this.onBand ? 1 : 0);\n            // Fix #2728, avoid NaN when only one data.\n            len === 0 && (len = 1);\n\n            var size = Math.abs(axisExtent[1] - axisExtent[0]);\n\n            return Math.abs(size) / len;\n        }\n\n    };\n\n    module.exports = Axis;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvY29vcmQvQXhpcy5qcz8wYWFiIl0sInNvdXJjZXNDb250ZW50IjpbIlxuXG4gICAgdmFyIG51bWJlclV0aWwgPSByZXF1aXJlKCcuLi91dGlsL251bWJlcicpO1xuICAgIHZhciBsaW5lYXJNYXAgPSBudW1iZXJVdGlsLmxpbmVhck1hcDtcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG5cbiAgICBmdW5jdGlvbiBmaXhFeHRlbnRXaXRoQmFuZHMoZXh0ZW50LCBuVGljaykge1xuICAgICAgICB2YXIgc2l6ZSA9IGV4dGVudFsxXSAtIGV4dGVudFswXTtcbiAgICAgICAgdmFyIGxlbiA9IG5UaWNrO1xuICAgICAgICB2YXIgbWFyZ2luID0gc2l6ZSAvIGxlbiAvIDI7XG4gICAgICAgIGV4dGVudFswXSArPSBtYXJnaW47XG4gICAgICAgIGV4dGVudFsxXSAtPSBtYXJnaW47XG4gICAgfVxuXG4gICAgdmFyIG5vcm1hbGl6ZWRFeHRlbnQgPSBbMCwgMV07XG4gICAgLyoqXG4gICAgICogQG5hbWUgbW9kdWxlOmVjaGFydHMvY29vcmQvQ2FydGVzaWFuQXhpc1xuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIHZhciBBeGlzID0gZnVuY3Rpb24gKGRpbSwgc2NhbGUsIGV4dGVudCkge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBeGlzIGRpbWVuc2lvbi4gU3VjaCBhcyAneCcsICd5JywgJ3onLCAnYW5nbGUnLCAncmFkaXVzJ1xuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kaW0gPSBkaW07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEF4aXMgc2NhbGVcbiAgICAgICAgICogQHR5cGUge21vZHVsZTplY2hhcnRzL2Nvb3JkL3NjYWxlLyp9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNjYWxlID0gc2NhbGU7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2V4dGVudCA9IGV4dGVudCB8fCBbMCwgMF07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pbnZlcnNlID0gZmFsc2U7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVzdWFsbHkgdHJ1ZSB3aGVuIGF4aXMgaGFzIGEgb3JkaW5hbCBzY2FsZVxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub25CYW5kID0gZmFsc2U7XG4gICAgfTtcblxuICAgIEF4aXMucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBBeGlzLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBheGlzIGV4dGVudCBjb250YWluIGdpdmVuIGNvb3JkXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb29yZFxuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgY29udGFpbjogZnVuY3Rpb24gKGNvb3JkKSB7XG4gICAgICAgICAgICB2YXIgZXh0ZW50ID0gdGhpcy5fZXh0ZW50O1xuICAgICAgICAgICAgdmFyIG1pbiA9IE1hdGgubWluKGV4dGVudFswXSwgZXh0ZW50WzFdKTtcbiAgICAgICAgICAgIHZhciBtYXggPSBNYXRoLm1heChleHRlbnRbMF0sIGV4dGVudFsxXSk7XG4gICAgICAgICAgICByZXR1cm4gY29vcmQgPj0gbWluICYmIGNvb3JkIDw9IG1heDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgYXhpcyBleHRlbnQgY29udGFpbiBnaXZlbiBkYXRhXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkYXRhXG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBjb250YWluRGF0YTogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRhaW4odGhpcy5kYXRhVG9Db29yZChkYXRhKSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBjb29yZCBleHRlbnQuXG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0RXh0ZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmV0ID0gdGhpcy5fZXh0ZW50LnNsaWNlKCk7XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgcHJlY2lzaW9uIHVzZWQgZm9yIGZvcm1hdHRpbmdcbiAgICAgICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gW2RhdGFFeHRlbnRdXG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIGdldFBpeGVsUHJlY2lzaW9uOiBmdW5jdGlvbiAoZGF0YUV4dGVudCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bWJlclV0aWwuZ2V0UGl4ZWxQcmVjaXNpb24oXG4gICAgICAgICAgICAgICAgZGF0YUV4dGVudCB8fCB0aGlzLnNjYWxlLmdldEV4dGVudCgpLFxuICAgICAgICAgICAgICAgIHRoaXMuX2V4dGVudFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IGNvb3JkIGV4dGVudFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZFxuICAgICAgICAgKi9cbiAgICAgICAgc2V0RXh0ZW50OiBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICAgICAgICAgICAgdmFyIGV4dGVudCA9IHRoaXMuX2V4dGVudDtcbiAgICAgICAgICAgIGV4dGVudFswXSA9IHN0YXJ0O1xuICAgICAgICAgICAgZXh0ZW50WzFdID0gZW5kO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0IGRhdGEgdG8gY29vcmQuIERhdGEgaXMgdGhlIHJhbmsgaWYgaXQgaGFzIGEgb3JkaW5hbCBzY2FsZVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gZGF0YVxuICAgICAgICAgKiBAcGFyYW0gIHtib29sZWFufSBjbGFtcFxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBkYXRhVG9Db29yZDogZnVuY3Rpb24gKGRhdGEsIGNsYW1wKSB7XG4gICAgICAgICAgICB2YXIgZXh0ZW50ID0gdGhpcy5fZXh0ZW50O1xuICAgICAgICAgICAgdmFyIHNjYWxlID0gdGhpcy5zY2FsZTtcbiAgICAgICAgICAgIGRhdGEgPSBzY2FsZS5ub3JtYWxpemUoZGF0YSk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLm9uQmFuZCAmJiBzY2FsZS50eXBlID09PSAnb3JkaW5hbCcpIHtcbiAgICAgICAgICAgICAgICBleHRlbnQgPSBleHRlbnQuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICBmaXhFeHRlbnRXaXRoQmFuZHMoZXh0ZW50LCBzY2FsZS5jb3VudCgpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGxpbmVhck1hcChkYXRhLCBub3JtYWxpemVkRXh0ZW50LCBleHRlbnQsIGNsYW1wKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydCBjb29yZCB0byBkYXRhLiBEYXRhIGlzIHRoZSByYW5rIGlmIGl0IGhhcyBhIG9yZGluYWwgc2NhbGVcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGNvb3JkXG4gICAgICAgICAqIEBwYXJhbSAge2Jvb2xlYW59IGNsYW1wXG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIGNvb3JkVG9EYXRhOiBmdW5jdGlvbiAoY29vcmQsIGNsYW1wKSB7XG4gICAgICAgICAgICB2YXIgZXh0ZW50ID0gdGhpcy5fZXh0ZW50O1xuICAgICAgICAgICAgdmFyIHNjYWxlID0gdGhpcy5zY2FsZTtcblxuICAgICAgICAgICAgaWYgKHRoaXMub25CYW5kICYmIHNjYWxlLnR5cGUgPT09ICdvcmRpbmFsJykge1xuICAgICAgICAgICAgICAgIGV4dGVudCA9IGV4dGVudC5zbGljZSgpO1xuICAgICAgICAgICAgICAgIGZpeEV4dGVudFdpdGhCYW5kcyhleHRlbnQsIHNjYWxlLmNvdW50KCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdCA9IGxpbmVhck1hcChjb29yZCwgZXh0ZW50LCBub3JtYWxpemVkRXh0ZW50LCBjbGFtcCk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYWxlLnNjYWxlKHQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0IHBpeGVsIHBvaW50IHRvIGRhdGEgaW4gYXhpc1xuICAgICAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBwb2ludFxuICAgICAgICAgKiBAcGFyYW0gIHtib29sZWFufSBjbGFtcFxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IGRhdGFcbiAgICAgICAgICovXG4gICAgICAgIHBvaW50VG9EYXRhOiBmdW5jdGlvbiAocG9pbnQsIGNsYW1wKSB7XG4gICAgICAgICAgICAvLyBTaG91bGQgYmUgaW1wbGVtZW50ZWQgaW4gZGVyaXZlZCBjbGFzcyBpZiBuZWNlc3NhcnkuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0VGlja3NDb29yZHM6IGZ1bmN0aW9uIChhbGlnbldpdGhMYWJlbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMub25CYW5kICYmICFhbGlnbldpdGhMYWJlbCkge1xuICAgICAgICAgICAgICAgIHZhciBiYW5kcyA9IHRoaXMuZ2V0QmFuZHMoKTtcbiAgICAgICAgICAgICAgICB2YXIgY29vcmRzID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiYW5kcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb29yZHMucHVzaChiYW5kc1tpXVswXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChiYW5kc1tpIC0gMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgY29vcmRzLnB1c2goYmFuZHNbaSAtIDFdWzFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvb3JkcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB6clV0aWwubWFwKHRoaXMuc2NhbGUuZ2V0VGlja3MoKSwgdGhpcy5kYXRhVG9Db29yZCwgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvb3JkcyBvZiBsYWJlbHMgYXJlIG9uIHRoZSB0aWNrcyBvciBvbiB0aGUgbWlkZGxlIG9mIGJhbmRzXG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0TGFiZWxzQ29vcmRzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4genJVdGlsLm1hcCh0aGlzLnNjYWxlLmdldFRpY2tzKCksIHRoaXMuZGF0YVRvQ29vcmQsIHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgYmFuZHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIGF4aXMgaGFzIGxhYmVscyBbMSwgMiwgMywgNF0uIEJhbmRzIG9uIHRoZSBheGlzIGFyZVxuICAgICAgICAgKiB8LS0tMS0tLXwtLS0yLS0tfC0tLTMtLS18LS0tNC0tLXwuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAgICAgKi9cbiAgICAgICAgIC8vIEZJWE1FIFNpdHVhdGlvbiB3aGVuIGxhYmVscyBpcyBvbiB0aWNrc1xuICAgICAgICBnZXRCYW5kczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGV4dGVudCA9IHRoaXMuZ2V0RXh0ZW50KCk7XG4gICAgICAgICAgICB2YXIgYmFuZHMgPSBbXTtcbiAgICAgICAgICAgIHZhciBsZW4gPSB0aGlzLnNjYWxlLmNvdW50KCk7XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSBleHRlbnRbMF07XG4gICAgICAgICAgICB2YXIgZW5kID0gZXh0ZW50WzFdO1xuICAgICAgICAgICAgdmFyIHNwYW4gPSBlbmQgLSBzdGFydDtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGJhbmRzLnB1c2goW1xuICAgICAgICAgICAgICAgICAgICBzcGFuICogaSAvIGxlbiArIHN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICBzcGFuICogKGkgKyAxKSAvIGxlbiArIHN0YXJ0XG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYmFuZHM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB3aWR0aCBvZiBiYW5kXG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIGdldEJhbmRXaWR0aDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGF4aXNFeHRlbnQgPSB0aGlzLl9leHRlbnQ7XG4gICAgICAgICAgICB2YXIgZGF0YUV4dGVudCA9IHRoaXMuc2NhbGUuZ2V0RXh0ZW50KCk7XG5cbiAgICAgICAgICAgIHZhciBsZW4gPSBkYXRhRXh0ZW50WzFdIC0gZGF0YUV4dGVudFswXSArICh0aGlzLm9uQmFuZCA/IDEgOiAwKTtcbiAgICAgICAgICAgIC8vIEZpeCAjMjcyOCwgYXZvaWQgTmFOIHdoZW4gb25seSBvbmUgZGF0YS5cbiAgICAgICAgICAgIGxlbiA9PT0gMCAmJiAobGVuID0gMSk7XG5cbiAgICAgICAgICAgIHZhciBzaXplID0gTWF0aC5hYnMoYXhpc0V4dGVudFsxXSAtIGF4aXNFeHRlbnRbMF0pO1xuXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5hYnMoc2l6ZSkgLyBsZW47XG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IEF4aXM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9jb29yZC9BeGlzLmpzXG4vLyBtb2R1bGUgaWQgPSAzNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 35 */
/* unknown exports provided */
/* all exports used */
/*!****************************!*\
  !*** ./lib/scale/Scale.js ***!
  \****************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * // Scale class management\n * @module echarts/scale/Scale\n */\n\n\n    var clazzUtil = __webpack_require__(/*! ../util/clazz */ 14);\n\n    /**\n     * @param {Object} [setting]\n     */\n    function Scale(setting) {\n        this._setting = setting || {};\n\n        /**\n         * Extent\n         * @type {Array.<number>}\n         * @protected\n         */\n        this._extent = [Infinity, -Infinity];\n\n        /**\n         * Step is calculated in adjustExtent\n         * @type {Array.<number>}\n         * @protected\n         */\n        this._interval = 0;\n\n        this.init && this.init.apply(this, arguments);\n    }\n\n    var scaleProto = Scale.prototype;\n\n    /**\n     * Parse input val to valid inner number.\n     * @param {*} val\n     * @return {number}\n     */\n    scaleProto.parse = function (val) {\n        // Notice: This would be a trap here, If the implementation\n        // of this method depends on extent, and this method is used\n        // before extent set (like in dataZoom), it would be wrong.\n        // Nevertheless, parse does not depend on extent generally.\n        return val;\n    };\n\n    scaleProto.getSetting = function (name) {\n        return this._setting[name];\n    };\n\n    scaleProto.contain = function (val) {\n        var extent = this._extent;\n        return val >= extent[0] && val <= extent[1];\n    };\n\n    /**\n     * Normalize value to linear [0, 1], return 0.5 if extent span is 0\n     * @param {number} val\n     * @return {number}\n     */\n    scaleProto.normalize = function (val) {\n        var extent = this._extent;\n        if (extent[1] === extent[0]) {\n            return 0.5;\n        }\n        return (val - extent[0]) / (extent[1] - extent[0]);\n    };\n\n    /**\n     * Scale normalized value\n     * @param {number} val\n     * @return {number}\n     */\n    scaleProto.scale = function (val) {\n        var extent = this._extent;\n        return val * (extent[1] - extent[0]) + extent[0];\n    };\n\n    /**\n     * Set extent from data\n     * @param {Array.<number>} other\n     */\n    scaleProto.unionExtent = function (other) {\n        var extent = this._extent;\n        other[0] < extent[0] && (extent[0] = other[0]);\n        other[1] > extent[1] && (extent[1] = other[1]);\n        // not setExtent because in log axis it may transformed to power\n        // this.setExtent(extent[0], extent[1]);\n    };\n\n    /**\n     * Set extent from data\n     * @param {module:echarts/data/List} data\n     * @param {string} dim\n     */\n    scaleProto.unionExtentFromData = function (data, dim) {\n        this.unionExtent(data.getDataExtent(dim, true));\n    };\n\n    /**\n     * Get extent\n     * @return {Array.<number>}\n     */\n    scaleProto.getExtent = function () {\n        return this._extent.slice();\n    };\n\n    /**\n     * Set extent\n     * @param {number} start\n     * @param {number} end\n     */\n    scaleProto.setExtent = function (start, end) {\n        var thisExtent = this._extent;\n        if (!isNaN(start)) {\n            thisExtent[0] = start;\n        }\n        if (!isNaN(end)) {\n            thisExtent[1] = end;\n        }\n    };\n\n    /**\n     * @return {Array.<string>}\n     */\n    scaleProto.getTicksLabels = function () {\n        var labels = [];\n        var ticks = this.getTicks();\n        for (var i = 0; i < ticks.length; i++) {\n            labels.push(this.getLabel(ticks[i]));\n        }\n        return labels;\n    };\n\n    /**\n     * When axis extent depends on data and no data exists,\n     * axis ticks should not be drawn, which is named 'blank'.\n     */\n    scaleProto.isBlank = function () {\n        return this._isBlank;\n    },\n\n    /**\n     * When axis extent depends on data and no data exists,\n     * axis ticks should not be drawn, which is named 'blank'.\n     */\n    scaleProto.setBlank = function (isBlank) {\n        this._isBlank = isBlank;\n    };\n\n\n    clazzUtil.enableClassExtend(Scale);\n    clazzUtil.enableClassManagement(Scale, {\n        registerWhenExtend: true\n    });\n\n    module.exports = Scale;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvc2NhbGUvU2NhbGUuanM/ZmNkNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIC8vIFNjYWxlIGNsYXNzIG1hbmFnZW1lbnRcbiAqIEBtb2R1bGUgZWNoYXJ0cy9zY2FsZS9TY2FsZVxuICovXG5cblxuICAgIHZhciBjbGF6elV0aWwgPSByZXF1aXJlKCcuLi91dGlsL2NsYXp6Jyk7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3NldHRpbmddXG4gICAgICovXG4gICAgZnVuY3Rpb24gU2NhbGUoc2V0dGluZykge1xuICAgICAgICB0aGlzLl9zZXR0aW5nID0gc2V0dGluZyB8fCB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRXh0ZW50XG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fZXh0ZW50ID0gW0luZmluaXR5LCAtSW5maW5pdHldO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdGVwIGlzIGNhbGN1bGF0ZWQgaW4gYWRqdXN0RXh0ZW50XG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5faW50ZXJ2YWwgPSAwO1xuXG4gICAgICAgIHRoaXMuaW5pdCAmJiB0aGlzLmluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICB2YXIgc2NhbGVQcm90byA9IFNjYWxlLnByb3RvdHlwZTtcblxuICAgIC8qKlxuICAgICAqIFBhcnNlIGlucHV0IHZhbCB0byB2YWxpZCBpbm5lciBudW1iZXIuXG4gICAgICogQHBhcmFtIHsqfSB2YWxcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgc2NhbGVQcm90by5wYXJzZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgLy8gTm90aWNlOiBUaGlzIHdvdWxkIGJlIGEgdHJhcCBoZXJlLCBJZiB0aGUgaW1wbGVtZW50YXRpb25cbiAgICAgICAgLy8gb2YgdGhpcyBtZXRob2QgZGVwZW5kcyBvbiBleHRlbnQsIGFuZCB0aGlzIG1ldGhvZCBpcyB1c2VkXG4gICAgICAgIC8vIGJlZm9yZSBleHRlbnQgc2V0IChsaWtlIGluIGRhdGFab29tKSwgaXQgd291bGQgYmUgd3JvbmcuXG4gICAgICAgIC8vIE5ldmVydGhlbGVzcywgcGFyc2UgZG9lcyBub3QgZGVwZW5kIG9uIGV4dGVudCBnZW5lcmFsbHkuXG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfTtcblxuICAgIHNjYWxlUHJvdG8uZ2V0U2V0dGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZXR0aW5nW25hbWVdO1xuICAgIH07XG5cbiAgICBzY2FsZVByb3RvLmNvbnRhaW4gPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIHZhciBleHRlbnQgPSB0aGlzLl9leHRlbnQ7XG4gICAgICAgIHJldHVybiB2YWwgPj0gZXh0ZW50WzBdICYmIHZhbCA8PSBleHRlbnRbMV07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIE5vcm1hbGl6ZSB2YWx1ZSB0byBsaW5lYXIgWzAsIDFdLCByZXR1cm4gMC41IGlmIGV4dGVudCBzcGFuIGlzIDBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIHNjYWxlUHJvdG8ubm9ybWFsaXplID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICB2YXIgZXh0ZW50ID0gdGhpcy5fZXh0ZW50O1xuICAgICAgICBpZiAoZXh0ZW50WzFdID09PSBleHRlbnRbMF0pIHtcbiAgICAgICAgICAgIHJldHVybiAwLjU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICh2YWwgLSBleHRlbnRbMF0pIC8gKGV4dGVudFsxXSAtIGV4dGVudFswXSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNjYWxlIG5vcm1hbGl6ZWQgdmFsdWVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIHNjYWxlUHJvdG8uc2NhbGUgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIHZhciBleHRlbnQgPSB0aGlzLl9leHRlbnQ7XG4gICAgICAgIHJldHVybiB2YWwgKiAoZXh0ZW50WzFdIC0gZXh0ZW50WzBdKSArIGV4dGVudFswXTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0IGV4dGVudCBmcm9tIGRhdGFcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBvdGhlclxuICAgICAqL1xuICAgIHNjYWxlUHJvdG8udW5pb25FeHRlbnQgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgdmFyIGV4dGVudCA9IHRoaXMuX2V4dGVudDtcbiAgICAgICAgb3RoZXJbMF0gPCBleHRlbnRbMF0gJiYgKGV4dGVudFswXSA9IG90aGVyWzBdKTtcbiAgICAgICAgb3RoZXJbMV0gPiBleHRlbnRbMV0gJiYgKGV4dGVudFsxXSA9IG90aGVyWzFdKTtcbiAgICAgICAgLy8gbm90IHNldEV4dGVudCBiZWNhdXNlIGluIGxvZyBheGlzIGl0IG1heSB0cmFuc2Zvcm1lZCB0byBwb3dlclxuICAgICAgICAvLyB0aGlzLnNldEV4dGVudChleHRlbnRbMF0sIGV4dGVudFsxXSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldCBleHRlbnQgZnJvbSBkYXRhXG4gICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9kYXRhL0xpc3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGltXG4gICAgICovXG4gICAgc2NhbGVQcm90by51bmlvbkV4dGVudEZyb21EYXRhID0gZnVuY3Rpb24gKGRhdGEsIGRpbSkge1xuICAgICAgICB0aGlzLnVuaW9uRXh0ZW50KGRhdGEuZ2V0RGF0YUV4dGVudChkaW0sIHRydWUpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IGV4dGVudFxuICAgICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICAgICAqL1xuICAgIHNjYWxlUHJvdG8uZ2V0RXh0ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZXh0ZW50LnNsaWNlKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldCBleHRlbnRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kXG4gICAgICovXG4gICAgc2NhbGVQcm90by5zZXRFeHRlbnQgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICAgICAgICB2YXIgdGhpc0V4dGVudCA9IHRoaXMuX2V4dGVudDtcbiAgICAgICAgaWYgKCFpc05hTihzdGFydCkpIHtcbiAgICAgICAgICAgIHRoaXNFeHRlbnRbMF0gPSBzdGFydDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzTmFOKGVuZCkpIHtcbiAgICAgICAgICAgIHRoaXNFeHRlbnRbMV0gPSBlbmQ7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7QXJyYXkuPHN0cmluZz59XG4gICAgICovXG4gICAgc2NhbGVQcm90by5nZXRUaWNrc0xhYmVscyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGxhYmVscyA9IFtdO1xuICAgICAgICB2YXIgdGlja3MgPSB0aGlzLmdldFRpY2tzKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGlja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxhYmVscy5wdXNoKHRoaXMuZ2V0TGFiZWwodGlja3NbaV0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGFiZWxzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGF4aXMgZXh0ZW50IGRlcGVuZHMgb24gZGF0YSBhbmQgbm8gZGF0YSBleGlzdHMsXG4gICAgICogYXhpcyB0aWNrcyBzaG91bGQgbm90IGJlIGRyYXduLCB3aGljaCBpcyBuYW1lZCAnYmxhbmsnLlxuICAgICAqL1xuICAgIHNjYWxlUHJvdG8uaXNCbGFuayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzQmxhbms7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gYXhpcyBleHRlbnQgZGVwZW5kcyBvbiBkYXRhIGFuZCBubyBkYXRhIGV4aXN0cyxcbiAgICAgKiBheGlzIHRpY2tzIHNob3VsZCBub3QgYmUgZHJhd24sIHdoaWNoIGlzIG5hbWVkICdibGFuaycuXG4gICAgICovXG4gICAgc2NhbGVQcm90by5zZXRCbGFuayA9IGZ1bmN0aW9uIChpc0JsYW5rKSB7XG4gICAgICAgIHRoaXMuX2lzQmxhbmsgPSBpc0JsYW5rO1xuICAgIH07XG5cblxuICAgIGNsYXp6VXRpbC5lbmFibGVDbGFzc0V4dGVuZChTY2FsZSk7XG4gICAgY2xhenpVdGlsLmVuYWJsZUNsYXNzTWFuYWdlbWVudChTY2FsZSwge1xuICAgICAgICByZWdpc3RlcldoZW5FeHRlbmQ6IHRydWVcbiAgICB9KTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gU2NhbGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9zY2FsZS9TY2FsZS5qc1xuLy8gbW9kdWxlIGlkID0gMzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 36 */
/* unknown exports provided */
/* all exports used */
/*!*****************************************************!*\
  !*** /home/yx/~/zrender/lib/graphic/Displayable.js ***!
  \*****************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * 可绘制的图形基类\n * Base class of all displayable graphic objects\n * @module zrender/graphic/Displayable\n */\n\n\n\n    var zrUtil = __webpack_require__(/*! ../core/util */ 0);\n\n    var Style = __webpack_require__(/*! ./Style */ 64);\n\n    var Element = __webpack_require__(/*! ../Element */ 57);\n    var RectText = __webpack_require__(/*! ./mixin/RectText */ 78);\n    // var Stateful = require('./mixin/Stateful');\n\n    /**\n     * @alias module:zrender/graphic/Displayable\n     * @extends module:zrender/Element\n     * @extends module:zrender/graphic/mixin/RectText\n     */\n    function Displayable(opts) {\n\n        opts = opts || {};\n\n        Element.call(this, opts);\n\n        // Extend properties\n        for (var name in opts) {\n            if (\n                opts.hasOwnProperty(name) &&\n                name !== 'style'\n            ) {\n                this[name] = opts[name];\n            }\n        }\n\n        /**\n         * @type {module:zrender/graphic/Style}\n         */\n        this.style = new Style(opts.style);\n\n        this._rect = null;\n        // Shapes for cascade clipping.\n        this.__clipPaths = [];\n\n        // FIXME Stateful must be mixined after style is setted\n        // Stateful.call(this, opts);\n    }\n\n    Displayable.prototype = {\n\n        constructor: Displayable,\n\n        type: 'displayable',\n\n        /**\n         * Displayable 是否为脏，Painter 中会根据该标记判断是否需要是否需要重新绘制\n         * Dirty flag. From which painter will determine if this displayable object needs brush\n         * @name module:zrender/graphic/Displayable#__dirty\n         * @type {boolean}\n         */\n        __dirty: true,\n\n        /**\n         * 图形是否可见，为true时不绘制图形，但是仍能触发鼠标事件\n         * If ignore drawing of the displayable object. Mouse event will still be triggered\n         * @name module:/zrender/graphic/Displayable#invisible\n         * @type {boolean}\n         * @default false\n         */\n        invisible: false,\n\n        /**\n         * @name module:/zrender/graphic/Displayable#z\n         * @type {number}\n         * @default 0\n         */\n        z: 0,\n\n        /**\n         * @name module:/zrender/graphic/Displayable#z\n         * @type {number}\n         * @default 0\n         */\n        z2: 0,\n\n        /**\n         * z层level，决定绘画在哪层canvas中\n         * @name module:/zrender/graphic/Displayable#zlevel\n         * @type {number}\n         * @default 0\n         */\n        zlevel: 0,\n\n        /**\n         * 是否可拖拽\n         * @name module:/zrender/graphic/Displayable#draggable\n         * @type {boolean}\n         * @default false\n         */\n        draggable: false,\n\n        /**\n         * 是否正在拖拽\n         * @name module:/zrender/graphic/Displayable#draggable\n         * @type {boolean}\n         * @default false\n         */\n        dragging: false,\n\n        /**\n         * 是否相应鼠标事件\n         * @name module:/zrender/graphic/Displayable#silent\n         * @type {boolean}\n         * @default false\n         */\n        silent: false,\n\n        /**\n         * If enable culling\n         * @type {boolean}\n         * @default false\n         */\n        culling: false,\n\n        /**\n         * Mouse cursor when hovered\n         * @name module:/zrender/graphic/Displayable#cursor\n         * @type {string}\n         */\n        cursor: 'pointer',\n\n        /**\n         * If hover area is bounding rect\n         * @name module:/zrender/graphic/Displayable#rectHover\n         * @type {string}\n         */\n        rectHover: false,\n\n        /**\n         * Render the element progressively when the value >= 0,\n         * usefull for large data.\n         * @type {number}\n         */\n        progressive: -1,\n\n        beforeBrush: function (ctx) {},\n\n        afterBrush: function (ctx) {},\n\n        /**\n         * 图形绘制方法\n         * @param {Canvas2DRenderingContext} ctx\n         */\n        // Interface\n        brush: function (ctx, prevEl) {},\n\n        /**\n         * 获取最小包围盒\n         * @return {module:zrender/core/BoundingRect}\n         */\n        // Interface\n        getBoundingRect: function () {},\n\n        /**\n         * 判断坐标 x, y 是否在图形上\n         * If displayable element contain coord x, y\n         * @param  {number} x\n         * @param  {number} y\n         * @return {boolean}\n         */\n        contain: function (x, y) {\n            return this.rectContain(x, y);\n        },\n\n        /**\n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        traverse: function (cb, context) {\n            cb.call(context, this);\n        },\n\n        /**\n         * 判断坐标 x, y 是否在图形的包围盒上\n         * If bounding rect of element contain coord x, y\n         * @param  {number} x\n         * @param  {number} y\n         * @return {boolean}\n         */\n        rectContain: function (x, y) {\n            var coord = this.transformCoordToLocal(x, y);\n            var rect = this.getBoundingRect();\n            return rect.contain(coord[0], coord[1]);\n        },\n\n        /**\n         * 标记图形元素为脏，并且在下一帧重绘\n         * Mark displayable element dirty and refresh next frame\n         */\n        dirty: function () {\n            this.__dirty = true;\n\n            this._rect = null;\n\n            this.__zr && this.__zr.refresh();\n        },\n\n        /**\n         * 图形是否会触发事件\n         * If displayable object binded any event\n         * @return {boolean}\n         */\n        // TODO, 通过 bind 绑定的事件\n        // isSilent: function () {\n        //     return !(\n        //         this.hoverable || this.draggable\n        //         || this.onmousemove || this.onmouseover || this.onmouseout\n        //         || this.onmousedown || this.onmouseup || this.onclick\n        //         || this.ondragenter || this.ondragover || this.ondragleave\n        //         || this.ondrop\n        //     );\n        // },\n        /**\n         * Alias for animate('style')\n         * @param {boolean} loop\n         */\n        animateStyle: function (loop) {\n            return this.animate('style', loop);\n        },\n\n        attrKV: function (key, value) {\n            if (key !== 'style') {\n                Element.prototype.attrKV.call(this, key, value);\n            }\n            else {\n                this.style.set(value);\n            }\n        },\n\n        /**\n         * @param {Object|string} key\n         * @param {*} value\n         */\n        setStyle: function (key, value) {\n            this.style.set(key, value);\n            this.dirty(false);\n            return this;\n        },\n\n        /**\n         * Use given style object\n         * @param  {Object} obj\n         */\n        useStyle: function (obj) {\n            this.style = new Style(obj);\n            this.dirty(false);\n            return this;\n        }\n    };\n\n    zrUtil.inherits(Displayable, Element);\n\n    zrUtil.mixin(Displayable, RectText);\n    // zrUtil.mixin(Displayable, Stateful);\n\n    module.exports = Displayable;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL2hvbWUveXgvfi96cmVuZGVyL2xpYi9ncmFwaGljL0Rpc3BsYXlhYmxlLmpzP2RhMGMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiDlj6/nu5jliLbnmoTlm77lvaLln7rnsbtcbiAqIEJhc2UgY2xhc3Mgb2YgYWxsIGRpc3BsYXlhYmxlIGdyYXBoaWMgb2JqZWN0c1xuICogQG1vZHVsZSB6cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGVcbiAqL1xuXG5cblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKTtcblxuICAgIHZhciBTdHlsZSA9IHJlcXVpcmUoJy4vU3R5bGUnKTtcblxuICAgIHZhciBFbGVtZW50ID0gcmVxdWlyZSgnLi4vRWxlbWVudCcpO1xuICAgIHZhciBSZWN0VGV4dCA9IHJlcXVpcmUoJy4vbWl4aW4vUmVjdFRleHQnKTtcbiAgICAvLyB2YXIgU3RhdGVmdWwgPSByZXF1aXJlKCcuL21peGluL1N0YXRlZnVsJyk7XG5cbiAgICAvKipcbiAgICAgKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZVxuICAgICAqIEBleHRlbmRzIG1vZHVsZTp6cmVuZGVyL0VsZW1lbnRcbiAgICAgKiBAZXh0ZW5kcyBtb2R1bGU6enJlbmRlci9ncmFwaGljL21peGluL1JlY3RUZXh0XG4gICAgICovXG4gICAgZnVuY3Rpb24gRGlzcGxheWFibGUob3B0cykge1xuXG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gICAgICAgIEVsZW1lbnQuY2FsbCh0aGlzLCBvcHRzKTtcblxuICAgICAgICAvLyBFeHRlbmQgcHJvcGVydGllc1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIG9wdHMpIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBvcHRzLmhhc093blByb3BlcnR5KG5hbWUpICYmXG4gICAgICAgICAgICAgICAgbmFtZSAhPT0gJ3N0eWxlJ1xuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdGhpc1tuYW1lXSA9IG9wdHNbbmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2dyYXBoaWMvU3R5bGV9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0eWxlID0gbmV3IFN0eWxlKG9wdHMuc3R5bGUpO1xuXG4gICAgICAgIHRoaXMuX3JlY3QgPSBudWxsO1xuICAgICAgICAvLyBTaGFwZXMgZm9yIGNhc2NhZGUgY2xpcHBpbmcuXG4gICAgICAgIHRoaXMuX19jbGlwUGF0aHMgPSBbXTtcblxuICAgICAgICAvLyBGSVhNRSBTdGF0ZWZ1bCBtdXN0IGJlIG1peGluZWQgYWZ0ZXIgc3R5bGUgaXMgc2V0dGVkXG4gICAgICAgIC8vIFN0YXRlZnVsLmNhbGwodGhpcywgb3B0cyk7XG4gICAgfVxuXG4gICAgRGlzcGxheWFibGUucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBEaXNwbGF5YWJsZSxcblxuICAgICAgICB0eXBlOiAnZGlzcGxheWFibGUnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNwbGF5YWJsZSDmmK/lkKbkuLrohI/vvIxQYWludGVyIOS4reS8muagueaNruivpeagh+iusOWIpOaWreaYr+WQpumcgOimgeaYr+WQpumcgOimgemHjeaWsOe7mOWItlxuICAgICAgICAgKiBEaXJ0eSBmbGFnLiBGcm9tIHdoaWNoIHBhaW50ZXIgd2lsbCBkZXRlcm1pbmUgaWYgdGhpcyBkaXNwbGF5YWJsZSBvYmplY3QgbmVlZHMgYnJ1c2hcbiAgICAgICAgICogQG5hbWUgbW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZSNfX2RpcnR5XG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgX19kaXJ0eTogdHJ1ZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5Zu+5b2i5piv5ZCm5Y+v6KeB77yM5Li6dHJ1ZeaXtuS4jee7mOWItuWbvuW9ou+8jOS9huaYr+S7jeiDveinpuWPkem8oOagh+S6i+S7tlxuICAgICAgICAgKiBJZiBpZ25vcmUgZHJhd2luZyBvZiB0aGUgZGlzcGxheWFibGUgb2JqZWN0LiBNb3VzZSBldmVudCB3aWxsIHN0aWxsIGJlIHRyaWdnZXJlZFxuICAgICAgICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZSNpbnZpc2libGVcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBpbnZpc2libGU6IGZhbHNlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZSN6XG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDBcbiAgICAgICAgICovXG4gICAgICAgIHo6IDAsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlI3pcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMFxuICAgICAgICAgKi9cbiAgICAgICAgejI6IDAsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHrlsYJsZXZlbO+8jOWGs+Wumue7mOeUu+WcqOWTquWxgmNhbnZhc+S4rVxuICAgICAgICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZSN6bGV2ZWxcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMFxuICAgICAgICAgKi9cbiAgICAgICAgemxldmVsOiAwLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmmK/lkKblj6/mi5bmi71cbiAgICAgICAgICogQG5hbWUgbW9kdWxlOi96cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGUjZHJhZ2dhYmxlXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgZHJhZ2dhYmxlOiBmYWxzZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5piv5ZCm5q2j5Zyo5ouW5ou9XG4gICAgICAgICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlI2RyYWdnYWJsZVxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIGRyYWdnaW5nOiBmYWxzZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5piv5ZCm55u45bqU6byg5qCH5LqL5Lu2XG4gICAgICAgICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlI3NpbGVudFxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHNpbGVudDogZmFsc2UsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGVuYWJsZSBjdWxsaW5nXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgY3VsbGluZzogZmFsc2UsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1vdXNlIGN1cnNvciB3aGVuIGhvdmVyZWRcbiAgICAgICAgICogQG5hbWUgbW9kdWxlOi96cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGUjY3Vyc29yXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICBjdXJzb3I6ICdwb2ludGVyJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgaG92ZXIgYXJlYSBpcyBib3VuZGluZyByZWN0XG4gICAgICAgICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlI3JlY3RIb3ZlclxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgcmVjdEhvdmVyOiBmYWxzZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVuZGVyIHRoZSBlbGVtZW50IHByb2dyZXNzaXZlbHkgd2hlbiB0aGUgdmFsdWUgPj0gMCxcbiAgICAgICAgICogdXNlZnVsbCBmb3IgbGFyZ2UgZGF0YS5cbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHByb2dyZXNzaXZlOiAtMSxcblxuICAgICAgICBiZWZvcmVCcnVzaDogZnVuY3Rpb24gKGN0eCkge30sXG5cbiAgICAgICAgYWZ0ZXJCcnVzaDogZnVuY3Rpb24gKGN0eCkge30sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWbvuW9oue7mOWItuaWueazlVxuICAgICAgICAgKiBAcGFyYW0ge0NhbnZhczJEUmVuZGVyaW5nQ29udGV4dH0gY3R4XG4gICAgICAgICAqL1xuICAgICAgICAvLyBJbnRlcmZhY2VcbiAgICAgICAgYnJ1c2g6IGZ1bmN0aW9uIChjdHgsIHByZXZFbCkge30sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiOt+WPluacgOWwj+WMheWbtOebklxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL0JvdW5kaW5nUmVjdH1cbiAgICAgICAgICovXG4gICAgICAgIC8vIEludGVyZmFjZVxuICAgICAgICBnZXRCb3VuZGluZ1JlY3Q6IGZ1bmN0aW9uICgpIHt9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDliKTmlq3lnZDmoIcgeCwgeSDmmK/lkKblnKjlm77lvaLkuIpcbiAgICAgICAgICogSWYgZGlzcGxheWFibGUgZWxlbWVudCBjb250YWluIGNvb3JkIHgsIHlcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB4XG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0geVxuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgY29udGFpbjogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlY3RDb250YWluKHgsIHkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2JcbiAgICAgICAgICogQHBhcmFtICB7fSAgIGNvbnRleHRcbiAgICAgICAgICovXG4gICAgICAgIHRyYXZlcnNlOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIGNiLmNhbGwoY29udGV4dCwgdGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWIpOaWreWdkOaghyB4LCB5IOaYr+WQpuWcqOWbvuW9oueahOWMheWbtOebkuS4ilxuICAgICAgICAgKiBJZiBib3VuZGluZyByZWN0IG9mIGVsZW1lbnQgY29udGFpbiBjb29yZCB4LCB5XG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0geFxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHlcbiAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHJlY3RDb250YWluOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgdmFyIGNvb3JkID0gdGhpcy50cmFuc2Zvcm1Db29yZFRvTG9jYWwoeCwgeSk7XG4gICAgICAgICAgICB2YXIgcmVjdCA9IHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgICAgICAgICByZXR1cm4gcmVjdC5jb250YWluKGNvb3JkWzBdLCBjb29yZFsxXSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOagh+iusOWbvuW9ouWFg+e0oOS4uuiEj++8jOW5tuS4lOWcqOS4i+S4gOW4p+mHjee7mFxuICAgICAgICAgKiBNYXJrIGRpc3BsYXlhYmxlIGVsZW1lbnQgZGlydHkgYW5kIHJlZnJlc2ggbmV4dCBmcmFtZVxuICAgICAgICAgKi9cbiAgICAgICAgZGlydHk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX19kaXJ0eSA9IHRydWU7XG5cbiAgICAgICAgICAgIHRoaXMuX3JlY3QgPSBudWxsO1xuXG4gICAgICAgICAgICB0aGlzLl9fenIgJiYgdGhpcy5fX3pyLnJlZnJlc2goKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5Zu+5b2i5piv5ZCm5Lya6Kem5Y+R5LqL5Lu2XG4gICAgICAgICAqIElmIGRpc3BsYXlhYmxlIG9iamVjdCBiaW5kZWQgYW55IGV2ZW50XG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICAvLyBUT0RPLCDpgJrov4cgYmluZCDnu5HlrprnmoTkuovku7ZcbiAgICAgICAgLy8gaXNTaWxlbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gICAgIHJldHVybiAhKFxuICAgICAgICAvLyAgICAgICAgIHRoaXMuaG92ZXJhYmxlIHx8IHRoaXMuZHJhZ2dhYmxlXG4gICAgICAgIC8vICAgICAgICAgfHwgdGhpcy5vbm1vdXNlbW92ZSB8fCB0aGlzLm9ubW91c2VvdmVyIHx8IHRoaXMub25tb3VzZW91dFxuICAgICAgICAvLyAgICAgICAgIHx8IHRoaXMub25tb3VzZWRvd24gfHwgdGhpcy5vbm1vdXNldXAgfHwgdGhpcy5vbmNsaWNrXG4gICAgICAgIC8vICAgICAgICAgfHwgdGhpcy5vbmRyYWdlbnRlciB8fCB0aGlzLm9uZHJhZ292ZXIgfHwgdGhpcy5vbmRyYWdsZWF2ZVxuICAgICAgICAvLyAgICAgICAgIHx8IHRoaXMub25kcm9wXG4gICAgICAgIC8vICAgICApO1xuICAgICAgICAvLyB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQWxpYXMgZm9yIGFuaW1hdGUoJ3N0eWxlJylcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBsb29wXG4gICAgICAgICAqL1xuICAgICAgICBhbmltYXRlU3R5bGU6IGZ1bmN0aW9uIChsb29wKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hbmltYXRlKCdzdHlsZScsIGxvb3ApO1xuICAgICAgICB9LFxuXG4gICAgICAgIGF0dHJLVjogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChrZXkgIT09ICdzdHlsZScpIHtcbiAgICAgICAgICAgICAgICBFbGVtZW50LnByb3RvdHlwZS5hdHRyS1YuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc3R5bGUuc2V0KHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R8c3RyaW5nfSBrZXlcbiAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0U3R5bGU6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnN0eWxlLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMuZGlydHkoZmFsc2UpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVzZSBnaXZlbiBzdHlsZSBvYmplY3RcbiAgICAgICAgICogQHBhcmFtICB7T2JqZWN0fSBvYmpcbiAgICAgICAgICovXG4gICAgICAgIHVzZVN0eWxlOiBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICB0aGlzLnN0eWxlID0gbmV3IFN0eWxlKG9iaik7XG4gICAgICAgICAgICB0aGlzLmRpcnR5KGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHpyVXRpbC5pbmhlcml0cyhEaXNwbGF5YWJsZSwgRWxlbWVudCk7XG5cbiAgICB6clV0aWwubWl4aW4oRGlzcGxheWFibGUsIFJlY3RUZXh0KTtcbiAgICAvLyB6clV0aWwubWl4aW4oRGlzcGxheWFibGUsIFN0YXRlZnVsKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gRGlzcGxheWFibGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS95eC9+L3pyZW5kZXIvbGliL2dyYXBoaWMvRGlzcGxheWFibGUuanNcbi8vIG1vZHVsZSBpZCA9IDM2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 37 */
/* unknown exports provided */
/* all exports used */
/*!**************************************************!*\
  !*** /home/yx/~/zrender/lib/graphic/Gradient.js ***!
  \**************************************************/
/***/ (function(module, exports) {

eval("\n\n    /**\n     * @param {Array.<Object>} colorStops\n     */\n    var Gradient = function (colorStops) {\n\n        this.colorStops = colorStops || [];\n    };\n\n    Gradient.prototype = {\n\n        constructor: Gradient,\n\n        addColorStop: function (offset, color) {\n            this.colorStops.push({\n\n                offset: offset,\n\n                color: color\n            });\n        }\n    };\n\n    module.exports = Gradient;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL2hvbWUveXgvfi96cmVuZGVyL2xpYi9ncmFwaGljL0dyYWRpZW50LmpzP2ZlY2MiXSwic291cmNlc0NvbnRlbnQiOlsiXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxPYmplY3Q+fSBjb2xvclN0b3BzXG4gICAgICovXG4gICAgdmFyIEdyYWRpZW50ID0gZnVuY3Rpb24gKGNvbG9yU3RvcHMpIHtcblxuICAgICAgICB0aGlzLmNvbG9yU3RvcHMgPSBjb2xvclN0b3BzIHx8IFtdO1xuICAgIH07XG5cbiAgICBHcmFkaWVudC5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IEdyYWRpZW50LFxuXG4gICAgICAgIGFkZENvbG9yU3RvcDogZnVuY3Rpb24gKG9mZnNldCwgY29sb3IpIHtcbiAgICAgICAgICAgIHRoaXMuY29sb3JTdG9wcy5wdXNoKHtcblxuICAgICAgICAgICAgICAgIG9mZnNldDogb2Zmc2V0LFxuXG4gICAgICAgICAgICAgICAgY29sb3I6IGNvbG9yXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IEdyYWRpZW50O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2hvbWUveXgvfi96cmVuZGVyL2xpYi9ncmFwaGljL0dyYWRpZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAzN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 38 */
/* unknown exports provided */
/* all exports used */
/*!******************************!*\
  !*** ./lib/util/throttle.js ***!
  \******************************/
/***/ (function(module, exports) {

eval("\n\n    var lib = {};\n\n    var ORIGIN_METHOD = '\\0__throttleOriginMethod';\n    var RATE = '\\0__throttleRate';\n    var THROTTLE_TYPE = '\\0__throttleType';\n\n    /**\n     * @public\n     * @param {(Function)} fn\n     * @param {number} [delay=0] Unit: ms.\n     * @param {boolean} [debounce=false]\n     *        true: If call interval less than `delay`, only the last call works.\n     *        false: If call interval less than `delay, call works on fixed rate.\n     * @return {(Function)} throttled fn.\n     */\n    lib.throttle = function (fn, delay, debounce) {\n\n        var currCall;\n        var lastCall = 0;\n        var lastExec = 0;\n        var timer = null;\n        var diff;\n        var scope;\n        var args;\n        var debounceNextCall;\n\n        delay = delay || 0;\n\n        function exec() {\n            lastExec = (new Date()).getTime();\n            timer = null;\n            fn.apply(scope, args || []);\n        }\n\n        var cb = function () {\n            currCall = (new Date()).getTime();\n            scope = this;\n            args = arguments;\n            var thisDelay = debounceNextCall || delay;\n            var thisDebounce = debounceNextCall || debounce;\n            debounceNextCall = null;\n            diff = currCall - (thisDebounce ? lastCall : lastExec) - thisDelay;\n\n            clearTimeout(timer);\n\n            if (thisDebounce) {\n                timer = setTimeout(exec, thisDelay);\n            }\n            else {\n                if (diff >= 0) {\n                    exec();\n                }\n                else {\n                    timer = setTimeout(exec, -diff);\n                }\n            }\n\n            lastCall = currCall;\n        };\n\n        /**\n         * Clear throttle.\n         * @public\n         */\n        cb.clear = function () {\n            if (timer) {\n                clearTimeout(timer);\n                timer = null;\n            }\n        };\n\n        /**\n         * Enable debounce once.\n         */\n        cb.debounceNextCall = function (debounceDelay) {\n            debounceNextCall = debounceDelay;\n        };\n\n        return cb;\n    };\n\n    /**\n     * Create throttle method or update throttle rate.\n     *\n     * @example\n     * ComponentView.prototype.render = function () {\n     *     ...\n     *     throttle.createOrUpdate(\n     *         this,\n     *         '_dispatchAction',\n     *         this.model.get('throttle'),\n     *         'fixRate'\n     *     );\n     * };\n     * ComponentView.prototype.remove = function () {\n     *     throttle.clear(this, '_dispatchAction');\n     * };\n     * ComponentView.prototype.dispose = function () {\n     *     throttle.clear(this, '_dispatchAction');\n     * };\n     *\n     * @public\n     * @param {Object} obj\n     * @param {string} fnAttr\n     * @param {number} [rate]\n     * @param {string} [throttleType='fixRate'] 'fixRate' or 'debounce'\n     * @return {Function} throttled function.\n     */\n    lib.createOrUpdate = function (obj, fnAttr, rate, throttleType) {\n        var fn = obj[fnAttr];\n\n        if (!fn) {\n            return;\n        }\n\n        var originFn = fn[ORIGIN_METHOD] || fn;\n        var lastThrottleType = fn[THROTTLE_TYPE];\n        var lastRate = fn[RATE];\n\n        if (lastRate !== rate || lastThrottleType !== throttleType) {\n            if (rate == null || !throttleType) {\n                return (obj[fnAttr] = originFn);\n            }\n\n            fn = obj[fnAttr] = lib.throttle(\n                originFn, rate, throttleType === 'debounce'\n            );\n            fn[ORIGIN_METHOD] = originFn;\n            fn[THROTTLE_TYPE] = throttleType;\n            fn[RATE] = rate;\n        }\n\n        return fn;\n    };\n\n    /**\n     * Clear throttle. Example see throttle.createOrUpdate.\n     *\n     * @public\n     * @param {Object} obj\n     * @param {string} fnAttr\n     */\n    lib.clear = function (obj, fnAttr) {\n        var fn = obj[fnAttr];\n        if (fn && fn[ORIGIN_METHOD]) {\n            obj[fnAttr] = fn[ORIGIN_METHOD];\n        }\n    };\n\n    module.exports = lib;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvdXRpbC90aHJvdHRsZS5qcz85NzYxIl0sInNvdXJjZXNDb250ZW50IjpbIlxuXG4gICAgdmFyIGxpYiA9IHt9O1xuXG4gICAgdmFyIE9SSUdJTl9NRVRIT0QgPSAnXFwwX190aHJvdHRsZU9yaWdpbk1ldGhvZCc7XG4gICAgdmFyIFJBVEUgPSAnXFwwX190aHJvdHRsZVJhdGUnO1xuICAgIHZhciBUSFJPVFRMRV9UWVBFID0gJ1xcMF9fdGhyb3R0bGVUeXBlJztcblxuICAgIC8qKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAcGFyYW0geyhGdW5jdGlvbil9IGZuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtkZWxheT0wXSBVbml0OiBtcy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtkZWJvdW5jZT1mYWxzZV1cbiAgICAgKiAgICAgICAgdHJ1ZTogSWYgY2FsbCBpbnRlcnZhbCBsZXNzIHRoYW4gYGRlbGF5YCwgb25seSB0aGUgbGFzdCBjYWxsIHdvcmtzLlxuICAgICAqICAgICAgICBmYWxzZTogSWYgY2FsbCBpbnRlcnZhbCBsZXNzIHRoYW4gYGRlbGF5LCBjYWxsIHdvcmtzIG9uIGZpeGVkIHJhdGUuXG4gICAgICogQHJldHVybiB7KEZ1bmN0aW9uKX0gdGhyb3R0bGVkIGZuLlxuICAgICAqL1xuICAgIGxpYi50aHJvdHRsZSA9IGZ1bmN0aW9uIChmbiwgZGVsYXksIGRlYm91bmNlKSB7XG5cbiAgICAgICAgdmFyIGN1cnJDYWxsO1xuICAgICAgICB2YXIgbGFzdENhbGwgPSAwO1xuICAgICAgICB2YXIgbGFzdEV4ZWMgPSAwO1xuICAgICAgICB2YXIgdGltZXIgPSBudWxsO1xuICAgICAgICB2YXIgZGlmZjtcbiAgICAgICAgdmFyIHNjb3BlO1xuICAgICAgICB2YXIgYXJncztcbiAgICAgICAgdmFyIGRlYm91bmNlTmV4dENhbGw7XG5cbiAgICAgICAgZGVsYXkgPSBkZWxheSB8fCAwO1xuXG4gICAgICAgIGZ1bmN0aW9uIGV4ZWMoKSB7XG4gICAgICAgICAgICBsYXN0RXhlYyA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICB0aW1lciA9IG51bGw7XG4gICAgICAgICAgICBmbi5hcHBseShzY29wZSwgYXJncyB8fCBbXSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjdXJyQ2FsbCA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICBzY29wZSA9IHRoaXM7XG4gICAgICAgICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgdmFyIHRoaXNEZWxheSA9IGRlYm91bmNlTmV4dENhbGwgfHwgZGVsYXk7XG4gICAgICAgICAgICB2YXIgdGhpc0RlYm91bmNlID0gZGVib3VuY2VOZXh0Q2FsbCB8fCBkZWJvdW5jZTtcbiAgICAgICAgICAgIGRlYm91bmNlTmV4dENhbGwgPSBudWxsO1xuICAgICAgICAgICAgZGlmZiA9IGN1cnJDYWxsIC0gKHRoaXNEZWJvdW5jZSA/IGxhc3RDYWxsIDogbGFzdEV4ZWMpIC0gdGhpc0RlbGF5O1xuXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuXG4gICAgICAgICAgICBpZiAodGhpc0RlYm91bmNlKSB7XG4gICAgICAgICAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KGV4ZWMsIHRoaXNEZWxheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoZGlmZiA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4ZWMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRpbWVyID0gc2V0VGltZW91dChleGVjLCAtZGlmZik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsYXN0Q2FsbCA9IGN1cnJDYWxsO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDbGVhciB0aHJvdHRsZS5cbiAgICAgICAgICogQHB1YmxpY1xuICAgICAgICAgKi9cbiAgICAgICAgY2IuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGltZXIpIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICAgICAgICAgIHRpbWVyID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRW5hYmxlIGRlYm91bmNlIG9uY2UuXG4gICAgICAgICAqL1xuICAgICAgICBjYi5kZWJvdW5jZU5leHRDYWxsID0gZnVuY3Rpb24gKGRlYm91bmNlRGVsYXkpIHtcbiAgICAgICAgICAgIGRlYm91bmNlTmV4dENhbGwgPSBkZWJvdW5jZURlbGF5O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBjYjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHRocm90dGxlIG1ldGhvZCBvciB1cGRhdGUgdGhyb3R0bGUgcmF0ZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogQ29tcG9uZW50Vmlldy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAqICAgICAuLi5cbiAgICAgKiAgICAgdGhyb3R0bGUuY3JlYXRlT3JVcGRhdGUoXG4gICAgICogICAgICAgICB0aGlzLFxuICAgICAqICAgICAgICAgJ19kaXNwYXRjaEFjdGlvbicsXG4gICAgICogICAgICAgICB0aGlzLm1vZGVsLmdldCgndGhyb3R0bGUnKSxcbiAgICAgKiAgICAgICAgICdmaXhSYXRlJ1xuICAgICAqICAgICApO1xuICAgICAqIH07XG4gICAgICogQ29tcG9uZW50Vmlldy5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgICAqICAgICB0aHJvdHRsZS5jbGVhcih0aGlzLCAnX2Rpc3BhdGNoQWN0aW9uJyk7XG4gICAgICogfTtcbiAgICAgKiBDb21wb25lbnRWaWV3LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAqICAgICB0aHJvdHRsZS5jbGVhcih0aGlzLCAnX2Rpc3BhdGNoQWN0aW9uJyk7XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZuQXR0clxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcmF0ZV1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3Rocm90dGxlVHlwZT0nZml4UmF0ZSddICdmaXhSYXRlJyBvciAnZGVib3VuY2UnXG4gICAgICogQHJldHVybiB7RnVuY3Rpb259IHRocm90dGxlZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBsaWIuY3JlYXRlT3JVcGRhdGUgPSBmdW5jdGlvbiAob2JqLCBmbkF0dHIsIHJhdGUsIHRocm90dGxlVHlwZSkge1xuICAgICAgICB2YXIgZm4gPSBvYmpbZm5BdHRyXTtcblxuICAgICAgICBpZiAoIWZuKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb3JpZ2luRm4gPSBmbltPUklHSU5fTUVUSE9EXSB8fCBmbjtcbiAgICAgICAgdmFyIGxhc3RUaHJvdHRsZVR5cGUgPSBmbltUSFJPVFRMRV9UWVBFXTtcbiAgICAgICAgdmFyIGxhc3RSYXRlID0gZm5bUkFURV07XG5cbiAgICAgICAgaWYgKGxhc3RSYXRlICE9PSByYXRlIHx8IGxhc3RUaHJvdHRsZVR5cGUgIT09IHRocm90dGxlVHlwZSkge1xuICAgICAgICAgICAgaWYgKHJhdGUgPT0gbnVsbCB8fCAhdGhyb3R0bGVUeXBlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChvYmpbZm5BdHRyXSA9IG9yaWdpbkZuKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm4gPSBvYmpbZm5BdHRyXSA9IGxpYi50aHJvdHRsZShcbiAgICAgICAgICAgICAgICBvcmlnaW5GbiwgcmF0ZSwgdGhyb3R0bGVUeXBlID09PSAnZGVib3VuY2UnXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZm5bT1JJR0lOX01FVEhPRF0gPSBvcmlnaW5GbjtcbiAgICAgICAgICAgIGZuW1RIUk9UVExFX1RZUEVdID0gdGhyb3R0bGVUeXBlO1xuICAgICAgICAgICAgZm5bUkFURV0gPSByYXRlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZuO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDbGVhciB0aHJvdHRsZS4gRXhhbXBsZSBzZWUgdGhyb3R0bGUuY3JlYXRlT3JVcGRhdGUuXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9ialxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmbkF0dHJcbiAgICAgKi9cbiAgICBsaWIuY2xlYXIgPSBmdW5jdGlvbiAob2JqLCBmbkF0dHIpIHtcbiAgICAgICAgdmFyIGZuID0gb2JqW2ZuQXR0cl07XG4gICAgICAgIGlmIChmbiAmJiBmbltPUklHSU5fTUVUSE9EXSkge1xuICAgICAgICAgICAgb2JqW2ZuQXR0cl0gPSBmbltPUklHSU5fTUVUSE9EXTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGxpYjtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvdXRpbC90aHJvdHRsZS5qc1xuLy8gbW9kdWxlIGlkID0gMzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 39 */
/* unknown exports provided */
/* all exports used */
/*!*******************************************!*\
  !*** ./lib/component/axis/AxisBuilder.js ***!
  \*******************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 0);\n    var formatUtil = __webpack_require__(/*! ../../util/format */ 6);\n    var graphic = __webpack_require__(/*! ../../util/graphic */ 2);\n    var Model = __webpack_require__(/*! ../../model/Model */ 9);\n    var numberUtil = __webpack_require__(/*! ../../util/number */ 3);\n    var remRadian = numberUtil.remRadian;\n    var isRadianAroundZero = numberUtil.isRadianAroundZero;\n    var vec2 = __webpack_require__(/*! zrender/lib/core/vector */ 4);\n    var matrix = __webpack_require__(/*! zrender/lib/core/matrix */ 18);\n    var v2ApplyTransform = vec2.applyTransform;\n    var retrieve = zrUtil.retrieve;\n\n    var PI = Math.PI;\n\n    function makeAxisEventDataBase(axisModel) {\n        var eventData = {\n            componentType: axisModel.mainType\n        };\n        eventData[axisModel.mainType + 'Index'] = axisModel.componentIndex;\n        return eventData;\n    }\n\n    /**\n     * A final axis is translated and rotated from a \"standard axis\".\n     * So opt.position and opt.rotation is required.\n     *\n     * A standard axis is and axis from [0, 0] to [0, axisExtent[1]],\n     * for example: (0, 0) ------------> (0, 50)\n     *\n     * nameDirection or tickDirection or labelDirection is 1 means tick\n     * or label is below the standard axis, whereas is -1 means above\n     * the standard axis. labelOffset means offset between label and axis,\n     * which is useful when 'onZero', where axisLabel is in the grid and\n     * label in outside grid.\n     *\n     * Tips: like always,\n     * positive rotation represents anticlockwise, and negative rotation\n     * represents clockwise.\n     * The direction of position coordinate is the same as the direction\n     * of screen coordinate.\n     *\n     * Do not need to consider axis 'inverse', which is auto processed by\n     * axis extent.\n     *\n     * @param {module:zrender/container/Group} group\n     * @param {Object} axisModel\n     * @param {Object} opt Standard axis parameters.\n     * @param {Array.<number>} opt.position [x, y]\n     * @param {number} opt.rotation by radian\n     * @param {number} [opt.nameDirection=1] 1 or -1 Used when nameLocation is 'middle'.\n     * @param {number} [opt.tickDirection=1] 1 or -1\n     * @param {number} [opt.labelDirection=1] 1 or -1\n     * @param {number} [opt.labelOffset=0] Usefull when onZero.\n     * @param {string} [opt.axisLabelShow] default get from axisModel.\n     * @param {string} [opt.axisName] default get from axisModel.\n     * @param {number} [opt.axisNameAvailableWidth]\n     * @param {number} [opt.labelRotate] by degree, default get from axisModel.\n     * @param {number} [opt.labelInterval] Default label interval when label\n     *                                     interval from model is null or 'auto'.\n     * @param {number} [opt.strokeContainThreshold] Default label interval when label\n     * @param {number} [opt.nameTruncateMaxWidth]\n     */\n    var AxisBuilder = function (axisModel, opt) {\n\n        /**\n         * @readOnly\n         */\n        this.opt = opt;\n\n        /**\n         * @readOnly\n         */\n        this.axisModel = axisModel;\n\n        // Default value\n        zrUtil.defaults(\n            opt,\n            {\n                labelOffset: 0,\n                nameDirection: 1,\n                tickDirection: 1,\n                labelDirection: 1,\n                silent: true\n            }\n        );\n\n        /**\n         * @readOnly\n         */\n        this.group = new graphic.Group();\n\n        // FIXME Not use a seperate text group?\n        var dumbGroup = new graphic.Group({\n            position: opt.position.slice(),\n            rotation: opt.rotation\n        });\n\n        // this.group.add(dumbGroup);\n        // this._dumbGroup = dumbGroup;\n\n        dumbGroup.updateTransform();\n        this._transform = dumbGroup.transform;\n\n        this._dumbGroup = dumbGroup;\n    };\n\n    AxisBuilder.prototype = {\n\n        constructor: AxisBuilder,\n\n        hasBuilder: function (name) {\n            return !!builders[name];\n        },\n\n        add: function (name) {\n            builders[name].call(this);\n        },\n\n        getGroup: function () {\n            return this.group;\n        }\n\n    };\n\n    var builders = {\n\n        /**\n         * @private\n         */\n        axisLine: function () {\n            var opt = this.opt;\n            var axisModel = this.axisModel;\n\n            if (!axisModel.get('axisLine.show')) {\n                return;\n            }\n\n            var extent = this.axisModel.axis.getExtent();\n\n            var matrix = this._transform;\n            var pt1 = [extent[0], 0];\n            var pt2 = [extent[1], 0];\n            if (matrix) {\n                v2ApplyTransform(pt1, pt1, matrix);\n                v2ApplyTransform(pt2, pt2, matrix);\n            }\n\n            this.group.add(new graphic.Line(graphic.subPixelOptimizeLine({\n\n                // Id for animation\n                anid: 'line',\n\n                shape: {\n                    x1: pt1[0],\n                    y1: pt1[1],\n                    x2: pt2[0],\n                    y2: pt2[1]\n                },\n                style: zrUtil.extend(\n                    {lineCap: 'round'},\n                    axisModel.getModel('axisLine.lineStyle').getLineStyle()\n                ),\n                strokeContainThreshold: opt.strokeContainThreshold || 5,\n                silent: true,\n                z2: 1\n            })));\n        },\n\n        /**\n         * @private\n         */\n        axisTick: function () {\n            var axisModel = this.axisModel;\n            var axis = axisModel.axis;\n\n            if (!axisModel.get('axisTick.show') || axis.scale.isBlank()) {\n                return;\n            }\n\n            var tickModel = axisModel.getModel('axisTick');\n            var opt = this.opt;\n\n            var lineStyleModel = tickModel.getModel('lineStyle');\n            var tickLen = tickModel.get('length');\n\n            var tickInterval = getInterval(tickModel, opt.labelInterval);\n            var ticksCoords = axis.getTicksCoords(tickModel.get('alignWithLabel'));\n            var ticks = axis.scale.getTicks();\n\n            var pt1 = [];\n            var pt2 = [];\n            var matrix = this._transform;\n\n            for (var i = 0; i < ticksCoords.length; i++) {\n                // Only ordinal scale support tick interval\n                if (ifIgnoreOnTick(axis, i, tickInterval)) {\n                     continue;\n                }\n\n                var tickCoord = ticksCoords[i];\n\n                pt1[0] = tickCoord;\n                pt1[1] = 0;\n                pt2[0] = tickCoord;\n                pt2[1] = opt.tickDirection * tickLen;\n\n                if (matrix) {\n                    v2ApplyTransform(pt1, pt1, matrix);\n                    v2ApplyTransform(pt2, pt2, matrix);\n                }\n                // Tick line, Not use group transform to have better line draw\n                this.group.add(new graphic.Line(graphic.subPixelOptimizeLine({\n\n                    // Id for animation\n                    anid: 'tick_' + ticks[i],\n\n                    shape: {\n                        x1: pt1[0],\n                        y1: pt1[1],\n                        x2: pt2[0],\n                        y2: pt2[1]\n                    },\n                    style: zrUtil.defaults(\n                        lineStyleModel.getLineStyle(),\n                        {\n                            stroke: axisModel.get('axisLine.lineStyle.color')\n                        }\n                    ),\n                    z2: 2,\n                    silent: true\n                })));\n            }\n        },\n\n        /**\n         * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n         * @param {module:echarts/coord/cartesian/GridModel} gridModel\n         * @private\n         */\n        axisLabel: function () {\n            var opt = this.opt;\n            var axisModel = this.axisModel;\n            var axis = axisModel.axis;\n            var show = retrieve(opt.axisLabelShow, axisModel.get('axisLabel.show'));\n\n            if (!show || axis.scale.isBlank()) {\n                return;\n            }\n\n            var labelModel = axisModel.getModel('axisLabel');\n            var textStyleModel = labelModel.getModel('textStyle');\n            var labelMargin = labelModel.get('margin');\n            var ticks = axis.scale.getTicks();\n            var labels = axisModel.getFormattedLabels();\n\n            // Special label rotate.\n            var labelRotation = (\n                retrieve(opt.labelRotate, labelModel.get('rotate')) || 0\n            ) * PI / 180;\n\n            var labelLayout = innerTextLayout(opt.rotation, labelRotation, opt.labelDirection);\n            var categoryData = axisModel.get('data');\n\n            var textEls = [];\n            var silent = isSilent(axisModel);\n            var triggerEvent = axisModel.get('triggerEvent');\n\n            zrUtil.each(ticks, function (tickVal, index) {\n                if (ifIgnoreOnTick(axis, index, opt.labelInterval)) {\n                     return;\n                }\n\n                var itemTextStyleModel = textStyleModel;\n                if (categoryData && categoryData[tickVal] && categoryData[tickVal].textStyle) {\n                    itemTextStyleModel = new Model(\n                        categoryData[tickVal].textStyle, textStyleModel, axisModel.ecModel\n                    );\n                }\n                var textColor = itemTextStyleModel.getTextColor()\n                    || axisModel.get('axisLine.lineStyle.color');\n\n                var tickCoord = axis.dataToCoord(tickVal);\n                var pos = [\n                    tickCoord,\n                    opt.labelOffset + opt.labelDirection * labelMargin\n                ];\n                var labelStr = axis.scale.getLabel(tickVal);\n\n                var textEl = new graphic.Text({\n\n                    // Id for animation\n                    anid: 'label_' + tickVal,\n\n                    style: {\n                        text: labels[index],\n                        textAlign: itemTextStyleModel.get('align', true) || labelLayout.textAlign,\n                        textVerticalAlign: itemTextStyleModel.get('baseline', true) || labelLayout.textVerticalAlign,\n                        textFont: itemTextStyleModel.getFont(),\n                        fill: typeof textColor === 'function'\n                            ? textColor(\n                                // (1) In category axis with data zoom, tick is not the original\n                                // index of axis.data. So tick should not be exposed to user\n                                // in category axis.\n                                // (2) Compatible with previous version, which always returns labelStr.\n                                // But in interval scale labelStr is like '223,445', which maked\n                                // user repalce ','. So we modify it to return original val but remain\n                                // it as 'string' to avoid error in replacing.\n                                axis.type === 'category' ? labelStr : axis.type === 'value' ? tickVal + '' : tickVal,\n                                index\n                            )\n                            : textColor\n                    },\n                    position: pos,\n                    rotation: labelLayout.rotation,\n                    silent: silent,\n                    z2: 10\n                });\n\n                // Pack data for mouse event\n                if (triggerEvent) {\n                    textEl.eventData = makeAxisEventDataBase(axisModel);\n                    textEl.eventData.targetType = 'axisLabel';\n                    textEl.eventData.value = labelStr;\n                }\n\n                // FIXME\n                this._dumbGroup.add(textEl);\n                textEl.updateTransform();\n\n                textEls.push(textEl);\n                this.group.add(textEl);\n\n                textEl.decomposeTransform();\n\n            }, this);\n\n            fixMinMaxLabelShow(axisModel, textEls);\n        },\n\n        /**\n         * @private\n         */\n        axisName: function () {\n            var opt = this.opt;\n            var axisModel = this.axisModel;\n            var name = retrieve(opt.axisName, axisModel.get('name'));\n\n            if (!name) {\n                return;\n            }\n\n            var nameLocation = axisModel.get('nameLocation');\n            var nameDirection = opt.nameDirection;\n            var textStyleModel = axisModel.getModel('nameTextStyle');\n            var gap = axisModel.get('nameGap') || 0;\n\n            var extent = this.axisModel.axis.getExtent();\n            var gapSignal = extent[0] > extent[1] ? -1 : 1;\n            var pos = [\n                nameLocation === 'start'\n                    ? extent[0] - gapSignal * gap\n                    : nameLocation === 'end'\n                    ? extent[1] + gapSignal * gap\n                    : (extent[0] + extent[1]) / 2, // 'middle'\n                // Reuse labelOffset.\n                nameLocation === 'middle' ? opt.labelOffset + nameDirection * gap : 0\n            ];\n\n            var labelLayout;\n\n            var nameRotation = axisModel.get('nameRotate');\n            if (nameRotation != null) {\n                nameRotation = nameRotation * PI / 180; // To radian.\n            }\n\n            var axisNameAvailableWidth;\n\n            if (nameLocation === 'middle') {\n                labelLayout = innerTextLayout(\n                    opt.rotation,\n                    nameRotation != null ? nameRotation : opt.rotation, // Adapt to axis.\n                    nameDirection\n                );\n            }\n            else {\n                labelLayout = endTextLayout(\n                    opt, nameLocation, nameRotation || 0, extent\n                );\n\n                axisNameAvailableWidth = opt.axisNameAvailableWidth;\n                if (axisNameAvailableWidth != null) {\n                    axisNameAvailableWidth = Math.abs(\n                        axisNameAvailableWidth / Math.sin(labelLayout.rotation)\n                    );\n                    !isFinite(axisNameAvailableWidth) && (axisNameAvailableWidth = null);\n                }\n            }\n\n            var textFont = textStyleModel.getFont();\n\n            var truncateOpt = axisModel.get('nameTruncate', true) || {};\n            var ellipsis = truncateOpt.ellipsis;\n            var maxWidth = retrieve(\n                opt.nameTruncateMaxWidth, truncateOpt.maxWidth, axisNameAvailableWidth\n            );\n            var truncatedText = (ellipsis != null && maxWidth != null)\n                ? formatUtil.truncateText(\n                    name, maxWidth, textFont, ellipsis,\n                    {minChar: 2, placeholder: truncateOpt.placeholder}\n                )\n                : name;\n\n            var tooltipOpt = axisModel.get('tooltip', true);\n\n            var mainType = axisModel.mainType;\n            var formatterParams = {\n                componentType: mainType,\n                name: name,\n                $vars: ['name']\n            };\n            formatterParams[mainType + 'Index'] = axisModel.componentIndex;\n\n            var textEl = new graphic.Text({\n\n                // Id for animation\n                anid: 'name',\n\n                __fullText: name,\n                __truncatedText: truncatedText,\n\n                style: {\n                    text: truncatedText,\n                    textFont: textFont,\n                    fill: textStyleModel.getTextColor()\n                        || axisModel.get('axisLine.lineStyle.color'),\n                    textAlign: labelLayout.textAlign,\n                    textVerticalAlign: labelLayout.textVerticalAlign\n                },\n                position: pos,\n                rotation: labelLayout.rotation,\n                silent: isSilent(axisModel),\n                z2: 1,\n                tooltip: (tooltipOpt && tooltipOpt.show)\n                    ? zrUtil.extend({\n                        content: name,\n                        formatter: function () {\n                            return name;\n                        },\n                        formatterParams: formatterParams\n                    }, tooltipOpt)\n                    : null\n            });\n\n            if (axisModel.get('triggerEvent')) {\n                textEl.eventData = makeAxisEventDataBase(axisModel);\n                textEl.eventData.targetType = 'axisName';\n                textEl.eventData.name = name;\n            }\n\n            // FIXME\n            this._dumbGroup.add(textEl);\n            textEl.updateTransform();\n\n            this.group.add(textEl);\n\n            textEl.decomposeTransform();\n        }\n\n    };\n\n    /**\n     * @public\n     * @static\n     * @param {Object} opt\n     * @param {number} axisRotation in radian\n     * @param {number} textRotation in radian\n     * @param {number} direction\n     * @return {Object} {\n     *  rotation, // according to axis\n     *  textAlign,\n     *  textVerticalAlign\n     * }\n     */\n    var innerTextLayout = AxisBuilder.innerTextLayout = function (axisRotation, textRotation, direction) {\n        var rotationDiff = remRadian(textRotation - axisRotation);\n        var textAlign;\n        var textVerticalAlign;\n\n        if (isRadianAroundZero(rotationDiff)) { // Label is parallel with axis line.\n            textVerticalAlign = direction > 0 ? 'top' : 'bottom';\n            textAlign = 'center';\n        }\n        else if (isRadianAroundZero(rotationDiff - PI)) { // Label is inverse parallel with axis line.\n            textVerticalAlign = direction > 0 ? 'bottom' : 'top';\n            textAlign = 'center';\n        }\n        else {\n            textVerticalAlign = 'middle';\n\n            if (rotationDiff > 0 && rotationDiff < PI) {\n                textAlign = direction > 0 ? 'right' : 'left';\n            }\n            else {\n                textAlign = direction > 0 ? 'left' : 'right';\n            }\n        }\n\n        return {\n            rotation: rotationDiff,\n            textAlign: textAlign,\n            textVerticalAlign: textVerticalAlign\n        };\n    };\n\n    function endTextLayout(opt, textPosition, textRotate, extent) {\n        var rotationDiff = remRadian(textRotate - opt.rotation);\n        var textAlign;\n        var textVerticalAlign;\n        var inverse = extent[0] > extent[1];\n        var onLeft = (textPosition === 'start' && !inverse)\n            || (textPosition !== 'start' && inverse);\n\n        if (isRadianAroundZero(rotationDiff - PI / 2)) {\n            textVerticalAlign = onLeft ? 'bottom' : 'top';\n            textAlign = 'center';\n        }\n        else if (isRadianAroundZero(rotationDiff - PI * 1.5)) {\n            textVerticalAlign = onLeft ? 'top' : 'bottom';\n            textAlign = 'center';\n        }\n        else {\n            textVerticalAlign = 'middle';\n            if (rotationDiff < PI * 1.5 && rotationDiff > PI / 2) {\n                textAlign = onLeft ? 'left' : 'right';\n            }\n            else {\n                textAlign = onLeft ? 'right' : 'left';\n            }\n        }\n\n        return {\n            rotation: rotationDiff,\n            textAlign: textAlign,\n            textVerticalAlign: textVerticalAlign\n        };\n    }\n\n    function isSilent(axisModel) {\n        var tooltipOpt = axisModel.get('tooltip');\n        return axisModel.get('silent')\n            // Consider mouse cursor, add these restrictions.\n            || !(\n                axisModel.get('triggerEvent') || (tooltipOpt && tooltipOpt.show)\n            );\n    }\n\n    function fixMinMaxLabelShow(axisModel, textEls) {\n        // If min or max are user set, we need to check\n        // If the tick on min(max) are overlap on their neighbour tick\n        // If they are overlapped, we need to hide the min(max) tick label\n        var showMinLabel = axisModel.get('axisLabel.showMinLabel');\n        var showMaxLabel = axisModel.get('axisLabel.showMaxLabel');\n        var firstLabel = textEls[0];\n        var nextLabel = textEls[1];\n        var lastLabel = textEls[textEls.length - 1];\n        var prevLabel = textEls[textEls.length - 2];\n\n        if (showMinLabel === false) {\n            firstLabel.ignore = true;\n        }\n        else if (axisModel.getMin() != null && isTwoLabelOverlapped(firstLabel, nextLabel)) {\n            showMinLabel ? (nextLabel.ignore = true) : (firstLabel.ignore = true);\n        }\n\n        if (showMaxLabel === false) {\n            lastLabel.ignore = true;\n        }\n        else if (axisModel.getMax() != null && isTwoLabelOverlapped(prevLabel, lastLabel)) {\n            showMaxLabel ? (prevLabel.ignore = true) : (lastLabel.ignore = true);\n        }\n    }\n\n    function isTwoLabelOverlapped(current, next, labelLayout) {\n        // current and next has the same rotation.\n        var firstRect = current && current.getBoundingRect().clone();\n        var nextRect = next && next.getBoundingRect().clone();\n\n        if (!firstRect || !nextRect) {\n            return;\n        }\n\n        // When checking intersect of two rotated labels, we use mRotationBack\n        // to avoid that boundingRect is enlarge when using `boundingRect.applyTransform`.\n        var mRotationBack = matrix.identity([]);\n        matrix.rotate(mRotationBack, mRotationBack, -current.rotation);\n\n        firstRect.applyTransform(matrix.mul([], mRotationBack, current.getLocalTransform()));\n        nextRect.applyTransform(matrix.mul([], mRotationBack, next.getLocalTransform()));\n\n        return firstRect.intersect(nextRect);\n    }\n\n\n    /**\n     * @static\n     */\n    var ifIgnoreOnTick = AxisBuilder.ifIgnoreOnTick = function (axis, i, interval) {\n        var rawTick;\n        var scale = axis.scale;\n        return scale.type === 'ordinal'\n            && (\n                typeof interval === 'function'\n                    ? (\n                        rawTick = scale.getTicks()[i],\n                        !interval(rawTick, scale.getLabel(rawTick))\n                    )\n                    : i % (interval + 1)\n            );\n    };\n\n    /**\n     * @static\n     */\n    var getInterval = AxisBuilder.getInterval = function (model, labelInterval) {\n        var interval = model.get('interval');\n        if (interval == null || interval == 'auto') {\n            interval = labelInterval;\n        }\n        return interval;\n    };\n\n    module.exports = AxisBuilder;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvY29tcG9uZW50L2F4aXMvQXhpc0J1aWxkZXIuanM/MGExMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgZm9ybWF0VXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvZm9ybWF0Jyk7XG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKCcuLi8uLi91dGlsL2dyYXBoaWMnKTtcbiAgICB2YXIgTW9kZWwgPSByZXF1aXJlKCcuLi8uLi9tb2RlbC9Nb2RlbCcpO1xuICAgIHZhciBudW1iZXJVdGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9udW1iZXInKTtcbiAgICB2YXIgcmVtUmFkaWFuID0gbnVtYmVyVXRpbC5yZW1SYWRpYW47XG4gICAgdmFyIGlzUmFkaWFuQXJvdW5kWmVybyA9IG51bWJlclV0aWwuaXNSYWRpYW5Bcm91bmRaZXJvO1xuICAgIHZhciB2ZWMyID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS92ZWN0b3InKTtcbiAgICB2YXIgbWF0cml4ID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS9tYXRyaXgnKTtcbiAgICB2YXIgdjJBcHBseVRyYW5zZm9ybSA9IHZlYzIuYXBwbHlUcmFuc2Zvcm07XG4gICAgdmFyIHJldHJpZXZlID0genJVdGlsLnJldHJpZXZlO1xuXG4gICAgdmFyIFBJID0gTWF0aC5QSTtcblxuICAgIGZ1bmN0aW9uIG1ha2VBeGlzRXZlbnREYXRhQmFzZShheGlzTW9kZWwpIHtcbiAgICAgICAgdmFyIGV2ZW50RGF0YSA9IHtcbiAgICAgICAgICAgIGNvbXBvbmVudFR5cGU6IGF4aXNNb2RlbC5tYWluVHlwZVxuICAgICAgICB9O1xuICAgICAgICBldmVudERhdGFbYXhpc01vZGVsLm1haW5UeXBlICsgJ0luZGV4J10gPSBheGlzTW9kZWwuY29tcG9uZW50SW5kZXg7XG4gICAgICAgIHJldHVybiBldmVudERhdGE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBmaW5hbCBheGlzIGlzIHRyYW5zbGF0ZWQgYW5kIHJvdGF0ZWQgZnJvbSBhIFwic3RhbmRhcmQgYXhpc1wiLlxuICAgICAqIFNvIG9wdC5wb3NpdGlvbiBhbmQgb3B0LnJvdGF0aW9uIGlzIHJlcXVpcmVkLlxuICAgICAqXG4gICAgICogQSBzdGFuZGFyZCBheGlzIGlzIGFuZCBheGlzIGZyb20gWzAsIDBdIHRvIFswLCBheGlzRXh0ZW50WzFdXSxcbiAgICAgKiBmb3IgZXhhbXBsZTogKDAsIDApIC0tLS0tLS0tLS0tLT4gKDAsIDUwKVxuICAgICAqXG4gICAgICogbmFtZURpcmVjdGlvbiBvciB0aWNrRGlyZWN0aW9uIG9yIGxhYmVsRGlyZWN0aW9uIGlzIDEgbWVhbnMgdGlja1xuICAgICAqIG9yIGxhYmVsIGlzIGJlbG93IHRoZSBzdGFuZGFyZCBheGlzLCB3aGVyZWFzIGlzIC0xIG1lYW5zIGFib3ZlXG4gICAgICogdGhlIHN0YW5kYXJkIGF4aXMuIGxhYmVsT2Zmc2V0IG1lYW5zIG9mZnNldCBiZXR3ZWVuIGxhYmVsIGFuZCBheGlzLFxuICAgICAqIHdoaWNoIGlzIHVzZWZ1bCB3aGVuICdvblplcm8nLCB3aGVyZSBheGlzTGFiZWwgaXMgaW4gdGhlIGdyaWQgYW5kXG4gICAgICogbGFiZWwgaW4gb3V0c2lkZSBncmlkLlxuICAgICAqXG4gICAgICogVGlwczogbGlrZSBhbHdheXMsXG4gICAgICogcG9zaXRpdmUgcm90YXRpb24gcmVwcmVzZW50cyBhbnRpY2xvY2t3aXNlLCBhbmQgbmVnYXRpdmUgcm90YXRpb25cbiAgICAgKiByZXByZXNlbnRzIGNsb2Nrd2lzZS5cbiAgICAgKiBUaGUgZGlyZWN0aW9uIG9mIHBvc2l0aW9uIGNvb3JkaW5hdGUgaXMgdGhlIHNhbWUgYXMgdGhlIGRpcmVjdGlvblxuICAgICAqIG9mIHNjcmVlbiBjb29yZGluYXRlLlxuICAgICAqXG4gICAgICogRG8gbm90IG5lZWQgdG8gY29uc2lkZXIgYXhpcyAnaW52ZXJzZScsIHdoaWNoIGlzIGF1dG8gcHJvY2Vzc2VkIGJ5XG4gICAgICogYXhpcyBleHRlbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2NvbnRhaW5lci9Hcm91cH0gZ3JvdXBcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXhpc01vZGVsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdCBTdGFuZGFyZCBheGlzIHBhcmFtZXRlcnMuXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gb3B0LnBvc2l0aW9uIFt4LCB5XVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvcHQucm90YXRpb24gYnkgcmFkaWFuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHQubmFtZURpcmVjdGlvbj0xXSAxIG9yIC0xIFVzZWQgd2hlbiBuYW1lTG9jYXRpb24gaXMgJ21pZGRsZScuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHQudGlja0RpcmVjdGlvbj0xXSAxIG9yIC0xXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHQubGFiZWxEaXJlY3Rpb249MV0gMSBvciAtMVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0LmxhYmVsT2Zmc2V0PTBdIFVzZWZ1bGwgd2hlbiBvblplcm8uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHQuYXhpc0xhYmVsU2hvd10gZGVmYXVsdCBnZXQgZnJvbSBheGlzTW9kZWwuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHQuYXhpc05hbWVdIGRlZmF1bHQgZ2V0IGZyb20gYXhpc01vZGVsLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0LmF4aXNOYW1lQXZhaWxhYmxlV2lkdGhdXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHQubGFiZWxSb3RhdGVdIGJ5IGRlZ3JlZSwgZGVmYXVsdCBnZXQgZnJvbSBheGlzTW9kZWwuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHQubGFiZWxJbnRlcnZhbF0gRGVmYXVsdCBsYWJlbCBpbnRlcnZhbCB3aGVuIGxhYmVsXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJ2YWwgZnJvbSBtb2RlbCBpcyBudWxsIG9yICdhdXRvJy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdC5zdHJva2VDb250YWluVGhyZXNob2xkXSBEZWZhdWx0IGxhYmVsIGludGVydmFsIHdoZW4gbGFiZWxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdC5uYW1lVHJ1bmNhdGVNYXhXaWR0aF1cbiAgICAgKi9cbiAgICB2YXIgQXhpc0J1aWxkZXIgPSBmdW5jdGlvbiAoYXhpc01vZGVsLCBvcHQpIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJlYWRPbmx5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9wdCA9IG9wdDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJlYWRPbmx5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmF4aXNNb2RlbCA9IGF4aXNNb2RlbDtcblxuICAgICAgICAvLyBEZWZhdWx0IHZhbHVlXG4gICAgICAgIHpyVXRpbC5kZWZhdWx0cyhcbiAgICAgICAgICAgIG9wdCxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBsYWJlbE9mZnNldDogMCxcbiAgICAgICAgICAgICAgICBuYW1lRGlyZWN0aW9uOiAxLFxuICAgICAgICAgICAgICAgIHRpY2tEaXJlY3Rpb246IDEsXG4gICAgICAgICAgICAgICAgbGFiZWxEaXJlY3Rpb246IDEsXG4gICAgICAgICAgICAgICAgc2lsZW50OiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZWFkT25seVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ncm91cCA9IG5ldyBncmFwaGljLkdyb3VwKCk7XG5cbiAgICAgICAgLy8gRklYTUUgTm90IHVzZSBhIHNlcGVyYXRlIHRleHQgZ3JvdXA/XG4gICAgICAgIHZhciBkdW1iR3JvdXAgPSBuZXcgZ3JhcGhpYy5Hcm91cCh7XG4gICAgICAgICAgICBwb3NpdGlvbjogb3B0LnBvc2l0aW9uLnNsaWNlKCksXG4gICAgICAgICAgICByb3RhdGlvbjogb3B0LnJvdGF0aW9uXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHRoaXMuZ3JvdXAuYWRkKGR1bWJHcm91cCk7XG4gICAgICAgIC8vIHRoaXMuX2R1bWJHcm91cCA9IGR1bWJHcm91cDtcblxuICAgICAgICBkdW1iR3JvdXAudXBkYXRlVHJhbnNmb3JtKCk7XG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybSA9IGR1bWJHcm91cC50cmFuc2Zvcm07XG5cbiAgICAgICAgdGhpcy5fZHVtYkdyb3VwID0gZHVtYkdyb3VwO1xuICAgIH07XG5cbiAgICBBeGlzQnVpbGRlci5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IEF4aXNCdWlsZGVyLFxuXG4gICAgICAgIGhhc0J1aWxkZXI6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gISFidWlsZGVyc1tuYW1lXTtcbiAgICAgICAgfSxcblxuICAgICAgICBhZGQ6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICBidWlsZGVyc1tuYW1lXS5jYWxsKHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldEdyb3VwOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ncm91cDtcbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIHZhciBidWlsZGVycyA9IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIGF4aXNMaW5lOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb3B0ID0gdGhpcy5vcHQ7XG4gICAgICAgICAgICB2YXIgYXhpc01vZGVsID0gdGhpcy5heGlzTW9kZWw7XG5cbiAgICAgICAgICAgIGlmICghYXhpc01vZGVsLmdldCgnYXhpc0xpbmUuc2hvdycpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZXh0ZW50ID0gdGhpcy5heGlzTW9kZWwuYXhpcy5nZXRFeHRlbnQoKTtcblxuICAgICAgICAgICAgdmFyIG1hdHJpeCA9IHRoaXMuX3RyYW5zZm9ybTtcbiAgICAgICAgICAgIHZhciBwdDEgPSBbZXh0ZW50WzBdLCAwXTtcbiAgICAgICAgICAgIHZhciBwdDIgPSBbZXh0ZW50WzFdLCAwXTtcbiAgICAgICAgICAgIGlmIChtYXRyaXgpIHtcbiAgICAgICAgICAgICAgICB2MkFwcGx5VHJhbnNmb3JtKHB0MSwgcHQxLCBtYXRyaXgpO1xuICAgICAgICAgICAgICAgIHYyQXBwbHlUcmFuc2Zvcm0ocHQyLCBwdDIsIG1hdHJpeCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuZ3JvdXAuYWRkKG5ldyBncmFwaGljLkxpbmUoZ3JhcGhpYy5zdWJQaXhlbE9wdGltaXplTGluZSh7XG5cbiAgICAgICAgICAgICAgICAvLyBJZCBmb3IgYW5pbWF0aW9uXG4gICAgICAgICAgICAgICAgYW5pZDogJ2xpbmUnLFxuXG4gICAgICAgICAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgICAgICAgICAgeDE6IHB0MVswXSxcbiAgICAgICAgICAgICAgICAgICAgeTE6IHB0MVsxXSxcbiAgICAgICAgICAgICAgICAgICAgeDI6IHB0MlswXSxcbiAgICAgICAgICAgICAgICAgICAgeTI6IHB0MlsxXVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc3R5bGU6IHpyVXRpbC5leHRlbmQoXG4gICAgICAgICAgICAgICAgICAgIHtsaW5lQ2FwOiAncm91bmQnfSxcbiAgICAgICAgICAgICAgICAgICAgYXhpc01vZGVsLmdldE1vZGVsKCdheGlzTGluZS5saW5lU3R5bGUnKS5nZXRMaW5lU3R5bGUoKVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgc3Ryb2tlQ29udGFpblRocmVzaG9sZDogb3B0LnN0cm9rZUNvbnRhaW5UaHJlc2hvbGQgfHwgNSxcbiAgICAgICAgICAgICAgICBzaWxlbnQ6IHRydWUsXG4gICAgICAgICAgICAgICAgejI6IDFcbiAgICAgICAgICAgIH0pKSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBheGlzVGljazogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGF4aXNNb2RlbCA9IHRoaXMuYXhpc01vZGVsO1xuICAgICAgICAgICAgdmFyIGF4aXMgPSBheGlzTW9kZWwuYXhpcztcblxuICAgICAgICAgICAgaWYgKCFheGlzTW9kZWwuZ2V0KCdheGlzVGljay5zaG93JykgfHwgYXhpcy5zY2FsZS5pc0JsYW5rKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB0aWNrTW9kZWwgPSBheGlzTW9kZWwuZ2V0TW9kZWwoJ2F4aXNUaWNrJyk7XG4gICAgICAgICAgICB2YXIgb3B0ID0gdGhpcy5vcHQ7XG5cbiAgICAgICAgICAgIHZhciBsaW5lU3R5bGVNb2RlbCA9IHRpY2tNb2RlbC5nZXRNb2RlbCgnbGluZVN0eWxlJyk7XG4gICAgICAgICAgICB2YXIgdGlja0xlbiA9IHRpY2tNb2RlbC5nZXQoJ2xlbmd0aCcpO1xuXG4gICAgICAgICAgICB2YXIgdGlja0ludGVydmFsID0gZ2V0SW50ZXJ2YWwodGlja01vZGVsLCBvcHQubGFiZWxJbnRlcnZhbCk7XG4gICAgICAgICAgICB2YXIgdGlja3NDb29yZHMgPSBheGlzLmdldFRpY2tzQ29vcmRzKHRpY2tNb2RlbC5nZXQoJ2FsaWduV2l0aExhYmVsJykpO1xuICAgICAgICAgICAgdmFyIHRpY2tzID0gYXhpcy5zY2FsZS5nZXRUaWNrcygpO1xuXG4gICAgICAgICAgICB2YXIgcHQxID0gW107XG4gICAgICAgICAgICB2YXIgcHQyID0gW107XG4gICAgICAgICAgICB2YXIgbWF0cml4ID0gdGhpcy5fdHJhbnNmb3JtO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRpY2tzQ29vcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgLy8gT25seSBvcmRpbmFsIHNjYWxlIHN1cHBvcnQgdGljayBpbnRlcnZhbFxuICAgICAgICAgICAgICAgIGlmIChpZklnbm9yZU9uVGljayhheGlzLCBpLCB0aWNrSW50ZXJ2YWwpKSB7XG4gICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgdGlja0Nvb3JkID0gdGlja3NDb29yZHNbaV07XG5cbiAgICAgICAgICAgICAgICBwdDFbMF0gPSB0aWNrQ29vcmQ7XG4gICAgICAgICAgICAgICAgcHQxWzFdID0gMDtcbiAgICAgICAgICAgICAgICBwdDJbMF0gPSB0aWNrQ29vcmQ7XG4gICAgICAgICAgICAgICAgcHQyWzFdID0gb3B0LnRpY2tEaXJlY3Rpb24gKiB0aWNrTGVuO1xuXG4gICAgICAgICAgICAgICAgaWYgKG1hdHJpeCkge1xuICAgICAgICAgICAgICAgICAgICB2MkFwcGx5VHJhbnNmb3JtKHB0MSwgcHQxLCBtYXRyaXgpO1xuICAgICAgICAgICAgICAgICAgICB2MkFwcGx5VHJhbnNmb3JtKHB0MiwgcHQyLCBtYXRyaXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUaWNrIGxpbmUsIE5vdCB1c2UgZ3JvdXAgdHJhbnNmb3JtIHRvIGhhdmUgYmV0dGVyIGxpbmUgZHJhd1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXAuYWRkKG5ldyBncmFwaGljLkxpbmUoZ3JhcGhpYy5zdWJQaXhlbE9wdGltaXplTGluZSh7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWQgZm9yIGFuaW1hdGlvblxuICAgICAgICAgICAgICAgICAgICBhbmlkOiAndGlja18nICsgdGlja3NbaV0sXG5cbiAgICAgICAgICAgICAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHgxOiBwdDFbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICB5MTogcHQxWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgeDI6IHB0MlswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHkyOiBwdDJbMV1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHpyVXRpbC5kZWZhdWx0cyhcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVTdHlsZU1vZGVsLmdldExpbmVTdHlsZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZTogYXhpc01vZGVsLmdldCgnYXhpc0xpbmUubGluZVN0eWxlLmNvbG9yJylcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgejI6IDIsXG4gICAgICAgICAgICAgICAgICAgIHNpbGVudDogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvY29vcmQvY2FydGVzaWFuL0F4aXNNb2RlbH0gYXhpc01vZGVsXG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvY29vcmQvY2FydGVzaWFuL0dyaWRNb2RlbH0gZ3JpZE1vZGVsXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBheGlzTGFiZWw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvcHQgPSB0aGlzLm9wdDtcbiAgICAgICAgICAgIHZhciBheGlzTW9kZWwgPSB0aGlzLmF4aXNNb2RlbDtcbiAgICAgICAgICAgIHZhciBheGlzID0gYXhpc01vZGVsLmF4aXM7XG4gICAgICAgICAgICB2YXIgc2hvdyA9IHJldHJpZXZlKG9wdC5heGlzTGFiZWxTaG93LCBheGlzTW9kZWwuZ2V0KCdheGlzTGFiZWwuc2hvdycpKTtcblxuICAgICAgICAgICAgaWYgKCFzaG93IHx8IGF4aXMuc2NhbGUuaXNCbGFuaygpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbGFiZWxNb2RlbCA9IGF4aXNNb2RlbC5nZXRNb2RlbCgnYXhpc0xhYmVsJyk7XG4gICAgICAgICAgICB2YXIgdGV4dFN0eWxlTW9kZWwgPSBsYWJlbE1vZGVsLmdldE1vZGVsKCd0ZXh0U3R5bGUnKTtcbiAgICAgICAgICAgIHZhciBsYWJlbE1hcmdpbiA9IGxhYmVsTW9kZWwuZ2V0KCdtYXJnaW4nKTtcbiAgICAgICAgICAgIHZhciB0aWNrcyA9IGF4aXMuc2NhbGUuZ2V0VGlja3MoKTtcbiAgICAgICAgICAgIHZhciBsYWJlbHMgPSBheGlzTW9kZWwuZ2V0Rm9ybWF0dGVkTGFiZWxzKCk7XG5cbiAgICAgICAgICAgIC8vIFNwZWNpYWwgbGFiZWwgcm90YXRlLlxuICAgICAgICAgICAgdmFyIGxhYmVsUm90YXRpb24gPSAoXG4gICAgICAgICAgICAgICAgcmV0cmlldmUob3B0LmxhYmVsUm90YXRlLCBsYWJlbE1vZGVsLmdldCgncm90YXRlJykpIHx8IDBcbiAgICAgICAgICAgICkgKiBQSSAvIDE4MDtcblxuICAgICAgICAgICAgdmFyIGxhYmVsTGF5b3V0ID0gaW5uZXJUZXh0TGF5b3V0KG9wdC5yb3RhdGlvbiwgbGFiZWxSb3RhdGlvbiwgb3B0LmxhYmVsRGlyZWN0aW9uKTtcbiAgICAgICAgICAgIHZhciBjYXRlZ29yeURhdGEgPSBheGlzTW9kZWwuZ2V0KCdkYXRhJyk7XG5cbiAgICAgICAgICAgIHZhciB0ZXh0RWxzID0gW107XG4gICAgICAgICAgICB2YXIgc2lsZW50ID0gaXNTaWxlbnQoYXhpc01vZGVsKTtcbiAgICAgICAgICAgIHZhciB0cmlnZ2VyRXZlbnQgPSBheGlzTW9kZWwuZ2V0KCd0cmlnZ2VyRXZlbnQnKTtcblxuICAgICAgICAgICAgenJVdGlsLmVhY2godGlja3MsIGZ1bmN0aW9uICh0aWNrVmFsLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIGlmIChpZklnbm9yZU9uVGljayhheGlzLCBpbmRleCwgb3B0LmxhYmVsSW50ZXJ2YWwpKSB7XG4gICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGl0ZW1UZXh0U3R5bGVNb2RlbCA9IHRleHRTdHlsZU1vZGVsO1xuICAgICAgICAgICAgICAgIGlmIChjYXRlZ29yeURhdGEgJiYgY2F0ZWdvcnlEYXRhW3RpY2tWYWxdICYmIGNhdGVnb3J5RGF0YVt0aWNrVmFsXS50ZXh0U3R5bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbVRleHRTdHlsZU1vZGVsID0gbmV3IE1vZGVsKFxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0ZWdvcnlEYXRhW3RpY2tWYWxdLnRleHRTdHlsZSwgdGV4dFN0eWxlTW9kZWwsIGF4aXNNb2RlbC5lY01vZGVsXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciB0ZXh0Q29sb3IgPSBpdGVtVGV4dFN0eWxlTW9kZWwuZ2V0VGV4dENvbG9yKClcbiAgICAgICAgICAgICAgICAgICAgfHwgYXhpc01vZGVsLmdldCgnYXhpc0xpbmUubGluZVN0eWxlLmNvbG9yJyk7XG5cbiAgICAgICAgICAgICAgICB2YXIgdGlja0Nvb3JkID0gYXhpcy5kYXRhVG9Db29yZCh0aWNrVmFsKTtcbiAgICAgICAgICAgICAgICB2YXIgcG9zID0gW1xuICAgICAgICAgICAgICAgICAgICB0aWNrQ29vcmQsXG4gICAgICAgICAgICAgICAgICAgIG9wdC5sYWJlbE9mZnNldCArIG9wdC5sYWJlbERpcmVjdGlvbiAqIGxhYmVsTWFyZ2luXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICB2YXIgbGFiZWxTdHIgPSBheGlzLnNjYWxlLmdldExhYmVsKHRpY2tWYWwpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHRleHRFbCA9IG5ldyBncmFwaGljLlRleHQoe1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIElkIGZvciBhbmltYXRpb25cbiAgICAgICAgICAgICAgICAgICAgYW5pZDogJ2xhYmVsXycgKyB0aWNrVmFsLFxuXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBsYWJlbHNbaW5kZXhdLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dEFsaWduOiBpdGVtVGV4dFN0eWxlTW9kZWwuZ2V0KCdhbGlnbicsIHRydWUpIHx8IGxhYmVsTGF5b3V0LnRleHRBbGlnbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHRWZXJ0aWNhbEFsaWduOiBpdGVtVGV4dFN0eWxlTW9kZWwuZ2V0KCdiYXNlbGluZScsIHRydWUpIHx8IGxhYmVsTGF5b3V0LnRleHRWZXJ0aWNhbEFsaWduLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dEZvbnQ6IGl0ZW1UZXh0U3R5bGVNb2RlbC5nZXRGb250KCksXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxsOiB0eXBlb2YgdGV4dENvbG9yID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB0ZXh0Q29sb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICgxKSBJbiBjYXRlZ29yeSBheGlzIHdpdGggZGF0YSB6b29tLCB0aWNrIGlzIG5vdCB0aGUgb3JpZ2luYWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5kZXggb2YgYXhpcy5kYXRhLiBTbyB0aWNrIHNob3VsZCBub3QgYmUgZXhwb3NlZCB0byB1c2VyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluIGNhdGVnb3J5IGF4aXMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICgyKSBDb21wYXRpYmxlIHdpdGggcHJldmlvdXMgdmVyc2lvbiwgd2hpY2ggYWx3YXlzIHJldHVybnMgbGFiZWxTdHIuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJ1dCBpbiBpbnRlcnZhbCBzY2FsZSBsYWJlbFN0ciBpcyBsaWtlICcyMjMsNDQ1Jywgd2hpY2ggbWFrZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXNlciByZXBhbGNlICcsJy4gU28gd2UgbW9kaWZ5IGl0IHRvIHJldHVybiBvcmlnaW5hbCB2YWwgYnV0IHJlbWFpblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpdCBhcyAnc3RyaW5nJyB0byBhdm9pZCBlcnJvciBpbiByZXBsYWNpbmcuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF4aXMudHlwZSA9PT0gJ2NhdGVnb3J5JyA/IGxhYmVsU3RyIDogYXhpcy50eXBlID09PSAndmFsdWUnID8gdGlja1ZhbCArICcnIDogdGlja1ZhbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB0ZXh0Q29sb3JcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHBvcyxcbiAgICAgICAgICAgICAgICAgICAgcm90YXRpb246IGxhYmVsTGF5b3V0LnJvdGF0aW9uLFxuICAgICAgICAgICAgICAgICAgICBzaWxlbnQ6IHNpbGVudCxcbiAgICAgICAgICAgICAgICAgICAgejI6IDEwXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBQYWNrIGRhdGEgZm9yIG1vdXNlIGV2ZW50XG4gICAgICAgICAgICAgICAgaWYgKHRyaWdnZXJFdmVudCkge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0RWwuZXZlbnREYXRhID0gbWFrZUF4aXNFdmVudERhdGFCYXNlKGF4aXNNb2RlbCk7XG4gICAgICAgICAgICAgICAgICAgIHRleHRFbC5ldmVudERhdGEudGFyZ2V0VHlwZSA9ICdheGlzTGFiZWwnO1xuICAgICAgICAgICAgICAgICAgICB0ZXh0RWwuZXZlbnREYXRhLnZhbHVlID0gbGFiZWxTdHI7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gRklYTUVcbiAgICAgICAgICAgICAgICB0aGlzLl9kdW1iR3JvdXAuYWRkKHRleHRFbCk7XG4gICAgICAgICAgICAgICAgdGV4dEVsLnVwZGF0ZVRyYW5zZm9ybSgpO1xuXG4gICAgICAgICAgICAgICAgdGV4dEVscy5wdXNoKHRleHRFbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cC5hZGQodGV4dEVsKTtcblxuICAgICAgICAgICAgICAgIHRleHRFbC5kZWNvbXBvc2VUcmFuc2Zvcm0oKTtcblxuICAgICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgICAgIGZpeE1pbk1heExhYmVsU2hvdyhheGlzTW9kZWwsIHRleHRFbHMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgYXhpc05hbWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvcHQgPSB0aGlzLm9wdDtcbiAgICAgICAgICAgIHZhciBheGlzTW9kZWwgPSB0aGlzLmF4aXNNb2RlbDtcbiAgICAgICAgICAgIHZhciBuYW1lID0gcmV0cmlldmUob3B0LmF4aXNOYW1lLCBheGlzTW9kZWwuZ2V0KCduYW1lJykpO1xuXG4gICAgICAgICAgICBpZiAoIW5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBuYW1lTG9jYXRpb24gPSBheGlzTW9kZWwuZ2V0KCduYW1lTG9jYXRpb24nKTtcbiAgICAgICAgICAgIHZhciBuYW1lRGlyZWN0aW9uID0gb3B0Lm5hbWVEaXJlY3Rpb247XG4gICAgICAgICAgICB2YXIgdGV4dFN0eWxlTW9kZWwgPSBheGlzTW9kZWwuZ2V0TW9kZWwoJ25hbWVUZXh0U3R5bGUnKTtcbiAgICAgICAgICAgIHZhciBnYXAgPSBheGlzTW9kZWwuZ2V0KCduYW1lR2FwJykgfHwgMDtcblxuICAgICAgICAgICAgdmFyIGV4dGVudCA9IHRoaXMuYXhpc01vZGVsLmF4aXMuZ2V0RXh0ZW50KCk7XG4gICAgICAgICAgICB2YXIgZ2FwU2lnbmFsID0gZXh0ZW50WzBdID4gZXh0ZW50WzFdID8gLTEgOiAxO1xuICAgICAgICAgICAgdmFyIHBvcyA9IFtcbiAgICAgICAgICAgICAgICBuYW1lTG9jYXRpb24gPT09ICdzdGFydCdcbiAgICAgICAgICAgICAgICAgICAgPyBleHRlbnRbMF0gLSBnYXBTaWduYWwgKiBnYXBcbiAgICAgICAgICAgICAgICAgICAgOiBuYW1lTG9jYXRpb24gPT09ICdlbmQnXG4gICAgICAgICAgICAgICAgICAgID8gZXh0ZW50WzFdICsgZ2FwU2lnbmFsICogZ2FwXG4gICAgICAgICAgICAgICAgICAgIDogKGV4dGVudFswXSArIGV4dGVudFsxXSkgLyAyLCAvLyAnbWlkZGxlJ1xuICAgICAgICAgICAgICAgIC8vIFJldXNlIGxhYmVsT2Zmc2V0LlxuICAgICAgICAgICAgICAgIG5hbWVMb2NhdGlvbiA9PT0gJ21pZGRsZScgPyBvcHQubGFiZWxPZmZzZXQgKyBuYW1lRGlyZWN0aW9uICogZ2FwIDogMFxuICAgICAgICAgICAgXTtcblxuICAgICAgICAgICAgdmFyIGxhYmVsTGF5b3V0O1xuXG4gICAgICAgICAgICB2YXIgbmFtZVJvdGF0aW9uID0gYXhpc01vZGVsLmdldCgnbmFtZVJvdGF0ZScpO1xuICAgICAgICAgICAgaWYgKG5hbWVSb3RhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbmFtZVJvdGF0aW9uID0gbmFtZVJvdGF0aW9uICogUEkgLyAxODA7IC8vIFRvIHJhZGlhbi5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGF4aXNOYW1lQXZhaWxhYmxlV2lkdGg7XG5cbiAgICAgICAgICAgIGlmIChuYW1lTG9jYXRpb24gPT09ICdtaWRkbGUnKSB7XG4gICAgICAgICAgICAgICAgbGFiZWxMYXlvdXQgPSBpbm5lclRleHRMYXlvdXQoXG4gICAgICAgICAgICAgICAgICAgIG9wdC5yb3RhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgbmFtZVJvdGF0aW9uICE9IG51bGwgPyBuYW1lUm90YXRpb24gOiBvcHQucm90YXRpb24sIC8vIEFkYXB0IHRvIGF4aXMuXG4gICAgICAgICAgICAgICAgICAgIG5hbWVEaXJlY3Rpb25cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGFiZWxMYXlvdXQgPSBlbmRUZXh0TGF5b3V0KFxuICAgICAgICAgICAgICAgICAgICBvcHQsIG5hbWVMb2NhdGlvbiwgbmFtZVJvdGF0aW9uIHx8IDAsIGV4dGVudFxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICBheGlzTmFtZUF2YWlsYWJsZVdpZHRoID0gb3B0LmF4aXNOYW1lQXZhaWxhYmxlV2lkdGg7XG4gICAgICAgICAgICAgICAgaWYgKGF4aXNOYW1lQXZhaWxhYmxlV2lkdGggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBheGlzTmFtZUF2YWlsYWJsZVdpZHRoID0gTWF0aC5hYnMoXG4gICAgICAgICAgICAgICAgICAgICAgICBheGlzTmFtZUF2YWlsYWJsZVdpZHRoIC8gTWF0aC5zaW4obGFiZWxMYXlvdXQucm90YXRpb24pXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICFpc0Zpbml0ZShheGlzTmFtZUF2YWlsYWJsZVdpZHRoKSAmJiAoYXhpc05hbWVBdmFpbGFibGVXaWR0aCA9IG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHRleHRGb250ID0gdGV4dFN0eWxlTW9kZWwuZ2V0Rm9udCgpO1xuXG4gICAgICAgICAgICB2YXIgdHJ1bmNhdGVPcHQgPSBheGlzTW9kZWwuZ2V0KCduYW1lVHJ1bmNhdGUnLCB0cnVlKSB8fCB7fTtcbiAgICAgICAgICAgIHZhciBlbGxpcHNpcyA9IHRydW5jYXRlT3B0LmVsbGlwc2lzO1xuICAgICAgICAgICAgdmFyIG1heFdpZHRoID0gcmV0cmlldmUoXG4gICAgICAgICAgICAgICAgb3B0Lm5hbWVUcnVuY2F0ZU1heFdpZHRoLCB0cnVuY2F0ZU9wdC5tYXhXaWR0aCwgYXhpc05hbWVBdmFpbGFibGVXaWR0aFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHZhciB0cnVuY2F0ZWRUZXh0ID0gKGVsbGlwc2lzICE9IG51bGwgJiYgbWF4V2lkdGggIT0gbnVsbClcbiAgICAgICAgICAgICAgICA/IGZvcm1hdFV0aWwudHJ1bmNhdGVUZXh0KFxuICAgICAgICAgICAgICAgICAgICBuYW1lLCBtYXhXaWR0aCwgdGV4dEZvbnQsIGVsbGlwc2lzLFxuICAgICAgICAgICAgICAgICAgICB7bWluQ2hhcjogMiwgcGxhY2Vob2xkZXI6IHRydW5jYXRlT3B0LnBsYWNlaG9sZGVyfVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICA6IG5hbWU7XG5cbiAgICAgICAgICAgIHZhciB0b29sdGlwT3B0ID0gYXhpc01vZGVsLmdldCgndG9vbHRpcCcsIHRydWUpO1xuXG4gICAgICAgICAgICB2YXIgbWFpblR5cGUgPSBheGlzTW9kZWwubWFpblR5cGU7XG4gICAgICAgICAgICB2YXIgZm9ybWF0dGVyUGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudFR5cGU6IG1haW5UeXBlLFxuICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICAgICAgJHZhcnM6IFsnbmFtZSddXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9ybWF0dGVyUGFyYW1zW21haW5UeXBlICsgJ0luZGV4J10gPSBheGlzTW9kZWwuY29tcG9uZW50SW5kZXg7XG5cbiAgICAgICAgICAgIHZhciB0ZXh0RWwgPSBuZXcgZ3JhcGhpYy5UZXh0KHtcblxuICAgICAgICAgICAgICAgIC8vIElkIGZvciBhbmltYXRpb25cbiAgICAgICAgICAgICAgICBhbmlkOiAnbmFtZScsXG5cbiAgICAgICAgICAgICAgICBfX2Z1bGxUZXh0OiBuYW1lLFxuICAgICAgICAgICAgICAgIF9fdHJ1bmNhdGVkVGV4dDogdHJ1bmNhdGVkVGV4dCxcblxuICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IHRydW5jYXRlZFRleHQsXG4gICAgICAgICAgICAgICAgICAgIHRleHRGb250OiB0ZXh0Rm9udCxcbiAgICAgICAgICAgICAgICAgICAgZmlsbDogdGV4dFN0eWxlTW9kZWwuZ2V0VGV4dENvbG9yKClcbiAgICAgICAgICAgICAgICAgICAgICAgIHx8IGF4aXNNb2RlbC5nZXQoJ2F4aXNMaW5lLmxpbmVTdHlsZS5jb2xvcicpLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0QWxpZ246IGxhYmVsTGF5b3V0LnRleHRBbGlnbixcbiAgICAgICAgICAgICAgICAgICAgdGV4dFZlcnRpY2FsQWxpZ246IGxhYmVsTGF5b3V0LnRleHRWZXJ0aWNhbEFsaWduXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogcG9zLFxuICAgICAgICAgICAgICAgIHJvdGF0aW9uOiBsYWJlbExheW91dC5yb3RhdGlvbixcbiAgICAgICAgICAgICAgICBzaWxlbnQ6IGlzU2lsZW50KGF4aXNNb2RlbCksXG4gICAgICAgICAgICAgICAgejI6IDEsXG4gICAgICAgICAgICAgICAgdG9vbHRpcDogKHRvb2x0aXBPcHQgJiYgdG9vbHRpcE9wdC5zaG93KVxuICAgICAgICAgICAgICAgICAgICA/IHpyVXRpbC5leHRlbmQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlclBhcmFtczogZm9ybWF0dGVyUGFyYW1zXG4gICAgICAgICAgICAgICAgICAgIH0sIHRvb2x0aXBPcHQpXG4gICAgICAgICAgICAgICAgICAgIDogbnVsbFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChheGlzTW9kZWwuZ2V0KCd0cmlnZ2VyRXZlbnQnKSkge1xuICAgICAgICAgICAgICAgIHRleHRFbC5ldmVudERhdGEgPSBtYWtlQXhpc0V2ZW50RGF0YUJhc2UoYXhpc01vZGVsKTtcbiAgICAgICAgICAgICAgICB0ZXh0RWwuZXZlbnREYXRhLnRhcmdldFR5cGUgPSAnYXhpc05hbWUnO1xuICAgICAgICAgICAgICAgIHRleHRFbC5ldmVudERhdGEubmFtZSA9IG5hbWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZJWE1FXG4gICAgICAgICAgICB0aGlzLl9kdW1iR3JvdXAuYWRkKHRleHRFbCk7XG4gICAgICAgICAgICB0ZXh0RWwudXBkYXRlVHJhbnNmb3JtKCk7XG5cbiAgICAgICAgICAgIHRoaXMuZ3JvdXAuYWRkKHRleHRFbCk7XG5cbiAgICAgICAgICAgIHRleHRFbC5kZWNvbXBvc2VUcmFuc2Zvcm0oKTtcbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBheGlzUm90YXRpb24gaW4gcmFkaWFuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRleHRSb3RhdGlvbiBpbiByYWRpYW5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGlyZWN0aW9uXG4gICAgICogQHJldHVybiB7T2JqZWN0fSB7XG4gICAgICogIHJvdGF0aW9uLCAvLyBhY2NvcmRpbmcgdG8gYXhpc1xuICAgICAqICB0ZXh0QWxpZ24sXG4gICAgICogIHRleHRWZXJ0aWNhbEFsaWduXG4gICAgICogfVxuICAgICAqL1xuICAgIHZhciBpbm5lclRleHRMYXlvdXQgPSBBeGlzQnVpbGRlci5pbm5lclRleHRMYXlvdXQgPSBmdW5jdGlvbiAoYXhpc1JvdGF0aW9uLCB0ZXh0Um90YXRpb24sIGRpcmVjdGlvbikge1xuICAgICAgICB2YXIgcm90YXRpb25EaWZmID0gcmVtUmFkaWFuKHRleHRSb3RhdGlvbiAtIGF4aXNSb3RhdGlvbik7XG4gICAgICAgIHZhciB0ZXh0QWxpZ247XG4gICAgICAgIHZhciB0ZXh0VmVydGljYWxBbGlnbjtcblxuICAgICAgICBpZiAoaXNSYWRpYW5Bcm91bmRaZXJvKHJvdGF0aW9uRGlmZikpIHsgLy8gTGFiZWwgaXMgcGFyYWxsZWwgd2l0aCBheGlzIGxpbmUuXG4gICAgICAgICAgICB0ZXh0VmVydGljYWxBbGlnbiA9IGRpcmVjdGlvbiA+IDAgPyAndG9wJyA6ICdib3R0b20nO1xuICAgICAgICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNSYWRpYW5Bcm91bmRaZXJvKHJvdGF0aW9uRGlmZiAtIFBJKSkgeyAvLyBMYWJlbCBpcyBpbnZlcnNlIHBhcmFsbGVsIHdpdGggYXhpcyBsaW5lLlxuICAgICAgICAgICAgdGV4dFZlcnRpY2FsQWxpZ24gPSBkaXJlY3Rpb24gPiAwID8gJ2JvdHRvbScgOiAndG9wJztcbiAgICAgICAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGV4dFZlcnRpY2FsQWxpZ24gPSAnbWlkZGxlJztcblxuICAgICAgICAgICAgaWYgKHJvdGF0aW9uRGlmZiA+IDAgJiYgcm90YXRpb25EaWZmIDwgUEkpIHtcbiAgICAgICAgICAgICAgICB0ZXh0QWxpZ24gPSBkaXJlY3Rpb24gPiAwID8gJ3JpZ2h0JyA6ICdsZWZ0JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRleHRBbGlnbiA9IGRpcmVjdGlvbiA+IDAgPyAnbGVmdCcgOiAncmlnaHQnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJvdGF0aW9uOiByb3RhdGlvbkRpZmYsXG4gICAgICAgICAgICB0ZXh0QWxpZ246IHRleHRBbGlnbixcbiAgICAgICAgICAgIHRleHRWZXJ0aWNhbEFsaWduOiB0ZXh0VmVydGljYWxBbGlnblxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBlbmRUZXh0TGF5b3V0KG9wdCwgdGV4dFBvc2l0aW9uLCB0ZXh0Um90YXRlLCBleHRlbnQpIHtcbiAgICAgICAgdmFyIHJvdGF0aW9uRGlmZiA9IHJlbVJhZGlhbih0ZXh0Um90YXRlIC0gb3B0LnJvdGF0aW9uKTtcbiAgICAgICAgdmFyIHRleHRBbGlnbjtcbiAgICAgICAgdmFyIHRleHRWZXJ0aWNhbEFsaWduO1xuICAgICAgICB2YXIgaW52ZXJzZSA9IGV4dGVudFswXSA+IGV4dGVudFsxXTtcbiAgICAgICAgdmFyIG9uTGVmdCA9ICh0ZXh0UG9zaXRpb24gPT09ICdzdGFydCcgJiYgIWludmVyc2UpXG4gICAgICAgICAgICB8fCAodGV4dFBvc2l0aW9uICE9PSAnc3RhcnQnICYmIGludmVyc2UpO1xuXG4gICAgICAgIGlmIChpc1JhZGlhbkFyb3VuZFplcm8ocm90YXRpb25EaWZmIC0gUEkgLyAyKSkge1xuICAgICAgICAgICAgdGV4dFZlcnRpY2FsQWxpZ24gPSBvbkxlZnQgPyAnYm90dG9tJyA6ICd0b3AnO1xuICAgICAgICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNSYWRpYW5Bcm91bmRaZXJvKHJvdGF0aW9uRGlmZiAtIFBJICogMS41KSkge1xuICAgICAgICAgICAgdGV4dFZlcnRpY2FsQWxpZ24gPSBvbkxlZnQgPyAndG9wJyA6ICdib3R0b20nO1xuICAgICAgICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0ZXh0VmVydGljYWxBbGlnbiA9ICdtaWRkbGUnO1xuICAgICAgICAgICAgaWYgKHJvdGF0aW9uRGlmZiA8IFBJICogMS41ICYmIHJvdGF0aW9uRGlmZiA+IFBJIC8gMikge1xuICAgICAgICAgICAgICAgIHRleHRBbGlnbiA9IG9uTGVmdCA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0ZXh0QWxpZ24gPSBvbkxlZnQgPyAncmlnaHQnIDogJ2xlZnQnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJvdGF0aW9uOiByb3RhdGlvbkRpZmYsXG4gICAgICAgICAgICB0ZXh0QWxpZ246IHRleHRBbGlnbixcbiAgICAgICAgICAgIHRleHRWZXJ0aWNhbEFsaWduOiB0ZXh0VmVydGljYWxBbGlnblxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzU2lsZW50KGF4aXNNb2RlbCkge1xuICAgICAgICB2YXIgdG9vbHRpcE9wdCA9IGF4aXNNb2RlbC5nZXQoJ3Rvb2x0aXAnKTtcbiAgICAgICAgcmV0dXJuIGF4aXNNb2RlbC5nZXQoJ3NpbGVudCcpXG4gICAgICAgICAgICAvLyBDb25zaWRlciBtb3VzZSBjdXJzb3IsIGFkZCB0aGVzZSByZXN0cmljdGlvbnMuXG4gICAgICAgICAgICB8fCAhKFxuICAgICAgICAgICAgICAgIGF4aXNNb2RlbC5nZXQoJ3RyaWdnZXJFdmVudCcpIHx8ICh0b29sdGlwT3B0ICYmIHRvb2x0aXBPcHQuc2hvdylcbiAgICAgICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZml4TWluTWF4TGFiZWxTaG93KGF4aXNNb2RlbCwgdGV4dEVscykge1xuICAgICAgICAvLyBJZiBtaW4gb3IgbWF4IGFyZSB1c2VyIHNldCwgd2UgbmVlZCB0byBjaGVja1xuICAgICAgICAvLyBJZiB0aGUgdGljayBvbiBtaW4obWF4KSBhcmUgb3ZlcmxhcCBvbiB0aGVpciBuZWlnaGJvdXIgdGlja1xuICAgICAgICAvLyBJZiB0aGV5IGFyZSBvdmVybGFwcGVkLCB3ZSBuZWVkIHRvIGhpZGUgdGhlIG1pbihtYXgpIHRpY2sgbGFiZWxcbiAgICAgICAgdmFyIHNob3dNaW5MYWJlbCA9IGF4aXNNb2RlbC5nZXQoJ2F4aXNMYWJlbC5zaG93TWluTGFiZWwnKTtcbiAgICAgICAgdmFyIHNob3dNYXhMYWJlbCA9IGF4aXNNb2RlbC5nZXQoJ2F4aXNMYWJlbC5zaG93TWF4TGFiZWwnKTtcbiAgICAgICAgdmFyIGZpcnN0TGFiZWwgPSB0ZXh0RWxzWzBdO1xuICAgICAgICB2YXIgbmV4dExhYmVsID0gdGV4dEVsc1sxXTtcbiAgICAgICAgdmFyIGxhc3RMYWJlbCA9IHRleHRFbHNbdGV4dEVscy5sZW5ndGggLSAxXTtcbiAgICAgICAgdmFyIHByZXZMYWJlbCA9IHRleHRFbHNbdGV4dEVscy5sZW5ndGggLSAyXTtcblxuICAgICAgICBpZiAoc2hvd01pbkxhYmVsID09PSBmYWxzZSkge1xuICAgICAgICAgICAgZmlyc3RMYWJlbC5pZ25vcmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGF4aXNNb2RlbC5nZXRNaW4oKSAhPSBudWxsICYmIGlzVHdvTGFiZWxPdmVybGFwcGVkKGZpcnN0TGFiZWwsIG5leHRMYWJlbCkpIHtcbiAgICAgICAgICAgIHNob3dNaW5MYWJlbCA/IChuZXh0TGFiZWwuaWdub3JlID0gdHJ1ZSkgOiAoZmlyc3RMYWJlbC5pZ25vcmUgPSB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzaG93TWF4TGFiZWwgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBsYXN0TGFiZWwuaWdub3JlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChheGlzTW9kZWwuZ2V0TWF4KCkgIT0gbnVsbCAmJiBpc1R3b0xhYmVsT3ZlcmxhcHBlZChwcmV2TGFiZWwsIGxhc3RMYWJlbCkpIHtcbiAgICAgICAgICAgIHNob3dNYXhMYWJlbCA/IChwcmV2TGFiZWwuaWdub3JlID0gdHJ1ZSkgOiAobGFzdExhYmVsLmlnbm9yZSA9IHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNUd29MYWJlbE92ZXJsYXBwZWQoY3VycmVudCwgbmV4dCwgbGFiZWxMYXlvdXQpIHtcbiAgICAgICAgLy8gY3VycmVudCBhbmQgbmV4dCBoYXMgdGhlIHNhbWUgcm90YXRpb24uXG4gICAgICAgIHZhciBmaXJzdFJlY3QgPSBjdXJyZW50ICYmIGN1cnJlbnQuZ2V0Qm91bmRpbmdSZWN0KCkuY2xvbmUoKTtcbiAgICAgICAgdmFyIG5leHRSZWN0ID0gbmV4dCAmJiBuZXh0LmdldEJvdW5kaW5nUmVjdCgpLmNsb25lKCk7XG5cbiAgICAgICAgaWYgKCFmaXJzdFJlY3QgfHwgIW5leHRSZWN0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXaGVuIGNoZWNraW5nIGludGVyc2VjdCBvZiB0d28gcm90YXRlZCBsYWJlbHMsIHdlIHVzZSBtUm90YXRpb25CYWNrXG4gICAgICAgIC8vIHRvIGF2b2lkIHRoYXQgYm91bmRpbmdSZWN0IGlzIGVubGFyZ2Ugd2hlbiB1c2luZyBgYm91bmRpbmdSZWN0LmFwcGx5VHJhbnNmb3JtYC5cbiAgICAgICAgdmFyIG1Sb3RhdGlvbkJhY2sgPSBtYXRyaXguaWRlbnRpdHkoW10pO1xuICAgICAgICBtYXRyaXgucm90YXRlKG1Sb3RhdGlvbkJhY2ssIG1Sb3RhdGlvbkJhY2ssIC1jdXJyZW50LnJvdGF0aW9uKTtcblxuICAgICAgICBmaXJzdFJlY3QuYXBwbHlUcmFuc2Zvcm0obWF0cml4Lm11bChbXSwgbVJvdGF0aW9uQmFjaywgY3VycmVudC5nZXRMb2NhbFRyYW5zZm9ybSgpKSk7XG4gICAgICAgIG5leHRSZWN0LmFwcGx5VHJhbnNmb3JtKG1hdHJpeC5tdWwoW10sIG1Sb3RhdGlvbkJhY2ssIG5leHQuZ2V0TG9jYWxUcmFuc2Zvcm0oKSkpO1xuXG4gICAgICAgIHJldHVybiBmaXJzdFJlY3QuaW50ZXJzZWN0KG5leHRSZWN0KTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICB2YXIgaWZJZ25vcmVPblRpY2sgPSBBeGlzQnVpbGRlci5pZklnbm9yZU9uVGljayA9IGZ1bmN0aW9uIChheGlzLCBpLCBpbnRlcnZhbCkge1xuICAgICAgICB2YXIgcmF3VGljaztcbiAgICAgICAgdmFyIHNjYWxlID0gYXhpcy5zY2FsZTtcbiAgICAgICAgcmV0dXJuIHNjYWxlLnR5cGUgPT09ICdvcmRpbmFsJ1xuICAgICAgICAgICAgJiYgKFxuICAgICAgICAgICAgICAgIHR5cGVvZiBpbnRlcnZhbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgICAgICAgICA/IChcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhd1RpY2sgPSBzY2FsZS5nZXRUaWNrcygpW2ldLFxuICAgICAgICAgICAgICAgICAgICAgICAgIWludGVydmFsKHJhd1RpY2ssIHNjYWxlLmdldExhYmVsKHJhd1RpY2spKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIDogaSAlIChpbnRlcnZhbCArIDEpXG4gICAgICAgICAgICApO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgdmFyIGdldEludGVydmFsID0gQXhpc0J1aWxkZXIuZ2V0SW50ZXJ2YWwgPSBmdW5jdGlvbiAobW9kZWwsIGxhYmVsSW50ZXJ2YWwpIHtcbiAgICAgICAgdmFyIGludGVydmFsID0gbW9kZWwuZ2V0KCdpbnRlcnZhbCcpO1xuICAgICAgICBpZiAoaW50ZXJ2YWwgPT0gbnVsbCB8fCBpbnRlcnZhbCA9PSAnYXV0bycpIHtcbiAgICAgICAgICAgIGludGVydmFsID0gbGFiZWxJbnRlcnZhbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW50ZXJ2YWw7XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gQXhpc0J1aWxkZXI7XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2NvbXBvbmVudC9heGlzL0F4aXNCdWlsZGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAzOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 40 */
/* unknown exports provided */
/* all exports used */
/*!****************************************!*\
  !*** ./lib/component/axis/AxisView.js ***!
  \****************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var axisPointerModelHelper = __webpack_require__(/*! ../axisPointer/modelHelper */ 45);\n\n    /**\n     * Base class of AxisView.\n     */\n    var AxisView = __webpack_require__(/*! ../../echarts */ 1).extendComponentView({\n\n        type: 'axis',\n\n        /**\n         * @private\n         */\n        _axisPointer: null,\n\n        /**\n         * @protected\n         * @type {string}\n         */\n        axisPointerClass: null,\n\n        /**\n         * @override\n         */\n        render: function (axisModel, ecModel, api, payload) {\n            // FIXME\n            // This process should proformed after coordinate systems updated\n            // (axis scale updated), and should be performed each time update.\n            // So put it here temporarily, although it is not appropriate to\n            // put a model-writing procedure in `view`.\n            this.axisPointerClass && axisPointerModelHelper.fixValue(axisModel);\n\n            AxisView.superApply(this, 'render', arguments);\n\n            updateAxisPointer(this, axisModel, ecModel, api, payload, true);\n        },\n\n        /**\n         * Action handler.\n         * @public\n         * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n         * @param {module:echarts/model/Global} ecModel\n         * @param {module:echarts/ExtensionAPI} api\n         * @param {Object} payload\n         */\n        updateAxisPointer: function (axisModel, ecModel, api, payload, force) {\n            updateAxisPointer(this, axisModel, ecModel, api, payload, false);\n        },\n\n        /**\n         * @override\n         */\n        remove: function (ecModel, api) {\n            var axisPointer = this._axisPointer;\n            axisPointer && axisPointer.remove(api);\n            AxisView.superApply(this, 'remove', arguments);\n        },\n\n        /**\n         * @override\n         */\n        dispose: function (ecModel, api) {\n            disposeAxisPointer(this, api);\n            AxisView.superApply(this, 'dispose', arguments);\n        }\n\n    });\n\n    function updateAxisPointer(axisView, axisModel, ecModel, api, payload, forceRender) {\n        var Clazz = AxisView.getAxisPointerClass(axisView.axisPointerClass);\n        if (!Clazz) {\n            return;\n        }\n        var axisPointerModel = axisPointerModelHelper.getAxisPointerModel(axisModel);\n        axisPointerModel\n            ? (axisView._axisPointer || (axisView._axisPointer = new Clazz()))\n                .render(axisModel, axisPointerModel, api, forceRender)\n            : disposeAxisPointer(axisView, api);\n    }\n\n    function disposeAxisPointer(axisView, ecModel, api) {\n        var axisPointer = axisView._axisPointer;\n        axisPointer && axisPointer.dispose(ecModel, api);\n        axisView._axisPointer = null;\n    }\n\n    var axisPointerClazz = [];\n\n    AxisView.registerAxisPointerClass = function (type, clazz) {\n        if (true) {\n            if (axisPointerClazz[type]) {\n                throw new Error('axisPointer ' + type + ' exists');\n            }\n        }\n        axisPointerClazz[type] = clazz;\n    };\n\n    AxisView.getAxisPointerClass = function (type) {\n        return type && axisPointerClazz[type];\n    };\n\n    module.exports = AxisView;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvY29tcG9uZW50L2F4aXMvQXhpc1ZpZXcuanM/YTcwYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcblxuICAgIHZhciBheGlzUG9pbnRlck1vZGVsSGVscGVyID0gcmVxdWlyZSgnLi4vYXhpc1BvaW50ZXIvbW9kZWxIZWxwZXInKTtcblxuICAgIC8qKlxuICAgICAqIEJhc2UgY2xhc3Mgb2YgQXhpc1ZpZXcuXG4gICAgICovXG4gICAgdmFyIEF4aXNWaWV3ID0gcmVxdWlyZSgnLi4vLi4vZWNoYXJ0cycpLmV4dGVuZENvbXBvbmVudFZpZXcoe1xuXG4gICAgICAgIHR5cGU6ICdheGlzJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF9heGlzUG9pbnRlcjogbnVsbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgYXhpc1BvaW50ZXJDbGFzczogbnVsbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgICAqL1xuICAgICAgICByZW5kZXI6IGZ1bmN0aW9uIChheGlzTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCkge1xuICAgICAgICAgICAgLy8gRklYTUVcbiAgICAgICAgICAgIC8vIFRoaXMgcHJvY2VzcyBzaG91bGQgcHJvZm9ybWVkIGFmdGVyIGNvb3JkaW5hdGUgc3lzdGVtcyB1cGRhdGVkXG4gICAgICAgICAgICAvLyAoYXhpcyBzY2FsZSB1cGRhdGVkKSwgYW5kIHNob3VsZCBiZSBwZXJmb3JtZWQgZWFjaCB0aW1lIHVwZGF0ZS5cbiAgICAgICAgICAgIC8vIFNvIHB1dCBpdCBoZXJlIHRlbXBvcmFyaWx5LCBhbHRob3VnaCBpdCBpcyBub3QgYXBwcm9wcmlhdGUgdG9cbiAgICAgICAgICAgIC8vIHB1dCBhIG1vZGVsLXdyaXRpbmcgcHJvY2VkdXJlIGluIGB2aWV3YC5cbiAgICAgICAgICAgIHRoaXMuYXhpc1BvaW50ZXJDbGFzcyAmJiBheGlzUG9pbnRlck1vZGVsSGVscGVyLmZpeFZhbHVlKGF4aXNNb2RlbCk7XG5cbiAgICAgICAgICAgIEF4aXNWaWV3LnN1cGVyQXBwbHkodGhpcywgJ3JlbmRlcicsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIHVwZGF0ZUF4aXNQb2ludGVyKHRoaXMsIGF4aXNNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkLCB0cnVlKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQWN0aW9uIGhhbmRsZXIuXG4gICAgICAgICAqIEBwdWJsaWNcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9jb29yZC9jYXJ0ZXNpYW4vQXhpc01vZGVsfSBheGlzTW9kZWxcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9IGVjTW9kZWxcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9FeHRlbnNpb25BUEl9IGFwaVxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcGF5bG9hZFxuICAgICAgICAgKi9cbiAgICAgICAgdXBkYXRlQXhpc1BvaW50ZXI6IGZ1bmN0aW9uIChheGlzTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCwgZm9yY2UpIHtcbiAgICAgICAgICAgIHVwZGF0ZUF4aXNQb2ludGVyKHRoaXMsIGF4aXNNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkLCBmYWxzZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiAoZWNNb2RlbCwgYXBpKSB7XG4gICAgICAgICAgICB2YXIgYXhpc1BvaW50ZXIgPSB0aGlzLl9heGlzUG9pbnRlcjtcbiAgICAgICAgICAgIGF4aXNQb2ludGVyICYmIGF4aXNQb2ludGVyLnJlbW92ZShhcGkpO1xuICAgICAgICAgICAgQXhpc1ZpZXcuc3VwZXJBcHBseSh0aGlzLCAncmVtb3ZlJywgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgICAqL1xuICAgICAgICBkaXNwb3NlOiBmdW5jdGlvbiAoZWNNb2RlbCwgYXBpKSB7XG4gICAgICAgICAgICBkaXNwb3NlQXhpc1BvaW50ZXIodGhpcywgYXBpKTtcbiAgICAgICAgICAgIEF4aXNWaWV3LnN1cGVyQXBwbHkodGhpcywgJ2Rpc3Bvc2UnLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG5cbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIHVwZGF0ZUF4aXNQb2ludGVyKGF4aXNWaWV3LCBheGlzTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCwgZm9yY2VSZW5kZXIpIHtcbiAgICAgICAgdmFyIENsYXp6ID0gQXhpc1ZpZXcuZ2V0QXhpc1BvaW50ZXJDbGFzcyhheGlzVmlldy5heGlzUG9pbnRlckNsYXNzKTtcbiAgICAgICAgaWYgKCFDbGF6eikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBheGlzUG9pbnRlck1vZGVsID0gYXhpc1BvaW50ZXJNb2RlbEhlbHBlci5nZXRBeGlzUG9pbnRlck1vZGVsKGF4aXNNb2RlbCk7XG4gICAgICAgIGF4aXNQb2ludGVyTW9kZWxcbiAgICAgICAgICAgID8gKGF4aXNWaWV3Ll9heGlzUG9pbnRlciB8fCAoYXhpc1ZpZXcuX2F4aXNQb2ludGVyID0gbmV3IENsYXp6KCkpKVxuICAgICAgICAgICAgICAgIC5yZW5kZXIoYXhpc01vZGVsLCBheGlzUG9pbnRlck1vZGVsLCBhcGksIGZvcmNlUmVuZGVyKVxuICAgICAgICAgICAgOiBkaXNwb3NlQXhpc1BvaW50ZXIoYXhpc1ZpZXcsIGFwaSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGlzcG9zZUF4aXNQb2ludGVyKGF4aXNWaWV3LCBlY01vZGVsLCBhcGkpIHtcbiAgICAgICAgdmFyIGF4aXNQb2ludGVyID0gYXhpc1ZpZXcuX2F4aXNQb2ludGVyO1xuICAgICAgICBheGlzUG9pbnRlciAmJiBheGlzUG9pbnRlci5kaXNwb3NlKGVjTW9kZWwsIGFwaSk7XG4gICAgICAgIGF4aXNWaWV3Ll9heGlzUG9pbnRlciA9IG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGF4aXNQb2ludGVyQ2xhenogPSBbXTtcblxuICAgIEF4aXNWaWV3LnJlZ2lzdGVyQXhpc1BvaW50ZXJDbGFzcyA9IGZ1bmN0aW9uICh0eXBlLCBjbGF6eikge1xuICAgICAgICBpZiAoX19ERVZfXykge1xuICAgICAgICAgICAgaWYgKGF4aXNQb2ludGVyQ2xhenpbdHlwZV0pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2F4aXNQb2ludGVyICcgKyB0eXBlICsgJyBleGlzdHMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBheGlzUG9pbnRlckNsYXp6W3R5cGVdID0gY2xheno7XG4gICAgfTtcblxuICAgIEF4aXNWaWV3LmdldEF4aXNQb2ludGVyQ2xhc3MgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICByZXR1cm4gdHlwZSAmJiBheGlzUG9pbnRlckNsYXp6W3R5cGVdO1xuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IEF4aXNWaWV3O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvY29tcG9uZW50L2F4aXMvQXhpc1ZpZXcuanNcbi8vIG1vZHVsZSBpZCA9IDQwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 41 */
/* unknown exports provided */
/* all exports used */
/*!*******************************************!*\
  !*** ./lib/coord/axisModelCommonMixin.js ***!
  \*******************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 0);\n    var axisHelper = __webpack_require__(/*! ./axisHelper */ 16);\n\n    function getName(obj) {\n        if (zrUtil.isObject(obj) && obj.value != null) {\n            return obj.value;\n        }\n        else {\n            return obj;\n        }\n    }\n\n    module.exports = {\n\n        /**\n         * Format labels\n         * @return {Array.<string>}\n         */\n        getFormattedLabels: function () {\n            return axisHelper.getFormattedLabels(\n                this.axis,\n                this.get('axisLabel.formatter')\n            );\n        },\n\n        /**\n         * Get categories\n         */\n        getCategories: function () {\n            return this.get('type') === 'category'\n                && zrUtil.map(this.get('data'), getName);\n        },\n\n        /**\n         * @param {boolean} origin\n         * @return {number|string} min value or 'dataMin' or null/undefined (means auto) or NaN\n         */\n        getMin: function (origin) {\n            var option = this.option;\n            var min = (!origin && option.rangeStart != null)\n                ? option.rangeStart : option.min;\n\n            if (this.axis && min != null && min !== 'dataMin' && !zrUtil.eqNaN(min)) {\n                min = this.axis.scale.parse(min);\n            }\n            return min;\n        },\n\n        /**\n         * @param {boolean} origin\n         * @return {number|string} max value or 'dataMax' or null/undefined (means auto) or NaN\n         */\n        getMax: function (origin) {\n            var option = this.option;\n            var max = (!origin && option.rangeEnd != null)\n                ? option.rangeEnd : option.max;\n\n            if (this.axis && max != null && max !== 'dataMax' && !zrUtil.eqNaN(max)) {\n                max = this.axis.scale.parse(max);\n            }\n            return max;\n        },\n\n        /**\n         * @return {boolean}\n         */\n        getNeedCrossZero: function () {\n            var option = this.option;\n            return (option.rangeStart != null || option.rangeEnd != null)\n                ? false : !option.scale;\n        },\n\n        /**\n         * Should be implemented by each axis model if necessary.\n         * @return {module:echarts/model/Component} coordinate system model\n         */\n        getCoordSysModel: zrUtil.noop,\n\n        /**\n         * @param {number} rangeStart Can only be finite number or null/undefined or NaN.\n         * @param {number} rangeEnd Can only be finite number or null/undefined or NaN.\n         */\n        setRange: function (rangeStart, rangeEnd) {\n            this.option.rangeStart = rangeStart;\n            this.option.rangeEnd = rangeEnd;\n        },\n\n        /**\n         * Reset range\n         */\n        resetRange: function () {\n            // rangeStart and rangeEnd is readonly.\n            this.option.rangeStart = this.option.rangeEnd = null;\n        }\n    };\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvY29vcmQvYXhpc01vZGVsQ29tbW9uTWl4aW4uanM/ZTRkNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgYXhpc0hlbHBlciA9IHJlcXVpcmUoJy4vYXhpc0hlbHBlcicpO1xuXG4gICAgZnVuY3Rpb24gZ2V0TmFtZShvYmopIHtcbiAgICAgICAgaWYgKHpyVXRpbC5pc09iamVjdChvYmopICYmIG9iai52YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGb3JtYXQgbGFiZWxzXG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5LjxzdHJpbmc+fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0Rm9ybWF0dGVkTGFiZWxzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gYXhpc0hlbHBlci5nZXRGb3JtYXR0ZWRMYWJlbHMoXG4gICAgICAgICAgICAgICAgdGhpcy5heGlzLFxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0KCdheGlzTGFiZWwuZm9ybWF0dGVyJylcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBjYXRlZ29yaWVzXG4gICAgICAgICAqL1xuICAgICAgICBnZXRDYXRlZ29yaWVzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQoJ3R5cGUnKSA9PT0gJ2NhdGVnb3J5J1xuICAgICAgICAgICAgICAgICYmIHpyVXRpbC5tYXAodGhpcy5nZXQoJ2RhdGEnKSwgZ2V0TmFtZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3JpZ2luXG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcnxzdHJpbmd9IG1pbiB2YWx1ZSBvciAnZGF0YU1pbicgb3IgbnVsbC91bmRlZmluZWQgKG1lYW5zIGF1dG8pIG9yIE5hTlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0TWluOiBmdW5jdGlvbiAob3JpZ2luKSB7XG4gICAgICAgICAgICB2YXIgb3B0aW9uID0gdGhpcy5vcHRpb247XG4gICAgICAgICAgICB2YXIgbWluID0gKCFvcmlnaW4gJiYgb3B0aW9uLnJhbmdlU3RhcnQgIT0gbnVsbClcbiAgICAgICAgICAgICAgICA/IG9wdGlvbi5yYW5nZVN0YXJ0IDogb3B0aW9uLm1pbjtcblxuICAgICAgICAgICAgaWYgKHRoaXMuYXhpcyAmJiBtaW4gIT0gbnVsbCAmJiBtaW4gIT09ICdkYXRhTWluJyAmJiAhenJVdGlsLmVxTmFOKG1pbikpIHtcbiAgICAgICAgICAgICAgICBtaW4gPSB0aGlzLmF4aXMuc2NhbGUucGFyc2UobWluKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtaW47XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3JpZ2luXG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcnxzdHJpbmd9IG1heCB2YWx1ZSBvciAnZGF0YU1heCcgb3IgbnVsbC91bmRlZmluZWQgKG1lYW5zIGF1dG8pIG9yIE5hTlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0TWF4OiBmdW5jdGlvbiAob3JpZ2luKSB7XG4gICAgICAgICAgICB2YXIgb3B0aW9uID0gdGhpcy5vcHRpb247XG4gICAgICAgICAgICB2YXIgbWF4ID0gKCFvcmlnaW4gJiYgb3B0aW9uLnJhbmdlRW5kICE9IG51bGwpXG4gICAgICAgICAgICAgICAgPyBvcHRpb24ucmFuZ2VFbmQgOiBvcHRpb24ubWF4O1xuXG4gICAgICAgICAgICBpZiAodGhpcy5heGlzICYmIG1heCAhPSBudWxsICYmIG1heCAhPT0gJ2RhdGFNYXgnICYmICF6clV0aWwuZXFOYU4obWF4KSkge1xuICAgICAgICAgICAgICAgIG1heCA9IHRoaXMuYXhpcy5zY2FsZS5wYXJzZShtYXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1heDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGdldE5lZWRDcm9zc1plcm86IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvcHRpb24gPSB0aGlzLm9wdGlvbjtcbiAgICAgICAgICAgIHJldHVybiAob3B0aW9uLnJhbmdlU3RhcnQgIT0gbnVsbCB8fCBvcHRpb24ucmFuZ2VFbmQgIT0gbnVsbClcbiAgICAgICAgICAgICAgICA/IGZhbHNlIDogIW9wdGlvbi5zY2FsZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2hvdWxkIGJlIGltcGxlbWVudGVkIGJ5IGVhY2ggYXhpcyBtb2RlbCBpZiBuZWNlc3NhcnkuXG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTplY2hhcnRzL21vZGVsL0NvbXBvbmVudH0gY29vcmRpbmF0ZSBzeXN0ZW0gbW9kZWxcbiAgICAgICAgICovXG4gICAgICAgIGdldENvb3JkU3lzTW9kZWw6IHpyVXRpbC5ub29wLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gcmFuZ2VTdGFydCBDYW4gb25seSBiZSBmaW5pdGUgbnVtYmVyIG9yIG51bGwvdW5kZWZpbmVkIG9yIE5hTi5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHJhbmdlRW5kIENhbiBvbmx5IGJlIGZpbml0ZSBudW1iZXIgb3IgbnVsbC91bmRlZmluZWQgb3IgTmFOLlxuICAgICAgICAgKi9cbiAgICAgICAgc2V0UmFuZ2U6IGZ1bmN0aW9uIChyYW5nZVN0YXJ0LCByYW5nZUVuZCkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb24ucmFuZ2VTdGFydCA9IHJhbmdlU3RhcnQ7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbi5yYW5nZUVuZCA9IHJhbmdlRW5kO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXNldCByYW5nZVxuICAgICAgICAgKi9cbiAgICAgICAgcmVzZXRSYW5nZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gcmFuZ2VTdGFydCBhbmQgcmFuZ2VFbmQgaXMgcmVhZG9ubHkuXG4gICAgICAgICAgICB0aGlzLm9wdGlvbi5yYW5nZVN0YXJ0ID0gdGhpcy5vcHRpb24ucmFuZ2VFbmQgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Nvb3JkL2F4aXNNb2RlbENvbW1vbk1peGluLmpzXG4vLyBtb2R1bGUgaWQgPSA0MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 42 */
/* unknown exports provided */
/* all exports used */
/*!*******************************!*\
  !*** ./lib/scale/Interval.js ***!
  \*******************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Interval scale\n * @module echarts/scale/Interval\n */\n\n\n\n    var numberUtil = __webpack_require__(/*! ../util/number */ 3);\n    var formatUtil = __webpack_require__(/*! ../util/format */ 6);\n    var Scale = __webpack_require__(/*! ./Scale */ 35);\n    var helper = __webpack_require__(/*! ./helper */ 71);\n\n    var roundNumber = numberUtil.round;\n\n    /**\n     * @alias module:echarts/coord/scale/Interval\n     * @constructor\n     */\n    var IntervalScale = Scale.extend({\n\n        type: 'interval',\n\n        _interval: 0,\n\n        _intervalPrecision: 2,\n\n        setExtent: function (start, end) {\n            var thisExtent = this._extent;\n            //start,end may be a Number like '25',so...\n            if (!isNaN(start)) {\n                thisExtent[0] = parseFloat(start);\n            }\n            if (!isNaN(end)) {\n                thisExtent[1] = parseFloat(end);\n            }\n        },\n\n        unionExtent: function (other) {\n            var extent = this._extent;\n            other[0] < extent[0] && (extent[0] = other[0]);\n            other[1] > extent[1] && (extent[1] = other[1]);\n\n            // unionExtent may called by it's sub classes\n            IntervalScale.prototype.setExtent.call(this, extent[0], extent[1]);\n        },\n        /**\n         * Get interval\n         */\n        getInterval: function () {\n            if (!this._interval) {\n                this.niceTicks();\n            }\n            return this._interval;\n        },\n\n        /**\n         * Set interval\n         */\n        setInterval: function (interval) {\n            this._interval = interval;\n            // Dropped auto calculated niceExtent and use user setted extent\n            // We assume user wan't to set both interval, min, max to get a better result\n            this._niceExtent = this._extent.slice();\n        },\n\n        /**\n         * @return {Array.<number>}\n         */\n        getTicks: function () {\n            if (!this._interval) {\n                this.niceTicks();\n            }\n            return helper.intervalScaleGetTicks(\n                this._interval, this._extent, this._niceExtent, this._intervalPrecision\n            );\n        },\n\n        /**\n         * @return {Array.<string>}\n         */\n        getTicksLabels: function () {\n            var labels = [];\n            var ticks = this.getTicks();\n            for (var i = 0; i < ticks.length; i++) {\n                labels.push(this.getLabel(ticks[i]));\n            }\n            return labels;\n        },\n\n        /**\n         * @param {number} data\n         * @param {Object} [opt]\n         * @param {number|string} [opt.precision] If 'auto', use nice presision.\n         * @param {boolean} [opt.pad] returns 1.50 but not 1.5 if precision is 2.\n         * @return {string}\n         */\n        getLabel: function (data, opt) {\n            if (data == null) {\n                return '';\n            }\n\n            var precision = opt && opt.precision;\n\n            if (precision == null) {\n                precision = numberUtil.getPrecisionSafe(data) || 0;\n            }\n            else if (precision === 'auto') {\n                // Should be more precise then tick.\n                precision = this._intervalPrecision;\n            }\n\n            // (1) If `precision` is set, 12.005 should be display as '12.00500'.\n            // (2) Use roundNumber (toFixed) to avoid scientific notation like '3.5e-7'.\n            data = roundNumber(data, precision, true);\n\n            return formatUtil.addCommas(data);\n        },\n\n        /**\n         * Update interval and extent of intervals for nice ticks\n         *\n         * @param {number} [splitNumber = 5] Desired number of ticks\n         */\n        niceTicks: function (splitNumber) {\n            splitNumber = splitNumber || 5;\n            var extent = this._extent;\n            var span = extent[1] - extent[0];\n            if (!isFinite(span)) {\n                return;\n            }\n            // User may set axis min 0 and data are all negative\n            // FIXME If it needs to reverse ?\n            if (span < 0) {\n                span = -span;\n                extent.reverse();\n            }\n\n            var result = helper.intervalScaleNiceTicks(extent, splitNumber);\n\n            this._intervalPrecision = result.intervalPrecision;\n            this._interval = result.interval;\n            this._niceExtent = result.niceTickExtent;\n        },\n\n        /**\n         * Nice extent.\n         * @param {number} [splitNumber = 5] Given approx tick number\n         * @param {boolean} [fixMin=false]\n         * @param {boolean} [fixMax=false]\n         */\n        niceExtent: function (splitNumber, fixMin, fixMax) {\n            var extent = this._extent;\n            // If extent start and end are same, expand them\n            if (extent[0] === extent[1]) {\n                if (extent[0] !== 0) {\n                    // Expand extent\n                    var expandSize = extent[0];\n                    // In the fowllowing case\n                    //      Axis has been fixed max 100\n                    //      Plus data are all 100 and axis extent are [100, 100].\n                    // Extend to the both side will cause expanded max is larger than fixed max.\n                    // So only expand to the smaller side.\n                    if (!fixMax) {\n                        extent[1] += expandSize / 2;\n                        extent[0] -= expandSize / 2;\n                    }\n                    else {\n                        extent[0] -= expandSize / 2;\n                    }\n                }\n                else {\n                    extent[1] = 1;\n                }\n            }\n            var span = extent[1] - extent[0];\n            // If there are no data and extent are [Infinity, -Infinity]\n            if (!isFinite(span)) {\n                extent[0] = 0;\n                extent[1] = 1;\n            }\n\n            this.niceTicks(splitNumber);\n\n            // var extent = this._extent;\n            var interval = this._interval;\n\n            if (!fixMin) {\n                extent[0] = roundNumber(Math.floor(extent[0] / interval) * interval);\n            }\n            if (!fixMax) {\n                extent[1] = roundNumber(Math.ceil(extent[1] / interval) * interval);\n            }\n        }\n    });\n\n    /**\n     * @return {module:echarts/scale/Time}\n     */\n    IntervalScale.create = function () {\n        return new IntervalScale();\n    };\n\n    module.exports = IntervalScale;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvc2NhbGUvSW50ZXJ2YWwuanM/YTJiYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEludGVydmFsIHNjYWxlXG4gKiBAbW9kdWxlIGVjaGFydHMvc2NhbGUvSW50ZXJ2YWxcbiAqL1xuXG5cblxuICAgIHZhciBudW1iZXJVdGlsID0gcmVxdWlyZSgnLi4vdXRpbC9udW1iZXInKTtcbiAgICB2YXIgZm9ybWF0VXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvZm9ybWF0Jyk7XG4gICAgdmFyIFNjYWxlID0gcmVxdWlyZSgnLi9TY2FsZScpO1xuICAgIHZhciBoZWxwZXIgPSByZXF1aXJlKCcuL2hlbHBlcicpO1xuXG4gICAgdmFyIHJvdW5kTnVtYmVyID0gbnVtYmVyVXRpbC5yb3VuZDtcblxuICAgIC8qKlxuICAgICAqIEBhbGlhcyBtb2R1bGU6ZWNoYXJ0cy9jb29yZC9zY2FsZS9JbnRlcnZhbFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIHZhciBJbnRlcnZhbFNjYWxlID0gU2NhbGUuZXh0ZW5kKHtcblxuICAgICAgICB0eXBlOiAnaW50ZXJ2YWwnLFxuXG4gICAgICAgIF9pbnRlcnZhbDogMCxcblxuICAgICAgICBfaW50ZXJ2YWxQcmVjaXNpb246IDIsXG5cbiAgICAgICAgc2V0RXh0ZW50OiBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICAgICAgICAgICAgdmFyIHRoaXNFeHRlbnQgPSB0aGlzLl9leHRlbnQ7XG4gICAgICAgICAgICAvL3N0YXJ0LGVuZCBtYXkgYmUgYSBOdW1iZXIgbGlrZSAnMjUnLHNvLi4uXG4gICAgICAgICAgICBpZiAoIWlzTmFOKHN0YXJ0KSkge1xuICAgICAgICAgICAgICAgIHRoaXNFeHRlbnRbMF0gPSBwYXJzZUZsb2F0KHN0YXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNOYU4oZW5kKSkge1xuICAgICAgICAgICAgICAgIHRoaXNFeHRlbnRbMV0gPSBwYXJzZUZsb2F0KGVuZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgdW5pb25FeHRlbnQ6IGZ1bmN0aW9uIChvdGhlcikge1xuICAgICAgICAgICAgdmFyIGV4dGVudCA9IHRoaXMuX2V4dGVudDtcbiAgICAgICAgICAgIG90aGVyWzBdIDwgZXh0ZW50WzBdICYmIChleHRlbnRbMF0gPSBvdGhlclswXSk7XG4gICAgICAgICAgICBvdGhlclsxXSA+IGV4dGVudFsxXSAmJiAoZXh0ZW50WzFdID0gb3RoZXJbMV0pO1xuXG4gICAgICAgICAgICAvLyB1bmlvbkV4dGVudCBtYXkgY2FsbGVkIGJ5IGl0J3Mgc3ViIGNsYXNzZXNcbiAgICAgICAgICAgIEludGVydmFsU2NhbGUucHJvdG90eXBlLnNldEV4dGVudC5jYWxsKHRoaXMsIGV4dGVudFswXSwgZXh0ZW50WzFdKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBpbnRlcnZhbFxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0SW50ZXJ2YWw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5faW50ZXJ2YWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5pY2VUaWNrcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ludGVydmFsO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgaW50ZXJ2YWxcbiAgICAgICAgICovXG4gICAgICAgIHNldEludGVydmFsOiBmdW5jdGlvbiAoaW50ZXJ2YWwpIHtcbiAgICAgICAgICAgIHRoaXMuX2ludGVydmFsID0gaW50ZXJ2YWw7XG4gICAgICAgICAgICAvLyBEcm9wcGVkIGF1dG8gY2FsY3VsYXRlZCBuaWNlRXh0ZW50IGFuZCB1c2UgdXNlciBzZXR0ZWQgZXh0ZW50XG4gICAgICAgICAgICAvLyBXZSBhc3N1bWUgdXNlciB3YW4ndCB0byBzZXQgYm90aCBpbnRlcnZhbCwgbWluLCBtYXggdG8gZ2V0IGEgYmV0dGVyIHJlc3VsdFxuICAgICAgICAgICAgdGhpcy5fbmljZUV4dGVudCA9IHRoaXMuX2V4dGVudC5zbGljZSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAgICAgICAgICovXG4gICAgICAgIGdldFRpY2tzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2ludGVydmFsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uaWNlVGlja3MoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBoZWxwZXIuaW50ZXJ2YWxTY2FsZUdldFRpY2tzKFxuICAgICAgICAgICAgICAgIHRoaXMuX2ludGVydmFsLCB0aGlzLl9leHRlbnQsIHRoaXMuX25pY2VFeHRlbnQsIHRoaXMuX2ludGVydmFsUHJlY2lzaW9uXG4gICAgICAgICAgICApO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48c3RyaW5nPn1cbiAgICAgICAgICovXG4gICAgICAgIGdldFRpY2tzTGFiZWxzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbGFiZWxzID0gW107XG4gICAgICAgICAgICB2YXIgdGlja3MgPSB0aGlzLmdldFRpY2tzKCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRpY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGFiZWxzLnB1c2godGhpcy5nZXRMYWJlbCh0aWNrc1tpXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGxhYmVscztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGRhdGFcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRdXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW29wdC5wcmVjaXNpb25dIElmICdhdXRvJywgdXNlIG5pY2UgcHJlc2lzaW9uLlxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHQucGFkXSByZXR1cm5zIDEuNTAgYnV0IG5vdCAxLjUgaWYgcHJlY2lzaW9uIGlzIDIuXG4gICAgICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIGdldExhYmVsOiBmdW5jdGlvbiAoZGF0YSwgb3B0KSB7XG4gICAgICAgICAgICBpZiAoZGF0YSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcHJlY2lzaW9uID0gb3B0ICYmIG9wdC5wcmVjaXNpb247XG5cbiAgICAgICAgICAgIGlmIChwcmVjaXNpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHByZWNpc2lvbiA9IG51bWJlclV0aWwuZ2V0UHJlY2lzaW9uU2FmZShkYXRhKSB8fCAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocHJlY2lzaW9uID09PSAnYXV0bycpIHtcbiAgICAgICAgICAgICAgICAvLyBTaG91bGQgYmUgbW9yZSBwcmVjaXNlIHRoZW4gdGljay5cbiAgICAgICAgICAgICAgICBwcmVjaXNpb24gPSB0aGlzLl9pbnRlcnZhbFByZWNpc2lvbjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gKDEpIElmIGBwcmVjaXNpb25gIGlzIHNldCwgMTIuMDA1IHNob3VsZCBiZSBkaXNwbGF5IGFzICcxMi4wMDUwMCcuXG4gICAgICAgICAgICAvLyAoMikgVXNlIHJvdW5kTnVtYmVyICh0b0ZpeGVkKSB0byBhdm9pZCBzY2llbnRpZmljIG5vdGF0aW9uIGxpa2UgJzMuNWUtNycuXG4gICAgICAgICAgICBkYXRhID0gcm91bmROdW1iZXIoZGF0YSwgcHJlY2lzaW9uLCB0cnVlKTtcblxuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdFV0aWwuYWRkQ29tbWFzKGRhdGEpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGUgaW50ZXJ2YWwgYW5kIGV4dGVudCBvZiBpbnRlcnZhbHMgZm9yIG5pY2UgdGlja3NcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtzcGxpdE51bWJlciA9IDVdIERlc2lyZWQgbnVtYmVyIG9mIHRpY2tzXG4gICAgICAgICAqL1xuICAgICAgICBuaWNlVGlja3M6IGZ1bmN0aW9uIChzcGxpdE51bWJlcikge1xuICAgICAgICAgICAgc3BsaXROdW1iZXIgPSBzcGxpdE51bWJlciB8fCA1O1xuICAgICAgICAgICAgdmFyIGV4dGVudCA9IHRoaXMuX2V4dGVudDtcbiAgICAgICAgICAgIHZhciBzcGFuID0gZXh0ZW50WzFdIC0gZXh0ZW50WzBdO1xuICAgICAgICAgICAgaWYgKCFpc0Zpbml0ZShzcGFuKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFVzZXIgbWF5IHNldCBheGlzIG1pbiAwIGFuZCBkYXRhIGFyZSBhbGwgbmVnYXRpdmVcbiAgICAgICAgICAgIC8vIEZJWE1FIElmIGl0IG5lZWRzIHRvIHJldmVyc2UgP1xuICAgICAgICAgICAgaWYgKHNwYW4gPCAwKSB7XG4gICAgICAgICAgICAgICAgc3BhbiA9IC1zcGFuO1xuICAgICAgICAgICAgICAgIGV4dGVudC5yZXZlcnNlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBoZWxwZXIuaW50ZXJ2YWxTY2FsZU5pY2VUaWNrcyhleHRlbnQsIHNwbGl0TnVtYmVyKTtcblxuICAgICAgICAgICAgdGhpcy5faW50ZXJ2YWxQcmVjaXNpb24gPSByZXN1bHQuaW50ZXJ2YWxQcmVjaXNpb247XG4gICAgICAgICAgICB0aGlzLl9pbnRlcnZhbCA9IHJlc3VsdC5pbnRlcnZhbDtcbiAgICAgICAgICAgIHRoaXMuX25pY2VFeHRlbnQgPSByZXN1bHQubmljZVRpY2tFeHRlbnQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5pY2UgZXh0ZW50LlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW3NwbGl0TnVtYmVyID0gNV0gR2l2ZW4gYXBwcm94IHRpY2sgbnVtYmVyXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ZpeE1pbj1mYWxzZV1cbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbZml4TWF4PWZhbHNlXVxuICAgICAgICAgKi9cbiAgICAgICAgbmljZUV4dGVudDogZnVuY3Rpb24gKHNwbGl0TnVtYmVyLCBmaXhNaW4sIGZpeE1heCkge1xuICAgICAgICAgICAgdmFyIGV4dGVudCA9IHRoaXMuX2V4dGVudDtcbiAgICAgICAgICAgIC8vIElmIGV4dGVudCBzdGFydCBhbmQgZW5kIGFyZSBzYW1lLCBleHBhbmQgdGhlbVxuICAgICAgICAgICAgaWYgKGV4dGVudFswXSA9PT0gZXh0ZW50WzFdKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV4dGVudFswXSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBFeHBhbmQgZXh0ZW50XG4gICAgICAgICAgICAgICAgICAgIHZhciBleHBhbmRTaXplID0gZXh0ZW50WzBdO1xuICAgICAgICAgICAgICAgICAgICAvLyBJbiB0aGUgZm93bGxvd2luZyBjYXNlXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgQXhpcyBoYXMgYmVlbiBmaXhlZCBtYXggMTAwXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgUGx1cyBkYXRhIGFyZSBhbGwgMTAwIGFuZCBheGlzIGV4dGVudCBhcmUgWzEwMCwgMTAwXS5cbiAgICAgICAgICAgICAgICAgICAgLy8gRXh0ZW5kIHRvIHRoZSBib3RoIHNpZGUgd2lsbCBjYXVzZSBleHBhbmRlZCBtYXggaXMgbGFyZ2VyIHRoYW4gZml4ZWQgbWF4LlxuICAgICAgICAgICAgICAgICAgICAvLyBTbyBvbmx5IGV4cGFuZCB0byB0aGUgc21hbGxlciBzaWRlLlxuICAgICAgICAgICAgICAgICAgICBpZiAoIWZpeE1heCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW50WzFdICs9IGV4cGFuZFNpemUgLyAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW50WzBdIC09IGV4cGFuZFNpemUgLyAyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW50WzBdIC09IGV4cGFuZFNpemUgLyAyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBleHRlbnRbMV0gPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzcGFuID0gZXh0ZW50WzFdIC0gZXh0ZW50WzBdO1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIGRhdGEgYW5kIGV4dGVudCBhcmUgW0luZmluaXR5LCAtSW5maW5pdHldXG4gICAgICAgICAgICBpZiAoIWlzRmluaXRlKHNwYW4pKSB7XG4gICAgICAgICAgICAgICAgZXh0ZW50WzBdID0gMDtcbiAgICAgICAgICAgICAgICBleHRlbnRbMV0gPSAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLm5pY2VUaWNrcyhzcGxpdE51bWJlcik7XG5cbiAgICAgICAgICAgIC8vIHZhciBleHRlbnQgPSB0aGlzLl9leHRlbnQ7XG4gICAgICAgICAgICB2YXIgaW50ZXJ2YWwgPSB0aGlzLl9pbnRlcnZhbDtcblxuICAgICAgICAgICAgaWYgKCFmaXhNaW4pIHtcbiAgICAgICAgICAgICAgICBleHRlbnRbMF0gPSByb3VuZE51bWJlcihNYXRoLmZsb29yKGV4dGVudFswXSAvIGludGVydmFsKSAqIGludGVydmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZml4TWF4KSB7XG4gICAgICAgICAgICAgICAgZXh0ZW50WzFdID0gcm91bmROdW1iZXIoTWF0aC5jZWlsKGV4dGVudFsxXSAvIGludGVydmFsKSAqIGludGVydmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7bW9kdWxlOmVjaGFydHMvc2NhbGUvVGltZX1cbiAgICAgKi9cbiAgICBJbnRlcnZhbFNjYWxlLmNyZWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbnRlcnZhbFNjYWxlKCk7XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gSW50ZXJ2YWxTY2FsZTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvc2NhbGUvSW50ZXJ2YWwuanNcbi8vIG1vZHVsZSBpZCA9IDQyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 43 */
/* unknown exports provided */
/* all exports used */
/*!**********************************************!*\
  !*** /home/yx/~/zrender/lib/core/timsort.js ***!
  \**********************************************/
/***/ (function(module, exports) {

eval("// https://github.com/mziccard/node-timsort\n\n    var DEFAULT_MIN_MERGE = 32;\n\n    var DEFAULT_MIN_GALLOPING = 7;\n\n    var DEFAULT_TMP_STORAGE_LENGTH = 256;\n\n    function minRunLength(n) {\n        var r = 0;\n\n        while (n >= DEFAULT_MIN_MERGE) {\n            r |= n & 1;\n            n >>= 1;\n        }\n\n        return n + r;\n    }\n\n    function makeAscendingRun(array, lo, hi, compare) {\n        var runHi = lo + 1;\n\n        if (runHi === hi) {\n            return 1;\n        }\n\n        if (compare(array[runHi++], array[lo]) < 0) {\n            while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {\n                runHi++;\n            }\n\n            reverseRun(array, lo, runHi);\n        }\n        else {\n            while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {\n                runHi++;\n            }\n        }\n\n        return runHi - lo;\n    }\n\n    function reverseRun(array, lo, hi) {\n        hi--;\n\n        while (lo < hi) {\n            var t = array[lo];\n            array[lo++] = array[hi];\n            array[hi--] = t;\n        }\n    }\n\n    function binaryInsertionSort(array, lo, hi, start, compare) {\n        if (start === lo) {\n            start++;\n        }\n\n        for (; start < hi; start++) {\n            var pivot = array[start];\n\n            var left = lo;\n            var right = start;\n            var mid;\n\n            while (left < right) {\n                mid = left + right >>> 1;\n\n                if (compare(pivot, array[mid]) < 0) {\n                    right = mid;\n                }\n                else {\n                    left = mid + 1;\n                }\n            }\n\n            var n = start - left;\n\n            switch (n) {\n                case 3:\n                    array[left + 3] = array[left + 2];\n\n                case 2:\n                    array[left + 2] = array[left + 1];\n\n                case 1:\n                    array[left + 1] = array[left];\n                    break;\n                default:\n                    while (n > 0) {\n                        array[left + n] = array[left + n - 1];\n                        n--;\n                    }\n            }\n\n            array[left] = pivot;\n        }\n    }\n\n    function gallopLeft(value, array, start, length, hint, compare) {\n        var lastOffset = 0;\n        var maxOffset = 0;\n        var offset = 1;\n\n        if (compare(value, array[start + hint]) > 0) {\n            maxOffset = length - hint;\n\n            while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n\n            lastOffset += hint;\n            offset += hint;\n        }\n        else {\n            maxOffset = hint + 1;\n            while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n\n            var tmp = lastOffset;\n            lastOffset = hint - offset;\n            offset = hint - tmp;\n        }\n\n        lastOffset++;\n        while (lastOffset < offset) {\n            var m = lastOffset + (offset - lastOffset >>> 1);\n\n            if (compare(value, array[start + m]) > 0) {\n                lastOffset = m + 1;\n            }\n            else {\n                offset = m;\n            }\n        }\n        return offset;\n    }\n\n    function gallopRight(value, array, start, length, hint, compare) {\n        var lastOffset = 0;\n        var maxOffset = 0;\n        var offset = 1;\n\n        if (compare(value, array[start + hint]) < 0) {\n            maxOffset = hint + 1;\n\n            while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n\n            var tmp = lastOffset;\n            lastOffset = hint - offset;\n            offset = hint - tmp;\n        }\n        else {\n            maxOffset = length - hint;\n\n            while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n\n            lastOffset += hint;\n            offset += hint;\n        }\n\n        lastOffset++;\n\n        while (lastOffset < offset) {\n            var m = lastOffset + (offset - lastOffset >>> 1);\n\n            if (compare(value, array[start + m]) < 0) {\n                offset = m;\n            }\n            else {\n                lastOffset = m + 1;\n            }\n        }\n\n        return offset;\n    }\n\n    function TimSort(array, compare) {\n        var minGallop = DEFAULT_MIN_GALLOPING;\n        var length = 0;\n        var tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;\n        var stackLength = 0;\n        var runStart;\n        var runLength;\n        var stackSize = 0;\n\n        length = array.length;\n\n        if (length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {\n            tmpStorageLength = length >>> 1;\n        }\n\n        var tmp = [];\n\n        stackLength = length < 120 ? 5 : length < 1542 ? 10 : length < 119151 ? 19 : 40;\n\n        runStart = [];\n        runLength = [];\n\n        function pushRun(_runStart, _runLength) {\n            runStart[stackSize] = _runStart;\n            runLength[stackSize] = _runLength;\n            stackSize += 1;\n        }\n\n        function mergeRuns() {\n            while (stackSize > 1) {\n                var n = stackSize - 2;\n\n                if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) {\n                    if (runLength[n - 1] < runLength[n + 1]) {\n                        n--;\n                    }\n                }\n                else if (runLength[n] > runLength[n + 1]) {\n                    break;\n                }\n                mergeAt(n);\n            }\n        }\n\n        function forceMergeRuns() {\n            while (stackSize > 1) {\n                var n = stackSize - 2;\n\n                if (n > 0 && runLength[n - 1] < runLength[n + 1]) {\n                    n--;\n                }\n\n                mergeAt(n);\n            }\n        }\n\n        function mergeAt(i) {\n            var start1 = runStart[i];\n            var length1 = runLength[i];\n            var start2 = runStart[i + 1];\n            var length2 = runLength[i + 1];\n\n            runLength[i] = length1 + length2;\n\n            if (i === stackSize - 3) {\n                runStart[i + 1] = runStart[i + 2];\n                runLength[i + 1] = runLength[i + 2];\n            }\n\n            stackSize--;\n\n            var k = gallopRight(array[start2], array, start1, length1, 0, compare);\n            start1 += k;\n            length1 -= k;\n\n            if (length1 === 0) {\n                return;\n            }\n\n            length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);\n\n            if (length2 === 0) {\n                return;\n            }\n\n            if (length1 <= length2) {\n                mergeLow(start1, length1, start2, length2);\n            }\n            else {\n                mergeHigh(start1, length1, start2, length2);\n            }\n        }\n\n        function mergeLow(start1, length1, start2, length2) {\n            var i = 0;\n\n            for (i = 0; i < length1; i++) {\n                tmp[i] = array[start1 + i];\n            }\n\n            var cursor1 = 0;\n            var cursor2 = start2;\n            var dest = start1;\n\n            array[dest++] = array[cursor2++];\n\n            if (--length2 === 0) {\n                for (i = 0; i < length1; i++) {\n                    array[dest + i] = tmp[cursor1 + i];\n                }\n                return;\n            }\n\n            if (length1 === 1) {\n                for (i = 0; i < length2; i++) {\n                    array[dest + i] = array[cursor2 + i];\n                }\n                array[dest + length2] = tmp[cursor1];\n                return;\n            }\n\n            var _minGallop = minGallop;\n            var count1, count2, exit;\n\n            while (1) {\n                count1 = 0;\n                count2 = 0;\n                exit = false;\n\n                do {\n                    if (compare(array[cursor2], tmp[cursor1]) < 0) {\n                        array[dest++] = array[cursor2++];\n                        count2++;\n                        count1 = 0;\n\n                        if (--length2 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                    else {\n                        array[dest++] = tmp[cursor1++];\n                        count1++;\n                        count2 = 0;\n                        if (--length1 === 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                } while ((count1 | count2) < _minGallop);\n\n                if (exit) {\n                    break;\n                }\n\n                do {\n                    count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);\n\n                    if (count1 !== 0) {\n                        for (i = 0; i < count1; i++) {\n                            array[dest + i] = tmp[cursor1 + i];\n                        }\n\n                        dest += count1;\n                        cursor1 += count1;\n                        length1 -= count1;\n                        if (length1 <= 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n\n                    array[dest++] = array[cursor2++];\n\n                    if (--length2 === 0) {\n                        exit = true;\n                        break;\n                    }\n\n                    count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);\n\n                    if (count2 !== 0) {\n                        for (i = 0; i < count2; i++) {\n                            array[dest + i] = array[cursor2 + i];\n                        }\n\n                        dest += count2;\n                        cursor2 += count2;\n                        length2 -= count2;\n\n                        if (length2 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                    array[dest++] = tmp[cursor1++];\n\n                    if (--length1 === 1) {\n                        exit = true;\n                        break;\n                    }\n\n                    _minGallop--;\n                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\n                if (exit) {\n                    break;\n                }\n\n                if (_minGallop < 0) {\n                    _minGallop = 0;\n                }\n\n                _minGallop += 2;\n            }\n\n            minGallop = _minGallop;\n\n            minGallop < 1 && (minGallop = 1);\n\n            if (length1 === 1) {\n                for (i = 0; i < length2; i++) {\n                    array[dest + i] = array[cursor2 + i];\n                }\n                array[dest + length2] = tmp[cursor1];\n            }\n            else if (length1 === 0) {\n                throw new Error();\n                // throw new Error('mergeLow preconditions were not respected');\n            }\n            else {\n                for (i = 0; i < length1; i++) {\n                    array[dest + i] = tmp[cursor1 + i];\n                }\n            }\n        }\n\n        function mergeHigh (start1, length1, start2, length2) {\n            var i = 0;\n\n            for (i = 0; i < length2; i++) {\n                tmp[i] = array[start2 + i];\n            }\n\n            var cursor1 = start1 + length1 - 1;\n            var cursor2 = length2 - 1;\n            var dest = start2 + length2 - 1;\n            var customCursor = 0;\n            var customDest = 0;\n\n            array[dest--] = array[cursor1--];\n\n            if (--length1 === 0) {\n                customCursor = dest - (length2 - 1);\n\n                for (i = 0; i < length2; i++) {\n                    array[customCursor + i] = tmp[i];\n                }\n\n                return;\n            }\n\n            if (length2 === 1) {\n                dest -= length1;\n                cursor1 -= length1;\n                customDest = dest + 1;\n                customCursor = cursor1 + 1;\n\n                for (i = length1 - 1; i >= 0; i--) {\n                    array[customDest + i] = array[customCursor + i];\n                }\n\n                array[dest] = tmp[cursor2];\n                return;\n            }\n\n            var _minGallop = minGallop;\n\n            while (true) {\n                var count1 = 0;\n                var count2 = 0;\n                var exit = false;\n\n                do {\n                    if (compare(tmp[cursor2], array[cursor1]) < 0) {\n                        array[dest--] = array[cursor1--];\n                        count1++;\n                        count2 = 0;\n                        if (--length1 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                    else {\n                        array[dest--] = tmp[cursor2--];\n                        count2++;\n                        count1 = 0;\n                        if (--length2 === 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                } while ((count1 | count2) < _minGallop);\n\n                if (exit) {\n                    break;\n                }\n\n                do {\n                    count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);\n\n                    if (count1 !== 0) {\n                        dest -= count1;\n                        cursor1 -= count1;\n                        length1 -= count1;\n                        customDest = dest + 1;\n                        customCursor = cursor1 + 1;\n\n                        for (i = count1 - 1; i >= 0; i--) {\n                            array[customDest + i] = array[customCursor + i];\n                        }\n\n                        if (length1 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n\n                    array[dest--] = tmp[cursor2--];\n\n                    if (--length2 === 1) {\n                        exit = true;\n                        break;\n                    }\n\n                    count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);\n\n                    if (count2 !== 0) {\n                        dest -= count2;\n                        cursor2 -= count2;\n                        length2 -= count2;\n                        customDest = dest + 1;\n                        customCursor = cursor2 + 1;\n\n                        for (i = 0; i < count2; i++) {\n                            array[customDest + i] = tmp[customCursor + i];\n                        }\n\n                        if (length2 <= 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n\n                    array[dest--] = array[cursor1--];\n\n                    if (--length1 === 0) {\n                        exit = true;\n                        break;\n                    }\n\n                    _minGallop--;\n                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\n                if (exit) {\n                    break;\n                }\n\n                if (_minGallop < 0) {\n                    _minGallop = 0;\n                }\n\n                _minGallop += 2;\n            }\n\n            minGallop = _minGallop;\n\n            if (minGallop < 1) {\n                minGallop = 1;\n            }\n\n            if (length2 === 1) {\n                dest -= length1;\n                cursor1 -= length1;\n                customDest = dest + 1;\n                customCursor = cursor1 + 1;\n\n                for (i = length1 - 1; i >= 0; i--) {\n                    array[customDest + i] = array[customCursor + i];\n                }\n\n                array[dest] = tmp[cursor2];\n            }\n            else if (length2 === 0) {\n                throw new Error();\n                // throw new Error('mergeHigh preconditions were not respected');\n            }\n            else {\n                customCursor = dest - (length2 - 1);\n                for (i = 0; i < length2; i++) {\n                    array[customCursor + i] = tmp[i];\n                }\n            }\n        }\n\n        this.mergeRuns = mergeRuns;\n        this.forceMergeRuns = forceMergeRuns;\n        this.pushRun = pushRun;\n    }\n\n    function sort(array, compare, lo, hi) {\n        if (!lo) {\n            lo = 0;\n        }\n        if (!hi) {\n            hi = array.length;\n        }\n\n        var remaining = hi - lo;\n\n        if (remaining < 2) {\n            return;\n        }\n\n        var runLength = 0;\n\n        if (remaining < DEFAULT_MIN_MERGE) {\n            runLength = makeAscendingRun(array, lo, hi, compare);\n            binaryInsertionSort(array, lo, hi, lo + runLength, compare);\n            return;\n        }\n\n        var ts = new TimSort(array, compare);\n\n        var minRun = minRunLength(remaining);\n\n        do {\n            runLength = makeAscendingRun(array, lo, hi, compare);\n            if (runLength < minRun) {\n                var force = remaining;\n                if (force > minRun) {\n                    force = minRun;\n                }\n\n                binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);\n                runLength = force;\n            }\n\n            ts.pushRun(lo, runLength);\n            ts.mergeRuns();\n\n            remaining -= runLength;\n            lo += runLength;\n        } while (remaining !== 0);\n\n        ts.forceMergeRuns();\n    }\n\n    module.exports = sort;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL2hvbWUveXgvfi96cmVuZGVyL2xpYi9jb3JlL3RpbXNvcnQuanM/MzBkZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBodHRwczovL2dpdGh1Yi5jb20vbXppY2NhcmQvbm9kZS10aW1zb3J0XG5cbiAgICB2YXIgREVGQVVMVF9NSU5fTUVSR0UgPSAzMjtcblxuICAgIHZhciBERUZBVUxUX01JTl9HQUxMT1BJTkcgPSA3O1xuXG4gICAgdmFyIERFRkFVTFRfVE1QX1NUT1JBR0VfTEVOR1RIID0gMjU2O1xuXG4gICAgZnVuY3Rpb24gbWluUnVuTGVuZ3RoKG4pIHtcbiAgICAgICAgdmFyIHIgPSAwO1xuXG4gICAgICAgIHdoaWxlIChuID49IERFRkFVTFRfTUlOX01FUkdFKSB7XG4gICAgICAgICAgICByIHw9IG4gJiAxO1xuICAgICAgICAgICAgbiA+Pj0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuICsgcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlQXNjZW5kaW5nUnVuKGFycmF5LCBsbywgaGksIGNvbXBhcmUpIHtcbiAgICAgICAgdmFyIHJ1bkhpID0gbG8gKyAxO1xuXG4gICAgICAgIGlmIChydW5IaSA9PT0gaGkpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbXBhcmUoYXJyYXlbcnVuSGkrK10sIGFycmF5W2xvXSkgPCAwKSB7XG4gICAgICAgICAgICB3aGlsZSAocnVuSGkgPCBoaSAmJiBjb21wYXJlKGFycmF5W3J1bkhpXSwgYXJyYXlbcnVuSGkgLSAxXSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgcnVuSGkrKztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV2ZXJzZVJ1bihhcnJheSwgbG8sIHJ1bkhpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdoaWxlIChydW5IaSA8IGhpICYmIGNvbXBhcmUoYXJyYXlbcnVuSGldLCBhcnJheVtydW5IaSAtIDFdKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgcnVuSGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBydW5IaSAtIGxvO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJldmVyc2VSdW4oYXJyYXksIGxvLCBoaSkge1xuICAgICAgICBoaS0tO1xuXG4gICAgICAgIHdoaWxlIChsbyA8IGhpKSB7XG4gICAgICAgICAgICB2YXIgdCA9IGFycmF5W2xvXTtcbiAgICAgICAgICAgIGFycmF5W2xvKytdID0gYXJyYXlbaGldO1xuICAgICAgICAgICAgYXJyYXlbaGktLV0gPSB0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYmluYXJ5SW5zZXJ0aW9uU29ydChhcnJheSwgbG8sIGhpLCBzdGFydCwgY29tcGFyZSkge1xuICAgICAgICBpZiAoc3RhcnQgPT09IGxvKSB7XG4gICAgICAgICAgICBzdGFydCsrO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICg7IHN0YXJ0IDwgaGk7IHN0YXJ0KyspIHtcbiAgICAgICAgICAgIHZhciBwaXZvdCA9IGFycmF5W3N0YXJ0XTtcblxuICAgICAgICAgICAgdmFyIGxlZnQgPSBsbztcbiAgICAgICAgICAgIHZhciByaWdodCA9IHN0YXJ0O1xuICAgICAgICAgICAgdmFyIG1pZDtcblxuICAgICAgICAgICAgd2hpbGUgKGxlZnQgPCByaWdodCkge1xuICAgICAgICAgICAgICAgIG1pZCA9IGxlZnQgKyByaWdodCA+Pj4gMTtcblxuICAgICAgICAgICAgICAgIGlmIChjb21wYXJlKHBpdm90LCBhcnJheVttaWRdKSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSBtaWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbWlkICsgMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBuID0gc3RhcnQgLSBsZWZ0O1xuXG4gICAgICAgICAgICBzd2l0Y2ggKG4pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIGFycmF5W2xlZnQgKyAzXSA9IGFycmF5W2xlZnQgKyAyXTtcblxuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlbbGVmdCArIDJdID0gYXJyYXlbbGVmdCArIDFdO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBhcnJheVtsZWZ0ICsgMV0gPSBhcnJheVtsZWZ0XTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKG4gPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJheVtsZWZ0ICsgbl0gPSBhcnJheVtsZWZ0ICsgbiAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbi0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGFycmF5W2xlZnRdID0gcGl2b3Q7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnYWxsb3BMZWZ0KHZhbHVlLCBhcnJheSwgc3RhcnQsIGxlbmd0aCwgaGludCwgY29tcGFyZSkge1xuICAgICAgICB2YXIgbGFzdE9mZnNldCA9IDA7XG4gICAgICAgIHZhciBtYXhPZmZzZXQgPSAwO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gMTtcblxuICAgICAgICBpZiAoY29tcGFyZSh2YWx1ZSwgYXJyYXlbc3RhcnQgKyBoaW50XSkgPiAwKSB7XG4gICAgICAgICAgICBtYXhPZmZzZXQgPSBsZW5ndGggLSBoaW50O1xuXG4gICAgICAgICAgICB3aGlsZSAob2Zmc2V0IDwgbWF4T2Zmc2V0ICYmIGNvbXBhcmUodmFsdWUsIGFycmF5W3N0YXJ0ICsgaGludCArIG9mZnNldF0pID4gMCkge1xuICAgICAgICAgICAgICAgIGxhc3RPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gKG9mZnNldCA8PCAxKSArIDE7XG5cbiAgICAgICAgICAgICAgICBpZiAob2Zmc2V0IDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gbWF4T2Zmc2V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG9mZnNldCA+IG1heE9mZnNldCkge1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IG1heE9mZnNldDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGFzdE9mZnNldCArPSBoaW50O1xuICAgICAgICAgICAgb2Zmc2V0ICs9IGhpbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtYXhPZmZzZXQgPSBoaW50ICsgMTtcbiAgICAgICAgICAgIHdoaWxlIChvZmZzZXQgPCBtYXhPZmZzZXQgJiYgY29tcGFyZSh2YWx1ZSwgYXJyYXlbc3RhcnQgKyBoaW50IC0gb2Zmc2V0XSkgPD0gMCkge1xuICAgICAgICAgICAgICAgIGxhc3RPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gKG9mZnNldCA8PCAxKSArIDE7XG5cbiAgICAgICAgICAgICAgICBpZiAob2Zmc2V0IDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gbWF4T2Zmc2V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvZmZzZXQgPiBtYXhPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBtYXhPZmZzZXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB0bXAgPSBsYXN0T2Zmc2V0O1xuICAgICAgICAgICAgbGFzdE9mZnNldCA9IGhpbnQgLSBvZmZzZXQ7XG4gICAgICAgICAgICBvZmZzZXQgPSBoaW50IC0gdG1wO1xuICAgICAgICB9XG5cbiAgICAgICAgbGFzdE9mZnNldCsrO1xuICAgICAgICB3aGlsZSAobGFzdE9mZnNldCA8IG9mZnNldCkge1xuICAgICAgICAgICAgdmFyIG0gPSBsYXN0T2Zmc2V0ICsgKG9mZnNldCAtIGxhc3RPZmZzZXQgPj4+IDEpO1xuXG4gICAgICAgICAgICBpZiAoY29tcGFyZSh2YWx1ZSwgYXJyYXlbc3RhcnQgKyBtXSkgPiAwKSB7XG4gICAgICAgICAgICAgICAgbGFzdE9mZnNldCA9IG0gKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdhbGxvcFJpZ2h0KHZhbHVlLCBhcnJheSwgc3RhcnQsIGxlbmd0aCwgaGludCwgY29tcGFyZSkge1xuICAgICAgICB2YXIgbGFzdE9mZnNldCA9IDA7XG4gICAgICAgIHZhciBtYXhPZmZzZXQgPSAwO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gMTtcblxuICAgICAgICBpZiAoY29tcGFyZSh2YWx1ZSwgYXJyYXlbc3RhcnQgKyBoaW50XSkgPCAwKSB7XG4gICAgICAgICAgICBtYXhPZmZzZXQgPSBoaW50ICsgMTtcblxuICAgICAgICAgICAgd2hpbGUgKG9mZnNldCA8IG1heE9mZnNldCAmJiBjb21wYXJlKHZhbHVlLCBhcnJheVtzdGFydCArIGhpbnQgLSBvZmZzZXRdKSA8IDApIHtcbiAgICAgICAgICAgICAgICBsYXN0T2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IChvZmZzZXQgPDwgMSkgKyAxO1xuXG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IG1heE9mZnNldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChvZmZzZXQgPiBtYXhPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBtYXhPZmZzZXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB0bXAgPSBsYXN0T2Zmc2V0O1xuICAgICAgICAgICAgbGFzdE9mZnNldCA9IGhpbnQgLSBvZmZzZXQ7XG4gICAgICAgICAgICBvZmZzZXQgPSBoaW50IC0gdG1wO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWF4T2Zmc2V0ID0gbGVuZ3RoIC0gaGludDtcblxuICAgICAgICAgICAgd2hpbGUgKG9mZnNldCA8IG1heE9mZnNldCAmJiBjb21wYXJlKHZhbHVlLCBhcnJheVtzdGFydCArIGhpbnQgKyBvZmZzZXRdKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgbGFzdE9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSAob2Zmc2V0IDw8IDEpICsgMTtcblxuICAgICAgICAgICAgICAgIGlmIChvZmZzZXQgPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSBtYXhPZmZzZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAob2Zmc2V0ID4gbWF4T2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gbWF4T2Zmc2V0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsYXN0T2Zmc2V0ICs9IGhpbnQ7XG4gICAgICAgICAgICBvZmZzZXQgKz0gaGludDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxhc3RPZmZzZXQrKztcblxuICAgICAgICB3aGlsZSAobGFzdE9mZnNldCA8IG9mZnNldCkge1xuICAgICAgICAgICAgdmFyIG0gPSBsYXN0T2Zmc2V0ICsgKG9mZnNldCAtIGxhc3RPZmZzZXQgPj4+IDEpO1xuXG4gICAgICAgICAgICBpZiAoY29tcGFyZSh2YWx1ZSwgYXJyYXlbc3RhcnQgKyBtXSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxhc3RPZmZzZXQgPSBtICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gVGltU29ydChhcnJheSwgY29tcGFyZSkge1xuICAgICAgICB2YXIgbWluR2FsbG9wID0gREVGQVVMVF9NSU5fR0FMTE9QSU5HO1xuICAgICAgICB2YXIgbGVuZ3RoID0gMDtcbiAgICAgICAgdmFyIHRtcFN0b3JhZ2VMZW5ndGggPSBERUZBVUxUX1RNUF9TVE9SQUdFX0xFTkdUSDtcbiAgICAgICAgdmFyIHN0YWNrTGVuZ3RoID0gMDtcbiAgICAgICAgdmFyIHJ1blN0YXJ0O1xuICAgICAgICB2YXIgcnVuTGVuZ3RoO1xuICAgICAgICB2YXIgc3RhY2tTaXplID0gMDtcblxuICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgICAgaWYgKGxlbmd0aCA8IDIgKiBERUZBVUxUX1RNUF9TVE9SQUdFX0xFTkdUSCkge1xuICAgICAgICAgICAgdG1wU3RvcmFnZUxlbmd0aCA9IGxlbmd0aCA+Pj4gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0bXAgPSBbXTtcblxuICAgICAgICBzdGFja0xlbmd0aCA9IGxlbmd0aCA8IDEyMCA/IDUgOiBsZW5ndGggPCAxNTQyID8gMTAgOiBsZW5ndGggPCAxMTkxNTEgPyAxOSA6IDQwO1xuXG4gICAgICAgIHJ1blN0YXJ0ID0gW107XG4gICAgICAgIHJ1bkxlbmd0aCA9IFtdO1xuXG4gICAgICAgIGZ1bmN0aW9uIHB1c2hSdW4oX3J1blN0YXJ0LCBfcnVuTGVuZ3RoKSB7XG4gICAgICAgICAgICBydW5TdGFydFtzdGFja1NpemVdID0gX3J1blN0YXJ0O1xuICAgICAgICAgICAgcnVuTGVuZ3RoW3N0YWNrU2l6ZV0gPSBfcnVuTGVuZ3RoO1xuICAgICAgICAgICAgc3RhY2tTaXplICs9IDE7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBtZXJnZVJ1bnMoKSB7XG4gICAgICAgICAgICB3aGlsZSAoc3RhY2tTaXplID4gMSkge1xuICAgICAgICAgICAgICAgIHZhciBuID0gc3RhY2tTaXplIC0gMjtcblxuICAgICAgICAgICAgICAgIGlmIChuID49IDEgJiYgcnVuTGVuZ3RoW24gLSAxXSA8PSBydW5MZW5ndGhbbl0gKyBydW5MZW5ndGhbbiArIDFdIHx8IG4gPj0gMiAmJiBydW5MZW5ndGhbbiAtIDJdIDw9IHJ1bkxlbmd0aFtuXSArIHJ1bkxlbmd0aFtuIC0gMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJ1bkxlbmd0aFtuIC0gMV0gPCBydW5MZW5ndGhbbiArIDFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuLS07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocnVuTGVuZ3RoW25dID4gcnVuTGVuZ3RoW24gKyAxXSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWVyZ2VBdChuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGZvcmNlTWVyZ2VSdW5zKCkge1xuICAgICAgICAgICAgd2hpbGUgKHN0YWNrU2l6ZSA+IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgbiA9IHN0YWNrU2l6ZSAtIDI7XG5cbiAgICAgICAgICAgICAgICBpZiAobiA+IDAgJiYgcnVuTGVuZ3RoW24gLSAxXSA8IHJ1bkxlbmd0aFtuICsgMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgbi0tO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG1lcmdlQXQobik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBtZXJnZUF0KGkpIHtcbiAgICAgICAgICAgIHZhciBzdGFydDEgPSBydW5TdGFydFtpXTtcbiAgICAgICAgICAgIHZhciBsZW5ndGgxID0gcnVuTGVuZ3RoW2ldO1xuICAgICAgICAgICAgdmFyIHN0YXJ0MiA9IHJ1blN0YXJ0W2kgKyAxXTtcbiAgICAgICAgICAgIHZhciBsZW5ndGgyID0gcnVuTGVuZ3RoW2kgKyAxXTtcblxuICAgICAgICAgICAgcnVuTGVuZ3RoW2ldID0gbGVuZ3RoMSArIGxlbmd0aDI7XG5cbiAgICAgICAgICAgIGlmIChpID09PSBzdGFja1NpemUgLSAzKSB7XG4gICAgICAgICAgICAgICAgcnVuU3RhcnRbaSArIDFdID0gcnVuU3RhcnRbaSArIDJdO1xuICAgICAgICAgICAgICAgIHJ1bkxlbmd0aFtpICsgMV0gPSBydW5MZW5ndGhbaSArIDJdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdGFja1NpemUtLTtcblxuICAgICAgICAgICAgdmFyIGsgPSBnYWxsb3BSaWdodChhcnJheVtzdGFydDJdLCBhcnJheSwgc3RhcnQxLCBsZW5ndGgxLCAwLCBjb21wYXJlKTtcbiAgICAgICAgICAgIHN0YXJ0MSArPSBrO1xuICAgICAgICAgICAgbGVuZ3RoMSAtPSBrO1xuXG4gICAgICAgICAgICBpZiAobGVuZ3RoMSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGVuZ3RoMiA9IGdhbGxvcExlZnQoYXJyYXlbc3RhcnQxICsgbGVuZ3RoMSAtIDFdLCBhcnJheSwgc3RhcnQyLCBsZW5ndGgyLCBsZW5ndGgyIC0gMSwgY29tcGFyZSk7XG5cbiAgICAgICAgICAgIGlmIChsZW5ndGgyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobGVuZ3RoMSA8PSBsZW5ndGgyKSB7XG4gICAgICAgICAgICAgICAgbWVyZ2VMb3coc3RhcnQxLCBsZW5ndGgxLCBzdGFydDIsIGxlbmd0aDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbWVyZ2VIaWdoKHN0YXJ0MSwgbGVuZ3RoMSwgc3RhcnQyLCBsZW5ndGgyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG1lcmdlTG93KHN0YXJ0MSwgbGVuZ3RoMSwgc3RhcnQyLCBsZW5ndGgyKSB7XG4gICAgICAgICAgICB2YXIgaSA9IDA7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGgxOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0bXBbaV0gPSBhcnJheVtzdGFydDEgKyBpXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGN1cnNvcjEgPSAwO1xuICAgICAgICAgICAgdmFyIGN1cnNvcjIgPSBzdGFydDI7XG4gICAgICAgICAgICB2YXIgZGVzdCA9IHN0YXJ0MTtcblxuICAgICAgICAgICAgYXJyYXlbZGVzdCsrXSA9IGFycmF5W2N1cnNvcjIrK107XG5cbiAgICAgICAgICAgIGlmICgtLWxlbmd0aDIgPT09IDApIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGFycmF5W2Rlc3QgKyBpXSA9IHRtcFtjdXJzb3IxICsgaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGxlbmd0aDEgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoMjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGFycmF5W2Rlc3QgKyBpXSA9IGFycmF5W2N1cnNvcjIgKyBpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXJyYXlbZGVzdCArIGxlbmd0aDJdID0gdG1wW2N1cnNvcjFdO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIF9taW5HYWxsb3AgPSBtaW5HYWxsb3A7XG4gICAgICAgICAgICB2YXIgY291bnQxLCBjb3VudDIsIGV4aXQ7XG5cbiAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgY291bnQxID0gMDtcbiAgICAgICAgICAgICAgICBjb3VudDIgPSAwO1xuICAgICAgICAgICAgICAgIGV4aXQgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBhcmUoYXJyYXlbY3Vyc29yMl0sIHRtcFtjdXJzb3IxXSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJheVtkZXN0KytdID0gYXJyYXlbY3Vyc29yMisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50MisrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnQxID0gMDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKC0tbGVuZ3RoMiA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlbZGVzdCsrXSA9IHRtcFtjdXJzb3IxKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnQxKys7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudDIgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKC0tbGVuZ3RoMSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSB3aGlsZSAoKGNvdW50MSB8IGNvdW50MikgPCBfbWluR2FsbG9wKTtcblxuICAgICAgICAgICAgICAgIGlmIChleGl0KSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnQxID0gZ2FsbG9wUmlnaHQoYXJyYXlbY3Vyc29yMl0sIHRtcCwgY3Vyc29yMSwgbGVuZ3RoMSwgMCwgY29tcGFyZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvdW50MSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvdW50MTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlbZGVzdCArIGldID0gdG1wW2N1cnNvcjEgKyBpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzdCArPSBjb3VudDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IxICs9IGNvdW50MTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aDEgLT0gY291bnQxO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxlbmd0aDEgPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYXJyYXlbZGVzdCsrXSA9IGFycmF5W2N1cnNvcjIrK107XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKC0tbGVuZ3RoMiA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGNvdW50MiA9IGdhbGxvcExlZnQodG1wW2N1cnNvcjFdLCBhcnJheSwgY3Vyc29yMiwgbGVuZ3RoMiwgMCwgY29tcGFyZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvdW50MiAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvdW50MjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlbZGVzdCArIGldID0gYXJyYXlbY3Vyc29yMiArIGldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXN0ICs9IGNvdW50MjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvcjIgKz0gY291bnQyO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoMiAtPSBjb3VudDI7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsZW5ndGgyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYXJyYXlbZGVzdCsrXSA9IHRtcFtjdXJzb3IxKytdO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICgtLWxlbmd0aDEgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBfbWluR2FsbG9wLS07XG4gICAgICAgICAgICAgICAgfSB3aGlsZSAoY291bnQxID49IERFRkFVTFRfTUlOX0dBTExPUElORyB8fCBjb3VudDIgPj0gREVGQVVMVF9NSU5fR0FMTE9QSU5HKTtcblxuICAgICAgICAgICAgICAgIGlmIChleGl0KSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChfbWluR2FsbG9wIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBfbWluR2FsbG9wID0gMDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfbWluR2FsbG9wICs9IDI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1pbkdhbGxvcCA9IF9taW5HYWxsb3A7XG5cbiAgICAgICAgICAgIG1pbkdhbGxvcCA8IDEgJiYgKG1pbkdhbGxvcCA9IDEpO1xuXG4gICAgICAgICAgICBpZiAobGVuZ3RoMSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGgyOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlbZGVzdCArIGldID0gYXJyYXlbY3Vyc29yMiArIGldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhcnJheVtkZXN0ICsgbGVuZ3RoMl0gPSB0bXBbY3Vyc29yMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChsZW5ndGgxID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgICAgICAgICAgICAgLy8gdGhyb3cgbmV3IEVycm9yKCdtZXJnZUxvdyBwcmVjb25kaXRpb25zIHdlcmUgbm90IHJlc3BlY3RlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDE7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBhcnJheVtkZXN0ICsgaV0gPSB0bXBbY3Vyc29yMSArIGldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG1lcmdlSGlnaCAoc3RhcnQxLCBsZW5ndGgxLCBzdGFydDIsIGxlbmd0aDIpIHtcbiAgICAgICAgICAgIHZhciBpID0gMDtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDI7IGkrKykge1xuICAgICAgICAgICAgICAgIHRtcFtpXSA9IGFycmF5W3N0YXJ0MiArIGldO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY3Vyc29yMSA9IHN0YXJ0MSArIGxlbmd0aDEgLSAxO1xuICAgICAgICAgICAgdmFyIGN1cnNvcjIgPSBsZW5ndGgyIC0gMTtcbiAgICAgICAgICAgIHZhciBkZXN0ID0gc3RhcnQyICsgbGVuZ3RoMiAtIDE7XG4gICAgICAgICAgICB2YXIgY3VzdG9tQ3Vyc29yID0gMDtcbiAgICAgICAgICAgIHZhciBjdXN0b21EZXN0ID0gMDtcblxuICAgICAgICAgICAgYXJyYXlbZGVzdC0tXSA9IGFycmF5W2N1cnNvcjEtLV07XG5cbiAgICAgICAgICAgIGlmICgtLWxlbmd0aDEgPT09IDApIHtcbiAgICAgICAgICAgICAgICBjdXN0b21DdXJzb3IgPSBkZXN0IC0gKGxlbmd0aDIgLSAxKTtcblxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGgyOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlbY3VzdG9tQ3Vyc29yICsgaV0gPSB0bXBbaV07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobGVuZ3RoMiA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGRlc3QgLT0gbGVuZ3RoMTtcbiAgICAgICAgICAgICAgICBjdXJzb3IxIC09IGxlbmd0aDE7XG4gICAgICAgICAgICAgICAgY3VzdG9tRGVzdCA9IGRlc3QgKyAxO1xuICAgICAgICAgICAgICAgIGN1c3RvbUN1cnNvciA9IGN1cnNvcjEgKyAxO1xuXG4gICAgICAgICAgICAgICAgZm9yIChpID0gbGVuZ3RoMSAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGFycmF5W2N1c3RvbURlc3QgKyBpXSA9IGFycmF5W2N1c3RvbUN1cnNvciArIGldO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGFycmF5W2Rlc3RdID0gdG1wW2N1cnNvcjJdO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIF9taW5HYWxsb3AgPSBtaW5HYWxsb3A7XG5cbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvdW50MSA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIGNvdW50MiA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIGV4aXQgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBhcmUodG1wW2N1cnNvcjJdLCBhcnJheVtjdXJzb3IxXSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJheVtkZXN0LS1dID0gYXJyYXlbY3Vyc29yMS0tXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50MSsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnQyID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgtLWxlbmd0aDEgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5W2Rlc3QtLV0gPSB0bXBbY3Vyc29yMi0tXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50MisrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnQxID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgtLWxlbmd0aDIgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gd2hpbGUgKChjb3VudDEgfCBjb3VudDIpIDwgX21pbkdhbGxvcCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZXhpdCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50MSA9IGxlbmd0aDEgLSBnYWxsb3BSaWdodCh0bXBbY3Vyc29yMl0sIGFycmF5LCBzdGFydDEsIGxlbmd0aDEsIGxlbmd0aDEgLSAxLCBjb21wYXJlKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoY291bnQxICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXN0IC09IGNvdW50MTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvcjEgLT0gY291bnQxO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoMSAtPSBjb3VudDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXN0b21EZXN0ID0gZGVzdCArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXN0b21DdXJzb3IgPSBjdXJzb3IxICsgMTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gY291bnQxIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJheVtjdXN0b21EZXN0ICsgaV0gPSBhcnJheVtjdXN0b21DdXJzb3IgKyBpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxlbmd0aDEgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGFycmF5W2Rlc3QtLV0gPSB0bXBbY3Vyc29yMi0tXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoLS1sZW5ndGgyID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY291bnQyID0gbGVuZ3RoMiAtIGdhbGxvcExlZnQoYXJyYXlbY3Vyc29yMV0sIHRtcCwgMCwgbGVuZ3RoMiwgbGVuZ3RoMiAtIDEsIGNvbXBhcmUpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3VudDIgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc3QgLT0gY291bnQyO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yMiAtPSBjb3VudDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGgyIC09IGNvdW50MjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1c3RvbURlc3QgPSBkZXN0ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1c3RvbUN1cnNvciA9IGN1cnNvcjIgKyAxO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQyOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJheVtjdXN0b21EZXN0ICsgaV0gPSB0bXBbY3VzdG9tQ3Vyc29yICsgaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsZW5ndGgyIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGFycmF5W2Rlc3QtLV0gPSBhcnJheVtjdXJzb3IxLS1dO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICgtLWxlbmd0aDEgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBfbWluR2FsbG9wLS07XG4gICAgICAgICAgICAgICAgfSB3aGlsZSAoY291bnQxID49IERFRkFVTFRfTUlOX0dBTExPUElORyB8fCBjb3VudDIgPj0gREVGQVVMVF9NSU5fR0FMTE9QSU5HKTtcblxuICAgICAgICAgICAgICAgIGlmIChleGl0KSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChfbWluR2FsbG9wIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBfbWluR2FsbG9wID0gMDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfbWluR2FsbG9wICs9IDI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1pbkdhbGxvcCA9IF9taW5HYWxsb3A7XG5cbiAgICAgICAgICAgIGlmIChtaW5HYWxsb3AgPCAxKSB7XG4gICAgICAgICAgICAgICAgbWluR2FsbG9wID0gMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGxlbmd0aDIgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBkZXN0IC09IGxlbmd0aDE7XG4gICAgICAgICAgICAgICAgY3Vyc29yMSAtPSBsZW5ndGgxO1xuICAgICAgICAgICAgICAgIGN1c3RvbURlc3QgPSBkZXN0ICsgMTtcbiAgICAgICAgICAgICAgICBjdXN0b21DdXJzb3IgPSBjdXJzb3IxICsgMTtcblxuICAgICAgICAgICAgICAgIGZvciAoaSA9IGxlbmd0aDEgLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICBhcnJheVtjdXN0b21EZXN0ICsgaV0gPSBhcnJheVtjdXN0b21DdXJzb3IgKyBpXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBhcnJheVtkZXN0XSA9IHRtcFtjdXJzb3IyXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGxlbmd0aDIgPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICAgICAgICAgICAgICAvLyB0aHJvdyBuZXcgRXJyb3IoJ21lcmdlSGlnaCBwcmVjb25kaXRpb25zIHdlcmUgbm90IHJlc3BlY3RlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY3VzdG9tQ3Vyc29yID0gZGVzdCAtIChsZW5ndGgyIC0gMSk7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDI7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBhcnJheVtjdXN0b21DdXJzb3IgKyBpXSA9IHRtcFtpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm1lcmdlUnVucyA9IG1lcmdlUnVucztcbiAgICAgICAgdGhpcy5mb3JjZU1lcmdlUnVucyA9IGZvcmNlTWVyZ2VSdW5zO1xuICAgICAgICB0aGlzLnB1c2hSdW4gPSBwdXNoUnVuO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNvcnQoYXJyYXksIGNvbXBhcmUsIGxvLCBoaSkge1xuICAgICAgICBpZiAoIWxvKSB7XG4gICAgICAgICAgICBsbyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFoaSkge1xuICAgICAgICAgICAgaGkgPSBhcnJheS5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVtYWluaW5nID0gaGkgLSBsbztcblxuICAgICAgICBpZiAocmVtYWluaW5nIDwgMikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJ1bkxlbmd0aCA9IDA7XG5cbiAgICAgICAgaWYgKHJlbWFpbmluZyA8IERFRkFVTFRfTUlOX01FUkdFKSB7XG4gICAgICAgICAgICBydW5MZW5ndGggPSBtYWtlQXNjZW5kaW5nUnVuKGFycmF5LCBsbywgaGksIGNvbXBhcmUpO1xuICAgICAgICAgICAgYmluYXJ5SW5zZXJ0aW9uU29ydChhcnJheSwgbG8sIGhpLCBsbyArIHJ1bkxlbmd0aCwgY29tcGFyZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdHMgPSBuZXcgVGltU29ydChhcnJheSwgY29tcGFyZSk7XG5cbiAgICAgICAgdmFyIG1pblJ1biA9IG1pblJ1bkxlbmd0aChyZW1haW5pbmcpO1xuXG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIHJ1bkxlbmd0aCA9IG1ha2VBc2NlbmRpbmdSdW4oYXJyYXksIGxvLCBoaSwgY29tcGFyZSk7XG4gICAgICAgICAgICBpZiAocnVuTGVuZ3RoIDwgbWluUnVuKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZvcmNlID0gcmVtYWluaW5nO1xuICAgICAgICAgICAgICAgIGlmIChmb3JjZSA+IG1pblJ1bikge1xuICAgICAgICAgICAgICAgICAgICBmb3JjZSA9IG1pblJ1bjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBiaW5hcnlJbnNlcnRpb25Tb3J0KGFycmF5LCBsbywgbG8gKyBmb3JjZSwgbG8gKyBydW5MZW5ndGgsIGNvbXBhcmUpO1xuICAgICAgICAgICAgICAgIHJ1bkxlbmd0aCA9IGZvcmNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0cy5wdXNoUnVuKGxvLCBydW5MZW5ndGgpO1xuICAgICAgICAgICAgdHMubWVyZ2VSdW5zKCk7XG5cbiAgICAgICAgICAgIHJlbWFpbmluZyAtPSBydW5MZW5ndGg7XG4gICAgICAgICAgICBsbyArPSBydW5MZW5ndGg7XG4gICAgICAgIH0gd2hpbGUgKHJlbWFpbmluZyAhPT0gMCk7XG5cbiAgICAgICAgdHMuZm9yY2VNZXJnZVJ1bnMoKTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHNvcnQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS95eC9+L3pyZW5kZXIvbGliL2NvcmUvdGltc29ydC5qc1xuLy8gbW9kdWxlIGlkID0gNDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 44 */
/* unknown exports provided */
/* all exports used */
/*!****************************************!*\
  !*** ./lib/chart/helper/SymbolDraw.js ***!
  \****************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * @module echarts/chart/helper/SymbolDraw\n */\n\n\n    var graphic = __webpack_require__(/*! ../../util/graphic */ 2);\n    var Symbol = __webpack_require__(/*! ./Symbol */ 55);\n\n    /**\n     * @constructor\n     * @alias module:echarts/chart/helper/SymbolDraw\n     * @param {module:zrender/graphic/Group} [symbolCtor]\n     */\n    function SymbolDraw(symbolCtor) {\n        this.group = new graphic.Group();\n\n        this._symbolCtor = symbolCtor || Symbol;\n    }\n\n    var symbolDrawProto = SymbolDraw.prototype;\n\n    function symbolNeedsDraw(data, idx, isIgnore) {\n        var point = data.getItemLayout(idx);\n        // Is an object\n        // if (point && point.hasOwnProperty('point')) {\n        //     point = point.point;\n        // }\n        return point && !isNaN(point[0]) && !isNaN(point[1]) && !(isIgnore && isIgnore(idx))\n                    && data.getItemVisual(idx, 'symbol') !== 'none';\n    }\n    /**\n     * Update symbols draw by new data\n     * @param {module:echarts/data/List} data\n     * @param {Array.<boolean>} [isIgnore]\n     */\n    symbolDrawProto.updateData = function (data, isIgnore) {\n        var group = this.group;\n        var seriesModel = data.hostModel;\n        var oldData = this._data;\n\n        var SymbolCtor = this._symbolCtor;\n\n        var seriesScope = {\n            itemStyle: seriesModel.getModel('itemStyle.normal').getItemStyle(['color']),\n            hoverItemStyle: seriesModel.getModel('itemStyle.emphasis').getItemStyle(),\n            symbolRotate: seriesModel.get('symbolRotate'),\n            symbolOffset: seriesModel.get('symbolOffset'),\n            hoverAnimation: seriesModel.get('hoverAnimation'),\n\n            labelModel: seriesModel.getModel('label.normal'),\n            hoverLabelModel: seriesModel.getModel('label.emphasis')\n        };\n\n        data.diff(oldData)\n            .add(function (newIdx) {\n                var point = data.getItemLayout(newIdx);\n                if (symbolNeedsDraw(data, newIdx, isIgnore)) {\n                    var symbolEl = new SymbolCtor(data, newIdx, seriesScope);\n                    symbolEl.attr('position', point);\n                    data.setItemGraphicEl(newIdx, symbolEl);\n                    group.add(symbolEl);\n                }\n            })\n            .update(function (newIdx, oldIdx) {\n                var symbolEl = oldData.getItemGraphicEl(oldIdx);\n                var point = data.getItemLayout(newIdx);\n                if (!symbolNeedsDraw(data, newIdx, isIgnore)) {\n                    group.remove(symbolEl);\n                    return;\n                }\n                if (!symbolEl) {\n                    symbolEl = new SymbolCtor(data, newIdx);\n                    symbolEl.attr('position', point);\n                }\n                else {\n                    symbolEl.updateData(data, newIdx, seriesScope);\n                    graphic.updateProps(symbolEl, {\n                        position: point\n                    }, seriesModel);\n                }\n\n                // Add back\n                group.add(symbolEl);\n\n                data.setItemGraphicEl(newIdx, symbolEl);\n            })\n            .remove(function (oldIdx) {\n                var el = oldData.getItemGraphicEl(oldIdx);\n                el && el.fadeOut(function () {\n                    group.remove(el);\n                });\n            })\n            .execute();\n\n        this._data = data;\n    };\n\n    symbolDrawProto.updateLayout = function () {\n        var data = this._data;\n        if (data) {\n            // Not use animation\n            data.eachItemGraphicEl(function (el, idx) {\n                var point = data.getItemLayout(idx);\n                el.attr('position', point);\n            });\n        }\n    };\n\n    symbolDrawProto.remove = function (enableAnimation) {\n        var group = this.group;\n        var data = this._data;\n        if (data) {\n            if (enableAnimation) {\n                data.eachItemGraphicEl(function (el) {\n                    el.fadeOut(function () {\n                        group.remove(el);\n                    });\n                });\n            }\n            else {\n                group.removeAll();\n            }\n        }\n    };\n\n    module.exports = SymbolDraw;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvY2hhcnQvaGVscGVyL1N5bWJvbERyYXcuanM/OWNhOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgZWNoYXJ0cy9jaGFydC9oZWxwZXIvU3ltYm9sRHJhd1xuICovXG5cblxuICAgIHZhciBncmFwaGljID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9ncmFwaGljJyk7XG4gICAgdmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vU3ltYm9sJyk7XG5cbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAYWxpYXMgbW9kdWxlOmVjaGFydHMvY2hhcnQvaGVscGVyL1N5bWJvbERyYXdcbiAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2dyYXBoaWMvR3JvdXB9IFtzeW1ib2xDdG9yXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFN5bWJvbERyYXcoc3ltYm9sQ3Rvcikge1xuICAgICAgICB0aGlzLmdyb3VwID0gbmV3IGdyYXBoaWMuR3JvdXAoKTtcblxuICAgICAgICB0aGlzLl9zeW1ib2xDdG9yID0gc3ltYm9sQ3RvciB8fCBTeW1ib2w7XG4gICAgfVxuXG4gICAgdmFyIHN5bWJvbERyYXdQcm90byA9IFN5bWJvbERyYXcucHJvdG90eXBlO1xuXG4gICAgZnVuY3Rpb24gc3ltYm9sTmVlZHNEcmF3KGRhdGEsIGlkeCwgaXNJZ25vcmUpIHtcbiAgICAgICAgdmFyIHBvaW50ID0gZGF0YS5nZXRJdGVtTGF5b3V0KGlkeCk7XG4gICAgICAgIC8vIElzIGFuIG9iamVjdFxuICAgICAgICAvLyBpZiAocG9pbnQgJiYgcG9pbnQuaGFzT3duUHJvcGVydHkoJ3BvaW50JykpIHtcbiAgICAgICAgLy8gICAgIHBvaW50ID0gcG9pbnQucG9pbnQ7XG4gICAgICAgIC8vIH1cbiAgICAgICAgcmV0dXJuIHBvaW50ICYmICFpc05hTihwb2ludFswXSkgJiYgIWlzTmFOKHBvaW50WzFdKSAmJiAhKGlzSWdub3JlICYmIGlzSWdub3JlKGlkeCkpXG4gICAgICAgICAgICAgICAgICAgICYmIGRhdGEuZ2V0SXRlbVZpc3VhbChpZHgsICdzeW1ib2wnKSAhPT0gJ25vbmUnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgc3ltYm9scyBkcmF3IGJ5IG5ldyBkYXRhXG4gICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9kYXRhL0xpc3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge0FycmF5Ljxib29sZWFuPn0gW2lzSWdub3JlXVxuICAgICAqL1xuICAgIHN5bWJvbERyYXdQcm90by51cGRhdGVEYXRhID0gZnVuY3Rpb24gKGRhdGEsIGlzSWdub3JlKSB7XG4gICAgICAgIHZhciBncm91cCA9IHRoaXMuZ3JvdXA7XG4gICAgICAgIHZhciBzZXJpZXNNb2RlbCA9IGRhdGEuaG9zdE1vZGVsO1xuICAgICAgICB2YXIgb2xkRGF0YSA9IHRoaXMuX2RhdGE7XG5cbiAgICAgICAgdmFyIFN5bWJvbEN0b3IgPSB0aGlzLl9zeW1ib2xDdG9yO1xuXG4gICAgICAgIHZhciBzZXJpZXNTY29wZSA9IHtcbiAgICAgICAgICAgIGl0ZW1TdHlsZTogc2VyaWVzTW9kZWwuZ2V0TW9kZWwoJ2l0ZW1TdHlsZS5ub3JtYWwnKS5nZXRJdGVtU3R5bGUoWydjb2xvciddKSxcbiAgICAgICAgICAgIGhvdmVySXRlbVN0eWxlOiBzZXJpZXNNb2RlbC5nZXRNb2RlbCgnaXRlbVN0eWxlLmVtcGhhc2lzJykuZ2V0SXRlbVN0eWxlKCksXG4gICAgICAgICAgICBzeW1ib2xSb3RhdGU6IHNlcmllc01vZGVsLmdldCgnc3ltYm9sUm90YXRlJyksXG4gICAgICAgICAgICBzeW1ib2xPZmZzZXQ6IHNlcmllc01vZGVsLmdldCgnc3ltYm9sT2Zmc2V0JyksXG4gICAgICAgICAgICBob3ZlckFuaW1hdGlvbjogc2VyaWVzTW9kZWwuZ2V0KCdob3ZlckFuaW1hdGlvbicpLFxuXG4gICAgICAgICAgICBsYWJlbE1vZGVsOiBzZXJpZXNNb2RlbC5nZXRNb2RlbCgnbGFiZWwubm9ybWFsJyksXG4gICAgICAgICAgICBob3ZlckxhYmVsTW9kZWw6IHNlcmllc01vZGVsLmdldE1vZGVsKCdsYWJlbC5lbXBoYXNpcycpXG4gICAgICAgIH07XG5cbiAgICAgICAgZGF0YS5kaWZmKG9sZERhdGEpXG4gICAgICAgICAgICAuYWRkKGZ1bmN0aW9uIChuZXdJZHgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcG9pbnQgPSBkYXRhLmdldEl0ZW1MYXlvdXQobmV3SWR4KTtcbiAgICAgICAgICAgICAgICBpZiAoc3ltYm9sTmVlZHNEcmF3KGRhdGEsIG5ld0lkeCwgaXNJZ25vcmUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzeW1ib2xFbCA9IG5ldyBTeW1ib2xDdG9yKGRhdGEsIG5ld0lkeCwgc2VyaWVzU2NvcGUpO1xuICAgICAgICAgICAgICAgICAgICBzeW1ib2xFbC5hdHRyKCdwb3NpdGlvbicsIHBvaW50KTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5zZXRJdGVtR3JhcGhpY0VsKG5ld0lkeCwgc3ltYm9sRWwpO1xuICAgICAgICAgICAgICAgICAgICBncm91cC5hZGQoc3ltYm9sRWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAudXBkYXRlKGZ1bmN0aW9uIChuZXdJZHgsIG9sZElkeCkge1xuICAgICAgICAgICAgICAgIHZhciBzeW1ib2xFbCA9IG9sZERhdGEuZ2V0SXRlbUdyYXBoaWNFbChvbGRJZHgpO1xuICAgICAgICAgICAgICAgIHZhciBwb2ludCA9IGRhdGEuZ2V0SXRlbUxheW91dChuZXdJZHgpO1xuICAgICAgICAgICAgICAgIGlmICghc3ltYm9sTmVlZHNEcmF3KGRhdGEsIG5ld0lkeCwgaXNJZ25vcmUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwLnJlbW92ZShzeW1ib2xFbCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFzeW1ib2xFbCkge1xuICAgICAgICAgICAgICAgICAgICBzeW1ib2xFbCA9IG5ldyBTeW1ib2xDdG9yKGRhdGEsIG5ld0lkeCk7XG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbEVsLmF0dHIoJ3Bvc2l0aW9uJywgcG9pbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sRWwudXBkYXRlRGF0YShkYXRhLCBuZXdJZHgsIHNlcmllc1Njb3BlKTtcbiAgICAgICAgICAgICAgICAgICAgZ3JhcGhpYy51cGRhdGVQcm9wcyhzeW1ib2xFbCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHBvaW50XG4gICAgICAgICAgICAgICAgICAgIH0sIHNlcmllc01vZGVsKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBBZGQgYmFja1xuICAgICAgICAgICAgICAgIGdyb3VwLmFkZChzeW1ib2xFbCk7XG5cbiAgICAgICAgICAgICAgICBkYXRhLnNldEl0ZW1HcmFwaGljRWwobmV3SWR4LCBzeW1ib2xFbCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnJlbW92ZShmdW5jdGlvbiAob2xkSWR4KSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsID0gb2xkRGF0YS5nZXRJdGVtR3JhcGhpY0VsKG9sZElkeCk7XG4gICAgICAgICAgICAgICAgZWwgJiYgZWwuZmFkZU91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwLnJlbW92ZShlbCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmV4ZWN1dGUoKTtcblxuICAgICAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgICB9O1xuXG4gICAgc3ltYm9sRHJhd1Byb3RvLnVwZGF0ZUxheW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xuICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgLy8gTm90IHVzZSBhbmltYXRpb25cbiAgICAgICAgICAgIGRhdGEuZWFjaEl0ZW1HcmFwaGljRWwoZnVuY3Rpb24gKGVsLCBpZHgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcG9pbnQgPSBkYXRhLmdldEl0ZW1MYXlvdXQoaWR4KTtcbiAgICAgICAgICAgICAgICBlbC5hdHRyKCdwb3NpdGlvbicsIHBvaW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHN5bWJvbERyYXdQcm90by5yZW1vdmUgPSBmdW5jdGlvbiAoZW5hYmxlQW5pbWF0aW9uKSB7XG4gICAgICAgIHZhciBncm91cCA9IHRoaXMuZ3JvdXA7XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcbiAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgIGlmIChlbmFibGVBbmltYXRpb24pIHtcbiAgICAgICAgICAgICAgICBkYXRhLmVhY2hJdGVtR3JhcGhpY0VsKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgICAgICAgICBlbC5mYWRlT3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwLnJlbW92ZShlbCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZ3JvdXAucmVtb3ZlQWxsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBTeW1ib2xEcmF3O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvY2hhcnQvaGVscGVyL1N5bWJvbERyYXcuanNcbi8vIG1vZHVsZSBpZCA9IDQ0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 45 */
/* unknown exports provided */
/* all exports used */
/*!**************************************************!*\
  !*** ./lib/component/axisPointer/modelHelper.js ***!
  \**************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 0);\n    var Model = __webpack_require__(/*! ../../model/Model */ 9);\n    var each = zrUtil.each;\n    var curry = zrUtil.curry;\n\n    var helper = {};\n\n    // Build axisPointerModel, mergin tooltip.axisPointer model for each axis.\n    // allAxesInfo should be updated when setOption performed.\n    helper.collect = function (ecModel, api) {\n        var result = {\n            /**\n             * key: makeKey(axis.model)\n             * value: {\n             *      axis,\n             *      coordSys,\n             *      axisPointerModel,\n             *      triggerTooltip,\n             *      involveSeries,\n             *      snap,\n             *      seriesModels,\n             *      seriesDataCount\n             * }\n             */\n            axesInfo: {},\n            seriesInvolved: false,\n            /**\n             * key: makeKey(coordSys.model)\n             * value: Object: key makeKey(axis.model), value: axisInfo\n             */\n            coordSysAxesInfo: {},\n            coordSysMap: {}\n        };\n\n        collectAxesInfo(result, ecModel, api);\n\n        // Check seriesInvolved for performance, in case too many series in some chart.\n        result.seriesInvolved && collectSeriesInfo(result, ecModel);\n\n        return result;\n    };\n\n    function collectAxesInfo(result, ecModel, api) {\n        var globalTooltipModel = ecModel.getComponent('tooltip');\n        var globalAxisPointerModel = ecModel.getComponent('axisPointer');\n        // links can only be set on global.\n        var linksOption = globalAxisPointerModel.get('link', true) || [];\n        var linkGroups = [];\n\n        // Collect axes info.\n        each(api.getCoordinateSystems(), function (coordSys) {\n            // Some coordinate system do not support axes, like geo.\n            if (!coordSys.axisPointerEnabled) {\n                return;\n            }\n\n            var coordSysKey = makeKey(coordSys.model);\n            var axesInfoInCoordSys = result.coordSysAxesInfo[coordSysKey] = {};\n            result.coordSysMap[coordSysKey] = coordSys;\n\n            // Set tooltip (like 'cross') is a convienent way to show axisPointer\n            // for user. So we enable seting tooltip on coordSys model.\n            var coordSysModel = coordSys.model;\n            var baseTooltipModel = coordSysModel.getModel('tooltip', globalTooltipModel);\n\n            each(coordSys.getAxes(), curry(saveTooltipAxisInfo, false, null));\n\n            // If axis tooltip used, choose tooltip axis for each coordSys.\n            // Notice this case: coordSys is `grid` but not `cartesian2D` here.\n            if (coordSys.getTooltipAxes\n                && globalTooltipModel\n                // If tooltip.showContent is set as false, tooltip will not\n                // show but axisPointer will show as normal.\n                && baseTooltipModel.get('show')\n            ) {\n                // Compatible with previous logic. But series.tooltip.trigger: 'axis'\n                // or series.data[n].tooltip.trigger: 'axis' are not support any more.\n                var triggerAxis = baseTooltipModel.get('trigger') === 'axis';\n                var cross = baseTooltipModel.get('axisPointer.type') === 'cross';\n                var tooltipAxes = coordSys.getTooltipAxes(baseTooltipModel.get('axisPointer.axis'));\n                if (triggerAxis || cross) {\n                    each(tooltipAxes.baseAxes, curry(\n                        saveTooltipAxisInfo, cross ? 'cross' : true, triggerAxis\n                    ));\n                }\n                if (cross) {\n                    each(tooltipAxes.otherAxes, curry(saveTooltipAxisInfo, 'cross', false));\n                }\n            }\n\n            // fromTooltip: true | false | 'cross'\n            // triggerTooltip: true | false | null\n            function saveTooltipAxisInfo(fromTooltip, triggerTooltip, axis) {\n                var axisPointerModel = axis.model.getModel('axisPointer', globalAxisPointerModel);\n\n                var axisPointerShow = axisPointerModel.get('show');\n                if (!axisPointerShow || (\n                    axisPointerShow === 'auto'\n                    && !fromTooltip\n                    && !isHandleTrigger(axisPointerModel)\n                )) {\n                    return;\n                }\n\n                if (triggerTooltip == null) {\n                    triggerTooltip = axisPointerModel.get('triggerTooltip');\n                }\n\n                axisPointerModel = fromTooltip\n                    ? makeAxisPointerModel(\n                        axis, baseTooltipModel, globalAxisPointerModel, ecModel,\n                        fromTooltip, triggerTooltip\n                    )\n                    : axisPointerModel;\n\n                var snap = axisPointerModel.get('snap');\n                var key = makeKey(axis.model);\n                var involveSeries = triggerTooltip || snap || axis.type === 'category';\n\n                // If result.axesInfo[key] exist, override it (tooltip has higher priority).\n                var axisInfo = result.axesInfo[key] = {\n                    key: key,\n                    axis: axis,\n                    coordSys: coordSys,\n                    axisPointerModel: axisPointerModel,\n                    triggerTooltip: triggerTooltip,\n                    involveSeries: involveSeries,\n                    snap: snap,\n                    useHandle: isHandleTrigger(axisPointerModel),\n                    seriesModels: []\n                };\n                axesInfoInCoordSys[key] = axisInfo;\n                result.seriesInvolved |= involveSeries;\n\n                var groupIndex = getLinkGroupIndex(linksOption, axis);\n                if (groupIndex != null) {\n                    var linkGroup = linkGroups[groupIndex] || (linkGroups[groupIndex] = {axesInfo: {}});\n                    linkGroup.axesInfo[key] = axisInfo;\n                    linkGroup.mapper = linksOption[groupIndex].mapper;\n                    axisInfo.linkGroup = linkGroup;\n                }\n            }\n        });\n    }\n\n    function makeAxisPointerModel(\n        axis, baseTooltipModel, globalAxisPointerModel, ecModel, fromTooltip, triggerTooltip\n    ) {\n        var tooltipAxisPointerModel = baseTooltipModel.getModel('axisPointer');\n        var volatileOption = {};\n\n        each(\n            [\n                'type', 'snap', 'lineStyle', 'shadowStyle', 'label',\n                'animation', 'animationDurationUpdate', 'animationEasingUpdate', 'z'\n            ],\n            function (field) {\n                volatileOption[field] = zrUtil.clone(tooltipAxisPointerModel.get(field));\n            }\n        );\n\n        // category axis do not auto snap, otherwise some tick that do not\n        // has value can not be hovered. value/time/log axis default snap if\n        // triggered from tooltip and trigger tooltip.\n        volatileOption.snap = axis.type !== 'category' && !!triggerTooltip;\n\n        // Compatibel with previous behavior, tooltip axis do not show label by default.\n        // Only these properties can be overrided from tooltip to axisPointer.\n        if (tooltipAxisPointerModel.get('type') === 'cross') {\n            volatileOption.type = 'line';\n        }\n        var labelOption = volatileOption.label || (volatileOption.label = {});\n        // Follow the convention, do not show label when triggered by tooltip by default.\n        labelOption.show == null && (labelOption.show = false);\n\n        if (fromTooltip === 'cross') {\n            // When 'cross', both axes show labels.\n            labelOption.show = true;\n            // If triggerTooltip, this is a base axis, which should better not use cross style\n            // (cross style is dashed by default)\n            if (!triggerTooltip) {\n                var crossStyle = volatileOption.lineStyle = tooltipAxisPointerModel.get('crossStyle');\n                crossStyle && zrUtil.defaults(\n                    labelOption.textStyle || (labelOption.textStyle = {}),\n                    crossStyle.textStyle\n                );\n            }\n        }\n\n        return axis.model.getModel(\n            'axisPointer',\n            new Model(volatileOption, globalAxisPointerModel, ecModel)\n        );\n    }\n\n    function collectSeriesInfo(result, ecModel) {\n        // Prepare data for axis trigger\n        ecModel.eachSeries(function (seriesModel) {\n\n            // Notice this case: this coordSys is `cartesian2D` but not `grid`.\n            var coordSys = seriesModel.coordinateSystem;\n            var seriesTooltipTrigger = seriesModel.get('tooltip.trigger', true);\n            if (!coordSys\n                || seriesTooltipTrigger === 'none'\n                || seriesTooltipTrigger === false\n                || seriesTooltipTrigger === 'item'\n                || seriesModel.get('axisPointer.show', true) === false\n            ) {\n                return;\n            }\n\n            each(result.coordSysAxesInfo[makeKey(coordSys.model)], function (axisInfo) {\n                var axis = axisInfo.axis;\n                if (coordSys.getAxis(axis.dim) === axis) {\n                    axisInfo.seriesModels.push(seriesModel);\n                    axisInfo.seriesDataCount == null && (axisInfo.seriesDataCount = 0);\n                    axisInfo.seriesDataCount += seriesModel.getData().count();\n                }\n            });\n\n        }, this);\n    }\n\n    /**\n     * For example:\n     * {\n     *     axisPointer: {\n     *         links: [{\n     *             xAxisIndex: [2, 4],\n     *             yAxisIndex: 'all'\n     *         }, {\n     *             xAxisId: ['a5', 'a7'],\n     *             xAxisName: 'xxx'\n     *         }]\n     *     }\n     * }\n     */\n    function getLinkGroupIndex(linksOption, axis) {\n        var axisModel = axis.model;\n        var dim = axis.dim;\n        for (var i = 0; i < linksOption.length; i++) {\n            var linkOption = linksOption[i] || {};\n            if (checkPropInLink(linkOption[dim + 'AxisId'], axisModel.id)\n                || checkPropInLink(linkOption[dim + 'AxisIndex'], axisModel.componentIndex)\n                || checkPropInLink(linkOption[dim + 'AxisName'], axisModel.name)\n            ) {\n                return i;\n            }\n        }\n    }\n\n    function checkPropInLink(linkPropValue, axisPropValue) {\n        return linkPropValue === 'all'\n            || (zrUtil.isArray(linkPropValue) && zrUtil.indexOf(linkPropValue, axisPropValue) >= 0)\n            || linkPropValue === axisPropValue;\n    }\n\n    helper.fixValue = function (axisModel) {\n        var axisInfo = helper.getAxisInfo(axisModel);\n        if (!axisInfo) {\n            return;\n        }\n\n        var axisPointerModel = axisInfo.axisPointerModel;\n        var scale = axisInfo.axis.scale;\n        var option = axisPointerModel.option;\n        var status = axisPointerModel.get('status');\n        var value = axisPointerModel.get('value');\n\n        // Parse init value for category and time axis.\n        if (value != null) {\n            value = scale.parse(value);\n        }\n\n        var useHandle = isHandleTrigger(axisPointerModel);\n        // If `handle` used, `axisPointer` will always be displayed, so value\n        // and status should be initialized.\n        if (status == null) {\n            option.status = useHandle ? 'show' : 'hide';\n        }\n\n        var extent = scale.getExtent().slice();\n        extent[0] > extent[1] && extent.reverse();\n\n        if (// Pick a value on axis when initializing.\n            value == null\n            // If both `handle` and `dataZoom` are used, value may be out of axis extent,\n            // where we should re-pick a value to keep `handle` displaying normally.\n            || value > extent[1]\n        ) {\n            // Make handle displayed on the end of the axis when init, which looks better.\n            value = extent[1];\n        }\n        if (value < extent[0]) {\n            value = extent[0];\n        }\n\n        option.value = value;\n\n        if (useHandle) {\n            option.status = axisInfo.axis.scale.isBlank() ? 'hide' : 'show';\n        }\n    };\n\n    helper.getAxisInfo = function (axisModel) {\n        var coordSysAxesInfo = (axisModel.ecModel.getComponent('axisPointer') || {}).coordSysAxesInfo;\n        return coordSysAxesInfo && coordSysAxesInfo.axesInfo[makeKey(axisModel)];\n    };\n\n    helper.getAxisPointerModel = function (axisModel) {\n        var axisInfo = helper.getAxisInfo(axisModel);\n        return axisInfo && axisInfo.axisPointerModel;\n    };\n\n    function isHandleTrigger(axisPointerModel) {\n        return !!axisPointerModel.get('handle.show');\n    }\n\n    /**\n     * @param {module:echarts/model/Model} model\n     * @return {string} unique key\n     */\n    var makeKey = helper.makeKey = function (model) {\n        return model.type + '||' + model.id;\n    };\n\n    module.exports = helper;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvY29tcG9uZW50L2F4aXNQb2ludGVyL21vZGVsSGVscGVyLmpzP2U4N2UiXSwic291cmNlc0NvbnRlbnQiOlsiXG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG4gICAgdmFyIE1vZGVsID0gcmVxdWlyZSgnLi4vLi4vbW9kZWwvTW9kZWwnKTtcbiAgICB2YXIgZWFjaCA9IHpyVXRpbC5lYWNoO1xuICAgIHZhciBjdXJyeSA9IHpyVXRpbC5jdXJyeTtcblxuICAgIHZhciBoZWxwZXIgPSB7fTtcblxuICAgIC8vIEJ1aWxkIGF4aXNQb2ludGVyTW9kZWwsIG1lcmdpbiB0b29sdGlwLmF4aXNQb2ludGVyIG1vZGVsIGZvciBlYWNoIGF4aXMuXG4gICAgLy8gYWxsQXhlc0luZm8gc2hvdWxkIGJlIHVwZGF0ZWQgd2hlbiBzZXRPcHRpb24gcGVyZm9ybWVkLlxuICAgIGhlbHBlci5jb2xsZWN0ID0gZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBrZXk6IG1ha2VLZXkoYXhpcy5tb2RlbClcbiAgICAgICAgICAgICAqIHZhbHVlOiB7XG4gICAgICAgICAgICAgKiAgICAgIGF4aXMsXG4gICAgICAgICAgICAgKiAgICAgIGNvb3JkU3lzLFxuICAgICAgICAgICAgICogICAgICBheGlzUG9pbnRlck1vZGVsLFxuICAgICAgICAgICAgICogICAgICB0cmlnZ2VyVG9vbHRpcCxcbiAgICAgICAgICAgICAqICAgICAgaW52b2x2ZVNlcmllcyxcbiAgICAgICAgICAgICAqICAgICAgc25hcCxcbiAgICAgICAgICAgICAqICAgICAgc2VyaWVzTW9kZWxzLFxuICAgICAgICAgICAgICogICAgICBzZXJpZXNEYXRhQ291bnRcbiAgICAgICAgICAgICAqIH1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgYXhlc0luZm86IHt9LFxuICAgICAgICAgICAgc2VyaWVzSW52b2x2ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBrZXk6IG1ha2VLZXkoY29vcmRTeXMubW9kZWwpXG4gICAgICAgICAgICAgKiB2YWx1ZTogT2JqZWN0OiBrZXkgbWFrZUtleShheGlzLm1vZGVsKSwgdmFsdWU6IGF4aXNJbmZvXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNvb3JkU3lzQXhlc0luZm86IHt9LFxuICAgICAgICAgICAgY29vcmRTeXNNYXA6IHt9XG4gICAgICAgIH07XG5cbiAgICAgICAgY29sbGVjdEF4ZXNJbmZvKHJlc3VsdCwgZWNNb2RlbCwgYXBpKTtcblxuICAgICAgICAvLyBDaGVjayBzZXJpZXNJbnZvbHZlZCBmb3IgcGVyZm9ybWFuY2UsIGluIGNhc2UgdG9vIG1hbnkgc2VyaWVzIGluIHNvbWUgY2hhcnQuXG4gICAgICAgIHJlc3VsdC5zZXJpZXNJbnZvbHZlZCAmJiBjb2xsZWN0U2VyaWVzSW5mbyhyZXN1bHQsIGVjTW9kZWwpO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGNvbGxlY3RBeGVzSW5mbyhyZXN1bHQsIGVjTW9kZWwsIGFwaSkge1xuICAgICAgICB2YXIgZ2xvYmFsVG9vbHRpcE1vZGVsID0gZWNNb2RlbC5nZXRDb21wb25lbnQoJ3Rvb2x0aXAnKTtcbiAgICAgICAgdmFyIGdsb2JhbEF4aXNQb2ludGVyTW9kZWwgPSBlY01vZGVsLmdldENvbXBvbmVudCgnYXhpc1BvaW50ZXInKTtcbiAgICAgICAgLy8gbGlua3MgY2FuIG9ubHkgYmUgc2V0IG9uIGdsb2JhbC5cbiAgICAgICAgdmFyIGxpbmtzT3B0aW9uID0gZ2xvYmFsQXhpc1BvaW50ZXJNb2RlbC5nZXQoJ2xpbmsnLCB0cnVlKSB8fCBbXTtcbiAgICAgICAgdmFyIGxpbmtHcm91cHMgPSBbXTtcblxuICAgICAgICAvLyBDb2xsZWN0IGF4ZXMgaW5mby5cbiAgICAgICAgZWFjaChhcGkuZ2V0Q29vcmRpbmF0ZVN5c3RlbXMoKSwgZnVuY3Rpb24gKGNvb3JkU3lzKSB7XG4gICAgICAgICAgICAvLyBTb21lIGNvb3JkaW5hdGUgc3lzdGVtIGRvIG5vdCBzdXBwb3J0IGF4ZXMsIGxpa2UgZ2VvLlxuICAgICAgICAgICAgaWYgKCFjb29yZFN5cy5heGlzUG9pbnRlckVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBjb29yZFN5c0tleSA9IG1ha2VLZXkoY29vcmRTeXMubW9kZWwpO1xuICAgICAgICAgICAgdmFyIGF4ZXNJbmZvSW5Db29yZFN5cyA9IHJlc3VsdC5jb29yZFN5c0F4ZXNJbmZvW2Nvb3JkU3lzS2V5XSA9IHt9O1xuICAgICAgICAgICAgcmVzdWx0LmNvb3JkU3lzTWFwW2Nvb3JkU3lzS2V5XSA9IGNvb3JkU3lzO1xuXG4gICAgICAgICAgICAvLyBTZXQgdG9vbHRpcCAobGlrZSAnY3Jvc3MnKSBpcyBhIGNvbnZpZW5lbnQgd2F5IHRvIHNob3cgYXhpc1BvaW50ZXJcbiAgICAgICAgICAgIC8vIGZvciB1c2VyLiBTbyB3ZSBlbmFibGUgc2V0aW5nIHRvb2x0aXAgb24gY29vcmRTeXMgbW9kZWwuXG4gICAgICAgICAgICB2YXIgY29vcmRTeXNNb2RlbCA9IGNvb3JkU3lzLm1vZGVsO1xuICAgICAgICAgICAgdmFyIGJhc2VUb29sdGlwTW9kZWwgPSBjb29yZFN5c01vZGVsLmdldE1vZGVsKCd0b29sdGlwJywgZ2xvYmFsVG9vbHRpcE1vZGVsKTtcblxuICAgICAgICAgICAgZWFjaChjb29yZFN5cy5nZXRBeGVzKCksIGN1cnJ5KHNhdmVUb29sdGlwQXhpc0luZm8sIGZhbHNlLCBudWxsKSk7XG5cbiAgICAgICAgICAgIC8vIElmIGF4aXMgdG9vbHRpcCB1c2VkLCBjaG9vc2UgdG9vbHRpcCBheGlzIGZvciBlYWNoIGNvb3JkU3lzLlxuICAgICAgICAgICAgLy8gTm90aWNlIHRoaXMgY2FzZTogY29vcmRTeXMgaXMgYGdyaWRgIGJ1dCBub3QgYGNhcnRlc2lhbjJEYCBoZXJlLlxuICAgICAgICAgICAgaWYgKGNvb3JkU3lzLmdldFRvb2x0aXBBeGVzXG4gICAgICAgICAgICAgICAgJiYgZ2xvYmFsVG9vbHRpcE1vZGVsXG4gICAgICAgICAgICAgICAgLy8gSWYgdG9vbHRpcC5zaG93Q29udGVudCBpcyBzZXQgYXMgZmFsc2UsIHRvb2x0aXAgd2lsbCBub3RcbiAgICAgICAgICAgICAgICAvLyBzaG93IGJ1dCBheGlzUG9pbnRlciB3aWxsIHNob3cgYXMgbm9ybWFsLlxuICAgICAgICAgICAgICAgICYmIGJhc2VUb29sdGlwTW9kZWwuZ2V0KCdzaG93JylcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIC8vIENvbXBhdGlibGUgd2l0aCBwcmV2aW91cyBsb2dpYy4gQnV0IHNlcmllcy50b29sdGlwLnRyaWdnZXI6ICdheGlzJ1xuICAgICAgICAgICAgICAgIC8vIG9yIHNlcmllcy5kYXRhW25dLnRvb2x0aXAudHJpZ2dlcjogJ2F4aXMnIGFyZSBub3Qgc3VwcG9ydCBhbnkgbW9yZS5cbiAgICAgICAgICAgICAgICB2YXIgdHJpZ2dlckF4aXMgPSBiYXNlVG9vbHRpcE1vZGVsLmdldCgndHJpZ2dlcicpID09PSAnYXhpcyc7XG4gICAgICAgICAgICAgICAgdmFyIGNyb3NzID0gYmFzZVRvb2x0aXBNb2RlbC5nZXQoJ2F4aXNQb2ludGVyLnR5cGUnKSA9PT0gJ2Nyb3NzJztcbiAgICAgICAgICAgICAgICB2YXIgdG9vbHRpcEF4ZXMgPSBjb29yZFN5cy5nZXRUb29sdGlwQXhlcyhiYXNlVG9vbHRpcE1vZGVsLmdldCgnYXhpc1BvaW50ZXIuYXhpcycpKTtcbiAgICAgICAgICAgICAgICBpZiAodHJpZ2dlckF4aXMgfHwgY3Jvc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgZWFjaCh0b29sdGlwQXhlcy5iYXNlQXhlcywgY3VycnkoXG4gICAgICAgICAgICAgICAgICAgICAgICBzYXZlVG9vbHRpcEF4aXNJbmZvLCBjcm9zcyA/ICdjcm9zcycgOiB0cnVlLCB0cmlnZ2VyQXhpc1xuICAgICAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNyb3NzKSB7XG4gICAgICAgICAgICAgICAgICAgIGVhY2godG9vbHRpcEF4ZXMub3RoZXJBeGVzLCBjdXJyeShzYXZlVG9vbHRpcEF4aXNJbmZvLCAnY3Jvc3MnLCBmYWxzZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZnJvbVRvb2x0aXA6IHRydWUgfCBmYWxzZSB8ICdjcm9zcydcbiAgICAgICAgICAgIC8vIHRyaWdnZXJUb29sdGlwOiB0cnVlIHwgZmFsc2UgfCBudWxsXG4gICAgICAgICAgICBmdW5jdGlvbiBzYXZlVG9vbHRpcEF4aXNJbmZvKGZyb21Ub29sdGlwLCB0cmlnZ2VyVG9vbHRpcCwgYXhpcykge1xuICAgICAgICAgICAgICAgIHZhciBheGlzUG9pbnRlck1vZGVsID0gYXhpcy5tb2RlbC5nZXRNb2RlbCgnYXhpc1BvaW50ZXInLCBnbG9iYWxBeGlzUG9pbnRlck1vZGVsKTtcblxuICAgICAgICAgICAgICAgIHZhciBheGlzUG9pbnRlclNob3cgPSBheGlzUG9pbnRlck1vZGVsLmdldCgnc2hvdycpO1xuICAgICAgICAgICAgICAgIGlmICghYXhpc1BvaW50ZXJTaG93IHx8IChcbiAgICAgICAgICAgICAgICAgICAgYXhpc1BvaW50ZXJTaG93ID09PSAnYXV0bydcbiAgICAgICAgICAgICAgICAgICAgJiYgIWZyb21Ub29sdGlwXG4gICAgICAgICAgICAgICAgICAgICYmICFpc0hhbmRsZVRyaWdnZXIoYXhpc1BvaW50ZXJNb2RlbClcbiAgICAgICAgICAgICAgICApKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodHJpZ2dlclRvb2x0aXAgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyVG9vbHRpcCA9IGF4aXNQb2ludGVyTW9kZWwuZ2V0KCd0cmlnZ2VyVG9vbHRpcCcpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGF4aXNQb2ludGVyTW9kZWwgPSBmcm9tVG9vbHRpcFxuICAgICAgICAgICAgICAgICAgICA/IG1ha2VBeGlzUG9pbnRlck1vZGVsKFxuICAgICAgICAgICAgICAgICAgICAgICAgYXhpcywgYmFzZVRvb2x0aXBNb2RlbCwgZ2xvYmFsQXhpc1BvaW50ZXJNb2RlbCwgZWNNb2RlbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyb21Ub29sdGlwLCB0cmlnZ2VyVG9vbHRpcFxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIDogYXhpc1BvaW50ZXJNb2RlbDtcblxuICAgICAgICAgICAgICAgIHZhciBzbmFwID0gYXhpc1BvaW50ZXJNb2RlbC5nZXQoJ3NuYXAnKTtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gbWFrZUtleShheGlzLm1vZGVsKTtcbiAgICAgICAgICAgICAgICB2YXIgaW52b2x2ZVNlcmllcyA9IHRyaWdnZXJUb29sdGlwIHx8IHNuYXAgfHwgYXhpcy50eXBlID09PSAnY2F0ZWdvcnknO1xuXG4gICAgICAgICAgICAgICAgLy8gSWYgcmVzdWx0LmF4ZXNJbmZvW2tleV0gZXhpc3QsIG92ZXJyaWRlIGl0ICh0b29sdGlwIGhhcyBoaWdoZXIgcHJpb3JpdHkpLlxuICAgICAgICAgICAgICAgIHZhciBheGlzSW5mbyA9IHJlc3VsdC5heGVzSW5mb1trZXldID0ge1xuICAgICAgICAgICAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICAgICAgICAgICAgYXhpczogYXhpcyxcbiAgICAgICAgICAgICAgICAgICAgY29vcmRTeXM6IGNvb3JkU3lzLFxuICAgICAgICAgICAgICAgICAgICBheGlzUG9pbnRlck1vZGVsOiBheGlzUG9pbnRlck1vZGVsLFxuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyVG9vbHRpcDogdHJpZ2dlclRvb2x0aXAsXG4gICAgICAgICAgICAgICAgICAgIGludm9sdmVTZXJpZXM6IGludm9sdmVTZXJpZXMsXG4gICAgICAgICAgICAgICAgICAgIHNuYXA6IHNuYXAsXG4gICAgICAgICAgICAgICAgICAgIHVzZUhhbmRsZTogaXNIYW5kbGVUcmlnZ2VyKGF4aXNQb2ludGVyTW9kZWwpLFxuICAgICAgICAgICAgICAgICAgICBzZXJpZXNNb2RlbHM6IFtdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBheGVzSW5mb0luQ29vcmRTeXNba2V5XSA9IGF4aXNJbmZvO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zZXJpZXNJbnZvbHZlZCB8PSBpbnZvbHZlU2VyaWVzO1xuXG4gICAgICAgICAgICAgICAgdmFyIGdyb3VwSW5kZXggPSBnZXRMaW5rR3JvdXBJbmRleChsaW5rc09wdGlvbiwgYXhpcyk7XG4gICAgICAgICAgICAgICAgaWYgKGdyb3VwSW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGlua0dyb3VwID0gbGlua0dyb3Vwc1tncm91cEluZGV4XSB8fCAobGlua0dyb3Vwc1tncm91cEluZGV4XSA9IHtheGVzSW5mbzoge319KTtcbiAgICAgICAgICAgICAgICAgICAgbGlua0dyb3VwLmF4ZXNJbmZvW2tleV0gPSBheGlzSW5mbztcbiAgICAgICAgICAgICAgICAgICAgbGlua0dyb3VwLm1hcHBlciA9IGxpbmtzT3B0aW9uW2dyb3VwSW5kZXhdLm1hcHBlcjtcbiAgICAgICAgICAgICAgICAgICAgYXhpc0luZm8ubGlua0dyb3VwID0gbGlua0dyb3VwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUF4aXNQb2ludGVyTW9kZWwoXG4gICAgICAgIGF4aXMsIGJhc2VUb29sdGlwTW9kZWwsIGdsb2JhbEF4aXNQb2ludGVyTW9kZWwsIGVjTW9kZWwsIGZyb21Ub29sdGlwLCB0cmlnZ2VyVG9vbHRpcFxuICAgICkge1xuICAgICAgICB2YXIgdG9vbHRpcEF4aXNQb2ludGVyTW9kZWwgPSBiYXNlVG9vbHRpcE1vZGVsLmdldE1vZGVsKCdheGlzUG9pbnRlcicpO1xuICAgICAgICB2YXIgdm9sYXRpbGVPcHRpb24gPSB7fTtcblxuICAgICAgICBlYWNoKFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICd0eXBlJywgJ3NuYXAnLCAnbGluZVN0eWxlJywgJ3NoYWRvd1N0eWxlJywgJ2xhYmVsJyxcbiAgICAgICAgICAgICAgICAnYW5pbWF0aW9uJywgJ2FuaW1hdGlvbkR1cmF0aW9uVXBkYXRlJywgJ2FuaW1hdGlvbkVhc2luZ1VwZGF0ZScsICd6J1xuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgICAgICAgICAgIHZvbGF0aWxlT3B0aW9uW2ZpZWxkXSA9IHpyVXRpbC5jbG9uZSh0b29sdGlwQXhpc1BvaW50ZXJNb2RlbC5nZXQoZmllbGQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcblxuICAgICAgICAvLyBjYXRlZ29yeSBheGlzIGRvIG5vdCBhdXRvIHNuYXAsIG90aGVyd2lzZSBzb21lIHRpY2sgdGhhdCBkbyBub3RcbiAgICAgICAgLy8gaGFzIHZhbHVlIGNhbiBub3QgYmUgaG92ZXJlZC4gdmFsdWUvdGltZS9sb2cgYXhpcyBkZWZhdWx0IHNuYXAgaWZcbiAgICAgICAgLy8gdHJpZ2dlcmVkIGZyb20gdG9vbHRpcCBhbmQgdHJpZ2dlciB0b29sdGlwLlxuICAgICAgICB2b2xhdGlsZU9wdGlvbi5zbmFwID0gYXhpcy50eXBlICE9PSAnY2F0ZWdvcnknICYmICEhdHJpZ2dlclRvb2x0aXA7XG5cbiAgICAgICAgLy8gQ29tcGF0aWJlbCB3aXRoIHByZXZpb3VzIGJlaGF2aW9yLCB0b29sdGlwIGF4aXMgZG8gbm90IHNob3cgbGFiZWwgYnkgZGVmYXVsdC5cbiAgICAgICAgLy8gT25seSB0aGVzZSBwcm9wZXJ0aWVzIGNhbiBiZSBvdmVycmlkZWQgZnJvbSB0b29sdGlwIHRvIGF4aXNQb2ludGVyLlxuICAgICAgICBpZiAodG9vbHRpcEF4aXNQb2ludGVyTW9kZWwuZ2V0KCd0eXBlJykgPT09ICdjcm9zcycpIHtcbiAgICAgICAgICAgIHZvbGF0aWxlT3B0aW9uLnR5cGUgPSAnbGluZSc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxhYmVsT3B0aW9uID0gdm9sYXRpbGVPcHRpb24ubGFiZWwgfHwgKHZvbGF0aWxlT3B0aW9uLmxhYmVsID0ge30pO1xuICAgICAgICAvLyBGb2xsb3cgdGhlIGNvbnZlbnRpb24sIGRvIG5vdCBzaG93IGxhYmVsIHdoZW4gdHJpZ2dlcmVkIGJ5IHRvb2x0aXAgYnkgZGVmYXVsdC5cbiAgICAgICAgbGFiZWxPcHRpb24uc2hvdyA9PSBudWxsICYmIChsYWJlbE9wdGlvbi5zaG93ID0gZmFsc2UpO1xuXG4gICAgICAgIGlmIChmcm9tVG9vbHRpcCA9PT0gJ2Nyb3NzJykge1xuICAgICAgICAgICAgLy8gV2hlbiAnY3Jvc3MnLCBib3RoIGF4ZXMgc2hvdyBsYWJlbHMuXG4gICAgICAgICAgICBsYWJlbE9wdGlvbi5zaG93ID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIElmIHRyaWdnZXJUb29sdGlwLCB0aGlzIGlzIGEgYmFzZSBheGlzLCB3aGljaCBzaG91bGQgYmV0dGVyIG5vdCB1c2UgY3Jvc3Mgc3R5bGVcbiAgICAgICAgICAgIC8vIChjcm9zcyBzdHlsZSBpcyBkYXNoZWQgYnkgZGVmYXVsdClcbiAgICAgICAgICAgIGlmICghdHJpZ2dlclRvb2x0aXApIHtcbiAgICAgICAgICAgICAgICB2YXIgY3Jvc3NTdHlsZSA9IHZvbGF0aWxlT3B0aW9uLmxpbmVTdHlsZSA9IHRvb2x0aXBBeGlzUG9pbnRlck1vZGVsLmdldCgnY3Jvc3NTdHlsZScpO1xuICAgICAgICAgICAgICAgIGNyb3NzU3R5bGUgJiYgenJVdGlsLmRlZmF1bHRzKFxuICAgICAgICAgICAgICAgICAgICBsYWJlbE9wdGlvbi50ZXh0U3R5bGUgfHwgKGxhYmVsT3B0aW9uLnRleHRTdHlsZSA9IHt9KSxcbiAgICAgICAgICAgICAgICAgICAgY3Jvc3NTdHlsZS50ZXh0U3R5bGVcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF4aXMubW9kZWwuZ2V0TW9kZWwoXG4gICAgICAgICAgICAnYXhpc1BvaW50ZXInLFxuICAgICAgICAgICAgbmV3IE1vZGVsKHZvbGF0aWxlT3B0aW9uLCBnbG9iYWxBeGlzUG9pbnRlck1vZGVsLCBlY01vZGVsKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbGxlY3RTZXJpZXNJbmZvKHJlc3VsdCwgZWNNb2RlbCkge1xuICAgICAgICAvLyBQcmVwYXJlIGRhdGEgZm9yIGF4aXMgdHJpZ2dlclxuICAgICAgICBlY01vZGVsLmVhY2hTZXJpZXMoZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG5cbiAgICAgICAgICAgIC8vIE5vdGljZSB0aGlzIGNhc2U6IHRoaXMgY29vcmRTeXMgaXMgYGNhcnRlc2lhbjJEYCBidXQgbm90IGBncmlkYC5cbiAgICAgICAgICAgIHZhciBjb29yZFN5cyA9IHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG4gICAgICAgICAgICB2YXIgc2VyaWVzVG9vbHRpcFRyaWdnZXIgPSBzZXJpZXNNb2RlbC5nZXQoJ3Rvb2x0aXAudHJpZ2dlcicsIHRydWUpO1xuICAgICAgICAgICAgaWYgKCFjb29yZFN5c1xuICAgICAgICAgICAgICAgIHx8IHNlcmllc1Rvb2x0aXBUcmlnZ2VyID09PSAnbm9uZSdcbiAgICAgICAgICAgICAgICB8fCBzZXJpZXNUb29sdGlwVHJpZ2dlciA9PT0gZmFsc2VcbiAgICAgICAgICAgICAgICB8fCBzZXJpZXNUb29sdGlwVHJpZ2dlciA9PT0gJ2l0ZW0nXG4gICAgICAgICAgICAgICAgfHwgc2VyaWVzTW9kZWwuZ2V0KCdheGlzUG9pbnRlci5zaG93JywgdHJ1ZSkgPT09IGZhbHNlXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVhY2gocmVzdWx0LmNvb3JkU3lzQXhlc0luZm9bbWFrZUtleShjb29yZFN5cy5tb2RlbCldLCBmdW5jdGlvbiAoYXhpc0luZm8pIHtcbiAgICAgICAgICAgICAgICB2YXIgYXhpcyA9IGF4aXNJbmZvLmF4aXM7XG4gICAgICAgICAgICAgICAgaWYgKGNvb3JkU3lzLmdldEF4aXMoYXhpcy5kaW0pID09PSBheGlzKSB7XG4gICAgICAgICAgICAgICAgICAgIGF4aXNJbmZvLnNlcmllc01vZGVscy5wdXNoKHNlcmllc01vZGVsKTtcbiAgICAgICAgICAgICAgICAgICAgYXhpc0luZm8uc2VyaWVzRGF0YUNvdW50ID09IG51bGwgJiYgKGF4aXNJbmZvLnNlcmllc0RhdGFDb3VudCA9IDApO1xuICAgICAgICAgICAgICAgICAgICBheGlzSW5mby5zZXJpZXNEYXRhQ291bnQgKz0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpLmNvdW50KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRm9yIGV4YW1wbGU6XG4gICAgICoge1xuICAgICAqICAgICBheGlzUG9pbnRlcjoge1xuICAgICAqICAgICAgICAgbGlua3M6IFt7XG4gICAgICogICAgICAgICAgICAgeEF4aXNJbmRleDogWzIsIDRdLFxuICAgICAqICAgICAgICAgICAgIHlBeGlzSW5kZXg6ICdhbGwnXG4gICAgICogICAgICAgICB9LCB7XG4gICAgICogICAgICAgICAgICAgeEF4aXNJZDogWydhNScsICdhNyddLFxuICAgICAqICAgICAgICAgICAgIHhBeGlzTmFtZTogJ3h4eCdcbiAgICAgKiAgICAgICAgIH1dXG4gICAgICogICAgIH1cbiAgICAgKiB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0TGlua0dyb3VwSW5kZXgobGlua3NPcHRpb24sIGF4aXMpIHtcbiAgICAgICAgdmFyIGF4aXNNb2RlbCA9IGF4aXMubW9kZWw7XG4gICAgICAgIHZhciBkaW0gPSBheGlzLmRpbTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5rc09wdGlvbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGxpbmtPcHRpb24gPSBsaW5rc09wdGlvbltpXSB8fCB7fTtcbiAgICAgICAgICAgIGlmIChjaGVja1Byb3BJbkxpbmsobGlua09wdGlvbltkaW0gKyAnQXhpc0lkJ10sIGF4aXNNb2RlbC5pZClcbiAgICAgICAgICAgICAgICB8fCBjaGVja1Byb3BJbkxpbmsobGlua09wdGlvbltkaW0gKyAnQXhpc0luZGV4J10sIGF4aXNNb2RlbC5jb21wb25lbnRJbmRleClcbiAgICAgICAgICAgICAgICB8fCBjaGVja1Byb3BJbkxpbmsobGlua09wdGlvbltkaW0gKyAnQXhpc05hbWUnXSwgYXhpc01vZGVsLm5hbWUpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNoZWNrUHJvcEluTGluayhsaW5rUHJvcFZhbHVlLCBheGlzUHJvcFZhbHVlKSB7XG4gICAgICAgIHJldHVybiBsaW5rUHJvcFZhbHVlID09PSAnYWxsJ1xuICAgICAgICAgICAgfHwgKHpyVXRpbC5pc0FycmF5KGxpbmtQcm9wVmFsdWUpICYmIHpyVXRpbC5pbmRleE9mKGxpbmtQcm9wVmFsdWUsIGF4aXNQcm9wVmFsdWUpID49IDApXG4gICAgICAgICAgICB8fCBsaW5rUHJvcFZhbHVlID09PSBheGlzUHJvcFZhbHVlO1xuICAgIH1cblxuICAgIGhlbHBlci5maXhWYWx1ZSA9IGZ1bmN0aW9uIChheGlzTW9kZWwpIHtcbiAgICAgICAgdmFyIGF4aXNJbmZvID0gaGVscGVyLmdldEF4aXNJbmZvKGF4aXNNb2RlbCk7XG4gICAgICAgIGlmICghYXhpc0luZm8pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBheGlzUG9pbnRlck1vZGVsID0gYXhpc0luZm8uYXhpc1BvaW50ZXJNb2RlbDtcbiAgICAgICAgdmFyIHNjYWxlID0gYXhpc0luZm8uYXhpcy5zY2FsZTtcbiAgICAgICAgdmFyIG9wdGlvbiA9IGF4aXNQb2ludGVyTW9kZWwub3B0aW9uO1xuICAgICAgICB2YXIgc3RhdHVzID0gYXhpc1BvaW50ZXJNb2RlbC5nZXQoJ3N0YXR1cycpO1xuICAgICAgICB2YXIgdmFsdWUgPSBheGlzUG9pbnRlck1vZGVsLmdldCgndmFsdWUnKTtcblxuICAgICAgICAvLyBQYXJzZSBpbml0IHZhbHVlIGZvciBjYXRlZ29yeSBhbmQgdGltZSBheGlzLlxuICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFsdWUgPSBzY2FsZS5wYXJzZSh2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdXNlSGFuZGxlID0gaXNIYW5kbGVUcmlnZ2VyKGF4aXNQb2ludGVyTW9kZWwpO1xuICAgICAgICAvLyBJZiBgaGFuZGxlYCB1c2VkLCBgYXhpc1BvaW50ZXJgIHdpbGwgYWx3YXlzIGJlIGRpc3BsYXllZCwgc28gdmFsdWVcbiAgICAgICAgLy8gYW5kIHN0YXR1cyBzaG91bGQgYmUgaW5pdGlhbGl6ZWQuXG4gICAgICAgIGlmIChzdGF0dXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgb3B0aW9uLnN0YXR1cyA9IHVzZUhhbmRsZSA/ICdzaG93JyA6ICdoaWRlJztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBleHRlbnQgPSBzY2FsZS5nZXRFeHRlbnQoKS5zbGljZSgpO1xuICAgICAgICBleHRlbnRbMF0gPiBleHRlbnRbMV0gJiYgZXh0ZW50LnJldmVyc2UoKTtcblxuICAgICAgICBpZiAoLy8gUGljayBhIHZhbHVlIG9uIGF4aXMgd2hlbiBpbml0aWFsaXppbmcuXG4gICAgICAgICAgICB2YWx1ZSA9PSBudWxsXG4gICAgICAgICAgICAvLyBJZiBib3RoIGBoYW5kbGVgIGFuZCBgZGF0YVpvb21gIGFyZSB1c2VkLCB2YWx1ZSBtYXkgYmUgb3V0IG9mIGF4aXMgZXh0ZW50LFxuICAgICAgICAgICAgLy8gd2hlcmUgd2Ugc2hvdWxkIHJlLXBpY2sgYSB2YWx1ZSB0byBrZWVwIGBoYW5kbGVgIGRpc3BsYXlpbmcgbm9ybWFsbHkuXG4gICAgICAgICAgICB8fCB2YWx1ZSA+IGV4dGVudFsxXVxuICAgICAgICApIHtcbiAgICAgICAgICAgIC8vIE1ha2UgaGFuZGxlIGRpc3BsYXllZCBvbiB0aGUgZW5kIG9mIHRoZSBheGlzIHdoZW4gaW5pdCwgd2hpY2ggbG9va3MgYmV0dGVyLlxuICAgICAgICAgICAgdmFsdWUgPSBleHRlbnRbMV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlIDwgZXh0ZW50WzBdKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGV4dGVudFswXTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9wdGlvbi52YWx1ZSA9IHZhbHVlO1xuXG4gICAgICAgIGlmICh1c2VIYW5kbGUpIHtcbiAgICAgICAgICAgIG9wdGlvbi5zdGF0dXMgPSBheGlzSW5mby5heGlzLnNjYWxlLmlzQmxhbmsoKSA/ICdoaWRlJyA6ICdzaG93JztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBoZWxwZXIuZ2V0QXhpc0luZm8gPSBmdW5jdGlvbiAoYXhpc01vZGVsKSB7XG4gICAgICAgIHZhciBjb29yZFN5c0F4ZXNJbmZvID0gKGF4aXNNb2RlbC5lY01vZGVsLmdldENvbXBvbmVudCgnYXhpc1BvaW50ZXInKSB8fCB7fSkuY29vcmRTeXNBeGVzSW5mbztcbiAgICAgICAgcmV0dXJuIGNvb3JkU3lzQXhlc0luZm8gJiYgY29vcmRTeXNBeGVzSW5mby5heGVzSW5mb1ttYWtlS2V5KGF4aXNNb2RlbCldO1xuICAgIH07XG5cbiAgICBoZWxwZXIuZ2V0QXhpc1BvaW50ZXJNb2RlbCA9IGZ1bmN0aW9uIChheGlzTW9kZWwpIHtcbiAgICAgICAgdmFyIGF4aXNJbmZvID0gaGVscGVyLmdldEF4aXNJbmZvKGF4aXNNb2RlbCk7XG4gICAgICAgIHJldHVybiBheGlzSW5mbyAmJiBheGlzSW5mby5heGlzUG9pbnRlck1vZGVsO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBpc0hhbmRsZVRyaWdnZXIoYXhpc1BvaW50ZXJNb2RlbCkge1xuICAgICAgICByZXR1cm4gISFheGlzUG9pbnRlck1vZGVsLmdldCgnaGFuZGxlLnNob3cnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBtb2RlbFxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gdW5pcXVlIGtleVxuICAgICAqL1xuICAgIHZhciBtYWtlS2V5ID0gaGVscGVyLm1ha2VLZXkgPSBmdW5jdGlvbiAobW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIG1vZGVsLnR5cGUgKyAnfHwnICsgbW9kZWwuaWQ7XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gaGVscGVyO1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9jb21wb25lbnQvYXhpc1BvaW50ZXIvbW9kZWxIZWxwZXIuanNcbi8vIG1vZHVsZSBpZCA9IDQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 46 */
/* unknown exports provided */
/* all exports used */
/*!*************************************************!*\
  !*** ./lib/component/dataZoom/DataZoomModel.js ***!
  \*************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * @file Data zoom model\n */\n\n\n    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 0);\n    var env = __webpack_require__(/*! zrender/lib/core/env */ 8);\n    var echarts = __webpack_require__(/*! ../../echarts */ 1);\n    var modelUtil = __webpack_require__(/*! ../../util/model */ 5);\n    var helper = __webpack_require__(/*! ./helper */ 82);\n    var AxisProxy = __webpack_require__(/*! ./AxisProxy */ 209);\n    var each = zrUtil.each;\n    var eachAxisDim = helper.eachAxisDim;\n\n    var DataZoomModel = echarts.extendComponentModel({\n\n        type: 'dataZoom',\n\n        dependencies: [\n            'xAxis', 'yAxis', 'zAxis', 'radiusAxis', 'angleAxis', 'singleAxis', 'series'\n        ],\n\n        /**\n         * @protected\n         */\n        defaultOption: {\n            zlevel: 0,\n            z: 4,                   // Higher than normal component (z: 2).\n            orient: null,           // Default auto by axisIndex. Possible value: 'horizontal', 'vertical'.\n            xAxisIndex: null,       // Default the first horizontal category axis.\n            yAxisIndex: null,       // Default the first vertical category axis.\n\n            filterMode: 'filter',   // Possible values: 'filter' or 'empty'.\n                                    // 'filter': data items which are out of window will be removed.\n                                    //           This option is applicable when filtering outliers.\n                                    // 'empty': data items which are out of window will be set to empty.\n                                    //          This option is applicable when user should not neglect\n                                    //          that there are some data items out of window.\n                                    // Taking line chart as an example, line will be broken in\n                                    // the filtered points when filterModel is set to 'empty', but\n                                    // be connected when set to 'filter'.\n\n            throttle: null,         // Dispatch action by the fixed rate, avoid frequency.\n                                    // default 100. Do not throttle when use null/undefined.\n                                    // If animation === true and animationDurationUpdate > 0,\n                                    // default value is 100, otherwise 20.\n            start: 0,               // Start percent. 0 ~ 100\n            end: 100,               // End percent. 0 ~ 100\n            startValue: null,       // Start value. If startValue specified, start is ignored.\n            endValue: null          // End value. If endValue specified, end is ignored.\n        },\n\n        /**\n         * @override\n         */\n        init: function (option, parentModel, ecModel) {\n\n            /**\n             * key like x_0, y_1\n             * @private\n             * @type {Object}\n             */\n            this._dataIntervalByAxis = {};\n\n            /**\n             * @private\n             */\n            this._dataInfo = {};\n\n            /**\n             * key like x_0, y_1\n             * @private\n             */\n            this._axisProxies = {};\n\n            /**\n             * @readOnly\n             */\n            this.textStyleModel;\n\n            /**\n             * @private\n             */\n            this._autoThrottle = true;\n\n            /**\n             * 'percent' or 'value'\n             * @private\n             */\n            this._rangePropMode = ['percent', 'percent'];\n\n            var rawOption = retrieveRaw(option);\n\n            this.mergeDefaultAndTheme(option, ecModel);\n\n            this.doInit(rawOption);\n        },\n\n        /**\n         * @override\n         */\n        mergeOption: function (newOption) {\n            var rawOption = retrieveRaw(newOption);\n\n            //FIX #2591\n            zrUtil.merge(this.option, newOption, true);\n\n            this.doInit(rawOption);\n        },\n\n        /**\n         * @protected\n         */\n        doInit: function (rawOption) {\n            var thisOption = this.option;\n\n            // Disable realtime view update if canvas is not supported.\n            if (!env.canvasSupported) {\n                thisOption.realtime = false;\n            }\n\n            this._setDefaultThrottle(rawOption);\n\n            updateRangeUse(this, rawOption);\n\n            each([['start', 'startValue'], ['end', 'endValue']], function (names, index) {\n                // start/end has higher priority over startValue/endValue if they\n                // both set, but we should make chart.setOption({endValue: 1000})\n                // effective, rather than chart.setOption({endValue: 1000, end: null}).\n                if (this._rangePropMode[index] === 'value') {\n                    thisOption[names[0]] = null;\n                }\n                // Otherwise do nothing and use the merge result.\n            }, this);\n\n            this.textStyleModel = this.getModel('textStyle');\n\n            this._resetTarget();\n\n            this._giveAxisProxies();\n        },\n\n        /**\n         * @private\n         */\n        _giveAxisProxies: function () {\n            var axisProxies = this._axisProxies;\n\n            this.eachTargetAxis(function (dimNames, axisIndex, dataZoomModel, ecModel) {\n                var axisModel = this.dependentModels[dimNames.axis][axisIndex];\n\n                // If exists, share axisProxy with other dataZoomModels.\n                var axisProxy = axisModel.__dzAxisProxy || (\n                    // Use the first dataZoomModel as the main model of axisProxy.\n                    axisModel.__dzAxisProxy = new AxisProxy(\n                        dimNames.name, axisIndex, this, ecModel\n                    )\n                );\n                // FIXME\n                // dispose __dzAxisProxy\n\n                axisProxies[dimNames.name + '_' + axisIndex] = axisProxy;\n            }, this);\n        },\n\n        /**\n         * @private\n         */\n        _resetTarget: function () {\n            var thisOption = this.option;\n\n            var autoMode = this._judgeAutoMode();\n\n            eachAxisDim(function (dimNames) {\n                var axisIndexName = dimNames.axisIndex;\n                thisOption[axisIndexName] = modelUtil.normalizeToArray(\n                    thisOption[axisIndexName]\n                );\n            }, this);\n\n            if (autoMode === 'axisIndex') {\n                this._autoSetAxisIndex();\n            }\n            else if (autoMode === 'orient') {\n                this._autoSetOrient();\n            }\n        },\n\n        /**\n         * @private\n         */\n        _judgeAutoMode: function () {\n            // Auto set only works for setOption at the first time.\n            // The following is user's reponsibility. So using merged\n            // option is OK.\n            var thisOption = this.option;\n\n            var hasIndexSpecified = false;\n            eachAxisDim(function (dimNames) {\n                // When user set axisIndex as a empty array, we think that user specify axisIndex\n                // but do not want use auto mode. Because empty array may be encountered when\n                // some error occured.\n                if (thisOption[dimNames.axisIndex] != null) {\n                    hasIndexSpecified = true;\n                }\n            }, this);\n\n            var orient = thisOption.orient;\n\n            if (orient == null && hasIndexSpecified) {\n                return 'orient';\n            }\n            else if (!hasIndexSpecified) {\n                if (orient == null) {\n                    thisOption.orient = 'horizontal';\n                }\n                return 'axisIndex';\n            }\n        },\n\n        /**\n         * @private\n         */\n        _autoSetAxisIndex: function () {\n            var autoAxisIndex = true;\n            var orient = this.get('orient', true);\n            var thisOption = this.option;\n            var dependentModels = this.dependentModels;\n\n            if (autoAxisIndex) {\n                // Find axis that parallel to dataZoom as default.\n                var dimName = orient === 'vertical' ? 'y' : 'x';\n\n                if (dependentModels[dimName + 'Axis'].length) {\n                    thisOption[dimName + 'AxisIndex'] = [0];\n                    autoAxisIndex = false;\n                }\n                else {\n                    each(dependentModels.singleAxis, function (singleAxisModel) {\n                        if (autoAxisIndex && singleAxisModel.get('orient', true) === orient) {\n                            thisOption.singleAxisIndex = [singleAxisModel.componentIndex];\n                            autoAxisIndex = false;\n                        }\n                    });\n                }\n            }\n\n            if (autoAxisIndex) {\n                // Find the first category axis as default. (consider polar)\n                eachAxisDim(function (dimNames) {\n                    if (!autoAxisIndex) {\n                        return;\n                    }\n                    var axisIndices = [];\n                    var axisModels = this.dependentModels[dimNames.axis];\n                    if (axisModels.length && !axisIndices.length) {\n                        for (var i = 0, len = axisModels.length; i < len; i++) {\n                            if (axisModels[i].get('type') === 'category') {\n                                axisIndices.push(i);\n                            }\n                        }\n                    }\n                    thisOption[dimNames.axisIndex] = axisIndices;\n                    if (axisIndices.length) {\n                        autoAxisIndex = false;\n                    }\n                }, this);\n            }\n\n            if (autoAxisIndex) {\n                // FIXME\n                // 这里是兼容ec2的写法（没指定xAxisIndex和yAxisIndex时把scatter和双数值轴折柱纳入dataZoom控制），\n                // 但是实际是否需要Grid.js#getScaleByOption来判断（考虑time，log等axis type）？\n\n                // If both dataZoom.xAxisIndex and dataZoom.yAxisIndex is not specified,\n                // dataZoom component auto adopts series that reference to\n                // both xAxis and yAxis which type is 'value'.\n                this.ecModel.eachSeries(function (seriesModel) {\n                    if (this._isSeriesHasAllAxesTypeOf(seriesModel, 'value')) {\n                        eachAxisDim(function (dimNames) {\n                            var axisIndices = thisOption[dimNames.axisIndex];\n\n                            var axisIndex = seriesModel.get(dimNames.axisIndex);\n                            var axisId = seriesModel.get(dimNames.axisId);\n\n                            var axisModel = seriesModel.ecModel.queryComponents({\n                                mainType: dimNames.axis,\n                                index: axisIndex,\n                                id: axisId\n                            })[0];\n\n                            if (true) {\n                                if (!axisModel) {\n                                    throw new Error(\n                                        dimNames.axis + ' \"' + zrUtil.retrieve(\n                                            axisIndex,\n                                            axisId,\n                                            0\n                                        ) + '\" not found'\n                                    );\n                                }\n                            }\n                            axisIndex = axisModel.componentIndex;\n\n                            if (zrUtil.indexOf(axisIndices, axisIndex) < 0) {\n                                axisIndices.push(axisIndex);\n                            }\n                        });\n                    }\n                }, this);\n            }\n        },\n\n        /**\n         * @private\n         */\n        _autoSetOrient: function () {\n            var dim;\n\n            // Find the first axis\n            this.eachTargetAxis(function (dimNames) {\n                !dim && (dim = dimNames.name);\n            }, this);\n\n            this.option.orient = dim === 'y' ? 'vertical' : 'horizontal';\n        },\n\n        /**\n         * @private\n         */\n        _isSeriesHasAllAxesTypeOf: function (seriesModel, axisType) {\n            // FIXME\n            // 需要series的xAxisIndex和yAxisIndex都首先自动设置上。\n            // 例如series.type === scatter时。\n\n            var is = true;\n            eachAxisDim(function (dimNames) {\n                var seriesAxisIndex = seriesModel.get(dimNames.axisIndex);\n                var axisModel = this.dependentModels[dimNames.axis][seriesAxisIndex];\n\n                if (!axisModel || axisModel.get('type') !== axisType) {\n                    is = false;\n                }\n            }, this);\n            return is;\n        },\n\n        /**\n         * @private\n         */\n        _setDefaultThrottle: function (rawOption) {\n            // When first time user set throttle, auto throttle ends.\n            if (rawOption.hasOwnProperty('throttle')) {\n                this._autoThrottle = false;\n            }\n            if (this._autoThrottle) {\n                var globalOption = this.ecModel.option;\n                this.option.throttle =\n                    (globalOption.animation && globalOption.animationDurationUpdate > 0)\n                    ? 100 : 20;\n            }\n        },\n\n        /**\n         * @public\n         */\n        getFirstTargetAxisModel: function () {\n            var firstAxisModel;\n            eachAxisDim(function (dimNames) {\n                if (firstAxisModel == null) {\n                    var indices = this.get(dimNames.axisIndex);\n                    if (indices.length) {\n                        firstAxisModel = this.dependentModels[dimNames.axis][indices[0]];\n                    }\n                }\n            }, this);\n\n            return firstAxisModel;\n        },\n\n        /**\n         * @public\n         * @param {Function} callback param: axisModel, dimNames, axisIndex, dataZoomModel, ecModel\n         */\n        eachTargetAxis: function (callback, context) {\n            var ecModel = this.ecModel;\n            eachAxisDim(function (dimNames) {\n                each(\n                    this.get(dimNames.axisIndex),\n                    function (axisIndex) {\n                        callback.call(context, dimNames, axisIndex, this, ecModel);\n                    },\n                    this\n                );\n            }, this);\n        },\n\n        /**\n         * @param {string} dimName\n         * @param {number} axisIndex\n         * @return {module:echarts/component/dataZoom/AxisProxy} If not found, return null/undefined.\n         */\n        getAxisProxy: function (dimName, axisIndex) {\n            return this._axisProxies[dimName + '_' + axisIndex];\n        },\n\n        /**\n         * @param {string} dimName\n         * @param {number} axisIndex\n         * @return {module:echarts/model/Model} If not found, return null/undefined.\n         */\n        getAxisModel: function (dimName, axisIndex) {\n            var axisProxy = this.getAxisProxy(dimName, axisIndex);\n            return axisProxy && axisProxy.getAxisModel();\n        },\n\n        /**\n         * If not specified, set to undefined.\n         *\n         * @public\n         * @param {Object} opt\n         * @param {number} [opt.start]\n         * @param {number} [opt.end]\n         * @param {number} [opt.startValue]\n         * @param {number} [opt.endValue]\n         * @param {boolean} [ignoreUpdateRangeUsg=false]\n         */\n        setRawRange: function (opt, ignoreUpdateRangeUsg) {\n            each(['start', 'end', 'startValue', 'endValue'], function (name) {\n                // If any of those prop is null/undefined, we should alos set\n                // them, because only one pair between start/end and\n                // startValue/endValue can work.\n                this.option[name] = opt[name];\n            }, this);\n\n            !ignoreUpdateRangeUsg && updateRangeUse(this, opt);\n        },\n\n        /**\n         * @public\n         * @return {Array.<number>} [startPercent, endPercent]\n         */\n        getPercentRange: function () {\n            var axisProxy = this.findRepresentativeAxisProxy();\n            if (axisProxy) {\n                return axisProxy.getDataPercentWindow();\n            }\n        },\n\n        /**\n         * @public\n         * For example, chart.getModel().getComponent('dataZoom').getValueRange('y', 0);\n         *\n         * @param {string} [axisDimName]\n         * @param {number} [axisIndex]\n         * @return {Array.<number>} [startValue, endValue] value can only be '-' or finite number.\n         */\n        getValueRange: function (axisDimName, axisIndex) {\n            if (axisDimName == null && axisIndex == null) {\n                var axisProxy = this.findRepresentativeAxisProxy();\n                if (axisProxy) {\n                    return axisProxy.getDataValueWindow();\n                }\n            }\n            else {\n                return this.getAxisProxy(axisDimName, axisIndex).getDataValueWindow();\n            }\n        },\n\n        /**\n         * @public\n         * @return {module:echarts/component/dataZoom/AxisProxy}\n         */\n        findRepresentativeAxisProxy: function () {\n            // Find the first hosted axisProxy\n            var axisProxies = this._axisProxies;\n            for (var key in axisProxies) {\n                if (axisProxies.hasOwnProperty(key) && axisProxies[key].hostedBy(this)) {\n                    return axisProxies[key];\n                }\n            }\n\n            // If no hosted axis find not hosted axisProxy.\n            // Consider this case: dataZoomModel1 and dataZoomModel2 control the same axis,\n            // and the option.start or option.end settings are different. The percentRange\n            // should follow axisProxy.\n            // (We encounter this problem in toolbox data zoom.)\n            for (var key in axisProxies) {\n                if (axisProxies.hasOwnProperty(key) && !axisProxies[key].hostedBy(this)) {\n                    return axisProxies[key];\n                }\n            }\n        },\n\n        /**\n         * @return {Array.<string>}\n         */\n        getRangePropMode: function () {\n            return this._rangePropMode.slice();\n        }\n    });\n\n    function retrieveRaw(option) {\n        var ret = {};\n        each(\n            ['start', 'end', 'startValue', 'endValue', 'throttle'],\n            function (name) {\n                option.hasOwnProperty(name) && (ret[name] = option[name]);\n            }\n        );\n        return ret;\n    }\n\n    function updateRangeUse(dataZoomModel, rawOption) {\n        each([['start', 'startValue'], ['end', 'endValue']], function (names, index) {\n            var rangePropMode = dataZoomModel._rangePropMode;\n            if (rawOption[names[0]] != null) {\n                rangePropMode[index] = 'percent';\n            }\n            else if (rawOption[names[1]] != null) {\n                rangePropMode[index] = 'value';\n            }\n            // else remain its original setting.\n        });\n    }\n\n    module.exports = DataZoomModel;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvY29tcG9uZW50L2RhdGFab29tL0RhdGFab29tTW9kZWwuanM/MThlMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlIERhdGEgem9vbSBtb2RlbFxuICovXG5cblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgZW52ID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS9lbnYnKTtcbiAgICB2YXIgZWNoYXJ0cyA9IHJlcXVpcmUoJy4uLy4uL2VjaGFydHMnKTtcbiAgICB2YXIgbW9kZWxVdGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9tb2RlbCcpO1xuICAgIHZhciBoZWxwZXIgPSByZXF1aXJlKCcuL2hlbHBlcicpO1xuICAgIHZhciBBeGlzUHJveHkgPSByZXF1aXJlKCcuL0F4aXNQcm94eScpO1xuICAgIHZhciBlYWNoID0genJVdGlsLmVhY2g7XG4gICAgdmFyIGVhY2hBeGlzRGltID0gaGVscGVyLmVhY2hBeGlzRGltO1xuXG4gICAgdmFyIERhdGFab29tTW9kZWwgPSBlY2hhcnRzLmV4dGVuZENvbXBvbmVudE1vZGVsKHtcblxuICAgICAgICB0eXBlOiAnZGF0YVpvb20nLFxuXG4gICAgICAgIGRlcGVuZGVuY2llczogW1xuICAgICAgICAgICAgJ3hBeGlzJywgJ3lBeGlzJywgJ3pBeGlzJywgJ3JhZGl1c0F4aXMnLCAnYW5nbGVBeGlzJywgJ3NpbmdsZUF4aXMnLCAnc2VyaWVzJ1xuICAgICAgICBdLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBkZWZhdWx0T3B0aW9uOiB7XG4gICAgICAgICAgICB6bGV2ZWw6IDAsXG4gICAgICAgICAgICB6OiA0LCAgICAgICAgICAgICAgICAgICAvLyBIaWdoZXIgdGhhbiBub3JtYWwgY29tcG9uZW50ICh6OiAyKS5cbiAgICAgICAgICAgIG9yaWVudDogbnVsbCwgICAgICAgICAgIC8vIERlZmF1bHQgYXV0byBieSBheGlzSW5kZXguIFBvc3NpYmxlIHZhbHVlOiAnaG9yaXpvbnRhbCcsICd2ZXJ0aWNhbCcuXG4gICAgICAgICAgICB4QXhpc0luZGV4OiBudWxsLCAgICAgICAvLyBEZWZhdWx0IHRoZSBmaXJzdCBob3Jpem9udGFsIGNhdGVnb3J5IGF4aXMuXG4gICAgICAgICAgICB5QXhpc0luZGV4OiBudWxsLCAgICAgICAvLyBEZWZhdWx0IHRoZSBmaXJzdCB2ZXJ0aWNhbCBjYXRlZ29yeSBheGlzLlxuXG4gICAgICAgICAgICBmaWx0ZXJNb2RlOiAnZmlsdGVyJywgICAvLyBQb3NzaWJsZSB2YWx1ZXM6ICdmaWx0ZXInIG9yICdlbXB0eScuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAnZmlsdGVyJzogZGF0YSBpdGVtcyB3aGljaCBhcmUgb3V0IG9mIHdpbmRvdyB3aWxsIGJlIHJlbW92ZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgVGhpcyBvcHRpb24gaXMgYXBwbGljYWJsZSB3aGVuIGZpbHRlcmluZyBvdXRsaWVycy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICdlbXB0eSc6IGRhdGEgaXRlbXMgd2hpY2ggYXJlIG91dCBvZiB3aW5kb3cgd2lsbCBiZSBzZXQgdG8gZW1wdHkuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICBUaGlzIG9wdGlvbiBpcyBhcHBsaWNhYmxlIHdoZW4gdXNlciBzaG91bGQgbm90IG5lZ2xlY3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgIHRoYXQgdGhlcmUgYXJlIHNvbWUgZGF0YSBpdGVtcyBvdXQgb2Ygd2luZG93LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGFraW5nIGxpbmUgY2hhcnQgYXMgYW4gZXhhbXBsZSwgbGluZSB3aWxsIGJlIGJyb2tlbiBpblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGZpbHRlcmVkIHBvaW50cyB3aGVuIGZpbHRlck1vZGVsIGlzIHNldCB0byAnZW1wdHknLCBidXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJlIGNvbm5lY3RlZCB3aGVuIHNldCB0byAnZmlsdGVyJy5cblxuICAgICAgICAgICAgdGhyb3R0bGU6IG51bGwsICAgICAgICAgLy8gRGlzcGF0Y2ggYWN0aW9uIGJ5IHRoZSBmaXhlZCByYXRlLCBhdm9pZCBmcmVxdWVuY3kuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkZWZhdWx0IDEwMC4gRG8gbm90IHRocm90dGxlIHdoZW4gdXNlIG51bGwvdW5kZWZpbmVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgYW5pbWF0aW9uID09PSB0cnVlIGFuZCBhbmltYXRpb25EdXJhdGlvblVwZGF0ZSA+IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkZWZhdWx0IHZhbHVlIGlzIDEwMCwgb3RoZXJ3aXNlIDIwLlxuICAgICAgICAgICAgc3RhcnQ6IDAsICAgICAgICAgICAgICAgLy8gU3RhcnQgcGVyY2VudC4gMCB+IDEwMFxuICAgICAgICAgICAgZW5kOiAxMDAsICAgICAgICAgICAgICAgLy8gRW5kIHBlcmNlbnQuIDAgfiAxMDBcbiAgICAgICAgICAgIHN0YXJ0VmFsdWU6IG51bGwsICAgICAgIC8vIFN0YXJ0IHZhbHVlLiBJZiBzdGFydFZhbHVlIHNwZWNpZmllZCwgc3RhcnQgaXMgaWdub3JlZC5cbiAgICAgICAgICAgIGVuZFZhbHVlOiBudWxsICAgICAgICAgIC8vIEVuZCB2YWx1ZS4gSWYgZW5kVmFsdWUgc3BlY2lmaWVkLCBlbmQgaXMgaWdub3JlZC5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgICAqL1xuICAgICAgICBpbml0OiBmdW5jdGlvbiAob3B0aW9uLCBwYXJlbnRNb2RlbCwgZWNNb2RlbCkge1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIGtleSBsaWtlIHhfMCwgeV8xXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5fZGF0YUludGVydmFsQnlBeGlzID0ge307XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5fZGF0YUluZm8gPSB7fTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBrZXkgbGlrZSB4XzAsIHlfMVxuICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5fYXhpc1Byb3hpZXMgPSB7fTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcmVhZE9ubHlcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy50ZXh0U3R5bGVNb2RlbDtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLl9hdXRvVGhyb3R0bGUgPSB0cnVlO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqICdwZXJjZW50JyBvciAndmFsdWUnXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLl9yYW5nZVByb3BNb2RlID0gWydwZXJjZW50JywgJ3BlcmNlbnQnXTtcblxuICAgICAgICAgICAgdmFyIHJhd09wdGlvbiA9IHJldHJpZXZlUmF3KG9wdGlvbik7XG5cbiAgICAgICAgICAgIHRoaXMubWVyZ2VEZWZhdWx0QW5kVGhlbWUob3B0aW9uLCBlY01vZGVsKTtcblxuICAgICAgICAgICAgdGhpcy5kb0luaXQocmF3T3B0aW9uKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgICAqL1xuICAgICAgICBtZXJnZU9wdGlvbjogZnVuY3Rpb24gKG5ld09wdGlvbikge1xuICAgICAgICAgICAgdmFyIHJhd09wdGlvbiA9IHJldHJpZXZlUmF3KG5ld09wdGlvbik7XG5cbiAgICAgICAgICAgIC8vRklYICMyNTkxXG4gICAgICAgICAgICB6clV0aWwubWVyZ2UodGhpcy5vcHRpb24sIG5ld09wdGlvbiwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIHRoaXMuZG9Jbml0KHJhd09wdGlvbik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGRvSW5pdDogZnVuY3Rpb24gKHJhd09wdGlvbikge1xuICAgICAgICAgICAgdmFyIHRoaXNPcHRpb24gPSB0aGlzLm9wdGlvbjtcblxuICAgICAgICAgICAgLy8gRGlzYWJsZSByZWFsdGltZSB2aWV3IHVwZGF0ZSBpZiBjYW52YXMgaXMgbm90IHN1cHBvcnRlZC5cbiAgICAgICAgICAgIGlmICghZW52LmNhbnZhc1N1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgIHRoaXNPcHRpb24ucmVhbHRpbWUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fc2V0RGVmYXVsdFRocm90dGxlKHJhd09wdGlvbik7XG5cbiAgICAgICAgICAgIHVwZGF0ZVJhbmdlVXNlKHRoaXMsIHJhd09wdGlvbik7XG5cbiAgICAgICAgICAgIGVhY2goW1snc3RhcnQnLCAnc3RhcnRWYWx1ZSddLCBbJ2VuZCcsICdlbmRWYWx1ZSddXSwgZnVuY3Rpb24gKG5hbWVzLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIC8vIHN0YXJ0L2VuZCBoYXMgaGlnaGVyIHByaW9yaXR5IG92ZXIgc3RhcnRWYWx1ZS9lbmRWYWx1ZSBpZiB0aGV5XG4gICAgICAgICAgICAgICAgLy8gYm90aCBzZXQsIGJ1dCB3ZSBzaG91bGQgbWFrZSBjaGFydC5zZXRPcHRpb24oe2VuZFZhbHVlOiAxMDAwfSlcbiAgICAgICAgICAgICAgICAvLyBlZmZlY3RpdmUsIHJhdGhlciB0aGFuIGNoYXJ0LnNldE9wdGlvbih7ZW5kVmFsdWU6IDEwMDAsIGVuZDogbnVsbH0pLlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9yYW5nZVByb3BNb2RlW2luZGV4XSA9PT0gJ3ZhbHVlJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzT3B0aW9uW25hbWVzWzBdXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSBkbyBub3RoaW5nIGFuZCB1c2UgdGhlIG1lcmdlIHJlc3VsdC5cbiAgICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgICB0aGlzLnRleHRTdHlsZU1vZGVsID0gdGhpcy5nZXRNb2RlbCgndGV4dFN0eWxlJyk7XG5cbiAgICAgICAgICAgIHRoaXMuX3Jlc2V0VGFyZ2V0KCk7XG5cbiAgICAgICAgICAgIHRoaXMuX2dpdmVBeGlzUHJveGllcygpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX2dpdmVBeGlzUHJveGllczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGF4aXNQcm94aWVzID0gdGhpcy5fYXhpc1Byb3hpZXM7XG5cbiAgICAgICAgICAgIHRoaXMuZWFjaFRhcmdldEF4aXMoZnVuY3Rpb24gKGRpbU5hbWVzLCBheGlzSW5kZXgsIGRhdGFab29tTW9kZWwsIGVjTW9kZWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXhpc01vZGVsID0gdGhpcy5kZXBlbmRlbnRNb2RlbHNbZGltTmFtZXMuYXhpc11bYXhpc0luZGV4XTtcblxuICAgICAgICAgICAgICAgIC8vIElmIGV4aXN0cywgc2hhcmUgYXhpc1Byb3h5IHdpdGggb3RoZXIgZGF0YVpvb21Nb2RlbHMuXG4gICAgICAgICAgICAgICAgdmFyIGF4aXNQcm94eSA9IGF4aXNNb2RlbC5fX2R6QXhpc1Byb3h5IHx8IChcbiAgICAgICAgICAgICAgICAgICAgLy8gVXNlIHRoZSBmaXJzdCBkYXRhWm9vbU1vZGVsIGFzIHRoZSBtYWluIG1vZGVsIG9mIGF4aXNQcm94eS5cbiAgICAgICAgICAgICAgICAgICAgYXhpc01vZGVsLl9fZHpBeGlzUHJveHkgPSBuZXcgQXhpc1Byb3h5KFxuICAgICAgICAgICAgICAgICAgICAgICAgZGltTmFtZXMubmFtZSwgYXhpc0luZGV4LCB0aGlzLCBlY01vZGVsXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIC8vIEZJWE1FXG4gICAgICAgICAgICAgICAgLy8gZGlzcG9zZSBfX2R6QXhpc1Byb3h5XG5cbiAgICAgICAgICAgICAgICBheGlzUHJveGllc1tkaW1OYW1lcy5uYW1lICsgJ18nICsgYXhpc0luZGV4XSA9IGF4aXNQcm94eTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX3Jlc2V0VGFyZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdGhpc09wdGlvbiA9IHRoaXMub3B0aW9uO1xuXG4gICAgICAgICAgICB2YXIgYXV0b01vZGUgPSB0aGlzLl9qdWRnZUF1dG9Nb2RlKCk7XG5cbiAgICAgICAgICAgIGVhY2hBeGlzRGltKGZ1bmN0aW9uIChkaW1OYW1lcykge1xuICAgICAgICAgICAgICAgIHZhciBheGlzSW5kZXhOYW1lID0gZGltTmFtZXMuYXhpc0luZGV4O1xuICAgICAgICAgICAgICAgIHRoaXNPcHRpb25bYXhpc0luZGV4TmFtZV0gPSBtb2RlbFV0aWwubm9ybWFsaXplVG9BcnJheShcbiAgICAgICAgICAgICAgICAgICAgdGhpc09wdGlvbltheGlzSW5kZXhOYW1lXVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgaWYgKGF1dG9Nb2RlID09PSAnYXhpc0luZGV4Jykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2F1dG9TZXRBeGlzSW5kZXgoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGF1dG9Nb2RlID09PSAnb3JpZW50Jykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2F1dG9TZXRPcmllbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF9qdWRnZUF1dG9Nb2RlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBBdXRvIHNldCBvbmx5IHdvcmtzIGZvciBzZXRPcHRpb24gYXQgdGhlIGZpcnN0IHRpbWUuXG4gICAgICAgICAgICAvLyBUaGUgZm9sbG93aW5nIGlzIHVzZXIncyByZXBvbnNpYmlsaXR5LiBTbyB1c2luZyBtZXJnZWRcbiAgICAgICAgICAgIC8vIG9wdGlvbiBpcyBPSy5cbiAgICAgICAgICAgIHZhciB0aGlzT3B0aW9uID0gdGhpcy5vcHRpb247XG5cbiAgICAgICAgICAgIHZhciBoYXNJbmRleFNwZWNpZmllZCA9IGZhbHNlO1xuICAgICAgICAgICAgZWFjaEF4aXNEaW0oZnVuY3Rpb24gKGRpbU5hbWVzKSB7XG4gICAgICAgICAgICAgICAgLy8gV2hlbiB1c2VyIHNldCBheGlzSW5kZXggYXMgYSBlbXB0eSBhcnJheSwgd2UgdGhpbmsgdGhhdCB1c2VyIHNwZWNpZnkgYXhpc0luZGV4XG4gICAgICAgICAgICAgICAgLy8gYnV0IGRvIG5vdCB3YW50IHVzZSBhdXRvIG1vZGUuIEJlY2F1c2UgZW1wdHkgYXJyYXkgbWF5IGJlIGVuY291bnRlcmVkIHdoZW5cbiAgICAgICAgICAgICAgICAvLyBzb21lIGVycm9yIG9jY3VyZWQuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXNPcHRpb25bZGltTmFtZXMuYXhpc0luZGV4XSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhc0luZGV4U3BlY2lmaWVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgdmFyIG9yaWVudCA9IHRoaXNPcHRpb24ub3JpZW50O1xuXG4gICAgICAgICAgICBpZiAob3JpZW50ID09IG51bGwgJiYgaGFzSW5kZXhTcGVjaWZpZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ29yaWVudCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghaGFzSW5kZXhTcGVjaWZpZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAob3JpZW50ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc09wdGlvbi5vcmllbnQgPSAnaG9yaXpvbnRhbCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAnYXhpc0luZGV4JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF9hdXRvU2V0QXhpc0luZGV4OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXV0b0F4aXNJbmRleCA9IHRydWU7XG4gICAgICAgICAgICB2YXIgb3JpZW50ID0gdGhpcy5nZXQoJ29yaWVudCcsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHRoaXNPcHRpb24gPSB0aGlzLm9wdGlvbjtcbiAgICAgICAgICAgIHZhciBkZXBlbmRlbnRNb2RlbHMgPSB0aGlzLmRlcGVuZGVudE1vZGVscztcblxuICAgICAgICAgICAgaWYgKGF1dG9BeGlzSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAvLyBGaW5kIGF4aXMgdGhhdCBwYXJhbGxlbCB0byBkYXRhWm9vbSBhcyBkZWZhdWx0LlxuICAgICAgICAgICAgICAgIHZhciBkaW1OYW1lID0gb3JpZW50ID09PSAndmVydGljYWwnID8gJ3knIDogJ3gnO1xuXG4gICAgICAgICAgICAgICAgaWYgKGRlcGVuZGVudE1vZGVsc1tkaW1OYW1lICsgJ0F4aXMnXS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc09wdGlvbltkaW1OYW1lICsgJ0F4aXNJbmRleCddID0gWzBdO1xuICAgICAgICAgICAgICAgICAgICBhdXRvQXhpc0luZGV4ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlYWNoKGRlcGVuZGVudE1vZGVscy5zaW5nbGVBeGlzLCBmdW5jdGlvbiAoc2luZ2xlQXhpc01vZGVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXV0b0F4aXNJbmRleCAmJiBzaW5nbGVBeGlzTW9kZWwuZ2V0KCdvcmllbnQnLCB0cnVlKSA9PT0gb3JpZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc09wdGlvbi5zaW5nbGVBeGlzSW5kZXggPSBbc2luZ2xlQXhpc01vZGVsLmNvbXBvbmVudEluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdXRvQXhpc0luZGV4ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGF1dG9BeGlzSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAvLyBGaW5kIHRoZSBmaXJzdCBjYXRlZ29yeSBheGlzIGFzIGRlZmF1bHQuIChjb25zaWRlciBwb2xhcilcbiAgICAgICAgICAgICAgICBlYWNoQXhpc0RpbShmdW5jdGlvbiAoZGltTmFtZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhdXRvQXhpc0luZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGF4aXNJbmRpY2VzID0gW107XG4gICAgICAgICAgICAgICAgICAgIHZhciBheGlzTW9kZWxzID0gdGhpcy5kZXBlbmRlbnRNb2RlbHNbZGltTmFtZXMuYXhpc107XG4gICAgICAgICAgICAgICAgICAgIGlmIChheGlzTW9kZWxzLmxlbmd0aCAmJiAhYXhpc0luZGljZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXhpc01vZGVscy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChheGlzTW9kZWxzW2ldLmdldCgndHlwZScpID09PSAnY2F0ZWdvcnknKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF4aXNJbmRpY2VzLnB1c2goaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXNPcHRpb25bZGltTmFtZXMuYXhpc0luZGV4XSA9IGF4aXNJbmRpY2VzO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXhpc0luZGljZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdXRvQXhpc0luZGV4ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGF1dG9BeGlzSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAvLyBGSVhNRVxuICAgICAgICAgICAgICAgIC8vIOi/memHjOaYr+WFvOWuuWVjMueahOWGmeazle+8iOayoeaMh+WumnhBeGlzSW5kZXjlkox5QXhpc0luZGV45pe25oqKc2NhdHRlcuWSjOWPjOaVsOWAvOi9tOaKmOafsee6s+WFpWRhdGFab29t5o6n5Yi277yJ77yMXG4gICAgICAgICAgICAgICAgLy8g5L2G5piv5a6e6ZmF5piv5ZCm6ZyA6KaBR3JpZC5qcyNnZXRTY2FsZUJ5T3B0aW9u5p2l5Yik5pat77yI6ICD6JmRdGltZe+8jGxvZ+etiWF4aXMgdHlwZe+8ie+8n1xuXG4gICAgICAgICAgICAgICAgLy8gSWYgYm90aCBkYXRhWm9vbS54QXhpc0luZGV4IGFuZCBkYXRhWm9vbS55QXhpc0luZGV4IGlzIG5vdCBzcGVjaWZpZWQsXG4gICAgICAgICAgICAgICAgLy8gZGF0YVpvb20gY29tcG9uZW50IGF1dG8gYWRvcHRzIHNlcmllcyB0aGF0IHJlZmVyZW5jZSB0b1xuICAgICAgICAgICAgICAgIC8vIGJvdGggeEF4aXMgYW5kIHlBeGlzIHdoaWNoIHR5cGUgaXMgJ3ZhbHVlJy5cbiAgICAgICAgICAgICAgICB0aGlzLmVjTW9kZWwuZWFjaFNlcmllcyhmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lzU2VyaWVzSGFzQWxsQXhlc1R5cGVPZihzZXJpZXNNb2RlbCwgJ3ZhbHVlJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVhY2hBeGlzRGltKGZ1bmN0aW9uIChkaW1OYW1lcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBheGlzSW5kaWNlcyA9IHRoaXNPcHRpb25bZGltTmFtZXMuYXhpc0luZGV4XTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBheGlzSW5kZXggPSBzZXJpZXNNb2RlbC5nZXQoZGltTmFtZXMuYXhpc0luZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXhpc0lkID0gc2VyaWVzTW9kZWwuZ2V0KGRpbU5hbWVzLmF4aXNJZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXhpc01vZGVsID0gc2VyaWVzTW9kZWwuZWNNb2RlbC5xdWVyeUNvbXBvbmVudHMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYWluVHlwZTogZGltTmFtZXMuYXhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGF4aXNJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGF4aXNJZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pWzBdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9fREVWX18pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFheGlzTW9kZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaW1OYW1lcy5heGlzICsgJyBcIicgKyB6clV0aWwucmV0cmlldmUoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF4aXNJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXhpc0lkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSArICdcIiBub3QgZm91bmQnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF4aXNJbmRleCA9IGF4aXNNb2RlbC5jb21wb25lbnRJbmRleDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh6clV0aWwuaW5kZXhPZihheGlzSW5kaWNlcywgYXhpc0luZGV4KSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXhpc0luZGljZXMucHVzaChheGlzSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfYXV0b1NldE9yaWVudDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGRpbTtcblxuICAgICAgICAgICAgLy8gRmluZCB0aGUgZmlyc3QgYXhpc1xuICAgICAgICAgICAgdGhpcy5lYWNoVGFyZ2V0QXhpcyhmdW5jdGlvbiAoZGltTmFtZXMpIHtcbiAgICAgICAgICAgICAgICAhZGltICYmIChkaW0gPSBkaW1OYW1lcy5uYW1lKTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgICB0aGlzLm9wdGlvbi5vcmllbnQgPSBkaW0gPT09ICd5JyA/ICd2ZXJ0aWNhbCcgOiAnaG9yaXpvbnRhbCc7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfaXNTZXJpZXNIYXNBbGxBeGVzVHlwZU9mOiBmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIGF4aXNUeXBlKSB7XG4gICAgICAgICAgICAvLyBGSVhNRVxuICAgICAgICAgICAgLy8g6ZyA6KaBc2VyaWVz55qEeEF4aXNJbmRleOWSjHlBeGlzSW5kZXjpg73pppblhYjoh6rliqjorr7nva7kuIrjgIJcbiAgICAgICAgICAgIC8vIOS+i+WmgnNlcmllcy50eXBlID09PSBzY2F0dGVy5pe244CCXG5cbiAgICAgICAgICAgIHZhciBpcyA9IHRydWU7XG4gICAgICAgICAgICBlYWNoQXhpc0RpbShmdW5jdGlvbiAoZGltTmFtZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VyaWVzQXhpc0luZGV4ID0gc2VyaWVzTW9kZWwuZ2V0KGRpbU5hbWVzLmF4aXNJbmRleCk7XG4gICAgICAgICAgICAgICAgdmFyIGF4aXNNb2RlbCA9IHRoaXMuZGVwZW5kZW50TW9kZWxzW2RpbU5hbWVzLmF4aXNdW3Nlcmllc0F4aXNJbmRleF07XG5cbiAgICAgICAgICAgICAgICBpZiAoIWF4aXNNb2RlbCB8fCBheGlzTW9kZWwuZ2V0KCd0eXBlJykgIT09IGF4aXNUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfc2V0RGVmYXVsdFRocm90dGxlOiBmdW5jdGlvbiAocmF3T3B0aW9uKSB7XG4gICAgICAgICAgICAvLyBXaGVuIGZpcnN0IHRpbWUgdXNlciBzZXQgdGhyb3R0bGUsIGF1dG8gdGhyb3R0bGUgZW5kcy5cbiAgICAgICAgICAgIGlmIChyYXdPcHRpb24uaGFzT3duUHJvcGVydHkoJ3Rocm90dGxlJykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hdXRvVGhyb3R0bGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9hdXRvVGhyb3R0bGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZ2xvYmFsT3B0aW9uID0gdGhpcy5lY01vZGVsLm9wdGlvbjtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbi50aHJvdHRsZSA9XG4gICAgICAgICAgICAgICAgICAgIChnbG9iYWxPcHRpb24uYW5pbWF0aW9uICYmIGdsb2JhbE9wdGlvbi5hbmltYXRpb25EdXJhdGlvblVwZGF0ZSA+IDApXG4gICAgICAgICAgICAgICAgICAgID8gMTAwIDogMjA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwdWJsaWNcbiAgICAgICAgICovXG4gICAgICAgIGdldEZpcnN0VGFyZ2V0QXhpc01vZGVsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZmlyc3RBeGlzTW9kZWw7XG4gICAgICAgICAgICBlYWNoQXhpc0RpbShmdW5jdGlvbiAoZGltTmFtZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmlyc3RBeGlzTW9kZWwgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kaWNlcyA9IHRoaXMuZ2V0KGRpbU5hbWVzLmF4aXNJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRpY2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3RBeGlzTW9kZWwgPSB0aGlzLmRlcGVuZGVudE1vZGVsc1tkaW1OYW1lcy5heGlzXVtpbmRpY2VzWzBdXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgICByZXR1cm4gZmlyc3RBeGlzTW9kZWw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwdWJsaWNcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgcGFyYW06IGF4aXNNb2RlbCwgZGltTmFtZXMsIGF4aXNJbmRleCwgZGF0YVpvb21Nb2RlbCwgZWNNb2RlbFxuICAgICAgICAgKi9cbiAgICAgICAgZWFjaFRhcmdldEF4aXM6IGZ1bmN0aW9uIChjYWxsYmFjaywgY29udGV4dCkge1xuICAgICAgICAgICAgdmFyIGVjTW9kZWwgPSB0aGlzLmVjTW9kZWw7XG4gICAgICAgICAgICBlYWNoQXhpc0RpbShmdW5jdGlvbiAoZGltTmFtZXMpIHtcbiAgICAgICAgICAgICAgICBlYWNoKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdldChkaW1OYW1lcy5heGlzSW5kZXgpLFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoYXhpc0luZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKGNvbnRleHQsIGRpbU5hbWVzLCBheGlzSW5kZXgsIHRoaXMsIGVjTW9kZWwpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB0aGlzXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGltTmFtZVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gYXhpc0luZGV4XG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTplY2hhcnRzL2NvbXBvbmVudC9kYXRhWm9vbS9BeGlzUHJveHl9IElmIG5vdCBmb3VuZCwgcmV0dXJuIG51bGwvdW5kZWZpbmVkLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0QXhpc1Byb3h5OiBmdW5jdGlvbiAoZGltTmFtZSwgYXhpc0luZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYXhpc1Byb3hpZXNbZGltTmFtZSArICdfJyArIGF4aXNJbmRleF07XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkaW1OYW1lXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBheGlzSW5kZXhcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWx9IElmIG5vdCBmb3VuZCwgcmV0dXJuIG51bGwvdW5kZWZpbmVkLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0QXhpc01vZGVsOiBmdW5jdGlvbiAoZGltTmFtZSwgYXhpc0luZGV4KSB7XG4gICAgICAgICAgICB2YXIgYXhpc1Byb3h5ID0gdGhpcy5nZXRBeGlzUHJveHkoZGltTmFtZSwgYXhpc0luZGV4KTtcbiAgICAgICAgICAgIHJldHVybiBheGlzUHJveHkgJiYgYXhpc1Byb3h5LmdldEF4aXNNb2RlbCgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBub3Qgc3BlY2lmaWVkLCBzZXQgdG8gdW5kZWZpbmVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHVibGljXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHQuc3RhcnRdXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0LmVuZF1cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHQuc3RhcnRWYWx1ZV1cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHQuZW5kVmFsdWVdXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lnbm9yZVVwZGF0ZVJhbmdlVXNnPWZhbHNlXVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0UmF3UmFuZ2U6IGZ1bmN0aW9uIChvcHQsIGlnbm9yZVVwZGF0ZVJhbmdlVXNnKSB7XG4gICAgICAgICAgICBlYWNoKFsnc3RhcnQnLCAnZW5kJywgJ3N0YXJ0VmFsdWUnLCAnZW5kVmFsdWUnXSwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBhbnkgb2YgdGhvc2UgcHJvcCBpcyBudWxsL3VuZGVmaW5lZCwgd2Ugc2hvdWxkIGFsb3Mgc2V0XG4gICAgICAgICAgICAgICAgLy8gdGhlbSwgYmVjYXVzZSBvbmx5IG9uZSBwYWlyIGJldHdlZW4gc3RhcnQvZW5kIGFuZFxuICAgICAgICAgICAgICAgIC8vIHN0YXJ0VmFsdWUvZW5kVmFsdWUgY2FuIHdvcmsuXG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25bbmFtZV0gPSBvcHRbbmFtZV07XG4gICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgIWlnbm9yZVVwZGF0ZVJhbmdlVXNnICYmIHVwZGF0ZVJhbmdlVXNlKHRoaXMsIG9wdCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwdWJsaWNcbiAgICAgICAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59IFtzdGFydFBlcmNlbnQsIGVuZFBlcmNlbnRdXG4gICAgICAgICAqL1xuICAgICAgICBnZXRQZXJjZW50UmFuZ2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBheGlzUHJveHkgPSB0aGlzLmZpbmRSZXByZXNlbnRhdGl2ZUF4aXNQcm94eSgpO1xuICAgICAgICAgICAgaWYgKGF4aXNQcm94eSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBheGlzUHJveHkuZ2V0RGF0YVBlcmNlbnRXaW5kb3coKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHB1YmxpY1xuICAgICAgICAgKiBGb3IgZXhhbXBsZSwgY2hhcnQuZ2V0TW9kZWwoKS5nZXRDb21wb25lbnQoJ2RhdGFab29tJykuZ2V0VmFsdWVSYW5nZSgneScsIDApO1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2F4aXNEaW1OYW1lXVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2F4aXNJbmRleF1cbiAgICAgICAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59IFtzdGFydFZhbHVlLCBlbmRWYWx1ZV0gdmFsdWUgY2FuIG9ubHkgYmUgJy0nIG9yIGZpbml0ZSBudW1iZXIuXG4gICAgICAgICAqL1xuICAgICAgICBnZXRWYWx1ZVJhbmdlOiBmdW5jdGlvbiAoYXhpc0RpbU5hbWUsIGF4aXNJbmRleCkge1xuICAgICAgICAgICAgaWYgKGF4aXNEaW1OYW1lID09IG51bGwgJiYgYXhpc0luZGV4ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXhpc1Byb3h5ID0gdGhpcy5maW5kUmVwcmVzZW50YXRpdmVBeGlzUHJveHkoKTtcbiAgICAgICAgICAgICAgICBpZiAoYXhpc1Byb3h5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBheGlzUHJveHkuZ2V0RGF0YVZhbHVlV2luZG93KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QXhpc1Byb3h5KGF4aXNEaW1OYW1lLCBheGlzSW5kZXgpLmdldERhdGFWYWx1ZVdpbmRvdygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHVibGljXG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTplY2hhcnRzL2NvbXBvbmVudC9kYXRhWm9vbS9BeGlzUHJveHl9XG4gICAgICAgICAqL1xuICAgICAgICBmaW5kUmVwcmVzZW50YXRpdmVBeGlzUHJveHk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIEZpbmQgdGhlIGZpcnN0IGhvc3RlZCBheGlzUHJveHlcbiAgICAgICAgICAgIHZhciBheGlzUHJveGllcyA9IHRoaXMuX2F4aXNQcm94aWVzO1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGF4aXNQcm94aWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGF4aXNQcm94aWVzLmhhc093blByb3BlcnR5KGtleSkgJiYgYXhpc1Byb3hpZXNba2V5XS5ob3N0ZWRCeSh0aGlzKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXhpc1Byb3hpZXNba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIG5vIGhvc3RlZCBheGlzIGZpbmQgbm90IGhvc3RlZCBheGlzUHJveHkuXG4gICAgICAgICAgICAvLyBDb25zaWRlciB0aGlzIGNhc2U6IGRhdGFab29tTW9kZWwxIGFuZCBkYXRhWm9vbU1vZGVsMiBjb250cm9sIHRoZSBzYW1lIGF4aXMsXG4gICAgICAgICAgICAvLyBhbmQgdGhlIG9wdGlvbi5zdGFydCBvciBvcHRpb24uZW5kIHNldHRpbmdzIGFyZSBkaWZmZXJlbnQuIFRoZSBwZXJjZW50UmFuZ2VcbiAgICAgICAgICAgIC8vIHNob3VsZCBmb2xsb3cgYXhpc1Byb3h5LlxuICAgICAgICAgICAgLy8gKFdlIGVuY291bnRlciB0aGlzIHByb2JsZW0gaW4gdG9vbGJveCBkYXRhIHpvb20uKVxuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGF4aXNQcm94aWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGF4aXNQcm94aWVzLmhhc093blByb3BlcnR5KGtleSkgJiYgIWF4aXNQcm94aWVzW2tleV0uaG9zdGVkQnkodGhpcykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF4aXNQcm94aWVzW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48c3RyaW5nPn1cbiAgICAgICAgICovXG4gICAgICAgIGdldFJhbmdlUHJvcE1vZGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yYW5nZVByb3BNb2RlLnNsaWNlKCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIHJldHJpZXZlUmF3KG9wdGlvbikge1xuICAgICAgICB2YXIgcmV0ID0ge307XG4gICAgICAgIGVhY2goXG4gICAgICAgICAgICBbJ3N0YXJ0JywgJ2VuZCcsICdzdGFydFZhbHVlJywgJ2VuZFZhbHVlJywgJ3Rocm90dGxlJ10sXG4gICAgICAgICAgICBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiAocmV0W25hbWVdID0gb3B0aW9uW25hbWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVSYW5nZVVzZShkYXRhWm9vbU1vZGVsLCByYXdPcHRpb24pIHtcbiAgICAgICAgZWFjaChbWydzdGFydCcsICdzdGFydFZhbHVlJ10sIFsnZW5kJywgJ2VuZFZhbHVlJ11dLCBmdW5jdGlvbiAobmFtZXMsIGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgcmFuZ2VQcm9wTW9kZSA9IGRhdGFab29tTW9kZWwuX3JhbmdlUHJvcE1vZGU7XG4gICAgICAgICAgICBpZiAocmF3T3B0aW9uW25hbWVzWzBdXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmFuZ2VQcm9wTW9kZVtpbmRleF0gPSAncGVyY2VudCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyYXdPcHRpb25bbmFtZXNbMV1dICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByYW5nZVByb3BNb2RlW2luZGV4XSA9ICd2YWx1ZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlbHNlIHJlbWFpbiBpdHMgb3JpZ2luYWwgc2V0dGluZy5cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBEYXRhWm9vbU1vZGVsO1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9jb21wb25lbnQvZGF0YVpvb20vRGF0YVpvb21Nb2RlbC5qc1xuLy8gbW9kdWxlIGlkID0gNDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 47 */
/* unknown exports provided */
/* all exports used */
/*!************************************************!*\
  !*** ./lib/component/dataZoom/DataZoomView.js ***!
  \************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var ComponentView = __webpack_require__(/*! ../../view/Component */ 72);\n\n    module.exports = ComponentView.extend({\n\n        type: 'dataZoom',\n\n        render: function (dataZoomModel, ecModel, api, payload) {\n            this.dataZoomModel = dataZoomModel;\n            this.ecModel = ecModel;\n            this.api = api;\n        },\n\n        /**\n         * Find the first target coordinate system.\n         *\n         * @protected\n         * @return {Object} {\n         *                   grid: [\n         *                       {model: coord0, axisModels: [axis1, axis3], coordIndex: 1},\n         *                       {model: coord1, axisModels: [axis0, axis2], coordIndex: 0},\n         *                       ...\n         *                   ],  // cartesians must not be null/undefined.\n         *                   polar: [\n         *                       {model: coord0, axisModels: [axis4], coordIndex: 0},\n         *                       ...\n         *                   ],  // polars must not be null/undefined.\n         *                   singleAxis: [\n         *                       {model: coord0, axisModels: [], coordIndex: 0}\n         *                   ]\n         */\n        getTargetCoordInfo: function () {\n            var dataZoomModel = this.dataZoomModel;\n            var ecModel = this.ecModel;\n            var coordSysLists = {};\n\n            dataZoomModel.eachTargetAxis(function (dimNames, axisIndex) {\n                var axisModel = ecModel.getComponent(dimNames.axis, axisIndex);\n                if (axisModel) {\n                    var coordModel = axisModel.getCoordSysModel();\n                    coordModel && save(\n                        coordModel,\n                        axisModel,\n                        coordSysLists[coordModel.mainType] || (coordSysLists[coordModel.mainType] = []),\n                        coordModel.componentIndex\n                    );\n                }\n            }, this);\n\n            function save(coordModel, axisModel, store, coordIndex) {\n                var item;\n                for (var i = 0; i < store.length; i++) {\n                    if (store[i].model === coordModel) {\n                        item = store[i];\n                        break;\n                    }\n                }\n                if (!item) {\n                    store.push(item = {\n                        model: coordModel, axisModels: [], coordIndex: coordIndex\n                    });\n                }\n                item.axisModels.push(axisModel);\n            }\n\n            return coordSysLists;\n        }\n\n    });\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvY29tcG9uZW50L2RhdGFab29tL0RhdGFab29tVmlldy5qcz9kMjY0Il0sInNvdXJjZXNDb250ZW50IjpbIlxuXG4gICAgdmFyIENvbXBvbmVudFZpZXcgPSByZXF1aXJlKCcuLi8uLi92aWV3L0NvbXBvbmVudCcpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBDb21wb25lbnRWaWV3LmV4dGVuZCh7XG5cbiAgICAgICAgdHlwZTogJ2RhdGFab29tJyxcblxuICAgICAgICByZW5kZXI6IGZ1bmN0aW9uIChkYXRhWm9vbU1vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YVpvb21Nb2RlbCA9IGRhdGFab29tTW9kZWw7XG4gICAgICAgICAgICB0aGlzLmVjTW9kZWwgPSBlY01vZGVsO1xuICAgICAgICAgICAgdGhpcy5hcGkgPSBhcGk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpbmQgdGhlIGZpcnN0IHRhcmdldCBjb29yZGluYXRlIHN5c3RlbS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHtcbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgZ3JpZDogW1xuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAge21vZGVsOiBjb29yZDAsIGF4aXNNb2RlbHM6IFtheGlzMSwgYXhpczNdLCBjb29yZEluZGV4OiAxfSxcbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgICAgIHttb2RlbDogY29vcmQxLCBheGlzTW9kZWxzOiBbYXhpczAsIGF4aXMyXSwgY29vcmRJbmRleDogMH0sXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAuLi5cbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgXSwgIC8vIGNhcnRlc2lhbnMgbXVzdCBub3QgYmUgbnVsbC91bmRlZmluZWQuXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgIHBvbGFyOiBbXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICB7bW9kZWw6IGNvb3JkMCwgYXhpc01vZGVsczogW2F4aXM0XSwgY29vcmRJbmRleDogMH0sXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAuLi5cbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgXSwgIC8vIHBvbGFycyBtdXN0IG5vdCBiZSBudWxsL3VuZGVmaW5lZC5cbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgc2luZ2xlQXhpczogW1xuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAge21vZGVsOiBjb29yZDAsIGF4aXNNb2RlbHM6IFtdLCBjb29yZEluZGV4OiAwfVxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAqL1xuICAgICAgICBnZXRUYXJnZXRDb29yZEluZm86IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBkYXRhWm9vbU1vZGVsID0gdGhpcy5kYXRhWm9vbU1vZGVsO1xuICAgICAgICAgICAgdmFyIGVjTW9kZWwgPSB0aGlzLmVjTW9kZWw7XG4gICAgICAgICAgICB2YXIgY29vcmRTeXNMaXN0cyA9IHt9O1xuXG4gICAgICAgICAgICBkYXRhWm9vbU1vZGVsLmVhY2hUYXJnZXRBeGlzKGZ1bmN0aW9uIChkaW1OYW1lcywgYXhpc0luZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIGF4aXNNb2RlbCA9IGVjTW9kZWwuZ2V0Q29tcG9uZW50KGRpbU5hbWVzLmF4aXMsIGF4aXNJbmRleCk7XG4gICAgICAgICAgICAgICAgaWYgKGF4aXNNb2RlbCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29vcmRNb2RlbCA9IGF4aXNNb2RlbC5nZXRDb29yZFN5c01vZGVsKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvb3JkTW9kZWwgJiYgc2F2ZShcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvb3JkTW9kZWwsXG4gICAgICAgICAgICAgICAgICAgICAgICBheGlzTW9kZWwsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb29yZFN5c0xpc3RzW2Nvb3JkTW9kZWwubWFpblR5cGVdIHx8IChjb29yZFN5c0xpc3RzW2Nvb3JkTW9kZWwubWFpblR5cGVdID0gW10pLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29vcmRNb2RlbC5jb21wb25lbnRJbmRleFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBzYXZlKGNvb3JkTW9kZWwsIGF4aXNNb2RlbCwgc3RvcmUsIGNvb3JkSW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXRlbTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0b3JlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdG9yZVtpXS5tb2RlbCA9PT0gY29vcmRNb2RlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbSA9IHN0b3JlW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0b3JlLnB1c2goaXRlbSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsOiBjb29yZE1vZGVsLCBheGlzTW9kZWxzOiBbXSwgY29vcmRJbmRleDogY29vcmRJbmRleFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaXRlbS5heGlzTW9kZWxzLnB1c2goYXhpc01vZGVsKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGNvb3JkU3lzTGlzdHM7XG4gICAgICAgIH1cblxuICAgIH0pO1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9jb21wb25lbnQvZGF0YVpvb20vRGF0YVpvb21WaWV3LmpzXG4vLyBtb2R1bGUgaWQgPSA0N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 48 */
/* unknown exports provided */
/* all exports used */
/*!********************************!*\
  !*** ./lib/data/DataDiffer.js ***!
  \********************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\n    function defaultKeyGetter(item) {\n        return item;\n    }\n\n    function DataDiffer(oldArr, newArr, oldKeyGetter, newKeyGetter) {\n        this._old = oldArr;\n        this._new = newArr;\n\n        this._oldKeyGetter = oldKeyGetter || defaultKeyGetter;\n        this._newKeyGetter = newKeyGetter || defaultKeyGetter;\n    }\n\n    DataDiffer.prototype = {\n\n        constructor: DataDiffer,\n\n        /**\n         * Callback function when add a data\n         */\n        add: function (func) {\n            this._add = func;\n            return this;\n        },\n\n        /**\n         * Callback function when update a data\n         */\n        update: function (func) {\n            this._update = func;\n            return this;\n        },\n\n        /**\n         * Callback function when remove a data\n         */\n        remove: function (func) {\n            this._remove = func;\n            return this;\n        },\n\n        execute: function () {\n            var oldArr = this._old;\n            var newArr = this._new;\n            var oldKeyGetter = this._oldKeyGetter;\n            var newKeyGetter = this._newKeyGetter;\n\n            var oldDataIndexMap = {};\n            var newDataIndexMap = {};\n            var oldDataKeyArr = [];\n            var newDataKeyArr = [];\n            var i;\n\n            initIndexMap(oldArr, oldDataIndexMap, oldDataKeyArr, oldKeyGetter);\n            initIndexMap(newArr, newDataIndexMap, newDataKeyArr, newKeyGetter);\n\n            // Travel by inverted order to make sure order consistency\n            // when duplicate keys exists (consider newDataIndex.pop() below).\n            // For performance consideration, these code below do not look neat.\n            for (i = 0; i < oldArr.length; i++) {\n                var key = oldDataKeyArr[i];\n                var idx = newDataIndexMap[key];\n\n                // idx can never be empty array here. see 'set null' logic below.\n                if (idx != null) {\n                    // Consider there is duplicate key (for example, use dataItem.name as key).\n                    // We should make sure every item in newArr and oldArr can be visited.\n                    var len = idx.length;\n                    if (len) {\n                        len === 1 && (newDataIndexMap[key] = null);\n                        idx = idx.unshift();\n                    }\n                    else {\n                        newDataIndexMap[key] = null;\n                    }\n                    this._update && this._update(idx, i);\n                }\n                else {\n                    this._remove && this._remove(i);\n                }\n            }\n\n            for (var i = 0; i < newDataKeyArr.length; i++) {\n                var key = newDataKeyArr[i];\n                if (newDataIndexMap.hasOwnProperty(key)) {\n                    var idx = newDataIndexMap[key];\n                    if (idx == null) {\n                        continue;\n                    }\n                    // idx can never be empty array here. see 'set null' logic above.\n                    if (!idx.length) {\n                        this._add && this._add(idx);\n                    }\n                    else {\n                        for (var j = 0, len = idx.length; j < len; j++) {\n                            this._add && this._add(idx[j]);\n                        }\n                    }\n                }\n            }\n        }\n    };\n\n    function initIndexMap(arr, map, keyArr, keyGetter) {\n        for (var i = 0; i < arr.length; i++) {\n            var key = keyGetter(arr[i], i);\n            var existence = map[key];\n            if (existence == null) {\n                keyArr.push(key);\n                map[key] = i;\n            }\n            else {\n                if (!existence.length) {\n                    map[key] = existence = [existence];\n                }\n                existence.push(i);\n            }\n        }\n    }\n\n    module.exports = DataDiffer;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvZGF0YS9EYXRhRGlmZmVyLmpzPzg0ZjYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICBmdW5jdGlvbiBkZWZhdWx0S2V5R2V0dGVyKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gRGF0YURpZmZlcihvbGRBcnIsIG5ld0Fyciwgb2xkS2V5R2V0dGVyLCBuZXdLZXlHZXR0ZXIpIHtcbiAgICAgICAgdGhpcy5fb2xkID0gb2xkQXJyO1xuICAgICAgICB0aGlzLl9uZXcgPSBuZXdBcnI7XG5cbiAgICAgICAgdGhpcy5fb2xkS2V5R2V0dGVyID0gb2xkS2V5R2V0dGVyIHx8IGRlZmF1bHRLZXlHZXR0ZXI7XG4gICAgICAgIHRoaXMuX25ld0tleUdldHRlciA9IG5ld0tleUdldHRlciB8fCBkZWZhdWx0S2V5R2V0dGVyO1xuICAgIH1cblxuICAgIERhdGFEaWZmZXIucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBEYXRhRGlmZmVyLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxsYmFjayBmdW5jdGlvbiB3aGVuIGFkZCBhIGRhdGFcbiAgICAgICAgICovXG4gICAgICAgIGFkZDogZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICAgICAgICAgIHRoaXMuX2FkZCA9IGZ1bmM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbGJhY2sgZnVuY3Rpb24gd2hlbiB1cGRhdGUgYSBkYXRhXG4gICAgICAgICAqL1xuICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGUgPSBmdW5jO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGxiYWNrIGZ1bmN0aW9uIHdoZW4gcmVtb3ZlIGEgZGF0YVxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiAoZnVuYykge1xuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlID0gZnVuYztcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGV4ZWN1dGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvbGRBcnIgPSB0aGlzLl9vbGQ7XG4gICAgICAgICAgICB2YXIgbmV3QXJyID0gdGhpcy5fbmV3O1xuICAgICAgICAgICAgdmFyIG9sZEtleUdldHRlciA9IHRoaXMuX29sZEtleUdldHRlcjtcbiAgICAgICAgICAgIHZhciBuZXdLZXlHZXR0ZXIgPSB0aGlzLl9uZXdLZXlHZXR0ZXI7XG5cbiAgICAgICAgICAgIHZhciBvbGREYXRhSW5kZXhNYXAgPSB7fTtcbiAgICAgICAgICAgIHZhciBuZXdEYXRhSW5kZXhNYXAgPSB7fTtcbiAgICAgICAgICAgIHZhciBvbGREYXRhS2V5QXJyID0gW107XG4gICAgICAgICAgICB2YXIgbmV3RGF0YUtleUFyciA9IFtdO1xuICAgICAgICAgICAgdmFyIGk7XG5cbiAgICAgICAgICAgIGluaXRJbmRleE1hcChvbGRBcnIsIG9sZERhdGFJbmRleE1hcCwgb2xkRGF0YUtleUFyciwgb2xkS2V5R2V0dGVyKTtcbiAgICAgICAgICAgIGluaXRJbmRleE1hcChuZXdBcnIsIG5ld0RhdGFJbmRleE1hcCwgbmV3RGF0YUtleUFyciwgbmV3S2V5R2V0dGVyKTtcblxuICAgICAgICAgICAgLy8gVHJhdmVsIGJ5IGludmVydGVkIG9yZGVyIHRvIG1ha2Ugc3VyZSBvcmRlciBjb25zaXN0ZW5jeVxuICAgICAgICAgICAgLy8gd2hlbiBkdXBsaWNhdGUga2V5cyBleGlzdHMgKGNvbnNpZGVyIG5ld0RhdGFJbmRleC5wb3AoKSBiZWxvdykuXG4gICAgICAgICAgICAvLyBGb3IgcGVyZm9ybWFuY2UgY29uc2lkZXJhdGlvbiwgdGhlc2UgY29kZSBiZWxvdyBkbyBub3QgbG9vayBuZWF0LlxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG9sZEFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBvbGREYXRhS2V5QXJyW2ldO1xuICAgICAgICAgICAgICAgIHZhciBpZHggPSBuZXdEYXRhSW5kZXhNYXBba2V5XTtcblxuICAgICAgICAgICAgICAgIC8vIGlkeCBjYW4gbmV2ZXIgYmUgZW1wdHkgYXJyYXkgaGVyZS4gc2VlICdzZXQgbnVsbCcgbG9naWMgYmVsb3cuXG4gICAgICAgICAgICAgICAgaWYgKGlkeCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENvbnNpZGVyIHRoZXJlIGlzIGR1cGxpY2F0ZSBrZXkgKGZvciBleGFtcGxlLCB1c2UgZGF0YUl0ZW0ubmFtZSBhcyBrZXkpLlxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBzaG91bGQgbWFrZSBzdXJlIGV2ZXJ5IGl0ZW0gaW4gbmV3QXJyIGFuZCBvbGRBcnIgY2FuIGJlIHZpc2l0ZWQuXG4gICAgICAgICAgICAgICAgICAgIHZhciBsZW4gPSBpZHgubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZW4gPT09IDEgJiYgKG5ld0RhdGFJbmRleE1hcFtrZXldID0gbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZHggPSBpZHgudW5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3RGF0YUluZGV4TWFwW2tleV0gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZSAmJiB0aGlzLl91cGRhdGUoaWR4LCBpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZSAmJiB0aGlzLl9yZW1vdmUoaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld0RhdGFLZXlBcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gbmV3RGF0YUtleUFycltpXTtcbiAgICAgICAgICAgICAgICBpZiAobmV3RGF0YUluZGV4TWFwLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlkeCA9IG5ld0RhdGFJbmRleE1hcFtrZXldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaWR4ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGlkeCBjYW4gbmV2ZXIgYmUgZW1wdHkgYXJyYXkgaGVyZS4gc2VlICdzZXQgbnVsbCcgbG9naWMgYWJvdmUuXG4gICAgICAgICAgICAgICAgICAgIGlmICghaWR4Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkICYmIHRoaXMuX2FkZChpZHgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGxlbiA9IGlkeC5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZCAmJiB0aGlzLl9hZGQoaWR4W2pdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBpbml0SW5kZXhNYXAoYXJyLCBtYXAsIGtleUFyciwga2V5R2V0dGVyKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0ga2V5R2V0dGVyKGFycltpXSwgaSk7XG4gICAgICAgICAgICB2YXIgZXhpc3RlbmNlID0gbWFwW2tleV07XG4gICAgICAgICAgICBpZiAoZXhpc3RlbmNlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBrZXlBcnIucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgIG1hcFtrZXldID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghZXhpc3RlbmNlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBtYXBba2V5XSA9IGV4aXN0ZW5jZSA9IFtleGlzdGVuY2VdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBleGlzdGVuY2UucHVzaChpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gRGF0YURpZmZlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2RhdGEvRGF0YURpZmZlci5qc1xuLy8gbW9kdWxlIGlkID0gNDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 49 */
/* unknown exports provided */
/* all exports used */
/*!*******************************!*\
  !*** ./lib/util/component.js ***!
  \*******************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 0);\n    var clazz = __webpack_require__(/*! ./clazz */ 14);\n\n    var parseClassType = clazz.parseClassType;\n\n    var base = 0;\n\n    var componentUtil = {};\n\n    var DELIMITER = '_';\n\n    /**\n     * @public\n     * @param {string} type\n     * @return {string}\n     */\n    componentUtil.getUID = function (type) {\n        // Considering the case of crossing js context,\n        // use Math.random to make id as unique as possible.\n        return [(type || ''), base++, Math.random()].join(DELIMITER);\n    };\n\n    /**\n     * @inner\n     */\n    componentUtil.enableSubTypeDefaulter = function (entity) {\n\n        var subTypeDefaulters = {};\n\n        entity.registerSubTypeDefaulter = function (componentType, defaulter) {\n            componentType = parseClassType(componentType);\n            subTypeDefaulters[componentType.main] = defaulter;\n        };\n\n        entity.determineSubType = function (componentType, option) {\n            var type = option.type;\n            if (!type) {\n                var componentTypeMain = parseClassType(componentType).main;\n                if (entity.hasSubTypes(componentType) && subTypeDefaulters[componentTypeMain]) {\n                    type = subTypeDefaulters[componentTypeMain](option);\n                }\n            }\n            return type;\n        };\n\n        return entity;\n    };\n\n    /**\n     * Topological travel on Activity Network (Activity On Vertices).\n     * Dependencies is defined in Model.prototype.dependencies, like ['xAxis', 'yAxis'].\n     *\n     * If 'xAxis' or 'yAxis' is absent in componentTypeList, just ignore it in topology.\n     *\n     * If there is circle dependencey, Error will be thrown.\n     *\n     */\n    componentUtil.enableTopologicalTravel = function (entity, dependencyGetter) {\n\n        /**\n         * @public\n         * @param {Array.<string>} targetNameList Target Component type list.\n         *                                           Can be ['aa', 'bb', 'aa.xx']\n         * @param {Array.<string>} fullNameList By which we can build dependency graph.\n         * @param {Function} callback Params: componentType, dependencies.\n         * @param {Object} context Scope of callback.\n         */\n        entity.topologicalTravel = function (targetNameList, fullNameList, callback, context) {\n            if (!targetNameList.length) {\n                return;\n            }\n\n            var result = makeDepndencyGraph(fullNameList);\n            var graph = result.graph;\n            var stack = result.noEntryList;\n\n            var targetNameSet = {};\n            zrUtil.each(targetNameList, function (name) {\n                targetNameSet[name] = true;\n            });\n\n            while (stack.length) {\n                var currComponentType = stack.pop();\n                var currVertex = graph[currComponentType];\n                var isInTargetNameSet = !!targetNameSet[currComponentType];\n                if (isInTargetNameSet) {\n                    callback.call(context, currComponentType, currVertex.originalDeps.slice());\n                    delete targetNameSet[currComponentType];\n                }\n                zrUtil.each(\n                    currVertex.successor,\n                    isInTargetNameSet ? removeEdgeAndAdd : removeEdge\n                );\n            }\n\n            zrUtil.each(targetNameSet, function () {\n                throw new Error('Circle dependency may exists');\n            });\n\n            function removeEdge(succComponentType) {\n                graph[succComponentType].entryCount--;\n                if (graph[succComponentType].entryCount === 0) {\n                    stack.push(succComponentType);\n                }\n            }\n\n            // Consider this case: legend depends on series, and we call\n            // chart.setOption({series: [...]}), where only series is in option.\n            // If we do not have 'removeEdgeAndAdd', legendModel.mergeOption will\n            // not be called, but only sereis.mergeOption is called. Thus legend\n            // have no chance to update its local record about series (like which\n            // name of series is available in legend).\n            function removeEdgeAndAdd(succComponentType) {\n                targetNameSet[succComponentType] = true;\n                removeEdge(succComponentType);\n            }\n        };\n\n        /**\n         * DepndencyGraph: {Object}\n         * key: conponentType,\n         * value: {\n         *     successor: [conponentTypes...],\n         *     originalDeps: [conponentTypes...],\n         *     entryCount: {number}\n         * }\n         */\n        function makeDepndencyGraph(fullNameList) {\n            var graph = {};\n            var noEntryList = [];\n\n            zrUtil.each(fullNameList, function (name) {\n\n                var thisItem = createDependencyGraphItem(graph, name);\n                var originalDeps = thisItem.originalDeps = dependencyGetter(name);\n\n                var availableDeps = getAvailableDependencies(originalDeps, fullNameList);\n                thisItem.entryCount = availableDeps.length;\n                if (thisItem.entryCount === 0) {\n                    noEntryList.push(name);\n                }\n\n                zrUtil.each(availableDeps, function (dependentName) {\n                    if (zrUtil.indexOf(thisItem.predecessor, dependentName) < 0) {\n                        thisItem.predecessor.push(dependentName);\n                    }\n                    var thatItem = createDependencyGraphItem(graph, dependentName);\n                    if (zrUtil.indexOf(thatItem.successor, dependentName) < 0) {\n                        thatItem.successor.push(name);\n                    }\n                });\n            });\n\n            return {graph: graph, noEntryList: noEntryList};\n        }\n\n        function createDependencyGraphItem(graph, name) {\n            if (!graph[name]) {\n                graph[name] = {predecessor: [], successor: []};\n            }\n            return graph[name];\n        }\n\n        function getAvailableDependencies(originalDeps, fullNameList) {\n            var availableDeps = [];\n            zrUtil.each(originalDeps, function (dep) {\n                zrUtil.indexOf(fullNameList, dep) >= 0 && availableDeps.push(dep);\n            });\n            return availableDeps;\n        }\n    };\n\n    module.exports = componentUtil;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvdXRpbC9jb21wb25lbnQuanM/YWFmYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgY2xhenogPSByZXF1aXJlKCcuL2NsYXp6Jyk7XG5cbiAgICB2YXIgcGFyc2VDbGFzc1R5cGUgPSBjbGF6ei5wYXJzZUNsYXNzVHlwZTtcblxuICAgIHZhciBiYXNlID0gMDtcblxuICAgIHZhciBjb21wb25lbnRVdGlsID0ge307XG5cbiAgICB2YXIgREVMSU1JVEVSID0gJ18nO1xuXG4gICAgLyoqXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAqL1xuICAgIGNvbXBvbmVudFV0aWwuZ2V0VUlEID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgLy8gQ29uc2lkZXJpbmcgdGhlIGNhc2Ugb2YgY3Jvc3NpbmcganMgY29udGV4dCxcbiAgICAgICAgLy8gdXNlIE1hdGgucmFuZG9tIHRvIG1ha2UgaWQgYXMgdW5pcXVlIGFzIHBvc3NpYmxlLlxuICAgICAgICByZXR1cm4gWyh0eXBlIHx8ICcnKSwgYmFzZSsrLCBNYXRoLnJhbmRvbSgpXS5qb2luKERFTElNSVRFUik7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGNvbXBvbmVudFV0aWwuZW5hYmxlU3ViVHlwZURlZmF1bHRlciA9IGZ1bmN0aW9uIChlbnRpdHkpIHtcblxuICAgICAgICB2YXIgc3ViVHlwZURlZmF1bHRlcnMgPSB7fTtcblxuICAgICAgICBlbnRpdHkucmVnaXN0ZXJTdWJUeXBlRGVmYXVsdGVyID0gZnVuY3Rpb24gKGNvbXBvbmVudFR5cGUsIGRlZmF1bHRlcikge1xuICAgICAgICAgICAgY29tcG9uZW50VHlwZSA9IHBhcnNlQ2xhc3NUeXBlKGNvbXBvbmVudFR5cGUpO1xuICAgICAgICAgICAgc3ViVHlwZURlZmF1bHRlcnNbY29tcG9uZW50VHlwZS5tYWluXSA9IGRlZmF1bHRlcjtcbiAgICAgICAgfTtcblxuICAgICAgICBlbnRpdHkuZGV0ZXJtaW5lU3ViVHlwZSA9IGZ1bmN0aW9uIChjb21wb25lbnRUeXBlLCBvcHRpb24pIHtcbiAgICAgICAgICAgIHZhciB0eXBlID0gb3B0aW9uLnR5cGU7XG4gICAgICAgICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29tcG9uZW50VHlwZU1haW4gPSBwYXJzZUNsYXNzVHlwZShjb21wb25lbnRUeXBlKS5tYWluO1xuICAgICAgICAgICAgICAgIGlmIChlbnRpdHkuaGFzU3ViVHlwZXMoY29tcG9uZW50VHlwZSkgJiYgc3ViVHlwZURlZmF1bHRlcnNbY29tcG9uZW50VHlwZU1haW5dKSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGUgPSBzdWJUeXBlRGVmYXVsdGVyc1tjb21wb25lbnRUeXBlTWFpbl0ob3B0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gZW50aXR5O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUb3BvbG9naWNhbCB0cmF2ZWwgb24gQWN0aXZpdHkgTmV0d29yayAoQWN0aXZpdHkgT24gVmVydGljZXMpLlxuICAgICAqIERlcGVuZGVuY2llcyBpcyBkZWZpbmVkIGluIE1vZGVsLnByb3RvdHlwZS5kZXBlbmRlbmNpZXMsIGxpa2UgWyd4QXhpcycsICd5QXhpcyddLlxuICAgICAqXG4gICAgICogSWYgJ3hBeGlzJyBvciAneUF4aXMnIGlzIGFic2VudCBpbiBjb21wb25lbnRUeXBlTGlzdCwganVzdCBpZ25vcmUgaXQgaW4gdG9wb2xvZ3kuXG4gICAgICpcbiAgICAgKiBJZiB0aGVyZSBpcyBjaXJjbGUgZGVwZW5kZW5jZXksIEVycm9yIHdpbGwgYmUgdGhyb3duLlxuICAgICAqXG4gICAgICovXG4gICAgY29tcG9uZW50VXRpbC5lbmFibGVUb3BvbG9naWNhbFRyYXZlbCA9IGZ1bmN0aW9uIChlbnRpdHksIGRlcGVuZGVuY3lHZXR0ZXIpIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHB1YmxpY1xuICAgICAgICAgKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSB0YXJnZXROYW1lTGlzdCBUYXJnZXQgQ29tcG9uZW50IHR5cGUgbGlzdC5cbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ2FuIGJlIFsnYWEnLCAnYmInLCAnYWEueHgnXVxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBmdWxsTmFtZUxpc3QgQnkgd2hpY2ggd2UgY2FuIGJ1aWxkIGRlcGVuZGVuY3kgZ3JhcGguXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFBhcmFtczogY29tcG9uZW50VHlwZSwgZGVwZW5kZW5jaWVzLlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY29udGV4dCBTY29wZSBvZiBjYWxsYmFjay5cbiAgICAgICAgICovXG4gICAgICAgIGVudGl0eS50b3BvbG9naWNhbFRyYXZlbCA9IGZ1bmN0aW9uICh0YXJnZXROYW1lTGlzdCwgZnVsbE5hbWVMaXN0LCBjYWxsYmFjaywgY29udGV4dCkge1xuICAgICAgICAgICAgaWYgKCF0YXJnZXROYW1lTGlzdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBtYWtlRGVwbmRlbmN5R3JhcGgoZnVsbE5hbWVMaXN0KTtcbiAgICAgICAgICAgIHZhciBncmFwaCA9IHJlc3VsdC5ncmFwaDtcbiAgICAgICAgICAgIHZhciBzdGFjayA9IHJlc3VsdC5ub0VudHJ5TGlzdDtcblxuICAgICAgICAgICAgdmFyIHRhcmdldE5hbWVTZXQgPSB7fTtcbiAgICAgICAgICAgIHpyVXRpbC5lYWNoKHRhcmdldE5hbWVMaXN0LCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICAgIHRhcmdldE5hbWVTZXRbbmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY3VyckNvbXBvbmVudFR5cGUgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICB2YXIgY3VyclZlcnRleCA9IGdyYXBoW2N1cnJDb21wb25lbnRUeXBlXTtcbiAgICAgICAgICAgICAgICB2YXIgaXNJblRhcmdldE5hbWVTZXQgPSAhIXRhcmdldE5hbWVTZXRbY3VyckNvbXBvbmVudFR5cGVdO1xuICAgICAgICAgICAgICAgIGlmIChpc0luVGFyZ2V0TmFtZVNldCkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKGNvbnRleHQsIGN1cnJDb21wb25lbnRUeXBlLCBjdXJyVmVydGV4Lm9yaWdpbmFsRGVwcy5zbGljZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRhcmdldE5hbWVTZXRbY3VyckNvbXBvbmVudFR5cGVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB6clV0aWwuZWFjaChcbiAgICAgICAgICAgICAgICAgICAgY3VyclZlcnRleC5zdWNjZXNzb3IsXG4gICAgICAgICAgICAgICAgICAgIGlzSW5UYXJnZXROYW1lU2V0ID8gcmVtb3ZlRWRnZUFuZEFkZCA6IHJlbW92ZUVkZ2VcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB6clV0aWwuZWFjaCh0YXJnZXROYW1lU2V0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDaXJjbGUgZGVwZW5kZW5jeSBtYXkgZXhpc3RzJyk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gcmVtb3ZlRWRnZShzdWNjQ29tcG9uZW50VHlwZSkge1xuICAgICAgICAgICAgICAgIGdyYXBoW3N1Y2NDb21wb25lbnRUeXBlXS5lbnRyeUNvdW50LS07XG4gICAgICAgICAgICAgICAgaWYgKGdyYXBoW3N1Y2NDb21wb25lbnRUeXBlXS5lbnRyeUNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goc3VjY0NvbXBvbmVudFR5cGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ29uc2lkZXIgdGhpcyBjYXNlOiBsZWdlbmQgZGVwZW5kcyBvbiBzZXJpZXMsIGFuZCB3ZSBjYWxsXG4gICAgICAgICAgICAvLyBjaGFydC5zZXRPcHRpb24oe3NlcmllczogWy4uLl19KSwgd2hlcmUgb25seSBzZXJpZXMgaXMgaW4gb3B0aW9uLlxuICAgICAgICAgICAgLy8gSWYgd2UgZG8gbm90IGhhdmUgJ3JlbW92ZUVkZ2VBbmRBZGQnLCBsZWdlbmRNb2RlbC5tZXJnZU9wdGlvbiB3aWxsXG4gICAgICAgICAgICAvLyBub3QgYmUgY2FsbGVkLCBidXQgb25seSBzZXJlaXMubWVyZ2VPcHRpb24gaXMgY2FsbGVkLiBUaHVzIGxlZ2VuZFxuICAgICAgICAgICAgLy8gaGF2ZSBubyBjaGFuY2UgdG8gdXBkYXRlIGl0cyBsb2NhbCByZWNvcmQgYWJvdXQgc2VyaWVzIChsaWtlIHdoaWNoXG4gICAgICAgICAgICAvLyBuYW1lIG9mIHNlcmllcyBpcyBhdmFpbGFibGUgaW4gbGVnZW5kKS5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHJlbW92ZUVkZ2VBbmRBZGQoc3VjY0NvbXBvbmVudFR5cGUpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXROYW1lU2V0W3N1Y2NDb21wb25lbnRUeXBlXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmVtb3ZlRWRnZShzdWNjQ29tcG9uZW50VHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlcG5kZW5jeUdyYXBoOiB7T2JqZWN0fVxuICAgICAgICAgKiBrZXk6IGNvbnBvbmVudFR5cGUsXG4gICAgICAgICAqIHZhbHVlOiB7XG4gICAgICAgICAqICAgICBzdWNjZXNzb3I6IFtjb25wb25lbnRUeXBlcy4uLl0sXG4gICAgICAgICAqICAgICBvcmlnaW5hbERlcHM6IFtjb25wb25lbnRUeXBlcy4uLl0sXG4gICAgICAgICAqICAgICBlbnRyeUNvdW50OiB7bnVtYmVyfVxuICAgICAgICAgKiB9XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBtYWtlRGVwbmRlbmN5R3JhcGgoZnVsbE5hbWVMaXN0KSB7XG4gICAgICAgICAgICB2YXIgZ3JhcGggPSB7fTtcbiAgICAgICAgICAgIHZhciBub0VudHJ5TGlzdCA9IFtdO1xuXG4gICAgICAgICAgICB6clV0aWwuZWFjaChmdWxsTmFtZUxpc3QsIGZ1bmN0aW9uIChuYW1lKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgdGhpc0l0ZW0gPSBjcmVhdGVEZXBlbmRlbmN5R3JhcGhJdGVtKGdyYXBoLCBuYW1lKTtcbiAgICAgICAgICAgICAgICB2YXIgb3JpZ2luYWxEZXBzID0gdGhpc0l0ZW0ub3JpZ2luYWxEZXBzID0gZGVwZW5kZW5jeUdldHRlcihuYW1lKTtcblxuICAgICAgICAgICAgICAgIHZhciBhdmFpbGFibGVEZXBzID0gZ2V0QXZhaWxhYmxlRGVwZW5kZW5jaWVzKG9yaWdpbmFsRGVwcywgZnVsbE5hbWVMaXN0KTtcbiAgICAgICAgICAgICAgICB0aGlzSXRlbS5lbnRyeUNvdW50ID0gYXZhaWxhYmxlRGVwcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXNJdGVtLmVudHJ5Q291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbm9FbnRyeUxpc3QucHVzaChuYW1lKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB6clV0aWwuZWFjaChhdmFpbGFibGVEZXBzLCBmdW5jdGlvbiAoZGVwZW5kZW50TmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoenJVdGlsLmluZGV4T2YodGhpc0l0ZW0ucHJlZGVjZXNzb3IsIGRlcGVuZGVudE5hbWUpIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc0l0ZW0ucHJlZGVjZXNzb3IucHVzaChkZXBlbmRlbnROYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgdGhhdEl0ZW0gPSBjcmVhdGVEZXBlbmRlbmN5R3JhcGhJdGVtKGdyYXBoLCBkZXBlbmRlbnROYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHpyVXRpbC5pbmRleE9mKHRoYXRJdGVtLnN1Y2Nlc3NvciwgZGVwZW5kZW50TmFtZSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0SXRlbS5zdWNjZXNzb3IucHVzaChuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiB7Z3JhcGg6IGdyYXBoLCBub0VudHJ5TGlzdDogbm9FbnRyeUxpc3R9O1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlRGVwZW5kZW5jeUdyYXBoSXRlbShncmFwaCwgbmFtZSkge1xuICAgICAgICAgICAgaWYgKCFncmFwaFtuYW1lXSkge1xuICAgICAgICAgICAgICAgIGdyYXBoW25hbWVdID0ge3ByZWRlY2Vzc29yOiBbXSwgc3VjY2Vzc29yOiBbXX07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZ3JhcGhbbmFtZV07XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXRBdmFpbGFibGVEZXBlbmRlbmNpZXMob3JpZ2luYWxEZXBzLCBmdWxsTmFtZUxpc3QpIHtcbiAgICAgICAgICAgIHZhciBhdmFpbGFibGVEZXBzID0gW107XG4gICAgICAgICAgICB6clV0aWwuZWFjaChvcmlnaW5hbERlcHMsIGZ1bmN0aW9uIChkZXApIHtcbiAgICAgICAgICAgICAgICB6clV0aWwuaW5kZXhPZihmdWxsTmFtZUxpc3QsIGRlcCkgPj0gMCAmJiBhdmFpbGFibGVEZXBzLnB1c2goZGVwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGF2YWlsYWJsZURlcHM7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBjb21wb25lbnRVdGlsO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvdXRpbC9jb21wb25lbnQuanNcbi8vIG1vZHVsZSBpZCA9IDQ5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 50 */
/* unknown exports provided */
/* all exports used */
/*!******************************!*\
  !*** ./lib/visual/symbol.js ***!
  \******************************/
/***/ (function(module, exports) {

eval("\n\n    module.exports = function (seriesType, defaultSymbolType, legendSymbol, ecModel, api) {\n\n        // Encoding visual for all series include which is filtered for legend drawing\n        ecModel.eachRawSeriesByType(seriesType, function (seriesModel) {\n            var data = seriesModel.getData();\n\n            var symbolType = seriesModel.get('symbol') || defaultSymbolType;\n            var symbolSize = seriesModel.get('symbolSize');\n\n            data.setVisual({\n                legendSymbol: legendSymbol || symbolType,\n                symbol: symbolType,\n                symbolSize: symbolSize\n            });\n\n            // Only visible series has each data be visual encoded\n            if (!ecModel.isSeriesFiltered(seriesModel)) {\n                if (typeof symbolSize === 'function') {\n                    data.each(function (idx) {\n                        var rawValue = seriesModel.getRawValue(idx);\n                        // FIXME\n                        var params = seriesModel.getDataParams(idx);\n                        data.setItemVisual(idx, 'symbolSize', symbolSize(rawValue, params));\n                    });\n                }\n                data.each(function (idx) {\n                    var itemModel = data.getItemModel(idx);\n                    var itemSymbolType = itemModel.getShallow('symbol', true);\n                    var itemSymbolSize = itemModel.getShallow('symbolSize', true);\n                    // If has item symbol\n                    if (itemSymbolType != null) {\n                        data.setItemVisual(idx, 'symbol', itemSymbolType);\n                    }\n                    if (itemSymbolSize != null) {\n                        // PENDING Transform symbolSize ?\n                        data.setItemVisual(idx, 'symbolSize', itemSymbolSize);\n                    }\n                });\n            }\n        });\n    };\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvdmlzdWFsL3N5bWJvbC5qcz9jOWVmIl0sInNvdXJjZXNDb250ZW50IjpbIlxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc2VyaWVzVHlwZSwgZGVmYXVsdFN5bWJvbFR5cGUsIGxlZ2VuZFN5bWJvbCwgZWNNb2RlbCwgYXBpKSB7XG5cbiAgICAgICAgLy8gRW5jb2RpbmcgdmlzdWFsIGZvciBhbGwgc2VyaWVzIGluY2x1ZGUgd2hpY2ggaXMgZmlsdGVyZWQgZm9yIGxlZ2VuZCBkcmF3aW5nXG4gICAgICAgIGVjTW9kZWwuZWFjaFJhd1Nlcmllc0J5VHlwZShzZXJpZXNUeXBlLCBmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuXG4gICAgICAgICAgICB2YXIgc3ltYm9sVHlwZSA9IHNlcmllc01vZGVsLmdldCgnc3ltYm9sJykgfHwgZGVmYXVsdFN5bWJvbFR5cGU7XG4gICAgICAgICAgICB2YXIgc3ltYm9sU2l6ZSA9IHNlcmllc01vZGVsLmdldCgnc3ltYm9sU2l6ZScpO1xuXG4gICAgICAgICAgICBkYXRhLnNldFZpc3VhbCh7XG4gICAgICAgICAgICAgICAgbGVnZW5kU3ltYm9sOiBsZWdlbmRTeW1ib2wgfHwgc3ltYm9sVHlwZSxcbiAgICAgICAgICAgICAgICBzeW1ib2w6IHN5bWJvbFR5cGUsXG4gICAgICAgICAgICAgICAgc3ltYm9sU2l6ZTogc3ltYm9sU2l6ZVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIE9ubHkgdmlzaWJsZSBzZXJpZXMgaGFzIGVhY2ggZGF0YSBiZSB2aXN1YWwgZW5jb2RlZFxuICAgICAgICAgICAgaWYgKCFlY01vZGVsLmlzU2VyaWVzRmlsdGVyZWQoc2VyaWVzTW9kZWwpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzeW1ib2xTaXplID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEuZWFjaChmdW5jdGlvbiAoaWR4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmF3VmFsdWUgPSBzZXJpZXNNb2RlbC5nZXRSYXdWYWx1ZShpZHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRklYTUVcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJhbXMgPSBzZXJpZXNNb2RlbC5nZXREYXRhUGFyYW1zKGlkeCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnNldEl0ZW1WaXN1YWwoaWR4LCAnc3ltYm9sU2l6ZScsIHN5bWJvbFNpemUocmF3VmFsdWUsIHBhcmFtcykpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGF0YS5lYWNoKGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW1Nb2RlbCA9IGRhdGEuZ2V0SXRlbU1vZGVsKGlkeCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpdGVtU3ltYm9sVHlwZSA9IGl0ZW1Nb2RlbC5nZXRTaGFsbG93KCdzeW1ib2wnLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW1TeW1ib2xTaXplID0gaXRlbU1vZGVsLmdldFNoYWxsb3coJ3N5bWJvbFNpemUnLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgaGFzIGl0ZW0gc3ltYm9sXG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtU3ltYm9sVHlwZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnNldEl0ZW1WaXN1YWwoaWR4LCAnc3ltYm9sJywgaXRlbVN5bWJvbFR5cGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtU3ltYm9sU2l6ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQRU5ESU5HIFRyYW5zZm9ybSBzeW1ib2xTaXplID9cbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuc2V0SXRlbVZpc3VhbChpZHgsICdzeW1ib2xTaXplJywgaXRlbVN5bWJvbFNpemUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi92aXN1YWwvc3ltYm9sLmpzXG4vLyBtb2R1bGUgaWQgPSA1MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 51 */
/* unknown exports provided */
/* all exports used */
/*!**************************************!*\
  !*** ./lib/component/axisPointer.js ***!
  \**************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var echarts = __webpack_require__(/*! ../echarts */ 1);\n    var axisPointerModelHelper = __webpack_require__(/*! ./axisPointer/modelHelper */ 45);\n    var axisTrigger = __webpack_require__(/*! ./axisPointer/axisTrigger */ 208);\n    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 0);\n\n    __webpack_require__(/*! ./axisPointer/AxisPointerModel */ 206);\n    __webpack_require__(/*! ./axisPointer/AxisPointerView */ 207);\n\n    // CartesianAxisPointer is not supposed to be required here. But consider\n    // echarts.simple.js and online build tooltip, which only require gridSimple,\n    // CartesianAxisPointer should be able to required somewhere.\n    __webpack_require__(/*! ./axisPointer/CartesianAxisPointer */ 149);\n\n    echarts.registerPreprocessor(function (option) {\n        // Always has a global axisPointerModel for default setting.\n        if (option) {\n            (!option.axisPointer || option.axisPointer.length === 0)\n                && (option.axisPointer = {});\n\n            var link = option.axisPointer.link;\n            // Normalize to array to avoid object mergin. But if link\n            // is not set, remain null/undefined, otherwise it will\n            // override existent link setting.\n            if (link && !zrUtil.isArray(link)) {\n                option.axisPointer.link = [link];\n            }\n        }\n    });\n\n    // This process should proformed after coordinate systems created\n    // and series data processed. So put it on statistic processing stage.\n    echarts.registerProcessor(echarts.PRIORITY.PROCESSOR.STATISTIC, function (ecModel, api) {\n        // Build axisPointerModel, mergin tooltip.axisPointer model for each axis.\n        // allAxesInfo should be updated when setOption performed.\n        ecModel.getComponent('axisPointer').coordSysAxesInfo\n            = axisPointerModelHelper.collect(ecModel, api);\n    });\n\n    // Broadcast to all views.\n    echarts.registerAction({\n        type: 'updateAxisPointer',\n        event: 'updateAxisPointer',\n        update: ':updateAxisPointer'\n    }, function (payload, ecModel, api) {\n        var outputFinder = axisTrigger(\n            ecModel.getComponent('axisPointer').coordSysAxesInfo,\n            payload.currTrigger,\n            [payload.x, payload.y],\n            payload,\n            payload.dispatchAction || zrUtil.bind(api.dispatchAction, api),\n            ecModel,\n            api,\n            payload.tooltipOption,\n            payload.highDownKey\n        );\n\n        return outputFinder;\n    });\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvY29tcG9uZW50L2F4aXNQb2ludGVyLmpzPzYyZDkiXSwic291cmNlc0NvbnRlbnQiOlsiXG5cbiAgICB2YXIgZWNoYXJ0cyA9IHJlcXVpcmUoJy4uL2VjaGFydHMnKTtcbiAgICB2YXIgYXhpc1BvaW50ZXJNb2RlbEhlbHBlciA9IHJlcXVpcmUoJy4vYXhpc1BvaW50ZXIvbW9kZWxIZWxwZXInKTtcbiAgICB2YXIgYXhpc1RyaWdnZXIgPSByZXF1aXJlKCcuL2F4aXNQb2ludGVyL2F4aXNUcmlnZ2VyJyk7XG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuXG4gICAgcmVxdWlyZSgnLi9heGlzUG9pbnRlci9BeGlzUG9pbnRlck1vZGVsJyk7XG4gICAgcmVxdWlyZSgnLi9heGlzUG9pbnRlci9BeGlzUG9pbnRlclZpZXcnKTtcblxuICAgIC8vIENhcnRlc2lhbkF4aXNQb2ludGVyIGlzIG5vdCBzdXBwb3NlZCB0byBiZSByZXF1aXJlZCBoZXJlLiBCdXQgY29uc2lkZXJcbiAgICAvLyBlY2hhcnRzLnNpbXBsZS5qcyBhbmQgb25saW5lIGJ1aWxkIHRvb2x0aXAsIHdoaWNoIG9ubHkgcmVxdWlyZSBncmlkU2ltcGxlLFxuICAgIC8vIENhcnRlc2lhbkF4aXNQb2ludGVyIHNob3VsZCBiZSBhYmxlIHRvIHJlcXVpcmVkIHNvbWV3aGVyZS5cbiAgICByZXF1aXJlKCcuL2F4aXNQb2ludGVyL0NhcnRlc2lhbkF4aXNQb2ludGVyJyk7XG5cbiAgICBlY2hhcnRzLnJlZ2lzdGVyUHJlcHJvY2Vzc29yKGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICAgICAgLy8gQWx3YXlzIGhhcyBhIGdsb2JhbCBheGlzUG9pbnRlck1vZGVsIGZvciBkZWZhdWx0IHNldHRpbmcuXG4gICAgICAgIGlmIChvcHRpb24pIHtcbiAgICAgICAgICAgICghb3B0aW9uLmF4aXNQb2ludGVyIHx8IG9wdGlvbi5heGlzUG9pbnRlci5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgICAgJiYgKG9wdGlvbi5heGlzUG9pbnRlciA9IHt9KTtcblxuICAgICAgICAgICAgdmFyIGxpbmsgPSBvcHRpb24uYXhpc1BvaW50ZXIubGluaztcbiAgICAgICAgICAgIC8vIE5vcm1hbGl6ZSB0byBhcnJheSB0byBhdm9pZCBvYmplY3QgbWVyZ2luLiBCdXQgaWYgbGlua1xuICAgICAgICAgICAgLy8gaXMgbm90IHNldCwgcmVtYWluIG51bGwvdW5kZWZpbmVkLCBvdGhlcndpc2UgaXQgd2lsbFxuICAgICAgICAgICAgLy8gb3ZlcnJpZGUgZXhpc3RlbnQgbGluayBzZXR0aW5nLlxuICAgICAgICAgICAgaWYgKGxpbmsgJiYgIXpyVXRpbC5pc0FycmF5KGxpbmspKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9uLmF4aXNQb2ludGVyLmxpbmsgPSBbbGlua107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFRoaXMgcHJvY2VzcyBzaG91bGQgcHJvZm9ybWVkIGFmdGVyIGNvb3JkaW5hdGUgc3lzdGVtcyBjcmVhdGVkXG4gICAgLy8gYW5kIHNlcmllcyBkYXRhIHByb2Nlc3NlZC4gU28gcHV0IGl0IG9uIHN0YXRpc3RpYyBwcm9jZXNzaW5nIHN0YWdlLlxuICAgIGVjaGFydHMucmVnaXN0ZXJQcm9jZXNzb3IoZWNoYXJ0cy5QUklPUklUWS5QUk9DRVNTT1IuU1RBVElTVElDLCBmdW5jdGlvbiAoZWNNb2RlbCwgYXBpKSB7XG4gICAgICAgIC8vIEJ1aWxkIGF4aXNQb2ludGVyTW9kZWwsIG1lcmdpbiB0b29sdGlwLmF4aXNQb2ludGVyIG1vZGVsIGZvciBlYWNoIGF4aXMuXG4gICAgICAgIC8vIGFsbEF4ZXNJbmZvIHNob3VsZCBiZSB1cGRhdGVkIHdoZW4gc2V0T3B0aW9uIHBlcmZvcm1lZC5cbiAgICAgICAgZWNNb2RlbC5nZXRDb21wb25lbnQoJ2F4aXNQb2ludGVyJykuY29vcmRTeXNBeGVzSW5mb1xuICAgICAgICAgICAgPSBheGlzUG9pbnRlck1vZGVsSGVscGVyLmNvbGxlY3QoZWNNb2RlbCwgYXBpKTtcbiAgICB9KTtcblxuICAgIC8vIEJyb2FkY2FzdCB0byBhbGwgdmlld3MuXG4gICAgZWNoYXJ0cy5yZWdpc3RlckFjdGlvbih7XG4gICAgICAgIHR5cGU6ICd1cGRhdGVBeGlzUG9pbnRlcicsXG4gICAgICAgIGV2ZW50OiAndXBkYXRlQXhpc1BvaW50ZXInLFxuICAgICAgICB1cGRhdGU6ICc6dXBkYXRlQXhpc1BvaW50ZXInXG4gICAgfSwgZnVuY3Rpb24gKHBheWxvYWQsIGVjTW9kZWwsIGFwaSkge1xuICAgICAgICB2YXIgb3V0cHV0RmluZGVyID0gYXhpc1RyaWdnZXIoXG4gICAgICAgICAgICBlY01vZGVsLmdldENvbXBvbmVudCgnYXhpc1BvaW50ZXInKS5jb29yZFN5c0F4ZXNJbmZvLFxuICAgICAgICAgICAgcGF5bG9hZC5jdXJyVHJpZ2dlcixcbiAgICAgICAgICAgIFtwYXlsb2FkLngsIHBheWxvYWQueV0sXG4gICAgICAgICAgICBwYXlsb2FkLFxuICAgICAgICAgICAgcGF5bG9hZC5kaXNwYXRjaEFjdGlvbiB8fCB6clV0aWwuYmluZChhcGkuZGlzcGF0Y2hBY3Rpb24sIGFwaSksXG4gICAgICAgICAgICBlY01vZGVsLFxuICAgICAgICAgICAgYXBpLFxuICAgICAgICAgICAgcGF5bG9hZC50b29sdGlwT3B0aW9uLFxuICAgICAgICAgICAgcGF5bG9hZC5oaWdoRG93bktleVxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybiBvdXRwdXRGaW5kZXI7XG4gICAgfSk7XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2NvbXBvbmVudC9heGlzUG9pbnRlci5qc1xuLy8gbW9kdWxlIGlkID0gNTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 52 */
/* unknown exports provided */
/* all exports used */
/*!******************************************!*\
  !*** /home/yx/~/zrender/lib/core/log.js ***!
  \******************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\n        var config = __webpack_require__(/*! ../config */ 32);\n\n        /**\n         * @exports zrender/tool/log\n         * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n         */\n        module.exports = function() {\n            if (config.debugMode === 0) {\n                return;\n            }\n            else if (config.debugMode == 1) {\n                for (var k in arguments) {\n                    throw new Error(arguments[k]);\n                }\n            }\n            else if (config.debugMode > 1) {\n                for (var k in arguments) {\n                    console.log(arguments[k]);\n                }\n            }\n        };\n\n        /* for debug\n        return function(mes) {\n            document.getElementById('wrong-message').innerHTML =\n                mes + ' ' + (new Date() - 0)\n                + '<br/>'\n                + document.getElementById('wrong-message').innerHTML;\n        };\n        */\n    \n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL2hvbWUveXgvfi96cmVuZGVyL2xpYi9jb3JlL2xvZy5qcz82OWY5Il0sInNvdXJjZXNDb250ZW50IjpbIlxuICAgICAgICB2YXIgY29uZmlnID0gcmVxdWlyZSgnLi4vY29uZmlnJyk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBleHBvcnRzIHpyZW5kZXIvdG9vbC9sb2dcbiAgICAgICAgICogQGF1dGhvciBLZW5lciAoQEtlbmVyLeael+WzsCwga2VuZXIubGluZmVuZ0BnbWFpbC5jb20pXG4gICAgICAgICAqL1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKGNvbmZpZy5kZWJ1Z01vZGUgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb25maWcuZGVidWdNb2RlID09IDEpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrIGluIGFyZ3VtZW50cykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYXJndW1lbnRzW2tdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb25maWcuZGVidWdNb2RlID4gMSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGsgaW4gYXJndW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGFyZ3VtZW50c1trXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8qIGZvciBkZWJ1Z1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24obWVzKSB7XG4gICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnd3JvbmctbWVzc2FnZScpLmlubmVySFRNTCA9XG4gICAgICAgICAgICAgICAgbWVzICsgJyAnICsgKG5ldyBEYXRlKCkgLSAwKVxuICAgICAgICAgICAgICAgICsgJzxici8+J1xuICAgICAgICAgICAgICAgICsgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3dyb25nLW1lc3NhZ2UnKS5pbm5lckhUTUw7XG4gICAgICAgIH07XG4gICAgICAgICovXG4gICAgXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS95eC9+L3pyZW5kZXIvbGliL2NvcmUvbG9nLmpzXG4vLyBtb2R1bGUgaWQgPSA1MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 53 */
/* unknown exports provided */
/* all exports used */
/*!***********************************************!*\
  !*** /home/yx/~/zrender/lib/graphic/Image.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Image element\n * @module zrender/graphic/Image\n */\n\n\n\n    var Displayable = __webpack_require__(/*! ./Displayable */ 36);\n    var BoundingRect = __webpack_require__(/*! ../core/BoundingRect */ 10);\n    var zrUtil = __webpack_require__(/*! ../core/util */ 0);\n\n    var LRU = __webpack_require__(/*! ../core/LRU */ 61);\n    var globalImageCache = new LRU(50);\n    /**\n     * @alias zrender/graphic/Image\n     * @extends module:zrender/graphic/Displayable\n     * @constructor\n     * @param {Object} opts\n     */\n    function ZImage(opts) {\n        Displayable.call(this, opts);\n    }\n\n    ZImage.prototype = {\n\n        constructor: ZImage,\n\n        type: 'image',\n\n        brush: function (ctx, prevEl) {\n            var style = this.style;\n            var src = style.image;\n            var image;\n\n            // Must bind each time\n            style.bind(ctx, this, prevEl);\n            // style.image is a url string\n            if (typeof src === 'string') {\n                image = this._image;\n            }\n            // style.image is an HTMLImageElement or HTMLCanvasElement or Canvas\n            else {\n                image = src;\n            }\n            // FIXME Case create many images with src\n            if (!image && src) {\n                // Try get from global image cache\n                var cachedImgObj = globalImageCache.get(src);\n                if (!cachedImgObj) {\n                    // Create a new image\n                    image = new Image();\n                    image.onload = function () {\n                        image.onload = null;\n                        for (var i = 0; i < cachedImgObj.pending.length; i++) {\n                            cachedImgObj.pending[i].dirty();\n                        }\n                    };\n                    cachedImgObj = {\n                        image: image,\n                        pending: [this]\n                    };\n                    image.src = src;\n                    globalImageCache.put(src, cachedImgObj);\n                    this._image = image;\n                    return;\n                }\n                else {\n                    image = cachedImgObj.image;\n                    this._image = image;\n                    // Image is not complete finish, add to pending list\n                    if (!image.width || !image.height) {\n                        cachedImgObj.pending.push(this);\n                        return;\n                    }\n                }\n            }\n\n            if (image) {\n                // 图片已经加载完成\n                // if (image.nodeName.toUpperCase() == 'IMG') {\n                //     if (!image.complete) {\n                //         return;\n                //     }\n                // }\n                // Else is canvas\n\n                var x = style.x || 0;\n                var y = style.y || 0;\n                // 图片加载失败\n                if (!image.width || !image.height) {\n                    return;\n                }\n                var width = style.width;\n                var height = style.height;\n                var aspect = image.width / image.height;\n                if (width == null && height != null) {\n                    // Keep image/height ratio\n                    width = height * aspect;\n                }\n                else if (height == null && width != null) {\n                    height = width / aspect;\n                }\n                else if (width == null && height == null) {\n                    width = image.width;\n                    height = image.height;\n                }\n\n                // 设置transform\n                this.setTransform(ctx);\n\n                if (style.sWidth && style.sHeight) {\n                    var sx = style.sx || 0;\n                    var sy = style.sy || 0;\n                    ctx.drawImage(\n                        image,\n                        sx, sy, style.sWidth, style.sHeight,\n                        x, y, width, height\n                    );\n                }\n                else if (style.sx && style.sy) {\n                    var sx = style.sx;\n                    var sy = style.sy;\n                    var sWidth = width - sx;\n                    var sHeight = height - sy;\n                    ctx.drawImage(\n                        image,\n                        sx, sy, sWidth, sHeight,\n                        x, y, width, height\n                    );\n                }\n                else {\n                    ctx.drawImage(image, x, y, width, height);\n                }\n\n                this.restoreTransform(ctx);\n\n                // Draw rect text\n                if (style.text != null) {\n                    this.drawRectText(ctx, this.getBoundingRect());\n                }\n\n            }\n        },\n\n        getBoundingRect: function () {\n            var style = this.style;\n            if (! this._rect) {\n                this._rect = new BoundingRect(\n                    style.x || 0, style.y || 0, style.width || 0, style.height || 0\n                );\n            }\n            return this._rect;\n        }\n    };\n\n    zrUtil.inherits(ZImage, Displayable);\n\n    module.exports = ZImage;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL2hvbWUveXgvfi96cmVuZGVyL2xpYi9ncmFwaGljL0ltYWdlLmpzP2I1MjkiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBJbWFnZSBlbGVtZW50XG4gKiBAbW9kdWxlIHpyZW5kZXIvZ3JhcGhpYy9JbWFnZVxuICovXG5cblxuXG4gICAgdmFyIERpc3BsYXlhYmxlID0gcmVxdWlyZSgnLi9EaXNwbGF5YWJsZScpO1xuICAgIHZhciBCb3VuZGluZ1JlY3QgPSByZXF1aXJlKCcuLi9jb3JlL0JvdW5kaW5nUmVjdCcpO1xuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKTtcblxuICAgIHZhciBMUlUgPSByZXF1aXJlKCcuLi9jb3JlL0xSVScpO1xuICAgIHZhciBnbG9iYWxJbWFnZUNhY2hlID0gbmV3IExSVSg1MCk7XG4gICAgLyoqXG4gICAgICogQGFsaWFzIHpyZW5kZXIvZ3JhcGhpYy9JbWFnZVxuICAgICAqIEBleHRlbmRzIG1vZHVsZTp6cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIFpJbWFnZShvcHRzKSB7XG4gICAgICAgIERpc3BsYXlhYmxlLmNhbGwodGhpcywgb3B0cyk7XG4gICAgfVxuXG4gICAgWkltYWdlLnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogWkltYWdlLFxuXG4gICAgICAgIHR5cGU6ICdpbWFnZScsXG5cbiAgICAgICAgYnJ1c2g6IGZ1bmN0aW9uIChjdHgsIHByZXZFbCkge1xuICAgICAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTtcbiAgICAgICAgICAgIHZhciBzcmMgPSBzdHlsZS5pbWFnZTtcbiAgICAgICAgICAgIHZhciBpbWFnZTtcblxuICAgICAgICAgICAgLy8gTXVzdCBiaW5kIGVhY2ggdGltZVxuICAgICAgICAgICAgc3R5bGUuYmluZChjdHgsIHRoaXMsIHByZXZFbCk7XG4gICAgICAgICAgICAvLyBzdHlsZS5pbWFnZSBpcyBhIHVybCBzdHJpbmdcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3JjID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGltYWdlID0gdGhpcy5faW1hZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzdHlsZS5pbWFnZSBpcyBhbiBIVE1MSW1hZ2VFbGVtZW50IG9yIEhUTUxDYW52YXNFbGVtZW50IG9yIENhbnZhc1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW1hZ2UgPSBzcmM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGSVhNRSBDYXNlIGNyZWF0ZSBtYW55IGltYWdlcyB3aXRoIHNyY1xuICAgICAgICAgICAgaWYgKCFpbWFnZSAmJiBzcmMpIHtcbiAgICAgICAgICAgICAgICAvLyBUcnkgZ2V0IGZyb20gZ2xvYmFsIGltYWdlIGNhY2hlXG4gICAgICAgICAgICAgICAgdmFyIGNhY2hlZEltZ09iaiA9IGdsb2JhbEltYWdlQ2FjaGUuZ2V0KHNyYyk7XG4gICAgICAgICAgICAgICAgaWYgKCFjYWNoZWRJbWdPYmopIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IGltYWdlXG4gICAgICAgICAgICAgICAgICAgIGltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgICAgICAgICAgICAgICAgIGltYWdlLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlLm9ubG9hZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNhY2hlZEltZ09iai5wZW5kaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVkSW1nT2JqLnBlbmRpbmdbaV0uZGlydHkoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVkSW1nT2JqID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2U6IGltYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGVuZGluZzogW3RoaXNdXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGltYWdlLnNyYyA9IHNyYztcbiAgICAgICAgICAgICAgICAgICAgZ2xvYmFsSW1hZ2VDYWNoZS5wdXQoc3JjLCBjYWNoZWRJbWdPYmopO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbWFnZSA9IGltYWdlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbWFnZSA9IGNhY2hlZEltZ09iai5pbWFnZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW1hZ2UgPSBpbWFnZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW1hZ2UgaXMgbm90IGNvbXBsZXRlIGZpbmlzaCwgYWRkIHRvIHBlbmRpbmcgbGlzdFxuICAgICAgICAgICAgICAgICAgICBpZiAoIWltYWdlLndpZHRoIHx8ICFpbWFnZS5oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlZEltZ09iai5wZW5kaW5nLnB1c2godGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpbWFnZSkge1xuICAgICAgICAgICAgICAgIC8vIOWbvueJh+W3sue7j+WKoOi9veWujOaIkFxuICAgICAgICAgICAgICAgIC8vIGlmIChpbWFnZS5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpID09ICdJTUcnKSB7XG4gICAgICAgICAgICAgICAgLy8gICAgIGlmICghaW1hZ2UuY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAvLyAgICAgfVxuICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICAvLyBFbHNlIGlzIGNhbnZhc1xuXG4gICAgICAgICAgICAgICAgdmFyIHggPSBzdHlsZS54IHx8IDA7XG4gICAgICAgICAgICAgICAgdmFyIHkgPSBzdHlsZS55IHx8IDA7XG4gICAgICAgICAgICAgICAgLy8g5Zu+54mH5Yqg6L295aSx6LSlXG4gICAgICAgICAgICAgICAgaWYgKCFpbWFnZS53aWR0aCB8fCAhaW1hZ2UuaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gc3R5bGUud2lkdGg7XG4gICAgICAgICAgICAgICAgdmFyIGhlaWdodCA9IHN0eWxlLmhlaWdodDtcbiAgICAgICAgICAgICAgICB2YXIgYXNwZWN0ID0gaW1hZ2Uud2lkdGggLyBpbWFnZS5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgaWYgKHdpZHRoID09IG51bGwgJiYgaGVpZ2h0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gS2VlcCBpbWFnZS9oZWlnaHQgcmF0aW9cbiAgICAgICAgICAgICAgICAgICAgd2lkdGggPSBoZWlnaHQgKiBhc3BlY3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGhlaWdodCA9PSBudWxsICYmIHdpZHRoICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gd2lkdGggLyBhc3BlY3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHdpZHRoID09IG51bGwgJiYgaGVpZ2h0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGggPSBpbWFnZS53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIOiuvue9rnRyYW5zZm9ybVxuICAgICAgICAgICAgICAgIHRoaXMuc2V0VHJhbnNmb3JtKGN0eCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoc3R5bGUuc1dpZHRoICYmIHN0eWxlLnNIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN4ID0gc3R5bGUuc3ggfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN5ID0gc3R5bGUuc3kgfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShcbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3gsIHN5LCBzdHlsZS5zV2lkdGgsIHN0eWxlLnNIZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICB4LCB5LCB3aWR0aCwgaGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHN0eWxlLnN4ICYmIHN0eWxlLnN5KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzeCA9IHN0eWxlLnN4O1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3kgPSBzdHlsZS5zeTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNXaWR0aCA9IHdpZHRoIC0gc3g7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzSGVpZ2h0ID0gaGVpZ2h0IC0gc3k7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UoXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN4LCBzeSwgc1dpZHRoLCBzSGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgeCwgeSwgd2lkdGgsIGhlaWdodFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShpbWFnZSwgeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5yZXN0b3JlVHJhbnNmb3JtKGN0eCk7XG5cbiAgICAgICAgICAgICAgICAvLyBEcmF3IHJlY3QgdGV4dFxuICAgICAgICAgICAgICAgIGlmIChzdHlsZS50ZXh0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3UmVjdFRleHQoY3R4LCB0aGlzLmdldEJvdW5kaW5nUmVjdCgpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBnZXRCb3VuZGluZ1JlY3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XG4gICAgICAgICAgICBpZiAoISB0aGlzLl9yZWN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVjdCA9IG5ldyBCb3VuZGluZ1JlY3QoXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlLnggfHwgMCwgc3R5bGUueSB8fCAwLCBzdHlsZS53aWR0aCB8fCAwLCBzdHlsZS5oZWlnaHQgfHwgMFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVjdDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB6clV0aWwuaW5oZXJpdHMoWkltYWdlLCBEaXNwbGF5YWJsZSk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFpJbWFnZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9ob21lL3l4L34venJlbmRlci9saWIvZ3JhcGhpYy9JbWFnZS5qc1xuLy8gbW9kdWxlIGlkID0gNTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 54 */
/* unknown exports provided */
/* all exports used */
/*!*****************************************************!*\
  !*** /home/yx/~/zrender/lib/mixin/Transformable.js ***!
  \*****************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * 提供变换扩展\n * @module zrender/mixin/Transformable\n * @author pissang (https://www.github.com/pissang)\n */\n\n\n    var matrix = __webpack_require__(/*! ../core/matrix */ 18);\n    var vector = __webpack_require__(/*! ../core/vector */ 4);\n    var mIdentity = matrix.identity;\n\n    var EPSILON = 5e-5;\n\n    function isNotAroundZero(val) {\n        return val > EPSILON || val < -EPSILON;\n    }\n\n    /**\n     * @alias module:zrender/mixin/Transformable\n     * @constructor\n     */\n    var Transformable = function (opts) {\n        opts = opts || {};\n        // If there are no given position, rotation, scale\n        if (!opts.position) {\n            /**\n             * 平移\n             * @type {Array.<number>}\n             * @default [0, 0]\n             */\n            this.position = [0, 0];\n        }\n        if (opts.rotation == null) {\n            /**\n             * 旋转\n             * @type {Array.<number>}\n             * @default 0\n             */\n            this.rotation = 0;\n        }\n        if (!opts.scale) {\n            /**\n             * 缩放\n             * @type {Array.<number>}\n             * @default [1, 1]\n             */\n            this.scale = [1, 1];\n        }\n        /**\n         * 旋转和缩放的原点\n         * @type {Array.<number>}\n         * @default null\n         */\n        this.origin = this.origin || null;\n    };\n\n    var transformableProto = Transformable.prototype;\n    transformableProto.transform = null;\n\n    /**\n     * 判断是否需要有坐标变换\n     * 如果有坐标变换, 则从position, rotation, scale以及父节点的transform计算出自身的transform矩阵\n     */\n    transformableProto.needLocalTransform = function () {\n        return isNotAroundZero(this.rotation)\n            || isNotAroundZero(this.position[0])\n            || isNotAroundZero(this.position[1])\n            || isNotAroundZero(this.scale[0] - 1)\n            || isNotAroundZero(this.scale[1] - 1);\n    };\n\n    transformableProto.updateTransform = function () {\n        var parent = this.parent;\n        var parentHasTransform = parent && parent.transform;\n        var needLocalTransform = this.needLocalTransform();\n\n        var m = this.transform;\n        if (!(needLocalTransform || parentHasTransform)) {\n            m && mIdentity(m);\n            return;\n        }\n\n        m = m || matrix.create();\n\n        if (needLocalTransform) {\n            this.getLocalTransform(m);\n        }\n        else {\n            mIdentity(m);\n        }\n\n        // 应用父节点变换\n        if (parentHasTransform) {\n            if (needLocalTransform) {\n                matrix.mul(m, parent.transform, m);\n            }\n            else {\n                matrix.copy(m, parent.transform);\n            }\n        }\n        // 保存这个变换矩阵\n        this.transform = m;\n\n        this.invTransform = this.invTransform || matrix.create();\n        matrix.invert(this.invTransform, m);\n    };\n\n    transformableProto.getLocalTransform = function (m) {\n        return Transformable.getLocalTransform(this, m);\n    };\n\n    /**\n     * 将自己的transform应用到context上\n     * @param {Context2D} ctx\n     */\n    transformableProto.setTransform = function (ctx) {\n        var m = this.transform;\n        var dpr = ctx.dpr || 1;\n        if (m) {\n            ctx.setTransform(dpr * m[0], dpr * m[1], dpr * m[2], dpr * m[3], dpr * m[4], dpr * m[5]);\n        }\n        else {\n            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n        }\n    };\n\n    transformableProto.restoreTransform = function (ctx) {\n        var dpr = ctx.dpr || 1;\n        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n    };\n\n    var tmpTransform = [];\n\n    /**\n     * 分解`transform`矩阵到`position`, `rotation`, `scale`\n     */\n    transformableProto.decomposeTransform = function () {\n        if (!this.transform) {\n            return;\n        }\n        var parent = this.parent;\n        var m = this.transform;\n        if (parent && parent.transform) {\n            // Get local transform and decompose them to position, scale, rotation\n            matrix.mul(tmpTransform, parent.invTransform, m);\n            m = tmpTransform;\n        }\n        var sx = m[0] * m[0] + m[1] * m[1];\n        var sy = m[2] * m[2] + m[3] * m[3];\n        var position = this.position;\n        var scale = this.scale;\n        if (isNotAroundZero(sx - 1)) {\n            sx = Math.sqrt(sx);\n        }\n        if (isNotAroundZero(sy - 1)) {\n            sy = Math.sqrt(sy);\n        }\n        if (m[0] < 0) {\n            sx = -sx;\n        }\n        if (m[3] < 0) {\n            sy = -sy;\n        }\n        position[0] = m[4];\n        position[1] = m[5];\n        scale[0] = sx;\n        scale[1] = sy;\n        this.rotation = Math.atan2(-m[1] / sy, m[0] / sx);\n    };\n\n    /**\n     * Get global scale\n     * @return {Array.<number>}\n     */\n    transformableProto.getGlobalScale = function () {\n        var m = this.transform;\n        if (!m) {\n            return [1, 1];\n        }\n        var sx = Math.sqrt(m[0] * m[0] + m[1] * m[1]);\n        var sy = Math.sqrt(m[2] * m[2] + m[3] * m[3]);\n        if (m[0] < 0) {\n            sx = -sx;\n        }\n        if (m[3] < 0) {\n            sy = -sy;\n        }\n        return [sx, sy];\n    };\n    /**\n     * 变换坐标位置到 shape 的局部坐标空间\n     * @method\n     * @param {number} x\n     * @param {number} y\n     * @return {Array.<number>}\n     */\n    transformableProto.transformCoordToLocal = function (x, y) {\n        var v2 = [x, y];\n        var invTransform = this.invTransform;\n        if (invTransform) {\n            vector.applyTransform(v2, v2, invTransform);\n        }\n        return v2;\n    };\n\n    /**\n     * 变换局部坐标位置到全局坐标空间\n     * @method\n     * @param {number} x\n     * @param {number} y\n     * @return {Array.<number>}\n     */\n    transformableProto.transformCoordToGlobal = function (x, y) {\n        var v2 = [x, y];\n        var transform = this.transform;\n        if (transform) {\n            vector.applyTransform(v2, v2, transform);\n        }\n        return v2;\n    };\n\n    /**\n     * @static\n     * @param {Object} target\n     * @param {Array.<number>} target.origin\n     * @param {number} target.rotation\n     * @param {Array.<number>} target.position\n     * @param {Array.<number>} [m]\n     */\n    Transformable.getLocalTransform = function (target, m) {\n        m = m || [];\n        mIdentity(m);\n\n        var origin = target.origin;\n        var scale = target.scale || [1, 1];\n        var rotation = target.rotation || 0;\n        var position = target.position || [0, 0];\n\n        if (origin) {\n            // Translate to origin\n            m[4] -= origin[0];\n            m[5] -= origin[1];\n        }\n        matrix.scale(m, m, scale);\n        if (rotation) {\n            matrix.rotate(m, m, rotation);\n        }\n        if (origin) {\n            // Translate back from origin\n            m[4] += origin[0];\n            m[5] += origin[1];\n        }\n\n        m[4] += position[0];\n        m[5] += position[1];\n\n        return m;\n    };\n\n    module.exports = Transformable;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL2hvbWUveXgvfi96cmVuZGVyL2xpYi9taXhpbi9UcmFuc2Zvcm1hYmxlLmpzPzNhZWEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuLyoqXG4gKiDmj5Dkvpvlj5jmjaLmianlsZVcbiAqIEBtb2R1bGUgenJlbmRlci9taXhpbi9UcmFuc2Zvcm1hYmxlXG4gKiBAYXV0aG9yIHBpc3NhbmcgKGh0dHBzOi8vd3d3LmdpdGh1Yi5jb20vcGlzc2FuZylcbiAqL1xuXG5cbiAgICB2YXIgbWF0cml4ID0gcmVxdWlyZSgnLi4vY29yZS9tYXRyaXgnKTtcbiAgICB2YXIgdmVjdG9yID0gcmVxdWlyZSgnLi4vY29yZS92ZWN0b3InKTtcbiAgICB2YXIgbUlkZW50aXR5ID0gbWF0cml4LmlkZW50aXR5O1xuXG4gICAgdmFyIEVQU0lMT04gPSA1ZS01O1xuXG4gICAgZnVuY3Rpb24gaXNOb3RBcm91bmRaZXJvKHZhbCkge1xuICAgICAgICByZXR1cm4gdmFsID4gRVBTSUxPTiB8fCB2YWwgPCAtRVBTSUxPTjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvbWl4aW4vVHJhbnNmb3JtYWJsZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIHZhciBUcmFuc2Zvcm1hYmxlID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBnaXZlbiBwb3NpdGlvbiwgcm90YXRpb24sIHNjYWxlXG4gICAgICAgIGlmICghb3B0cy5wb3NpdGlvbikge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiDlubPnp7tcbiAgICAgICAgICAgICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICAgICAgICAgICAqIEBkZWZhdWx0IFswLCAwXVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uID0gWzAsIDBdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRzLnJvdGF0aW9uID09IG51bGwpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICog5peL6L2sXG4gICAgICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAgICAgICAgICAgKiBAZGVmYXVsdCAwXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMucm90YXRpb24gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICghb3B0cy5zY2FsZSkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiDnvKnmlL5cbiAgICAgICAgICAgICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICAgICAgICAgICAqIEBkZWZhdWx0IFsxLCAxXVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnNjYWxlID0gWzEsIDFdO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDml4vovazlkoznvKnmlL7nmoTljp/ngrlcbiAgICAgICAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICAgICAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9yaWdpbiA9IHRoaXMub3JpZ2luIHx8IG51bGw7XG4gICAgfTtcblxuICAgIHZhciB0cmFuc2Zvcm1hYmxlUHJvdG8gPSBUcmFuc2Zvcm1hYmxlLnByb3RvdHlwZTtcbiAgICB0cmFuc2Zvcm1hYmxlUHJvdG8udHJhbnNmb3JtID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIOWIpOaWreaYr+WQpumcgOimgeacieWdkOagh+WPmOaNolxuICAgICAqIOWmguaenOacieWdkOagh+WPmOaNoiwg5YiZ5LuOcG9zaXRpb24sIHJvdGF0aW9uLCBzY2FsZeS7peWPiueItuiKgueCueeahHRyYW5zZm9ybeiuoeeul+WHuuiHqui6q+eahHRyYW5zZm9ybeefqemYtVxuICAgICAqL1xuICAgIHRyYW5zZm9ybWFibGVQcm90by5uZWVkTG9jYWxUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBpc05vdEFyb3VuZFplcm8odGhpcy5yb3RhdGlvbilcbiAgICAgICAgICAgIHx8IGlzTm90QXJvdW5kWmVybyh0aGlzLnBvc2l0aW9uWzBdKVxuICAgICAgICAgICAgfHwgaXNOb3RBcm91bmRaZXJvKHRoaXMucG9zaXRpb25bMV0pXG4gICAgICAgICAgICB8fCBpc05vdEFyb3VuZFplcm8odGhpcy5zY2FsZVswXSAtIDEpXG4gICAgICAgICAgICB8fCBpc05vdEFyb3VuZFplcm8odGhpcy5zY2FsZVsxXSAtIDEpO1xuICAgIH07XG5cbiAgICB0cmFuc2Zvcm1hYmxlUHJvdG8udXBkYXRlVHJhbnNmb3JtID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XG4gICAgICAgIHZhciBwYXJlbnRIYXNUcmFuc2Zvcm0gPSBwYXJlbnQgJiYgcGFyZW50LnRyYW5zZm9ybTtcbiAgICAgICAgdmFyIG5lZWRMb2NhbFRyYW5zZm9ybSA9IHRoaXMubmVlZExvY2FsVHJhbnNmb3JtKCk7XG5cbiAgICAgICAgdmFyIG0gPSB0aGlzLnRyYW5zZm9ybTtcbiAgICAgICAgaWYgKCEobmVlZExvY2FsVHJhbnNmb3JtIHx8IHBhcmVudEhhc1RyYW5zZm9ybSkpIHtcbiAgICAgICAgICAgIG0gJiYgbUlkZW50aXR5KG0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbSA9IG0gfHwgbWF0cml4LmNyZWF0ZSgpO1xuXG4gICAgICAgIGlmIChuZWVkTG9jYWxUcmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0TG9jYWxUcmFuc2Zvcm0obSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtSWRlbnRpdHkobSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyDlupTnlKjniLboioLngrnlj5jmjaJcbiAgICAgICAgaWYgKHBhcmVudEhhc1RyYW5zZm9ybSkge1xuICAgICAgICAgICAgaWYgKG5lZWRMb2NhbFRyYW5zZm9ybSkge1xuICAgICAgICAgICAgICAgIG1hdHJpeC5tdWwobSwgcGFyZW50LnRyYW5zZm9ybSwgbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtYXRyaXguY29weShtLCBwYXJlbnQudHJhbnNmb3JtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyDkv53lrZjov5nkuKrlj5jmjaLnn6npmLVcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0gPSBtO1xuXG4gICAgICAgIHRoaXMuaW52VHJhbnNmb3JtID0gdGhpcy5pbnZUcmFuc2Zvcm0gfHwgbWF0cml4LmNyZWF0ZSgpO1xuICAgICAgICBtYXRyaXguaW52ZXJ0KHRoaXMuaW52VHJhbnNmb3JtLCBtKTtcbiAgICB9O1xuXG4gICAgdHJhbnNmb3JtYWJsZVByb3RvLmdldExvY2FsVHJhbnNmb3JtID0gZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgcmV0dXJuIFRyYW5zZm9ybWFibGUuZ2V0TG9jYWxUcmFuc2Zvcm0odGhpcywgbSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIOWwhuiHquW3seeahHRyYW5zZm9ybeW6lOeUqOWIsGNvbnRleHTkuIpcbiAgICAgKiBAcGFyYW0ge0NvbnRleHQyRH0gY3R4XG4gICAgICovXG4gICAgdHJhbnNmb3JtYWJsZVByb3RvLnNldFRyYW5zZm9ybSA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgdmFyIG0gPSB0aGlzLnRyYW5zZm9ybTtcbiAgICAgICAgdmFyIGRwciA9IGN0eC5kcHIgfHwgMTtcbiAgICAgICAgaWYgKG0pIHtcbiAgICAgICAgICAgIGN0eC5zZXRUcmFuc2Zvcm0oZHByICogbVswXSwgZHByICogbVsxXSwgZHByICogbVsyXSwgZHByICogbVszXSwgZHByICogbVs0XSwgZHByICogbVs1XSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjdHguc2V0VHJhbnNmb3JtKGRwciwgMCwgMCwgZHByLCAwLCAwKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB0cmFuc2Zvcm1hYmxlUHJvdG8ucmVzdG9yZVRyYW5zZm9ybSA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgdmFyIGRwciA9IGN0eC5kcHIgfHwgMTtcbiAgICAgICAgY3R4LnNldFRyYW5zZm9ybShkcHIsIDAsIDAsIGRwciwgMCwgMCk7XG4gICAgfTtcblxuICAgIHZhciB0bXBUcmFuc2Zvcm0gPSBbXTtcblxuICAgIC8qKlxuICAgICAqIOWIhuino2B0cmFuc2Zvcm1g55+p6Zi15YiwYHBvc2l0aW9uYCwgYHJvdGF0aW9uYCwgYHNjYWxlYFxuICAgICAqL1xuICAgIHRyYW5zZm9ybWFibGVQcm90by5kZWNvbXBvc2VUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy50cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XG4gICAgICAgIHZhciBtID0gdGhpcy50cmFuc2Zvcm07XG4gICAgICAgIGlmIChwYXJlbnQgJiYgcGFyZW50LnRyYW5zZm9ybSkge1xuICAgICAgICAgICAgLy8gR2V0IGxvY2FsIHRyYW5zZm9ybSBhbmQgZGVjb21wb3NlIHRoZW0gdG8gcG9zaXRpb24sIHNjYWxlLCByb3RhdGlvblxuICAgICAgICAgICAgbWF0cml4Lm11bCh0bXBUcmFuc2Zvcm0sIHBhcmVudC5pbnZUcmFuc2Zvcm0sIG0pO1xuICAgICAgICAgICAgbSA9IHRtcFRyYW5zZm9ybTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3ggPSBtWzBdICogbVswXSArIG1bMV0gKiBtWzFdO1xuICAgICAgICB2YXIgc3kgPSBtWzJdICogbVsyXSArIG1bM10gKiBtWzNdO1xuICAgICAgICB2YXIgcG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uO1xuICAgICAgICB2YXIgc2NhbGUgPSB0aGlzLnNjYWxlO1xuICAgICAgICBpZiAoaXNOb3RBcm91bmRaZXJvKHN4IC0gMSkpIHtcbiAgICAgICAgICAgIHN4ID0gTWF0aC5zcXJ0KHN4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNOb3RBcm91bmRaZXJvKHN5IC0gMSkpIHtcbiAgICAgICAgICAgIHN5ID0gTWF0aC5zcXJ0KHN5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobVswXSA8IDApIHtcbiAgICAgICAgICAgIHN4ID0gLXN4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChtWzNdIDwgMCkge1xuICAgICAgICAgICAgc3kgPSAtc3k7XG4gICAgICAgIH1cbiAgICAgICAgcG9zaXRpb25bMF0gPSBtWzRdO1xuICAgICAgICBwb3NpdGlvblsxXSA9IG1bNV07XG4gICAgICAgIHNjYWxlWzBdID0gc3g7XG4gICAgICAgIHNjYWxlWzFdID0gc3k7XG4gICAgICAgIHRoaXMucm90YXRpb24gPSBNYXRoLmF0YW4yKC1tWzFdIC8gc3ksIG1bMF0gLyBzeCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBnbG9iYWwgc2NhbGVcbiAgICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAgICAgKi9cbiAgICB0cmFuc2Zvcm1hYmxlUHJvdG8uZ2V0R2xvYmFsU2NhbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtID0gdGhpcy50cmFuc2Zvcm07XG4gICAgICAgIGlmICghbSkge1xuICAgICAgICAgICAgcmV0dXJuIFsxLCAxXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3ggPSBNYXRoLnNxcnQobVswXSAqIG1bMF0gKyBtWzFdICogbVsxXSk7XG4gICAgICAgIHZhciBzeSA9IE1hdGguc3FydChtWzJdICogbVsyXSArIG1bM10gKiBtWzNdKTtcbiAgICAgICAgaWYgKG1bMF0gPCAwKSB7XG4gICAgICAgICAgICBzeCA9IC1zeDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobVszXSA8IDApIHtcbiAgICAgICAgICAgIHN5ID0gLXN5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbc3gsIHN5XTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIOWPmOaNouWdkOagh+S9jee9ruWIsCBzaGFwZSDnmoTlsYDpg6jlnZDmoIfnqbrpl7RcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICAgICAqL1xuICAgIHRyYW5zZm9ybWFibGVQcm90by50cmFuc2Zvcm1Db29yZFRvTG9jYWwgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICB2YXIgdjIgPSBbeCwgeV07XG4gICAgICAgIHZhciBpbnZUcmFuc2Zvcm0gPSB0aGlzLmludlRyYW5zZm9ybTtcbiAgICAgICAgaWYgKGludlRyYW5zZm9ybSkge1xuICAgICAgICAgICAgdmVjdG9yLmFwcGx5VHJhbnNmb3JtKHYyLCB2MiwgaW52VHJhbnNmb3JtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdjI7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIOWPmOaNouWxgOmDqOWdkOagh+S9jee9ruWIsOWFqOWxgOWdkOagh+epuumXtFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gICAgICovXG4gICAgdHJhbnNmb3JtYWJsZVByb3RvLnRyYW5zZm9ybUNvb3JkVG9HbG9iYWwgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICB2YXIgdjIgPSBbeCwgeV07XG4gICAgICAgIHZhciB0cmFuc2Zvcm0gPSB0aGlzLnRyYW5zZm9ybTtcbiAgICAgICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgICAgICAgdmVjdG9yLmFwcGx5VHJhbnNmb3JtKHYyLCB2MiwgdHJhbnNmb3JtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdjI7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gdGFyZ2V0Lm9yaWdpblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0YXJnZXQucm90YXRpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB0YXJnZXQucG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBbbV1cbiAgICAgKi9cbiAgICBUcmFuc2Zvcm1hYmxlLmdldExvY2FsVHJhbnNmb3JtID0gZnVuY3Rpb24gKHRhcmdldCwgbSkge1xuICAgICAgICBtID0gbSB8fCBbXTtcbiAgICAgICAgbUlkZW50aXR5KG0pO1xuXG4gICAgICAgIHZhciBvcmlnaW4gPSB0YXJnZXQub3JpZ2luO1xuICAgICAgICB2YXIgc2NhbGUgPSB0YXJnZXQuc2NhbGUgfHwgWzEsIDFdO1xuICAgICAgICB2YXIgcm90YXRpb24gPSB0YXJnZXQucm90YXRpb24gfHwgMDtcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gdGFyZ2V0LnBvc2l0aW9uIHx8IFswLCAwXTtcblxuICAgICAgICBpZiAob3JpZ2luKSB7XG4gICAgICAgICAgICAvLyBUcmFuc2xhdGUgdG8gb3JpZ2luXG4gICAgICAgICAgICBtWzRdIC09IG9yaWdpblswXTtcbiAgICAgICAgICAgIG1bNV0gLT0gb3JpZ2luWzFdO1xuICAgICAgICB9XG4gICAgICAgIG1hdHJpeC5zY2FsZShtLCBtLCBzY2FsZSk7XG4gICAgICAgIGlmIChyb3RhdGlvbikge1xuICAgICAgICAgICAgbWF0cml4LnJvdGF0ZShtLCBtLCByb3RhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9yaWdpbikge1xuICAgICAgICAgICAgLy8gVHJhbnNsYXRlIGJhY2sgZnJvbSBvcmlnaW5cbiAgICAgICAgICAgIG1bNF0gKz0gb3JpZ2luWzBdO1xuICAgICAgICAgICAgbVs1XSArPSBvcmlnaW5bMV07XG4gICAgICAgIH1cblxuICAgICAgICBtWzRdICs9IHBvc2l0aW9uWzBdO1xuICAgICAgICBtWzVdICs9IHBvc2l0aW9uWzFdO1xuXG4gICAgICAgIHJldHVybiBtO1xuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFRyYW5zZm9ybWFibGU7XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9ob21lL3l4L34venJlbmRlci9saWIvbWl4aW4vVHJhbnNmb3JtYWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gNTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 55 */
/* unknown exports provided */
/* all exports used */
/*!************************************!*\
  !*** ./lib/chart/helper/Symbol.js ***!
  \************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * @module echarts/chart/helper/Symbol\n */\n\n\n    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 0);\n    var symbolUtil = __webpack_require__(/*! ../../util/symbol */ 23);\n    var graphic = __webpack_require__(/*! ../../util/graphic */ 2);\n    var numberUtil = __webpack_require__(/*! ../../util/number */ 3);\n\n    function getSymbolSize(data, idx) {\n        var symbolSize = data.getItemVisual(idx, 'symbolSize');\n        return symbolSize instanceof Array\n            ? symbolSize.slice()\n            : [+symbolSize, +symbolSize];\n    }\n\n    function getScale(symbolSize) {\n        return [symbolSize[0] / 2, symbolSize[1] / 2];\n    }\n\n    /**\n     * @constructor\n     * @alias {module:echarts/chart/helper/Symbol}\n     * @param {module:echarts/data/List} data\n     * @param {number} idx\n     * @extends {module:zrender/graphic/Group}\n     */\n    function Symbol(data, idx, seriesScope) {\n        graphic.Group.call(this);\n\n        this.updateData(data, idx, seriesScope);\n    }\n\n    var symbolProto = Symbol.prototype;\n\n    function driftSymbol(dx, dy) {\n        this.parent.drift(dx, dy);\n    }\n\n    symbolProto._createSymbol = function (symbolType, data, idx, symbolSize) {\n        // Remove paths created before\n        this.removeAll();\n\n        var seriesModel = data.hostModel;\n        var color = data.getItemVisual(idx, 'color');\n\n        // var symbolPath = symbolUtil.createSymbol(\n        //     symbolType, -0.5, -0.5, 1, 1, color\n        // );\n        // If width/height are set too small (e.g., set to 1) on ios10\n        // and macOS Sierra, a circle stroke become a rect, no matter what\n        // the scale is set. So we set width/height as 2. See #4150.\n        var symbolPath = symbolUtil.createSymbol(\n            symbolType, -1, -1, 2, 2, color\n        );\n\n        symbolPath.attr({\n            z2: 100,\n            culling: true,\n            scale: [0, 0]\n        });\n        // Rewrite drift method\n        symbolPath.drift = driftSymbol;\n\n        graphic.initProps(symbolPath, {\n            scale: getScale(symbolSize)\n        }, seriesModel, idx);\n        this._symbolType = symbolType;\n\n        this.add(symbolPath);\n    };\n\n    /**\n     * Stop animation\n     * @param {boolean} toLastFrame\n     */\n    symbolProto.stopSymbolAnimation = function (toLastFrame) {\n        this.childAt(0).stopAnimation(toLastFrame);\n    };\n\n    /**\n     * Get symbol path element\n     */\n    symbolProto.getSymbolPath = function () {\n        return this.childAt(0);\n    };\n\n    /**\n     * Get scale(aka, current symbol size).\n     * Including the change caused by animation\n     */\n    symbolProto.getScale = function () {\n        return this.childAt(0).scale;\n    };\n\n    /**\n     * Highlight symbol\n     */\n    symbolProto.highlight = function () {\n        this.childAt(0).trigger('emphasis');\n    };\n\n    /**\n     * Downplay symbol\n     */\n    symbolProto.downplay = function () {\n        this.childAt(0).trigger('normal');\n    };\n\n    /**\n     * @param {number} zlevel\n     * @param {number} z\n     */\n    symbolProto.setZ = function (zlevel, z) {\n        var symbolPath = this.childAt(0);\n        symbolPath.zlevel = zlevel;\n        symbolPath.z = z;\n    };\n\n    symbolProto.setDraggable = function (draggable) {\n        var symbolPath = this.childAt(0);\n        symbolPath.draggable = draggable;\n        symbolPath.cursor = draggable ? 'move' : 'pointer';\n    };\n\n    /**\n     * Update symbol properties\n     * @param  {module:echarts/data/List} data\n     * @param  {number} idx\n     */\n    symbolProto.updateData = function (data, idx, seriesScope) {\n        this.silent = false;\n\n        var symbolType = data.getItemVisual(idx, 'symbol') || 'circle';\n        var seriesModel = data.hostModel;\n        var symbolSize = getSymbolSize(data, idx);\n\n        if (symbolType !== this._symbolType) {\n            this._createSymbol(symbolType, data, idx, symbolSize);\n        }\n        else {\n            var symbolPath = this.childAt(0);\n            symbolPath.silent = false;\n            graphic.updateProps(symbolPath, {\n                scale: getScale(symbolSize)\n            }, seriesModel, idx);\n        }\n        this._updateCommon(data, idx, symbolSize, seriesScope);\n        this._seriesModel = seriesModel;\n    };\n\n    // Update common properties\n    var normalStyleAccessPath = ['itemStyle', 'normal'];\n    var emphasisStyleAccessPath = ['itemStyle', 'emphasis'];\n    var normalLabelAccessPath = ['label', 'normal'];\n    var emphasisLabelAccessPath = ['label', 'emphasis'];\n\n    symbolProto._updateCommon = function (data, idx, symbolSize, seriesScope) {\n        var symbolPath = this.childAt(0);\n        var seriesModel = data.hostModel;\n        var color = data.getItemVisual(idx, 'color');\n\n        // Reset style\n        if (symbolPath.type !== 'image') {\n            symbolPath.useStyle({\n                strokeNoScale: true\n            });\n        }\n\n        seriesScope = seriesScope || null;\n\n        var itemStyle = seriesScope && seriesScope.itemStyle;\n        var hoverItemStyle = seriesScope && seriesScope.hoverItemStyle;\n        var symbolRotate = seriesScope && seriesScope.symbolRotate;\n        var symbolOffset = seriesScope && seriesScope.symbolOffset;\n        var labelModel = seriesScope && seriesScope.labelModel;\n        var hoverLabelModel = seriesScope && seriesScope.hoverLabelModel;\n        var hoverAnimation = seriesScope && seriesScope.hoverAnimation;\n\n        if (!seriesScope || data.hasItemOption) {\n            var itemModel = data.getItemModel(idx);\n\n            // Color must be excluded.\n            // Because symbol provide setColor individually to set fill and stroke\n            itemStyle = itemModel.getModel(normalStyleAccessPath).getItemStyle(['color']);\n            hoverItemStyle = itemModel.getModel(emphasisStyleAccessPath).getItemStyle();\n\n            symbolRotate = itemModel.getShallow('symbolRotate');\n            symbolOffset = itemModel.getShallow('symbolOffset');\n\n            labelModel = itemModel.getModel(normalLabelAccessPath);\n            hoverLabelModel = itemModel.getModel(emphasisLabelAccessPath);\n            hoverAnimation = itemModel.getShallow('hoverAnimation');\n        }\n        else {\n            hoverItemStyle = zrUtil.extend({}, hoverItemStyle);\n        }\n\n        var elStyle = symbolPath.style;\n\n        symbolPath.attr('rotation', (symbolRotate || 0) * Math.PI / 180 || 0);\n\n        if (symbolOffset) {\n            symbolPath.attr('position', [\n                numberUtil.parsePercent(symbolOffset[0], symbolSize[0]),\n                numberUtil.parsePercent(symbolOffset[1], symbolSize[1])\n            ]);\n        }\n\n        // PENDING setColor before setStyle!!!\n        symbolPath.setColor(color);\n\n        symbolPath.setStyle(itemStyle);\n\n        var opacity = data.getItemVisual(idx, 'opacity');\n        if (opacity != null) {\n            elStyle.opacity = opacity;\n        }\n\n        // Get last value dim\n        var dimensions = data.dimensions.slice();\n        var valueDim;\n        var dataType;\n        while (dimensions.length && (\n            valueDim = dimensions.pop(),\n            dataType = data.getDimensionInfo(valueDim).type,\n            dataType === 'ordinal' || dataType === 'time'\n        )) {} // jshint ignore:line\n\n        if (valueDim != null && labelModel.getShallow('show')) {\n            graphic.setText(elStyle, labelModel, color);\n            elStyle.text = zrUtil.retrieve(\n                seriesModel.getFormattedLabel(idx, 'normal'),\n                data.get(valueDim, idx)\n            );\n        }\n        else {\n            elStyle.text = '';\n        }\n\n        if (valueDim != null && hoverLabelModel.getShallow('show')) {\n            graphic.setText(hoverItemStyle, hoverLabelModel, color);\n            hoverItemStyle.text = zrUtil.retrieve(\n                seriesModel.getFormattedLabel(idx, 'emphasis'),\n                data.get(valueDim, idx)\n            );\n        }\n        else {\n            hoverItemStyle.text = '';\n        }\n\n        symbolPath.off('mouseover')\n            .off('mouseout')\n            .off('emphasis')\n            .off('normal');\n\n        symbolPath.hoverStyle = hoverItemStyle;\n\n        graphic.setHoverStyle(symbolPath);\n\n        var scale = getScale(symbolSize);\n\n        if (hoverAnimation && seriesModel.isAnimationEnabled()) {\n            var onEmphasis = function() {\n                var ratio = scale[1] / scale[0];\n                this.animateTo({\n                    scale: [\n                        Math.max(scale[0] * 1.1, scale[0] + 3),\n                        Math.max(scale[1] * 1.1, scale[1] + 3 * ratio)\n                    ]\n                }, 400, 'elasticOut');\n            };\n            var onNormal = function() {\n                this.animateTo({\n                    scale: scale\n                }, 400, 'elasticOut');\n            };\n            symbolPath.on('mouseover', onEmphasis)\n                .on('mouseout', onNormal)\n                .on('emphasis', onEmphasis)\n                .on('normal', onNormal);\n        }\n    };\n\n    symbolProto.fadeOut = function (cb) {\n        var symbolPath = this.childAt(0);\n        // Avoid mistaken hover when fading out\n        this.silent = symbolPath.silent = true;\n        // Not show text when animating\n        symbolPath.style.text = '';\n        graphic.updateProps(symbolPath, {\n            scale: [0, 0]\n        }, this._seriesModel, this.dataIndex, cb);\n    };\n\n    zrUtil.inherits(Symbol, graphic.Group);\n\n    module.exports = Symbol;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvY2hhcnQvaGVscGVyL1N5bWJvbC5qcz80ZTI3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQG1vZHVsZSBlY2hhcnRzL2NoYXJ0L2hlbHBlci9TeW1ib2xcbiAqL1xuXG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG4gICAgdmFyIHN5bWJvbFV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL3N5bWJvbCcpO1xuICAgIHZhciBncmFwaGljID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9ncmFwaGljJyk7XG4gICAgdmFyIG51bWJlclV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL251bWJlcicpO1xuXG4gICAgZnVuY3Rpb24gZ2V0U3ltYm9sU2l6ZShkYXRhLCBpZHgpIHtcbiAgICAgICAgdmFyIHN5bWJvbFNpemUgPSBkYXRhLmdldEl0ZW1WaXN1YWwoaWR4LCAnc3ltYm9sU2l6ZScpO1xuICAgICAgICByZXR1cm4gc3ltYm9sU2l6ZSBpbnN0YW5jZW9mIEFycmF5XG4gICAgICAgICAgICA/IHN5bWJvbFNpemUuc2xpY2UoKVxuICAgICAgICAgICAgOiBbK3N5bWJvbFNpemUsICtzeW1ib2xTaXplXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTY2FsZShzeW1ib2xTaXplKSB7XG4gICAgICAgIHJldHVybiBbc3ltYm9sU2l6ZVswXSAvIDIsIHN5bWJvbFNpemVbMV0gLyAyXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAYWxpYXMge21vZHVsZTplY2hhcnRzL2NoYXJ0L2hlbHBlci9TeW1ib2x9XG4gICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9kYXRhL0xpc3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaWR4XG4gICAgICogQGV4dGVuZHMge21vZHVsZTp6cmVuZGVyL2dyYXBoaWMvR3JvdXB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gU3ltYm9sKGRhdGEsIGlkeCwgc2VyaWVzU2NvcGUpIHtcbiAgICAgICAgZ3JhcGhpYy5Hcm91cC5jYWxsKHRoaXMpO1xuXG4gICAgICAgIHRoaXMudXBkYXRlRGF0YShkYXRhLCBpZHgsIHNlcmllc1Njb3BlKTtcbiAgICB9XG5cbiAgICB2YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wucHJvdG90eXBlO1xuXG4gICAgZnVuY3Rpb24gZHJpZnRTeW1ib2woZHgsIGR5KSB7XG4gICAgICAgIHRoaXMucGFyZW50LmRyaWZ0KGR4LCBkeSk7XG4gICAgfVxuXG4gICAgc3ltYm9sUHJvdG8uX2NyZWF0ZVN5bWJvbCA9IGZ1bmN0aW9uIChzeW1ib2xUeXBlLCBkYXRhLCBpZHgsIHN5bWJvbFNpemUpIHtcbiAgICAgICAgLy8gUmVtb3ZlIHBhdGhzIGNyZWF0ZWQgYmVmb3JlXG4gICAgICAgIHRoaXMucmVtb3ZlQWxsKCk7XG5cbiAgICAgICAgdmFyIHNlcmllc01vZGVsID0gZGF0YS5ob3N0TW9kZWw7XG4gICAgICAgIHZhciBjb2xvciA9IGRhdGEuZ2V0SXRlbVZpc3VhbChpZHgsICdjb2xvcicpO1xuXG4gICAgICAgIC8vIHZhciBzeW1ib2xQYXRoID0gc3ltYm9sVXRpbC5jcmVhdGVTeW1ib2woXG4gICAgICAgIC8vICAgICBzeW1ib2xUeXBlLCAtMC41LCAtMC41LCAxLCAxLCBjb2xvclxuICAgICAgICAvLyApO1xuICAgICAgICAvLyBJZiB3aWR0aC9oZWlnaHQgYXJlIHNldCB0b28gc21hbGwgKGUuZy4sIHNldCB0byAxKSBvbiBpb3MxMFxuICAgICAgICAvLyBhbmQgbWFjT1MgU2llcnJhLCBhIGNpcmNsZSBzdHJva2UgYmVjb21lIGEgcmVjdCwgbm8gbWF0dGVyIHdoYXRcbiAgICAgICAgLy8gdGhlIHNjYWxlIGlzIHNldC4gU28gd2Ugc2V0IHdpZHRoL2hlaWdodCBhcyAyLiBTZWUgIzQxNTAuXG4gICAgICAgIHZhciBzeW1ib2xQYXRoID0gc3ltYm9sVXRpbC5jcmVhdGVTeW1ib2woXG4gICAgICAgICAgICBzeW1ib2xUeXBlLCAtMSwgLTEsIDIsIDIsIGNvbG9yXG4gICAgICAgICk7XG5cbiAgICAgICAgc3ltYm9sUGF0aC5hdHRyKHtcbiAgICAgICAgICAgIHoyOiAxMDAsXG4gICAgICAgICAgICBjdWxsaW5nOiB0cnVlLFxuICAgICAgICAgICAgc2NhbGU6IFswLCAwXVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gUmV3cml0ZSBkcmlmdCBtZXRob2RcbiAgICAgICAgc3ltYm9sUGF0aC5kcmlmdCA9IGRyaWZ0U3ltYm9sO1xuXG4gICAgICAgIGdyYXBoaWMuaW5pdFByb3BzKHN5bWJvbFBhdGgsIHtcbiAgICAgICAgICAgIHNjYWxlOiBnZXRTY2FsZShzeW1ib2xTaXplKVxuICAgICAgICB9LCBzZXJpZXNNb2RlbCwgaWR4KTtcbiAgICAgICAgdGhpcy5fc3ltYm9sVHlwZSA9IHN5bWJvbFR5cGU7XG5cbiAgICAgICAgdGhpcy5hZGQoc3ltYm9sUGF0aCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFN0b3AgYW5pbWF0aW9uXG4gICAgICogQHBhcmFtIHtib29sZWFufSB0b0xhc3RGcmFtZVxuICAgICAqL1xuICAgIHN5bWJvbFByb3RvLnN0b3BTeW1ib2xBbmltYXRpb24gPSBmdW5jdGlvbiAodG9MYXN0RnJhbWUpIHtcbiAgICAgICAgdGhpcy5jaGlsZEF0KDApLnN0b3BBbmltYXRpb24odG9MYXN0RnJhbWUpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgc3ltYm9sIHBhdGggZWxlbWVudFxuICAgICAqL1xuICAgIHN5bWJvbFByb3RvLmdldFN5bWJvbFBhdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkQXQoMCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBzY2FsZShha2EsIGN1cnJlbnQgc3ltYm9sIHNpemUpLlxuICAgICAqIEluY2x1ZGluZyB0aGUgY2hhbmdlIGNhdXNlZCBieSBhbmltYXRpb25cbiAgICAgKi9cbiAgICBzeW1ib2xQcm90by5nZXRTY2FsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRBdCgwKS5zY2FsZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSGlnaGxpZ2h0IHN5bWJvbFxuICAgICAqL1xuICAgIHN5bWJvbFByb3RvLmhpZ2hsaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jaGlsZEF0KDApLnRyaWdnZXIoJ2VtcGhhc2lzJyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERvd25wbGF5IHN5bWJvbFxuICAgICAqL1xuICAgIHN5bWJvbFByb3RvLmRvd25wbGF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNoaWxkQXQoMCkudHJpZ2dlcignbm9ybWFsJyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB6bGV2ZWxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gelxuICAgICAqL1xuICAgIHN5bWJvbFByb3RvLnNldFogPSBmdW5jdGlvbiAoemxldmVsLCB6KSB7XG4gICAgICAgIHZhciBzeW1ib2xQYXRoID0gdGhpcy5jaGlsZEF0KDApO1xuICAgICAgICBzeW1ib2xQYXRoLnpsZXZlbCA9IHpsZXZlbDtcbiAgICAgICAgc3ltYm9sUGF0aC56ID0gejtcbiAgICB9O1xuXG4gICAgc3ltYm9sUHJvdG8uc2V0RHJhZ2dhYmxlID0gZnVuY3Rpb24gKGRyYWdnYWJsZSkge1xuICAgICAgICB2YXIgc3ltYm9sUGF0aCA9IHRoaXMuY2hpbGRBdCgwKTtcbiAgICAgICAgc3ltYm9sUGF0aC5kcmFnZ2FibGUgPSBkcmFnZ2FibGU7XG4gICAgICAgIHN5bWJvbFBhdGguY3Vyc29yID0gZHJhZ2dhYmxlID8gJ21vdmUnIDogJ3BvaW50ZXInO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgc3ltYm9sIHByb3BlcnRpZXNcbiAgICAgKiBAcGFyYW0gIHttb2R1bGU6ZWNoYXJ0cy9kYXRhL0xpc3R9IGRhdGFcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IGlkeFxuICAgICAqL1xuICAgIHN5bWJvbFByb3RvLnVwZGF0ZURhdGEgPSBmdW5jdGlvbiAoZGF0YSwgaWR4LCBzZXJpZXNTY29wZSkge1xuICAgICAgICB0aGlzLnNpbGVudCA9IGZhbHNlO1xuXG4gICAgICAgIHZhciBzeW1ib2xUeXBlID0gZGF0YS5nZXRJdGVtVmlzdWFsKGlkeCwgJ3N5bWJvbCcpIHx8ICdjaXJjbGUnO1xuICAgICAgICB2YXIgc2VyaWVzTW9kZWwgPSBkYXRhLmhvc3RNb2RlbDtcbiAgICAgICAgdmFyIHN5bWJvbFNpemUgPSBnZXRTeW1ib2xTaXplKGRhdGEsIGlkeCk7XG5cbiAgICAgICAgaWYgKHN5bWJvbFR5cGUgIT09IHRoaXMuX3N5bWJvbFR5cGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVN5bWJvbChzeW1ib2xUeXBlLCBkYXRhLCBpZHgsIHN5bWJvbFNpemUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHN5bWJvbFBhdGggPSB0aGlzLmNoaWxkQXQoMCk7XG4gICAgICAgICAgICBzeW1ib2xQYXRoLnNpbGVudCA9IGZhbHNlO1xuICAgICAgICAgICAgZ3JhcGhpYy51cGRhdGVQcm9wcyhzeW1ib2xQYXRoLCB7XG4gICAgICAgICAgICAgICAgc2NhbGU6IGdldFNjYWxlKHN5bWJvbFNpemUpXG4gICAgICAgICAgICB9LCBzZXJpZXNNb2RlbCwgaWR4KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl91cGRhdGVDb21tb24oZGF0YSwgaWR4LCBzeW1ib2xTaXplLCBzZXJpZXNTY29wZSk7XG4gICAgICAgIHRoaXMuX3Nlcmllc01vZGVsID0gc2VyaWVzTW9kZWw7XG4gICAgfTtcblxuICAgIC8vIFVwZGF0ZSBjb21tb24gcHJvcGVydGllc1xuICAgIHZhciBub3JtYWxTdHlsZUFjY2Vzc1BhdGggPSBbJ2l0ZW1TdHlsZScsICdub3JtYWwnXTtcbiAgICB2YXIgZW1waGFzaXNTdHlsZUFjY2Vzc1BhdGggPSBbJ2l0ZW1TdHlsZScsICdlbXBoYXNpcyddO1xuICAgIHZhciBub3JtYWxMYWJlbEFjY2Vzc1BhdGggPSBbJ2xhYmVsJywgJ25vcm1hbCddO1xuICAgIHZhciBlbXBoYXNpc0xhYmVsQWNjZXNzUGF0aCA9IFsnbGFiZWwnLCAnZW1waGFzaXMnXTtcblxuICAgIHN5bWJvbFByb3RvLl91cGRhdGVDb21tb24gPSBmdW5jdGlvbiAoZGF0YSwgaWR4LCBzeW1ib2xTaXplLCBzZXJpZXNTY29wZSkge1xuICAgICAgICB2YXIgc3ltYm9sUGF0aCA9IHRoaXMuY2hpbGRBdCgwKTtcbiAgICAgICAgdmFyIHNlcmllc01vZGVsID0gZGF0YS5ob3N0TW9kZWw7XG4gICAgICAgIHZhciBjb2xvciA9IGRhdGEuZ2V0SXRlbVZpc3VhbChpZHgsICdjb2xvcicpO1xuXG4gICAgICAgIC8vIFJlc2V0IHN0eWxlXG4gICAgICAgIGlmIChzeW1ib2xQYXRoLnR5cGUgIT09ICdpbWFnZScpIHtcbiAgICAgICAgICAgIHN5bWJvbFBhdGgudXNlU3R5bGUoe1xuICAgICAgICAgICAgICAgIHN0cm9rZU5vU2NhbGU6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VyaWVzU2NvcGUgPSBzZXJpZXNTY29wZSB8fCBudWxsO1xuXG4gICAgICAgIHZhciBpdGVtU3R5bGUgPSBzZXJpZXNTY29wZSAmJiBzZXJpZXNTY29wZS5pdGVtU3R5bGU7XG4gICAgICAgIHZhciBob3Zlckl0ZW1TdHlsZSA9IHNlcmllc1Njb3BlICYmIHNlcmllc1Njb3BlLmhvdmVySXRlbVN0eWxlO1xuICAgICAgICB2YXIgc3ltYm9sUm90YXRlID0gc2VyaWVzU2NvcGUgJiYgc2VyaWVzU2NvcGUuc3ltYm9sUm90YXRlO1xuICAgICAgICB2YXIgc3ltYm9sT2Zmc2V0ID0gc2VyaWVzU2NvcGUgJiYgc2VyaWVzU2NvcGUuc3ltYm9sT2Zmc2V0O1xuICAgICAgICB2YXIgbGFiZWxNb2RlbCA9IHNlcmllc1Njb3BlICYmIHNlcmllc1Njb3BlLmxhYmVsTW9kZWw7XG4gICAgICAgIHZhciBob3ZlckxhYmVsTW9kZWwgPSBzZXJpZXNTY29wZSAmJiBzZXJpZXNTY29wZS5ob3ZlckxhYmVsTW9kZWw7XG4gICAgICAgIHZhciBob3ZlckFuaW1hdGlvbiA9IHNlcmllc1Njb3BlICYmIHNlcmllc1Njb3BlLmhvdmVyQW5pbWF0aW9uO1xuXG4gICAgICAgIGlmICghc2VyaWVzU2NvcGUgfHwgZGF0YS5oYXNJdGVtT3B0aW9uKSB7XG4gICAgICAgICAgICB2YXIgaXRlbU1vZGVsID0gZGF0YS5nZXRJdGVtTW9kZWwoaWR4KTtcblxuICAgICAgICAgICAgLy8gQ29sb3IgbXVzdCBiZSBleGNsdWRlZC5cbiAgICAgICAgICAgIC8vIEJlY2F1c2Ugc3ltYm9sIHByb3ZpZGUgc2V0Q29sb3IgaW5kaXZpZHVhbGx5IHRvIHNldCBmaWxsIGFuZCBzdHJva2VcbiAgICAgICAgICAgIGl0ZW1TdHlsZSA9IGl0ZW1Nb2RlbC5nZXRNb2RlbChub3JtYWxTdHlsZUFjY2Vzc1BhdGgpLmdldEl0ZW1TdHlsZShbJ2NvbG9yJ10pO1xuICAgICAgICAgICAgaG92ZXJJdGVtU3R5bGUgPSBpdGVtTW9kZWwuZ2V0TW9kZWwoZW1waGFzaXNTdHlsZUFjY2Vzc1BhdGgpLmdldEl0ZW1TdHlsZSgpO1xuXG4gICAgICAgICAgICBzeW1ib2xSb3RhdGUgPSBpdGVtTW9kZWwuZ2V0U2hhbGxvdygnc3ltYm9sUm90YXRlJyk7XG4gICAgICAgICAgICBzeW1ib2xPZmZzZXQgPSBpdGVtTW9kZWwuZ2V0U2hhbGxvdygnc3ltYm9sT2Zmc2V0Jyk7XG5cbiAgICAgICAgICAgIGxhYmVsTW9kZWwgPSBpdGVtTW9kZWwuZ2V0TW9kZWwobm9ybWFsTGFiZWxBY2Nlc3NQYXRoKTtcbiAgICAgICAgICAgIGhvdmVyTGFiZWxNb2RlbCA9IGl0ZW1Nb2RlbC5nZXRNb2RlbChlbXBoYXNpc0xhYmVsQWNjZXNzUGF0aCk7XG4gICAgICAgICAgICBob3ZlckFuaW1hdGlvbiA9IGl0ZW1Nb2RlbC5nZXRTaGFsbG93KCdob3ZlckFuaW1hdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaG92ZXJJdGVtU3R5bGUgPSB6clV0aWwuZXh0ZW5kKHt9LCBob3Zlckl0ZW1TdHlsZSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZWxTdHlsZSA9IHN5bWJvbFBhdGguc3R5bGU7XG5cbiAgICAgICAgc3ltYm9sUGF0aC5hdHRyKCdyb3RhdGlvbicsIChzeW1ib2xSb3RhdGUgfHwgMCkgKiBNYXRoLlBJIC8gMTgwIHx8IDApO1xuXG4gICAgICAgIGlmIChzeW1ib2xPZmZzZXQpIHtcbiAgICAgICAgICAgIHN5bWJvbFBhdGguYXR0cigncG9zaXRpb24nLCBbXG4gICAgICAgICAgICAgICAgbnVtYmVyVXRpbC5wYXJzZVBlcmNlbnQoc3ltYm9sT2Zmc2V0WzBdLCBzeW1ib2xTaXplWzBdKSxcbiAgICAgICAgICAgICAgICBudW1iZXJVdGlsLnBhcnNlUGVyY2VudChzeW1ib2xPZmZzZXRbMV0sIHN5bWJvbFNpemVbMV0pXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFBFTkRJTkcgc2V0Q29sb3IgYmVmb3JlIHNldFN0eWxlISEhXG4gICAgICAgIHN5bWJvbFBhdGguc2V0Q29sb3IoY29sb3IpO1xuXG4gICAgICAgIHN5bWJvbFBhdGguc2V0U3R5bGUoaXRlbVN0eWxlKTtcblxuICAgICAgICB2YXIgb3BhY2l0eSA9IGRhdGEuZ2V0SXRlbVZpc3VhbChpZHgsICdvcGFjaXR5Jyk7XG4gICAgICAgIGlmIChvcGFjaXR5ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGVsU3R5bGUub3BhY2l0eSA9IG9wYWNpdHk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHZXQgbGFzdCB2YWx1ZSBkaW1cbiAgICAgICAgdmFyIGRpbWVuc2lvbnMgPSBkYXRhLmRpbWVuc2lvbnMuc2xpY2UoKTtcbiAgICAgICAgdmFyIHZhbHVlRGltO1xuICAgICAgICB2YXIgZGF0YVR5cGU7XG4gICAgICAgIHdoaWxlIChkaW1lbnNpb25zLmxlbmd0aCAmJiAoXG4gICAgICAgICAgICB2YWx1ZURpbSA9IGRpbWVuc2lvbnMucG9wKCksXG4gICAgICAgICAgICBkYXRhVHlwZSA9IGRhdGEuZ2V0RGltZW5zaW9uSW5mbyh2YWx1ZURpbSkudHlwZSxcbiAgICAgICAgICAgIGRhdGFUeXBlID09PSAnb3JkaW5hbCcgfHwgZGF0YVR5cGUgPT09ICd0aW1lJ1xuICAgICAgICApKSB7fSAvLyBqc2hpbnQgaWdub3JlOmxpbmVcblxuICAgICAgICBpZiAodmFsdWVEaW0gIT0gbnVsbCAmJiBsYWJlbE1vZGVsLmdldFNoYWxsb3coJ3Nob3cnKSkge1xuICAgICAgICAgICAgZ3JhcGhpYy5zZXRUZXh0KGVsU3R5bGUsIGxhYmVsTW9kZWwsIGNvbG9yKTtcbiAgICAgICAgICAgIGVsU3R5bGUudGV4dCA9IHpyVXRpbC5yZXRyaWV2ZShcbiAgICAgICAgICAgICAgICBzZXJpZXNNb2RlbC5nZXRGb3JtYXR0ZWRMYWJlbChpZHgsICdub3JtYWwnKSxcbiAgICAgICAgICAgICAgICBkYXRhLmdldCh2YWx1ZURpbSwgaWR4KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVsU3R5bGUudGV4dCA9ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlRGltICE9IG51bGwgJiYgaG92ZXJMYWJlbE1vZGVsLmdldFNoYWxsb3coJ3Nob3cnKSkge1xuICAgICAgICAgICAgZ3JhcGhpYy5zZXRUZXh0KGhvdmVySXRlbVN0eWxlLCBob3ZlckxhYmVsTW9kZWwsIGNvbG9yKTtcbiAgICAgICAgICAgIGhvdmVySXRlbVN0eWxlLnRleHQgPSB6clV0aWwucmV0cmlldmUoXG4gICAgICAgICAgICAgICAgc2VyaWVzTW9kZWwuZ2V0Rm9ybWF0dGVkTGFiZWwoaWR4LCAnZW1waGFzaXMnKSxcbiAgICAgICAgICAgICAgICBkYXRhLmdldCh2YWx1ZURpbSwgaWR4KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGhvdmVySXRlbVN0eWxlLnRleHQgPSAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIHN5bWJvbFBhdGgub2ZmKCdtb3VzZW92ZXInKVxuICAgICAgICAgICAgLm9mZignbW91c2VvdXQnKVxuICAgICAgICAgICAgLm9mZignZW1waGFzaXMnKVxuICAgICAgICAgICAgLm9mZignbm9ybWFsJyk7XG5cbiAgICAgICAgc3ltYm9sUGF0aC5ob3ZlclN0eWxlID0gaG92ZXJJdGVtU3R5bGU7XG5cbiAgICAgICAgZ3JhcGhpYy5zZXRIb3ZlclN0eWxlKHN5bWJvbFBhdGgpO1xuXG4gICAgICAgIHZhciBzY2FsZSA9IGdldFNjYWxlKHN5bWJvbFNpemUpO1xuXG4gICAgICAgIGlmIChob3ZlckFuaW1hdGlvbiAmJiBzZXJpZXNNb2RlbC5pc0FuaW1hdGlvbkVuYWJsZWQoKSkge1xuICAgICAgICAgICAgdmFyIG9uRW1waGFzaXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmF0aW8gPSBzY2FsZVsxXSAvIHNjYWxlWzBdO1xuICAgICAgICAgICAgICAgIHRoaXMuYW5pbWF0ZVRvKHtcbiAgICAgICAgICAgICAgICAgICAgc2NhbGU6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgubWF4KHNjYWxlWzBdICogMS4xLCBzY2FsZVswXSArIDMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5tYXgoc2NhbGVbMV0gKiAxLjEsIHNjYWxlWzFdICsgMyAqIHJhdGlvKVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfSwgNDAwLCAnZWxhc3RpY091dCcpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBvbk5vcm1hbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYW5pbWF0ZVRvKHtcbiAgICAgICAgICAgICAgICAgICAgc2NhbGU6IHNjYWxlXG4gICAgICAgICAgICAgICAgfSwgNDAwLCAnZWxhc3RpY091dCcpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHN5bWJvbFBhdGgub24oJ21vdXNlb3ZlcicsIG9uRW1waGFzaXMpXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZW91dCcsIG9uTm9ybWFsKVxuICAgICAgICAgICAgICAgIC5vbignZW1waGFzaXMnLCBvbkVtcGhhc2lzKVxuICAgICAgICAgICAgICAgIC5vbignbm9ybWFsJywgb25Ob3JtYWwpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHN5bWJvbFByb3RvLmZhZGVPdXQgPSBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgdmFyIHN5bWJvbFBhdGggPSB0aGlzLmNoaWxkQXQoMCk7XG4gICAgICAgIC8vIEF2b2lkIG1pc3Rha2VuIGhvdmVyIHdoZW4gZmFkaW5nIG91dFxuICAgICAgICB0aGlzLnNpbGVudCA9IHN5bWJvbFBhdGguc2lsZW50ID0gdHJ1ZTtcbiAgICAgICAgLy8gTm90IHNob3cgdGV4dCB3aGVuIGFuaW1hdGluZ1xuICAgICAgICBzeW1ib2xQYXRoLnN0eWxlLnRleHQgPSAnJztcbiAgICAgICAgZ3JhcGhpYy51cGRhdGVQcm9wcyhzeW1ib2xQYXRoLCB7XG4gICAgICAgICAgICBzY2FsZTogWzAsIDBdXG4gICAgICAgIH0sIHRoaXMuX3Nlcmllc01vZGVsLCB0aGlzLmRhdGFJbmRleCwgY2IpO1xuICAgIH07XG5cbiAgICB6clV0aWwuaW5oZXJpdHMoU3ltYm9sLCBncmFwaGljLkdyb3VwKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gU3ltYm9sO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvY2hhcnQvaGVscGVyL1N5bWJvbC5qc1xuLy8gbW9kdWxlIGlkID0gNTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 56 */
/* unknown exports provided */
/* all exports used */
/*!*************************************!*\
  !*** ./lib/coord/cartesian/Grid.js ***!
  \*************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Grid is a region which contains at most 4 cartesian systems\n *\n * TODO Default cartesian\n */\nvar factory = exports;\n\n    var layout = __webpack_require__(/*! ../../util/layout */ 11);\n    var axisHelper = __webpack_require__(/*! ../../coord/axisHelper */ 16);\n\n    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 0);\n    var Cartesian2D = __webpack_require__(/*! ./Cartesian2D */ 162);\n    var Axis2D = __webpack_require__(/*! ./Axis2D */ 160);\n\n    var each = zrUtil.each;\n\n    var ifAxisCrossZero = axisHelper.ifAxisCrossZero;\n    var niceScaleExtent = axisHelper.niceScaleExtent;\n\n    // 依赖 GridModel, AxisModel 做预处理\n    __webpack_require__(/*! ./GridModel */ 163);\n\n    /**\n     * Check if the axis is used in the specified grid\n     * @inner\n     */\n    function isAxisUsedInTheGrid(axisModel, gridModel, ecModel) {\n        return axisModel.getCoordSysModel() === gridModel;\n    }\n\n    function getLabelUnionRect(axis) {\n        var axisModel = axis.model;\n        var labels = axisModel.getFormattedLabels();\n        var textStyleModel = axisModel.getModel('axisLabel.textStyle');\n        var rect;\n        var step = 1;\n        var labelCount = labels.length;\n        if (labelCount > 40) {\n            // Simple optimization for large amount of labels\n            step = Math.ceil(labelCount / 40);\n        }\n        for (var i = 0; i < labelCount; i += step) {\n            if (!axis.isLabelIgnored(i)) {\n                var singleRect = textStyleModel.getTextRect(labels[i]);\n                // FIXME consider label rotate\n                rect ? rect.union(singleRect) : (rect = singleRect);\n            }\n        }\n        return rect;\n    }\n\n    function Grid(gridModel, ecModel, api) {\n        /**\n         * @type {Object.<string, module:echarts/coord/cartesian/Cartesian2D>}\n         * @private\n         */\n        this._coordsMap = {};\n\n        /**\n         * @type {Array.<module:echarts/coord/cartesian/Cartesian>}\n         * @private\n         */\n        this._coordsList = [];\n\n        /**\n         * @type {Object.<string, module:echarts/coord/cartesian/Axis2D>}\n         * @private\n         */\n        this._axesMap = {};\n\n        /**\n         * @type {Array.<module:echarts/coord/cartesian/Axis2D>}\n         * @private\n         */\n        this._axesList = [];\n\n        this._initCartesian(gridModel, ecModel, api);\n\n        this.model = gridModel;\n    }\n\n    var gridProto = Grid.prototype;\n\n    gridProto.type = 'grid';\n\n    gridProto.axisPointerEnabled = true;\n\n    gridProto.getRect = function () {\n        return this._rect;\n    };\n\n    gridProto.update = function (ecModel, api) {\n\n        var axesMap = this._axesMap;\n\n        this._updateScale(ecModel, this.model);\n\n        function ifAxisCanNotOnZero(otherAxisDim) {\n            var axes = axesMap[otherAxisDim];\n            for (var idx in axes) {\n                if (axes.hasOwnProperty(idx)) {\n                    var axis = axes[idx];\n                    if (axis && (axis.type === 'category' || !ifAxisCrossZero(axis))) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n\n        each(axesMap.x, function (xAxis) {\n            niceScaleExtent(xAxis.scale, xAxis.model);\n        });\n        each(axesMap.y, function (yAxis) {\n            niceScaleExtent(yAxis.scale, yAxis.model);\n        });\n        // Fix configuration\n        each(axesMap.x, function (xAxis) {\n            // onZero can not be enabled in these two situations\n            // 1. When any other axis is a category axis\n            // 2. When any other axis not across 0 point\n            if (ifAxisCanNotOnZero('y')) {\n                xAxis.onZero = false;\n            }\n        });\n        each(axesMap.y, function (yAxis) {\n            if (ifAxisCanNotOnZero('x')) {\n                yAxis.onZero = false;\n            }\n        });\n\n        // Resize again if containLabel is enabled\n        // FIXME It may cause getting wrong grid size in data processing stage\n        this.resize(this.model, api);\n    };\n\n    /**\n     * Resize the grid\n     * @param {module:echarts/coord/cartesian/GridModel} gridModel\n     * @param {module:echarts/ExtensionAPI} api\n     */\n    gridProto.resize = function (gridModel, api) {\n\n        var gridRect = layout.getLayoutRect(\n            gridModel.getBoxLayoutParams(), {\n                width: api.getWidth(),\n                height: api.getHeight()\n            });\n\n        this._rect = gridRect;\n\n        var axesList = this._axesList;\n\n        adjustAxes();\n\n        // Minus label size\n        if (gridModel.get('containLabel')) {\n            each(axesList, function (axis) {\n                if (!axis.model.get('axisLabel.inside')) {\n                    var labelUnionRect = getLabelUnionRect(axis);\n                    if (labelUnionRect) {\n                        var dim = axis.isHorizontal() ? 'height' : 'width';\n                        var margin = axis.model.get('axisLabel.margin');\n                        gridRect[dim] -= labelUnionRect[dim] + margin;\n                        if (axis.position === 'top') {\n                            gridRect.y += labelUnionRect.height + margin;\n                        }\n                        else if (axis.position === 'left')  {\n                            gridRect.x += labelUnionRect.width + margin;\n                        }\n                    }\n                }\n            });\n\n            adjustAxes();\n        }\n\n        function adjustAxes() {\n            each(axesList, function (axis) {\n                var isHorizontal = axis.isHorizontal();\n                var extent = isHorizontal ? [0, gridRect.width] : [0, gridRect.height];\n                var idx = axis.inverse ? 1 : 0;\n                axis.setExtent(extent[idx], extent[1 - idx]);\n                updateAxisTransfrom(axis, isHorizontal ? gridRect.x : gridRect.y);\n            });\n        }\n    };\n\n    /**\n     * @param {string} axisType\n     * @param {ndumber} [axisIndex]\n     */\n    gridProto.getAxis = function (axisType, axisIndex) {\n        var axesMapOnDim = this._axesMap[axisType];\n        if (axesMapOnDim != null) {\n            if (axisIndex == null) {\n                // Find first axis\n                for (var name in axesMapOnDim) {\n                    if (axesMapOnDim.hasOwnProperty(name)) {\n                        return axesMapOnDim[name];\n                    }\n                }\n            }\n            return axesMapOnDim[axisIndex];\n        }\n    };\n\n    /**\n     * @return {Array.<module:echarts/coord/Axis>}\n     */\n    gridProto.getAxes = function () {\n        return this._axesList.slice();\n    };\n\n    /**\n     * Usage:\n     *      grid.getCartesian(xAxisIndex, yAxisIndex);\n     *      grid.getCartesian(xAxisIndex);\n     *      grid.getCartesian(null, yAxisIndex);\n     *      grid.getCartesian({xAxisIndex: ..., yAxisIndex: ...});\n     *\n     * @param {number|Object} [xAxisIndex]\n     * @param {number} [yAxisIndex]\n     */\n    gridProto.getCartesian = function (xAxisIndex, yAxisIndex) {\n        if (xAxisIndex != null && yAxisIndex != null) {\n            var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n            return this._coordsMap[key];\n        }\n\n        if (zrUtil.isObject(xAxisIndex)) {\n            yAxisIndex = xAxisIndex.yAxisIndex;\n            xAxisIndex = xAxisIndex.xAxisIndex;\n        }\n        // When only xAxisIndex or yAxisIndex given, find its first cartesian.\n        for (var i = 0, coordList = this._coordsList; i < coordList.length; i++) {\n            if (coordList[i].getAxis('x').index === xAxisIndex\n                || coordList[i].getAxis('y').index === yAxisIndex\n            ) {\n                return coordList[i];\n            }\n        }\n    };\n\n    gridProto.getCartesians = function () {\n        return this._coordsList.slice();\n    };\n\n    /**\n     * @implements\n     * see {module:echarts/CoodinateSystem}\n     */\n    gridProto.convertToPixel = function (ecModel, finder, value) {\n        var target = this._findConvertTarget(ecModel, finder);\n\n        return target.cartesian\n            ? target.cartesian.dataToPoint(value)\n            : target.axis\n            ? target.axis.toGlobalCoord(target.axis.dataToCoord(value))\n            : null;\n    };\n\n    /**\n     * @implements\n     * see {module:echarts/CoodinateSystem}\n     */\n    gridProto.convertFromPixel = function (ecModel, finder, value) {\n        var target = this._findConvertTarget(ecModel, finder);\n\n        return target.cartesian\n            ? target.cartesian.pointToData(value)\n            : target.axis\n            ? target.axis.coordToData(target.axis.toLocalCoord(value))\n            : null;\n    };\n\n    /**\n     * @inner\n     */\n    gridProto._findConvertTarget = function (ecModel, finder) {\n        var seriesModel = finder.seriesModel;\n        var xAxisModel = finder.xAxisModel\n            || (seriesModel && seriesModel.getReferringComponents('xAxis')[0]);\n        var yAxisModel = finder.yAxisModel\n            || (seriesModel && seriesModel.getReferringComponents('yAxis')[0]);\n        var gridModel = finder.gridModel;\n        var coordsList = this._coordsList;\n        var cartesian;\n        var axis;\n\n        if (seriesModel) {\n            cartesian = seriesModel.coordinateSystem;\n            zrUtil.indexOf(coordsList, cartesian) < 0 && (cartesian = null);\n        }\n        else if (xAxisModel && yAxisModel) {\n            cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n        }\n        else if (xAxisModel) {\n            axis = this.getAxis('x', xAxisModel.componentIndex);\n        }\n        else if (yAxisModel) {\n            axis = this.getAxis('y', yAxisModel.componentIndex);\n        }\n        // Lowest priority.\n        else if (gridModel) {\n            var grid = gridModel.coordinateSystem;\n            if (grid === this) {\n                cartesian = this._coordsList[0];\n            }\n        }\n\n        return {cartesian: cartesian, axis: axis};\n    };\n\n    /**\n     * @implements\n     * see {module:echarts/CoodinateSystem}\n     */\n    gridProto.containPoint = function (point) {\n        var coord = this._coordsList[0];\n        if (coord) {\n            return coord.containPoint(point);\n        }\n    };\n\n    /**\n     * Initialize cartesian coordinate systems\n     * @private\n     */\n    gridProto._initCartesian = function (gridModel, ecModel, api) {\n        var axisPositionUsed = {\n            left: false,\n            right: false,\n            top: false,\n            bottom: false\n        };\n\n        var axesMap = {\n            x: {},\n            y: {}\n        };\n        var axesCount = {\n            x: 0,\n            y: 0\n        };\n\n        /// Create axis\n        ecModel.eachComponent('xAxis', createAxisCreator('x'), this);\n        ecModel.eachComponent('yAxis', createAxisCreator('y'), this);\n\n        if (!axesCount.x || !axesCount.y) {\n            // Roll back when there no either x or y axis\n            this._axesMap = {};\n            this._axesList = [];\n            return;\n        }\n\n        this._axesMap = axesMap;\n\n        /// Create cartesian2d\n        each(axesMap.x, function (xAxis, xAxisIndex) {\n            each(axesMap.y, function (yAxis, yAxisIndex) {\n                var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n                var cartesian = new Cartesian2D(key);\n\n                cartesian.grid = this;\n                cartesian.model = gridModel;\n\n                this._coordsMap[key] = cartesian;\n                this._coordsList.push(cartesian);\n\n                cartesian.addAxis(xAxis);\n                cartesian.addAxis(yAxis);\n            }, this);\n        }, this);\n\n        function createAxisCreator(axisType) {\n            return function (axisModel, idx) {\n                if (!isAxisUsedInTheGrid(axisModel, gridModel, ecModel)) {\n                    return;\n                }\n\n                var axisPosition = axisModel.get('position');\n                if (axisType === 'x') {\n                    // Fix position\n                    if (axisPosition !== 'top' && axisPosition !== 'bottom') {\n                        // Default bottom of X\n                        axisPosition = 'bottom';\n                        if (axisPositionUsed[axisPosition]) {\n                            axisPosition = axisPosition === 'top' ? 'bottom' : 'top';\n                        }\n                    }\n                }\n                else {\n                    // Fix position\n                    if (axisPosition !== 'left' && axisPosition !== 'right') {\n                        // Default left of Y\n                        axisPosition = 'left';\n                        if (axisPositionUsed[axisPosition]) {\n                            axisPosition = axisPosition === 'left' ? 'right' : 'left';\n                        }\n                    }\n                }\n                axisPositionUsed[axisPosition] = true;\n\n                var axis = new Axis2D(\n                    axisType, axisHelper.createScaleByModel(axisModel),\n                    [0, 0],\n                    axisModel.get('type'),\n                    axisPosition\n                );\n\n                var isCategory = axis.type === 'category';\n                axis.onBand = isCategory && axisModel.get('boundaryGap');\n                axis.inverse = axisModel.get('inverse');\n\n                axis.onZero = axisModel.get('axisLine.onZero');\n\n                // Inject axis into axisModel\n                axisModel.axis = axis;\n\n                // Inject axisModel into axis\n                axis.model = axisModel;\n\n                // Inject grid info axis\n                axis.grid = this;\n\n                // Index of axis, can be used as key\n                axis.index = idx;\n\n                this._axesList.push(axis);\n\n                axesMap[axisType][idx] = axis;\n                axesCount[axisType]++;\n            };\n        }\n    };\n\n    /**\n     * Update cartesian properties from series\n     * @param  {module:echarts/model/Option} option\n     * @private\n     */\n    gridProto._updateScale = function (ecModel, gridModel) {\n        // Reset scale\n        zrUtil.each(this._axesList, function (axis) {\n            axis.scale.setExtent(Infinity, -Infinity);\n        });\n        ecModel.eachSeries(function (seriesModel) {\n            if (isCartesian2D(seriesModel)) {\n                var axesModels = findAxesModels(seriesModel, ecModel);\n                var xAxisModel = axesModels[0];\n                var yAxisModel = axesModels[1];\n\n                if (!isAxisUsedInTheGrid(xAxisModel, gridModel, ecModel)\n                    || !isAxisUsedInTheGrid(yAxisModel, gridModel, ecModel)\n                 ) {\n                    return;\n                }\n\n                var cartesian = this.getCartesian(\n                    xAxisModel.componentIndex, yAxisModel.componentIndex\n                );\n                var data = seriesModel.getData();\n                var xAxis = cartesian.getAxis('x');\n                var yAxis = cartesian.getAxis('y');\n\n                if (data.type === 'list') {\n                    unionExtent(data, xAxis, seriesModel);\n                    unionExtent(data, yAxis, seriesModel);\n                }\n            }\n        }, this);\n\n        function unionExtent(data, axis, seriesModel) {\n            each(seriesModel.coordDimToDataDim(axis.dim), function (dim) {\n                axis.scale.unionExtentFromData(data, dim);\n            });\n        }\n    };\n\n    /**\n     * @param {string} [dim] 'x' or 'y' or 'auto' or null/undefined\n     * @return {Object} {baseAxes: [], otherAxes: []}\n     */\n    gridProto.getTooltipAxes = function (dim) {\n        var baseAxes = [];\n        var otherAxes = [];\n\n        each(this.getCartesians(), function (cartesian) {\n            var baseAxis = (dim != null && dim !== 'auto')\n                ? cartesian.getAxis(dim) : cartesian.getBaseAxis();\n            var otherAxis = cartesian.getOtherAxis(baseAxis);\n            zrUtil.indexOf(baseAxes, baseAxis) < 0 && baseAxes.push(baseAxis);\n            zrUtil.indexOf(otherAxes, otherAxis) < 0 && otherAxes.push(otherAxis);\n        });\n\n        return {baseAxes: baseAxes, otherAxes: otherAxes};\n    };\n\n    /**\n     * @inner\n     */\n    function updateAxisTransfrom(axis, coordBase) {\n        var axisExtent = axis.getExtent();\n        var axisExtentSum = axisExtent[0] + axisExtent[1];\n\n        // Fast transform\n        axis.toGlobalCoord = axis.dim === 'x'\n            ? function (coord) {\n                return coord + coordBase;\n            }\n            : function (coord) {\n                return axisExtentSum - coord + coordBase;\n            };\n        axis.toLocalCoord = axis.dim === 'x'\n            ? function (coord) {\n                return coord - coordBase;\n            }\n            : function (coord) {\n                return axisExtentSum - coord + coordBase;\n            };\n    }\n\n    var axesTypes = ['xAxis', 'yAxis'];\n    /**\n     * @inner\n     */\n    function findAxesModels(seriesModel, ecModel) {\n        return zrUtil.map(axesTypes, function (axisType) {\n            var axisModel = seriesModel.getReferringComponents(axisType)[0];\n\n            if (true) {\n                if (!axisModel) {\n                    throw new Error(axisType + ' \"' + zrUtil.retrieve(\n                        seriesModel.get(axisType + 'Index'),\n                        seriesModel.get(axisType + 'Id'),\n                        0\n                    ) + '\" not found');\n                }\n            }\n            return axisModel;\n        });\n    }\n\n    /**\n     * @inner\n     */\n    function isCartesian2D(seriesModel) {\n        return seriesModel.get('coordinateSystem') === 'cartesian2d';\n    }\n\n    Grid.create = function (ecModel, api) {\n        var grids = [];\n        ecModel.eachComponent('grid', function (gridModel, idx) {\n            var grid = new Grid(gridModel, ecModel, api);\n            grid.name = 'grid_' + idx;\n            grid.resize(gridModel, api);\n\n            gridModel.coordinateSystem = grid;\n\n            grids.push(grid);\n        });\n\n        // Inject the coordinateSystems into seriesModel\n        ecModel.eachSeries(function (seriesModel) {\n            if (!isCartesian2D(seriesModel)) {\n                return;\n            }\n\n            var axesModels = findAxesModels(seriesModel, ecModel);\n            var xAxisModel = axesModels[0];\n            var yAxisModel = axesModels[1];\n\n            var gridModel = xAxisModel.getCoordSysModel();\n\n            if (true) {\n                if (!gridModel) {\n                    throw new Error(\n                        'Grid \"' + zrUtil.retrieve(\n                            xAxisModel.get('gridIndex'),\n                            xAxisModel.get('gridId'),\n                            0\n                        ) + '\" not found'\n                    );\n                }\n                if (xAxisModel.getCoordSysModel() !== yAxisModel.getCoordSysModel()) {\n                    throw new Error('xAxis and yAxis must use the same grid');\n                }\n            }\n\n            var grid = gridModel.coordinateSystem;\n\n            seriesModel.coordinateSystem = grid.getCartesian(\n                xAxisModel.componentIndex, yAxisModel.componentIndex\n            );\n        });\n\n        return grids;\n    };\n\n    // For deciding which dimensions to use when creating list data\n    Grid.dimensions = Grid.prototype.dimensions = Cartesian2D.prototype.dimensions;\n\n    __webpack_require__(/*! ../../CoordinateSystem */ 26).register('cartesian2d', Grid);\n\n    module.exports = Grid;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvY29vcmQvY2FydGVzaWFuL0dyaWQuanM/MDVlNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEdyaWQgaXMgYSByZWdpb24gd2hpY2ggY29udGFpbnMgYXQgbW9zdCA0IGNhcnRlc2lhbiBzeXN0ZW1zXG4gKlxuICogVE9ETyBEZWZhdWx0IGNhcnRlc2lhblxuICovXG52YXIgZmFjdG9yeSA9IGV4cG9ydHM7XG5cbiAgICB2YXIgbGF5b3V0ID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9sYXlvdXQnKTtcbiAgICB2YXIgYXhpc0hlbHBlciA9IHJlcXVpcmUoJy4uLy4uL2Nvb3JkL2F4aXNIZWxwZXInKTtcblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgQ2FydGVzaWFuMkQgPSByZXF1aXJlKCcuL0NhcnRlc2lhbjJEJyk7XG4gICAgdmFyIEF4aXMyRCA9IHJlcXVpcmUoJy4vQXhpczJEJyk7XG5cbiAgICB2YXIgZWFjaCA9IHpyVXRpbC5lYWNoO1xuXG4gICAgdmFyIGlmQXhpc0Nyb3NzWmVybyA9IGF4aXNIZWxwZXIuaWZBeGlzQ3Jvc3NaZXJvO1xuICAgIHZhciBuaWNlU2NhbGVFeHRlbnQgPSBheGlzSGVscGVyLm5pY2VTY2FsZUV4dGVudDtcblxuICAgIC8vIOS+nei1liBHcmlkTW9kZWwsIEF4aXNNb2RlbCDlgZrpooTlpITnkIZcbiAgICByZXF1aXJlKCcuL0dyaWRNb2RlbCcpO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhlIGF4aXMgaXMgdXNlZCBpbiB0aGUgc3BlY2lmaWVkIGdyaWRcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0F4aXNVc2VkSW5UaGVHcmlkKGF4aXNNb2RlbCwgZ3JpZE1vZGVsLCBlY01vZGVsKSB7XG4gICAgICAgIHJldHVybiBheGlzTW9kZWwuZ2V0Q29vcmRTeXNNb2RlbCgpID09PSBncmlkTW9kZWw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0TGFiZWxVbmlvblJlY3QoYXhpcykge1xuICAgICAgICB2YXIgYXhpc01vZGVsID0gYXhpcy5tb2RlbDtcbiAgICAgICAgdmFyIGxhYmVscyA9IGF4aXNNb2RlbC5nZXRGb3JtYXR0ZWRMYWJlbHMoKTtcbiAgICAgICAgdmFyIHRleHRTdHlsZU1vZGVsID0gYXhpc01vZGVsLmdldE1vZGVsKCdheGlzTGFiZWwudGV4dFN0eWxlJyk7XG4gICAgICAgIHZhciByZWN0O1xuICAgICAgICB2YXIgc3RlcCA9IDE7XG4gICAgICAgIHZhciBsYWJlbENvdW50ID0gbGFiZWxzLmxlbmd0aDtcbiAgICAgICAgaWYgKGxhYmVsQ291bnQgPiA0MCkge1xuICAgICAgICAgICAgLy8gU2ltcGxlIG9wdGltaXphdGlvbiBmb3IgbGFyZ2UgYW1vdW50IG9mIGxhYmVsc1xuICAgICAgICAgICAgc3RlcCA9IE1hdGguY2VpbChsYWJlbENvdW50IC8gNDApO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGFiZWxDb3VudDsgaSArPSBzdGVwKSB7XG4gICAgICAgICAgICBpZiAoIWF4aXMuaXNMYWJlbElnbm9yZWQoaSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2luZ2xlUmVjdCA9IHRleHRTdHlsZU1vZGVsLmdldFRleHRSZWN0KGxhYmVsc1tpXSk7XG4gICAgICAgICAgICAgICAgLy8gRklYTUUgY29uc2lkZXIgbGFiZWwgcm90YXRlXG4gICAgICAgICAgICAgICAgcmVjdCA/IHJlY3QudW5pb24oc2luZ2xlUmVjdCkgOiAocmVjdCA9IHNpbmdsZVJlY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWN0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIEdyaWQoZ3JpZE1vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywgbW9kdWxlOmVjaGFydHMvY29vcmQvY2FydGVzaWFuL0NhcnRlc2lhbjJEPn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2Nvb3Jkc01hcCA9IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPG1vZHVsZTplY2hhcnRzL2Nvb3JkL2NhcnRlc2lhbi9DYXJ0ZXNpYW4+fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fY29vcmRzTGlzdCA9IFtdO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsIG1vZHVsZTplY2hhcnRzL2Nvb3JkL2NhcnRlc2lhbi9BeGlzMkQ+fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fYXhlc01hcCA9IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPG1vZHVsZTplY2hhcnRzL2Nvb3JkL2NhcnRlc2lhbi9BeGlzMkQ+fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fYXhlc0xpc3QgPSBbXTtcblxuICAgICAgICB0aGlzLl9pbml0Q2FydGVzaWFuKGdyaWRNb2RlbCwgZWNNb2RlbCwgYXBpKTtcblxuICAgICAgICB0aGlzLm1vZGVsID0gZ3JpZE1vZGVsO1xuICAgIH1cblxuICAgIHZhciBncmlkUHJvdG8gPSBHcmlkLnByb3RvdHlwZTtcblxuICAgIGdyaWRQcm90by50eXBlID0gJ2dyaWQnO1xuXG4gICAgZ3JpZFByb3RvLmF4aXNQb2ludGVyRW5hYmxlZCA9IHRydWU7XG5cbiAgICBncmlkUHJvdG8uZ2V0UmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlY3Q7XG4gICAgfTtcblxuICAgIGdyaWRQcm90by51cGRhdGUgPSBmdW5jdGlvbiAoZWNNb2RlbCwgYXBpKSB7XG5cbiAgICAgICAgdmFyIGF4ZXNNYXAgPSB0aGlzLl9heGVzTWFwO1xuXG4gICAgICAgIHRoaXMuX3VwZGF0ZVNjYWxlKGVjTW9kZWwsIHRoaXMubW9kZWwpO1xuXG4gICAgICAgIGZ1bmN0aW9uIGlmQXhpc0Nhbk5vdE9uWmVybyhvdGhlckF4aXNEaW0pIHtcbiAgICAgICAgICAgIHZhciBheGVzID0gYXhlc01hcFtvdGhlckF4aXNEaW1dO1xuICAgICAgICAgICAgZm9yICh2YXIgaWR4IGluIGF4ZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXhlcy5oYXNPd25Qcm9wZXJ0eShpZHgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBheGlzID0gYXhlc1tpZHhdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXhpcyAmJiAoYXhpcy50eXBlID09PSAnY2F0ZWdvcnknIHx8ICFpZkF4aXNDcm9zc1plcm8oYXhpcykpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVhY2goYXhlc01hcC54LCBmdW5jdGlvbiAoeEF4aXMpIHtcbiAgICAgICAgICAgIG5pY2VTY2FsZUV4dGVudCh4QXhpcy5zY2FsZSwgeEF4aXMubW9kZWwpO1xuICAgICAgICB9KTtcbiAgICAgICAgZWFjaChheGVzTWFwLnksIGZ1bmN0aW9uICh5QXhpcykge1xuICAgICAgICAgICAgbmljZVNjYWxlRXh0ZW50KHlBeGlzLnNjYWxlLCB5QXhpcy5tb2RlbCk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBGaXggY29uZmlndXJhdGlvblxuICAgICAgICBlYWNoKGF4ZXNNYXAueCwgZnVuY3Rpb24gKHhBeGlzKSB7XG4gICAgICAgICAgICAvLyBvblplcm8gY2FuIG5vdCBiZSBlbmFibGVkIGluIHRoZXNlIHR3byBzaXR1YXRpb25zXG4gICAgICAgICAgICAvLyAxLiBXaGVuIGFueSBvdGhlciBheGlzIGlzIGEgY2F0ZWdvcnkgYXhpc1xuICAgICAgICAgICAgLy8gMi4gV2hlbiBhbnkgb3RoZXIgYXhpcyBub3QgYWNyb3NzIDAgcG9pbnRcbiAgICAgICAgICAgIGlmIChpZkF4aXNDYW5Ob3RPblplcm8oJ3knKSkge1xuICAgICAgICAgICAgICAgIHhBeGlzLm9uWmVybyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZWFjaChheGVzTWFwLnksIGZ1bmN0aW9uICh5QXhpcykge1xuICAgICAgICAgICAgaWYgKGlmQXhpc0Nhbk5vdE9uWmVybygneCcpKSB7XG4gICAgICAgICAgICAgICAgeUF4aXMub25aZXJvID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFJlc2l6ZSBhZ2FpbiBpZiBjb250YWluTGFiZWwgaXMgZW5hYmxlZFxuICAgICAgICAvLyBGSVhNRSBJdCBtYXkgY2F1c2UgZ2V0dGluZyB3cm9uZyBncmlkIHNpemUgaW4gZGF0YSBwcm9jZXNzaW5nIHN0YWdlXG4gICAgICAgIHRoaXMucmVzaXplKHRoaXMubW9kZWwsIGFwaSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlc2l6ZSB0aGUgZ3JpZFxuICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvY29vcmQvY2FydGVzaWFuL0dyaWRNb2RlbH0gZ3JpZE1vZGVsXG4gICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9FeHRlbnNpb25BUEl9IGFwaVxuICAgICAqL1xuICAgIGdyaWRQcm90by5yZXNpemUgPSBmdW5jdGlvbiAoZ3JpZE1vZGVsLCBhcGkpIHtcblxuICAgICAgICB2YXIgZ3JpZFJlY3QgPSBsYXlvdXQuZ2V0TGF5b3V0UmVjdChcbiAgICAgICAgICAgIGdyaWRNb2RlbC5nZXRCb3hMYXlvdXRQYXJhbXMoKSwge1xuICAgICAgICAgICAgICAgIHdpZHRoOiBhcGkuZ2V0V2lkdGgoKSxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGFwaS5nZXRIZWlnaHQoKVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5fcmVjdCA9IGdyaWRSZWN0O1xuXG4gICAgICAgIHZhciBheGVzTGlzdCA9IHRoaXMuX2F4ZXNMaXN0O1xuXG4gICAgICAgIGFkanVzdEF4ZXMoKTtcblxuICAgICAgICAvLyBNaW51cyBsYWJlbCBzaXplXG4gICAgICAgIGlmIChncmlkTW9kZWwuZ2V0KCdjb250YWluTGFiZWwnKSkge1xuICAgICAgICAgICAgZWFjaChheGVzTGlzdCwgZnVuY3Rpb24gKGF4aXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWF4aXMubW9kZWwuZ2V0KCdheGlzTGFiZWwuaW5zaWRlJykpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxhYmVsVW5pb25SZWN0ID0gZ2V0TGFiZWxVbmlvblJlY3QoYXhpcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsYWJlbFVuaW9uUmVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRpbSA9IGF4aXMuaXNIb3Jpem9udGFsKCkgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWFyZ2luID0gYXhpcy5tb2RlbC5nZXQoJ2F4aXNMYWJlbC5tYXJnaW4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyaWRSZWN0W2RpbV0gLT0gbGFiZWxVbmlvblJlY3RbZGltXSArIG1hcmdpbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChheGlzLnBvc2l0aW9uID09PSAndG9wJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyaWRSZWN0LnkgKz0gbGFiZWxVbmlvblJlY3QuaGVpZ2h0ICsgbWFyZ2luO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYXhpcy5wb3NpdGlvbiA9PT0gJ2xlZnQnKSAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyaWRSZWN0LnggKz0gbGFiZWxVbmlvblJlY3Qud2lkdGggKyBtYXJnaW47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgYWRqdXN0QXhlcygpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gYWRqdXN0QXhlcygpIHtcbiAgICAgICAgICAgIGVhY2goYXhlc0xpc3QsIGZ1bmN0aW9uIChheGlzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlzSG9yaXpvbnRhbCA9IGF4aXMuaXNIb3Jpem9udGFsKCk7XG4gICAgICAgICAgICAgICAgdmFyIGV4dGVudCA9IGlzSG9yaXpvbnRhbCA/IFswLCBncmlkUmVjdC53aWR0aF0gOiBbMCwgZ3JpZFJlY3QuaGVpZ2h0XTtcbiAgICAgICAgICAgICAgICB2YXIgaWR4ID0gYXhpcy5pbnZlcnNlID8gMSA6IDA7XG4gICAgICAgICAgICAgICAgYXhpcy5zZXRFeHRlbnQoZXh0ZW50W2lkeF0sIGV4dGVudFsxIC0gaWR4XSk7XG4gICAgICAgICAgICAgICAgdXBkYXRlQXhpc1RyYW5zZnJvbShheGlzLCBpc0hvcml6b250YWwgPyBncmlkUmVjdC54IDogZ3JpZFJlY3QueSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXhpc1R5cGVcbiAgICAgKiBAcGFyYW0ge25kdW1iZXJ9IFtheGlzSW5kZXhdXG4gICAgICovXG4gICAgZ3JpZFByb3RvLmdldEF4aXMgPSBmdW5jdGlvbiAoYXhpc1R5cGUsIGF4aXNJbmRleCkge1xuICAgICAgICB2YXIgYXhlc01hcE9uRGltID0gdGhpcy5fYXhlc01hcFtheGlzVHlwZV07XG4gICAgICAgIGlmIChheGVzTWFwT25EaW0gIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGF4aXNJbmRleCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gRmluZCBmaXJzdCBheGlzXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBheGVzTWFwT25EaW0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF4ZXNNYXBPbkRpbS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF4ZXNNYXBPbkRpbVtuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBheGVzTWFwT25EaW1bYXhpc0luZGV4XTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtBcnJheS48bW9kdWxlOmVjaGFydHMvY29vcmQvQXhpcz59XG4gICAgICovXG4gICAgZ3JpZFByb3RvLmdldEF4ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9heGVzTGlzdC5zbGljZSgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBVc2FnZTpcbiAgICAgKiAgICAgIGdyaWQuZ2V0Q2FydGVzaWFuKHhBeGlzSW5kZXgsIHlBeGlzSW5kZXgpO1xuICAgICAqICAgICAgZ3JpZC5nZXRDYXJ0ZXNpYW4oeEF4aXNJbmRleCk7XG4gICAgICogICAgICBncmlkLmdldENhcnRlc2lhbihudWxsLCB5QXhpc0luZGV4KTtcbiAgICAgKiAgICAgIGdyaWQuZ2V0Q2FydGVzaWFuKHt4QXhpc0luZGV4OiAuLi4sIHlBeGlzSW5kZXg6IC4uLn0pO1xuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ8T2JqZWN0fSBbeEF4aXNJbmRleF1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3lBeGlzSW5kZXhdXG4gICAgICovXG4gICAgZ3JpZFByb3RvLmdldENhcnRlc2lhbiA9IGZ1bmN0aW9uICh4QXhpc0luZGV4LCB5QXhpc0luZGV4KSB7XG4gICAgICAgIGlmICh4QXhpc0luZGV4ICE9IG51bGwgJiYgeUF4aXNJbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gJ3gnICsgeEF4aXNJbmRleCArICd5JyArIHlBeGlzSW5kZXg7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29vcmRzTWFwW2tleV07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoenJVdGlsLmlzT2JqZWN0KHhBeGlzSW5kZXgpKSB7XG4gICAgICAgICAgICB5QXhpc0luZGV4ID0geEF4aXNJbmRleC55QXhpc0luZGV4O1xuICAgICAgICAgICAgeEF4aXNJbmRleCA9IHhBeGlzSW5kZXgueEF4aXNJbmRleDtcbiAgICAgICAgfVxuICAgICAgICAvLyBXaGVuIG9ubHkgeEF4aXNJbmRleCBvciB5QXhpc0luZGV4IGdpdmVuLCBmaW5kIGl0cyBmaXJzdCBjYXJ0ZXNpYW4uXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBjb29yZExpc3QgPSB0aGlzLl9jb29yZHNMaXN0OyBpIDwgY29vcmRMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoY29vcmRMaXN0W2ldLmdldEF4aXMoJ3gnKS5pbmRleCA9PT0geEF4aXNJbmRleFxuICAgICAgICAgICAgICAgIHx8IGNvb3JkTGlzdFtpXS5nZXRBeGlzKCd5JykuaW5kZXggPT09IHlBeGlzSW5kZXhcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb29yZExpc3RbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZ3JpZFByb3RvLmdldENhcnRlc2lhbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb29yZHNMaXN0LnNsaWNlKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBpbXBsZW1lbnRzXG4gICAgICogc2VlIHttb2R1bGU6ZWNoYXJ0cy9Db29kaW5hdGVTeXN0ZW19XG4gICAgICovXG4gICAgZ3JpZFByb3RvLmNvbnZlcnRUb1BpeGVsID0gZnVuY3Rpb24gKGVjTW9kZWwsIGZpbmRlciwgdmFsdWUpIHtcbiAgICAgICAgdmFyIHRhcmdldCA9IHRoaXMuX2ZpbmRDb252ZXJ0VGFyZ2V0KGVjTW9kZWwsIGZpbmRlcik7XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldC5jYXJ0ZXNpYW5cbiAgICAgICAgICAgID8gdGFyZ2V0LmNhcnRlc2lhbi5kYXRhVG9Qb2ludCh2YWx1ZSlcbiAgICAgICAgICAgIDogdGFyZ2V0LmF4aXNcbiAgICAgICAgICAgID8gdGFyZ2V0LmF4aXMudG9HbG9iYWxDb29yZCh0YXJnZXQuYXhpcy5kYXRhVG9Db29yZCh2YWx1ZSkpXG4gICAgICAgICAgICA6IG51bGw7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBpbXBsZW1lbnRzXG4gICAgICogc2VlIHttb2R1bGU6ZWNoYXJ0cy9Db29kaW5hdGVTeXN0ZW19XG4gICAgICovXG4gICAgZ3JpZFByb3RvLmNvbnZlcnRGcm9tUGl4ZWwgPSBmdW5jdGlvbiAoZWNNb2RlbCwgZmluZGVyLCB2YWx1ZSkge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcy5fZmluZENvbnZlcnRUYXJnZXQoZWNNb2RlbCwgZmluZGVyKTtcblxuICAgICAgICByZXR1cm4gdGFyZ2V0LmNhcnRlc2lhblxuICAgICAgICAgICAgPyB0YXJnZXQuY2FydGVzaWFuLnBvaW50VG9EYXRhKHZhbHVlKVxuICAgICAgICAgICAgOiB0YXJnZXQuYXhpc1xuICAgICAgICAgICAgPyB0YXJnZXQuYXhpcy5jb29yZFRvRGF0YSh0YXJnZXQuYXhpcy50b0xvY2FsQ29vcmQodmFsdWUpKVxuICAgICAgICAgICAgOiBudWxsO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBncmlkUHJvdG8uX2ZpbmRDb252ZXJ0VGFyZ2V0ID0gZnVuY3Rpb24gKGVjTW9kZWwsIGZpbmRlcikge1xuICAgICAgICB2YXIgc2VyaWVzTW9kZWwgPSBmaW5kZXIuc2VyaWVzTW9kZWw7XG4gICAgICAgIHZhciB4QXhpc01vZGVsID0gZmluZGVyLnhBeGlzTW9kZWxcbiAgICAgICAgICAgIHx8IChzZXJpZXNNb2RlbCAmJiBzZXJpZXNNb2RlbC5nZXRSZWZlcnJpbmdDb21wb25lbnRzKCd4QXhpcycpWzBdKTtcbiAgICAgICAgdmFyIHlBeGlzTW9kZWwgPSBmaW5kZXIueUF4aXNNb2RlbFxuICAgICAgICAgICAgfHwgKHNlcmllc01vZGVsICYmIHNlcmllc01vZGVsLmdldFJlZmVycmluZ0NvbXBvbmVudHMoJ3lBeGlzJylbMF0pO1xuICAgICAgICB2YXIgZ3JpZE1vZGVsID0gZmluZGVyLmdyaWRNb2RlbDtcbiAgICAgICAgdmFyIGNvb3Jkc0xpc3QgPSB0aGlzLl9jb29yZHNMaXN0O1xuICAgICAgICB2YXIgY2FydGVzaWFuO1xuICAgICAgICB2YXIgYXhpcztcblxuICAgICAgICBpZiAoc2VyaWVzTW9kZWwpIHtcbiAgICAgICAgICAgIGNhcnRlc2lhbiA9IHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG4gICAgICAgICAgICB6clV0aWwuaW5kZXhPZihjb29yZHNMaXN0LCBjYXJ0ZXNpYW4pIDwgMCAmJiAoY2FydGVzaWFuID0gbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoeEF4aXNNb2RlbCAmJiB5QXhpc01vZGVsKSB7XG4gICAgICAgICAgICBjYXJ0ZXNpYW4gPSB0aGlzLmdldENhcnRlc2lhbih4QXhpc01vZGVsLmNvbXBvbmVudEluZGV4LCB5QXhpc01vZGVsLmNvbXBvbmVudEluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh4QXhpc01vZGVsKSB7XG4gICAgICAgICAgICBheGlzID0gdGhpcy5nZXRBeGlzKCd4JywgeEF4aXNNb2RlbC5jb21wb25lbnRJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoeUF4aXNNb2RlbCkge1xuICAgICAgICAgICAgYXhpcyA9IHRoaXMuZ2V0QXhpcygneScsIHlBeGlzTW9kZWwuY29tcG9uZW50SW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIExvd2VzdCBwcmlvcml0eS5cbiAgICAgICAgZWxzZSBpZiAoZ3JpZE1vZGVsKSB7XG4gICAgICAgICAgICB2YXIgZ3JpZCA9IGdyaWRNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICAgICAgICAgICAgaWYgKGdyaWQgPT09IHRoaXMpIHtcbiAgICAgICAgICAgICAgICBjYXJ0ZXNpYW4gPSB0aGlzLl9jb29yZHNMaXN0WzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtjYXJ0ZXNpYW46IGNhcnRlc2lhbiwgYXhpczogYXhpc307XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBpbXBsZW1lbnRzXG4gICAgICogc2VlIHttb2R1bGU6ZWNoYXJ0cy9Db29kaW5hdGVTeXN0ZW19XG4gICAgICovXG4gICAgZ3JpZFByb3RvLmNvbnRhaW5Qb2ludCA9IGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgICB2YXIgY29vcmQgPSB0aGlzLl9jb29yZHNMaXN0WzBdO1xuICAgICAgICBpZiAoY29vcmQpIHtcbiAgICAgICAgICAgIHJldHVybiBjb29yZC5jb250YWluUG9pbnQocG9pbnQpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgY2FydGVzaWFuIGNvb3JkaW5hdGUgc3lzdGVtc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZ3JpZFByb3RvLl9pbml0Q2FydGVzaWFuID0gZnVuY3Rpb24gKGdyaWRNb2RlbCwgZWNNb2RlbCwgYXBpKSB7XG4gICAgICAgIHZhciBheGlzUG9zaXRpb25Vc2VkID0ge1xuICAgICAgICAgICAgbGVmdDogZmFsc2UsXG4gICAgICAgICAgICByaWdodDogZmFsc2UsXG4gICAgICAgICAgICB0b3A6IGZhbHNlLFxuICAgICAgICAgICAgYm90dG9tOiBmYWxzZVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBheGVzTWFwID0ge1xuICAgICAgICAgICAgeDoge30sXG4gICAgICAgICAgICB5OiB7fVxuICAgICAgICB9O1xuICAgICAgICB2YXIgYXhlc0NvdW50ID0ge1xuICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgIHk6IDBcbiAgICAgICAgfTtcblxuICAgICAgICAvLy8gQ3JlYXRlIGF4aXNcbiAgICAgICAgZWNNb2RlbC5lYWNoQ29tcG9uZW50KCd4QXhpcycsIGNyZWF0ZUF4aXNDcmVhdG9yKCd4JyksIHRoaXMpO1xuICAgICAgICBlY01vZGVsLmVhY2hDb21wb25lbnQoJ3lBeGlzJywgY3JlYXRlQXhpc0NyZWF0b3IoJ3knKSwgdGhpcyk7XG5cbiAgICAgICAgaWYgKCFheGVzQ291bnQueCB8fCAhYXhlc0NvdW50LnkpIHtcbiAgICAgICAgICAgIC8vIFJvbGwgYmFjayB3aGVuIHRoZXJlIG5vIGVpdGhlciB4IG9yIHkgYXhpc1xuICAgICAgICAgICAgdGhpcy5fYXhlc01hcCA9IHt9O1xuICAgICAgICAgICAgdGhpcy5fYXhlc0xpc3QgPSBbXTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2F4ZXNNYXAgPSBheGVzTWFwO1xuXG4gICAgICAgIC8vLyBDcmVhdGUgY2FydGVzaWFuMmRcbiAgICAgICAgZWFjaChheGVzTWFwLngsIGZ1bmN0aW9uICh4QXhpcywgeEF4aXNJbmRleCkge1xuICAgICAgICAgICAgZWFjaChheGVzTWFwLnksIGZ1bmN0aW9uICh5QXhpcywgeUF4aXNJbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSAneCcgKyB4QXhpc0luZGV4ICsgJ3knICsgeUF4aXNJbmRleDtcbiAgICAgICAgICAgICAgICB2YXIgY2FydGVzaWFuID0gbmV3IENhcnRlc2lhbjJEKGtleSk7XG5cbiAgICAgICAgICAgICAgICBjYXJ0ZXNpYW4uZ3JpZCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgY2FydGVzaWFuLm1vZGVsID0gZ3JpZE1vZGVsO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fY29vcmRzTWFwW2tleV0gPSBjYXJ0ZXNpYW47XG4gICAgICAgICAgICAgICAgdGhpcy5fY29vcmRzTGlzdC5wdXNoKGNhcnRlc2lhbik7XG5cbiAgICAgICAgICAgICAgICBjYXJ0ZXNpYW4uYWRkQXhpcyh4QXhpcyk7XG4gICAgICAgICAgICAgICAgY2FydGVzaWFuLmFkZEF4aXMoeUF4aXMpO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZUF4aXNDcmVhdG9yKGF4aXNUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGF4aXNNb2RlbCwgaWR4KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc0F4aXNVc2VkSW5UaGVHcmlkKGF4aXNNb2RlbCwgZ3JpZE1vZGVsLCBlY01vZGVsKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGF4aXNQb3NpdGlvbiA9IGF4aXNNb2RlbC5nZXQoJ3Bvc2l0aW9uJyk7XG4gICAgICAgICAgICAgICAgaWYgKGF4aXNUeXBlID09PSAneCcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRml4IHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgIGlmIChheGlzUG9zaXRpb24gIT09ICd0b3AnICYmIGF4aXNQb3NpdGlvbiAhPT0gJ2JvdHRvbScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlZmF1bHQgYm90dG9tIG9mIFhcbiAgICAgICAgICAgICAgICAgICAgICAgIGF4aXNQb3NpdGlvbiA9ICdib3R0b20nO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGF4aXNQb3NpdGlvblVzZWRbYXhpc1Bvc2l0aW9uXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF4aXNQb3NpdGlvbiA9IGF4aXNQb3NpdGlvbiA9PT0gJ3RvcCcgPyAnYm90dG9tJyA6ICd0b3AnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBGaXggcG9zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgaWYgKGF4aXNQb3NpdGlvbiAhPT0gJ2xlZnQnICYmIGF4aXNQb3NpdGlvbiAhPT0gJ3JpZ2h0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVmYXVsdCBsZWZ0IG9mIFlcbiAgICAgICAgICAgICAgICAgICAgICAgIGF4aXNQb3NpdGlvbiA9ICdsZWZ0JztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChheGlzUG9zaXRpb25Vc2VkW2F4aXNQb3NpdGlvbl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBheGlzUG9zaXRpb24gPSBheGlzUG9zaXRpb24gPT09ICdsZWZ0JyA/ICdyaWdodCcgOiAnbGVmdCc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXhpc1Bvc2l0aW9uVXNlZFtheGlzUG9zaXRpb25dID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIHZhciBheGlzID0gbmV3IEF4aXMyRChcbiAgICAgICAgICAgICAgICAgICAgYXhpc1R5cGUsIGF4aXNIZWxwZXIuY3JlYXRlU2NhbGVCeU1vZGVsKGF4aXNNb2RlbCksXG4gICAgICAgICAgICAgICAgICAgIFswLCAwXSxcbiAgICAgICAgICAgICAgICAgICAgYXhpc01vZGVsLmdldCgndHlwZScpLFxuICAgICAgICAgICAgICAgICAgICBheGlzUG9zaXRpb25cbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgdmFyIGlzQ2F0ZWdvcnkgPSBheGlzLnR5cGUgPT09ICdjYXRlZ29yeSc7XG4gICAgICAgICAgICAgICAgYXhpcy5vbkJhbmQgPSBpc0NhdGVnb3J5ICYmIGF4aXNNb2RlbC5nZXQoJ2JvdW5kYXJ5R2FwJyk7XG4gICAgICAgICAgICAgICAgYXhpcy5pbnZlcnNlID0gYXhpc01vZGVsLmdldCgnaW52ZXJzZScpO1xuXG4gICAgICAgICAgICAgICAgYXhpcy5vblplcm8gPSBheGlzTW9kZWwuZ2V0KCdheGlzTGluZS5vblplcm8nKTtcblxuICAgICAgICAgICAgICAgIC8vIEluamVjdCBheGlzIGludG8gYXhpc01vZGVsXG4gICAgICAgICAgICAgICAgYXhpc01vZGVsLmF4aXMgPSBheGlzO1xuXG4gICAgICAgICAgICAgICAgLy8gSW5qZWN0IGF4aXNNb2RlbCBpbnRvIGF4aXNcbiAgICAgICAgICAgICAgICBheGlzLm1vZGVsID0gYXhpc01vZGVsO1xuXG4gICAgICAgICAgICAgICAgLy8gSW5qZWN0IGdyaWQgaW5mbyBheGlzXG4gICAgICAgICAgICAgICAgYXhpcy5ncmlkID0gdGhpcztcblxuICAgICAgICAgICAgICAgIC8vIEluZGV4IG9mIGF4aXMsIGNhbiBiZSB1c2VkIGFzIGtleVxuICAgICAgICAgICAgICAgIGF4aXMuaW5kZXggPSBpZHg7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9heGVzTGlzdC5wdXNoKGF4aXMpO1xuXG4gICAgICAgICAgICAgICAgYXhlc01hcFtheGlzVHlwZV1baWR4XSA9IGF4aXM7XG4gICAgICAgICAgICAgICAgYXhlc0NvdW50W2F4aXNUeXBlXSsrO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgY2FydGVzaWFuIHByb3BlcnRpZXMgZnJvbSBzZXJpZXNcbiAgICAgKiBAcGFyYW0gIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9PcHRpb259IG9wdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZ3JpZFByb3RvLl91cGRhdGVTY2FsZSA9IGZ1bmN0aW9uIChlY01vZGVsLCBncmlkTW9kZWwpIHtcbiAgICAgICAgLy8gUmVzZXQgc2NhbGVcbiAgICAgICAgenJVdGlsLmVhY2godGhpcy5fYXhlc0xpc3QsIGZ1bmN0aW9uIChheGlzKSB7XG4gICAgICAgICAgICBheGlzLnNjYWxlLnNldEV4dGVudChJbmZpbml0eSwgLUluZmluaXR5KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGVjTW9kZWwuZWFjaFNlcmllcyhmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICAgICAgICAgIGlmIChpc0NhcnRlc2lhbjJEKHNlcmllc01vZGVsKSkge1xuICAgICAgICAgICAgICAgIHZhciBheGVzTW9kZWxzID0gZmluZEF4ZXNNb2RlbHMoc2VyaWVzTW9kZWwsIGVjTW9kZWwpO1xuICAgICAgICAgICAgICAgIHZhciB4QXhpc01vZGVsID0gYXhlc01vZGVsc1swXTtcbiAgICAgICAgICAgICAgICB2YXIgeUF4aXNNb2RlbCA9IGF4ZXNNb2RlbHNbMV07XG5cbiAgICAgICAgICAgICAgICBpZiAoIWlzQXhpc1VzZWRJblRoZUdyaWQoeEF4aXNNb2RlbCwgZ3JpZE1vZGVsLCBlY01vZGVsKVxuICAgICAgICAgICAgICAgICAgICB8fCAhaXNBeGlzVXNlZEluVGhlR3JpZCh5QXhpc01vZGVsLCBncmlkTW9kZWwsIGVjTW9kZWwpXG4gICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGNhcnRlc2lhbiA9IHRoaXMuZ2V0Q2FydGVzaWFuKFxuICAgICAgICAgICAgICAgICAgICB4QXhpc01vZGVsLmNvbXBvbmVudEluZGV4LCB5QXhpc01vZGVsLmNvbXBvbmVudEluZGV4XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICAgICAgICAgICAgICB2YXIgeEF4aXMgPSBjYXJ0ZXNpYW4uZ2V0QXhpcygneCcpO1xuICAgICAgICAgICAgICAgIHZhciB5QXhpcyA9IGNhcnRlc2lhbi5nZXRBeGlzKCd5Jyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZGF0YS50eXBlID09PSAnbGlzdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdW5pb25FeHRlbnQoZGF0YSwgeEF4aXMsIHNlcmllc01vZGVsKTtcbiAgICAgICAgICAgICAgICAgICAgdW5pb25FeHRlbnQoZGF0YSwgeUF4aXMsIHNlcmllc01vZGVsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIGZ1bmN0aW9uIHVuaW9uRXh0ZW50KGRhdGEsIGF4aXMsIHNlcmllc01vZGVsKSB7XG4gICAgICAgICAgICBlYWNoKHNlcmllc01vZGVsLmNvb3JkRGltVG9EYXRhRGltKGF4aXMuZGltKSwgZnVuY3Rpb24gKGRpbSkge1xuICAgICAgICAgICAgICAgIGF4aXMuc2NhbGUudW5pb25FeHRlbnRGcm9tRGF0YShkYXRhLCBkaW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtkaW1dICd4JyBvciAneScgb3IgJ2F1dG8nIG9yIG51bGwvdW5kZWZpbmVkXG4gICAgICogQHJldHVybiB7T2JqZWN0fSB7YmFzZUF4ZXM6IFtdLCBvdGhlckF4ZXM6IFtdfVxuICAgICAqL1xuICAgIGdyaWRQcm90by5nZXRUb29sdGlwQXhlcyA9IGZ1bmN0aW9uIChkaW0pIHtcbiAgICAgICAgdmFyIGJhc2VBeGVzID0gW107XG4gICAgICAgIHZhciBvdGhlckF4ZXMgPSBbXTtcblxuICAgICAgICBlYWNoKHRoaXMuZ2V0Q2FydGVzaWFucygpLCBmdW5jdGlvbiAoY2FydGVzaWFuKSB7XG4gICAgICAgICAgICB2YXIgYmFzZUF4aXMgPSAoZGltICE9IG51bGwgJiYgZGltICE9PSAnYXV0bycpXG4gICAgICAgICAgICAgICAgPyBjYXJ0ZXNpYW4uZ2V0QXhpcyhkaW0pIDogY2FydGVzaWFuLmdldEJhc2VBeGlzKCk7XG4gICAgICAgICAgICB2YXIgb3RoZXJBeGlzID0gY2FydGVzaWFuLmdldE90aGVyQXhpcyhiYXNlQXhpcyk7XG4gICAgICAgICAgICB6clV0aWwuaW5kZXhPZihiYXNlQXhlcywgYmFzZUF4aXMpIDwgMCAmJiBiYXNlQXhlcy5wdXNoKGJhc2VBeGlzKTtcbiAgICAgICAgICAgIHpyVXRpbC5pbmRleE9mKG90aGVyQXhlcywgb3RoZXJBeGlzKSA8IDAgJiYgb3RoZXJBeGVzLnB1c2gob3RoZXJBeGlzKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHtiYXNlQXhlczogYmFzZUF4ZXMsIG90aGVyQXhlczogb3RoZXJBeGVzfTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gdXBkYXRlQXhpc1RyYW5zZnJvbShheGlzLCBjb29yZEJhc2UpIHtcbiAgICAgICAgdmFyIGF4aXNFeHRlbnQgPSBheGlzLmdldEV4dGVudCgpO1xuICAgICAgICB2YXIgYXhpc0V4dGVudFN1bSA9IGF4aXNFeHRlbnRbMF0gKyBheGlzRXh0ZW50WzFdO1xuXG4gICAgICAgIC8vIEZhc3QgdHJhbnNmb3JtXG4gICAgICAgIGF4aXMudG9HbG9iYWxDb29yZCA9IGF4aXMuZGltID09PSAneCdcbiAgICAgICAgICAgID8gZnVuY3Rpb24gKGNvb3JkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvb3JkICsgY29vcmRCYXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiBmdW5jdGlvbiAoY29vcmQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXhpc0V4dGVudFN1bSAtIGNvb3JkICsgY29vcmRCYXNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgYXhpcy50b0xvY2FsQ29vcmQgPSBheGlzLmRpbSA9PT0gJ3gnXG4gICAgICAgICAgICA/IGZ1bmN0aW9uIChjb29yZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb29yZCAtIGNvb3JkQmFzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDogZnVuY3Rpb24gKGNvb3JkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF4aXNFeHRlbnRTdW0gLSBjb29yZCArIGNvb3JkQmFzZTtcbiAgICAgICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGF4ZXNUeXBlcyA9IFsneEF4aXMnLCAneUF4aXMnXTtcbiAgICAvKipcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kQXhlc01vZGVscyhzZXJpZXNNb2RlbCwgZWNNb2RlbCkge1xuICAgICAgICByZXR1cm4genJVdGlsLm1hcChheGVzVHlwZXMsIGZ1bmN0aW9uIChheGlzVHlwZSkge1xuICAgICAgICAgICAgdmFyIGF4aXNNb2RlbCA9IHNlcmllc01vZGVsLmdldFJlZmVycmluZ0NvbXBvbmVudHMoYXhpc1R5cGUpWzBdO1xuXG4gICAgICAgICAgICBpZiAoX19ERVZfXykge1xuICAgICAgICAgICAgICAgIGlmICghYXhpc01vZGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihheGlzVHlwZSArICcgXCInICsgenJVdGlsLnJldHJpZXZlKFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzTW9kZWwuZ2V0KGF4aXNUeXBlICsgJ0luZGV4JyksXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXNNb2RlbC5nZXQoYXhpc1R5cGUgKyAnSWQnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICAgICAgICAgKSArICdcIiBub3QgZm91bmQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXhpc01vZGVsO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0NhcnRlc2lhbjJEKHNlcmllc01vZGVsKSB7XG4gICAgICAgIHJldHVybiBzZXJpZXNNb2RlbC5nZXQoJ2Nvb3JkaW5hdGVTeXN0ZW0nKSA9PT0gJ2NhcnRlc2lhbjJkJztcbiAgICB9XG5cbiAgICBHcmlkLmNyZWF0ZSA9IGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHtcbiAgICAgICAgdmFyIGdyaWRzID0gW107XG4gICAgICAgIGVjTW9kZWwuZWFjaENvbXBvbmVudCgnZ3JpZCcsIGZ1bmN0aW9uIChncmlkTW9kZWwsIGlkeCkge1xuICAgICAgICAgICAgdmFyIGdyaWQgPSBuZXcgR3JpZChncmlkTW9kZWwsIGVjTW9kZWwsIGFwaSk7XG4gICAgICAgICAgICBncmlkLm5hbWUgPSAnZ3JpZF8nICsgaWR4O1xuICAgICAgICAgICAgZ3JpZC5yZXNpemUoZ3JpZE1vZGVsLCBhcGkpO1xuXG4gICAgICAgICAgICBncmlkTW9kZWwuY29vcmRpbmF0ZVN5c3RlbSA9IGdyaWQ7XG5cbiAgICAgICAgICAgIGdyaWRzLnB1c2goZ3JpZCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEluamVjdCB0aGUgY29vcmRpbmF0ZVN5c3RlbXMgaW50byBzZXJpZXNNb2RlbFxuICAgICAgICBlY01vZGVsLmVhY2hTZXJpZXMoZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICAgICAgICBpZiAoIWlzQ2FydGVzaWFuMkQoc2VyaWVzTW9kZWwpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgYXhlc01vZGVscyA9IGZpbmRBeGVzTW9kZWxzKHNlcmllc01vZGVsLCBlY01vZGVsKTtcbiAgICAgICAgICAgIHZhciB4QXhpc01vZGVsID0gYXhlc01vZGVsc1swXTtcbiAgICAgICAgICAgIHZhciB5QXhpc01vZGVsID0gYXhlc01vZGVsc1sxXTtcblxuICAgICAgICAgICAgdmFyIGdyaWRNb2RlbCA9IHhBeGlzTW9kZWwuZ2V0Q29vcmRTeXNNb2RlbCgpO1xuXG4gICAgICAgICAgICBpZiAoX19ERVZfXykge1xuICAgICAgICAgICAgICAgIGlmICghZ3JpZE1vZGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICdHcmlkIFwiJyArIHpyVXRpbC5yZXRyaWV2ZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4QXhpc01vZGVsLmdldCgnZ3JpZEluZGV4JyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeEF4aXNNb2RlbC5nZXQoJ2dyaWRJZCcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICAgICAgICAgICAgICkgKyAnXCIgbm90IGZvdW5kJ1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoeEF4aXNNb2RlbC5nZXRDb29yZFN5c01vZGVsKCkgIT09IHlBeGlzTW9kZWwuZ2V0Q29vcmRTeXNNb2RlbCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigneEF4aXMgYW5kIHlBeGlzIG11c3QgdXNlIHRoZSBzYW1lIGdyaWQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBncmlkID0gZ3JpZE1vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG5cbiAgICAgICAgICAgIHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW0gPSBncmlkLmdldENhcnRlc2lhbihcbiAgICAgICAgICAgICAgICB4QXhpc01vZGVsLmNvbXBvbmVudEluZGV4LCB5QXhpc01vZGVsLmNvbXBvbmVudEluZGV4XG4gICAgICAgICAgICApO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gZ3JpZHM7XG4gICAgfTtcblxuICAgIC8vIEZvciBkZWNpZGluZyB3aGljaCBkaW1lbnNpb25zIHRvIHVzZSB3aGVuIGNyZWF0aW5nIGxpc3QgZGF0YVxuICAgIEdyaWQuZGltZW5zaW9ucyA9IEdyaWQucHJvdG90eXBlLmRpbWVuc2lvbnMgPSBDYXJ0ZXNpYW4yRC5wcm90b3R5cGUuZGltZW5zaW9ucztcblxuICAgIHJlcXVpcmUoJy4uLy4uL0Nvb3JkaW5hdGVTeXN0ZW0nKS5yZWdpc3RlcignY2FydGVzaWFuMmQnLCBHcmlkKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gR3JpZDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Nvb3JkL2NhcnRlc2lhbi9HcmlkLmpzXG4vLyBtb2R1bGUgaWQgPSA1NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 57 */
/* unknown exports provided */
/* all exports used */
/*!*****************************************!*\
  !*** /home/yx/~/zrender/lib/Element.js ***!
  \*****************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * @module zrender/Element\n */\n\n\n    var guid = __webpack_require__(/*! ./core/guid */ 62);\n    var Eventful = __webpack_require__(/*! ./mixin/Eventful */ 22);\n    var Transformable = __webpack_require__(/*! ./mixin/Transformable */ 54);\n    var Animatable = __webpack_require__(/*! ./mixin/Animatable */ 128);\n    var zrUtil = __webpack_require__(/*! ./core/util */ 0);\n\n    /**\n     * @alias module:zrender/Element\n     * @constructor\n     * @extends {module:zrender/mixin/Animatable}\n     * @extends {module:zrender/mixin/Transformable}\n     * @extends {module:zrender/mixin/Eventful}\n     */\n    var Element = function (opts) {\n\n        Transformable.call(this, opts);\n        Eventful.call(this, opts);\n        Animatable.call(this, opts);\n\n        /**\n         * 画布元素ID\n         * @type {string}\n         */\n        this.id = opts.id || guid();\n    };\n\n    Element.prototype = {\n\n        /**\n         * 元素类型\n         * Element type\n         * @type {string}\n         */\n        type: 'element',\n\n        /**\n         * 元素名字\n         * Element name\n         * @type {string}\n         */\n        name: '',\n\n        /**\n         * ZRender 实例对象，会在 element 添加到 zrender 实例中后自动赋值\n         * ZRender instance will be assigned when element is associated with zrender\n         * @name module:/zrender/Element#__zr\n         * @type {module:zrender/ZRender}\n         */\n        __zr: null,\n\n        /**\n         * 图形是否忽略，为true时忽略图形的绘制以及事件触发\n         * If ignore drawing and events of the element object\n         * @name module:/zrender/Element#ignore\n         * @type {boolean}\n         * @default false\n         */\n        ignore: false,\n\n        /**\n         * 用于裁剪的路径(shape)，所有 Group 内的路径在绘制时都会被这个路径裁剪\n         * 该路径会继承被裁减对象的变换\n         * @type {module:zrender/graphic/Path}\n         * @see http://www.w3.org/TR/2dcontext/#clipping-region\n         * @readOnly\n         */\n        clipPath: null,\n\n        /**\n         * Drift element\n         * @param  {number} dx dx on the global space\n         * @param  {number} dy dy on the global space\n         */\n        drift: function (dx, dy) {\n            switch (this.draggable) {\n                case 'horizontal':\n                    dy = 0;\n                    break;\n                case 'vertical':\n                    dx = 0;\n                    break;\n            }\n\n            var m = this.transform;\n            if (!m) {\n                m = this.transform = [1, 0, 0, 1, 0, 0];\n            }\n            m[4] += dx;\n            m[5] += dy;\n\n            this.decomposeTransform();\n            this.dirty(false);\n        },\n\n        /**\n         * Hook before update\n         */\n        beforeUpdate: function () {},\n        /**\n         * Hook after update\n         */\n        afterUpdate: function () {},\n        /**\n         * Update each frame\n         */\n        update: function () {\n            this.updateTransform();\n        },\n\n        /**\n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        traverse: function (cb, context) {},\n\n        /**\n         * @protected\n         */\n        attrKV: function (key, value) {\n            if (key === 'position' || key === 'scale' || key === 'origin') {\n                // Copy the array\n                if (value) {\n                    var target = this[key];\n                    if (!target) {\n                        target = this[key] = [];\n                    }\n                    target[0] = value[0];\n                    target[1] = value[1];\n                }\n            }\n            else {\n                this[key] = value;\n            }\n        },\n\n        /**\n         * Hide the element\n         */\n        hide: function () {\n            this.ignore = true;\n            this.__zr && this.__zr.refresh();\n        },\n\n        /**\n         * Show the element\n         */\n        show: function () {\n            this.ignore = false;\n            this.__zr && this.__zr.refresh();\n        },\n\n        /**\n         * @param {string|Object} key\n         * @param {*} value\n         */\n        attr: function (key, value) {\n            if (typeof key === 'string') {\n                this.attrKV(key, value);\n            }\n            else if (zrUtil.isObject(key)) {\n                for (var name in key) {\n                    if (key.hasOwnProperty(name)) {\n                        this.attrKV(name, key[name]);\n                    }\n                }\n            }\n\n            this.dirty(false);\n\n            return this;\n        },\n\n        /**\n         * @param {module:zrender/graphic/Path} clipPath\n         */\n        setClipPath: function (clipPath) {\n            var zr = this.__zr;\n            if (zr) {\n                clipPath.addSelfToZr(zr);\n            }\n\n            // Remove previous clip path\n            if (this.clipPath && this.clipPath !== clipPath) {\n                this.removeClipPath();\n            }\n\n            this.clipPath = clipPath;\n            clipPath.__zr = zr;\n            clipPath.__clipTarget = this;\n\n            this.dirty(false);\n        },\n\n        /**\n         */\n        removeClipPath: function () {\n            var clipPath = this.clipPath;\n            if (clipPath) {\n                if (clipPath.__zr) {\n                    clipPath.removeSelfFromZr(clipPath.__zr);\n                }\n\n                clipPath.__zr = null;\n                clipPath.__clipTarget = null;\n                this.clipPath = null;\n\n                this.dirty(false);\n            }\n        },\n\n        /**\n         * Add self from zrender instance.\n         * Not recursively because it will be invoked when element added to storage.\n         * @param {module:zrender/ZRender} zr\n         */\n        addSelfToZr: function (zr) {\n            this.__zr = zr;\n            // 添加动画\n            var animators = this.animators;\n            if (animators) {\n                for (var i = 0; i < animators.length; i++) {\n                    zr.animation.addAnimator(animators[i]);\n                }\n            }\n\n            if (this.clipPath) {\n                this.clipPath.addSelfToZr(zr);\n            }\n        },\n\n        /**\n         * Remove self from zrender instance.\n         * Not recursively because it will be invoked when element added to storage.\n         * @param {module:zrender/ZRender} zr\n         */\n        removeSelfFromZr: function (zr) {\n            this.__zr = null;\n            // 移除动画\n            var animators = this.animators;\n            if (animators) {\n                for (var i = 0; i < animators.length; i++) {\n                    zr.animation.removeAnimator(animators[i]);\n                }\n            }\n\n            if (this.clipPath) {\n                this.clipPath.removeSelfFromZr(zr);\n            }\n        }\n    };\n\n    zrUtil.mixin(Element, Animatable);\n    zrUtil.mixin(Element, Transformable);\n    zrUtil.mixin(Element, Eventful);\n\n    module.exports = Element;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL2hvbWUveXgvfi96cmVuZGVyL2xpYi9FbGVtZW50LmpzP2E4OWQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuLyoqXG4gKiBAbW9kdWxlIHpyZW5kZXIvRWxlbWVudFxuICovXG5cblxuICAgIHZhciBndWlkID0gcmVxdWlyZSgnLi9jb3JlL2d1aWQnKTtcbiAgICB2YXIgRXZlbnRmdWwgPSByZXF1aXJlKCcuL21peGluL0V2ZW50ZnVsJyk7XG4gICAgdmFyIFRyYW5zZm9ybWFibGUgPSByZXF1aXJlKCcuL21peGluL1RyYW5zZm9ybWFibGUnKTtcbiAgICB2YXIgQW5pbWF0YWJsZSA9IHJlcXVpcmUoJy4vbWl4aW4vQW5pbWF0YWJsZScpO1xuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCcuL2NvcmUvdXRpbCcpO1xuXG4gICAgLyoqXG4gICAgICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL0VsZW1lbnRcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAZXh0ZW5kcyB7bW9kdWxlOnpyZW5kZXIvbWl4aW4vQW5pbWF0YWJsZX1cbiAgICAgKiBAZXh0ZW5kcyB7bW9kdWxlOnpyZW5kZXIvbWl4aW4vVHJhbnNmb3JtYWJsZX1cbiAgICAgKiBAZXh0ZW5kcyB7bW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWx9XG4gICAgICovXG4gICAgdmFyIEVsZW1lbnQgPSBmdW5jdGlvbiAob3B0cykge1xuXG4gICAgICAgIFRyYW5zZm9ybWFibGUuY2FsbCh0aGlzLCBvcHRzKTtcbiAgICAgICAgRXZlbnRmdWwuY2FsbCh0aGlzLCBvcHRzKTtcbiAgICAgICAgQW5pbWF0YWJsZS5jYWxsKHRoaXMsIG9wdHMpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDnlLvluIPlhYPntKBJRFxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pZCA9IG9wdHMuaWQgfHwgZ3VpZCgpO1xuICAgIH07XG5cbiAgICBFbGVtZW50LnByb3RvdHlwZSA9IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICog5YWD57Sg57G75Z6LXG4gICAgICAgICAqIEVsZW1lbnQgdHlwZVxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdHlwZTogJ2VsZW1lbnQnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlhYPntKDlkI3lrZdcbiAgICAgICAgICogRWxlbWVudCBuYW1lXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICBuYW1lOiAnJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogWlJlbmRlciDlrp7kvovlr7nosaHvvIzkvJrlnKggZWxlbWVudCDmt7vliqDliLAgenJlbmRlciDlrp7kvovkuK3lkI7oh6rliqjotYvlgLxcbiAgICAgICAgICogWlJlbmRlciBpbnN0YW5jZSB3aWxsIGJlIGFzc2lnbmVkIHdoZW4gZWxlbWVudCBpcyBhc3NvY2lhdGVkIHdpdGggenJlbmRlclxuICAgICAgICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvRWxlbWVudCNfX3pyXG4gICAgICAgICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9aUmVuZGVyfVxuICAgICAgICAgKi9cbiAgICAgICAgX196cjogbnVsbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5Zu+5b2i5piv5ZCm5b+955Wl77yM5Li6dHJ1ZeaXtuW/veeVpeWbvuW9oueahOe7mOWItuS7peWPiuS6i+S7tuinpuWPkVxuICAgICAgICAgKiBJZiBpZ25vcmUgZHJhd2luZyBhbmQgZXZlbnRzIG9mIHRoZSBlbGVtZW50IG9iamVjdFxuICAgICAgICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvRWxlbWVudCNpZ25vcmVcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBpZ25vcmU6IGZhbHNlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDnlKjkuo7oo4HliarnmoTot6/lvoQoc2hhcGUp77yM5omA5pyJIEdyb3VwIOWGheeahOi3r+W+hOWcqOe7mOWItuaXtumDveS8muiiq+i/meS4qui3r+W+hOijgeWJqlxuICAgICAgICAgKiDor6Xot6/lvoTkvJrnu6fmib/ooqvoo4Hlh4/lr7nosaHnmoTlj5jmjaJcbiAgICAgICAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2dyYXBoaWMvUGF0aH1cbiAgICAgICAgICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi8yZGNvbnRleHQvI2NsaXBwaW5nLXJlZ2lvblxuICAgICAgICAgKiBAcmVhZE9ubHlcbiAgICAgICAgICovXG4gICAgICAgIGNsaXBQYXRoOiBudWxsLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEcmlmdCBlbGVtZW50XG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gZHggZHggb24gdGhlIGdsb2JhbCBzcGFjZVxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IGR5IGR5IG9uIHRoZSBnbG9iYWwgc3BhY2VcbiAgICAgICAgICovXG4gICAgICAgIGRyaWZ0OiBmdW5jdGlvbiAoZHgsIGR5KSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuZHJhZ2dhYmxlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnaG9yaXpvbnRhbCc6XG4gICAgICAgICAgICAgICAgICAgIGR5ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAndmVydGljYWwnOlxuICAgICAgICAgICAgICAgICAgICBkeCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbSA9IHRoaXMudHJhbnNmb3JtO1xuICAgICAgICAgICAgaWYgKCFtKSB7XG4gICAgICAgICAgICAgICAgbSA9IHRoaXMudHJhbnNmb3JtID0gWzEsIDAsIDAsIDEsIDAsIDBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbVs0XSArPSBkeDtcbiAgICAgICAgICAgIG1bNV0gKz0gZHk7XG5cbiAgICAgICAgICAgIHRoaXMuZGVjb21wb3NlVHJhbnNmb3JtKCk7XG4gICAgICAgICAgICB0aGlzLmRpcnR5KGZhbHNlKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSG9vayBiZWZvcmUgdXBkYXRlXG4gICAgICAgICAqL1xuICAgICAgICBiZWZvcmVVcGRhdGU6IGZ1bmN0aW9uICgpIHt9LFxuICAgICAgICAvKipcbiAgICAgICAgICogSG9vayBhZnRlciB1cGRhdGVcbiAgICAgICAgICovXG4gICAgICAgIGFmdGVyVXBkYXRlOiBmdW5jdGlvbiAoKSB7fSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZSBlYWNoIGZyYW1lXG4gICAgICAgICAqL1xuICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVHJhbnNmb3JtKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYlxuICAgICAgICAgKiBAcGFyYW0gIHt9ICAgY29udGV4dFxuICAgICAgICAgKi9cbiAgICAgICAgdHJhdmVyc2U6IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge30sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGF0dHJLVjogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChrZXkgPT09ICdwb3NpdGlvbicgfHwga2V5ID09PSAnc2NhbGUnIHx8IGtleSA9PT0gJ29yaWdpbicpIHtcbiAgICAgICAgICAgICAgICAvLyBDb3B5IHRoZSBhcnJheVxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpc1trZXldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0ID0gdGhpc1trZXldID0gW107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0WzBdID0gdmFsdWVbMF07XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFsxXSA9IHZhbHVlWzFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIaWRlIHRoZSBlbGVtZW50XG4gICAgICAgICAqL1xuICAgICAgICBoaWRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmlnbm9yZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9fenIgJiYgdGhpcy5fX3pyLnJlZnJlc2goKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2hvdyB0aGUgZWxlbWVudFxuICAgICAgICAgKi9cbiAgICAgICAgc2hvdzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5pZ25vcmUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX196ciAmJiB0aGlzLl9fenIucmVmcmVzaCgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IGtleVxuICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICAgICAqL1xuICAgICAgICBhdHRyOiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hdHRyS1Yoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh6clV0aWwuaXNPYmplY3Qoa2V5KSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIG5hbWUgaW4ga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cktWKG5hbWUsIGtleVtuYW1lXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuZGlydHkoZmFsc2UpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9ncmFwaGljL1BhdGh9IGNsaXBQYXRoXG4gICAgICAgICAqL1xuICAgICAgICBzZXRDbGlwUGF0aDogZnVuY3Rpb24gKGNsaXBQYXRoKSB7XG4gICAgICAgICAgICB2YXIgenIgPSB0aGlzLl9fenI7XG4gICAgICAgICAgICBpZiAoenIpIHtcbiAgICAgICAgICAgICAgICBjbGlwUGF0aC5hZGRTZWxmVG9acih6cik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJlbW92ZSBwcmV2aW91cyBjbGlwIHBhdGhcbiAgICAgICAgICAgIGlmICh0aGlzLmNsaXBQYXRoICYmIHRoaXMuY2xpcFBhdGggIT09IGNsaXBQYXRoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVDbGlwUGF0aCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmNsaXBQYXRoID0gY2xpcFBhdGg7XG4gICAgICAgICAgICBjbGlwUGF0aC5fX3pyID0genI7XG4gICAgICAgICAgICBjbGlwUGF0aC5fX2NsaXBUYXJnZXQgPSB0aGlzO1xuXG4gICAgICAgICAgICB0aGlzLmRpcnR5KGZhbHNlKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICovXG4gICAgICAgIHJlbW92ZUNsaXBQYXRoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY2xpcFBhdGggPSB0aGlzLmNsaXBQYXRoO1xuICAgICAgICAgICAgaWYgKGNsaXBQYXRoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNsaXBQYXRoLl9fenIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xpcFBhdGgucmVtb3ZlU2VsZkZyb21acihjbGlwUGF0aC5fX3pyKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjbGlwUGF0aC5fX3pyID0gbnVsbDtcbiAgICAgICAgICAgICAgICBjbGlwUGF0aC5fX2NsaXBUYXJnZXQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuY2xpcFBhdGggPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5kaXJ0eShmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZCBzZWxmIGZyb20genJlbmRlciBpbnN0YW5jZS5cbiAgICAgICAgICogTm90IHJlY3Vyc2l2ZWx5IGJlY2F1c2UgaXQgd2lsbCBiZSBpbnZva2VkIHdoZW4gZWxlbWVudCBhZGRlZCB0byBzdG9yYWdlLlxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL1pSZW5kZXJ9IHpyXG4gICAgICAgICAqL1xuICAgICAgICBhZGRTZWxmVG9acjogZnVuY3Rpb24gKHpyKSB7XG4gICAgICAgICAgICB0aGlzLl9fenIgPSB6cjtcbiAgICAgICAgICAgIC8vIOa3u+WKoOWKqOeUu1xuICAgICAgICAgICAgdmFyIGFuaW1hdG9ycyA9IHRoaXMuYW5pbWF0b3JzO1xuICAgICAgICAgICAgaWYgKGFuaW1hdG9ycykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW5pbWF0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHpyLmFuaW1hdGlvbi5hZGRBbmltYXRvcihhbmltYXRvcnNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuY2xpcFBhdGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsaXBQYXRoLmFkZFNlbGZUb1pyKHpyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3ZlIHNlbGYgZnJvbSB6cmVuZGVyIGluc3RhbmNlLlxuICAgICAgICAgKiBOb3QgcmVjdXJzaXZlbHkgYmVjYXVzZSBpdCB3aWxsIGJlIGludm9rZWQgd2hlbiBlbGVtZW50IGFkZGVkIHRvIHN0b3JhZ2UuXG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvWlJlbmRlcn0genJcbiAgICAgICAgICovXG4gICAgICAgIHJlbW92ZVNlbGZGcm9tWnI6IGZ1bmN0aW9uICh6cikge1xuICAgICAgICAgICAgdGhpcy5fX3pyID0gbnVsbDtcbiAgICAgICAgICAgIC8vIOenu+mZpOWKqOeUu1xuICAgICAgICAgICAgdmFyIGFuaW1hdG9ycyA9IHRoaXMuYW5pbWF0b3JzO1xuICAgICAgICAgICAgaWYgKGFuaW1hdG9ycykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW5pbWF0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHpyLmFuaW1hdGlvbi5yZW1vdmVBbmltYXRvcihhbmltYXRvcnNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuY2xpcFBhdGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsaXBQYXRoLnJlbW92ZVNlbGZGcm9tWnIoenIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIHpyVXRpbC5taXhpbihFbGVtZW50LCBBbmltYXRhYmxlKTtcbiAgICB6clV0aWwubWl4aW4oRWxlbWVudCwgVHJhbnNmb3JtYWJsZSk7XG4gICAgenJVdGlsLm1peGluKEVsZW1lbnQsIEV2ZW50ZnVsKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gRWxlbWVudDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9ob21lL3l4L34venJlbmRlci9saWIvRWxlbWVudC5qc1xuLy8gbW9kdWxlIGlkID0gNTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 58 */
/* unknown exports provided */
/* all exports used */
/*!****************************************************!*\
  !*** /home/yx/~/zrender/lib/animation/Animator.js ***!
  \****************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * @module echarts/animation/Animator\n */\n\n\n    var Clip = __webpack_require__(/*! ./Clip */ 107);\n    var color = __webpack_require__(/*! ../tool/color */ 21);\n    var util = __webpack_require__(/*! ../core/util */ 0);\n    var isArrayLike = util.isArrayLike;\n\n    var arraySlice = Array.prototype.slice;\n\n    function defaultGetter(target, key) {\n        return target[key];\n    }\n\n    function defaultSetter(target, key, value) {\n        target[key] = value;\n    }\n\n    /**\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} percent\n     * @return {number}\n     */\n    function interpolateNumber(p0, p1, percent) {\n        return (p1 - p0) * percent + p0;\n    }\n\n    /**\n     * @param  {string} p0\n     * @param  {string} p1\n     * @param  {number} percent\n     * @return {string}\n     */\n    function interpolateString(p0, p1, percent) {\n        return percent > 0.5 ? p1 : p0;\n    }\n\n    /**\n     * @param  {Array} p0\n     * @param  {Array} p1\n     * @param  {number} percent\n     * @param  {Array} out\n     * @param  {number} arrDim\n     */\n    function interpolateArray(p0, p1, percent, out, arrDim) {\n        var len = p0.length;\n        if (arrDim == 1) {\n            for (var i = 0; i < len; i++) {\n                out[i] = interpolateNumber(p0[i], p1[i], percent);\n            }\n        }\n        else {\n            var len2 = p0[0].length;\n            for (var i = 0; i < len; i++) {\n                for (var j = 0; j < len2; j++) {\n                    out[i][j] = interpolateNumber(\n                        p0[i][j], p1[i][j], percent\n                    );\n                }\n            }\n        }\n    }\n\n    // arr0 is source array, arr1 is target array.\n    // Do some preprocess to avoid error happened when interpolating from arr0 to arr1\n    function fillArr(arr0, arr1, arrDim) {\n        var arr0Len = arr0.length;\n        var arr1Len = arr1.length;\n        if (arr0Len !== arr1Len) {\n            // FIXME Not work for TypedArray\n            var isPreviousLarger = arr0Len > arr1Len;\n            if (isPreviousLarger) {\n                // Cut the previous\n                arr0.length = arr1Len;\n            }\n            else {\n                // Fill the previous\n                for (var i = arr0Len; i < arr1Len; i++) {\n                    arr0.push(\n                        arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i])\n                    );\n                }\n            }\n        }\n        // Handling NaN value\n        var len2 = arr0[0] && arr0[0].length;\n        for (var i = 0; i < arr0.length; i++) {\n            if (arrDim === 1) {\n                if (isNaN(arr0[i])) {\n                    arr0[i] = arr1[i];\n                }\n            }\n            else {\n                for (var j = 0; j < len2; j++) {\n                    if (isNaN(arr0[i][j])) {\n                        arr0[i][j] = arr1[i][j];\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * @param  {Array} arr0\n     * @param  {Array} arr1\n     * @param  {number} arrDim\n     * @return {boolean}\n     */\n    function isArraySame(arr0, arr1, arrDim) {\n        if (arr0 === arr1) {\n            return true;\n        }\n        var len = arr0.length;\n        if (len !== arr1.length) {\n            return false;\n        }\n        if (arrDim === 1) {\n            for (var i = 0; i < len; i++) {\n                if (arr0[i] !== arr1[i]) {\n                    return false;\n                }\n            }\n        }\n        else {\n            var len2 = arr0[0].length;\n            for (var i = 0; i < len; i++) {\n                for (var j = 0; j < len2; j++) {\n                    if (arr0[i][j] !== arr1[i][j]) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Catmull Rom interpolate array\n     * @param  {Array} p0\n     * @param  {Array} p1\n     * @param  {Array} p2\n     * @param  {Array} p3\n     * @param  {number} t\n     * @param  {number} t2\n     * @param  {number} t3\n     * @param  {Array} out\n     * @param  {number} arrDim\n     */\n    function catmullRomInterpolateArray(\n        p0, p1, p2, p3, t, t2, t3, out, arrDim\n    ) {\n        var len = p0.length;\n        if (arrDim == 1) {\n            for (var i = 0; i < len; i++) {\n                out[i] = catmullRomInterpolate(\n                    p0[i], p1[i], p2[i], p3[i], t, t2, t3\n                );\n            }\n        }\n        else {\n            var len2 = p0[0].length;\n            for (var i = 0; i < len; i++) {\n                for (var j = 0; j < len2; j++) {\n                    out[i][j] = catmullRomInterpolate(\n                        p0[i][j], p1[i][j], p2[i][j], p3[i][j],\n                        t, t2, t3\n                    );\n                }\n            }\n        }\n    }\n\n    /**\n     * Catmull Rom interpolate number\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @param  {number} t2\n     * @param  {number} t3\n     * @return {number}\n     */\n    function catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {\n        var v0 = (p2 - p0) * 0.5;\n        var v1 = (p3 - p1) * 0.5;\n        return (2 * (p1 - p2) + v0 + v1) * t3\n                + (-3 * (p1 - p2) - 2 * v0 - v1) * t2\n                + v0 * t + p1;\n    }\n\n    function cloneValue(value) {\n        if (isArrayLike(value)) {\n            var len = value.length;\n            if (isArrayLike(value[0])) {\n                var ret = [];\n                for (var i = 0; i < len; i++) {\n                    ret.push(arraySlice.call(value[i]));\n                }\n                return ret;\n            }\n\n            return arraySlice.call(value);\n        }\n\n        return value;\n    }\n\n    function rgba2String(rgba) {\n        rgba[0] = Math.floor(rgba[0]);\n        rgba[1] = Math.floor(rgba[1]);\n        rgba[2] = Math.floor(rgba[2]);\n\n        return 'rgba(' + rgba.join(',') + ')';\n    }\n\n    function createTrackClip (animator, easing, oneTrackDone, keyframes, propName) {\n        var getter = animator._getter;\n        var setter = animator._setter;\n        var useSpline = easing === 'spline';\n\n        var trackLen = keyframes.length;\n        if (!trackLen) {\n            return;\n        }\n        // Guess data type\n        var firstVal = keyframes[0].value;\n        var isValueArray = isArrayLike(firstVal);\n        var isValueColor = false;\n        var isValueString = false;\n\n        // For vertices morphing\n        var arrDim = (\n                isValueArray\n                && isArrayLike(firstVal[0])\n            )\n            ? 2 : 1;\n        var trackMaxTime;\n        // Sort keyframe as ascending\n        keyframes.sort(function(a, b) {\n            return a.time - b.time;\n        });\n\n        trackMaxTime = keyframes[trackLen - 1].time;\n        // Percents of each keyframe\n        var kfPercents = [];\n        // Value of each keyframe\n        var kfValues = [];\n        var prevValue = keyframes[0].value;\n        var isAllValueEqual = true;\n        for (var i = 0; i < trackLen; i++) {\n            kfPercents.push(keyframes[i].time / trackMaxTime);\n            // Assume value is a color when it is a string\n            var value = keyframes[i].value;\n\n            // Check if value is equal, deep check if value is array\n            if (!((isValueArray && isArraySame(value, prevValue, arrDim))\n                || (!isValueArray && value === prevValue))) {\n                isAllValueEqual = false;\n            }\n            prevValue = value;\n\n            // Try converting a string to a color array\n            if (typeof value == 'string') {\n                var colorArray = color.parse(value);\n                if (colorArray) {\n                    value = colorArray;\n                    isValueColor = true;\n                }\n                else {\n                    isValueString = true;\n                }\n            }\n            kfValues.push(value);\n        }\n        if (isAllValueEqual) {\n            return;\n        }\n\n        var lastValue = kfValues[trackLen - 1];\n        // Polyfill array and NaN value\n        for (var i = 0; i < trackLen - 1; i++) {\n            if (isValueArray) {\n                fillArr(kfValues[i], lastValue, arrDim);\n            }\n            else {\n                if (isNaN(kfValues[i]) && !isNaN(lastValue) && !isValueString && !isValueColor) {\n                    kfValues[i] = lastValue;\n                }\n            }\n        }\n        isValueArray && fillArr(getter(animator._target, propName), lastValue, arrDim);\n\n        // Cache the key of last frame to speed up when\n        // animation playback is sequency\n        var lastFrame = 0;\n        var lastFramePercent = 0;\n        var start;\n        var w;\n        var p0;\n        var p1;\n        var p2;\n        var p3;\n\n        if (isValueColor) {\n            var rgba = [0, 0, 0, 0];\n        }\n\n        var onframe = function (target, percent) {\n            // Find the range keyframes\n            // kf1-----kf2---------current--------kf3\n            // find kf2 and kf3 and do interpolation\n            var frame;\n            // In the easing function like elasticOut, percent may less than 0\n            if (percent < 0) {\n                frame = 0;\n            }\n            else if (percent < lastFramePercent) {\n                // Start from next key\n                // PENDING start from lastFrame ?\n                start = Math.min(lastFrame + 1, trackLen - 1);\n                for (frame = start; frame >= 0; frame--) {\n                    if (kfPercents[frame] <= percent) {\n                        break;\n                    }\n                }\n                // PENDING really need to do this ?\n                frame = Math.min(frame, trackLen - 2);\n            }\n            else {\n                for (frame = lastFrame; frame < trackLen; frame++) {\n                    if (kfPercents[frame] > percent) {\n                        break;\n                    }\n                }\n                frame = Math.min(frame - 1, trackLen - 2);\n            }\n            lastFrame = frame;\n            lastFramePercent = percent;\n\n            var range = (kfPercents[frame + 1] - kfPercents[frame]);\n            if (range === 0) {\n                return;\n            }\n            else {\n                w = (percent - kfPercents[frame]) / range;\n            }\n            if (useSpline) {\n                p1 = kfValues[frame];\n                p0 = kfValues[frame === 0 ? frame : frame - 1];\n                p2 = kfValues[frame > trackLen - 2 ? trackLen - 1 : frame + 1];\n                p3 = kfValues[frame > trackLen - 3 ? trackLen - 1 : frame + 2];\n                if (isValueArray) {\n                    catmullRomInterpolateArray(\n                        p0, p1, p2, p3, w, w * w, w * w * w,\n                        getter(target, propName),\n                        arrDim\n                    );\n                }\n                else {\n                    var value;\n                    if (isValueColor) {\n                        value = catmullRomInterpolateArray(\n                            p0, p1, p2, p3, w, w * w, w * w * w,\n                            rgba, 1\n                        );\n                        value = rgba2String(rgba);\n                    }\n                    else if (isValueString) {\n                        // String is step(0.5)\n                        return interpolateString(p1, p2, w);\n                    }\n                    else {\n                        value = catmullRomInterpolate(\n                            p0, p1, p2, p3, w, w * w, w * w * w\n                        );\n                    }\n                    setter(\n                        target,\n                        propName,\n                        value\n                    );\n                }\n            }\n            else {\n                if (isValueArray) {\n                    interpolateArray(\n                        kfValues[frame], kfValues[frame + 1], w,\n                        getter(target, propName),\n                        arrDim\n                    );\n                }\n                else {\n                    var value;\n                    if (isValueColor) {\n                        interpolateArray(\n                            kfValues[frame], kfValues[frame + 1], w,\n                            rgba, 1\n                        );\n                        value = rgba2String(rgba);\n                    }\n                    else if (isValueString) {\n                        // String is step(0.5)\n                        return interpolateString(kfValues[frame], kfValues[frame + 1], w);\n                    }\n                    else {\n                        value = interpolateNumber(kfValues[frame], kfValues[frame + 1], w);\n                    }\n                    setter(\n                        target,\n                        propName,\n                        value\n                    );\n                }\n            }\n        };\n\n        var clip = new Clip({\n            target: animator._target,\n            life: trackMaxTime,\n            loop: animator._loop,\n            delay: animator._delay,\n            onframe: onframe,\n            ondestroy: oneTrackDone\n        });\n\n        if (easing && easing !== 'spline') {\n            clip.easing = easing;\n        }\n\n        return clip;\n    }\n\n    /**\n     * @alias module:zrender/animation/Animator\n     * @constructor\n     * @param {Object} target\n     * @param {boolean} loop\n     * @param {Function} getter\n     * @param {Function} setter\n     */\n    var Animator = function(target, loop, getter, setter) {\n        this._tracks = {};\n        this._target = target;\n\n        this._loop = loop || false;\n\n        this._getter = getter || defaultGetter;\n        this._setter = setter || defaultSetter;\n\n        this._clipCount = 0;\n\n        this._delay = 0;\n\n        this._doneList = [];\n\n        this._onframeList = [];\n\n        this._clipList = [];\n    };\n\n    Animator.prototype = {\n        /**\n         * 设置动画关键帧\n         * @param  {number} time 关键帧时间，单位是ms\n         * @param  {Object} props 关键帧的属性值，key-value表示\n         * @return {module:zrender/animation/Animator}\n         */\n        when: function(time /* ms */, props) {\n            var tracks = this._tracks;\n            for (var propName in props) {\n                if (!props.hasOwnProperty(propName)) {\n                    continue;\n                }\n\n                if (!tracks[propName]) {\n                    tracks[propName] = [];\n                    // Invalid value\n                    var value = this._getter(this._target, propName);\n                    if (value == null) {\n                        // zrLog('Invalid property ' + propName);\n                        continue;\n                    }\n                    // If time is 0\n                    //  Then props is given initialize value\n                    // Else\n                    //  Initialize value from current prop value\n                    if (time !== 0) {\n                        tracks[propName].push({\n                            time: 0,\n                            value: cloneValue(value)\n                        });\n                    }\n                }\n                tracks[propName].push({\n                    time: time,\n                    value: props[propName]\n                });\n            }\n            return this;\n        },\n        /**\n         * 添加动画每一帧的回调函数\n         * @param  {Function} callback\n         * @return {module:zrender/animation/Animator}\n         */\n        during: function (callback) {\n            this._onframeList.push(callback);\n            return this;\n        },\n\n        pause: function () {\n            for (var i = 0; i < this._clipList.length; i++) {\n                this._clipList[i].pause();\n            }\n            this._paused = true;\n        },\n\n        resume: function () {\n            for (var i = 0; i < this._clipList.length; i++) {\n                this._clipList[i].resume();\n            }\n            this._paused = false;\n        },\n\n        isPaused: function () {\n            return !!this._paused;\n        },\n\n        _doneCallback: function () {\n            // Clear all tracks\n            this._tracks = {};\n            // Clear all clips\n            this._clipList.length = 0;\n\n            var doneList = this._doneList;\n            var len = doneList.length;\n            for (var i = 0; i < len; i++) {\n                doneList[i].call(this);\n            }\n        },\n        /**\n         * 开始执行动画\n         * @param  {string|Function} easing\n         *         动画缓动函数，详见{@link module:zrender/animation/easing}\n         * @return {module:zrender/animation/Animator}\n         */\n        start: function (easing) {\n\n            var self = this;\n            var clipCount = 0;\n\n            var oneTrackDone = function() {\n                clipCount--;\n                if (!clipCount) {\n                    self._doneCallback();\n                }\n            };\n\n            var lastClip;\n            for (var propName in this._tracks) {\n                if (!this._tracks.hasOwnProperty(propName)) {\n                    continue;\n                }\n                var clip = createTrackClip(\n                    this, easing, oneTrackDone,\n                    this._tracks[propName], propName\n                );\n                if (clip) {\n                    this._clipList.push(clip);\n                    clipCount++;\n\n                    // If start after added to animation\n                    if (this.animation) {\n                        this.animation.addClip(clip);\n                    }\n\n                    lastClip = clip;\n                }\n            }\n\n            // Add during callback on the last clip\n            if (lastClip) {\n                var oldOnFrame = lastClip.onframe;\n                lastClip.onframe = function (target, percent) {\n                    oldOnFrame(target, percent);\n\n                    for (var i = 0; i < self._onframeList.length; i++) {\n                        self._onframeList[i](target, percent);\n                    }\n                };\n            }\n\n            if (!clipCount) {\n                this._doneCallback();\n            }\n            return this;\n        },\n        /**\n         * 停止动画\n         * @param {boolean} forwardToLast If move to last frame before stop\n         */\n        stop: function (forwardToLast) {\n            var clipList = this._clipList;\n            var animation = this.animation;\n            for (var i = 0; i < clipList.length; i++) {\n                var clip = clipList[i];\n                if (forwardToLast) {\n                    // Move to last frame before stop\n                    clip.onframe(this._target, 1);\n                }\n                animation && animation.removeClip(clip);\n            }\n            clipList.length = 0;\n        },\n        /**\n         * 设置动画延迟开始的时间\n         * @param  {number} time 单位ms\n         * @return {module:zrender/animation/Animator}\n         */\n        delay: function (time) {\n            this._delay = time;\n            return this;\n        },\n        /**\n         * 添加动画结束的回调\n         * @param  {Function} cb\n         * @return {module:zrender/animation/Animator}\n         */\n        done: function(cb) {\n            if (cb) {\n                this._doneList.push(cb);\n            }\n            return this;\n        },\n\n        /**\n         * @return {Array.<module:zrender/animation/Clip>}\n         */\n        getClips: function () {\n            return this._clipList;\n        }\n    };\n\n    module.exports = Animator;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL2hvbWUveXgvfi96cmVuZGVyL2xpYi9hbmltYXRpb24vQW5pbWF0b3IuanM/OTJhOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgZWNoYXJ0cy9hbmltYXRpb24vQW5pbWF0b3JcbiAqL1xuXG5cbiAgICB2YXIgQ2xpcCA9IHJlcXVpcmUoJy4vQ2xpcCcpO1xuICAgIHZhciBjb2xvciA9IHJlcXVpcmUoJy4uL3Rvb2wvY29sb3InKTtcbiAgICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpO1xuICAgIHZhciBpc0FycmF5TGlrZSA9IHV0aWwuaXNBcnJheUxpa2U7XG5cbiAgICB2YXIgYXJyYXlTbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuICAgIGZ1bmN0aW9uIGRlZmF1bHRHZXR0ZXIodGFyZ2V0LCBrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldFtrZXldO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlZmF1bHRTZXR0ZXIodGFyZ2V0LCBrZXksIHZhbHVlKSB7XG4gICAgICAgIHRhcmdldFtrZXldID0gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHBlcmNlbnRcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgZnVuY3Rpb24gaW50ZXJwb2xhdGVOdW1iZXIocDAsIHAxLCBwZXJjZW50KSB7XG4gICAgICAgIHJldHVybiAocDEgLSBwMCkgKiBwZXJjZW50ICsgcDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBwMFxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gcDFcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHBlcmNlbnRcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICovXG4gICAgZnVuY3Rpb24gaW50ZXJwb2xhdGVTdHJpbmcocDAsIHAxLCBwZXJjZW50KSB7XG4gICAgICAgIHJldHVybiBwZXJjZW50ID4gMC41ID8gcDEgOiBwMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gcDBcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gcDFcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHBlcmNlbnRcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gb3V0XG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBhcnJEaW1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnRlcnBvbGF0ZUFycmF5KHAwLCBwMSwgcGVyY2VudCwgb3V0LCBhcnJEaW0pIHtcbiAgICAgICAgdmFyIGxlbiA9IHAwLmxlbmd0aDtcbiAgICAgICAgaWYgKGFyckRpbSA9PSAxKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgb3V0W2ldID0gaW50ZXJwb2xhdGVOdW1iZXIocDBbaV0sIHAxW2ldLCBwZXJjZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBsZW4yID0gcDBbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGVuMjsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dFtpXVtqXSA9IGludGVycG9sYXRlTnVtYmVyKFxuICAgICAgICAgICAgICAgICAgICAgICAgcDBbaV1bal0sIHAxW2ldW2pdLCBwZXJjZW50XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gYXJyMCBpcyBzb3VyY2UgYXJyYXksIGFycjEgaXMgdGFyZ2V0IGFycmF5LlxuICAgIC8vIERvIHNvbWUgcHJlcHJvY2VzcyB0byBhdm9pZCBlcnJvciBoYXBwZW5lZCB3aGVuIGludGVycG9sYXRpbmcgZnJvbSBhcnIwIHRvIGFycjFcbiAgICBmdW5jdGlvbiBmaWxsQXJyKGFycjAsIGFycjEsIGFyckRpbSkge1xuICAgICAgICB2YXIgYXJyMExlbiA9IGFycjAubGVuZ3RoO1xuICAgICAgICB2YXIgYXJyMUxlbiA9IGFycjEubGVuZ3RoO1xuICAgICAgICBpZiAoYXJyMExlbiAhPT0gYXJyMUxlbikge1xuICAgICAgICAgICAgLy8gRklYTUUgTm90IHdvcmsgZm9yIFR5cGVkQXJyYXlcbiAgICAgICAgICAgIHZhciBpc1ByZXZpb3VzTGFyZ2VyID0gYXJyMExlbiA+IGFycjFMZW47XG4gICAgICAgICAgICBpZiAoaXNQcmV2aW91c0xhcmdlcikge1xuICAgICAgICAgICAgICAgIC8vIEN1dCB0aGUgcHJldmlvdXNcbiAgICAgICAgICAgICAgICBhcnIwLmxlbmd0aCA9IGFycjFMZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBGaWxsIHRoZSBwcmV2aW91c1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBhcnIwTGVuOyBpIDwgYXJyMUxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGFycjAucHVzaChcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyckRpbSA9PT0gMSA/IGFycjFbaV0gOiBhcnJheVNsaWNlLmNhbGwoYXJyMVtpXSlcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGFuZGxpbmcgTmFOIHZhbHVlXG4gICAgICAgIHZhciBsZW4yID0gYXJyMFswXSAmJiBhcnIwWzBdLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoYXJyRGltID09PSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzTmFOKGFycjBbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGFycjBbaV0gPSBhcnIxW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGVuMjsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc05hTihhcnIwW2ldW2pdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJyMFtpXVtqXSA9IGFycjFbaV1bal07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gYXJyMFxuICAgICAqIEBwYXJhbSAge0FycmF5fSBhcnIxXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBhcnJEaW1cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzQXJyYXlTYW1lKGFycjAsIGFycjEsIGFyckRpbSkge1xuICAgICAgICBpZiAoYXJyMCA9PT0gYXJyMSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxlbiA9IGFycjAubGVuZ3RoO1xuICAgICAgICBpZiAobGVuICE9PSBhcnIxLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcnJEaW0gPT09IDEpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoYXJyMFtpXSAhPT0gYXJyMVtpXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGxlbjIgPSBhcnIwWzBdLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxlbjI7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXJyMFtpXVtqXSAhPT0gYXJyMVtpXVtqXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhdG11bGwgUm9tIGludGVycG9sYXRlIGFycmF5XG4gICAgICogQHBhcmFtICB7QXJyYXl9IHAwXG4gICAgICogQHBhcmFtICB7QXJyYXl9IHAxXG4gICAgICogQHBhcmFtICB7QXJyYXl9IHAyXG4gICAgICogQHBhcmFtICB7QXJyYXl9IHAzXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSB0XG4gICAgICogQHBhcmFtICB7bnVtYmVyfSB0MlxuICAgICAqIEBwYXJhbSAge251bWJlcn0gdDNcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gb3V0XG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBhcnJEaW1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYXRtdWxsUm9tSW50ZXJwb2xhdGVBcnJheShcbiAgICAgICAgcDAsIHAxLCBwMiwgcDMsIHQsIHQyLCB0Mywgb3V0LCBhcnJEaW1cbiAgICApIHtcbiAgICAgICAgdmFyIGxlbiA9IHAwLmxlbmd0aDtcbiAgICAgICAgaWYgKGFyckRpbSA9PSAxKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgb3V0W2ldID0gY2F0bXVsbFJvbUludGVycG9sYXRlKFxuICAgICAgICAgICAgICAgICAgICBwMFtpXSwgcDFbaV0sIHAyW2ldLCBwM1tpXSwgdCwgdDIsIHQzXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBsZW4yID0gcDBbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGVuMjsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dFtpXVtqXSA9IGNhdG11bGxSb21JbnRlcnBvbGF0ZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHAwW2ldW2pdLCBwMVtpXVtqXSwgcDJbaV1bal0sIHAzW2ldW2pdLFxuICAgICAgICAgICAgICAgICAgICAgICAgdCwgdDIsIHQzXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2F0bXVsbCBSb20gaW50ZXJwb2xhdGUgbnVtYmVyXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAyXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwM1xuICAgICAqIEBwYXJhbSAge251bWJlcn0gdFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gdDJcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHQzXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhdG11bGxSb21JbnRlcnBvbGF0ZShwMCwgcDEsIHAyLCBwMywgdCwgdDIsIHQzKSB7XG4gICAgICAgIHZhciB2MCA9IChwMiAtIHAwKSAqIDAuNTtcbiAgICAgICAgdmFyIHYxID0gKHAzIC0gcDEpICogMC41O1xuICAgICAgICByZXR1cm4gKDIgKiAocDEgLSBwMikgKyB2MCArIHYxKSAqIHQzXG4gICAgICAgICAgICAgICAgKyAoLTMgKiAocDEgLSBwMikgLSAyICogdjAgLSB2MSkgKiB0MlxuICAgICAgICAgICAgICAgICsgdjAgKiB0ICsgcDE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xvbmVWYWx1ZSh2YWx1ZSkge1xuICAgICAgICBpZiAoaXNBcnJheUxpa2UodmFsdWUpKSB7XG4gICAgICAgICAgICB2YXIgbGVuID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGlzQXJyYXlMaWtlKHZhbHVlWzBdKSkge1xuICAgICAgICAgICAgICAgIHZhciByZXQgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldC5wdXNoKGFycmF5U2xpY2UuY2FsbCh2YWx1ZVtpXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gYXJyYXlTbGljZS5jYWxsKHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZ2JhMlN0cmluZyhyZ2JhKSB7XG4gICAgICAgIHJnYmFbMF0gPSBNYXRoLmZsb29yKHJnYmFbMF0pO1xuICAgICAgICByZ2JhWzFdID0gTWF0aC5mbG9vcihyZ2JhWzFdKTtcbiAgICAgICAgcmdiYVsyXSA9IE1hdGguZmxvb3IocmdiYVsyXSk7XG5cbiAgICAgICAgcmV0dXJuICdyZ2JhKCcgKyByZ2JhLmpvaW4oJywnKSArICcpJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVUcmFja0NsaXAgKGFuaW1hdG9yLCBlYXNpbmcsIG9uZVRyYWNrRG9uZSwga2V5ZnJhbWVzLCBwcm9wTmFtZSkge1xuICAgICAgICB2YXIgZ2V0dGVyID0gYW5pbWF0b3IuX2dldHRlcjtcbiAgICAgICAgdmFyIHNldHRlciA9IGFuaW1hdG9yLl9zZXR0ZXI7XG4gICAgICAgIHZhciB1c2VTcGxpbmUgPSBlYXNpbmcgPT09ICdzcGxpbmUnO1xuXG4gICAgICAgIHZhciB0cmFja0xlbiA9IGtleWZyYW1lcy5sZW5ndGg7XG4gICAgICAgIGlmICghdHJhY2tMZW4pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBHdWVzcyBkYXRhIHR5cGVcbiAgICAgICAgdmFyIGZpcnN0VmFsID0ga2V5ZnJhbWVzWzBdLnZhbHVlO1xuICAgICAgICB2YXIgaXNWYWx1ZUFycmF5ID0gaXNBcnJheUxpa2UoZmlyc3RWYWwpO1xuICAgICAgICB2YXIgaXNWYWx1ZUNvbG9yID0gZmFsc2U7XG4gICAgICAgIHZhciBpc1ZhbHVlU3RyaW5nID0gZmFsc2U7XG5cbiAgICAgICAgLy8gRm9yIHZlcnRpY2VzIG1vcnBoaW5nXG4gICAgICAgIHZhciBhcnJEaW0gPSAoXG4gICAgICAgICAgICAgICAgaXNWYWx1ZUFycmF5XG4gICAgICAgICAgICAgICAgJiYgaXNBcnJheUxpa2UoZmlyc3RWYWxbMF0pXG4gICAgICAgICAgICApXG4gICAgICAgICAgICA/IDIgOiAxO1xuICAgICAgICB2YXIgdHJhY2tNYXhUaW1lO1xuICAgICAgICAvLyBTb3J0IGtleWZyYW1lIGFzIGFzY2VuZGluZ1xuICAgICAgICBrZXlmcmFtZXMuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYS50aW1lIC0gYi50aW1lO1xuICAgICAgICB9KTtcblxuICAgICAgICB0cmFja01heFRpbWUgPSBrZXlmcmFtZXNbdHJhY2tMZW4gLSAxXS50aW1lO1xuICAgICAgICAvLyBQZXJjZW50cyBvZiBlYWNoIGtleWZyYW1lXG4gICAgICAgIHZhciBrZlBlcmNlbnRzID0gW107XG4gICAgICAgIC8vIFZhbHVlIG9mIGVhY2gga2V5ZnJhbWVcbiAgICAgICAgdmFyIGtmVmFsdWVzID0gW107XG4gICAgICAgIHZhciBwcmV2VmFsdWUgPSBrZXlmcmFtZXNbMF0udmFsdWU7XG4gICAgICAgIHZhciBpc0FsbFZhbHVlRXF1YWwgPSB0cnVlO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYWNrTGVuOyBpKyspIHtcbiAgICAgICAgICAgIGtmUGVyY2VudHMucHVzaChrZXlmcmFtZXNbaV0udGltZSAvIHRyYWNrTWF4VGltZSk7XG4gICAgICAgICAgICAvLyBBc3N1bWUgdmFsdWUgaXMgYSBjb2xvciB3aGVuIGl0IGlzIGEgc3RyaW5nXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBrZXlmcmFtZXNbaV0udmFsdWU7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHZhbHVlIGlzIGVxdWFsLCBkZWVwIGNoZWNrIGlmIHZhbHVlIGlzIGFycmF5XG4gICAgICAgICAgICBpZiAoISgoaXNWYWx1ZUFycmF5ICYmIGlzQXJyYXlTYW1lKHZhbHVlLCBwcmV2VmFsdWUsIGFyckRpbSkpXG4gICAgICAgICAgICAgICAgfHwgKCFpc1ZhbHVlQXJyYXkgJiYgdmFsdWUgPT09IHByZXZWYWx1ZSkpKSB7XG4gICAgICAgICAgICAgICAgaXNBbGxWYWx1ZUVxdWFsID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2VmFsdWUgPSB2YWx1ZTtcblxuICAgICAgICAgICAgLy8gVHJ5IGNvbnZlcnRpbmcgYSBzdHJpbmcgdG8gYSBjb2xvciBhcnJheVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHZhciBjb2xvckFycmF5ID0gY29sb3IucGFyc2UodmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChjb2xvckFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gY29sb3JBcnJheTtcbiAgICAgICAgICAgICAgICAgICAgaXNWYWx1ZUNvbG9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlzVmFsdWVTdHJpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGtmVmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0FsbFZhbHVlRXF1YWwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsYXN0VmFsdWUgPSBrZlZhbHVlc1t0cmFja0xlbiAtIDFdO1xuICAgICAgICAvLyBQb2x5ZmlsbCBhcnJheSBhbmQgTmFOIHZhbHVlXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhY2tMZW4gLSAxOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpc1ZhbHVlQXJyYXkpIHtcbiAgICAgICAgICAgICAgICBmaWxsQXJyKGtmVmFsdWVzW2ldLCBsYXN0VmFsdWUsIGFyckRpbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNOYU4oa2ZWYWx1ZXNbaV0pICYmICFpc05hTihsYXN0VmFsdWUpICYmICFpc1ZhbHVlU3RyaW5nICYmICFpc1ZhbHVlQ29sb3IpIHtcbiAgICAgICAgICAgICAgICAgICAga2ZWYWx1ZXNbaV0gPSBsYXN0VmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlzVmFsdWVBcnJheSAmJiBmaWxsQXJyKGdldHRlcihhbmltYXRvci5fdGFyZ2V0LCBwcm9wTmFtZSksIGxhc3RWYWx1ZSwgYXJyRGltKTtcblxuICAgICAgICAvLyBDYWNoZSB0aGUga2V5IG9mIGxhc3QgZnJhbWUgdG8gc3BlZWQgdXAgd2hlblxuICAgICAgICAvLyBhbmltYXRpb24gcGxheWJhY2sgaXMgc2VxdWVuY3lcbiAgICAgICAgdmFyIGxhc3RGcmFtZSA9IDA7XG4gICAgICAgIHZhciBsYXN0RnJhbWVQZXJjZW50ID0gMDtcbiAgICAgICAgdmFyIHN0YXJ0O1xuICAgICAgICB2YXIgdztcbiAgICAgICAgdmFyIHAwO1xuICAgICAgICB2YXIgcDE7XG4gICAgICAgIHZhciBwMjtcbiAgICAgICAgdmFyIHAzO1xuXG4gICAgICAgIGlmIChpc1ZhbHVlQ29sb3IpIHtcbiAgICAgICAgICAgIHZhciByZ2JhID0gWzAsIDAsIDAsIDBdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9uZnJhbWUgPSBmdW5jdGlvbiAodGFyZ2V0LCBwZXJjZW50KSB7XG4gICAgICAgICAgICAvLyBGaW5kIHRoZSByYW5nZSBrZXlmcmFtZXNcbiAgICAgICAgICAgIC8vIGtmMS0tLS0ta2YyLS0tLS0tLS0tY3VycmVudC0tLS0tLS0ta2YzXG4gICAgICAgICAgICAvLyBmaW5kIGtmMiBhbmQga2YzIGFuZCBkbyBpbnRlcnBvbGF0aW9uXG4gICAgICAgICAgICB2YXIgZnJhbWU7XG4gICAgICAgICAgICAvLyBJbiB0aGUgZWFzaW5nIGZ1bmN0aW9uIGxpa2UgZWxhc3RpY091dCwgcGVyY2VudCBtYXkgbGVzcyB0aGFuIDBcbiAgICAgICAgICAgIGlmIChwZXJjZW50IDwgMCkge1xuICAgICAgICAgICAgICAgIGZyYW1lID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBlcmNlbnQgPCBsYXN0RnJhbWVQZXJjZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gU3RhcnQgZnJvbSBuZXh0IGtleVxuICAgICAgICAgICAgICAgIC8vIFBFTkRJTkcgc3RhcnQgZnJvbSBsYXN0RnJhbWUgP1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gTWF0aC5taW4obGFzdEZyYW1lICsgMSwgdHJhY2tMZW4gLSAxKTtcbiAgICAgICAgICAgICAgICBmb3IgKGZyYW1lID0gc3RhcnQ7IGZyYW1lID49IDA7IGZyYW1lLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtmUGVyY2VudHNbZnJhbWVdIDw9IHBlcmNlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFBFTkRJTkcgcmVhbGx5IG5lZWQgdG8gZG8gdGhpcyA/XG4gICAgICAgICAgICAgICAgZnJhbWUgPSBNYXRoLm1pbihmcmFtZSwgdHJhY2tMZW4gLSAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAoZnJhbWUgPSBsYXN0RnJhbWU7IGZyYW1lIDwgdHJhY2tMZW47IGZyYW1lKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtmUGVyY2VudHNbZnJhbWVdID4gcGVyY2VudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnJhbWUgPSBNYXRoLm1pbihmcmFtZSAtIDEsIHRyYWNrTGVuIC0gMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXN0RnJhbWUgPSBmcmFtZTtcbiAgICAgICAgICAgIGxhc3RGcmFtZVBlcmNlbnQgPSBwZXJjZW50O1xuXG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSAoa2ZQZXJjZW50c1tmcmFtZSArIDFdIC0ga2ZQZXJjZW50c1tmcmFtZV0pO1xuICAgICAgICAgICAgaWYgKHJhbmdlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdyA9IChwZXJjZW50IC0ga2ZQZXJjZW50c1tmcmFtZV0pIC8gcmFuZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodXNlU3BsaW5lKSB7XG4gICAgICAgICAgICAgICAgcDEgPSBrZlZhbHVlc1tmcmFtZV07XG4gICAgICAgICAgICAgICAgcDAgPSBrZlZhbHVlc1tmcmFtZSA9PT0gMCA/IGZyYW1lIDogZnJhbWUgLSAxXTtcbiAgICAgICAgICAgICAgICBwMiA9IGtmVmFsdWVzW2ZyYW1lID4gdHJhY2tMZW4gLSAyID8gdHJhY2tMZW4gLSAxIDogZnJhbWUgKyAxXTtcbiAgICAgICAgICAgICAgICBwMyA9IGtmVmFsdWVzW2ZyYW1lID4gdHJhY2tMZW4gLSAzID8gdHJhY2tMZW4gLSAxIDogZnJhbWUgKyAyXTtcbiAgICAgICAgICAgICAgICBpZiAoaXNWYWx1ZUFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhdG11bGxSb21JbnRlcnBvbGF0ZUFycmF5KFxuICAgICAgICAgICAgICAgICAgICAgICAgcDAsIHAxLCBwMiwgcDMsIHcsIHcgKiB3LCB3ICogdyAqIHcsXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXR0ZXIodGFyZ2V0LCBwcm9wTmFtZSksXG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJEaW1cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzVmFsdWVDb2xvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBjYXRtdWxsUm9tSW50ZXJwb2xhdGVBcnJheShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwMCwgcDEsIHAyLCBwMywgdywgdyAqIHcsIHcgKiB3ICogdyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZ2JhLCAxXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSByZ2JhMlN0cmluZyhyZ2JhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc1ZhbHVlU3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdHJpbmcgaXMgc3RlcCgwLjUpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJwb2xhdGVTdHJpbmcocDEsIHAyLCB3KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gY2F0bXVsbFJvbUludGVycG9sYXRlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAwLCBwMSwgcDIsIHAzLCB3LCB3ICogdywgdyAqIHcgKiB3XG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNldHRlcihcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNWYWx1ZUFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgIGludGVycG9sYXRlQXJyYXkoXG4gICAgICAgICAgICAgICAgICAgICAgICBrZlZhbHVlc1tmcmFtZV0sIGtmVmFsdWVzW2ZyYW1lICsgMV0sIHcsXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXR0ZXIodGFyZ2V0LCBwcm9wTmFtZSksXG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJEaW1cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzVmFsdWVDb2xvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJwb2xhdGVBcnJheShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZlZhbHVlc1tmcmFtZV0sIGtmVmFsdWVzW2ZyYW1lICsgMV0sIHcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmdiYSwgMVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcmdiYTJTdHJpbmcocmdiYSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNWYWx1ZVN0cmluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3RyaW5nIGlzIHN0ZXAoMC41KVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGludGVycG9sYXRlU3RyaW5nKGtmVmFsdWVzW2ZyYW1lXSwga2ZWYWx1ZXNbZnJhbWUgKyAxXSwgdyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGludGVycG9sYXRlTnVtYmVyKGtmVmFsdWVzW2ZyYW1lXSwga2ZWYWx1ZXNbZnJhbWUgKyAxXSwgdyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2V0dGVyKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcE5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgY2xpcCA9IG5ldyBDbGlwKHtcbiAgICAgICAgICAgIHRhcmdldDogYW5pbWF0b3IuX3RhcmdldCxcbiAgICAgICAgICAgIGxpZmU6IHRyYWNrTWF4VGltZSxcbiAgICAgICAgICAgIGxvb3A6IGFuaW1hdG9yLl9sb29wLFxuICAgICAgICAgICAgZGVsYXk6IGFuaW1hdG9yLl9kZWxheSxcbiAgICAgICAgICAgIG9uZnJhbWU6IG9uZnJhbWUsXG4gICAgICAgICAgICBvbmRlc3Ryb3k6IG9uZVRyYWNrRG9uZVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoZWFzaW5nICYmIGVhc2luZyAhPT0gJ3NwbGluZScpIHtcbiAgICAgICAgICAgIGNsaXAuZWFzaW5nID0gZWFzaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNsaXA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRvclxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGxvb3BcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBnZXR0ZXJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZXR0ZXJcbiAgICAgKi9cbiAgICB2YXIgQW5pbWF0b3IgPSBmdW5jdGlvbih0YXJnZXQsIGxvb3AsIGdldHRlciwgc2V0dGVyKSB7XG4gICAgICAgIHRoaXMuX3RyYWNrcyA9IHt9O1xuICAgICAgICB0aGlzLl90YXJnZXQgPSB0YXJnZXQ7XG5cbiAgICAgICAgdGhpcy5fbG9vcCA9IGxvb3AgfHwgZmFsc2U7XG5cbiAgICAgICAgdGhpcy5fZ2V0dGVyID0gZ2V0dGVyIHx8IGRlZmF1bHRHZXR0ZXI7XG4gICAgICAgIHRoaXMuX3NldHRlciA9IHNldHRlciB8fCBkZWZhdWx0U2V0dGVyO1xuXG4gICAgICAgIHRoaXMuX2NsaXBDb3VudCA9IDA7XG5cbiAgICAgICAgdGhpcy5fZGVsYXkgPSAwO1xuXG4gICAgICAgIHRoaXMuX2RvbmVMaXN0ID0gW107XG5cbiAgICAgICAgdGhpcy5fb25mcmFtZUxpc3QgPSBbXTtcblxuICAgICAgICB0aGlzLl9jbGlwTGlzdCA9IFtdO1xuICAgIH07XG5cbiAgICBBbmltYXRvci5wcm90b3R5cGUgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDorr7nva7liqjnlLvlhbPplK7luKdcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB0aW1lIOWFs+mUruW4p+aXtumXtO+8jOWNleS9jeaYr21zXG4gICAgICAgICAqIEBwYXJhbSAge09iamVjdH0gcHJvcHMg5YWz6ZSu5bin55qE5bGe5oCn5YC877yMa2V5LXZhbHVl6KGo56S6XG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRvcn1cbiAgICAgICAgICovXG4gICAgICAgIHdoZW46IGZ1bmN0aW9uKHRpbWUgLyogbXMgKi8sIHByb3BzKSB7XG4gICAgICAgICAgICB2YXIgdHJhY2tzID0gdGhpcy5fdHJhY2tzO1xuICAgICAgICAgICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gcHJvcHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXByb3BzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIXRyYWNrc1twcm9wTmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhY2tzW3Byb3BOYW1lXSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAvLyBJbnZhbGlkIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX2dldHRlcih0aGlzLl90YXJnZXQsIHByb3BOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHpyTG9nKCdJbnZhbGlkIHByb3BlcnR5ICcgKyBwcm9wTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aW1lIGlzIDBcbiAgICAgICAgICAgICAgICAgICAgLy8gIFRoZW4gcHJvcHMgaXMgZ2l2ZW4gaW5pdGlhbGl6ZSB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAvLyBFbHNlXG4gICAgICAgICAgICAgICAgICAgIC8vICBJbml0aWFsaXplIHZhbHVlIGZyb20gY3VycmVudCBwcm9wIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aW1lICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFja3NbcHJvcE5hbWVdLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWU6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGNsb25lVmFsdWUodmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cmFja3NbcHJvcE5hbWVdLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0aW1lOiB0aW1lLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcHJvcHNbcHJvcE5hbWVdXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOa3u+WKoOWKqOeUu+avj+S4gOW4p+eahOWbnuiwg+WHveaVsFxuICAgICAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdG9yfVxuICAgICAgICAgKi9cbiAgICAgICAgZHVyaW5nOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMuX29uZnJhbWVMaXN0LnB1c2goY2FsbGJhY2spO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcGF1c2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fY2xpcExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jbGlwTGlzdFtpXS5wYXVzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcGF1c2VkID0gdHJ1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICByZXN1bWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fY2xpcExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jbGlwTGlzdFtpXS5yZXN1bWUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuICAgICAgICB9LFxuXG4gICAgICAgIGlzUGF1c2VkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gISF0aGlzLl9wYXVzZWQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2RvbmVDYWxsYmFjazogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gQ2xlYXIgYWxsIHRyYWNrc1xuICAgICAgICAgICAgdGhpcy5fdHJhY2tzID0ge307XG4gICAgICAgICAgICAvLyBDbGVhciBhbGwgY2xpcHNcbiAgICAgICAgICAgIHRoaXMuX2NsaXBMaXN0Lmxlbmd0aCA9IDA7XG5cbiAgICAgICAgICAgIHZhciBkb25lTGlzdCA9IHRoaXMuX2RvbmVMaXN0O1xuICAgICAgICAgICAgdmFyIGxlbiA9IGRvbmVMaXN0Lmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBkb25lTGlzdFtpXS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICog5byA5aeL5omn6KGM5Yqo55S7XG4gICAgICAgICAqIEBwYXJhbSAge3N0cmluZ3xGdW5jdGlvbn0gZWFzaW5nXG4gICAgICAgICAqICAgICAgICAg5Yqo55S757yT5Yqo5Ye95pWw77yM6K+m6KeBe0BsaW5rIG1vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9lYXNpbmd9XG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRvcn1cbiAgICAgICAgICovXG4gICAgICAgIHN0YXJ0OiBmdW5jdGlvbiAoZWFzaW5nKSB7XG5cbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHZhciBjbGlwQ291bnQgPSAwO1xuXG4gICAgICAgICAgICB2YXIgb25lVHJhY2tEb25lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgY2xpcENvdW50LS07XG4gICAgICAgICAgICAgICAgaWYgKCFjbGlwQ291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fZG9uZUNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIGxhc3RDbGlwO1xuICAgICAgICAgICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gdGhpcy5fdHJhY2tzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl90cmFja3MuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgY2xpcCA9IGNyZWF0ZVRyYWNrQ2xpcChcbiAgICAgICAgICAgICAgICAgICAgdGhpcywgZWFzaW5nLCBvbmVUcmFja0RvbmUsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RyYWNrc1twcm9wTmFtZV0sIHByb3BOYW1lXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZiAoY2xpcCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jbGlwTGlzdC5wdXNoKGNsaXApO1xuICAgICAgICAgICAgICAgICAgICBjbGlwQ291bnQrKztcblxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBzdGFydCBhZnRlciBhZGRlZCB0byBhbmltYXRpb25cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYW5pbWF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFuaW1hdGlvbi5hZGRDbGlwKGNsaXApO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgbGFzdENsaXAgPSBjbGlwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQWRkIGR1cmluZyBjYWxsYmFjayBvbiB0aGUgbGFzdCBjbGlwXG4gICAgICAgICAgICBpZiAobGFzdENsaXApIHtcbiAgICAgICAgICAgICAgICB2YXIgb2xkT25GcmFtZSA9IGxhc3RDbGlwLm9uZnJhbWU7XG4gICAgICAgICAgICAgICAgbGFzdENsaXAub25mcmFtZSA9IGZ1bmN0aW9uICh0YXJnZXQsIHBlcmNlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgb2xkT25GcmFtZSh0YXJnZXQsIHBlcmNlbnQpO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZi5fb25mcmFtZUxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX29uZnJhbWVMaXN0W2ldKHRhcmdldCwgcGVyY2VudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWNsaXBDb3VudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RvbmVDYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlgZzmraLliqjnlLtcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBmb3J3YXJkVG9MYXN0IElmIG1vdmUgdG8gbGFzdCBmcmFtZSBiZWZvcmUgc3RvcFxuICAgICAgICAgKi9cbiAgICAgICAgc3RvcDogZnVuY3Rpb24gKGZvcndhcmRUb0xhc3QpIHtcbiAgICAgICAgICAgIHZhciBjbGlwTGlzdCA9IHRoaXMuX2NsaXBMaXN0O1xuICAgICAgICAgICAgdmFyIGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGlwTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBjbGlwID0gY2xpcExpc3RbaV07XG4gICAgICAgICAgICAgICAgaWYgKGZvcndhcmRUb0xhc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTW92ZSB0byBsYXN0IGZyYW1lIGJlZm9yZSBzdG9wXG4gICAgICAgICAgICAgICAgICAgIGNsaXAub25mcmFtZSh0aGlzLl90YXJnZXQsIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhbmltYXRpb24gJiYgYW5pbWF0aW9uLnJlbW92ZUNsaXAoY2xpcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbGlwTGlzdC5sZW5ndGggPSAwO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICog6K6+572u5Yqo55S75bu26L+f5byA5aeL55qE5pe26Ze0XG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gdGltZSDljZXkvY1tc1xuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0b3J9XG4gICAgICAgICAqL1xuICAgICAgICBkZWxheTogZnVuY3Rpb24gKHRpbWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2RlbGF5ID0gdGltZTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICog5re75Yqg5Yqo55S757uT5p2f55qE5Zue6LCDXG4gICAgICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYlxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0b3J9XG4gICAgICAgICAqL1xuICAgICAgICBkb25lOiBmdW5jdGlvbihjYikge1xuICAgICAgICAgICAgaWYgKGNiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZG9uZUxpc3QucHVzaChjYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7QXJyYXkuPG1vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9DbGlwPn1cbiAgICAgICAgICovXG4gICAgICAgIGdldENsaXBzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2xpcExpc3Q7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBBbmltYXRvcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9ob21lL3l4L34venJlbmRlci9saWIvYW5pbWF0aW9uL0FuaW1hdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSA1OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 59 */
/* unknown exports provided */
/* all exports used */
/*!*****************************************************************!*\
  !*** /home/yx/~/zrender/lib/animation/requestAnimationFrame.js ***!
  \*****************************************************************/
/***/ (function(module, exports) {

eval("\n\n    module.exports = (typeof window !== 'undefined' &&\n                                    (window.requestAnimationFrame\n                                    || window.msRequestAnimationFrame\n                                    || window.mozRequestAnimationFrame\n                                    || window.webkitRequestAnimationFrame))\n                                || function (func) {\n                                    setTimeout(func, 16);\n                                };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL2hvbWUveXgvfi96cmVuZGVyL2xpYi9hbmltYXRpb24vcmVxdWVzdEFuaW1hdGlvbkZyYW1lLmpzPzBiYTYiXSwic291cmNlc0NvbnRlbnQiOlsiXG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IHdpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmMsIDE2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2hvbWUveXgvfi96cmVuZGVyL2xpYi9hbmltYXRpb24vcmVxdWVzdEFuaW1hdGlvbkZyYW1lLmpzXG4vLyBtb2R1bGUgaWQgPSA1OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 60 */
/* unknown exports provided */
/* all exports used */
/*!**********************************************!*\
  !*** /home/yx/~/zrender/lib/contain/util.js ***!
  \**********************************************/
/***/ (function(module, exports) {

eval("\n\n    var PI2 = Math.PI * 2;\n    module.exports = {\n        normalizeRadian: function(angle) {\n            angle %= PI2;\n            if (angle < 0) {\n                angle += PI2;\n            }\n            return angle;\n        }\n    };\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL2hvbWUveXgvfi96cmVuZGVyL2xpYi9jb250YWluL3V0aWwuanM/MDMyYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcblxuICAgIHZhciBQSTIgPSBNYXRoLlBJICogMjtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgbm9ybWFsaXplUmFkaWFuOiBmdW5jdGlvbihhbmdsZSkge1xuICAgICAgICAgICAgYW5nbGUgJT0gUEkyO1xuICAgICAgICAgICAgaWYgKGFuZ2xlIDwgMCkge1xuICAgICAgICAgICAgICAgIGFuZ2xlICs9IFBJMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhbmdsZTtcbiAgICAgICAgfVxuICAgIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS95eC9+L3pyZW5kZXIvbGliL2NvbnRhaW4vdXRpbC5qc1xuLy8gbW9kdWxlIGlkID0gNjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 61 */
/* unknown exports provided */
/* all exports used */
/*!******************************************!*\
  !*** /home/yx/~/zrender/lib/core/LRU.js ***!
  \******************************************/
/***/ (function(module, exports) {

eval("// Simple LRU cache use doubly linked list\n// @module zrender/core/LRU\n\n\n    /**\n     * Simple double linked list. Compared with array, it has O(1) remove operation.\n     * @constructor\n     */\n    var LinkedList = function () {\n\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.head = null;\n\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.tail = null;\n\n        this._len = 0;\n    };\n\n    var linkedListProto = LinkedList.prototype;\n    /**\n     * Insert a new value at the tail\n     * @param  {} val\n     * @return {module:zrender/core/LRU~Entry}\n     */\n    linkedListProto.insert = function (val) {\n        var entry = new Entry(val);\n        this.insertEntry(entry);\n        return entry;\n    };\n\n    /**\n     * Insert an entry at the tail\n     * @param  {module:zrender/core/LRU~Entry} entry\n     */\n    linkedListProto.insertEntry = function (entry) {\n        if (!this.head) {\n            this.head = this.tail = entry;\n        }\n        else {\n            this.tail.next = entry;\n            entry.prev = this.tail;\n            entry.next = null;\n            this.tail = entry;\n        }\n        this._len++;\n    };\n\n    /**\n     * Remove entry.\n     * @param  {module:zrender/core/LRU~Entry} entry\n     */\n    linkedListProto.remove = function (entry) {\n        var prev = entry.prev;\n        var next = entry.next;\n        if (prev) {\n            prev.next = next;\n        }\n        else {\n            // Is head\n            this.head = next;\n        }\n        if (next) {\n            next.prev = prev;\n        }\n        else {\n            // Is tail\n            this.tail = prev;\n        }\n        entry.next = entry.prev = null;\n        this._len--;\n    };\n\n    /**\n     * @return {number}\n     */\n    linkedListProto.len = function () {\n        return this._len;\n    };\n\n    /**\n     * Clear list\n     */\n    linkedListProto.clear = function () {\n        this.head = this.tail = null;\n        this._len = 0;\n    };\n\n    /**\n     * @constructor\n     * @param {} val\n     */\n    var Entry = function (val) {\n        /**\n         * @type {}\n         */\n        this.value = val;\n\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.next;\n\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.prev;\n    };\n\n    /**\n     * LRU Cache\n     * @constructor\n     * @alias module:zrender/core/LRU\n     */\n    var LRU = function (maxSize) {\n\n        this._list = new LinkedList();\n\n        this._map = {};\n\n        this._maxSize = maxSize || 10;\n\n        this._lastRemovedEntry = null;\n    };\n\n    var LRUProto = LRU.prototype;\n\n    /**\n     * @param  {string} key\n     * @param  {} value\n     * @return {} Removed value\n     */\n    LRUProto.put = function (key, value) {\n        var list = this._list;\n        var map = this._map;\n        var removed = null;\n        if (map[key] == null) {\n            var len = list.len();\n            // Reuse last removed entry\n            var entry = this._lastRemovedEntry;\n\n            if (len >= this._maxSize && len > 0) {\n                // Remove the least recently used\n                var leastUsedEntry = list.head;\n                list.remove(leastUsedEntry);\n                delete map[leastUsedEntry.key];\n\n                removed = leastUsedEntry.value;\n                this._lastRemovedEntry = leastUsedEntry;\n            }\n\n            if (entry) {\n                entry.value = value;\n            }\n            else {\n                entry = new Entry(value);\n            }\n            entry.key = key;\n            list.insertEntry(entry);\n            map[key] = entry;\n        }\n\n        return removed;\n    };\n\n    /**\n     * @param  {string} key\n     * @return {}\n     */\n    LRUProto.get = function (key) {\n        var entry = this._map[key];\n        var list = this._list;\n        if (entry != null) {\n            // Put the latest used entry in the tail\n            if (entry !== list.tail) {\n                list.remove(entry);\n                list.insertEntry(entry);\n            }\n\n            return entry.value;\n        }\n    };\n\n    /**\n     * Clear the cache\n     */\n    LRUProto.clear = function () {\n        this._list.clear();\n        this._map = {};\n    };\n\n    module.exports = LRU;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL2hvbWUveXgvfi96cmVuZGVyL2xpYi9jb3JlL0xSVS5qcz85ZjMyIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFNpbXBsZSBMUlUgY2FjaGUgdXNlIGRvdWJseSBsaW5rZWQgbGlzdFxuLy8gQG1vZHVsZSB6cmVuZGVyL2NvcmUvTFJVXG5cblxuICAgIC8qKlxuICAgICAqIFNpbXBsZSBkb3VibGUgbGlua2VkIGxpc3QuIENvbXBhcmVkIHdpdGggYXJyYXksIGl0IGhhcyBPKDEpIHJlbW92ZSBvcGVyYXRpb24uXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgdmFyIExpbmtlZExpc3QgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9jb3JlL0xSVX5FbnRyeX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaGVhZCA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9jb3JlL0xSVX5FbnRyeX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudGFpbCA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5fbGVuID0gMDtcbiAgICB9O1xuXG4gICAgdmFyIGxpbmtlZExpc3RQcm90byA9IExpbmtlZExpc3QucHJvdG90eXBlO1xuICAgIC8qKlxuICAgICAqIEluc2VydCBhIG5ldyB2YWx1ZSBhdCB0aGUgdGFpbFxuICAgICAqIEBwYXJhbSAge30gdmFsXG4gICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9MUlV+RW50cnl9XG4gICAgICovXG4gICAgbGlua2VkTGlzdFByb3RvLmluc2VydCA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gbmV3IEVudHJ5KHZhbCk7XG4gICAgICAgIHRoaXMuaW5zZXJ0RW50cnkoZW50cnkpO1xuICAgICAgICByZXR1cm4gZW50cnk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEluc2VydCBhbiBlbnRyeSBhdCB0aGUgdGFpbFxuICAgICAqIEBwYXJhbSAge21vZHVsZTp6cmVuZGVyL2NvcmUvTFJVfkVudHJ5fSBlbnRyeVxuICAgICAqL1xuICAgIGxpbmtlZExpc3RQcm90by5pbnNlcnRFbnRyeSA9IGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICBpZiAoIXRoaXMuaGVhZCkge1xuICAgICAgICAgICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gZW50cnk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnRhaWwubmV4dCA9IGVudHJ5O1xuICAgICAgICAgICAgZW50cnkucHJldiA9IHRoaXMudGFpbDtcbiAgICAgICAgICAgIGVudHJ5Lm5leHQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy50YWlsID0gZW50cnk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbGVuKys7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBlbnRyeS5cbiAgICAgKiBAcGFyYW0gIHttb2R1bGU6enJlbmRlci9jb3JlL0xSVX5FbnRyeX0gZW50cnlcbiAgICAgKi9cbiAgICBsaW5rZWRMaXN0UHJvdG8ucmVtb3ZlID0gZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgIHZhciBwcmV2ID0gZW50cnkucHJldjtcbiAgICAgICAgdmFyIG5leHQgPSBlbnRyeS5uZXh0O1xuICAgICAgICBpZiAocHJldikge1xuICAgICAgICAgICAgcHJldi5uZXh0ID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIElzIGhlYWRcbiAgICAgICAgICAgIHRoaXMuaGVhZCA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5leHQpIHtcbiAgICAgICAgICAgIG5leHQucHJldiA9IHByZXY7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBJcyB0YWlsXG4gICAgICAgICAgICB0aGlzLnRhaWwgPSBwcmV2O1xuICAgICAgICB9XG4gICAgICAgIGVudHJ5Lm5leHQgPSBlbnRyeS5wcmV2ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbGVuLS07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBsaW5rZWRMaXN0UHJvdG8ubGVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGVuO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDbGVhciBsaXN0XG4gICAgICovXG4gICAgbGlua2VkTGlzdFByb3RvLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO1xuICAgICAgICB0aGlzLl9sZW4gPSAwO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge30gdmFsXG4gICAgICovXG4gICAgdmFyIEVudHJ5ID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9jb3JlL0xSVX5FbnRyeX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubmV4dDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2NvcmUvTFJVfkVudHJ5fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wcmV2O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBMUlUgQ2FjaGVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvY29yZS9MUlVcbiAgICAgKi9cbiAgICB2YXIgTFJVID0gZnVuY3Rpb24gKG1heFNpemUpIHtcblxuICAgICAgICB0aGlzLl9saXN0ID0gbmV3IExpbmtlZExpc3QoKTtcblxuICAgICAgICB0aGlzLl9tYXAgPSB7fTtcblxuICAgICAgICB0aGlzLl9tYXhTaXplID0gbWF4U2l6ZSB8fCAxMDtcblxuICAgICAgICB0aGlzLl9sYXN0UmVtb3ZlZEVudHJ5ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgdmFyIExSVVByb3RvID0gTFJVLnByb3RvdHlwZTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSAge3N0cmluZ30ga2V5XG4gICAgICogQHBhcmFtICB7fSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge30gUmVtb3ZlZCB2YWx1ZVxuICAgICAqL1xuICAgIExSVVByb3RvLnB1dCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgIHZhciBsaXN0ID0gdGhpcy5fbGlzdDtcbiAgICAgICAgdmFyIG1hcCA9IHRoaXMuX21hcDtcbiAgICAgICAgdmFyIHJlbW92ZWQgPSBudWxsO1xuICAgICAgICBpZiAobWFwW2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGxlbiA9IGxpc3QubGVuKCk7XG4gICAgICAgICAgICAvLyBSZXVzZSBsYXN0IHJlbW92ZWQgZW50cnlcbiAgICAgICAgICAgIHZhciBlbnRyeSA9IHRoaXMuX2xhc3RSZW1vdmVkRW50cnk7XG5cbiAgICAgICAgICAgIGlmIChsZW4gPj0gdGhpcy5fbWF4U2l6ZSAmJiBsZW4gPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBsZWFzdCByZWNlbnRseSB1c2VkXG4gICAgICAgICAgICAgICAgdmFyIGxlYXN0VXNlZEVudHJ5ID0gbGlzdC5oZWFkO1xuICAgICAgICAgICAgICAgIGxpc3QucmVtb3ZlKGxlYXN0VXNlZEVudHJ5KTtcbiAgICAgICAgICAgICAgICBkZWxldGUgbWFwW2xlYXN0VXNlZEVudHJ5LmtleV07XG5cbiAgICAgICAgICAgICAgICByZW1vdmVkID0gbGVhc3RVc2VkRW50cnkudmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGFzdFJlbW92ZWRFbnRyeSA9IGxlYXN0VXNlZEVudHJ5O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICAgICAgICBlbnRyeS52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZW50cnkgPSBuZXcgRW50cnkodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZW50cnkua2V5ID0ga2V5O1xuICAgICAgICAgICAgbGlzdC5pbnNlcnRFbnRyeShlbnRyeSk7XG4gICAgICAgICAgICBtYXBba2V5XSA9IGVudHJ5O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlbW92ZWQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSAge3N0cmluZ30ga2V5XG4gICAgICogQHJldHVybiB7fVxuICAgICAqL1xuICAgIExSVVByb3RvLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy5fbWFwW2tleV07XG4gICAgICAgIHZhciBsaXN0ID0gdGhpcy5fbGlzdDtcbiAgICAgICAgaWYgKGVudHJ5ICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFB1dCB0aGUgbGF0ZXN0IHVzZWQgZW50cnkgaW4gdGhlIHRhaWxcbiAgICAgICAgICAgIGlmIChlbnRyeSAhPT0gbGlzdC50YWlsKSB7XG4gICAgICAgICAgICAgICAgbGlzdC5yZW1vdmUoZW50cnkpO1xuICAgICAgICAgICAgICAgIGxpc3QuaW5zZXJ0RW50cnkoZW50cnkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZW50cnkudmFsdWU7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2xlYXIgdGhlIGNhY2hlXG4gICAgICovXG4gICAgTFJVUHJvdG8uY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2xpc3QuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5fbWFwID0ge307XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gTFJVO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2hvbWUveXgvfi96cmVuZGVyL2xpYi9jb3JlL0xSVS5qc1xuLy8gbW9kdWxlIGlkID0gNjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 62 */
/* unknown exports provided */
/* all exports used */
/*!*******************************************!*\
  !*** /home/yx/~/zrender/lib/core/guid.js ***!
  \*******************************************/
/***/ (function(module, exports) {

eval("/**\n * zrender: 生成唯一id\n *\n * @author errorrik (errorrik@gmail.com)\n */\n\n\n    var idStart = 0x0907;\n\n    module.exports = function () {\n        return idStart++;\n    };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL2hvbWUveXgvfi96cmVuZGVyL2xpYi9jb3JlL2d1aWQuanM/ODUyMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIHpyZW5kZXI6IOeUn+aIkOWUr+S4gGlkXG4gKlxuICogQGF1dGhvciBlcnJvcnJpayAoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cblxuICAgIHZhciBpZFN0YXJ0ID0gMHgwOTA3O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBpZFN0YXJ0Kys7XG4gICAgfTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2hvbWUveXgvfi96cmVuZGVyL2xpYi9jb3JlL2d1aWQuanNcbi8vIG1vZHVsZSBpZCA9IDYyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 63 */
/* unknown exports provided */
/* all exports used */
/*!*************************************************!*\
  !*** /home/yx/~/zrender/lib/graphic/Pattern.js ***!
  \*************************************************/
/***/ (function(module, exports) {

eval("\n\n    var Pattern = function (image, repeat) {\n        // Should do nothing more in this constructor. Because gradient can be\n        // declard by `color: {image: ...}`, where this constructor will not be called.\n\n        this.image = image;\n        this.repeat = repeat;\n\n        // Can be cloned\n        this.type = 'pattern';\n    };\n\n    Pattern.prototype.getCanvasPattern = function (ctx) {\n        return ctx.createPattern(this.image, this.repeat || 'repeat');\n    };\n\n    module.exports = Pattern;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL2hvbWUveXgvfi96cmVuZGVyL2xpYi9ncmFwaGljL1BhdHRlcm4uanM/ZmFiZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcblxuICAgIHZhciBQYXR0ZXJuID0gZnVuY3Rpb24gKGltYWdlLCByZXBlYXQpIHtcbiAgICAgICAgLy8gU2hvdWxkIGRvIG5vdGhpbmcgbW9yZSBpbiB0aGlzIGNvbnN0cnVjdG9yLiBCZWNhdXNlIGdyYWRpZW50IGNhbiBiZVxuICAgICAgICAvLyBkZWNsYXJkIGJ5IGBjb2xvcjoge2ltYWdlOiAuLi59YCwgd2hlcmUgdGhpcyBjb25zdHJ1Y3RvciB3aWxsIG5vdCBiZSBjYWxsZWQuXG5cbiAgICAgICAgdGhpcy5pbWFnZSA9IGltYWdlO1xuICAgICAgICB0aGlzLnJlcGVhdCA9IHJlcGVhdDtcblxuICAgICAgICAvLyBDYW4gYmUgY2xvbmVkXG4gICAgICAgIHRoaXMudHlwZSA9ICdwYXR0ZXJuJztcbiAgICB9O1xuXG4gICAgUGF0dGVybi5wcm90b3R5cGUuZ2V0Q2FudmFzUGF0dGVybiA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgcmV0dXJuIGN0eC5jcmVhdGVQYXR0ZXJuKHRoaXMuaW1hZ2UsIHRoaXMucmVwZWF0IHx8ICdyZXBlYXQnKTtcbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBQYXR0ZXJuO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2hvbWUveXgvfi96cmVuZGVyL2xpYi9ncmFwaGljL1BhdHRlcm4uanNcbi8vIG1vZHVsZSBpZCA9IDYzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 64 */
/* unknown exports provided */
/* all exports used */
/*!***********************************************!*\
  !*** /home/yx/~/zrender/lib/graphic/Style.js ***!
  \***********************************************/
/***/ (function(module, exports) {

eval("/**\n * @module zrender/graphic/Style\n */\n\n\n    var STYLE_COMMON_PROPS = [\n        ['shadowBlur', 0], ['shadowOffsetX', 0], ['shadowOffsetY', 0], ['shadowColor', '#000'],\n        ['lineCap', 'butt'], ['lineJoin', 'miter'], ['miterLimit', 10]\n    ];\n\n    // var SHADOW_PROPS = STYLE_COMMON_PROPS.slice(0, 4);\n    // var LINE_PROPS = STYLE_COMMON_PROPS.slice(4);\n\n    var Style = function (opts) {\n        this.extendFrom(opts);\n    };\n\n    function createLinearGradient(ctx, obj, rect) {\n        var x = obj.x == null ? 0 : obj.x;\n        var x2 = obj.x2 == null ? 1 : obj.x2;\n        var y = obj.y == null ? 0 : obj.y;\n        var y2 = obj.y2 == null ? 0 : obj.y2;\n\n        if (!obj.global) {\n            x = x * rect.width + rect.x;\n            x2 = x2 * rect.width + rect.x;\n            y = y * rect.height + rect.y;\n            y2 = y2 * rect.height + rect.y;\n        }\n\n        var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);\n\n        return canvasGradient;\n    }\n\n    function createRadialGradient(ctx, obj, rect) {\n        var width = rect.width;\n        var height = rect.height;\n        var min = Math.min(width, height);\n\n        var x = obj.x == null ? 0.5 : obj.x;\n        var y = obj.y == null ? 0.5 : obj.y;\n        var r = obj.r == null ? 0.5 : obj.r;\n        if (!obj.global) {\n            x = x * width + rect.x;\n            y = y * height + rect.y;\n            r = r * min;\n        }\n\n        var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);\n\n        return canvasGradient;\n    }\n\n\n    Style.prototype = {\n\n        constructor: Style,\n\n        /**\n         * @type {string}\n         */\n        fill: '#000000',\n\n        /**\n         * @type {string}\n         */\n        stroke: null,\n\n        /**\n         * @type {number}\n         */\n        opacity: 1,\n\n        /**\n         * @type {Array.<number>}\n         */\n        lineDash: null,\n\n        /**\n         * @type {number}\n         */\n        lineDashOffset: 0,\n\n        /**\n         * @type {number}\n         */\n        shadowBlur: 0,\n\n        /**\n         * @type {number}\n         */\n        shadowOffsetX: 0,\n\n        /**\n         * @type {number}\n         */\n        shadowOffsetY: 0,\n\n        /**\n         * @type {number}\n         */\n        lineWidth: 1,\n\n        /**\n         * If stroke ignore scale\n         * @type {Boolean}\n         */\n        strokeNoScale: false,\n\n        // Bounding rect text configuration\n        // Not affected by element transform\n        /**\n         * @type {string}\n         */\n        text: null,\n\n        /**\n         * @type {string}\n         */\n        textFill: '#000',\n\n        /**\n         * @type {string}\n         */\n        textStroke: null,\n\n        /**\n         * 'inside', 'left', 'right', 'top', 'bottom'\n         * [x, y]\n         * @type {string|Array.<number>}\n         * @default 'inside'\n         */\n        textPosition: 'inside',\n\n        /**\n         * [x, y]\n         * @type {Array.<number>}\n         */\n        textOffset: null,\n\n        /**\n         * @type {string}\n         */\n        textBaseline: null,\n\n        /**\n         * @type {string}\n         */\n        textAlign: null,\n\n        /**\n         * @type {string}\n         */\n        textVerticalAlign: null,\n\n        /**\n         * Only useful in Path and Image element\n         * @type {number}\n         */\n        textDistance: 5,\n\n        /**\n         * Only useful in Path and Image element\n         * @type {number}\n         */\n        textShadowBlur: 0,\n\n        /**\n         * Only useful in Path and Image element\n         * @type {number}\n         */\n        textShadowOffsetX: 0,\n\n        /**\n         * Only useful in Path and Image element\n         * @type {number}\n         */\n        textShadowOffsetY: 0,\n\n        /**\n         * If transform text\n         * Only useful in Path and Image element\n         * @type {boolean}\n         */\n        textTransform: false,\n\n        /**\n         * Text rotate around position of Path or Image\n         * Only useful in Path and Image element and textTransform is false.\n         */\n        textRotation: 0,\n\n        /**\n         * @type {string}\n         * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation\n         */\n        blend: null,\n\n        /**\n         * @param {CanvasRenderingContext2D} ctx\n         */\n        bind: function (ctx, el, prevEl) {\n            var style = this;\n            var prevStyle = prevEl && prevEl.style;\n            var firstDraw = !prevStyle;\n\n            for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n                var prop = STYLE_COMMON_PROPS[i];\n                var styleName = prop[0];\n\n                if (firstDraw || style[styleName] !== prevStyle[styleName]) {\n                    // FIXME Invalid property value will cause style leak from previous element.\n                    ctx[styleName] = style[styleName] || prop[1];\n                }\n            }\n\n            if ((firstDraw || style.fill !== prevStyle.fill)) {\n                ctx.fillStyle = style.fill;\n            }\n            if ((firstDraw || style.stroke !== prevStyle.stroke)) {\n                ctx.strokeStyle = style.stroke;\n            }\n            if ((firstDraw || style.opacity !== prevStyle.opacity)) {\n                ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;\n            }\n\n            if ((firstDraw || style.blend !== prevStyle.blend)) {\n                ctx.globalCompositeOperation = style.blend || 'source-over';\n            }\n            if (this.hasStroke()) {\n                var lineWidth = style.lineWidth;\n                ctx.lineWidth = lineWidth / (\n                    (this.strokeNoScale && el && el.getLineScale) ? el.getLineScale() : 1\n                );\n            }\n        },\n\n        hasFill: function () {\n            var fill = this.fill;\n            return fill != null && fill !== 'none';\n        },\n\n        hasStroke: function () {\n            var stroke = this.stroke;\n            return stroke != null && stroke !== 'none' && this.lineWidth > 0;\n        },\n\n        /**\n         * Extend from other style\n         * @param {zrender/graphic/Style} otherStyle\n         * @param {boolean} overwrite\n         */\n        extendFrom: function (otherStyle, overwrite) {\n            if (otherStyle) {\n                var target = this;\n                for (var name in otherStyle) {\n                    if (otherStyle.hasOwnProperty(name)\n                        && (overwrite || ! target.hasOwnProperty(name))\n                    ) {\n                        target[name] = otherStyle[name];\n                    }\n                }\n            }\n        },\n\n        /**\n         * Batch setting style with a given object\n         * @param {Object|string} obj\n         * @param {*} [obj]\n         */\n        set: function (obj, value) {\n            if (typeof obj === 'string') {\n                this[obj] = value;\n            }\n            else {\n                this.extendFrom(obj, true);\n            }\n        },\n\n        /**\n         * Clone\n         * @return {zrender/graphic/Style} [description]\n         */\n        clone: function () {\n            var newStyle = new this.constructor();\n            newStyle.extendFrom(this, true);\n            return newStyle;\n        },\n\n        getGradient: function (ctx, obj, rect) {\n            var method = obj.type === 'radial' ? createRadialGradient : createLinearGradient;\n            var canvasGradient = method(ctx, obj, rect);\n            var colorStops = obj.colorStops;\n            for (var i = 0; i < colorStops.length; i++) {\n                canvasGradient.addColorStop(\n                    colorStops[i].offset, colorStops[i].color\n                );\n            }\n            return canvasGradient;\n        }\n    };\n\n    var styleProto = Style.prototype;\n    for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n        var prop = STYLE_COMMON_PROPS[i];\n        if (!(prop[0] in styleProto)) {\n            styleProto[prop[0]] = prop[1];\n        }\n    }\n\n    // Provide for others\n    Style.getGradient = styleProto.getGradient;\n\n    module.exports = Style;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL2hvbWUveXgvfi96cmVuZGVyL2xpYi9ncmFwaGljL1N0eWxlLmpzPzk2YmIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9kdWxlIHpyZW5kZXIvZ3JhcGhpYy9TdHlsZVxuICovXG5cblxuICAgIHZhciBTVFlMRV9DT01NT05fUFJPUFMgPSBbXG4gICAgICAgIFsnc2hhZG93Qmx1cicsIDBdLCBbJ3NoYWRvd09mZnNldFgnLCAwXSwgWydzaGFkb3dPZmZzZXRZJywgMF0sIFsnc2hhZG93Q29sb3InLCAnIzAwMCddLFxuICAgICAgICBbJ2xpbmVDYXAnLCAnYnV0dCddLCBbJ2xpbmVKb2luJywgJ21pdGVyJ10sIFsnbWl0ZXJMaW1pdCcsIDEwXVxuICAgIF07XG5cbiAgICAvLyB2YXIgU0hBRE9XX1BST1BTID0gU1RZTEVfQ09NTU9OX1BST1BTLnNsaWNlKDAsIDQpO1xuICAgIC8vIHZhciBMSU5FX1BST1BTID0gU1RZTEVfQ09NTU9OX1BST1BTLnNsaWNlKDQpO1xuXG4gICAgdmFyIFN0eWxlID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgICAgICAgdGhpcy5leHRlbmRGcm9tKG9wdHMpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVMaW5lYXJHcmFkaWVudChjdHgsIG9iaiwgcmVjdCkge1xuICAgICAgICB2YXIgeCA9IG9iai54ID09IG51bGwgPyAwIDogb2JqLng7XG4gICAgICAgIHZhciB4MiA9IG9iai54MiA9PSBudWxsID8gMSA6IG9iai54MjtcbiAgICAgICAgdmFyIHkgPSBvYmoueSA9PSBudWxsID8gMCA6IG9iai55O1xuICAgICAgICB2YXIgeTIgPSBvYmoueTIgPT0gbnVsbCA/IDAgOiBvYmoueTI7XG5cbiAgICAgICAgaWYgKCFvYmouZ2xvYmFsKSB7XG4gICAgICAgICAgICB4ID0geCAqIHJlY3Qud2lkdGggKyByZWN0Lng7XG4gICAgICAgICAgICB4MiA9IHgyICogcmVjdC53aWR0aCArIHJlY3QueDtcbiAgICAgICAgICAgIHkgPSB5ICogcmVjdC5oZWlnaHQgKyByZWN0Lnk7XG4gICAgICAgICAgICB5MiA9IHkyICogcmVjdC5oZWlnaHQgKyByZWN0Lnk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2FudmFzR3JhZGllbnQgPSBjdHguY3JlYXRlTGluZWFyR3JhZGllbnQoeCwgeSwgeDIsIHkyKTtcblxuICAgICAgICByZXR1cm4gY2FudmFzR3JhZGllbnQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlUmFkaWFsR3JhZGllbnQoY3R4LCBvYmosIHJlY3QpIHtcbiAgICAgICAgdmFyIHdpZHRoID0gcmVjdC53aWR0aDtcbiAgICAgICAgdmFyIGhlaWdodCA9IHJlY3QuaGVpZ2h0O1xuICAgICAgICB2YXIgbWluID0gTWF0aC5taW4od2lkdGgsIGhlaWdodCk7XG5cbiAgICAgICAgdmFyIHggPSBvYmoueCA9PSBudWxsID8gMC41IDogb2JqLng7XG4gICAgICAgIHZhciB5ID0gb2JqLnkgPT0gbnVsbCA/IDAuNSA6IG9iai55O1xuICAgICAgICB2YXIgciA9IG9iai5yID09IG51bGwgPyAwLjUgOiBvYmoucjtcbiAgICAgICAgaWYgKCFvYmouZ2xvYmFsKSB7XG4gICAgICAgICAgICB4ID0geCAqIHdpZHRoICsgcmVjdC54O1xuICAgICAgICAgICAgeSA9IHkgKiBoZWlnaHQgKyByZWN0Lnk7XG4gICAgICAgICAgICByID0gciAqIG1pbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjYW52YXNHcmFkaWVudCA9IGN0eC5jcmVhdGVSYWRpYWxHcmFkaWVudCh4LCB5LCAwLCB4LCB5LCByKTtcblxuICAgICAgICByZXR1cm4gY2FudmFzR3JhZGllbnQ7XG4gICAgfVxuXG5cbiAgICBTdHlsZS5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IFN0eWxlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgZmlsbDogJyMwMDAwMDAnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgc3Ryb2tlOiBudWxsLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgb3BhY2l0eTogMSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICAgICAgICAgKi9cbiAgICAgICAgbGluZURhc2g6IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBsaW5lRGFzaE9mZnNldDogMCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHNoYWRvd0JsdXI6IDAsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBzaGFkb3dPZmZzZXRYOiAwLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgc2hhZG93T2Zmc2V0WTogMCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIGxpbmVXaWR0aDogMSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgc3Ryb2tlIGlnbm9yZSBzY2FsZVxuICAgICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHN0cm9rZU5vU2NhbGU6IGZhbHNlLFxuXG4gICAgICAgIC8vIEJvdW5kaW5nIHJlY3QgdGV4dCBjb25maWd1cmF0aW9uXG4gICAgICAgIC8vIE5vdCBhZmZlY3RlZCBieSBlbGVtZW50IHRyYW5zZm9ybVxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRleHQ6IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0ZXh0RmlsbDogJyMwMDAnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGV4dFN0cm9rZTogbnVsbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogJ2luc2lkZScsICdsZWZ0JywgJ3JpZ2h0JywgJ3RvcCcsICdib3R0b20nXG4gICAgICAgICAqIFt4LCB5XVxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfEFycmF5LjxudW1iZXI+fVxuICAgICAgICAgKiBAZGVmYXVsdCAnaW5zaWRlJ1xuICAgICAgICAgKi9cbiAgICAgICAgdGV4dFBvc2l0aW9uOiAnaW5zaWRlJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogW3gsIHldXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICAgICAgICovXG4gICAgICAgIHRleHRPZmZzZXQ6IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0ZXh0QmFzZWxpbmU6IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0ZXh0QWxpZ246IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0ZXh0VmVydGljYWxBbGlnbjogbnVsbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogT25seSB1c2VmdWwgaW4gUGF0aCBhbmQgSW1hZ2UgZWxlbWVudFxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGV4dERpc3RhbmNlOiA1LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPbmx5IHVzZWZ1bCBpbiBQYXRoIGFuZCBJbWFnZSBlbGVtZW50XG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0ZXh0U2hhZG93Qmx1cjogMCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogT25seSB1c2VmdWwgaW4gUGF0aCBhbmQgSW1hZ2UgZWxlbWVudFxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGV4dFNoYWRvd09mZnNldFg6IDAsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9ubHkgdXNlZnVsIGluIFBhdGggYW5kIEltYWdlIGVsZW1lbnRcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRleHRTaGFkb3dPZmZzZXRZOiAwLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0cmFuc2Zvcm0gdGV4dFxuICAgICAgICAgKiBPbmx5IHVzZWZ1bCBpbiBQYXRoIGFuZCBJbWFnZSBlbGVtZW50XG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGV4dFRyYW5zZm9ybTogZmFsc2UsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRleHQgcm90YXRlIGFyb3VuZCBwb3NpdGlvbiBvZiBQYXRoIG9yIEltYWdlXG4gICAgICAgICAqIE9ubHkgdXNlZnVsIGluIFBhdGggYW5kIEltYWdlIGVsZW1lbnQgYW5kIHRleHRUcmFuc2Zvcm0gaXMgZmFsc2UuXG4gICAgICAgICAqL1xuICAgICAgICB0ZXh0Um90YXRpb246IDAsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBibGVuZDogbnVsbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAgICAgKi9cbiAgICAgICAgYmluZDogZnVuY3Rpb24gKGN0eCwgZWwsIHByZXZFbCkge1xuICAgICAgICAgICAgdmFyIHN0eWxlID0gdGhpcztcbiAgICAgICAgICAgIHZhciBwcmV2U3R5bGUgPSBwcmV2RWwgJiYgcHJldkVsLnN0eWxlO1xuICAgICAgICAgICAgdmFyIGZpcnN0RHJhdyA9ICFwcmV2U3R5bGU7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgU1RZTEVfQ09NTU9OX1BST1BTLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByb3AgPSBTVFlMRV9DT01NT05fUFJPUFNbaV07XG4gICAgICAgICAgICAgICAgdmFyIHN0eWxlTmFtZSA9IHByb3BbMF07XG5cbiAgICAgICAgICAgICAgICBpZiAoZmlyc3REcmF3IHx8IHN0eWxlW3N0eWxlTmFtZV0gIT09IHByZXZTdHlsZVtzdHlsZU5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZJWE1FIEludmFsaWQgcHJvcGVydHkgdmFsdWUgd2lsbCBjYXVzZSBzdHlsZSBsZWFrIGZyb20gcHJldmlvdXMgZWxlbWVudC5cbiAgICAgICAgICAgICAgICAgICAgY3R4W3N0eWxlTmFtZV0gPSBzdHlsZVtzdHlsZU5hbWVdIHx8IHByb3BbMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoKGZpcnN0RHJhdyB8fCBzdHlsZS5maWxsICE9PSBwcmV2U3R5bGUuZmlsbCkpIHtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gc3R5bGUuZmlsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoZmlyc3REcmF3IHx8IHN0eWxlLnN0cm9rZSAhPT0gcHJldlN0eWxlLnN0cm9rZSkpIHtcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHlsZS5zdHJva2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKGZpcnN0RHJhdyB8fCBzdHlsZS5vcGFjaXR5ICE9PSBwcmV2U3R5bGUub3BhY2l0eSkpIHtcbiAgICAgICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSBzdHlsZS5vcGFjaXR5ID09IG51bGwgPyAxIDogc3R5bGUub3BhY2l0eTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKChmaXJzdERyYXcgfHwgc3R5bGUuYmxlbmQgIT09IHByZXZTdHlsZS5ibGVuZCkpIHtcbiAgICAgICAgICAgICAgICBjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gc3R5bGUuYmxlbmQgfHwgJ3NvdXJjZS1vdmVyJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmhhc1N0cm9rZSgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxpbmVXaWR0aCA9IHN0eWxlLmxpbmVXaWR0aDtcbiAgICAgICAgICAgICAgICBjdHgubGluZVdpZHRoID0gbGluZVdpZHRoIC8gKFxuICAgICAgICAgICAgICAgICAgICAodGhpcy5zdHJva2VOb1NjYWxlICYmIGVsICYmIGVsLmdldExpbmVTY2FsZSkgPyBlbC5nZXRMaW5lU2NhbGUoKSA6IDFcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGhhc0ZpbGw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBmaWxsID0gdGhpcy5maWxsO1xuICAgICAgICAgICAgcmV0dXJuIGZpbGwgIT0gbnVsbCAmJiBmaWxsICE9PSAnbm9uZSc7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFzU3Ryb2tlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc3Ryb2tlID0gdGhpcy5zdHJva2U7XG4gICAgICAgICAgICByZXR1cm4gc3Ryb2tlICE9IG51bGwgJiYgc3Ryb2tlICE9PSAnbm9uZScgJiYgdGhpcy5saW5lV2lkdGggPiAwO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFeHRlbmQgZnJvbSBvdGhlciBzdHlsZVxuICAgICAgICAgKiBAcGFyYW0ge3pyZW5kZXIvZ3JhcGhpYy9TdHlsZX0gb3RoZXJTdHlsZVxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG92ZXJ3cml0ZVxuICAgICAgICAgKi9cbiAgICAgICAgZXh0ZW5kRnJvbTogZnVuY3Rpb24gKG90aGVyU3R5bGUsIG92ZXJ3cml0ZSkge1xuICAgICAgICAgICAgaWYgKG90aGVyU3R5bGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcztcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBuYW1lIGluIG90aGVyU3R5bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG90aGVyU3R5bGUuaGFzT3duUHJvcGVydHkobmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIChvdmVyd3JpdGUgfHwgISB0YXJnZXQuaGFzT3duUHJvcGVydHkobmFtZSkpXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W25hbWVdID0gb3RoZXJTdHlsZVtuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQmF0Y2ggc2V0dGluZyBzdHlsZSB3aXRoIGEgZ2l2ZW4gb2JqZWN0XG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fHN0cmluZ30gb2JqXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29ial1cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKG9iaiwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRoaXNbb2JqXSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5leHRlbmRGcm9tKG9iaiwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENsb25lXG4gICAgICAgICAqIEByZXR1cm4ge3pyZW5kZXIvZ3JhcGhpYy9TdHlsZX0gW2Rlc2NyaXB0aW9uXVxuICAgICAgICAgKi9cbiAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBuZXdTdHlsZSA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKCk7XG4gICAgICAgICAgICBuZXdTdHlsZS5leHRlbmRGcm9tKHRoaXMsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIG5ld1N0eWxlO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldEdyYWRpZW50OiBmdW5jdGlvbiAoY3R4LCBvYmosIHJlY3QpIHtcbiAgICAgICAgICAgIHZhciBtZXRob2QgPSBvYmoudHlwZSA9PT0gJ3JhZGlhbCcgPyBjcmVhdGVSYWRpYWxHcmFkaWVudCA6IGNyZWF0ZUxpbmVhckdyYWRpZW50O1xuICAgICAgICAgICAgdmFyIGNhbnZhc0dyYWRpZW50ID0gbWV0aG9kKGN0eCwgb2JqLCByZWN0KTtcbiAgICAgICAgICAgIHZhciBjb2xvclN0b3BzID0gb2JqLmNvbG9yU3RvcHM7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbG9yU3RvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjYW52YXNHcmFkaWVudC5hZGRDb2xvclN0b3AoXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yU3RvcHNbaV0ub2Zmc2V0LCBjb2xvclN0b3BzW2ldLmNvbG9yXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjYW52YXNHcmFkaWVudDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgc3R5bGVQcm90byA9IFN0eWxlLnByb3RvdHlwZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IFNUWUxFX0NPTU1PTl9QUk9QUy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcHJvcCA9IFNUWUxFX0NPTU1PTl9QUk9QU1tpXTtcbiAgICAgICAgaWYgKCEocHJvcFswXSBpbiBzdHlsZVByb3RvKSkge1xuICAgICAgICAgICAgc3R5bGVQcm90b1twcm9wWzBdXSA9IHByb3BbMV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBQcm92aWRlIGZvciBvdGhlcnNcbiAgICBTdHlsZS5nZXRHcmFkaWVudCA9IHN0eWxlUHJvdG8uZ2V0R3JhZGllbnQ7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFN0eWxlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2hvbWUveXgvfi96cmVuZGVyL2xpYi9ncmFwaGljL1N0eWxlLmpzXG4vLyBtb2R1bGUgaWQgPSA2NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 65 */
/* unknown exports provided */
/* all exports used */
/*!*****************************************************!*\
  !*** /home/yx/~/zrender/lib/graphic/helper/poly.js ***!
  \*****************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var smoothSpline = __webpack_require__(/*! ./smoothSpline */ 118);\n    var smoothBezier = __webpack_require__(/*! ./smoothBezier */ 117);\n\n    module.exports = {\n        buildPath: function (ctx, shape, closePath) {\n            var points = shape.points;\n            var smooth = shape.smooth;\n            if (points && points.length >= 2) {\n                if (smooth && smooth !== 'spline') {\n                    var controlPoints = smoothBezier(\n                        points, smooth, closePath, shape.smoothConstraint\n                    );\n\n                    ctx.moveTo(points[0][0], points[0][1]);\n                    var len = points.length;\n                    for (var i = 0; i < (closePath ? len : len - 1); i++) {\n                        var cp1 = controlPoints[i * 2];\n                        var cp2 = controlPoints[i * 2 + 1];\n                        var p = points[(i + 1) % len];\n                        ctx.bezierCurveTo(\n                            cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]\n                        );\n                    }\n                }\n                else {\n                    if (smooth === 'spline') {\n                        points = smoothSpline(points, closePath);\n                    }\n\n                    ctx.moveTo(points[0][0], points[0][1]);\n                    for (var i = 1, l = points.length; i < l; i++) {\n                        ctx.lineTo(points[i][0], points[i][1]);\n                    }\n                }\n\n                closePath && ctx.closePath();\n            }\n        }\n    };\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL2hvbWUveXgvfi96cmVuZGVyL2xpYi9ncmFwaGljL2hlbHBlci9wb2x5LmpzP2UyZGQiXSwic291cmNlc0NvbnRlbnQiOlsiXG5cbiAgICB2YXIgc21vb3RoU3BsaW5lID0gcmVxdWlyZSgnLi9zbW9vdGhTcGxpbmUnKTtcbiAgICB2YXIgc21vb3RoQmV6aWVyID0gcmVxdWlyZSgnLi9zbW9vdGhCZXppZXInKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlLCBjbG9zZVBhdGgpIHtcbiAgICAgICAgICAgIHZhciBwb2ludHMgPSBzaGFwZS5wb2ludHM7XG4gICAgICAgICAgICB2YXIgc21vb3RoID0gc2hhcGUuc21vb3RoO1xuICAgICAgICAgICAgaWYgKHBvaW50cyAmJiBwb2ludHMubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICAgICAgICBpZiAoc21vb3RoICYmIHNtb290aCAhPT0gJ3NwbGluZScpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRyb2xQb2ludHMgPSBzbW9vdGhCZXppZXIoXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMsIHNtb290aCwgY2xvc2VQYXRoLCBzaGFwZS5zbW9vdGhDb25zdHJhaW50XG4gICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyhwb2ludHNbMF1bMF0sIHBvaW50c1swXVsxXSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsZW4gPSBwb2ludHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IChjbG9zZVBhdGggPyBsZW4gOiBsZW4gLSAxKTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3AxID0gY29udHJvbFBvaW50c1tpICogMl07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3AyID0gY29udHJvbFBvaW50c1tpICogMiArIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHAgPSBwb2ludHNbKGkgKyAxKSAlIGxlbl07XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcDFbMF0sIGNwMVsxXSwgY3AyWzBdLCBjcDJbMV0sIHBbMF0sIHBbMV1cbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzbW9vdGggPT09ICdzcGxpbmUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMgPSBzbW9vdGhTcGxpbmUocG9pbnRzLCBjbG9zZVBhdGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyhwb2ludHNbMF1bMF0sIHBvaW50c1swXVsxXSk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxLCBsID0gcG9pbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhwb2ludHNbaV1bMF0sIHBvaW50c1tpXVsxXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjbG9zZVBhdGggJiYgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9ob21lL3l4L34venJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvcG9seS5qc1xuLy8gbW9kdWxlIGlkID0gNjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 66 */
/* unknown exports provided */
/* all exports used */
/*!***************************************!*\
  !*** ./lib/coord/axisModelCreator.js ***!
  \***************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var axisDefault = __webpack_require__(/*! ./axisDefault */ 100);\n    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 0);\n    var ComponentModel = __webpack_require__(/*! ../model/Component */ 12);\n    var layout = __webpack_require__(/*! ../util/layout */ 11);\n\n    // FIXME axisType is fixed ?\n    var AXIS_TYPES = ['value', 'category', 'time', 'log'];\n\n    /**\n     * Generate sub axis model class\n     * @param {string} axisName 'x' 'y' 'radius' 'angle' 'parallel'\n     * @param {module:echarts/model/Component} BaseAxisModelClass\n     * @param {Function} axisTypeDefaulter\n     * @param {Object} [extraDefaultOption]\n     */\n    module.exports = function (axisName, BaseAxisModelClass, axisTypeDefaulter, extraDefaultOption) {\n\n        zrUtil.each(AXIS_TYPES, function (axisType) {\n\n            BaseAxisModelClass.extend({\n\n                type: axisName + 'Axis.' + axisType,\n\n                mergeDefaultAndTheme: function (option, ecModel) {\n                    var layoutMode = this.layoutMode;\n                    var inputPositionParams = layoutMode\n                        ? layout.getLayoutParams(option) : {};\n\n                    var themeModel = ecModel.getTheme();\n                    zrUtil.merge(option, themeModel.get(axisType + 'Axis'));\n                    zrUtil.merge(option, this.getDefaultOption());\n\n                    option.type = axisTypeDefaulter(axisName, option);\n\n                    if (layoutMode) {\n                        layout.mergeLayoutParam(option, inputPositionParams, layoutMode);\n                    }\n                },\n\n                defaultOption: zrUtil.mergeAll(\n                    [\n                        {},\n                        axisDefault[axisType + 'Axis'],\n                        extraDefaultOption\n                    ],\n                    true\n                )\n            });\n        });\n\n        ComponentModel.registerSubTypeDefaulter(\n            axisName + 'Axis',\n            zrUtil.curry(axisTypeDefaulter, axisName)\n        );\n    };\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvY29vcmQvYXhpc01vZGVsQ3JlYXRvci5qcz9iZjNmIl0sInNvdXJjZXNDb250ZW50IjpbIlxuXG4gICAgdmFyIGF4aXNEZWZhdWx0ID0gcmVxdWlyZSgnLi9heGlzRGVmYXVsdCcpO1xuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgQ29tcG9uZW50TW9kZWwgPSByZXF1aXJlKCcuLi9tb2RlbC9Db21wb25lbnQnKTtcbiAgICB2YXIgbGF5b3V0ID0gcmVxdWlyZSgnLi4vdXRpbC9sYXlvdXQnKTtcblxuICAgIC8vIEZJWE1FIGF4aXNUeXBlIGlzIGZpeGVkID9cbiAgICB2YXIgQVhJU19UWVBFUyA9IFsndmFsdWUnLCAnY2F0ZWdvcnknLCAndGltZScsICdsb2cnXTtcblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIHN1YiBheGlzIG1vZGVsIGNsYXNzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGF4aXNOYW1lICd4JyAneScgJ3JhZGl1cycgJ2FuZ2xlJyAncGFyYWxsZWwnXG4gICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Db21wb25lbnR9IEJhc2VBeGlzTW9kZWxDbGFzc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGF4aXNUeXBlRGVmYXVsdGVyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtleHRyYURlZmF1bHRPcHRpb25dXG4gICAgICovXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXhpc05hbWUsIEJhc2VBeGlzTW9kZWxDbGFzcywgYXhpc1R5cGVEZWZhdWx0ZXIsIGV4dHJhRGVmYXVsdE9wdGlvbikge1xuXG4gICAgICAgIHpyVXRpbC5lYWNoKEFYSVNfVFlQRVMsIGZ1bmN0aW9uIChheGlzVHlwZSkge1xuXG4gICAgICAgICAgICBCYXNlQXhpc01vZGVsQ2xhc3MuZXh0ZW5kKHtcblxuICAgICAgICAgICAgICAgIHR5cGU6IGF4aXNOYW1lICsgJ0F4aXMuJyArIGF4aXNUeXBlLFxuXG4gICAgICAgICAgICAgICAgbWVyZ2VEZWZhdWx0QW5kVGhlbWU6IGZ1bmN0aW9uIChvcHRpb24sIGVjTW9kZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxheW91dE1vZGUgPSB0aGlzLmxheW91dE1vZGU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbnB1dFBvc2l0aW9uUGFyYW1zID0gbGF5b3V0TW9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBsYXlvdXQuZ2V0TGF5b3V0UGFyYW1zKG9wdGlvbikgOiB7fTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgdGhlbWVNb2RlbCA9IGVjTW9kZWwuZ2V0VGhlbWUoKTtcbiAgICAgICAgICAgICAgICAgICAgenJVdGlsLm1lcmdlKG9wdGlvbiwgdGhlbWVNb2RlbC5nZXQoYXhpc1R5cGUgKyAnQXhpcycpKTtcbiAgICAgICAgICAgICAgICAgICAgenJVdGlsLm1lcmdlKG9wdGlvbiwgdGhpcy5nZXREZWZhdWx0T3B0aW9uKCkpO1xuXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbi50eXBlID0gYXhpc1R5cGVEZWZhdWx0ZXIoYXhpc05hbWUsIG9wdGlvbik7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGxheW91dE1vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheW91dC5tZXJnZUxheW91dFBhcmFtKG9wdGlvbiwgaW5wdXRQb3NpdGlvblBhcmFtcywgbGF5b3V0TW9kZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgZGVmYXVsdE9wdGlvbjogenJVdGlsLm1lcmdlQWxsKFxuICAgICAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF4aXNEZWZhdWx0W2F4aXNUeXBlICsgJ0F4aXMnXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhRGVmYXVsdE9wdGlvblxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIENvbXBvbmVudE1vZGVsLnJlZ2lzdGVyU3ViVHlwZURlZmF1bHRlcihcbiAgICAgICAgICAgIGF4aXNOYW1lICsgJ0F4aXMnLFxuICAgICAgICAgICAgenJVdGlsLmN1cnJ5KGF4aXNUeXBlRGVmYXVsdGVyLCBheGlzTmFtZSlcbiAgICAgICAgKTtcbiAgICB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvY29vcmQvYXhpc01vZGVsQ3JlYXRvci5qc1xuLy8gbW9kdWxlIGlkID0gNjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 67 */
/* unknown exports provided */
/* all exports used */
/*!******************************************!*\
  !*** ./lib/coord/cartesian/AxisModel.js ***!
  \******************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\n    var ComponentModel = __webpack_require__(/*! ../../model/Component */ 12);\n    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 0);\n    var axisModelCreator = __webpack_require__(/*! ../axisModelCreator */ 66);\n\n    var AxisModel = ComponentModel.extend({\n\n        type: 'cartesian2dAxis',\n\n        /**\n         * @type {module:echarts/coord/cartesian/Axis2D}\n         */\n        axis: null,\n\n        /**\n         * @override\n         */\n        init: function () {\n            AxisModel.superApply(this, 'init', arguments);\n            this.resetRange();\n        },\n\n        /**\n         * @override\n         */\n        mergeOption: function () {\n            AxisModel.superApply(this, 'mergeOption', arguments);\n            this.resetRange();\n        },\n\n        /**\n         * @override\n         */\n        restoreData: function () {\n            AxisModel.superApply(this, 'restoreData', arguments);\n            this.resetRange();\n        },\n\n        /**\n         * @override\n         * @return {module:echarts/model/Component}\n         */\n        getCoordSysModel: function () {\n            return this.ecModel.queryComponents({\n                mainType: 'grid',\n                index: this.option.gridIndex,\n                id: this.option.gridId\n            })[0];\n        }\n\n    });\n\n    function getAxisType(axisDim, option) {\n        // Default axis with data is category axis\n        return option.type || (option.data ? 'category' : 'value');\n    }\n\n    zrUtil.merge(AxisModel.prototype, __webpack_require__(/*! ../axisModelCommonMixin */ 41));\n\n    var extraOption = {\n        // gridIndex: 0,\n        // gridId: '',\n\n        // Offset is for multiple axis on the same position\n        offset: 0\n    };\n\n    axisModelCreator('x', AxisModel, getAxisType, extraOption);\n    axisModelCreator('y', AxisModel, getAxisType, extraOption);\n\n    module.exports = AxisModel;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvY29vcmQvY2FydGVzaWFuL0F4aXNNb2RlbC5qcz84MThmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuXG4gICAgdmFyIENvbXBvbmVudE1vZGVsID0gcmVxdWlyZSgnLi4vLi4vbW9kZWwvQ29tcG9uZW50Jyk7XG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuICAgIHZhciBheGlzTW9kZWxDcmVhdG9yID0gcmVxdWlyZSgnLi4vYXhpc01vZGVsQ3JlYXRvcicpO1xuXG4gICAgdmFyIEF4aXNNb2RlbCA9IENvbXBvbmVudE1vZGVsLmV4dGVuZCh7XG5cbiAgICAgICAgdHlwZTogJ2NhcnRlc2lhbjJkQXhpcycsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHttb2R1bGU6ZWNoYXJ0cy9jb29yZC9jYXJ0ZXNpYW4vQXhpczJEfVxuICAgICAgICAgKi9cbiAgICAgICAgYXhpczogbnVsbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgICAqL1xuICAgICAgICBpbml0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBBeGlzTW9kZWwuc3VwZXJBcHBseSh0aGlzLCAnaW5pdCcsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB0aGlzLnJlc2V0UmFuZ2UoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgICAqL1xuICAgICAgICBtZXJnZU9wdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgQXhpc01vZGVsLnN1cGVyQXBwbHkodGhpcywgJ21lcmdlT3B0aW9uJywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHRoaXMucmVzZXRSYW5nZSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAb3ZlcnJpZGVcbiAgICAgICAgICovXG4gICAgICAgIHJlc3RvcmVEYXRhOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBBeGlzTW9kZWwuc3VwZXJBcHBseSh0aGlzLCAncmVzdG9yZURhdGEnLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgdGhpcy5yZXNldFJhbmdlKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Db21wb25lbnR9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRDb29yZFN5c01vZGVsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lY01vZGVsLnF1ZXJ5Q29tcG9uZW50cyh7XG4gICAgICAgICAgICAgICAgbWFpblR5cGU6ICdncmlkJyxcbiAgICAgICAgICAgICAgICBpbmRleDogdGhpcy5vcHRpb24uZ3JpZEluZGV4LFxuICAgICAgICAgICAgICAgIGlkOiB0aGlzLm9wdGlvbi5ncmlkSWRcbiAgICAgICAgICAgIH0pWzBdO1xuICAgICAgICB9XG5cbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGdldEF4aXNUeXBlKGF4aXNEaW0sIG9wdGlvbikge1xuICAgICAgICAvLyBEZWZhdWx0IGF4aXMgd2l0aCBkYXRhIGlzIGNhdGVnb3J5IGF4aXNcbiAgICAgICAgcmV0dXJuIG9wdGlvbi50eXBlIHx8IChvcHRpb24uZGF0YSA/ICdjYXRlZ29yeScgOiAndmFsdWUnKTtcbiAgICB9XG5cbiAgICB6clV0aWwubWVyZ2UoQXhpc01vZGVsLnByb3RvdHlwZSwgcmVxdWlyZSgnLi4vYXhpc01vZGVsQ29tbW9uTWl4aW4nKSk7XG5cbiAgICB2YXIgZXh0cmFPcHRpb24gPSB7XG4gICAgICAgIC8vIGdyaWRJbmRleDogMCxcbiAgICAgICAgLy8gZ3JpZElkOiAnJyxcblxuICAgICAgICAvLyBPZmZzZXQgaXMgZm9yIG11bHRpcGxlIGF4aXMgb24gdGhlIHNhbWUgcG9zaXRpb25cbiAgICAgICAgb2Zmc2V0OiAwXG4gICAgfTtcblxuICAgIGF4aXNNb2RlbENyZWF0b3IoJ3gnLCBBeGlzTW9kZWwsIGdldEF4aXNUeXBlLCBleHRyYU9wdGlvbik7XG4gICAgYXhpc01vZGVsQ3JlYXRvcigneScsIEF4aXNNb2RlbCwgZ2V0QXhpc1R5cGUsIGV4dHJhT3B0aW9uKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gQXhpc01vZGVsO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvY29vcmQvY2FydGVzaWFuL0F4aXNNb2RlbC5qc1xuLy8gbW9kdWxlIGlkID0gNjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 68 */
/* unknown exports provided */
/* all exports used */
/*!******************************!*\
  !*** ./lib/layout/points.js ***!
  \******************************/
/***/ (function(module, exports) {

eval("\n\n    module.exports = function (seriesType, ecModel) {\n        ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n            var data = seriesModel.getData();\n            var coordSys = seriesModel.coordinateSystem;\n\n            if (coordSys) {\n                var dims = coordSys.dimensions;\n\n                if (dims.length === 1) {\n                    data.each(dims[0], function (x, idx) {\n                        // Also {Array.<number>}, not undefined to avoid if...else... statement\n                        data.setItemLayout(idx, isNaN(x) ? [NaN, NaN] : coordSys.dataToPoint(x));\n                    });\n                }\n                else if (dims.length === 2) {\n                    data.each(dims, function (x, y, idx) {\n                        // Also {Array.<number>}, not undefined to avoid if...else... statement\n                        data.setItemLayout(\n                            idx, (isNaN(x) || isNaN(y)) ? [NaN, NaN] : coordSys.dataToPoint([x, y])\n                        );\n                    }, true);\n                }\n            }\n        });\n    };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvbGF5b3V0L3BvaW50cy5qcz9iNWNkIl0sInNvdXJjZXNDb250ZW50IjpbIlxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc2VyaWVzVHlwZSwgZWNNb2RlbCkge1xuICAgICAgICBlY01vZGVsLmVhY2hTZXJpZXNCeVR5cGUoc2VyaWVzVHlwZSwgZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICAgICAgICAgIHZhciBjb29yZFN5cyA9IHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG5cbiAgICAgICAgICAgIGlmIChjb29yZFN5cykge1xuICAgICAgICAgICAgICAgIHZhciBkaW1zID0gY29vcmRTeXMuZGltZW5zaW9ucztcblxuICAgICAgICAgICAgICAgIGlmIChkaW1zLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhLmVhY2goZGltc1swXSwgZnVuY3Rpb24gKHgsIGlkeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWxzbyB7QXJyYXkuPG51bWJlcj59LCBub3QgdW5kZWZpbmVkIHRvIGF2b2lkIGlmLi4uZWxzZS4uLiBzdGF0ZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuc2V0SXRlbUxheW91dChpZHgsIGlzTmFOKHgpID8gW05hTiwgTmFOXSA6IGNvb3JkU3lzLmRhdGFUb1BvaW50KHgpKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRpbXMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEuZWFjaChkaW1zLCBmdW5jdGlvbiAoeCwgeSwgaWR4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBbHNvIHtBcnJheS48bnVtYmVyPn0sIG5vdCB1bmRlZmluZWQgdG8gYXZvaWQgaWYuLi5lbHNlLi4uIHN0YXRlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5zZXRJdGVtTGF5b3V0KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkeCwgKGlzTmFOKHgpIHx8IGlzTmFOKHkpKSA/IFtOYU4sIE5hTl0gOiBjb29yZFN5cy5kYXRhVG9Qb2ludChbeCwgeV0pXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2xheW91dC9wb2ludHMuanNcbi8vIG1vZHVsZSBpZCA9IDY4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 69 */
/* unknown exports provided */
/* all exports used */
/*!*****************************************!*\
  !*** ./lib/model/mixin/colorPalette.js ***!
  \*****************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var classUtil = __webpack_require__(/*! ../../util/clazz */ 14);\n    var set = classUtil.set;\n    var get = classUtil.get;\n\n    module.exports = {\n        clearColorPalette: function () {\n            set(this, 'colorIdx', 0);\n            set(this, 'colorNameMap', {});\n        },\n\n        getColorFromPalette: function (name, scope) {\n            scope = scope || this;\n            var colorIdx = get(scope, 'colorIdx') || 0;\n            var colorNameMap = get(scope, 'colorNameMap') || set(scope, 'colorNameMap', {});\n            if (colorNameMap[name]) {\n                return colorNameMap[name];\n            }\n            var colorPalette = this.get('color', true) || [];\n            if (!colorPalette.length) {\n                return;\n            }\n\n            var color = colorPalette[colorIdx];\n            if (name) {\n                colorNameMap[name] = color;\n            }\n            set(scope, 'colorIdx', (colorIdx + 1) % colorPalette.length);\n\n            return color;\n        }\n    };\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvbW9kZWwvbWl4aW4vY29sb3JQYWxldHRlLmpzP2VlMDYiXSwic291cmNlc0NvbnRlbnQiOlsiXG5cbiAgICB2YXIgY2xhc3NVdGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9jbGF6eicpO1xuICAgIHZhciBzZXQgPSBjbGFzc1V0aWwuc2V0O1xuICAgIHZhciBnZXQgPSBjbGFzc1V0aWwuZ2V0O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIGNsZWFyQ29sb3JQYWxldHRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzZXQodGhpcywgJ2NvbG9ySWR4JywgMCk7XG4gICAgICAgICAgICBzZXQodGhpcywgJ2NvbG9yTmFtZU1hcCcsIHt9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRDb2xvckZyb21QYWxldHRlOiBmdW5jdGlvbiAobmFtZSwgc2NvcGUpIHtcbiAgICAgICAgICAgIHNjb3BlID0gc2NvcGUgfHwgdGhpcztcbiAgICAgICAgICAgIHZhciBjb2xvcklkeCA9IGdldChzY29wZSwgJ2NvbG9ySWR4JykgfHwgMDtcbiAgICAgICAgICAgIHZhciBjb2xvck5hbWVNYXAgPSBnZXQoc2NvcGUsICdjb2xvck5hbWVNYXAnKSB8fCBzZXQoc2NvcGUsICdjb2xvck5hbWVNYXAnLCB7fSk7XG4gICAgICAgICAgICBpZiAoY29sb3JOYW1lTWFwW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbG9yTmFtZU1hcFtuYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjb2xvclBhbGV0dGUgPSB0aGlzLmdldCgnY29sb3InLCB0cnVlKSB8fCBbXTtcbiAgICAgICAgICAgIGlmICghY29sb3JQYWxldHRlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGNvbG9yID0gY29sb3JQYWxldHRlW2NvbG9ySWR4XTtcbiAgICAgICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgY29sb3JOYW1lTWFwW25hbWVdID0gY29sb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXQoc2NvcGUsICdjb2xvcklkeCcsIChjb2xvcklkeCArIDEpICUgY29sb3JQYWxldHRlLmxlbmd0aCk7XG5cbiAgICAgICAgICAgIHJldHVybiBjb2xvcjtcbiAgICAgICAgfVxuICAgIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9tb2RlbC9taXhpbi9jb2xvclBhbGV0dGUuanNcbi8vIG1vZHVsZSBpZCA9IDY5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 70 */
/* unknown exports provided */
/* all exports used */
/*!*************************************!*\
  !*** ./lib/processor/dataFilter.js ***!
  \*************************************/
/***/ (function(module, exports) {

eval("\n    module.exports = function (seriesType, ecModel) {\n        var legendModels = ecModel.findComponents({\n            mainType: 'legend'\n        });\n        if (!legendModels || !legendModels.length) {\n            return;\n        }\n        ecModel.eachSeriesByType(seriesType, function (series) {\n            var data = series.getData();\n            data.filterSelf(function (idx) {\n                var name = data.getName(idx);\n                // If in any legend component the status is not selected.\n                for (var i = 0; i < legendModels.length; i++) {\n                    if (!legendModels[i].isSelected(name)) {\n                        return false;\n                    }\n                }\n                return true;\n            }, this);\n        }, this);\n    };\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvcHJvY2Vzc29yL2RhdGFGaWx0ZXIuanM/MTkwZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzZXJpZXNUeXBlLCBlY01vZGVsKSB7XG4gICAgICAgIHZhciBsZWdlbmRNb2RlbHMgPSBlY01vZGVsLmZpbmRDb21wb25lbnRzKHtcbiAgICAgICAgICAgIG1haW5UeXBlOiAnbGVnZW5kJ1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFsZWdlbmRNb2RlbHMgfHwgIWxlZ2VuZE1vZGVscy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlY01vZGVsLmVhY2hTZXJpZXNCeVR5cGUoc2VyaWVzVHlwZSwgZnVuY3Rpb24gKHNlcmllcykge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBzZXJpZXMuZ2V0RGF0YSgpO1xuICAgICAgICAgICAgZGF0YS5maWx0ZXJTZWxmKGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IGRhdGEuZ2V0TmFtZShpZHgpO1xuICAgICAgICAgICAgICAgIC8vIElmIGluIGFueSBsZWdlbmQgY29tcG9uZW50IHRoZSBzdGF0dXMgaXMgbm90IHNlbGVjdGVkLlxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVnZW5kTW9kZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbGVnZW5kTW9kZWxzW2ldLmlzU2VsZWN0ZWQobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvcHJvY2Vzc29yL2RhdGFGaWx0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDcwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 71 */
/* unknown exports provided */
/* all exports used */
/*!*****************************!*\
  !*** ./lib/scale/helper.js ***!
  \*****************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * For testable.\n */\n\n\n    var numberUtil = __webpack_require__(/*! ../util/number */ 3);\n\n    var roundNumber = numberUtil.round;\n\n    var helper = {};\n\n    /**\n     * @param {Array.<number>} extent Both extent[0] and extent[1] should be valid number.\n     *                                Should be extent[0] < extent[1].\n     * @param {number} splitNumber splitNumber should be >= 1.\n     * @return {Object} {interval, intervalPrecision, niceTickExtent}\n     */\n    helper.intervalScaleNiceTicks = function (extent, splitNumber) {\n        var result = {};\n        var span = extent[1] - extent[0];\n\n        var interval = result.interval = numberUtil.nice(span / splitNumber, true);\n        // Tow more digital for tick.\n        var precision = result.intervalPrecision = numberUtil.getPrecisionSafe(interval) + 2;\n        // Niced extent inside original extent\n        var niceTickExtent = result.niceTickExtent = [\n            roundNumber(Math.ceil(extent[0] / interval) * interval, precision),\n            roundNumber(Math.floor(extent[1] / interval) * interval, precision)\n        ];\n\n        helper.fixExtent(niceTickExtent, extent);\n\n        return result;\n    };\n\n    function clamp(niceTickExtent, idx, extent) {\n        niceTickExtent[idx] = Math.max(Math.min(niceTickExtent[idx], extent[1]), extent[0]);\n    }\n\n    // In some cases (e.g., splitNumber is 1), niceTickExtent may be out of extent.\n    helper.fixExtent = function (niceTickExtent, extent) {\n        !isFinite(niceTickExtent[0]) && (niceTickExtent[0] = extent[0]);\n        !isFinite(niceTickExtent[1]) && (niceTickExtent[1] = extent[1]);\n        clamp(niceTickExtent, 0, extent);\n        clamp(niceTickExtent, 1, extent);\n        if (niceTickExtent[0] > niceTickExtent[1]) {\n            niceTickExtent[0] = niceTickExtent[1];\n        }\n    };\n\n    helper.intervalScaleGetTicks = function (interval, extent, niceTickExtent, intervalPrecision) {\n        var ticks = [];\n\n        // If interval is 0, return [];\n        if (!interval) {\n            return ticks;\n        }\n\n        // Consider this case: using dataZoom toolbox, zoom and zoom.\n        var safeLimit = 10000;\n\n        if (extent[0] < niceTickExtent[0]) {\n            ticks.push(extent[0]);\n        }\n        var tick = niceTickExtent[0];\n\n        while (tick <= niceTickExtent[1]) {\n            ticks.push(tick);\n            // Avoid rounding error\n            tick = roundNumber(tick + interval, intervalPrecision);\n            if (tick === ticks[ticks.length - 1]) {\n                // Consider out of safe float point, e.g.,\n                // -3711126.9907707 + 2e-10 === -3711126.9907707\n                break;\n            }\n            if (ticks.length > safeLimit) {\n                return [];\n            }\n        }\n        // Consider this case: the last item of ticks is smaller\n        // than niceTickExtent[1] and niceTickExtent[1] === extent[1].\n        if (extent[1] > (ticks.length ? ticks[ticks.length - 1] : niceTickExtent[1])) {\n            ticks.push(extent[1]);\n        }\n\n        return ticks;\n    };\n\n    module.exports = helper;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvc2NhbGUvaGVscGVyLmpzP2RjOWEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBGb3IgdGVzdGFibGUuXG4gKi9cblxuXG4gICAgdmFyIG51bWJlclV0aWwgPSByZXF1aXJlKCcuLi91dGlsL251bWJlcicpO1xuXG4gICAgdmFyIHJvdW5kTnVtYmVyID0gbnVtYmVyVXRpbC5yb3VuZDtcblxuICAgIHZhciBoZWxwZXIgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGV4dGVudCBCb3RoIGV4dGVudFswXSBhbmQgZXh0ZW50WzFdIHNob3VsZCBiZSB2YWxpZCBudW1iZXIuXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNob3VsZCBiZSBleHRlbnRbMF0gPCBleHRlbnRbMV0uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNwbGl0TnVtYmVyIHNwbGl0TnVtYmVyIHNob3VsZCBiZSA+PSAxLlxuICAgICAqIEByZXR1cm4ge09iamVjdH0ge2ludGVydmFsLCBpbnRlcnZhbFByZWNpc2lvbiwgbmljZVRpY2tFeHRlbnR9XG4gICAgICovXG4gICAgaGVscGVyLmludGVydmFsU2NhbGVOaWNlVGlja3MgPSBmdW5jdGlvbiAoZXh0ZW50LCBzcGxpdE51bWJlcikge1xuICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgIHZhciBzcGFuID0gZXh0ZW50WzFdIC0gZXh0ZW50WzBdO1xuXG4gICAgICAgIHZhciBpbnRlcnZhbCA9IHJlc3VsdC5pbnRlcnZhbCA9IG51bWJlclV0aWwubmljZShzcGFuIC8gc3BsaXROdW1iZXIsIHRydWUpO1xuICAgICAgICAvLyBUb3cgbW9yZSBkaWdpdGFsIGZvciB0aWNrLlxuICAgICAgICB2YXIgcHJlY2lzaW9uID0gcmVzdWx0LmludGVydmFsUHJlY2lzaW9uID0gbnVtYmVyVXRpbC5nZXRQcmVjaXNpb25TYWZlKGludGVydmFsKSArIDI7XG4gICAgICAgIC8vIE5pY2VkIGV4dGVudCBpbnNpZGUgb3JpZ2luYWwgZXh0ZW50XG4gICAgICAgIHZhciBuaWNlVGlja0V4dGVudCA9IHJlc3VsdC5uaWNlVGlja0V4dGVudCA9IFtcbiAgICAgICAgICAgIHJvdW5kTnVtYmVyKE1hdGguY2VpbChleHRlbnRbMF0gLyBpbnRlcnZhbCkgKiBpbnRlcnZhbCwgcHJlY2lzaW9uKSxcbiAgICAgICAgICAgIHJvdW5kTnVtYmVyKE1hdGguZmxvb3IoZXh0ZW50WzFdIC8gaW50ZXJ2YWwpICogaW50ZXJ2YWwsIHByZWNpc2lvbilcbiAgICAgICAgXTtcblxuICAgICAgICBoZWxwZXIuZml4RXh0ZW50KG5pY2VUaWNrRXh0ZW50LCBleHRlbnQpO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGNsYW1wKG5pY2VUaWNrRXh0ZW50LCBpZHgsIGV4dGVudCkge1xuICAgICAgICBuaWNlVGlja0V4dGVudFtpZHhdID0gTWF0aC5tYXgoTWF0aC5taW4obmljZVRpY2tFeHRlbnRbaWR4XSwgZXh0ZW50WzFdKSwgZXh0ZW50WzBdKTtcbiAgICB9XG5cbiAgICAvLyBJbiBzb21lIGNhc2VzIChlLmcuLCBzcGxpdE51bWJlciBpcyAxKSwgbmljZVRpY2tFeHRlbnQgbWF5IGJlIG91dCBvZiBleHRlbnQuXG4gICAgaGVscGVyLmZpeEV4dGVudCA9IGZ1bmN0aW9uIChuaWNlVGlja0V4dGVudCwgZXh0ZW50KSB7XG4gICAgICAgICFpc0Zpbml0ZShuaWNlVGlja0V4dGVudFswXSkgJiYgKG5pY2VUaWNrRXh0ZW50WzBdID0gZXh0ZW50WzBdKTtcbiAgICAgICAgIWlzRmluaXRlKG5pY2VUaWNrRXh0ZW50WzFdKSAmJiAobmljZVRpY2tFeHRlbnRbMV0gPSBleHRlbnRbMV0pO1xuICAgICAgICBjbGFtcChuaWNlVGlja0V4dGVudCwgMCwgZXh0ZW50KTtcbiAgICAgICAgY2xhbXAobmljZVRpY2tFeHRlbnQsIDEsIGV4dGVudCk7XG4gICAgICAgIGlmIChuaWNlVGlja0V4dGVudFswXSA+IG5pY2VUaWNrRXh0ZW50WzFdKSB7XG4gICAgICAgICAgICBuaWNlVGlja0V4dGVudFswXSA9IG5pY2VUaWNrRXh0ZW50WzFdO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGhlbHBlci5pbnRlcnZhbFNjYWxlR2V0VGlja3MgPSBmdW5jdGlvbiAoaW50ZXJ2YWwsIGV4dGVudCwgbmljZVRpY2tFeHRlbnQsIGludGVydmFsUHJlY2lzaW9uKSB7XG4gICAgICAgIHZhciB0aWNrcyA9IFtdO1xuXG4gICAgICAgIC8vIElmIGludGVydmFsIGlzIDAsIHJldHVybiBbXTtcbiAgICAgICAgaWYgKCFpbnRlcnZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRpY2tzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29uc2lkZXIgdGhpcyBjYXNlOiB1c2luZyBkYXRhWm9vbSB0b29sYm94LCB6b29tIGFuZCB6b29tLlxuICAgICAgICB2YXIgc2FmZUxpbWl0ID0gMTAwMDA7XG5cbiAgICAgICAgaWYgKGV4dGVudFswXSA8IG5pY2VUaWNrRXh0ZW50WzBdKSB7XG4gICAgICAgICAgICB0aWNrcy5wdXNoKGV4dGVudFswXSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRpY2sgPSBuaWNlVGlja0V4dGVudFswXTtcblxuICAgICAgICB3aGlsZSAodGljayA8PSBuaWNlVGlja0V4dGVudFsxXSkge1xuICAgICAgICAgICAgdGlja3MucHVzaCh0aWNrKTtcbiAgICAgICAgICAgIC8vIEF2b2lkIHJvdW5kaW5nIGVycm9yXG4gICAgICAgICAgICB0aWNrID0gcm91bmROdW1iZXIodGljayArIGludGVydmFsLCBpbnRlcnZhbFByZWNpc2lvbik7XG4gICAgICAgICAgICBpZiAodGljayA9PT0gdGlja3NbdGlja3MubGVuZ3RoIC0gMV0pIHtcbiAgICAgICAgICAgICAgICAvLyBDb25zaWRlciBvdXQgb2Ygc2FmZSBmbG9hdCBwb2ludCwgZS5nLixcbiAgICAgICAgICAgICAgICAvLyAtMzcxMTEyNi45OTA3NzA3ICsgMmUtMTAgPT09IC0zNzExMTI2Ljk5MDc3MDdcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aWNrcy5sZW5ndGggPiBzYWZlTGltaXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29uc2lkZXIgdGhpcyBjYXNlOiB0aGUgbGFzdCBpdGVtIG9mIHRpY2tzIGlzIHNtYWxsZXJcbiAgICAgICAgLy8gdGhhbiBuaWNlVGlja0V4dGVudFsxXSBhbmQgbmljZVRpY2tFeHRlbnRbMV0gPT09IGV4dGVudFsxXS5cbiAgICAgICAgaWYgKGV4dGVudFsxXSA+ICh0aWNrcy5sZW5ndGggPyB0aWNrc1t0aWNrcy5sZW5ndGggLSAxXSA6IG5pY2VUaWNrRXh0ZW50WzFdKSkge1xuICAgICAgICAgICAgdGlja3MucHVzaChleHRlbnRbMV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRpY2tzO1xuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGhlbHBlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL3NjYWxlL2hlbHBlci5qc1xuLy8gbW9kdWxlIGlkID0gNzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 72 */
/* unknown exports provided */
/* all exports used */
/*!*******************************!*\
  !*** ./lib/view/Component.js ***!
  \*******************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var Group = __webpack_require__(/*! zrender/lib/container/Group */ 33);\n    var componentUtil = __webpack_require__(/*! ../util/component */ 49);\n    var clazzUtil = __webpack_require__(/*! ../util/clazz */ 14);\n\n    var Component = function () {\n        /**\n         * @type {module:zrender/container/Group}\n         * @readOnly\n         */\n        this.group = new Group();\n\n        /**\n         * @type {string}\n         * @readOnly\n         */\n        this.uid = componentUtil.getUID('viewComponent');\n    };\n\n    Component.prototype = {\n\n        constructor: Component,\n\n        init: function (ecModel, api) {},\n\n        render: function (componentModel, ecModel, api, payload) {},\n\n        dispose: function () {}\n\n    };\n\n    var componentProto = Component.prototype;\n    componentProto.updateView\n        = componentProto.updateLayout\n        = componentProto.updateVisual\n        = function (seriesModel, ecModel, api, payload) {\n            // Do nothing;\n        };\n    // Enable Component.extend.\n    clazzUtil.enableClassExtend(Component);\n\n    // Enable capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n    clazzUtil.enableClassManagement(Component, {registerWhenExtend: true});\n\n    module.exports = Component;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvdmlldy9Db21wb25lbnQuanM/YTQwNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcblxuICAgIHZhciBHcm91cCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvbnRhaW5lci9Hcm91cCcpO1xuICAgIHZhciBjb21wb25lbnRVdGlsID0gcmVxdWlyZSgnLi4vdXRpbC9jb21wb25lbnQnKTtcbiAgICB2YXIgY2xhenpVdGlsID0gcmVxdWlyZSgnLi4vdXRpbC9jbGF6eicpO1xuXG4gICAgdmFyIENvbXBvbmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9jb250YWluZXIvR3JvdXB9XG4gICAgICAgICAqIEByZWFkT25seVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ncm91cCA9IG5ldyBHcm91cCgpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKiBAcmVhZE9ubHlcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudWlkID0gY29tcG9uZW50VXRpbC5nZXRVSUQoJ3ZpZXdDb21wb25lbnQnKTtcbiAgICB9O1xuXG4gICAgQ29tcG9uZW50LnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogQ29tcG9uZW50LFxuXG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHt9LFxuXG4gICAgICAgIHJlbmRlcjogZnVuY3Rpb24gKGNvbXBvbmVudE1vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpIHt9LFxuXG4gICAgICAgIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHt9XG5cbiAgICB9O1xuXG4gICAgdmFyIGNvbXBvbmVudFByb3RvID0gQ29tcG9uZW50LnByb3RvdHlwZTtcbiAgICBjb21wb25lbnRQcm90by51cGRhdGVWaWV3XG4gICAgICAgID0gY29tcG9uZW50UHJvdG8udXBkYXRlTGF5b3V0XG4gICAgICAgID0gY29tcG9uZW50UHJvdG8udXBkYXRlVmlzdWFsXG4gICAgICAgID0gZnVuY3Rpb24gKHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpIHtcbiAgICAgICAgICAgIC8vIERvIG5vdGhpbmc7XG4gICAgICAgIH07XG4gICAgLy8gRW5hYmxlIENvbXBvbmVudC5leHRlbmQuXG4gICAgY2xhenpVdGlsLmVuYWJsZUNsYXNzRXh0ZW5kKENvbXBvbmVudCk7XG5cbiAgICAvLyBFbmFibGUgY2FwYWJpbGl0eSBvZiByZWdpc3RlckNsYXNzLCBnZXRDbGFzcywgaGFzQ2xhc3MsIHJlZ2lzdGVyU3ViVHlwZURlZmF1bHRlciBhbmQgc28gb24uXG4gICAgY2xhenpVdGlsLmVuYWJsZUNsYXNzTWFuYWdlbWVudChDb21wb25lbnQsIHtyZWdpc3RlcldoZW5FeHRlbmQ6IHRydWV9KTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gQ29tcG9uZW50O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvdmlldy9Db21wb25lbnQuanNcbi8vIG1vZHVsZSBpZCA9IDcyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 73 */
/* unknown exports provided */
/* all exports used */
/*!**************************!*\
  !*** ./lib/chart/bar.js ***!
  \**************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 0);\n\n    __webpack_require__(/*! ../coord/cartesian/Grid */ 56);\n\n    __webpack_require__(/*! ./bar/BarSeries */ 134);\n    __webpack_require__(/*! ./bar/BarView */ 135);\n\n    var barLayoutGrid = __webpack_require__(/*! ../layout/barGrid */ 101);\n    var echarts = __webpack_require__(/*! ../echarts */ 1);\n\n    echarts.registerLayout(zrUtil.curry(barLayoutGrid, 'bar'));\n    // Visual coding for legend\n    echarts.registerVisual(function (ecModel) {\n        ecModel.eachSeriesByType('bar', function (seriesModel) {\n            var data = seriesModel.getData();\n            data.setVisual('legendSymbol', 'roundRect');\n        });\n    });\n\n    // In case developer forget to include grid component\n    __webpack_require__(/*! ../component/gridSimple */ 31);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvY2hhcnQvYmFyLmpzP2E3MjUiXSwic291cmNlc0NvbnRlbnQiOlsiXG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG5cbiAgICByZXF1aXJlKCcuLi9jb29yZC9jYXJ0ZXNpYW4vR3JpZCcpO1xuXG4gICAgcmVxdWlyZSgnLi9iYXIvQmFyU2VyaWVzJyk7XG4gICAgcmVxdWlyZSgnLi9iYXIvQmFyVmlldycpO1xuXG4gICAgdmFyIGJhckxheW91dEdyaWQgPSByZXF1aXJlKCcuLi9sYXlvdXQvYmFyR3JpZCcpO1xuICAgIHZhciBlY2hhcnRzID0gcmVxdWlyZSgnLi4vZWNoYXJ0cycpO1xuXG4gICAgZWNoYXJ0cy5yZWdpc3RlckxheW91dCh6clV0aWwuY3VycnkoYmFyTGF5b3V0R3JpZCwgJ2JhcicpKTtcbiAgICAvLyBWaXN1YWwgY29kaW5nIGZvciBsZWdlbmRcbiAgICBlY2hhcnRzLnJlZ2lzdGVyVmlzdWFsKGZ1bmN0aW9uIChlY01vZGVsKSB7XG4gICAgICAgIGVjTW9kZWwuZWFjaFNlcmllc0J5VHlwZSgnYmFyJywgZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICAgICAgICAgIGRhdGEuc2V0VmlzdWFsKCdsZWdlbmRTeW1ib2wnLCAncm91bmRSZWN0Jyk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLy8gSW4gY2FzZSBkZXZlbG9wZXIgZm9yZ2V0IHRvIGluY2x1ZGUgZ3JpZCBjb21wb25lbnRcbiAgICByZXF1aXJlKCcuLi9jb21wb25lbnQvZ3JpZFNpbXBsZScpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvY2hhcnQvYmFyLmpzXG4vLyBtb2R1bGUgaWQgPSA3M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 74 */
/* unknown exports provided */
/* all exports used */
/*!***************************!*\
  !*** ./lib/chart/line.js ***!
  \***************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 0);\n    var echarts = __webpack_require__(/*! ../echarts */ 1);\n    var PRIORITY = echarts.PRIORITY;\n\n    __webpack_require__(/*! ./line/LineSeries */ 139);\n    __webpack_require__(/*! ./line/LineView */ 140);\n\n    echarts.registerVisual(zrUtil.curry(\n        __webpack_require__(/*! ../visual/symbol */ 50), 'line', 'circle', 'line'\n    ));\n    echarts.registerLayout(zrUtil.curry(\n        __webpack_require__(/*! ../layout/points */ 68), 'line'\n    ));\n\n    // Down sample after filter\n    echarts.registerProcessor(PRIORITY.PROCESSOR.STATISTIC, zrUtil.curry(\n        __webpack_require__(/*! ../processor/dataSample */ 177), 'line'\n    ));\n\n    // In case developer forget to include grid component\n    __webpack_require__(/*! ../component/gridSimple */ 31);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvY2hhcnQvbGluZS5qcz84ZjEwIl0sInNvdXJjZXNDb250ZW50IjpbIlxuXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuICAgIHZhciBlY2hhcnRzID0gcmVxdWlyZSgnLi4vZWNoYXJ0cycpO1xuICAgIHZhciBQUklPUklUWSA9IGVjaGFydHMuUFJJT1JJVFk7XG5cbiAgICByZXF1aXJlKCcuL2xpbmUvTGluZVNlcmllcycpO1xuICAgIHJlcXVpcmUoJy4vbGluZS9MaW5lVmlldycpO1xuXG4gICAgZWNoYXJ0cy5yZWdpc3RlclZpc3VhbCh6clV0aWwuY3VycnkoXG4gICAgICAgIHJlcXVpcmUoJy4uL3Zpc3VhbC9zeW1ib2wnKSwgJ2xpbmUnLCAnY2lyY2xlJywgJ2xpbmUnXG4gICAgKSk7XG4gICAgZWNoYXJ0cy5yZWdpc3RlckxheW91dCh6clV0aWwuY3VycnkoXG4gICAgICAgIHJlcXVpcmUoJy4uL2xheW91dC9wb2ludHMnKSwgJ2xpbmUnXG4gICAgKSk7XG5cbiAgICAvLyBEb3duIHNhbXBsZSBhZnRlciBmaWx0ZXJcbiAgICBlY2hhcnRzLnJlZ2lzdGVyUHJvY2Vzc29yKFBSSU9SSVRZLlBST0NFU1NPUi5TVEFUSVNUSUMsIHpyVXRpbC5jdXJyeShcbiAgICAgICAgcmVxdWlyZSgnLi4vcHJvY2Vzc29yL2RhdGFTYW1wbGUnKSwgJ2xpbmUnXG4gICAgKSk7XG5cbiAgICAvLyBJbiBjYXNlIGRldmVsb3BlciBmb3JnZXQgdG8gaW5jbHVkZSBncmlkIGNvbXBvbmVudFxuICAgIHJlcXVpcmUoJy4uL2NvbXBvbmVudC9ncmlkU2ltcGxlJyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9jaGFydC9saW5lLmpzXG4vLyBtb2R1bGUgaWQgPSA3NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 75 */
/* unknown exports provided */
/* all exports used */
/*!**************************!*\
  !*** ./lib/chart/pie.js ***!
  \**************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 0);\n    var echarts = __webpack_require__(/*! ../echarts */ 1);\n\n    __webpack_require__(/*! ./pie/PieSeries */ 142);\n    __webpack_require__(/*! ./pie/PieView */ 143);\n\n    __webpack_require__(/*! ../action/createDataSelectAction */ 94)('pie', [{\n        type: 'pieToggleSelect',\n        event: 'pieselectchanged',\n        method: 'toggleSelected'\n    }, {\n        type: 'pieSelect',\n        event: 'pieselected',\n        method: 'select'\n    }, {\n        type: 'pieUnSelect',\n        event: 'pieunselected',\n        method: 'unSelect'\n    }]);\n\n    echarts.registerVisual(zrUtil.curry(__webpack_require__(/*! ../visual/dataColor */ 89), 'pie'));\n\n    echarts.registerLayout(zrUtil.curry(\n        __webpack_require__(/*! ./pie/pieLayout */ 145), 'pie'\n    ));\n\n    echarts.registerProcessor(zrUtil.curry(__webpack_require__(/*! ../processor/dataFilter */ 70), 'pie'));\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvY2hhcnQvcGllLmpzP2EwNTAiXSwic291cmNlc0NvbnRlbnQiOlsiXG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG4gICAgdmFyIGVjaGFydHMgPSByZXF1aXJlKCcuLi9lY2hhcnRzJyk7XG5cbiAgICByZXF1aXJlKCcuL3BpZS9QaWVTZXJpZXMnKTtcbiAgICByZXF1aXJlKCcuL3BpZS9QaWVWaWV3Jyk7XG5cbiAgICByZXF1aXJlKCcuLi9hY3Rpb24vY3JlYXRlRGF0YVNlbGVjdEFjdGlvbicpKCdwaWUnLCBbe1xuICAgICAgICB0eXBlOiAncGllVG9nZ2xlU2VsZWN0JyxcbiAgICAgICAgZXZlbnQ6ICdwaWVzZWxlY3RjaGFuZ2VkJyxcbiAgICAgICAgbWV0aG9kOiAndG9nZ2xlU2VsZWN0ZWQnXG4gICAgfSwge1xuICAgICAgICB0eXBlOiAncGllU2VsZWN0JyxcbiAgICAgICAgZXZlbnQ6ICdwaWVzZWxlY3RlZCcsXG4gICAgICAgIG1ldGhvZDogJ3NlbGVjdCdcbiAgICB9LCB7XG4gICAgICAgIHR5cGU6ICdwaWVVblNlbGVjdCcsXG4gICAgICAgIGV2ZW50OiAncGlldW5zZWxlY3RlZCcsXG4gICAgICAgIG1ldGhvZDogJ3VuU2VsZWN0J1xuICAgIH1dKTtcblxuICAgIGVjaGFydHMucmVnaXN0ZXJWaXN1YWwoenJVdGlsLmN1cnJ5KHJlcXVpcmUoJy4uL3Zpc3VhbC9kYXRhQ29sb3InKSwgJ3BpZScpKTtcblxuICAgIGVjaGFydHMucmVnaXN0ZXJMYXlvdXQoenJVdGlsLmN1cnJ5KFxuICAgICAgICByZXF1aXJlKCcuL3BpZS9waWVMYXlvdXQnKSwgJ3BpZSdcbiAgICApKTtcblxuICAgIGVjaGFydHMucmVnaXN0ZXJQcm9jZXNzb3IoenJVdGlsLmN1cnJ5KHJlcXVpcmUoJy4uL3Byb2Nlc3Nvci9kYXRhRmlsdGVyJyksICdwaWUnKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9jaGFydC9waWUuanNcbi8vIG1vZHVsZSBpZCA9IDc1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 76 */
/* unknown exports provided */
/* all exports used */
/*!*******************************************!*\
  !*** /home/yx/~/zrender/lib/core/bbox.js ***!
  \*******************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * @author Yi Shen(https://github.com/pissang)\n */\n\n\n    var vec2 = __webpack_require__(/*! ./vector */ 4);\n    var curve = __webpack_require__(/*! ./curve */ 19);\n\n    var bbox = {};\n    var mathMin = Math.min;\n    var mathMax = Math.max;\n    var mathSin = Math.sin;\n    var mathCos = Math.cos;\n\n    var start = vec2.create();\n    var end = vec2.create();\n    var extremity = vec2.create();\n\n    var PI2 = Math.PI * 2;\n    /**\n     * 从顶点数组中计算出最小包围盒，写入`min`和`max`中\n     * @module zrender/core/bbox\n     * @param {Array<Object>} points 顶点数组\n     * @param {number} min\n     * @param {number} max\n     */\n    bbox.fromPoints = function(points, min, max) {\n        if (points.length === 0) {\n            return;\n        }\n        var p = points[0];\n        var left = p[0];\n        var right = p[0];\n        var top = p[1];\n        var bottom = p[1];\n        var i;\n\n        for (i = 1; i < points.length; i++) {\n            p = points[i];\n            left = mathMin(left, p[0]);\n            right = mathMax(right, p[0]);\n            top = mathMin(top, p[1]);\n            bottom = mathMax(bottom, p[1]);\n        }\n\n        min[0] = left;\n        min[1] = top;\n        max[0] = right;\n        max[1] = bottom;\n    };\n\n    /**\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromLine = function (x0, y0, x1, y1, min, max) {\n        min[0] = mathMin(x0, x1);\n        min[1] = mathMin(y0, y1);\n        max[0] = mathMax(x0, x1);\n        max[1] = mathMax(y0, y1);\n    };\n\n    var xDim = [];\n    var yDim = [];\n    /**\n     * 从三阶贝塞尔曲线(p0, p1, p2, p3)中计算出最小包围盒，写入`min`和`max`中\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {number} x3\n     * @param {number} y3\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromCubic = function(\n        x0, y0, x1, y1, x2, y2, x3, y3, min, max\n    ) {\n        var cubicExtrema = curve.cubicExtrema;\n        var cubicAt = curve.cubicAt;\n        var i;\n        var n = cubicExtrema(x0, x1, x2, x3, xDim);\n        min[0] = Infinity;\n        min[1] = Infinity;\n        max[0] = -Infinity;\n        max[1] = -Infinity;\n\n        for (i = 0; i < n; i++) {\n            var x = cubicAt(x0, x1, x2, x3, xDim[i]);\n            min[0] = mathMin(x, min[0]);\n            max[0] = mathMax(x, max[0]);\n        }\n        n = cubicExtrema(y0, y1, y2, y3, yDim);\n        for (i = 0; i < n; i++) {\n            var y = cubicAt(y0, y1, y2, y3, yDim[i]);\n            min[1] = mathMin(y, min[1]);\n            max[1] = mathMax(y, max[1]);\n        }\n\n        min[0] = mathMin(x0, min[0]);\n        max[0] = mathMax(x0, max[0]);\n        min[0] = mathMin(x3, min[0]);\n        max[0] = mathMax(x3, max[0]);\n\n        min[1] = mathMin(y0, min[1]);\n        max[1] = mathMax(y0, max[1]);\n        min[1] = mathMin(y3, min[1]);\n        max[1] = mathMax(y3, max[1]);\n    };\n\n    /**\n     * 从二阶贝塞尔曲线(p0, p1, p2)中计算出最小包围盒，写入`min`和`max`中\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromQuadratic = function(x0, y0, x1, y1, x2, y2, min, max) {\n        var quadraticExtremum = curve.quadraticExtremum;\n        var quadraticAt = curve.quadraticAt;\n        // Find extremities, where derivative in x dim or y dim is zero\n        var tx =\n            mathMax(\n                mathMin(quadraticExtremum(x0, x1, x2), 1), 0\n            );\n        var ty =\n            mathMax(\n                mathMin(quadraticExtremum(y0, y1, y2), 1), 0\n            );\n\n        var x = quadraticAt(x0, x1, x2, tx);\n        var y = quadraticAt(y0, y1, y2, ty);\n\n        min[0] = mathMin(x0, x2, x);\n        min[1] = mathMin(y0, y2, y);\n        max[0] = mathMax(x0, x2, x);\n        max[1] = mathMax(y0, y2, y);\n    };\n\n    /**\n     * 从圆弧中计算出最小包围盒，写入`min`和`max`中\n     * @method\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x\n     * @param {number} y\n     * @param {number} rx\n     * @param {number} ry\n     * @param {number} startAngle\n     * @param {number} endAngle\n     * @param {number} anticlockwise\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromArc = function (\n        x, y, rx, ry, startAngle, endAngle, anticlockwise, min, max\n    ) {\n        var vec2Min = vec2.min;\n        var vec2Max = vec2.max;\n\n        var diff = Math.abs(startAngle - endAngle);\n\n\n        if (diff % PI2 < 1e-4 && diff > 1e-4) {\n            // Is a circle\n            min[0] = x - rx;\n            min[1] = y - ry;\n            max[0] = x + rx;\n            max[1] = y + ry;\n            return;\n        }\n\n        start[0] = mathCos(startAngle) * rx + x;\n        start[1] = mathSin(startAngle) * ry + y;\n\n        end[0] = mathCos(endAngle) * rx + x;\n        end[1] = mathSin(endAngle) * ry + y;\n\n        vec2Min(min, start, end);\n        vec2Max(max, start, end);\n\n        // Thresh to [0, Math.PI * 2]\n        startAngle = startAngle % (PI2);\n        if (startAngle < 0) {\n            startAngle = startAngle + PI2;\n        }\n        endAngle = endAngle % (PI2);\n        if (endAngle < 0) {\n            endAngle = endAngle + PI2;\n        }\n\n        if (startAngle > endAngle && !anticlockwise) {\n            endAngle += PI2;\n        }\n        else if (startAngle < endAngle && anticlockwise) {\n            startAngle += PI2;\n        }\n        if (anticlockwise) {\n            var tmp = endAngle;\n            endAngle = startAngle;\n            startAngle = tmp;\n        }\n\n        // var number = 0;\n        // var step = (anticlockwise ? -Math.PI : Math.PI) / 2;\n        for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {\n            if (angle > startAngle) {\n                extremity[0] = mathCos(angle) * rx + x;\n                extremity[1] = mathSin(angle) * ry + y;\n\n                vec2Min(min, extremity, min);\n                vec2Max(max, extremity, max);\n            }\n        }\n    };\n\n    module.exports = bbox;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL2hvbWUveXgvfi96cmVuZGVyL2xpYi9jb3JlL2Jib3guanM/NzZlOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBhdXRob3IgWWkgU2hlbihodHRwczovL2dpdGh1Yi5jb20vcGlzc2FuZylcbiAqL1xuXG5cbiAgICB2YXIgdmVjMiA9IHJlcXVpcmUoJy4vdmVjdG9yJyk7XG4gICAgdmFyIGN1cnZlID0gcmVxdWlyZSgnLi9jdXJ2ZScpO1xuXG4gICAgdmFyIGJib3ggPSB7fTtcbiAgICB2YXIgbWF0aE1pbiA9IE1hdGgubWluO1xuICAgIHZhciBtYXRoTWF4ID0gTWF0aC5tYXg7XG4gICAgdmFyIG1hdGhTaW4gPSBNYXRoLnNpbjtcbiAgICB2YXIgbWF0aENvcyA9IE1hdGguY29zO1xuXG4gICAgdmFyIHN0YXJ0ID0gdmVjMi5jcmVhdGUoKTtcbiAgICB2YXIgZW5kID0gdmVjMi5jcmVhdGUoKTtcbiAgICB2YXIgZXh0cmVtaXR5ID0gdmVjMi5jcmVhdGUoKTtcblxuICAgIHZhciBQSTIgPSBNYXRoLlBJICogMjtcbiAgICAvKipcbiAgICAgKiDku47pobbngrnmlbDnu4TkuK3orqHnrpflh7rmnIDlsI/ljIXlm7Tnm5LvvIzlhpnlhaVgbWluYOWSjGBtYXhg5LitXG4gICAgICogQG1vZHVsZSB6cmVuZGVyL2NvcmUvYmJveFxuICAgICAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gcG9pbnRzIOmhtueCueaVsOe7hFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaW5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWF4XG4gICAgICovXG4gICAgYmJveC5mcm9tUG9pbnRzID0gZnVuY3Rpb24ocG9pbnRzLCBtaW4sIG1heCkge1xuICAgICAgICBpZiAocG9pbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwID0gcG9pbnRzWzBdO1xuICAgICAgICB2YXIgbGVmdCA9IHBbMF07XG4gICAgICAgIHZhciByaWdodCA9IHBbMF07XG4gICAgICAgIHZhciB0b3AgPSBwWzFdO1xuICAgICAgICB2YXIgYm90dG9tID0gcFsxXTtcbiAgICAgICAgdmFyIGk7XG5cbiAgICAgICAgZm9yIChpID0gMTsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcCA9IHBvaW50c1tpXTtcbiAgICAgICAgICAgIGxlZnQgPSBtYXRoTWluKGxlZnQsIHBbMF0pO1xuICAgICAgICAgICAgcmlnaHQgPSBtYXRoTWF4KHJpZ2h0LCBwWzBdKTtcbiAgICAgICAgICAgIHRvcCA9IG1hdGhNaW4odG9wLCBwWzFdKTtcbiAgICAgICAgICAgIGJvdHRvbSA9IG1hdGhNYXgoYm90dG9tLCBwWzFdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1pblswXSA9IGxlZnQ7XG4gICAgICAgIG1pblsxXSA9IHRvcDtcbiAgICAgICAgbWF4WzBdID0gcmlnaHQ7XG4gICAgICAgIG1heFsxXSA9IGJvdHRvbTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvYmJveFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MVxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IG1pblxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IG1heFxuICAgICAqL1xuICAgIGJib3guZnJvbUxpbmUgPSBmdW5jdGlvbiAoeDAsIHkwLCB4MSwgeTEsIG1pbiwgbWF4KSB7XG4gICAgICAgIG1pblswXSA9IG1hdGhNaW4oeDAsIHgxKTtcbiAgICAgICAgbWluWzFdID0gbWF0aE1pbih5MCwgeTEpO1xuICAgICAgICBtYXhbMF0gPSBtYXRoTWF4KHgwLCB4MSk7XG4gICAgICAgIG1heFsxXSA9IG1hdGhNYXgoeTAsIHkxKTtcbiAgICB9O1xuXG4gICAgdmFyIHhEaW0gPSBbXTtcbiAgICB2YXIgeURpbSA9IFtdO1xuICAgIC8qKlxuICAgICAqIOS7juS4iemYtui0neWhnuWwlOabsue6vyhwMCwgcDEsIHAyLCBwMynkuK3orqHnrpflh7rmnIDlsI/ljIXlm7Tnm5LvvIzlhpnlhaVgbWluYOWSjGBtYXhg5LitXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvYmJveFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4M1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5M1xuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IG1pblxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IG1heFxuICAgICAqL1xuICAgIGJib3guZnJvbUN1YmljID0gZnVuY3Rpb24oXG4gICAgICAgIHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgbWluLCBtYXhcbiAgICApIHtcbiAgICAgICAgdmFyIGN1YmljRXh0cmVtYSA9IGN1cnZlLmN1YmljRXh0cmVtYTtcbiAgICAgICAgdmFyIGN1YmljQXQgPSBjdXJ2ZS5jdWJpY0F0O1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIG4gPSBjdWJpY0V4dHJlbWEoeDAsIHgxLCB4MiwgeDMsIHhEaW0pO1xuICAgICAgICBtaW5bMF0gPSBJbmZpbml0eTtcbiAgICAgICAgbWluWzFdID0gSW5maW5pdHk7XG4gICAgICAgIG1heFswXSA9IC1JbmZpbml0eTtcbiAgICAgICAgbWF4WzFdID0gLUluZmluaXR5O1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB4ID0gY3ViaWNBdCh4MCwgeDEsIHgyLCB4MywgeERpbVtpXSk7XG4gICAgICAgICAgICBtaW5bMF0gPSBtYXRoTWluKHgsIG1pblswXSk7XG4gICAgICAgICAgICBtYXhbMF0gPSBtYXRoTWF4KHgsIG1heFswXSk7XG4gICAgICAgIH1cbiAgICAgICAgbiA9IGN1YmljRXh0cmVtYSh5MCwgeTEsIHkyLCB5MywgeURpbSk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB5ID0gY3ViaWNBdCh5MCwgeTEsIHkyLCB5MywgeURpbVtpXSk7XG4gICAgICAgICAgICBtaW5bMV0gPSBtYXRoTWluKHksIG1pblsxXSk7XG4gICAgICAgICAgICBtYXhbMV0gPSBtYXRoTWF4KHksIG1heFsxXSk7XG4gICAgICAgIH1cblxuICAgICAgICBtaW5bMF0gPSBtYXRoTWluKHgwLCBtaW5bMF0pO1xuICAgICAgICBtYXhbMF0gPSBtYXRoTWF4KHgwLCBtYXhbMF0pO1xuICAgICAgICBtaW5bMF0gPSBtYXRoTWluKHgzLCBtaW5bMF0pO1xuICAgICAgICBtYXhbMF0gPSBtYXRoTWF4KHgzLCBtYXhbMF0pO1xuXG4gICAgICAgIG1pblsxXSA9IG1hdGhNaW4oeTAsIG1pblsxXSk7XG4gICAgICAgIG1heFsxXSA9IG1hdGhNYXgoeTAsIG1heFsxXSk7XG4gICAgICAgIG1pblsxXSA9IG1hdGhNaW4oeTMsIG1pblsxXSk7XG4gICAgICAgIG1heFsxXSA9IG1hdGhNYXgoeTMsIG1heFsxXSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIOS7juS6jOmYtui0neWhnuWwlOabsue6vyhwMCwgcDEsIHAyKeS4reiuoeeul+WHuuacgOWwj+WMheWbtOebku+8jOWGmeWFpWBtaW5g5ZKMYG1heGDkuK1cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9iYm94XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgwXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkwXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgxXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkxXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkyXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gbWluXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gbWF4XG4gICAgICovXG4gICAgYmJveC5mcm9tUXVhZHJhdGljID0gZnVuY3Rpb24oeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgbWluLCBtYXgpIHtcbiAgICAgICAgdmFyIHF1YWRyYXRpY0V4dHJlbXVtID0gY3VydmUucXVhZHJhdGljRXh0cmVtdW07XG4gICAgICAgIHZhciBxdWFkcmF0aWNBdCA9IGN1cnZlLnF1YWRyYXRpY0F0O1xuICAgICAgICAvLyBGaW5kIGV4dHJlbWl0aWVzLCB3aGVyZSBkZXJpdmF0aXZlIGluIHggZGltIG9yIHkgZGltIGlzIHplcm9cbiAgICAgICAgdmFyIHR4ID1cbiAgICAgICAgICAgIG1hdGhNYXgoXG4gICAgICAgICAgICAgICAgbWF0aE1pbihxdWFkcmF0aWNFeHRyZW11bSh4MCwgeDEsIHgyKSwgMSksIDBcbiAgICAgICAgICAgICk7XG4gICAgICAgIHZhciB0eSA9XG4gICAgICAgICAgICBtYXRoTWF4KFxuICAgICAgICAgICAgICAgIG1hdGhNaW4ocXVhZHJhdGljRXh0cmVtdW0oeTAsIHkxLCB5MiksIDEpLCAwXG4gICAgICAgICAgICApO1xuXG4gICAgICAgIHZhciB4ID0gcXVhZHJhdGljQXQoeDAsIHgxLCB4MiwgdHgpO1xuICAgICAgICB2YXIgeSA9IHF1YWRyYXRpY0F0KHkwLCB5MSwgeTIsIHR5KTtcblxuICAgICAgICBtaW5bMF0gPSBtYXRoTWluKHgwLCB4MiwgeCk7XG4gICAgICAgIG1pblsxXSA9IG1hdGhNaW4oeTAsIHkyLCB5KTtcbiAgICAgICAgbWF4WzBdID0gbWF0aE1heCh4MCwgeDIsIHgpO1xuICAgICAgICBtYXhbMV0gPSBtYXRoTWF4KHkwLCB5MiwgeSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIOS7juWchuW8p+S4reiuoeeul+WHuuacgOWwj+WMheWbtOebku+8jOWGmeWFpWBtaW5g5ZKMYG1heGDkuK1cbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvYmJveFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcnhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcnlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRBbmdsZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmRBbmdsZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbnRpY2xvY2t3aXNlXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gbWluXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gbWF4XG4gICAgICovXG4gICAgYmJveC5mcm9tQXJjID0gZnVuY3Rpb24gKFxuICAgICAgICB4LCB5LCByeCwgcnksIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBhbnRpY2xvY2t3aXNlLCBtaW4sIG1heFxuICAgICkge1xuICAgICAgICB2YXIgdmVjMk1pbiA9IHZlYzIubWluO1xuICAgICAgICB2YXIgdmVjMk1heCA9IHZlYzIubWF4O1xuXG4gICAgICAgIHZhciBkaWZmID0gTWF0aC5hYnMoc3RhcnRBbmdsZSAtIGVuZEFuZ2xlKTtcblxuXG4gICAgICAgIGlmIChkaWZmICUgUEkyIDwgMWUtNCAmJiBkaWZmID4gMWUtNCkge1xuICAgICAgICAgICAgLy8gSXMgYSBjaXJjbGVcbiAgICAgICAgICAgIG1pblswXSA9IHggLSByeDtcbiAgICAgICAgICAgIG1pblsxXSA9IHkgLSByeTtcbiAgICAgICAgICAgIG1heFswXSA9IHggKyByeDtcbiAgICAgICAgICAgIG1heFsxXSA9IHkgKyByeTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXJ0WzBdID0gbWF0aENvcyhzdGFydEFuZ2xlKSAqIHJ4ICsgeDtcbiAgICAgICAgc3RhcnRbMV0gPSBtYXRoU2luKHN0YXJ0QW5nbGUpICogcnkgKyB5O1xuXG4gICAgICAgIGVuZFswXSA9IG1hdGhDb3MoZW5kQW5nbGUpICogcnggKyB4O1xuICAgICAgICBlbmRbMV0gPSBtYXRoU2luKGVuZEFuZ2xlKSAqIHJ5ICsgeTtcblxuICAgICAgICB2ZWMyTWluKG1pbiwgc3RhcnQsIGVuZCk7XG4gICAgICAgIHZlYzJNYXgobWF4LCBzdGFydCwgZW5kKTtcblxuICAgICAgICAvLyBUaHJlc2ggdG8gWzAsIE1hdGguUEkgKiAyXVxuICAgICAgICBzdGFydEFuZ2xlID0gc3RhcnRBbmdsZSAlIChQSTIpO1xuICAgICAgICBpZiAoc3RhcnRBbmdsZSA8IDApIHtcbiAgICAgICAgICAgIHN0YXJ0QW5nbGUgPSBzdGFydEFuZ2xlICsgUEkyO1xuICAgICAgICB9XG4gICAgICAgIGVuZEFuZ2xlID0gZW5kQW5nbGUgJSAoUEkyKTtcbiAgICAgICAgaWYgKGVuZEFuZ2xlIDwgMCkge1xuICAgICAgICAgICAgZW5kQW5nbGUgPSBlbmRBbmdsZSArIFBJMjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdGFydEFuZ2xlID4gZW5kQW5nbGUgJiYgIWFudGljbG9ja3dpc2UpIHtcbiAgICAgICAgICAgIGVuZEFuZ2xlICs9IFBJMjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGFydEFuZ2xlIDwgZW5kQW5nbGUgJiYgYW50aWNsb2Nrd2lzZSkge1xuICAgICAgICAgICAgc3RhcnRBbmdsZSArPSBQSTI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFudGljbG9ja3dpc2UpIHtcbiAgICAgICAgICAgIHZhciB0bXAgPSBlbmRBbmdsZTtcbiAgICAgICAgICAgIGVuZEFuZ2xlID0gc3RhcnRBbmdsZTtcbiAgICAgICAgICAgIHN0YXJ0QW5nbGUgPSB0bXA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YXIgbnVtYmVyID0gMDtcbiAgICAgICAgLy8gdmFyIHN0ZXAgPSAoYW50aWNsb2Nrd2lzZSA/IC1NYXRoLlBJIDogTWF0aC5QSSkgLyAyO1xuICAgICAgICBmb3IgKHZhciBhbmdsZSA9IDA7IGFuZ2xlIDwgZW5kQW5nbGU7IGFuZ2xlICs9IE1hdGguUEkgLyAyKSB7XG4gICAgICAgICAgICBpZiAoYW5nbGUgPiBzdGFydEFuZ2xlKSB7XG4gICAgICAgICAgICAgICAgZXh0cmVtaXR5WzBdID0gbWF0aENvcyhhbmdsZSkgKiByeCArIHg7XG4gICAgICAgICAgICAgICAgZXh0cmVtaXR5WzFdID0gbWF0aFNpbihhbmdsZSkgKiByeSArIHk7XG5cbiAgICAgICAgICAgICAgICB2ZWMyTWluKG1pbiwgZXh0cmVtaXR5LCBtaW4pO1xuICAgICAgICAgICAgICAgIHZlYzJNYXgobWF4LCBleHRyZW1pdHksIG1heCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBiYm94O1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS95eC9+L3pyZW5kZXIvbGliL2NvcmUvYmJveC5qc1xuLy8gbW9kdWxlIGlkID0gNzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 77 */
/* unknown exports provided */
/* all exports used */
/*!**********************************************!*\
  !*** /home/yx/~/zrender/lib/graphic/Text.js ***!
  \**********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Text element\n * @module zrender/graphic/Text\n *\n * TODO Wrapping\n *\n * Text not support gradient\n */\n\n\n\n    var Displayable = __webpack_require__(/*! ./Displayable */ 36);\n    var zrUtil = __webpack_require__(/*! ../core/util */ 0);\n    var textContain = __webpack_require__(/*! ../contain/text */ 15);\n\n    /**\n     * @alias zrender/graphic/Text\n     * @extends module:zrender/graphic/Displayable\n     * @constructor\n     * @param {Object} opts\n     */\n    var Text = function (opts) {\n        Displayable.call(this, opts);\n    };\n\n    Text.prototype = {\n\n        constructor: Text,\n\n        type: 'text',\n\n        brush: function (ctx, prevEl) {\n            var style = this.style;\n            var x = style.x || 0;\n            var y = style.y || 0;\n            // Convert to string\n            var text = style.text;\n\n            // Convert to string\n            text != null && (text += '');\n\n            // Always bind style\n            style.bind(ctx, this, prevEl);\n\n            if (text) {\n\n                this.setTransform(ctx);\n\n                var textBaseline;\n                var textAlign = style.textAlign;\n                var font = style.textFont || style.font;\n                if (style.textVerticalAlign) {\n                    var rect = textContain.getBoundingRect(\n                        text, font, style.textAlign, 'top'\n                    );\n                    // Ignore textBaseline\n                    textBaseline = 'middle';\n                    switch (style.textVerticalAlign) {\n                        case 'middle':\n                            y -= rect.height / 2 - rect.lineHeight / 2;\n                            break;\n                        case 'bottom':\n                            y -= rect.height - rect.lineHeight / 2;\n                            break;\n                        default:\n                            y += rect.lineHeight / 2;\n                    }\n                }\n                else {\n                    textBaseline = style.textBaseline;\n                }\n\n                // TODO Invalid font\n                ctx.font = font || '12px sans-serif';\n                ctx.textAlign = textAlign || 'left';\n                // Use canvas default left textAlign. Giving invalid value will cause state not change\n                if (ctx.textAlign !== textAlign) {\n                    ctx.textAlign = 'left';\n                }\n                // FIXME in text contain default is top\n                ctx.textBaseline = textBaseline || 'alphabetic';\n                // Use canvas default alphabetic baseline\n                if (ctx.textBaseline !== textBaseline) {\n                    ctx.textBaseline = 'alphabetic';\n                }\n\n                var lineHeight = textContain.measureText('国', ctx.font).width;\n\n                var textLines = text.split('\\n');\n                for (var i = 0; i < textLines.length; i++) {\n                    // Fill after stroke so the outline will not cover the main part.\n                    style.hasStroke() && ctx.strokeText(textLines[i], x, y);\n                    style.hasFill() && ctx.fillText(textLines[i], x, y);\n                    y += lineHeight;\n                }\n\n                this.restoreTransform(ctx);\n            }\n        },\n\n        getBoundingRect: function () {\n            var style = this.style;\n            if (!this._rect) {\n                var textVerticalAlign = style.textVerticalAlign;\n                var rect = textContain.getBoundingRect(\n                    style.text + '', style.textFont || style.font, style.textAlign,\n                    textVerticalAlign ? 'top' : style.textBaseline\n                );\n                switch (textVerticalAlign) {\n                    case 'middle':\n                        rect.y -= rect.height / 2;\n                        break;\n                    case 'bottom':\n                        rect.y -= rect.height;\n                        break;\n                }\n                rect.x += style.x || 0;\n                rect.y += style.y || 0;\n                if (style.hasStroke()) {\n                    var w = style.lineWidth;\n                    rect.x -= w / 2;\n                    rect.y -= w / 2;\n                    rect.width += w;\n                    rect.height += w;\n                }\n                this._rect = rect;\n            }\n\n            return this._rect;\n        }\n    };\n\n    zrUtil.inherits(Text, Displayable);\n\n    module.exports = Text;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL2hvbWUveXgvfi96cmVuZGVyL2xpYi9ncmFwaGljL1RleHQuanM/M2QzZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFRleHQgZWxlbWVudFxuICogQG1vZHVsZSB6cmVuZGVyL2dyYXBoaWMvVGV4dFxuICpcbiAqIFRPRE8gV3JhcHBpbmdcbiAqXG4gKiBUZXh0IG5vdCBzdXBwb3J0IGdyYWRpZW50XG4gKi9cblxuXG5cbiAgICB2YXIgRGlzcGxheWFibGUgPSByZXF1aXJlKCcuL0Rpc3BsYXlhYmxlJyk7XG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpO1xuICAgIHZhciB0ZXh0Q29udGFpbiA9IHJlcXVpcmUoJy4uL2NvbnRhaW4vdGV4dCcpO1xuXG4gICAgLyoqXG4gICAgICogQGFsaWFzIHpyZW5kZXIvZ3JhcGhpYy9UZXh0XG4gICAgICogQGV4dGVuZHMgbW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICovXG4gICAgdmFyIFRleHQgPSBmdW5jdGlvbiAob3B0cykge1xuICAgICAgICBEaXNwbGF5YWJsZS5jYWxsKHRoaXMsIG9wdHMpO1xuICAgIH07XG5cbiAgICBUZXh0LnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogVGV4dCxcblxuICAgICAgICB0eXBlOiAndGV4dCcsXG5cbiAgICAgICAgYnJ1c2g6IGZ1bmN0aW9uIChjdHgsIHByZXZFbCkge1xuICAgICAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTtcbiAgICAgICAgICAgIHZhciB4ID0gc3R5bGUueCB8fCAwO1xuICAgICAgICAgICAgdmFyIHkgPSBzdHlsZS55IHx8IDA7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IHRvIHN0cmluZ1xuICAgICAgICAgICAgdmFyIHRleHQgPSBzdHlsZS50ZXh0O1xuXG4gICAgICAgICAgICAvLyBDb252ZXJ0IHRvIHN0cmluZ1xuICAgICAgICAgICAgdGV4dCAhPSBudWxsICYmICh0ZXh0ICs9ICcnKTtcblxuICAgICAgICAgICAgLy8gQWx3YXlzIGJpbmQgc3R5bGVcbiAgICAgICAgICAgIHN0eWxlLmJpbmQoY3R4LCB0aGlzLCBwcmV2RWwpO1xuXG4gICAgICAgICAgICBpZiAodGV4dCkge1xuXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRUcmFuc2Zvcm0oY3R4KTtcblxuICAgICAgICAgICAgICAgIHZhciB0ZXh0QmFzZWxpbmU7XG4gICAgICAgICAgICAgICAgdmFyIHRleHRBbGlnbiA9IHN0eWxlLnRleHRBbGlnbjtcbiAgICAgICAgICAgICAgICB2YXIgZm9udCA9IHN0eWxlLnRleHRGb250IHx8IHN0eWxlLmZvbnQ7XG4gICAgICAgICAgICAgICAgaWYgKHN0eWxlLnRleHRWZXJ0aWNhbEFsaWduKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZWN0ID0gdGV4dENvbnRhaW4uZ2V0Qm91bmRpbmdSZWN0KFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCwgZm9udCwgc3R5bGUudGV4dEFsaWduLCAndG9wJ1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgdGV4dEJhc2VsaW5lXG4gICAgICAgICAgICAgICAgICAgIHRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHN0eWxlLnRleHRWZXJ0aWNhbEFsaWduKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdtaWRkbGUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgLT0gcmVjdC5oZWlnaHQgLyAyIC0gcmVjdC5saW5lSGVpZ2h0IC8gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeSAtPSByZWN0LmhlaWdodCAtIHJlY3QubGluZUhlaWdodCAvIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgKz0gcmVjdC5saW5lSGVpZ2h0IC8gMjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dEJhc2VsaW5lID0gc3R5bGUudGV4dEJhc2VsaW5lO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFRPRE8gSW52YWxpZCBmb250XG4gICAgICAgICAgICAgICAgY3R4LmZvbnQgPSBmb250IHx8ICcxMnB4IHNhbnMtc2VyaWYnO1xuICAgICAgICAgICAgICAgIGN0eC50ZXh0QWxpZ24gPSB0ZXh0QWxpZ24gfHwgJ2xlZnQnO1xuICAgICAgICAgICAgICAgIC8vIFVzZSBjYW52YXMgZGVmYXVsdCBsZWZ0IHRleHRBbGlnbi4gR2l2aW5nIGludmFsaWQgdmFsdWUgd2lsbCBjYXVzZSBzdGF0ZSBub3QgY2hhbmdlXG4gICAgICAgICAgICAgICAgaWYgKGN0eC50ZXh0QWxpZ24gIT09IHRleHRBbGlnbikge1xuICAgICAgICAgICAgICAgICAgICBjdHgudGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBGSVhNRSBpbiB0ZXh0IGNvbnRhaW4gZGVmYXVsdCBpcyB0b3BcbiAgICAgICAgICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gdGV4dEJhc2VsaW5lIHx8ICdhbHBoYWJldGljJztcbiAgICAgICAgICAgICAgICAvLyBVc2UgY2FudmFzIGRlZmF1bHQgYWxwaGFiZXRpYyBiYXNlbGluZVxuICAgICAgICAgICAgICAgIGlmIChjdHgudGV4dEJhc2VsaW5lICE9PSB0ZXh0QmFzZWxpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9ICdhbHBoYWJldGljJztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgbGluZUhlaWdodCA9IHRleHRDb250YWluLm1lYXN1cmVUZXh0KCflm70nLCBjdHguZm9udCkud2lkdGg7XG5cbiAgICAgICAgICAgICAgICB2YXIgdGV4dExpbmVzID0gdGV4dC5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0TGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRmlsbCBhZnRlciBzdHJva2Ugc28gdGhlIG91dGxpbmUgd2lsbCBub3QgY292ZXIgdGhlIG1haW4gcGFydC5cbiAgICAgICAgICAgICAgICAgICAgc3R5bGUuaGFzU3Ryb2tlKCkgJiYgY3R4LnN0cm9rZVRleHQodGV4dExpbmVzW2ldLCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUuaGFzRmlsbCgpICYmIGN0eC5maWxsVGV4dCh0ZXh0TGluZXNbaV0sIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICB5ICs9IGxpbmVIZWlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5yZXN0b3JlVHJhbnNmb3JtKGN0eCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0Qm91bmRpbmdSZWN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLnN0eWxlO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9yZWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHRleHRWZXJ0aWNhbEFsaWduID0gc3R5bGUudGV4dFZlcnRpY2FsQWxpZ247XG4gICAgICAgICAgICAgICAgdmFyIHJlY3QgPSB0ZXh0Q29udGFpbi5nZXRCb3VuZGluZ1JlY3QoXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlLnRleHQgKyAnJywgc3R5bGUudGV4dEZvbnQgfHwgc3R5bGUuZm9udCwgc3R5bGUudGV4dEFsaWduLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0VmVydGljYWxBbGlnbiA/ICd0b3AnIDogc3R5bGUudGV4dEJhc2VsaW5lXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRleHRWZXJ0aWNhbEFsaWduKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ21pZGRsZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZWN0LnkgLT0gcmVjdC5oZWlnaHQgLyAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZWN0LnkgLT0gcmVjdC5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVjdC54ICs9IHN0eWxlLnggfHwgMDtcbiAgICAgICAgICAgICAgICByZWN0LnkgKz0gc3R5bGUueSB8fCAwO1xuICAgICAgICAgICAgICAgIGlmIChzdHlsZS5oYXNTdHJva2UoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdyA9IHN0eWxlLmxpbmVXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgcmVjdC54IC09IHcgLyAyO1xuICAgICAgICAgICAgICAgICAgICByZWN0LnkgLT0gdyAvIDI7XG4gICAgICAgICAgICAgICAgICAgIHJlY3Qud2lkdGggKz0gdztcbiAgICAgICAgICAgICAgICAgICAgcmVjdC5oZWlnaHQgKz0gdztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVjdCA9IHJlY3Q7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWN0O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHpyVXRpbC5pbmhlcml0cyhUZXh0LCBEaXNwbGF5YWJsZSk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFRleHQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS95eC9+L3pyZW5kZXIvbGliL2dyYXBoaWMvVGV4dC5qc1xuLy8gbW9kdWxlIGlkID0gNzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 78 */
/* unknown exports provided */
/* all exports used */
/*!********************************************************!*\
  !*** /home/yx/~/zrender/lib/graphic/mixin/RectText.js ***!
  \********************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Mixin for drawing text in a element bounding rect\n * @module zrender/mixin/RectText\n */\n\n\n\n    var textContain = __webpack_require__(/*! ../../contain/text */ 15);\n    var BoundingRect = __webpack_require__(/*! ../../core/BoundingRect */ 10);\n\n    var tmpRect = new BoundingRect();\n\n    var RectText = function () {};\n\n    function parsePercent(value, maxValue) {\n        if (typeof value === 'string') {\n            if (value.lastIndexOf('%') >= 0) {\n                return parseFloat(value) / 100 * maxValue;\n            }\n            return parseFloat(value);\n        }\n        return value;\n    }\n\n    RectText.prototype = {\n\n        constructor: RectText,\n\n        /**\n         * Draw text in a rect with specified position.\n         * @param  {CanvasRenderingContext} ctx\n         * @param  {Object} rect Displayable rect\n         * @return {Object} textRect Alternative precalculated text bounding rect\n         */\n        drawRectText: function (ctx, rect, textRect) {\n            var style = this.style;\n            var text = style.text;\n            // Convert to string\n            text != null && (text += '');\n            if (!text) {\n                return;\n            }\n\n            // FIXME\n            ctx.save();\n\n            var x;\n            var y;\n            var textPosition = style.textPosition;\n            var textOffset = style.textOffset;\n            var distance = style.textDistance;\n            var align = style.textAlign;\n            var font = style.textFont || style.font;\n            var baseline = style.textBaseline;\n            var verticalAlign = style.textVerticalAlign;\n\n            textRect = textRect || textContain.getBoundingRect(text, font, align, baseline);\n\n            // Transform rect to view space\n            var transform = this.transform;\n            if (!style.textTransform) {\n                if (transform) {\n                    tmpRect.copy(rect);\n                    tmpRect.applyTransform(transform);\n                    rect = tmpRect;\n                }\n            }\n            else {\n                this.setTransform(ctx);\n            }\n\n            // Text position represented by coord\n            if (textPosition instanceof Array) {\n                // Percent\n                x = rect.x + parsePercent(textPosition[0], rect.width);\n                y = rect.y + parsePercent(textPosition[1], rect.height);\n                align = align || 'left';\n                baseline = baseline || 'top';\n\n                if (verticalAlign) {\n                    switch (verticalAlign) {\n                        case 'middle':\n                            y -= textRect.height / 2 - textRect.lineHeight / 2;\n                            break;\n                        case 'bottom':\n                            y -= textRect.height - textRect.lineHeight / 2;\n                            break;\n                        default:\n                            y += textRect.lineHeight / 2;\n                    }\n                    // Force bseline to be middle\n                    baseline = 'middle';\n                }\n            }\n            else {\n                var res = textContain.adjustTextPositionOnRect(\n                    textPosition, rect, textRect, distance\n                );\n                x = res.x;\n                y = res.y;\n                // Default align and baseline when has textPosition\n                align = align || res.textAlign;\n                baseline = baseline || res.textBaseline;\n            }\n\n            if (textOffset) {\n                x += textOffset[0];\n                y += textOffset[1];\n            }\n\n            // Use canvas default left textAlign. Giving invalid value will cause state not change\n            ctx.textAlign = align || 'left';\n            // Use canvas default alphabetic baseline\n            ctx.textBaseline = baseline || 'alphabetic';\n\n            var textFill = style.textFill;\n            var textStroke = style.textStroke;\n            textFill && (ctx.fillStyle = textFill);\n            textStroke && (ctx.strokeStyle = textStroke);\n\n            // TODO Invalid font\n            ctx.font = font || '12px sans-serif';\n\n            // Text shadow\n            // Always set shadowBlur and shadowOffset to avoid leak from displayable\n            ctx.shadowBlur = style.textShadowBlur;\n            ctx.shadowColor = style.textShadowColor || 'transparent';\n            ctx.shadowOffsetX = style.textShadowOffsetX;\n            ctx.shadowOffsetY = style.textShadowOffsetY;\n\n            var textLines = text.split('\\n');\n\n            if (style.textRotation) {\n                transform && ctx.translate(transform[4], transform[5]);\n                ctx.rotate(style.textRotation);\n                transform && ctx.translate(-transform[4], -transform[5]);\n            }\n\n            for (var i = 0; i < textLines.length; i++) {\n                    // Fill after stroke so the outline will not cover the main part.\n                textStroke && ctx.strokeText(textLines[i], x, y);\n                textFill && ctx.fillText(textLines[i], x, y);\n                y += textRect.lineHeight;\n            }\n\n            ctx.restore();\n        }\n    };\n\n    module.exports = RectText;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL2hvbWUveXgvfi96cmVuZGVyL2xpYi9ncmFwaGljL21peGluL1JlY3RUZXh0LmpzP2I4M2EiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBNaXhpbiBmb3IgZHJhd2luZyB0ZXh0IGluIGEgZWxlbWVudCBib3VuZGluZyByZWN0XG4gKiBAbW9kdWxlIHpyZW5kZXIvbWl4aW4vUmVjdFRleHRcbiAqL1xuXG5cblxuICAgIHZhciB0ZXh0Q29udGFpbiA9IHJlcXVpcmUoJy4uLy4uL2NvbnRhaW4vdGV4dCcpO1xuICAgIHZhciBCb3VuZGluZ1JlY3QgPSByZXF1aXJlKCcuLi8uLi9jb3JlL0JvdW5kaW5nUmVjdCcpO1xuXG4gICAgdmFyIHRtcFJlY3QgPSBuZXcgQm91bmRpbmdSZWN0KCk7XG5cbiAgICB2YXIgUmVjdFRleHQgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgIGZ1bmN0aW9uIHBhcnNlUGVyY2VudCh2YWx1ZSwgbWF4VmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZS5sYXN0SW5kZXhPZignJScpID49IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCh2YWx1ZSkgLyAxMDAgKiBtYXhWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgUmVjdFRleHQucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBSZWN0VGV4dCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRHJhdyB0ZXh0IGluIGEgcmVjdCB3aXRoIHNwZWNpZmllZCBwb3NpdGlvbi5cbiAgICAgICAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dH0gY3R4XG4gICAgICAgICAqIEBwYXJhbSAge09iamVjdH0gcmVjdCBEaXNwbGF5YWJsZSByZWN0XG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gdGV4dFJlY3QgQWx0ZXJuYXRpdmUgcHJlY2FsY3VsYXRlZCB0ZXh0IGJvdW5kaW5nIHJlY3RcbiAgICAgICAgICovXG4gICAgICAgIGRyYXdSZWN0VGV4dDogZnVuY3Rpb24gKGN0eCwgcmVjdCwgdGV4dFJlY3QpIHtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XG4gICAgICAgICAgICB2YXIgdGV4dCA9IHN0eWxlLnRleHQ7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IHRvIHN0cmluZ1xuICAgICAgICAgICAgdGV4dCAhPSBudWxsICYmICh0ZXh0ICs9ICcnKTtcbiAgICAgICAgICAgIGlmICghdGV4dCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRklYTUVcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XG5cbiAgICAgICAgICAgIHZhciB4O1xuICAgICAgICAgICAgdmFyIHk7XG4gICAgICAgICAgICB2YXIgdGV4dFBvc2l0aW9uID0gc3R5bGUudGV4dFBvc2l0aW9uO1xuICAgICAgICAgICAgdmFyIHRleHRPZmZzZXQgPSBzdHlsZS50ZXh0T2Zmc2V0O1xuICAgICAgICAgICAgdmFyIGRpc3RhbmNlID0gc3R5bGUudGV4dERpc3RhbmNlO1xuICAgICAgICAgICAgdmFyIGFsaWduID0gc3R5bGUudGV4dEFsaWduO1xuICAgICAgICAgICAgdmFyIGZvbnQgPSBzdHlsZS50ZXh0Rm9udCB8fCBzdHlsZS5mb250O1xuICAgICAgICAgICAgdmFyIGJhc2VsaW5lID0gc3R5bGUudGV4dEJhc2VsaW5lO1xuICAgICAgICAgICAgdmFyIHZlcnRpY2FsQWxpZ24gPSBzdHlsZS50ZXh0VmVydGljYWxBbGlnbjtcblxuICAgICAgICAgICAgdGV4dFJlY3QgPSB0ZXh0UmVjdCB8fCB0ZXh0Q29udGFpbi5nZXRCb3VuZGluZ1JlY3QodGV4dCwgZm9udCwgYWxpZ24sIGJhc2VsaW5lKTtcblxuICAgICAgICAgICAgLy8gVHJhbnNmb3JtIHJlY3QgdG8gdmlldyBzcGFjZVxuICAgICAgICAgICAgdmFyIHRyYW5zZm9ybSA9IHRoaXMudHJhbnNmb3JtO1xuICAgICAgICAgICAgaWYgKCFzdHlsZS50ZXh0VHJhbnNmb3JtKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgICAgICAgICAgICAgICB0bXBSZWN0LmNvcHkocmVjdCk7XG4gICAgICAgICAgICAgICAgICAgIHRtcFJlY3QuYXBwbHlUcmFuc2Zvcm0odHJhbnNmb3JtKTtcbiAgICAgICAgICAgICAgICAgICAgcmVjdCA9IHRtcFJlY3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRUcmFuc2Zvcm0oY3R4KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVGV4dCBwb3NpdGlvbiByZXByZXNlbnRlZCBieSBjb29yZFxuICAgICAgICAgICAgaWYgKHRleHRQb3NpdGlvbiBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgLy8gUGVyY2VudFxuICAgICAgICAgICAgICAgIHggPSByZWN0LnggKyBwYXJzZVBlcmNlbnQodGV4dFBvc2l0aW9uWzBdLCByZWN0LndpZHRoKTtcbiAgICAgICAgICAgICAgICB5ID0gcmVjdC55ICsgcGFyc2VQZXJjZW50KHRleHRQb3NpdGlvblsxXSwgcmVjdC5oZWlnaHQpO1xuICAgICAgICAgICAgICAgIGFsaWduID0gYWxpZ24gfHwgJ2xlZnQnO1xuICAgICAgICAgICAgICAgIGJhc2VsaW5lID0gYmFzZWxpbmUgfHwgJ3RvcCc7XG5cbiAgICAgICAgICAgICAgICBpZiAodmVydGljYWxBbGlnbikge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHZlcnRpY2FsQWxpZ24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ21pZGRsZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeSAtPSB0ZXh0UmVjdC5oZWlnaHQgLyAyIC0gdGV4dFJlY3QubGluZUhlaWdodCAvIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgLT0gdGV4dFJlY3QuaGVpZ2h0IC0gdGV4dFJlY3QubGluZUhlaWdodCAvIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgKz0gdGV4dFJlY3QubGluZUhlaWdodCAvIDI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yY2UgYnNlbGluZSB0byBiZSBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgYmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzID0gdGV4dENvbnRhaW4uYWRqdXN0VGV4dFBvc2l0aW9uT25SZWN0KFxuICAgICAgICAgICAgICAgICAgICB0ZXh0UG9zaXRpb24sIHJlY3QsIHRleHRSZWN0LCBkaXN0YW5jZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgeCA9IHJlcy54O1xuICAgICAgICAgICAgICAgIHkgPSByZXMueTtcbiAgICAgICAgICAgICAgICAvLyBEZWZhdWx0IGFsaWduIGFuZCBiYXNlbGluZSB3aGVuIGhhcyB0ZXh0UG9zaXRpb25cbiAgICAgICAgICAgICAgICBhbGlnbiA9IGFsaWduIHx8IHJlcy50ZXh0QWxpZ247XG4gICAgICAgICAgICAgICAgYmFzZWxpbmUgPSBiYXNlbGluZSB8fCByZXMudGV4dEJhc2VsaW5lO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGV4dE9mZnNldCkge1xuICAgICAgICAgICAgICAgIHggKz0gdGV4dE9mZnNldFswXTtcbiAgICAgICAgICAgICAgICB5ICs9IHRleHRPZmZzZXRbMV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFVzZSBjYW52YXMgZGVmYXVsdCBsZWZ0IHRleHRBbGlnbi4gR2l2aW5nIGludmFsaWQgdmFsdWUgd2lsbCBjYXVzZSBzdGF0ZSBub3QgY2hhbmdlXG4gICAgICAgICAgICBjdHgudGV4dEFsaWduID0gYWxpZ24gfHwgJ2xlZnQnO1xuICAgICAgICAgICAgLy8gVXNlIGNhbnZhcyBkZWZhdWx0IGFscGhhYmV0aWMgYmFzZWxpbmVcbiAgICAgICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSBiYXNlbGluZSB8fCAnYWxwaGFiZXRpYyc7XG5cbiAgICAgICAgICAgIHZhciB0ZXh0RmlsbCA9IHN0eWxlLnRleHRGaWxsO1xuICAgICAgICAgICAgdmFyIHRleHRTdHJva2UgPSBzdHlsZS50ZXh0U3Ryb2tlO1xuICAgICAgICAgICAgdGV4dEZpbGwgJiYgKGN0eC5maWxsU3R5bGUgPSB0ZXh0RmlsbCk7XG4gICAgICAgICAgICB0ZXh0U3Ryb2tlICYmIChjdHguc3Ryb2tlU3R5bGUgPSB0ZXh0U3Ryb2tlKTtcblxuICAgICAgICAgICAgLy8gVE9ETyBJbnZhbGlkIGZvbnRcbiAgICAgICAgICAgIGN0eC5mb250ID0gZm9udCB8fCAnMTJweCBzYW5zLXNlcmlmJztcblxuICAgICAgICAgICAgLy8gVGV4dCBzaGFkb3dcbiAgICAgICAgICAgIC8vIEFsd2F5cyBzZXQgc2hhZG93Qmx1ciBhbmQgc2hhZG93T2Zmc2V0IHRvIGF2b2lkIGxlYWsgZnJvbSBkaXNwbGF5YWJsZVxuICAgICAgICAgICAgY3R4LnNoYWRvd0JsdXIgPSBzdHlsZS50ZXh0U2hhZG93Qmx1cjtcbiAgICAgICAgICAgIGN0eC5zaGFkb3dDb2xvciA9IHN0eWxlLnRleHRTaGFkb3dDb2xvciB8fCAndHJhbnNwYXJlbnQnO1xuICAgICAgICAgICAgY3R4LnNoYWRvd09mZnNldFggPSBzdHlsZS50ZXh0U2hhZG93T2Zmc2V0WDtcbiAgICAgICAgICAgIGN0eC5zaGFkb3dPZmZzZXRZID0gc3R5bGUudGV4dFNoYWRvd09mZnNldFk7XG5cbiAgICAgICAgICAgIHZhciB0ZXh0TGluZXMgPSB0ZXh0LnNwbGl0KCdcXG4nKTtcblxuICAgICAgICAgICAgaWYgKHN0eWxlLnRleHRSb3RhdGlvbikge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybSAmJiBjdHgudHJhbnNsYXRlKHRyYW5zZm9ybVs0XSwgdHJhbnNmb3JtWzVdKTtcbiAgICAgICAgICAgICAgICBjdHgucm90YXRlKHN0eWxlLnRleHRSb3RhdGlvbik7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtICYmIGN0eC50cmFuc2xhdGUoLXRyYW5zZm9ybVs0XSwgLXRyYW5zZm9ybVs1XSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGV4dExpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZpbGwgYWZ0ZXIgc3Ryb2tlIHNvIHRoZSBvdXRsaW5lIHdpbGwgbm90IGNvdmVyIHRoZSBtYWluIHBhcnQuXG4gICAgICAgICAgICAgICAgdGV4dFN0cm9rZSAmJiBjdHguc3Ryb2tlVGV4dCh0ZXh0TGluZXNbaV0sIHgsIHkpO1xuICAgICAgICAgICAgICAgIHRleHRGaWxsICYmIGN0eC5maWxsVGV4dCh0ZXh0TGluZXNbaV0sIHgsIHkpO1xuICAgICAgICAgICAgICAgIHkgKz0gdGV4dFJlY3QubGluZUhlaWdodDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFJlY3RUZXh0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2hvbWUveXgvfi96cmVuZGVyL2xpYi9ncmFwaGljL21peGluL1JlY3RUZXh0LmpzXG4vLyBtb2R1bGUgaWQgPSA3OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 79 */
/* unknown exports provided */
/* all exports used */
/*!*****************************************!*\
  !*** /home/yx/~/zrender/lib/zrender.js ***!
  \*****************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n * ZRender, a high performance 2d drawing library.\n *\n * Copyright (c) 2013, Baidu Inc.\n * All rights reserved.\n *\n * LICENSE\n * https://github.com/ecomfe/zrender/blob/master/LICENSE.txt\n */\n// Global defines\n\n    var guid = __webpack_require__(/*! ./core/guid */ 62);\n    var env = __webpack_require__(/*! ./core/env */ 8);\n    var zrUtil = __webpack_require__(/*! ./core/util */ 0);\n\n    var Handler = __webpack_require__(/*! ./Handler */ 102);\n    var Storage = __webpack_require__(/*! ./Storage */ 105);\n    var Animation = __webpack_require__(/*! ./animation/Animation */ 106);\n    var HandlerProxy = __webpack_require__(/*! ./dom/HandlerProxy */ 113);\n\n    var useVML = !env.canvasSupported;\n\n    var painterCtors = {\n        canvas: __webpack_require__(/*! ./Painter */ 104)\n    };\n\n    var instances = {};    // ZRender实例map索引\n\n    var zrender = {};\n\n    /**\n     * @type {string}\n     */\n    zrender.version = '3.4.4';\n\n    /**\n     * Initializing a zrender instance\n     * @param {HTMLElement} dom\n     * @param {Object} opts\n     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n     * @param {number} [opts.devicePixelRatio]\n     * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)\n     * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)\n     * @return {module:zrender/ZRender}\n     */\n    zrender.init = function(dom, opts) {\n        var zr = new ZRender(guid(), dom, opts);\n        instances[zr.id] = zr;\n        return zr;\n    };\n\n    /**\n     * Dispose zrender instance\n     * @param {module:zrender/ZRender} zr\n     */\n    zrender.dispose = function (zr) {\n        if (zr) {\n            zr.dispose();\n        }\n        else {\n            for (var key in instances) {\n                if (instances.hasOwnProperty(key)) {\n                    instances[key].dispose();\n                }\n            }\n            instances = {};\n        }\n\n        return zrender;\n    };\n\n    /**\n     * Get zrender instance by id\n     * @param {string} id zrender instance id\n     * @return {module:zrender/ZRender}\n     */\n    zrender.getInstance = function (id) {\n        return instances[id];\n    };\n\n    zrender.registerPainter = function (name, Ctor) {\n        painterCtors[name] = Ctor;\n    };\n\n    function delInstance(id) {\n        delete instances[id];\n    }\n\n    /**\n     * @module zrender/ZRender\n     */\n    /**\n     * @constructor\n     * @alias module:zrender/ZRender\n     * @param {string} id\n     * @param {HTMLDomElement} dom\n     * @param {Object} opts\n     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n     * @param {number} [opts.devicePixelRatio]\n     * @param {number} [opts.width] Can be 'auto' (the same as null/undefined)\n     * @param {number} [opts.height] Can be 'auto' (the same as null/undefined)\n     */\n    var ZRender = function(id, dom, opts) {\n\n        opts = opts || {};\n\n        /**\n         * @type {HTMLDomElement}\n         */\n        this.dom = dom;\n\n        /**\n         * @type {string}\n         */\n        this.id = id;\n\n        var self = this;\n        var storage = new Storage();\n\n        var rendererType = opts.renderer;\n        // TODO WebGL\n        if (useVML) {\n            if (!painterCtors.vml) {\n                throw new Error('You need to require \\'zrender/vml/vml\\' to support IE8');\n            }\n            rendererType = 'vml';\n        }\n        else if (!rendererType || !painterCtors[rendererType]) {\n            rendererType = 'canvas';\n        }\n        var painter = new painterCtors[rendererType](dom, storage, opts);\n\n        this.storage = storage;\n        this.painter = painter;\n\n        var handerProxy = !env.node ? new HandlerProxy(painter.getViewportRoot()) : null;\n        this.handler = new Handler(storage, painter, handerProxy, painter.root);\n\n        /**\n         * @type {module:zrender/animation/Animation}\n         */\n        this.animation = new Animation({\n            stage: {\n                update: zrUtil.bind(this.flush, this)\n            }\n        });\n        this.animation.start();\n\n        /**\n         * @type {boolean}\n         * @private\n         */\n        this._needsRefresh;\n\n        // 修改 storage.delFromStorage, 每次删除元素之前删除动画\n        // FIXME 有点ugly\n        var oldDelFromStorage = storage.delFromStorage;\n        var oldAddToStorage = storage.addToStorage;\n\n        storage.delFromStorage = function (el) {\n            oldDelFromStorage.call(storage, el);\n\n            el && el.removeSelfFromZr(self);\n        };\n\n        storage.addToStorage = function (el) {\n            oldAddToStorage.call(storage, el);\n\n            el.addSelfToZr(self);\n        };\n    };\n\n    ZRender.prototype = {\n\n        constructor: ZRender,\n        /**\n         * 获取实例唯一标识\n         * @return {string}\n         */\n        getId: function () {\n            return this.id;\n        },\n\n        /**\n         * 添加元素\n         * @param  {module:zrender/Element} el\n         */\n        add: function (el) {\n            this.storage.addRoot(el);\n            this._needsRefresh = true;\n        },\n\n        /**\n         * 删除元素\n         * @param  {module:zrender/Element} el\n         */\n        remove: function (el) {\n            this.storage.delRoot(el);\n            this._needsRefresh = true;\n        },\n\n        /**\n         * Change configuration of layer\n         * @param {string} zLevel\n         * @param {Object} config\n         * @param {string} [config.clearColor=0] Clear color\n         * @param {string} [config.motionBlur=false] If enable motion blur\n         * @param {number} [config.lastFrameAlpha=0.7] Motion blur factor. Larger value cause longer trailer\n        */\n        configLayer: function (zLevel, config) {\n            this.painter.configLayer(zLevel, config);\n            this._needsRefresh = true;\n        },\n\n        /**\n         * Repaint the canvas immediately\n         */\n        refreshImmediately: function () {\n            // Clear needsRefresh ahead to avoid something wrong happens in refresh\n            // Or it will cause zrender refreshes again and again.\n            this._needsRefresh = false;\n            this.painter.refresh();\n            /**\n             * Avoid trigger zr.refresh in Element#beforeUpdate hook\n             */\n            this._needsRefresh = false;\n        },\n\n        /**\n         * Mark and repaint the canvas in the next frame of browser\n         */\n        refresh: function() {\n            this._needsRefresh = true;\n        },\n\n        /**\n         * Perform all refresh\n         */\n        flush: function () {\n            if (this._needsRefresh) {\n                this.refreshImmediately();\n            }\n            if (this._needsRefreshHover) {\n                this.refreshHoverImmediately();\n            }\n        },\n\n        /**\n         * Add element to hover layer\n         * @param  {module:zrender/Element} el\n         * @param {Object} style\n         */\n        addHover: function (el, style) {\n            if (this.painter.addHover) {\n                this.painter.addHover(el, style);\n                this.refreshHover();\n            }\n        },\n\n        /**\n         * Add element from hover layer\n         * @param  {module:zrender/Element} el\n         */\n        removeHover: function (el) {\n            if (this.painter.removeHover) {\n                this.painter.removeHover(el);\n                this.refreshHover();\n            }\n        },\n\n        /**\n         * Clear all hover elements in hover layer\n         * @param  {module:zrender/Element} el\n         */\n        clearHover: function () {\n            if (this.painter.clearHover) {\n                this.painter.clearHover();\n                this.refreshHover();\n            }\n        },\n\n        /**\n         * Refresh hover in next frame\n         */\n        refreshHover: function () {\n            this._needsRefreshHover = true;\n        },\n\n        /**\n         * Refresh hover immediately\n         */\n        refreshHoverImmediately: function () {\n            this._needsRefreshHover = false;\n            this.painter.refreshHover && this.painter.refreshHover();\n        },\n\n        /**\n         * Resize the canvas.\n         * Should be invoked when container size is changed\n         * @param {Object} [opts]\n         * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)\n         * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)\n         */\n        resize: function(opts) {\n            opts = opts || {};\n            this.painter.resize(opts.width, opts.height);\n            this.handler.resize();\n        },\n\n        /**\n         * Stop and clear all animation immediately\n         */\n        clearAnimation: function () {\n            this.animation.clear();\n        },\n\n        /**\n         * Get container width\n         */\n        getWidth: function() {\n            return this.painter.getWidth();\n        },\n\n        /**\n         * Get container height\n         */\n        getHeight: function() {\n            return this.painter.getHeight();\n        },\n\n        /**\n         * Export the canvas as Base64 URL\n         * @param {string} type\n         * @param {string} [backgroundColor='#fff']\n         * @return {string} Base64 URL\n         */\n        // toDataURL: function(type, backgroundColor) {\n        //     return this.painter.getRenderedCanvas({\n        //         backgroundColor: backgroundColor\n        //     }).toDataURL(type);\n        // },\n\n        /**\n         * Converting a path to image.\n         * It has much better performance of drawing image rather than drawing a vector path.\n         * @param {module:zrender/graphic/Path} e\n         * @param {number} width\n         * @param {number} height\n         */\n        pathToImage: function(e, dpr) {\n            return this.painter.pathToImage(e, dpr);\n        },\n\n        /**\n         * Set default cursor\n         * @param {string} [cursorStyle='default'] 例如 crosshair\n         */\n        setCursorStyle: function (cursorStyle) {\n            this.handler.setCursorStyle(cursorStyle);\n        },\n\n        /**\n         * Find hovered element\n         * @param {number} x\n         * @param {number} y\n         * @return {Object} {target, topTarget}\n         */\n        findHover: function (x, y) {\n            return this.handler.findHover(x, y);\n        },\n\n        /**\n         * Bind event\n         *\n         * @param {string} eventName Event name\n         * @param {Function} eventHandler Handler function\n         * @param {Object} [context] Context object\n         */\n        on: function(eventName, eventHandler, context) {\n            this.handler.on(eventName, eventHandler, context);\n        },\n\n        /**\n         * Unbind event\n         * @param {string} eventName Event name\n         * @param {Function} [eventHandler] Handler function\n         */\n        off: function(eventName, eventHandler) {\n            this.handler.off(eventName, eventHandler);\n        },\n\n        /**\n         * Trigger event manually\n         *\n         * @param {string} eventName Event name\n         * @param {event=} event Event object\n         */\n        trigger: function (eventName, event) {\n            this.handler.trigger(eventName, event);\n        },\n\n\n        /**\n         * Clear all objects and the canvas.\n         */\n        clear: function () {\n            this.storage.delRoot();\n            this.painter.clear();\n        },\n\n        /**\n         * Dispose self.\n         */\n        dispose: function () {\n            this.animation.stop();\n\n            this.clear();\n            this.storage.dispose();\n            this.painter.dispose();\n            this.handler.dispose();\n\n            this.animation =\n            this.storage =\n            this.painter =\n            this.handler = null;\n\n            delInstance(this.id);\n        }\n    };\n\n    module.exports = zrender;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL2hvbWUveXgvfi96cmVuZGVyL2xpYi96cmVuZGVyLmpzP2EwMmQiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBaUmVuZGVyLCBhIGhpZ2ggcGVyZm9ybWFuY2UgMmQgZHJhd2luZyBsaWJyYXJ5LlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMywgQmFpZHUgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMSUNFTlNFXG4gKiBodHRwczovL2dpdGh1Yi5jb20vZWNvbWZlL3pyZW5kZXIvYmxvYi9tYXN0ZXIvTElDRU5TRS50eHRcbiAqL1xuLy8gR2xvYmFsIGRlZmluZXNcblxuICAgIHZhciBndWlkID0gcmVxdWlyZSgnLi9jb3JlL2d1aWQnKTtcbiAgICB2YXIgZW52ID0gcmVxdWlyZSgnLi9jb3JlL2VudicpO1xuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCcuL2NvcmUvdXRpbCcpO1xuXG4gICAgdmFyIEhhbmRsZXIgPSByZXF1aXJlKCcuL0hhbmRsZXInKTtcbiAgICB2YXIgU3RvcmFnZSA9IHJlcXVpcmUoJy4vU3RvcmFnZScpO1xuICAgIHZhciBBbmltYXRpb24gPSByZXF1aXJlKCcuL2FuaW1hdGlvbi9BbmltYXRpb24nKTtcbiAgICB2YXIgSGFuZGxlclByb3h5ID0gcmVxdWlyZSgnLi9kb20vSGFuZGxlclByb3h5Jyk7XG5cbiAgICB2YXIgdXNlVk1MID0gIWVudi5jYW52YXNTdXBwb3J0ZWQ7XG5cbiAgICB2YXIgcGFpbnRlckN0b3JzID0ge1xuICAgICAgICBjYW52YXM6IHJlcXVpcmUoJy4vUGFpbnRlcicpXG4gICAgfTtcblxuICAgIHZhciBpbnN0YW5jZXMgPSB7fTsgICAgLy8gWlJlbmRlcuWunuS+i21hcOe0ouW8lVxuXG4gICAgdmFyIHpyZW5kZXIgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgenJlbmRlci52ZXJzaW9uID0gJzMuNC40JztcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemluZyBhIHpyZW5kZXIgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBkb21cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5yZW5kZXJlcj0nY2FudmFzJ10gJ2NhbnZhcycgb3IgJ3N2ZydcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdHMuZGV2aWNlUGl4ZWxSYXRpb11cbiAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtvcHRzLndpZHRoXSBDYW4gYmUgJ2F1dG8nICh0aGUgc2FtZSBhcyBudWxsL3VuZGVmaW5lZClcbiAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtvcHRzLmhlaWdodF0gQ2FuIGJlICdhdXRvJyAodGhlIHNhbWUgYXMgbnVsbC91bmRlZmluZWQpXG4gICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvWlJlbmRlcn1cbiAgICAgKi9cbiAgICB6cmVuZGVyLmluaXQgPSBmdW5jdGlvbihkb20sIG9wdHMpIHtcbiAgICAgICAgdmFyIHpyID0gbmV3IFpSZW5kZXIoZ3VpZCgpLCBkb20sIG9wdHMpO1xuICAgICAgICBpbnN0YW5jZXNbenIuaWRdID0genI7XG4gICAgICAgIHJldHVybiB6cjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGlzcG9zZSB6cmVuZGVyIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9aUmVuZGVyfSB6clxuICAgICAqL1xuICAgIHpyZW5kZXIuZGlzcG9zZSA9IGZ1bmN0aW9uICh6cikge1xuICAgICAgICBpZiAoenIpIHtcbiAgICAgICAgICAgIHpyLmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBpbnN0YW5jZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2VzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VzW2tleV0uZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluc3RhbmNlcyA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHpyZW5kZXI7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB6cmVuZGVyIGluc3RhbmNlIGJ5IGlkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIHpyZW5kZXIgaW5zdGFuY2UgaWRcbiAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9aUmVuZGVyfVxuICAgICAqL1xuICAgIHpyZW5kZXIuZ2V0SW5zdGFuY2UgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlc1tpZF07XG4gICAgfTtcblxuICAgIHpyZW5kZXIucmVnaXN0ZXJQYWludGVyID0gZnVuY3Rpb24gKG5hbWUsIEN0b3IpIHtcbiAgICAgICAgcGFpbnRlckN0b3JzW25hbWVdID0gQ3RvcjtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZGVsSW5zdGFuY2UoaWQpIHtcbiAgICAgICAgZGVsZXRlIGluc3RhbmNlc1tpZF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1vZHVsZSB6cmVuZGVyL1pSZW5kZXJcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvWlJlbmRlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZFxuICAgICAqIEBwYXJhbSB7SFRNTERvbUVsZW1lbnR9IGRvbVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLnJlbmRlcmVyPSdjYW52YXMnXSAnY2FudmFzJyBvciAnc3ZnJ1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy5kZXZpY2VQaXhlbFJhdGlvXVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy53aWR0aF0gQ2FuIGJlICdhdXRvJyAodGhlIHNhbWUgYXMgbnVsbC91bmRlZmluZWQpXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLmhlaWdodF0gQ2FuIGJlICdhdXRvJyAodGhlIHNhbWUgYXMgbnVsbC91bmRlZmluZWQpXG4gICAgICovXG4gICAgdmFyIFpSZW5kZXIgPSBmdW5jdGlvbihpZCwgZG9tLCBvcHRzKSB7XG5cbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtIVE1MRG9tRWxlbWVudH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZG9tID0gZG9tO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHN0b3JhZ2UgPSBuZXcgU3RvcmFnZSgpO1xuXG4gICAgICAgIHZhciByZW5kZXJlclR5cGUgPSBvcHRzLnJlbmRlcmVyO1xuICAgICAgICAvLyBUT0RPIFdlYkdMXG4gICAgICAgIGlmICh1c2VWTUwpIHtcbiAgICAgICAgICAgIGlmICghcGFpbnRlckN0b3JzLnZtbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG5lZWQgdG8gcmVxdWlyZSBcXCd6cmVuZGVyL3ZtbC92bWxcXCcgdG8gc3VwcG9ydCBJRTgnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlbmRlcmVyVHlwZSA9ICd2bWwnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFyZW5kZXJlclR5cGUgfHwgIXBhaW50ZXJDdG9yc1tyZW5kZXJlclR5cGVdKSB7XG4gICAgICAgICAgICByZW5kZXJlclR5cGUgPSAnY2FudmFzJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGFpbnRlciA9IG5ldyBwYWludGVyQ3RvcnNbcmVuZGVyZXJUeXBlXShkb20sIHN0b3JhZ2UsIG9wdHMpO1xuXG4gICAgICAgIHRoaXMuc3RvcmFnZSA9IHN0b3JhZ2U7XG4gICAgICAgIHRoaXMucGFpbnRlciA9IHBhaW50ZXI7XG5cbiAgICAgICAgdmFyIGhhbmRlclByb3h5ID0gIWVudi5ub2RlID8gbmV3IEhhbmRsZXJQcm94eShwYWludGVyLmdldFZpZXdwb3J0Um9vdCgpKSA6IG51bGw7XG4gICAgICAgIHRoaXMuaGFuZGxlciA9IG5ldyBIYW5kbGVyKHN0b3JhZ2UsIHBhaW50ZXIsIGhhbmRlclByb3h5LCBwYWludGVyLnJvb3QpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdGlvbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYW5pbWF0aW9uID0gbmV3IEFuaW1hdGlvbih7XG4gICAgICAgICAgICBzdGFnZToge1xuICAgICAgICAgICAgICAgIHVwZGF0ZTogenJVdGlsLmJpbmQodGhpcy5mbHVzaCwgdGhpcylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uLnN0YXJ0KCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbmVlZHNSZWZyZXNoO1xuXG4gICAgICAgIC8vIOS/ruaUuSBzdG9yYWdlLmRlbEZyb21TdG9yYWdlLCDmr4/mrKHliKDpmaTlhYPntKDkuYvliY3liKDpmaTliqjnlLtcbiAgICAgICAgLy8gRklYTUUg5pyJ54K5dWdseVxuICAgICAgICB2YXIgb2xkRGVsRnJvbVN0b3JhZ2UgPSBzdG9yYWdlLmRlbEZyb21TdG9yYWdlO1xuICAgICAgICB2YXIgb2xkQWRkVG9TdG9yYWdlID0gc3RvcmFnZS5hZGRUb1N0b3JhZ2U7XG5cbiAgICAgICAgc3RvcmFnZS5kZWxGcm9tU3RvcmFnZSA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgb2xkRGVsRnJvbVN0b3JhZ2UuY2FsbChzdG9yYWdlLCBlbCk7XG5cbiAgICAgICAgICAgIGVsICYmIGVsLnJlbW92ZVNlbGZGcm9tWnIoc2VsZik7XG4gICAgICAgIH07XG5cbiAgICAgICAgc3RvcmFnZS5hZGRUb1N0b3JhZ2UgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIG9sZEFkZFRvU3RvcmFnZS5jYWxsKHN0b3JhZ2UsIGVsKTtcblxuICAgICAgICAgICAgZWwuYWRkU2VsZlRvWnIoc2VsZik7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIFpSZW5kZXIucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBaUmVuZGVyLFxuICAgICAgICAvKipcbiAgICAgICAgICog6I635Y+W5a6e5L6L5ZSv5LiA5qCH6K+GXG4gICAgICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIGdldElkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pZDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5re75Yqg5YWD57SgXG4gICAgICAgICAqIEBwYXJhbSAge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGVsXG4gICAgICAgICAqL1xuICAgICAgICBhZGQ6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgdGhpcy5zdG9yYWdlLmFkZFJvb3QoZWwpO1xuICAgICAgICAgICAgdGhpcy5fbmVlZHNSZWZyZXNoID0gdHJ1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5Yig6Zmk5YWD57SgXG4gICAgICAgICAqIEBwYXJhbSAge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGVsXG4gICAgICAgICAqL1xuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgdGhpcy5zdG9yYWdlLmRlbFJvb3QoZWwpO1xuICAgICAgICAgICAgdGhpcy5fbmVlZHNSZWZyZXNoID0gdHJ1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2hhbmdlIGNvbmZpZ3VyYXRpb24gb2YgbGF5ZXJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHpMZXZlbFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY29uZmlnLmNsZWFyQ29sb3I9MF0gQ2xlYXIgY29sb3JcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtjb25maWcubW90aW9uQmx1cj1mYWxzZV0gSWYgZW5hYmxlIG1vdGlvbiBibHVyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbY29uZmlnLmxhc3RGcmFtZUFscGhhPTAuN10gTW90aW9uIGJsdXIgZmFjdG9yLiBMYXJnZXIgdmFsdWUgY2F1c2UgbG9uZ2VyIHRyYWlsZXJcbiAgICAgICAgKi9cbiAgICAgICAgY29uZmlnTGF5ZXI6IGZ1bmN0aW9uICh6TGV2ZWwsIGNvbmZpZykge1xuICAgICAgICAgICAgdGhpcy5wYWludGVyLmNvbmZpZ0xheWVyKHpMZXZlbCwgY29uZmlnKTtcbiAgICAgICAgICAgIHRoaXMuX25lZWRzUmVmcmVzaCA9IHRydWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlcGFpbnQgdGhlIGNhbnZhcyBpbW1lZGlhdGVseVxuICAgICAgICAgKi9cbiAgICAgICAgcmVmcmVzaEltbWVkaWF0ZWx5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBDbGVhciBuZWVkc1JlZnJlc2ggYWhlYWQgdG8gYXZvaWQgc29tZXRoaW5nIHdyb25nIGhhcHBlbnMgaW4gcmVmcmVzaFxuICAgICAgICAgICAgLy8gT3IgaXQgd2lsbCBjYXVzZSB6cmVuZGVyIHJlZnJlc2hlcyBhZ2FpbiBhbmQgYWdhaW4uXG4gICAgICAgICAgICB0aGlzLl9uZWVkc1JlZnJlc2ggPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMucGFpbnRlci5yZWZyZXNoKCk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEF2b2lkIHRyaWdnZXIgenIucmVmcmVzaCBpbiBFbGVtZW50I2JlZm9yZVVwZGF0ZSBob29rXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuX25lZWRzUmVmcmVzaCA9IGZhbHNlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYXJrIGFuZCByZXBhaW50IHRoZSBjYW52YXMgaW4gdGhlIG5leHQgZnJhbWUgb2YgYnJvd3NlclxuICAgICAgICAgKi9cbiAgICAgICAgcmVmcmVzaDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLl9uZWVkc1JlZnJlc2ggPSB0cnVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQZXJmb3JtIGFsbCByZWZyZXNoXG4gICAgICAgICAqL1xuICAgICAgICBmbHVzaDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX25lZWRzUmVmcmVzaCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVmcmVzaEltbWVkaWF0ZWx5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fbmVlZHNSZWZyZXNoSG92ZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZnJlc2hIb3ZlckltbWVkaWF0ZWx5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZCBlbGVtZW50IHRvIGhvdmVyIGxheWVyXG4gICAgICAgICAqIEBwYXJhbSAge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGVsXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZVxuICAgICAgICAgKi9cbiAgICAgICAgYWRkSG92ZXI6IGZ1bmN0aW9uIChlbCwgc3R5bGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBhaW50ZXIuYWRkSG92ZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhaW50ZXIuYWRkSG92ZXIoZWwsIHN0eWxlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZnJlc2hIb3ZlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGQgZWxlbWVudCBmcm9tIGhvdmVyIGxheWVyXG4gICAgICAgICAqIEBwYXJhbSAge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGVsXG4gICAgICAgICAqL1xuICAgICAgICByZW1vdmVIb3ZlcjogZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wYWludGVyLnJlbW92ZUhvdmVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYWludGVyLnJlbW92ZUhvdmVyKGVsKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZnJlc2hIb3ZlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDbGVhciBhbGwgaG92ZXIgZWxlbWVudHMgaW4gaG92ZXIgbGF5ZXJcbiAgICAgICAgICogQHBhcmFtICB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gZWxcbiAgICAgICAgICovXG4gICAgICAgIGNsZWFySG92ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBhaW50ZXIuY2xlYXJIb3Zlcikge1xuICAgICAgICAgICAgICAgIHRoaXMucGFpbnRlci5jbGVhckhvdmVyKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoSG92ZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVmcmVzaCBob3ZlciBpbiBuZXh0IGZyYW1lXG4gICAgICAgICAqL1xuICAgICAgICByZWZyZXNoSG92ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX25lZWRzUmVmcmVzaEhvdmVyID0gdHJ1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVmcmVzaCBob3ZlciBpbW1lZGlhdGVseVxuICAgICAgICAgKi9cbiAgICAgICAgcmVmcmVzaEhvdmVySW1tZWRpYXRlbHk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX25lZWRzUmVmcmVzaEhvdmVyID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnBhaW50ZXIucmVmcmVzaEhvdmVyICYmIHRoaXMucGFpbnRlci5yZWZyZXNoSG92ZXIoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVzaXplIHRoZSBjYW52YXMuXG4gICAgICAgICAqIFNob3VsZCBiZSBpbnZva2VkIHdoZW4gY29udGFpbmVyIHNpemUgaXMgY2hhbmdlZFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdHNdXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW29wdHMud2lkdGhdIENhbiBiZSAnYXV0bycgKHRoZSBzYW1lIGFzIG51bGwvdW5kZWZpbmVkKVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtvcHRzLmhlaWdodF0gQ2FuIGJlICdhdXRvJyAodGhlIHNhbWUgYXMgbnVsbC91bmRlZmluZWQpXG4gICAgICAgICAqL1xuICAgICAgICByZXNpemU6IGZ1bmN0aW9uKG9wdHMpIHtcbiAgICAgICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgICAgICAgICAgdGhpcy5wYWludGVyLnJlc2l6ZShvcHRzLndpZHRoLCBvcHRzLmhlaWdodCk7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZXIucmVzaXplKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0b3AgYW5kIGNsZWFyIGFsbCBhbmltYXRpb24gaW1tZWRpYXRlbHlcbiAgICAgICAgICovXG4gICAgICAgIGNsZWFyQW5pbWF0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvbi5jbGVhcigpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgY29udGFpbmVyIHdpZHRoXG4gICAgICAgICAqL1xuICAgICAgICBnZXRXaWR0aDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYWludGVyLmdldFdpZHRoKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBjb250YWluZXIgaGVpZ2h0XG4gICAgICAgICAqL1xuICAgICAgICBnZXRIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFpbnRlci5nZXRIZWlnaHQoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRXhwb3J0IHRoZSBjYW52YXMgYXMgQmFzZTY0IFVSTFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2JhY2tncm91bmRDb2xvcj0nI2ZmZiddXG4gICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gQmFzZTY0IFVSTFxuICAgICAgICAgKi9cbiAgICAgICAgLy8gdG9EYXRhVVJMOiBmdW5jdGlvbih0eXBlLCBiYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgICAgLy8gICAgIHJldHVybiB0aGlzLnBhaW50ZXIuZ2V0UmVuZGVyZWRDYW52YXMoe1xuICAgICAgICAvLyAgICAgICAgIGJhY2tncm91bmRDb2xvcjogYmFja2dyb3VuZENvbG9yXG4gICAgICAgIC8vICAgICB9KS50b0RhdGFVUkwodHlwZSk7XG4gICAgICAgIC8vIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnRpbmcgYSBwYXRoIHRvIGltYWdlLlxuICAgICAgICAgKiBJdCBoYXMgbXVjaCBiZXR0ZXIgcGVyZm9ybWFuY2Ugb2YgZHJhd2luZyBpbWFnZSByYXRoZXIgdGhhbiBkcmF3aW5nIGEgdmVjdG9yIHBhdGguXG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9QYXRofSBlXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0XG4gICAgICAgICAqL1xuICAgICAgICBwYXRoVG9JbWFnZTogZnVuY3Rpb24oZSwgZHByKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYWludGVyLnBhdGhUb0ltYWdlKGUsIGRwcik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCBkZWZhdWx0IGN1cnNvclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2N1cnNvclN0eWxlPSdkZWZhdWx0J10g5L6L5aaCIGNyb3NzaGFpclxuICAgICAgICAgKi9cbiAgICAgICAgc2V0Q3Vyc29yU3R5bGU6IGZ1bmN0aW9uIChjdXJzb3JTdHlsZSkge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVyLnNldEN1cnNvclN0eWxlKGN1cnNvclN0eWxlKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRmluZCBob3ZlcmVkIGVsZW1lbnRcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSB7dGFyZ2V0LCB0b3BUYXJnZXR9XG4gICAgICAgICAqL1xuICAgICAgICBmaW5kSG92ZXI6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVyLmZpbmRIb3Zlcih4LCB5KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQmluZCBldmVudFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIEV2ZW50IG5hbWVcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXZlbnRIYW5kbGVyIEhhbmRsZXIgZnVuY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0XSBDb250ZXh0IG9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgb246IGZ1bmN0aW9uKGV2ZW50TmFtZSwgZXZlbnRIYW5kbGVyLCBjb250ZXh0KSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZXIub24oZXZlbnROYW1lLCBldmVudEhhbmRsZXIsIGNvbnRleHQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVbmJpbmQgZXZlbnRcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBFdmVudCBuYW1lXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtldmVudEhhbmRsZXJdIEhhbmRsZXIgZnVuY3Rpb25cbiAgICAgICAgICovXG4gICAgICAgIG9mZjogZnVuY3Rpb24oZXZlbnROYW1lLCBldmVudEhhbmRsZXIpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlci5vZmYoZXZlbnROYW1lLCBldmVudEhhbmRsZXIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcmlnZ2VyIGV2ZW50IG1hbnVhbGx5XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgRXZlbnQgbmFtZVxuICAgICAgICAgKiBAcGFyYW0ge2V2ZW50PX0gZXZlbnQgRXZlbnQgb2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICB0cmlnZ2VyOiBmdW5jdGlvbiAoZXZlbnROYW1lLCBldmVudCkge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVyLnRyaWdnZXIoZXZlbnROYW1lLCBldmVudCk7XG4gICAgICAgIH0sXG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2xlYXIgYWxsIG9iamVjdHMgYW5kIHRoZSBjYW52YXMuXG4gICAgICAgICAqL1xuICAgICAgICBjbGVhcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5zdG9yYWdlLmRlbFJvb3QoKTtcbiAgICAgICAgICAgIHRoaXMucGFpbnRlci5jbGVhcigpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNwb3NlIHNlbGYuXG4gICAgICAgICAqL1xuICAgICAgICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvbi5zdG9wKCk7XG5cbiAgICAgICAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgICAgICAgIHRoaXMuc3RvcmFnZS5kaXNwb3NlKCk7XG4gICAgICAgICAgICB0aGlzLnBhaW50ZXIuZGlzcG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVyLmRpc3Bvc2UoKTtcblxuICAgICAgICAgICAgdGhpcy5hbmltYXRpb24gPVxuICAgICAgICAgICAgdGhpcy5zdG9yYWdlID1cbiAgICAgICAgICAgIHRoaXMucGFpbnRlciA9XG4gICAgICAgICAgICB0aGlzLmhhbmRsZXIgPSBudWxsO1xuXG4gICAgICAgICAgICBkZWxJbnN0YW5jZSh0aGlzLmlkKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHpyZW5kZXI7XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9ob21lL3l4L34venJlbmRlci9saWIvenJlbmRlci5qc1xuLy8gbW9kdWxlIGlkID0gNzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 80 */
/* unknown exports provided */
/* all exports used */
/*!***************************************************!*\
  !*** ./lib/component/axis/cartesianAxisHelper.js ***!
  \***************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 0);\n\n    var helper = {};\n\n    /**\n     * @param {Object} opt {labelInside}\n     * @return {Object} {\n     *  position, rotation, labelDirection, labelOffset,\n     *  tickDirection, labelRotate, labelInterval, z2\n     * }\n     */\n    helper.layout = function (gridModel, axisModel, opt) {\n        opt = opt || {};\n        var grid = gridModel.coordinateSystem;\n        var axis = axisModel.axis;\n        var layout = {};\n\n        var rawAxisPosition = axis.position;\n        var axisPosition = axis.onZero ? 'onZero' : rawAxisPosition;\n        var axisDim = axis.dim;\n\n        // [left, right, top, bottom]\n        var rect = grid.getRect();\n        var rectBound = [rect.x, rect.x + rect.width, rect.y, rect.y + rect.height];\n\n        var axisOffset = axisModel.get('offset') || 0;\n\n        var posMap = {\n            x: { top: rectBound[2] - axisOffset, bottom: rectBound[3] + axisOffset },\n            y: { left: rectBound[0] - axisOffset, right: rectBound[1] + axisOffset }\n        };\n\n        posMap.x.onZero = Math.max(Math.min(getZero('y'), posMap.x.bottom), posMap.x.top);\n        posMap.y.onZero = Math.max(Math.min(getZero('x'), posMap.y.right), posMap.y.left);\n\n        function getZero(dim, val) {\n            var theAxis = grid.getAxis(dim);\n            return theAxis.toGlobalCoord(theAxis.dataToCoord(0));\n        }\n\n        // Axis position\n        layout.position = [\n            axisDim === 'y' ? posMap.y[axisPosition] : rectBound[0],\n            axisDim === 'x' ? posMap.x[axisPosition] : rectBound[3]\n        ];\n\n        // Axis rotation\n        layout.rotation = Math.PI / 2 * (axisDim === 'x' ? 0 : 1);\n\n        // Tick and label direction, x y is axisDim\n        var dirMap = {top: -1, bottom: 1, left: -1, right: 1};\n\n        layout.labelDirection = layout.tickDirection = layout.nameDirection = dirMap[rawAxisPosition];\n        layout.labelOffset = axis.onZero ? posMap[axisDim][rawAxisPosition] - posMap[axisDim].onZero : 0;\n\n        if (axisModel.get('axisTick.inside')) {\n            layout.tickDirection = -layout.tickDirection;\n        }\n        if (zrUtil.retrieve(opt.labelInside, axisModel.get('axisLabel.inside'))) {\n            layout.labelDirection = -layout.labelDirection;\n        }\n\n        // Special label rotation\n        var labelRotate = axisModel.get('axisLabel.rotate');\n        layout.labelRotate = axisPosition === 'top' ? -labelRotate : labelRotate;\n\n        // label interval when auto mode.\n        layout.labelInterval = axis.getLabelInterval();\n\n        // Over splitLine and splitArea\n        layout.z2 = 1;\n\n        return layout;\n    };\n\n    module.exports = helper;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvY29tcG9uZW50L2F4aXMvY2FydGVzaWFuQXhpc0hlbHBlci5qcz9lNzVkIl0sInNvdXJjZXNDb250ZW50IjpbIlxuXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuXG4gICAgdmFyIGhlbHBlciA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdCB7bGFiZWxJbnNpZGV9XG4gICAgICogQHJldHVybiB7T2JqZWN0fSB7XG4gICAgICogIHBvc2l0aW9uLCByb3RhdGlvbiwgbGFiZWxEaXJlY3Rpb24sIGxhYmVsT2Zmc2V0LFxuICAgICAqICB0aWNrRGlyZWN0aW9uLCBsYWJlbFJvdGF0ZSwgbGFiZWxJbnRlcnZhbCwgejJcbiAgICAgKiB9XG4gICAgICovXG4gICAgaGVscGVyLmxheW91dCA9IGZ1bmN0aW9uIChncmlkTW9kZWwsIGF4aXNNb2RlbCwgb3B0KSB7XG4gICAgICAgIG9wdCA9IG9wdCB8fCB7fTtcbiAgICAgICAgdmFyIGdyaWQgPSBncmlkTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcbiAgICAgICAgdmFyIGF4aXMgPSBheGlzTW9kZWwuYXhpcztcbiAgICAgICAgdmFyIGxheW91dCA9IHt9O1xuXG4gICAgICAgIHZhciByYXdBeGlzUG9zaXRpb24gPSBheGlzLnBvc2l0aW9uO1xuICAgICAgICB2YXIgYXhpc1Bvc2l0aW9uID0gYXhpcy5vblplcm8gPyAnb25aZXJvJyA6IHJhd0F4aXNQb3NpdGlvbjtcbiAgICAgICAgdmFyIGF4aXNEaW0gPSBheGlzLmRpbTtcblxuICAgICAgICAvLyBbbGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tXVxuICAgICAgICB2YXIgcmVjdCA9IGdyaWQuZ2V0UmVjdCgpO1xuICAgICAgICB2YXIgcmVjdEJvdW5kID0gW3JlY3QueCwgcmVjdC54ICsgcmVjdC53aWR0aCwgcmVjdC55LCByZWN0LnkgKyByZWN0LmhlaWdodF07XG5cbiAgICAgICAgdmFyIGF4aXNPZmZzZXQgPSBheGlzTW9kZWwuZ2V0KCdvZmZzZXQnKSB8fCAwO1xuXG4gICAgICAgIHZhciBwb3NNYXAgPSB7XG4gICAgICAgICAgICB4OiB7IHRvcDogcmVjdEJvdW5kWzJdIC0gYXhpc09mZnNldCwgYm90dG9tOiByZWN0Qm91bmRbM10gKyBheGlzT2Zmc2V0IH0sXG4gICAgICAgICAgICB5OiB7IGxlZnQ6IHJlY3RCb3VuZFswXSAtIGF4aXNPZmZzZXQsIHJpZ2h0OiByZWN0Qm91bmRbMV0gKyBheGlzT2Zmc2V0IH1cbiAgICAgICAgfTtcblxuICAgICAgICBwb3NNYXAueC5vblplcm8gPSBNYXRoLm1heChNYXRoLm1pbihnZXRaZXJvKCd5JyksIHBvc01hcC54LmJvdHRvbSksIHBvc01hcC54LnRvcCk7XG4gICAgICAgIHBvc01hcC55Lm9uWmVybyA9IE1hdGgubWF4KE1hdGgubWluKGdldFplcm8oJ3gnKSwgcG9zTWFwLnkucmlnaHQpLCBwb3NNYXAueS5sZWZ0KTtcblxuICAgICAgICBmdW5jdGlvbiBnZXRaZXJvKGRpbSwgdmFsKSB7XG4gICAgICAgICAgICB2YXIgdGhlQXhpcyA9IGdyaWQuZ2V0QXhpcyhkaW0pO1xuICAgICAgICAgICAgcmV0dXJuIHRoZUF4aXMudG9HbG9iYWxDb29yZCh0aGVBeGlzLmRhdGFUb0Nvb3JkKDApKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEF4aXMgcG9zaXRpb25cbiAgICAgICAgbGF5b3V0LnBvc2l0aW9uID0gW1xuICAgICAgICAgICAgYXhpc0RpbSA9PT0gJ3knID8gcG9zTWFwLnlbYXhpc1Bvc2l0aW9uXSA6IHJlY3RCb3VuZFswXSxcbiAgICAgICAgICAgIGF4aXNEaW0gPT09ICd4JyA/IHBvc01hcC54W2F4aXNQb3NpdGlvbl0gOiByZWN0Qm91bmRbM11cbiAgICAgICAgXTtcblxuICAgICAgICAvLyBBeGlzIHJvdGF0aW9uXG4gICAgICAgIGxheW91dC5yb3RhdGlvbiA9IE1hdGguUEkgLyAyICogKGF4aXNEaW0gPT09ICd4JyA/IDAgOiAxKTtcblxuICAgICAgICAvLyBUaWNrIGFuZCBsYWJlbCBkaXJlY3Rpb24sIHggeSBpcyBheGlzRGltXG4gICAgICAgIHZhciBkaXJNYXAgPSB7dG9wOiAtMSwgYm90dG9tOiAxLCBsZWZ0OiAtMSwgcmlnaHQ6IDF9O1xuXG4gICAgICAgIGxheW91dC5sYWJlbERpcmVjdGlvbiA9IGxheW91dC50aWNrRGlyZWN0aW9uID0gbGF5b3V0Lm5hbWVEaXJlY3Rpb24gPSBkaXJNYXBbcmF3QXhpc1Bvc2l0aW9uXTtcbiAgICAgICAgbGF5b3V0LmxhYmVsT2Zmc2V0ID0gYXhpcy5vblplcm8gPyBwb3NNYXBbYXhpc0RpbV1bcmF3QXhpc1Bvc2l0aW9uXSAtIHBvc01hcFtheGlzRGltXS5vblplcm8gOiAwO1xuXG4gICAgICAgIGlmIChheGlzTW9kZWwuZ2V0KCdheGlzVGljay5pbnNpZGUnKSkge1xuICAgICAgICAgICAgbGF5b3V0LnRpY2tEaXJlY3Rpb24gPSAtbGF5b3V0LnRpY2tEaXJlY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHpyVXRpbC5yZXRyaWV2ZShvcHQubGFiZWxJbnNpZGUsIGF4aXNNb2RlbC5nZXQoJ2F4aXNMYWJlbC5pbnNpZGUnKSkpIHtcbiAgICAgICAgICAgIGxheW91dC5sYWJlbERpcmVjdGlvbiA9IC1sYXlvdXQubGFiZWxEaXJlY3Rpb247XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTcGVjaWFsIGxhYmVsIHJvdGF0aW9uXG4gICAgICAgIHZhciBsYWJlbFJvdGF0ZSA9IGF4aXNNb2RlbC5nZXQoJ2F4aXNMYWJlbC5yb3RhdGUnKTtcbiAgICAgICAgbGF5b3V0LmxhYmVsUm90YXRlID0gYXhpc1Bvc2l0aW9uID09PSAndG9wJyA/IC1sYWJlbFJvdGF0ZSA6IGxhYmVsUm90YXRlO1xuXG4gICAgICAgIC8vIGxhYmVsIGludGVydmFsIHdoZW4gYXV0byBtb2RlLlxuICAgICAgICBsYXlvdXQubGFiZWxJbnRlcnZhbCA9IGF4aXMuZ2V0TGFiZWxJbnRlcnZhbCgpO1xuXG4gICAgICAgIC8vIE92ZXIgc3BsaXRMaW5lIGFuZCBzcGxpdEFyZWFcbiAgICAgICAgbGF5b3V0LnoyID0gMTtcblxuICAgICAgICByZXR1cm4gbGF5b3V0O1xuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGhlbHBlcjtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvY29tcG9uZW50L2F4aXMvY2FydGVzaWFuQXhpc0hlbHBlci5qc1xuLy8gbW9kdWxlIGlkID0gODBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 81 */
/* unknown exports provided */
/* all exports used */
/*!*************************************************!*\
  !*** ./lib/component/axisPointer/viewHelper.js ***!
  \*************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\n    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 0);\n    var graphic = __webpack_require__(/*! ../../util/graphic */ 2);\n    var textContain = __webpack_require__(/*! zrender/lib/contain/text */ 15);\n    var formatUtil = __webpack_require__(/*! ../../util/format */ 6);\n    var matrix = __webpack_require__(/*! zrender/lib/core/matrix */ 18);\n    var axisHelper = __webpack_require__(/*! ../../coord/axisHelper */ 16);\n    var AxisBuilder = __webpack_require__(/*! ../axis/AxisBuilder */ 39);\n\n    var helper = {};\n\n    /**\n     * @param {module:echarts/model/Model} axisPointerModel\n     */\n    helper.buildElStyle = function (axisPointerModel) {\n        var axisPointerType = axisPointerModel.get('type');\n        var styleModel = axisPointerModel.getModel(axisPointerType + 'Style');\n        var style;\n        if (axisPointerType === 'line') {\n            style = styleModel.getLineStyle();\n            style.fill = null;\n        }\n        else if (axisPointerType === 'shadow') {\n            style = styleModel.getAreaStyle();\n            style.stroke = null;\n        }\n        return style;\n    };\n\n    /**\n     * @param {Function} labelPos {align, verticalAlign, position}\n     */\n    helper.buildLabelElOption = function (\n        elOption, axisModel, axisPointerModel, api, labelPos\n    ) {\n        var value = axisPointerModel.get('value');\n        var text = helper.getValueLabel(\n            value, axisModel.axis, axisModel.ecModel,\n            axisPointerModel.get('seriesDataIndices'),\n            {\n                precision: axisPointerModel.get('label.precision'),\n                formatter: axisPointerModel.get('label.formatter')\n            }\n        );\n        var labelModel = axisPointerModel.getModel('label');\n        var textStyleModel = labelModel.getModel('textStyle');\n        var paddings = formatUtil.normalizeCssArray(labelModel.get('padding') || 0);\n\n        var font = textStyleModel.getFont();\n        var textRect = textContain.getBoundingRect(\n            text, font, labelPos.textAlign, labelPos.textBaseline\n        );\n\n        var position = labelPos.position;\n        var width = textRect.width + paddings[1] + paddings[3];\n        var height = textRect.height + paddings[0] + paddings[2];\n\n        // Adjust by align.\n        var align = labelPos.align;\n        align === 'right' && (position[0] -= width);\n        align === 'center' && (position[0] -= width / 2);\n        var verticalAlign = labelPos.verticalAlign;\n        verticalAlign === 'bottom' && (position[1] -= height);\n        verticalAlign === 'middle' && (position[1] -= height / 2);\n\n        // Not overflow ec container\n        confineInContainer(position, width, height, api);\n\n        var bgColor = labelModel.get('backgroundColor');\n        if (!bgColor || bgColor === 'auto') {\n            bgColor = axisModel.get('axisLine.lineStyle.color');\n        }\n\n        elOption.label = {\n            shape: {x: 0, y: 0, width: width, height: height, r: labelModel.get('borderRadius')},\n            position: position.slice(),\n            style: {\n                text: text,\n                textFont: font,\n                textFill: textStyleModel.getTextColor(),\n                textPosition: 'inside',\n                fill: bgColor,\n                stroke: labelModel.get('borderColor') || 'transparent',\n                lineWidth: labelModel.get('borderWidth') || 0,\n                shadowBlur: labelModel.get('shadowBlur'),\n                shadowColor: labelModel.get('shadowColor'),\n                shadowOffsetX: labelModel.get('shadowOffsetX'),\n                shadowOffsetY: labelModel.get('shadowOffsetY')\n            },\n            // Lable should be over axisPointer.\n            z2: 10\n        };\n    };\n\n    // Do not overflow ec container\n    function confineInContainer(position, width, height, api) {\n        var viewWidth = api.getWidth();\n        var viewHeight = api.getHeight();\n        position[0] = Math.min(position[0] + width, viewWidth) - width;\n        position[1] = Math.min(position[1] + height, viewHeight) - height;\n        position[0] = Math.max(position[0], 0);\n        position[1] = Math.max(position[1], 0);\n    }\n\n    /**\n     * @param {number} value\n     * @param {module:echarts/coord/Axis} axis\n     * @param {module:echarts/model/Global} ecModel\n     * @param {Object} opt\n     * @param {Array.<Object>} seriesDataIndices\n     * @param {number|string} opt.precision 'auto' or a number\n     * @param {string|Function} opt.formatter label formatter\n     */\n    helper.getValueLabel = function (value, axis, ecModel, seriesDataIndices, opt) {\n        var text = axis.scale.getLabel(\n            // If `precision` is set, width can be fixed (like '12.00500'), which\n            // helps to debounce when when moving label.\n            value, {precision: opt.precision}\n        );\n        var formatter = opt.formatter;\n\n        if (formatter) {\n            var params = {\n                value: axisHelper.getAxisRawValue(axis, value),\n                seriesData: []\n            };\n            zrUtil.each(seriesDataIndices, function (idxItem) {\n                var series = ecModel.getSeriesByIndex(idxItem.seriesIndex);\n                var dataIndex = idxItem.dataIndexInside;\n                var dataParams = series && series.getDataParams(dataIndex);\n                dataParams && params.seriesData.push(dataParams);\n            });\n\n            if (zrUtil.isString(formatter)) {\n                text = formatter.replace('{value}', text);\n            }\n            else if (zrUtil.isFunction(formatter)) {\n                text = formatter(params);\n            }\n        }\n\n        return text;\n    };\n\n    /**\n     * @param {module:echarts/coord/Axis} axis\n     * @param {number} value\n     * @param {Object} layoutInfo {\n     *  rotation, position, labelOffset, labelDirection, labelMargin\n     * }\n     */\n    helper.getTransformedPosition = function (axis, value, layoutInfo) {\n        var transform = matrix.create();\n        matrix.rotate(transform, transform, layoutInfo.rotation);\n        matrix.translate(transform, transform, layoutInfo.position);\n\n        return graphic.applyTransform([\n            axis.dataToCoord(value),\n            (layoutInfo.labelOffset || 0)\n                + (layoutInfo.labelDirection || 1) * (layoutInfo.labelMargin || 0)\n        ], transform);\n    };\n\n    helper.buildCartesianSingleLabelElOption = function (\n        value, elOption, layoutInfo, axisModel, axisPointerModel, api\n    ) {\n        var textLayout = AxisBuilder.innerTextLayout(\n            layoutInfo.rotation, 0, layoutInfo.labelDirection\n        );\n        layoutInfo.labelMargin = axisPointerModel.get('label.margin');\n        helper.buildLabelElOption(elOption, axisModel, axisPointerModel, api, {\n            position: helper.getTransformedPosition(axisModel.axis, value, layoutInfo),\n            align: textLayout.textAlign,\n            verticalAlign: textLayout.textVerticalAlign\n        });\n    };\n\n    /**\n     * @param {Array.<number>} p1\n     * @param {Array.<number>} p2\n     * @param {number} [xDimIndex=0] or 1\n     */\n    helper.makeLineShape = function (p1, p2, xDimIndex) {\n        xDimIndex = xDimIndex || 0;\n        return {\n            x1: p1[xDimIndex],\n            y1: p1[1 - xDimIndex],\n            x2: p2[xDimIndex],\n            y2: p2[1 - xDimIndex]\n        };\n    };\n\n    /**\n     * @param {Array.<number>} xy\n     * @param {Array.<number>} wh\n     * @param {number} [xDimIndex=0] or 1\n     */\n    helper.makeRectShape = function (xy, wh, xDimIndex) {\n        xDimIndex = xDimIndex || 0;\n        return {\n            x: xy[xDimIndex],\n            y: xy[1 - xDimIndex],\n            width: wh[xDimIndex],\n            height: wh[1 - xDimIndex]\n        };\n    };\n\n    helper.makeSectorShape = function (cx, cy, r0, r, startAngle, endAngle) {\n        return {\n            cx: cx,\n            cy: cy,\n            r0: r0,\n            r: r,\n            startAngle: startAngle,\n            endAngle: endAngle,\n            clockwise: true\n        };\n    };\n\n    module.exports = helper;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvY29tcG9uZW50L2F4aXNQb2ludGVyL3ZpZXdIZWxwZXIuanM/MWViMCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvZ3JhcGhpYycpO1xuICAgIHZhciB0ZXh0Q29udGFpbiA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvbnRhaW4vdGV4dCcpO1xuICAgIHZhciBmb3JtYXRVdGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9mb3JtYXQnKTtcbiAgICB2YXIgbWF0cml4ID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS9tYXRyaXgnKTtcbiAgICB2YXIgYXhpc0hlbHBlciA9IHJlcXVpcmUoJy4uLy4uL2Nvb3JkL2F4aXNIZWxwZXInKTtcbiAgICB2YXIgQXhpc0J1aWxkZXIgPSByZXF1aXJlKCcuLi9heGlzL0F4aXNCdWlsZGVyJyk7XG5cbiAgICB2YXIgaGVscGVyID0ge307XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBheGlzUG9pbnRlck1vZGVsXG4gICAgICovXG4gICAgaGVscGVyLmJ1aWxkRWxTdHlsZSA9IGZ1bmN0aW9uIChheGlzUG9pbnRlck1vZGVsKSB7XG4gICAgICAgIHZhciBheGlzUG9pbnRlclR5cGUgPSBheGlzUG9pbnRlck1vZGVsLmdldCgndHlwZScpO1xuICAgICAgICB2YXIgc3R5bGVNb2RlbCA9IGF4aXNQb2ludGVyTW9kZWwuZ2V0TW9kZWwoYXhpc1BvaW50ZXJUeXBlICsgJ1N0eWxlJyk7XG4gICAgICAgIHZhciBzdHlsZTtcbiAgICAgICAgaWYgKGF4aXNQb2ludGVyVHlwZSA9PT0gJ2xpbmUnKSB7XG4gICAgICAgICAgICBzdHlsZSA9IHN0eWxlTW9kZWwuZ2V0TGluZVN0eWxlKCk7XG4gICAgICAgICAgICBzdHlsZS5maWxsID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChheGlzUG9pbnRlclR5cGUgPT09ICdzaGFkb3cnKSB7XG4gICAgICAgICAgICBzdHlsZSA9IHN0eWxlTW9kZWwuZ2V0QXJlYVN0eWxlKCk7XG4gICAgICAgICAgICBzdHlsZS5zdHJva2UgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHlsZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGFiZWxQb3Mge2FsaWduLCB2ZXJ0aWNhbEFsaWduLCBwb3NpdGlvbn1cbiAgICAgKi9cbiAgICBoZWxwZXIuYnVpbGRMYWJlbEVsT3B0aW9uID0gZnVuY3Rpb24gKFxuICAgICAgICBlbE9wdGlvbiwgYXhpc01vZGVsLCBheGlzUG9pbnRlck1vZGVsLCBhcGksIGxhYmVsUG9zXG4gICAgKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGF4aXNQb2ludGVyTW9kZWwuZ2V0KCd2YWx1ZScpO1xuICAgICAgICB2YXIgdGV4dCA9IGhlbHBlci5nZXRWYWx1ZUxhYmVsKFxuICAgICAgICAgICAgdmFsdWUsIGF4aXNNb2RlbC5heGlzLCBheGlzTW9kZWwuZWNNb2RlbCxcbiAgICAgICAgICAgIGF4aXNQb2ludGVyTW9kZWwuZ2V0KCdzZXJpZXNEYXRhSW5kaWNlcycpLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHByZWNpc2lvbjogYXhpc1BvaW50ZXJNb2RlbC5nZXQoJ2xhYmVsLnByZWNpc2lvbicpLFxuICAgICAgICAgICAgICAgIGZvcm1hdHRlcjogYXhpc1BvaW50ZXJNb2RlbC5nZXQoJ2xhYmVsLmZvcm1hdHRlcicpXG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICAgIHZhciBsYWJlbE1vZGVsID0gYXhpc1BvaW50ZXJNb2RlbC5nZXRNb2RlbCgnbGFiZWwnKTtcbiAgICAgICAgdmFyIHRleHRTdHlsZU1vZGVsID0gbGFiZWxNb2RlbC5nZXRNb2RlbCgndGV4dFN0eWxlJyk7XG4gICAgICAgIHZhciBwYWRkaW5ncyA9IGZvcm1hdFV0aWwubm9ybWFsaXplQ3NzQXJyYXkobGFiZWxNb2RlbC5nZXQoJ3BhZGRpbmcnKSB8fCAwKTtcblxuICAgICAgICB2YXIgZm9udCA9IHRleHRTdHlsZU1vZGVsLmdldEZvbnQoKTtcbiAgICAgICAgdmFyIHRleHRSZWN0ID0gdGV4dENvbnRhaW4uZ2V0Qm91bmRpbmdSZWN0KFxuICAgICAgICAgICAgdGV4dCwgZm9udCwgbGFiZWxQb3MudGV4dEFsaWduLCBsYWJlbFBvcy50ZXh0QmFzZWxpbmVcbiAgICAgICAgKTtcblxuICAgICAgICB2YXIgcG9zaXRpb24gPSBsYWJlbFBvcy5wb3NpdGlvbjtcbiAgICAgICAgdmFyIHdpZHRoID0gdGV4dFJlY3Qud2lkdGggKyBwYWRkaW5nc1sxXSArIHBhZGRpbmdzWzNdO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gdGV4dFJlY3QuaGVpZ2h0ICsgcGFkZGluZ3NbMF0gKyBwYWRkaW5nc1syXTtcblxuICAgICAgICAvLyBBZGp1c3QgYnkgYWxpZ24uXG4gICAgICAgIHZhciBhbGlnbiA9IGxhYmVsUG9zLmFsaWduO1xuICAgICAgICBhbGlnbiA9PT0gJ3JpZ2h0JyAmJiAocG9zaXRpb25bMF0gLT0gd2lkdGgpO1xuICAgICAgICBhbGlnbiA9PT0gJ2NlbnRlcicgJiYgKHBvc2l0aW9uWzBdIC09IHdpZHRoIC8gMik7XG4gICAgICAgIHZhciB2ZXJ0aWNhbEFsaWduID0gbGFiZWxQb3MudmVydGljYWxBbGlnbjtcbiAgICAgICAgdmVydGljYWxBbGlnbiA9PT0gJ2JvdHRvbScgJiYgKHBvc2l0aW9uWzFdIC09IGhlaWdodCk7XG4gICAgICAgIHZlcnRpY2FsQWxpZ24gPT09ICdtaWRkbGUnICYmIChwb3NpdGlvblsxXSAtPSBoZWlnaHQgLyAyKTtcblxuICAgICAgICAvLyBOb3Qgb3ZlcmZsb3cgZWMgY29udGFpbmVyXG4gICAgICAgIGNvbmZpbmVJbkNvbnRhaW5lcihwb3NpdGlvbiwgd2lkdGgsIGhlaWdodCwgYXBpKTtcblxuICAgICAgICB2YXIgYmdDb2xvciA9IGxhYmVsTW9kZWwuZ2V0KCdiYWNrZ3JvdW5kQ29sb3InKTtcbiAgICAgICAgaWYgKCFiZ0NvbG9yIHx8IGJnQ29sb3IgPT09ICdhdXRvJykge1xuICAgICAgICAgICAgYmdDb2xvciA9IGF4aXNNb2RlbC5nZXQoJ2F4aXNMaW5lLmxpbmVTdHlsZS5jb2xvcicpO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxPcHRpb24ubGFiZWwgPSB7XG4gICAgICAgICAgICBzaGFwZToge3g6IDAsIHk6IDAsIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQsIHI6IGxhYmVsTW9kZWwuZ2V0KCdib3JkZXJSYWRpdXMnKX0sXG4gICAgICAgICAgICBwb3NpdGlvbjogcG9zaXRpb24uc2xpY2UoKSxcbiAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgICAgICAgICB0ZXh0Rm9udDogZm9udCxcbiAgICAgICAgICAgICAgICB0ZXh0RmlsbDogdGV4dFN0eWxlTW9kZWwuZ2V0VGV4dENvbG9yKCksXG4gICAgICAgICAgICAgICAgdGV4dFBvc2l0aW9uOiAnaW5zaWRlJyxcbiAgICAgICAgICAgICAgICBmaWxsOiBiZ0NvbG9yLFxuICAgICAgICAgICAgICAgIHN0cm9rZTogbGFiZWxNb2RlbC5nZXQoJ2JvcmRlckNvbG9yJykgfHwgJ3RyYW5zcGFyZW50JyxcbiAgICAgICAgICAgICAgICBsaW5lV2lkdGg6IGxhYmVsTW9kZWwuZ2V0KCdib3JkZXJXaWR0aCcpIHx8IDAsXG4gICAgICAgICAgICAgICAgc2hhZG93Qmx1cjogbGFiZWxNb2RlbC5nZXQoJ3NoYWRvd0JsdXInKSxcbiAgICAgICAgICAgICAgICBzaGFkb3dDb2xvcjogbGFiZWxNb2RlbC5nZXQoJ3NoYWRvd0NvbG9yJyksXG4gICAgICAgICAgICAgICAgc2hhZG93T2Zmc2V0WDogbGFiZWxNb2RlbC5nZXQoJ3NoYWRvd09mZnNldFgnKSxcbiAgICAgICAgICAgICAgICBzaGFkb3dPZmZzZXRZOiBsYWJlbE1vZGVsLmdldCgnc2hhZG93T2Zmc2V0WScpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gTGFibGUgc2hvdWxkIGJlIG92ZXIgYXhpc1BvaW50ZXIuXG4gICAgICAgICAgICB6MjogMTBcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLy8gRG8gbm90IG92ZXJmbG93IGVjIGNvbnRhaW5lclxuICAgIGZ1bmN0aW9uIGNvbmZpbmVJbkNvbnRhaW5lcihwb3NpdGlvbiwgd2lkdGgsIGhlaWdodCwgYXBpKSB7XG4gICAgICAgIHZhciB2aWV3V2lkdGggPSBhcGkuZ2V0V2lkdGgoKTtcbiAgICAgICAgdmFyIHZpZXdIZWlnaHQgPSBhcGkuZ2V0SGVpZ2h0KCk7XG4gICAgICAgIHBvc2l0aW9uWzBdID0gTWF0aC5taW4ocG9zaXRpb25bMF0gKyB3aWR0aCwgdmlld1dpZHRoKSAtIHdpZHRoO1xuICAgICAgICBwb3NpdGlvblsxXSA9IE1hdGgubWluKHBvc2l0aW9uWzFdICsgaGVpZ2h0LCB2aWV3SGVpZ2h0KSAtIGhlaWdodDtcbiAgICAgICAgcG9zaXRpb25bMF0gPSBNYXRoLm1heChwb3NpdGlvblswXSwgMCk7XG4gICAgICAgIHBvc2l0aW9uWzFdID0gTWF0aC5tYXgocG9zaXRpb25bMV0sIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvY29vcmQvQXhpc30gYXhpc1xuICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvR2xvYmFsfSBlY01vZGVsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdFxuICAgICAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD59IHNlcmllc0RhdGFJbmRpY2VzXG4gICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBvcHQucHJlY2lzaW9uICdhdXRvJyBvciBhIG51bWJlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfEZ1bmN0aW9ufSBvcHQuZm9ybWF0dGVyIGxhYmVsIGZvcm1hdHRlclxuICAgICAqL1xuICAgIGhlbHBlci5nZXRWYWx1ZUxhYmVsID0gZnVuY3Rpb24gKHZhbHVlLCBheGlzLCBlY01vZGVsLCBzZXJpZXNEYXRhSW5kaWNlcywgb3B0KSB7XG4gICAgICAgIHZhciB0ZXh0ID0gYXhpcy5zY2FsZS5nZXRMYWJlbChcbiAgICAgICAgICAgIC8vIElmIGBwcmVjaXNpb25gIGlzIHNldCwgd2lkdGggY2FuIGJlIGZpeGVkIChsaWtlICcxMi4wMDUwMCcpLCB3aGljaFxuICAgICAgICAgICAgLy8gaGVscHMgdG8gZGVib3VuY2Ugd2hlbiB3aGVuIG1vdmluZyBsYWJlbC5cbiAgICAgICAgICAgIHZhbHVlLCB7cHJlY2lzaW9uOiBvcHQucHJlY2lzaW9ufVxuICAgICAgICApO1xuICAgICAgICB2YXIgZm9ybWF0dGVyID0gb3B0LmZvcm1hdHRlcjtcblxuICAgICAgICBpZiAoZm9ybWF0dGVyKSB7XG4gICAgICAgICAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBheGlzSGVscGVyLmdldEF4aXNSYXdWYWx1ZShheGlzLCB2YWx1ZSksXG4gICAgICAgICAgICAgICAgc2VyaWVzRGF0YTogW11cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB6clV0aWwuZWFjaChzZXJpZXNEYXRhSW5kaWNlcywgZnVuY3Rpb24gKGlkeEl0ZW0pIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VyaWVzID0gZWNNb2RlbC5nZXRTZXJpZXNCeUluZGV4KGlkeEl0ZW0uc2VyaWVzSW5kZXgpO1xuICAgICAgICAgICAgICAgIHZhciBkYXRhSW5kZXggPSBpZHhJdGVtLmRhdGFJbmRleEluc2lkZTtcbiAgICAgICAgICAgICAgICB2YXIgZGF0YVBhcmFtcyA9IHNlcmllcyAmJiBzZXJpZXMuZ2V0RGF0YVBhcmFtcyhkYXRhSW5kZXgpO1xuICAgICAgICAgICAgICAgIGRhdGFQYXJhbXMgJiYgcGFyYW1zLnNlcmllc0RhdGEucHVzaChkYXRhUGFyYW1zKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoenJVdGlsLmlzU3RyaW5nKGZvcm1hdHRlcikpIHtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gZm9ybWF0dGVyLnJlcGxhY2UoJ3t2YWx1ZX0nLCB0ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHpyVXRpbC5pc0Z1bmN0aW9uKGZvcm1hdHRlcikpIHtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gZm9ybWF0dGVyKHBhcmFtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9jb29yZC9BeGlzfSBheGlzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGxheW91dEluZm8ge1xuICAgICAqICByb3RhdGlvbiwgcG9zaXRpb24sIGxhYmVsT2Zmc2V0LCBsYWJlbERpcmVjdGlvbiwgbGFiZWxNYXJnaW5cbiAgICAgKiB9XG4gICAgICovXG4gICAgaGVscGVyLmdldFRyYW5zZm9ybWVkUG9zaXRpb24gPSBmdW5jdGlvbiAoYXhpcywgdmFsdWUsIGxheW91dEluZm8pIHtcbiAgICAgICAgdmFyIHRyYW5zZm9ybSA9IG1hdHJpeC5jcmVhdGUoKTtcbiAgICAgICAgbWF0cml4LnJvdGF0ZSh0cmFuc2Zvcm0sIHRyYW5zZm9ybSwgbGF5b3V0SW5mby5yb3RhdGlvbik7XG4gICAgICAgIG1hdHJpeC50cmFuc2xhdGUodHJhbnNmb3JtLCB0cmFuc2Zvcm0sIGxheW91dEluZm8ucG9zaXRpb24pO1xuXG4gICAgICAgIHJldHVybiBncmFwaGljLmFwcGx5VHJhbnNmb3JtKFtcbiAgICAgICAgICAgIGF4aXMuZGF0YVRvQ29vcmQodmFsdWUpLFxuICAgICAgICAgICAgKGxheW91dEluZm8ubGFiZWxPZmZzZXQgfHwgMClcbiAgICAgICAgICAgICAgICArIChsYXlvdXRJbmZvLmxhYmVsRGlyZWN0aW9uIHx8IDEpICogKGxheW91dEluZm8ubGFiZWxNYXJnaW4gfHwgMClcbiAgICAgICAgXSwgdHJhbnNmb3JtKTtcbiAgICB9O1xuXG4gICAgaGVscGVyLmJ1aWxkQ2FydGVzaWFuU2luZ2xlTGFiZWxFbE9wdGlvbiA9IGZ1bmN0aW9uIChcbiAgICAgICAgdmFsdWUsIGVsT3B0aW9uLCBsYXlvdXRJbmZvLCBheGlzTW9kZWwsIGF4aXNQb2ludGVyTW9kZWwsIGFwaVxuICAgICkge1xuICAgICAgICB2YXIgdGV4dExheW91dCA9IEF4aXNCdWlsZGVyLmlubmVyVGV4dExheW91dChcbiAgICAgICAgICAgIGxheW91dEluZm8ucm90YXRpb24sIDAsIGxheW91dEluZm8ubGFiZWxEaXJlY3Rpb25cbiAgICAgICAgKTtcbiAgICAgICAgbGF5b3V0SW5mby5sYWJlbE1hcmdpbiA9IGF4aXNQb2ludGVyTW9kZWwuZ2V0KCdsYWJlbC5tYXJnaW4nKTtcbiAgICAgICAgaGVscGVyLmJ1aWxkTGFiZWxFbE9wdGlvbihlbE9wdGlvbiwgYXhpc01vZGVsLCBheGlzUG9pbnRlck1vZGVsLCBhcGksIHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiBoZWxwZXIuZ2V0VHJhbnNmb3JtZWRQb3NpdGlvbihheGlzTW9kZWwuYXhpcywgdmFsdWUsIGxheW91dEluZm8pLFxuICAgICAgICAgICAgYWxpZ246IHRleHRMYXlvdXQudGV4dEFsaWduLFxuICAgICAgICAgICAgdmVydGljYWxBbGlnbjogdGV4dExheW91dC50ZXh0VmVydGljYWxBbGlnblxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gcDFcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBwMlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbeERpbUluZGV4PTBdIG9yIDFcbiAgICAgKi9cbiAgICBoZWxwZXIubWFrZUxpbmVTaGFwZSA9IGZ1bmN0aW9uIChwMSwgcDIsIHhEaW1JbmRleCkge1xuICAgICAgICB4RGltSW5kZXggPSB4RGltSW5kZXggfHwgMDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHgxOiBwMVt4RGltSW5kZXhdLFxuICAgICAgICAgICAgeTE6IHAxWzEgLSB4RGltSW5kZXhdLFxuICAgICAgICAgICAgeDI6IHAyW3hEaW1JbmRleF0sXG4gICAgICAgICAgICB5MjogcDJbMSAtIHhEaW1JbmRleF1cbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0geHlcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB3aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbeERpbUluZGV4PTBdIG9yIDFcbiAgICAgKi9cbiAgICBoZWxwZXIubWFrZVJlY3RTaGFwZSA9IGZ1bmN0aW9uICh4eSwgd2gsIHhEaW1JbmRleCkge1xuICAgICAgICB4RGltSW5kZXggPSB4RGltSW5kZXggfHwgMDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IHh5W3hEaW1JbmRleF0sXG4gICAgICAgICAgICB5OiB4eVsxIC0geERpbUluZGV4XSxcbiAgICAgICAgICAgIHdpZHRoOiB3aFt4RGltSW5kZXhdLFxuICAgICAgICAgICAgaGVpZ2h0OiB3aFsxIC0geERpbUluZGV4XVxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICBoZWxwZXIubWFrZVNlY3RvclNoYXBlID0gZnVuY3Rpb24gKGN4LCBjeSwgcjAsIHIsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjeDogY3gsXG4gICAgICAgICAgICBjeTogY3ksXG4gICAgICAgICAgICByMDogcjAsXG4gICAgICAgICAgICByOiByLFxuICAgICAgICAgICAgc3RhcnRBbmdsZTogc3RhcnRBbmdsZSxcbiAgICAgICAgICAgIGVuZEFuZ2xlOiBlbmRBbmdsZSxcbiAgICAgICAgICAgIGNsb2Nrd2lzZTogdHJ1ZVxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGhlbHBlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2NvbXBvbmVudC9heGlzUG9pbnRlci92aWV3SGVscGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA4MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 82 */
/* unknown exports provided */
/* all exports used */
/*!******************************************!*\
  !*** ./lib/component/dataZoom/helper.js ***!
  \******************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\n    var formatUtil = __webpack_require__(/*! ../../util/format */ 6);\n    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 0);\n\n    var helper = {};\n\n    var AXIS_DIMS = ['x', 'y', 'z', 'radius', 'angle', 'single'];\n    // Supported coords.\n    var COORDS = ['cartesian2d', 'polar', 'singleAxis'];\n\n    /**\n     * @param {string} coordType\n     * @return {boolean}\n     */\n    helper.isCoordSupported = function (coordType) {\n        return zrUtil.indexOf(COORDS, coordType) >= 0;\n    };\n\n    /**\n     * Create \"each\" method to iterate names.\n     *\n     * @pubilc\n     * @param  {Array.<string>} names\n     * @param  {Array.<string>=} attrs\n     * @return {Function}\n     */\n    helper.createNameEach = function (names, attrs) {\n        names = names.slice();\n        var capitalNames = zrUtil.map(names, formatUtil.capitalFirst);\n        attrs = (attrs || []).slice();\n        var capitalAttrs = zrUtil.map(attrs, formatUtil.capitalFirst);\n\n        return function (callback, context) {\n            zrUtil.each(names, function (name, index) {\n                var nameObj = {name: name, capital: capitalNames[index]};\n\n                for (var j = 0; j < attrs.length; j++) {\n                    nameObj[attrs[j]] = name + capitalAttrs[j];\n                }\n\n                callback.call(context, nameObj);\n            });\n        };\n    };\n\n    /**\n     * Iterate each dimension name.\n     *\n     * @public\n     * @param {Function} callback The parameter is like:\n     *                            {\n     *                                name: 'angle',\n     *                                capital: 'Angle',\n     *                                axis: 'angleAxis',\n     *                                axisIndex: 'angleAixs',\n     *                                index: 'angleIndex'\n     *                            }\n     * @param {Object} context\n     */\n    helper.eachAxisDim = helper.createNameEach(AXIS_DIMS, ['axisIndex', 'axis', 'index', 'id']);\n\n    /**\n     * If tow dataZoomModels has the same axis controlled, we say that they are 'linked'.\n     * dataZoomModels and 'links' make up one or more graphics.\n     * This function finds the graphic where the source dataZoomModel is in.\n     *\n     * @public\n     * @param {Function} forEachNode Node iterator.\n     * @param {Function} forEachEdgeType edgeType iterator\n     * @param {Function} edgeIdGetter Giving node and edgeType, return an array of edge id.\n     * @return {Function} Input: sourceNode, Output: Like {nodes: [], dims: {}}\n     */\n    helper.createLinkedNodesFinder = function (forEachNode, forEachEdgeType, edgeIdGetter) {\n\n        return function (sourceNode) {\n            var result = {\n                nodes: [],\n                records: {} // key: edgeType.name, value: Object (key: edge id, value: boolean).\n            };\n\n            forEachEdgeType(function (edgeType) {\n                result.records[edgeType.name] = {};\n            });\n\n            if (!sourceNode) {\n                return result;\n            }\n\n            absorb(sourceNode, result);\n\n            var existsLink;\n            do {\n                existsLink = false;\n                forEachNode(processSingleNode);\n            }\n            while (existsLink);\n\n            function processSingleNode(node) {\n                if (!isNodeAbsorded(node, result) && isLinked(node, result)) {\n                    absorb(node, result);\n                    existsLink = true;\n                }\n            }\n\n            return result;\n        };\n\n        function isNodeAbsorded(node, result) {\n            return zrUtil.indexOf(result.nodes, node) >= 0;\n        }\n\n        function isLinked(node, result) {\n            var hasLink = false;\n            forEachEdgeType(function (edgeType) {\n                zrUtil.each(edgeIdGetter(node, edgeType) || [], function (edgeId) {\n                    result.records[edgeType.name][edgeId] && (hasLink = true);\n                });\n            });\n            return hasLink;\n        }\n\n        function absorb(node, result) {\n            result.nodes.push(node);\n            forEachEdgeType(function (edgeType) {\n                zrUtil.each(edgeIdGetter(node, edgeType) || [], function (edgeId) {\n                    result.records[edgeType.name][edgeId] = true;\n                });\n            });\n        }\n    };\n\n    module.exports = helper;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvY29tcG9uZW50L2RhdGFab29tL2hlbHBlci5qcz81YmM0Il0sInNvdXJjZXNDb250ZW50IjpbIlxuICAgIHZhciBmb3JtYXRVdGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9mb3JtYXQnKTtcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG5cbiAgICB2YXIgaGVscGVyID0ge307XG5cbiAgICB2YXIgQVhJU19ESU1TID0gWyd4JywgJ3knLCAneicsICdyYWRpdXMnLCAnYW5nbGUnLCAnc2luZ2xlJ107XG4gICAgLy8gU3VwcG9ydGVkIGNvb3Jkcy5cbiAgICB2YXIgQ09PUkRTID0gWydjYXJ0ZXNpYW4yZCcsICdwb2xhcicsICdzaW5nbGVBeGlzJ107XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29vcmRUeXBlXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBoZWxwZXIuaXNDb29yZFN1cHBvcnRlZCA9IGZ1bmN0aW9uIChjb29yZFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHpyVXRpbC5pbmRleE9mKENPT1JEUywgY29vcmRUeXBlKSA+PSAwO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgXCJlYWNoXCIgbWV0aG9kIHRvIGl0ZXJhdGUgbmFtZXMuXG4gICAgICpcbiAgICAgKiBAcHViaWxjXG4gICAgICogQHBhcmFtICB7QXJyYXkuPHN0cmluZz59IG5hbWVzXG4gICAgICogQHBhcmFtICB7QXJyYXkuPHN0cmluZz49fSBhdHRyc1xuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIGhlbHBlci5jcmVhdGVOYW1lRWFjaCA9IGZ1bmN0aW9uIChuYW1lcywgYXR0cnMpIHtcbiAgICAgICAgbmFtZXMgPSBuYW1lcy5zbGljZSgpO1xuICAgICAgICB2YXIgY2FwaXRhbE5hbWVzID0genJVdGlsLm1hcChuYW1lcywgZm9ybWF0VXRpbC5jYXBpdGFsRmlyc3QpO1xuICAgICAgICBhdHRycyA9IChhdHRycyB8fCBbXSkuc2xpY2UoKTtcbiAgICAgICAgdmFyIGNhcGl0YWxBdHRycyA9IHpyVXRpbC5tYXAoYXR0cnMsIGZvcm1hdFV0aWwuY2FwaXRhbEZpcnN0KTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgICAgICAgICB6clV0aWwuZWFjaChuYW1lcywgZnVuY3Rpb24gKG5hbWUsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWVPYmogPSB7bmFtZTogbmFtZSwgY2FwaXRhbDogY2FwaXRhbE5hbWVzW2luZGV4XX07XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGF0dHJzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWVPYmpbYXR0cnNbal1dID0gbmFtZSArIGNhcGl0YWxBdHRyc1tqXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKGNvbnRleHQsIG5hbWVPYmopO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGUgZWFjaCBkaW1lbnNpb24gbmFtZS5cbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgcGFyYW1ldGVyIGlzIGxpa2U6XG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnYW5nbGUnLFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXBpdGFsOiAnQW5nbGUnLFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBheGlzOiAnYW5nbGVBeGlzJyxcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXhpc0luZGV4OiAnYW5nbGVBaXhzJyxcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6ICdhbmdsZUluZGV4J1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICAgICAqL1xuICAgIGhlbHBlci5lYWNoQXhpc0RpbSA9IGhlbHBlci5jcmVhdGVOYW1lRWFjaChBWElTX0RJTVMsIFsnYXhpc0luZGV4JywgJ2F4aXMnLCAnaW5kZXgnLCAnaWQnXSk7XG5cbiAgICAvKipcbiAgICAgKiBJZiB0b3cgZGF0YVpvb21Nb2RlbHMgaGFzIHRoZSBzYW1lIGF4aXMgY29udHJvbGxlZCwgd2Ugc2F5IHRoYXQgdGhleSBhcmUgJ2xpbmtlZCcuXG4gICAgICogZGF0YVpvb21Nb2RlbHMgYW5kICdsaW5rcycgbWFrZSB1cCBvbmUgb3IgbW9yZSBncmFwaGljcy5cbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGZpbmRzIHRoZSBncmFwaGljIHdoZXJlIHRoZSBzb3VyY2UgZGF0YVpvb21Nb2RlbCBpcyBpbi5cbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmb3JFYWNoTm9kZSBOb2RlIGl0ZXJhdG9yLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZvckVhY2hFZGdlVHlwZSBlZGdlVHlwZSBpdGVyYXRvclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVkZ2VJZEdldHRlciBHaXZpbmcgbm9kZSBhbmQgZWRnZVR5cGUsIHJldHVybiBhbiBhcnJheSBvZiBlZGdlIGlkLlxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBJbnB1dDogc291cmNlTm9kZSwgT3V0cHV0OiBMaWtlIHtub2RlczogW10sIGRpbXM6IHt9fVxuICAgICAqL1xuICAgIGhlbHBlci5jcmVhdGVMaW5rZWROb2Rlc0ZpbmRlciA9IGZ1bmN0aW9uIChmb3JFYWNoTm9kZSwgZm9yRWFjaEVkZ2VUeXBlLCBlZGdlSWRHZXR0ZXIpIHtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHNvdXJjZU5vZGUpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgbm9kZXM6IFtdLFxuICAgICAgICAgICAgICAgIHJlY29yZHM6IHt9IC8vIGtleTogZWRnZVR5cGUubmFtZSwgdmFsdWU6IE9iamVjdCAoa2V5OiBlZGdlIGlkLCB2YWx1ZTogYm9vbGVhbikuXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBmb3JFYWNoRWRnZVR5cGUoZnVuY3Rpb24gKGVkZ2VUeXBlKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnJlY29yZHNbZWRnZVR5cGUubmFtZV0gPSB7fTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoIXNvdXJjZU5vZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhYnNvcmIoc291cmNlTm9kZSwgcmVzdWx0KTtcblxuICAgICAgICAgICAgdmFyIGV4aXN0c0xpbms7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgZXhpc3RzTGluayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGZvckVhY2hOb2RlKHByb2Nlc3NTaW5nbGVOb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChleGlzdHNMaW5rKTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gcHJvY2Vzc1NpbmdsZU5vZGUobm9kZSkge1xuICAgICAgICAgICAgICAgIGlmICghaXNOb2RlQWJzb3JkZWQobm9kZSwgcmVzdWx0KSAmJiBpc0xpbmtlZChub2RlLCByZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFic29yYihub2RlLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICBleGlzdHNMaW5rID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gaXNOb2RlQWJzb3JkZWQobm9kZSwgcmVzdWx0KSB7XG4gICAgICAgICAgICByZXR1cm4genJVdGlsLmluZGV4T2YocmVzdWx0Lm5vZGVzLCBub2RlKSA+PSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaXNMaW5rZWQobm9kZSwgcmVzdWx0KSB7XG4gICAgICAgICAgICB2YXIgaGFzTGluayA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yRWFjaEVkZ2VUeXBlKGZ1bmN0aW9uIChlZGdlVHlwZSkge1xuICAgICAgICAgICAgICAgIHpyVXRpbC5lYWNoKGVkZ2VJZEdldHRlcihub2RlLCBlZGdlVHlwZSkgfHwgW10sIGZ1bmN0aW9uIChlZGdlSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnJlY29yZHNbZWRnZVR5cGUubmFtZV1bZWRnZUlkXSAmJiAoaGFzTGluayA9IHRydWUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gaGFzTGluaztcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGFic29yYihub2RlLCByZXN1bHQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5ub2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgZm9yRWFjaEVkZ2VUeXBlKGZ1bmN0aW9uIChlZGdlVHlwZSkge1xuICAgICAgICAgICAgICAgIHpyVXRpbC5lYWNoKGVkZ2VJZEdldHRlcihub2RlLCBlZGdlVHlwZSkgfHwgW10sIGZ1bmN0aW9uIChlZGdlSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnJlY29yZHNbZWRnZVR5cGUubmFtZV1bZWRnZUlkXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGhlbHBlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2NvbXBvbmVudC9kYXRhWm9vbS9oZWxwZXIuanNcbi8vIG1vZHVsZSBpZCA9IDgyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 83 */
/* unknown exports provided */
/* all exports used */
/*!*************************************************!*\
  !*** ./lib/component/helper/selectableMixin.js ***!
  \*************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Data selectable mixin for chart series.\n * To eanble data select, option of series must have `selectedMode`.\n * And each data item will use `selected` to toggle itself selected status\n *\n * @module echarts/chart/helper/DataSelectable\n */\n\n\n    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 0);\n\n    module.exports = {\n\n        updateSelectedMap: function (targetList) {\n            this._selectTargetMap = zrUtil.reduce(targetList || [], function (targetMap, target) {\n                targetMap[target.name] = target;\n                return targetMap;\n            }, {});\n        },\n        /**\n         * @param {string} name\n         */\n        // PENGING If selectedMode is null ?\n        select: function (name) {\n            var targetMap = this._selectTargetMap;\n            var target = targetMap[name];\n            var selectedMode = this.get('selectedMode');\n            if (selectedMode === 'single') {\n                zrUtil.each(targetMap, function (target) {\n                    target.selected = false;\n                });\n            }\n            target && (target.selected = true);\n        },\n\n        /**\n         * @param {string} name\n         */\n        unSelect: function (name) {\n            var target = this._selectTargetMap[name];\n            // var selectedMode = this.get('selectedMode');\n            // selectedMode !== 'single' && target && (target.selected = false);\n            target && (target.selected = false);\n        },\n\n        /**\n         * @param {string} name\n         */\n        toggleSelected: function (name) {\n            var target = this._selectTargetMap[name];\n            if (target != null) {\n                this[target.selected ? 'unSelect' : 'select'](name);\n                return target.selected;\n            }\n        },\n\n        /**\n         * @param {string} name\n         */\n        isSelected: function (name) {\n            var target = this._selectTargetMap[name];\n            return target && target.selected;\n        }\n    };\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvY29tcG9uZW50L2hlbHBlci9zZWxlY3RhYmxlTWl4aW4uanM/NmVkYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIERhdGEgc2VsZWN0YWJsZSBtaXhpbiBmb3IgY2hhcnQgc2VyaWVzLlxuICogVG8gZWFuYmxlIGRhdGEgc2VsZWN0LCBvcHRpb24gb2Ygc2VyaWVzIG11c3QgaGF2ZSBgc2VsZWN0ZWRNb2RlYC5cbiAqIEFuZCBlYWNoIGRhdGEgaXRlbSB3aWxsIHVzZSBgc2VsZWN0ZWRgIHRvIHRvZ2dsZSBpdHNlbGYgc2VsZWN0ZWQgc3RhdHVzXG4gKlxuICogQG1vZHVsZSBlY2hhcnRzL2NoYXJ0L2hlbHBlci9EYXRhU2VsZWN0YWJsZVxuICovXG5cblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuXG4gICAgICAgIHVwZGF0ZVNlbGVjdGVkTWFwOiBmdW5jdGlvbiAodGFyZ2V0TGlzdCkge1xuICAgICAgICAgICAgdGhpcy5fc2VsZWN0VGFyZ2V0TWFwID0genJVdGlsLnJlZHVjZSh0YXJnZXRMaXN0IHx8IFtdLCBmdW5jdGlvbiAodGFyZ2V0TWFwLCB0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRNYXBbdGFyZ2V0Lm5hbWVdID0gdGFyZ2V0O1xuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXRNYXA7XG4gICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAgICAgKi9cbiAgICAgICAgLy8gUEVOR0lORyBJZiBzZWxlY3RlZE1vZGUgaXMgbnVsbCA/XG4gICAgICAgIHNlbGVjdDogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXRNYXAgPSB0aGlzLl9zZWxlY3RUYXJnZXRNYXA7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gdGFyZ2V0TWFwW25hbWVdO1xuICAgICAgICAgICAgdmFyIHNlbGVjdGVkTW9kZSA9IHRoaXMuZ2V0KCdzZWxlY3RlZE1vZGUnKTtcbiAgICAgICAgICAgIGlmIChzZWxlY3RlZE1vZGUgPT09ICdzaW5nbGUnKSB7XG4gICAgICAgICAgICAgICAgenJVdGlsLmVhY2godGFyZ2V0TWFwLCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5zZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFyZ2V0ICYmICh0YXJnZXQuc2VsZWN0ZWQgPSB0cnVlKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgICAgICovXG4gICAgICAgIHVuU2VsZWN0OiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgdmFyIHRhcmdldCA9IHRoaXMuX3NlbGVjdFRhcmdldE1hcFtuYW1lXTtcbiAgICAgICAgICAgIC8vIHZhciBzZWxlY3RlZE1vZGUgPSB0aGlzLmdldCgnc2VsZWN0ZWRNb2RlJyk7XG4gICAgICAgICAgICAvLyBzZWxlY3RlZE1vZGUgIT09ICdzaW5nbGUnICYmIHRhcmdldCAmJiAodGFyZ2V0LnNlbGVjdGVkID0gZmFsc2UpO1xuICAgICAgICAgICAgdGFyZ2V0ICYmICh0YXJnZXQuc2VsZWN0ZWQgPSBmYWxzZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICAgICAqL1xuICAgICAgICB0b2dnbGVTZWxlY3RlZDogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSB0aGlzLl9zZWxlY3RUYXJnZXRNYXBbbmFtZV07XG4gICAgICAgICAgICBpZiAodGFyZ2V0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzW3RhcmdldC5zZWxlY3RlZCA/ICd1blNlbGVjdCcgOiAnc2VsZWN0J10obmFtZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5zZWxlY3RlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgICAgICovXG4gICAgICAgIGlzU2VsZWN0ZWQ6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcy5fc2VsZWN0VGFyZ2V0TWFwW25hbWVdO1xuICAgICAgICAgICAgcmV0dXJuIHRhcmdldCAmJiB0YXJnZXQuc2VsZWN0ZWQ7XG4gICAgICAgIH1cbiAgICB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvY29tcG9uZW50L2hlbHBlci9zZWxlY3RhYmxlTWl4aW4uanNcbi8vIG1vZHVsZSBpZCA9IDgzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 84 */
/* unknown exports provided */
/* all exports used */
/*!********************************************!*\
  !*** ./lib/component/helper/sliderMove.js ***!
  \********************************************/
/***/ (function(module, exports) {

eval("\n\n    /**\n     * Calculate slider move result.\n     *\n     * @param {number} delta Move length.\n     * @param {Array.<number>} handleEnds handleEnds[0] and be bigger then handleEnds[1].\n     *                                    handleEnds will be modified in this method.\n     * @param {Array.<number>} extent handleEnds is restricted by extent.\n     *                                extent[0] should less or equals than extent[1].\n     * @param {string} mode 'rigid': Math.abs(handleEnds[0] - handleEnds[1]) remain unchanged,\n     *                      'cross' handleEnds[0] can be bigger then handleEnds[1],\n     *                      'push' handleEnds[0] can not be bigger then handleEnds[1],\n     *                              when they touch, one push other.\n     * @param {number} handleIndex If mode is 'rigid', handleIndex is not required.\n     * @return {Array.<number>} The input handleEnds.\n     */\n    module.exports = function (delta, handleEnds, extent, mode, handleIndex) {\n        if (!delta) {\n            return handleEnds;\n        }\n\n        if (mode === 'rigid') {\n            delta = getRealDelta(delta, handleEnds, extent);\n            handleEnds[0] += delta;\n            handleEnds[1] += delta;\n        }\n        else {\n            delta = getRealDelta(delta, handleEnds[handleIndex], extent);\n            handleEnds[handleIndex] += delta;\n\n            if (mode === 'push' && handleEnds[0] > handleEnds[1]) {\n                handleEnds[1 - handleIndex] = handleEnds[handleIndex];\n            }\n        }\n\n        return handleEnds;\n\n        function getRealDelta(delta, handleEnds, extent) {\n            var handleMinMax = !handleEnds.length\n                ? [handleEnds, handleEnds]\n                : handleEnds.slice();\n            handleEnds[0] > handleEnds[1] && handleMinMax.reverse();\n\n            if (delta < 0 && handleMinMax[0] + delta < extent[0]) {\n                delta = extent[0] - handleMinMax[0];\n            }\n            if (delta > 0 && handleMinMax[1] + delta > extent[1]) {\n                delta = extent[1] - handleMinMax[1];\n            }\n            return delta;\n        }\n    };\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvY29tcG9uZW50L2hlbHBlci9zbGlkZXJNb3ZlLmpzPzE0MzkiXSwic291cmNlc0NvbnRlbnQiOlsiXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgc2xpZGVyIG1vdmUgcmVzdWx0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRlbHRhIE1vdmUgbGVuZ3RoLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGhhbmRsZUVuZHMgaGFuZGxlRW5kc1swXSBhbmQgYmUgYmlnZ2VyIHRoZW4gaGFuZGxlRW5kc1sxXS5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZUVuZHMgd2lsbCBiZSBtb2RpZmllZCBpbiB0aGlzIG1ldGhvZC5cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBleHRlbnQgaGFuZGxlRW5kcyBpcyByZXN0cmljdGVkIGJ5IGV4dGVudC5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW50WzBdIHNob3VsZCBsZXNzIG9yIGVxdWFscyB0aGFuIGV4dGVudFsxXS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbW9kZSAncmlnaWQnOiBNYXRoLmFicyhoYW5kbGVFbmRzWzBdIC0gaGFuZGxlRW5kc1sxXSkgcmVtYWluIHVuY2hhbmdlZCxcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAnY3Jvc3MnIGhhbmRsZUVuZHNbMF0gY2FuIGJlIGJpZ2dlciB0aGVuIGhhbmRsZUVuZHNbMV0sXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgJ3B1c2gnIGhhbmRsZUVuZHNbMF0gY2FuIG5vdCBiZSBiaWdnZXIgdGhlbiBoYW5kbGVFbmRzWzFdLFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hlbiB0aGV5IHRvdWNoLCBvbmUgcHVzaCBvdGhlci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlSW5kZXggSWYgbW9kZSBpcyAncmlnaWQnLCBoYW5kbGVJbmRleCBpcyBub3QgcmVxdWlyZWQuXG4gICAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59IFRoZSBpbnB1dCBoYW5kbGVFbmRzLlxuICAgICAqL1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGRlbHRhLCBoYW5kbGVFbmRzLCBleHRlbnQsIG1vZGUsIGhhbmRsZUluZGV4KSB7XG4gICAgICAgIGlmICghZGVsdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVFbmRzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1vZGUgPT09ICdyaWdpZCcpIHtcbiAgICAgICAgICAgIGRlbHRhID0gZ2V0UmVhbERlbHRhKGRlbHRhLCBoYW5kbGVFbmRzLCBleHRlbnQpO1xuICAgICAgICAgICAgaGFuZGxlRW5kc1swXSArPSBkZWx0YTtcbiAgICAgICAgICAgIGhhbmRsZUVuZHNbMV0gKz0gZGVsdGE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWx0YSA9IGdldFJlYWxEZWx0YShkZWx0YSwgaGFuZGxlRW5kc1toYW5kbGVJbmRleF0sIGV4dGVudCk7XG4gICAgICAgICAgICBoYW5kbGVFbmRzW2hhbmRsZUluZGV4XSArPSBkZWx0YTtcblxuICAgICAgICAgICAgaWYgKG1vZGUgPT09ICdwdXNoJyAmJiBoYW5kbGVFbmRzWzBdID4gaGFuZGxlRW5kc1sxXSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZUVuZHNbMSAtIGhhbmRsZUluZGV4XSA9IGhhbmRsZUVuZHNbaGFuZGxlSW5kZXhdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGhhbmRsZUVuZHM7XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0UmVhbERlbHRhKGRlbHRhLCBoYW5kbGVFbmRzLCBleHRlbnQpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGVNaW5NYXggPSAhaGFuZGxlRW5kcy5sZW5ndGhcbiAgICAgICAgICAgICAgICA/IFtoYW5kbGVFbmRzLCBoYW5kbGVFbmRzXVxuICAgICAgICAgICAgICAgIDogaGFuZGxlRW5kcy5zbGljZSgpO1xuICAgICAgICAgICAgaGFuZGxlRW5kc1swXSA+IGhhbmRsZUVuZHNbMV0gJiYgaGFuZGxlTWluTWF4LnJldmVyc2UoKTtcblxuICAgICAgICAgICAgaWYgKGRlbHRhIDwgMCAmJiBoYW5kbGVNaW5NYXhbMF0gKyBkZWx0YSA8IGV4dGVudFswXSkge1xuICAgICAgICAgICAgICAgIGRlbHRhID0gZXh0ZW50WzBdIC0gaGFuZGxlTWluTWF4WzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRlbHRhID4gMCAmJiBoYW5kbGVNaW5NYXhbMV0gKyBkZWx0YSA+IGV4dGVudFsxXSkge1xuICAgICAgICAgICAgICAgIGRlbHRhID0gZXh0ZW50WzFdIC0gaGFuZGxlTWluTWF4WzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRlbHRhO1xuICAgICAgICB9XG4gICAgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2NvbXBvbmVudC9oZWxwZXIvc2xpZGVyTW92ZS5qc1xuLy8gbW9kdWxlIGlkID0gODRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 85 */
/* unknown exports provided */
/* all exports used */
/*!*********************************************!*\
  !*** ./lib/component/marker/MarkerModel.js ***!
  \*********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var modelUtil = __webpack_require__(/*! ../../util/model */ 5);\n    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 0);\n    var env = __webpack_require__(/*! zrender/lib/core/env */ 8);\n\n    var formatUtil = __webpack_require__(/*! ../../util/format */ 6);\n    var addCommas = formatUtil.addCommas;\n    var encodeHTML = formatUtil.encodeHTML;\n\n    function fillLabel(opt) {\n        modelUtil.defaultEmphasis(\n            opt.label,\n            modelUtil.LABEL_OPTIONS\n        );\n    }\n    var MarkerModel = __webpack_require__(/*! ../../echarts */ 1).extendComponentModel({\n\n        type: 'marker',\n\n        dependencies: ['series', 'grid', 'polar', 'geo'],\n        /**\n         * @overrite\n         */\n        init: function (option, parentModel, ecModel, extraOpt) {\n\n            if (true) {\n                if (this.type === 'marker') {\n                    throw new Error('Marker component is abstract component. Use markLine, markPoint, markArea instead.');\n                }\n            }\n            this.mergeDefaultAndTheme(option, ecModel);\n            this.mergeOption(option, ecModel, extraOpt.createdBySelf, true);\n        },\n\n        /**\n         * @return {boolean}\n         */\n        isAnimationEnabled: function () {\n            if (env.node) {\n                return false;\n            }\n\n            var hostSeries = this.__hostSeries;\n            return this.getShallow('animation') && hostSeries && hostSeries.isAnimationEnabled();\n        },\n\n        mergeOption: function (newOpt, ecModel, createdBySelf, isInit) {\n            var MarkerModel = this.constructor;\n            var modelPropName = this.mainType + 'Model';\n            if (!createdBySelf) {\n                ecModel.eachSeries(function (seriesModel) {\n\n                    var markerOpt = seriesModel.get(this.mainType);\n\n                    var markerModel = seriesModel[modelPropName];\n                    if (!markerOpt || !markerOpt.data) {\n                        seriesModel[modelPropName] = null;\n                        return;\n                    }\n                    if (!markerModel) {\n                        if (isInit) {\n                            // Default label emphasis `position` and `show`\n                            fillLabel(markerOpt);\n                        }\n                        zrUtil.each(markerOpt.data, function (item) {\n                            // FIXME Overwrite fillLabel method ?\n                            if (item instanceof Array) {\n                                fillLabel(item[0]);\n                                fillLabel(item[1]);\n                            }\n                            else {\n                                fillLabel(item);\n                            }\n                        });\n\n                        markerModel = new MarkerModel(\n                            markerOpt, this, ecModel\n                        );\n\n                        zrUtil.extend(markerModel, {\n                            mainType: this.mainType,\n                            // Use the same series index and name\n                            seriesIndex: seriesModel.seriesIndex,\n                            name: seriesModel.name,\n                            createdBySelf: true\n                        });\n\n                        markerModel.__hostSeries = seriesModel;\n                    }\n                    else {\n                        markerModel.mergeOption(markerOpt, ecModel, true);\n                    }\n                    seriesModel[modelPropName] = markerModel;\n                }, this);\n            }\n        },\n\n        formatTooltip: function (dataIndex) {\n            var data = this.getData();\n            var value = this.getRawValue(dataIndex);\n            var formattedValue = zrUtil.isArray(value)\n                ? zrUtil.map(value, addCommas).join(', ') : addCommas(value);\n            var name = data.getName(dataIndex);\n            var html = encodeHTML(this.name);\n            if (value != null || name) {\n                html += '<br />';\n            }\n            if (name) {\n                html += encodeHTML(name);\n                if (value != null) {\n                    html += ' : ';\n                }\n            }\n            if (value != null) {\n                html += encodeHTML(formattedValue);\n            }\n            return html;\n        },\n\n        getData: function () {\n            return this._data;\n        },\n\n        setData: function (data) {\n            this._data = data;\n        }\n    });\n\n    zrUtil.mixin(MarkerModel, modelUtil.dataFormatMixin);\n\n    module.exports = MarkerModel;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvY29tcG9uZW50L21hcmtlci9NYXJrZXJNb2RlbC5qcz8xZDU4Il0sInNvdXJjZXNDb250ZW50IjpbIlxuXG4gICAgdmFyIG1vZGVsVXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvbW9kZWwnKTtcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG4gICAgdmFyIGVudiA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvZW52Jyk7XG5cbiAgICB2YXIgZm9ybWF0VXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvZm9ybWF0Jyk7XG4gICAgdmFyIGFkZENvbW1hcyA9IGZvcm1hdFV0aWwuYWRkQ29tbWFzO1xuICAgIHZhciBlbmNvZGVIVE1MID0gZm9ybWF0VXRpbC5lbmNvZGVIVE1MO1xuXG4gICAgZnVuY3Rpb24gZmlsbExhYmVsKG9wdCkge1xuICAgICAgICBtb2RlbFV0aWwuZGVmYXVsdEVtcGhhc2lzKFxuICAgICAgICAgICAgb3B0LmxhYmVsLFxuICAgICAgICAgICAgbW9kZWxVdGlsLkxBQkVMX09QVElPTlNcbiAgICAgICAgKTtcbiAgICB9XG4gICAgdmFyIE1hcmtlck1vZGVsID0gcmVxdWlyZSgnLi4vLi4vZWNoYXJ0cycpLmV4dGVuZENvbXBvbmVudE1vZGVsKHtcblxuICAgICAgICB0eXBlOiAnbWFya2VyJyxcblxuICAgICAgICBkZXBlbmRlbmNpZXM6IFsnc2VyaWVzJywgJ2dyaWQnLCAncG9sYXInLCAnZ2VvJ10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAb3ZlcnJpdGVcbiAgICAgICAgICovXG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uIChvcHRpb24sIHBhcmVudE1vZGVsLCBlY01vZGVsLCBleHRyYU9wdCkge1xuXG4gICAgICAgICAgICBpZiAoX19ERVZfXykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdtYXJrZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWFya2VyIGNvbXBvbmVudCBpcyBhYnN0cmFjdCBjb21wb25lbnQuIFVzZSBtYXJrTGluZSwgbWFya1BvaW50LCBtYXJrQXJlYSBpbnN0ZWFkLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubWVyZ2VEZWZhdWx0QW5kVGhlbWUob3B0aW9uLCBlY01vZGVsKTtcbiAgICAgICAgICAgIHRoaXMubWVyZ2VPcHRpb24ob3B0aW9uLCBlY01vZGVsLCBleHRyYU9wdC5jcmVhdGVkQnlTZWxmLCB0cnVlKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGlzQW5pbWF0aW9uRW5hYmxlZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGVudi5ub2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgaG9zdFNlcmllcyA9IHRoaXMuX19ob3N0U2VyaWVzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2hhbGxvdygnYW5pbWF0aW9uJykgJiYgaG9zdFNlcmllcyAmJiBob3N0U2VyaWVzLmlzQW5pbWF0aW9uRW5hYmxlZCgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG1lcmdlT3B0aW9uOiBmdW5jdGlvbiAobmV3T3B0LCBlY01vZGVsLCBjcmVhdGVkQnlTZWxmLCBpc0luaXQpIHtcbiAgICAgICAgICAgIHZhciBNYXJrZXJNb2RlbCA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgICAgICAgICB2YXIgbW9kZWxQcm9wTmFtZSA9IHRoaXMubWFpblR5cGUgKyAnTW9kZWwnO1xuICAgICAgICAgICAgaWYgKCFjcmVhdGVkQnlTZWxmKSB7XG4gICAgICAgICAgICAgICAgZWNNb2RlbC5lYWNoU2VyaWVzKGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXJrZXJPcHQgPSBzZXJpZXNNb2RlbC5nZXQodGhpcy5tYWluVHlwZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hcmtlck1vZGVsID0gc2VyaWVzTW9kZWxbbW9kZWxQcm9wTmFtZV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghbWFya2VyT3B0IHx8ICFtYXJrZXJPcHQuZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzTW9kZWxbbW9kZWxQcm9wTmFtZV0gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghbWFya2VyTW9kZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0luaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEZWZhdWx0IGxhYmVsIGVtcGhhc2lzIGBwb3NpdGlvbmAgYW5kIGBzaG93YFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGxMYWJlbChtYXJrZXJPcHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgenJVdGlsLmVhY2gobWFya2VyT3B0LmRhdGEsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRklYTUUgT3ZlcndyaXRlIGZpbGxMYWJlbCBtZXRob2QgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsbExhYmVsKGl0ZW1bMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxsTGFiZWwoaXRlbVsxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxsTGFiZWwoaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtlck1vZGVsID0gbmV3IE1hcmtlck1vZGVsKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtlck9wdCwgdGhpcywgZWNNb2RlbFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgenJVdGlsLmV4dGVuZChtYXJrZXJNb2RlbCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1haW5UeXBlOiB0aGlzLm1haW5UeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZSB0aGUgc2FtZSBzZXJpZXMgaW5kZXggYW5kIG5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXNJbmRleDogc2VyaWVzTW9kZWwuc2VyaWVzSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogc2VyaWVzTW9kZWwubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVkQnlTZWxmOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgbWFya2VyTW9kZWwuX19ob3N0U2VyaWVzID0gc2VyaWVzTW9kZWw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXJrZXJNb2RlbC5tZXJnZU9wdGlvbihtYXJrZXJPcHQsIGVjTW9kZWwsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNlcmllc01vZGVsW21vZGVsUHJvcE5hbWVdID0gbWFya2VyTW9kZWw7XG4gICAgICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZm9ybWF0VG9vbHRpcDogZnVuY3Rpb24gKGRhdGFJbmRleCkge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmdldERhdGEoKTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0UmF3VmFsdWUoZGF0YUluZGV4KTtcbiAgICAgICAgICAgIHZhciBmb3JtYXR0ZWRWYWx1ZSA9IHpyVXRpbC5pc0FycmF5KHZhbHVlKVxuICAgICAgICAgICAgICAgID8genJVdGlsLm1hcCh2YWx1ZSwgYWRkQ29tbWFzKS5qb2luKCcsICcpIDogYWRkQ29tbWFzKHZhbHVlKTtcbiAgICAgICAgICAgIHZhciBuYW1lID0gZGF0YS5nZXROYW1lKGRhdGFJbmRleCk7XG4gICAgICAgICAgICB2YXIgaHRtbCA9IGVuY29kZUhUTUwodGhpcy5uYW1lKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPSBudWxsIHx8IG5hbWUpIHtcbiAgICAgICAgICAgICAgICBodG1sICs9ICc8YnIgLz4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgICAgICBodG1sICs9IGVuY29kZUhUTUwobmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaHRtbCArPSAnIDogJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGh0bWwgKz0gZW5jb2RlSFRNTChmb3JtYXR0ZWRWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaHRtbDtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXREYXRhOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXREYXRhOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgdGhpcy5fZGF0YSA9IGRhdGE7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHpyVXRpbC5taXhpbihNYXJrZXJNb2RlbCwgbW9kZWxVdGlsLmRhdGFGb3JtYXRNaXhpbik7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IE1hcmtlck1vZGVsO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvY29tcG9uZW50L21hcmtlci9NYXJrZXJNb2RlbC5qc1xuLy8gbW9kdWxlIGlkID0gODVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 86 */
/* unknown exports provided */
/* all exports used */
/*!********************************************!*\
  !*** ./lib/component/marker/MarkerView.js ***!
  \********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    module.exports = __webpack_require__(/*! ../../echarts */ 1).extendComponentView({\n\n        type: 'marker',\n\n        init: function () {\n            /**\n             * Markline grouped by series\n             * @private\n             * @type {Object}\n             */\n            this.markerGroupMap = {};\n        },\n\n        render: function (markerModel, ecModel, api) {\n            var markerGroupMap = this.markerGroupMap;\n            for (var name in markerGroupMap) {\n                if (markerGroupMap.hasOwnProperty(name)) {\n                    markerGroupMap[name].__keep = false;\n                }\n            }\n\n            var markerModelKey = this.type + 'Model';\n            ecModel.eachSeries(function (seriesModel) {\n                var markerModel = seriesModel[markerModelKey];\n                markerModel && this.renderSeries(seriesModel, markerModel, ecModel, api);\n            }, this);\n\n            for (var name in markerGroupMap) {\n                if (markerGroupMap.hasOwnProperty(name) && !markerGroupMap[name].__keep) {\n                    this.group.remove(markerGroupMap[name].group);\n                }\n            }\n        },\n\n        renderSeries: function () {}\n    });\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvY29tcG9uZW50L21hcmtlci9NYXJrZXJWaWV3LmpzP2YyN2IiXSwic291cmNlc0NvbnRlbnQiOlsiXG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL2VjaGFydHMnKS5leHRlbmRDb21wb25lbnRWaWV3KHtcblxuICAgICAgICB0eXBlOiAnbWFya2VyJyxcblxuICAgICAgICBpbml0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIE1hcmtsaW5lIGdyb3VwZWQgYnkgc2VyaWVzXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5tYXJrZXJHcm91cE1hcCA9IHt9O1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbmRlcjogZnVuY3Rpb24gKG1hcmtlck1vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgICAgICAgICAgIHZhciBtYXJrZXJHcm91cE1hcCA9IHRoaXMubWFya2VyR3JvdXBNYXA7XG4gICAgICAgICAgICBmb3IgKHZhciBuYW1lIGluIG1hcmtlckdyb3VwTWFwKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hcmtlckdyb3VwTWFwLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hcmtlckdyb3VwTWFwW25hbWVdLl9fa2VlcCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG1hcmtlck1vZGVsS2V5ID0gdGhpcy50eXBlICsgJ01vZGVsJztcbiAgICAgICAgICAgIGVjTW9kZWwuZWFjaFNlcmllcyhmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWFya2VyTW9kZWwgPSBzZXJpZXNNb2RlbFttYXJrZXJNb2RlbEtleV07XG4gICAgICAgICAgICAgICAgbWFya2VyTW9kZWwgJiYgdGhpcy5yZW5kZXJTZXJpZXMoc2VyaWVzTW9kZWwsIG1hcmtlck1vZGVsLCBlY01vZGVsLCBhcGkpO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIG5hbWUgaW4gbWFya2VyR3JvdXBNYXApIHtcbiAgICAgICAgICAgICAgICBpZiAobWFya2VyR3JvdXBNYXAuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgIW1hcmtlckdyb3VwTWFwW25hbWVdLl9fa2VlcCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmdyb3VwLnJlbW92ZShtYXJrZXJHcm91cE1hcFtuYW1lXS5ncm91cCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHJlbmRlclNlcmllczogZnVuY3Rpb24gKCkge31cbiAgICB9KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2NvbXBvbmVudC9tYXJrZXIvTWFya2VyVmlldy5qc1xuLy8gbW9kdWxlIGlkID0gODZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 87 */
/* unknown exports provided */
/* all exports used */
/*!**********************************************!*\
  !*** ./lib/component/marker/markerHelper.js ***!
  \**********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 0);\n    var numberUtil = __webpack_require__(/*! ../../util/number */ 3);\n    var indexOf = zrUtil.indexOf;\n\n    function hasXOrY(item) {\n        return !(isNaN(parseFloat(item.x)) && isNaN(parseFloat(item.y)));\n    }\n\n    function hasXAndY(item) {\n        return !isNaN(parseFloat(item.x)) && !isNaN(parseFloat(item.y));\n    }\n\n    function getPrecision(data, valueAxisDim, dataIndex) {\n        var precision = -1;\n        do {\n            precision = Math.max(\n                numberUtil.getPrecision(data.get(\n                    valueAxisDim, dataIndex\n                )),\n                precision\n            );\n            data = data.stackedOn;\n        } while (data);\n\n        return precision;\n    }\n\n    function markerTypeCalculatorWithExtent(\n        mlType, data, otherDataDim, targetDataDim, otherCoordIndex, targetCoordIndex\n    ) {\n        var coordArr = [];\n        var value = numCalculate(data, targetDataDim, mlType);\n\n        var dataIndex = data.indicesOfNearest(targetDataDim, value, true)[0];\n        coordArr[otherCoordIndex] = data.get(otherDataDim, dataIndex, true);\n        coordArr[targetCoordIndex] = data.get(targetDataDim, dataIndex, true);\n\n        var precision = getPrecision(data, targetDataDim, dataIndex);\n        if (precision >= 0) {\n            coordArr[targetCoordIndex] = +coordArr[targetCoordIndex].toFixed(precision);\n        }\n\n        return coordArr;\n    }\n\n    var curry = zrUtil.curry;\n    // TODO Specified percent\n    var markerTypeCalculator = {\n        /**\n         * @method\n         * @param {module:echarts/data/List} data\n         * @param {string} baseAxisDim\n         * @param {string} valueAxisDim\n         */\n        min: curry(markerTypeCalculatorWithExtent, 'min'),\n        /**\n         * @method\n         * @param {module:echarts/data/List} data\n         * @param {string} baseAxisDim\n         * @param {string} valueAxisDim\n         */\n        max: curry(markerTypeCalculatorWithExtent, 'max'),\n\n        /**\n         * @method\n         * @param {module:echarts/data/List} data\n         * @param {string} baseAxisDim\n         * @param {string} valueAxisDim\n         */\n        average: curry(markerTypeCalculatorWithExtent, 'average')\n    };\n\n    /**\n     * Transform markPoint data item to format used in List by do the following\n     * 1. Calculate statistic like `max`, `min`, `average`\n     * 2. Convert `item.xAxis`, `item.yAxis` to `item.coord` array\n     * @param  {module:echarts/model/Series} seriesModel\n     * @param  {module:echarts/coord/*} [coordSys]\n     * @param  {Object} item\n     * @return {Object}\n     */\n    var dataTransform = function (seriesModel, item) {\n        var data = seriesModel.getData();\n        var coordSys = seriesModel.coordinateSystem;\n\n        // 1. If not specify the position with pixel directly\n        // 2. If `coord` is not a data array. Which uses `xAxis`,\n        // `yAxis` to specify the coord on each dimension\n\n        // parseFloat first because item.x and item.y can be percent string like '20%'\n        if (item && !hasXAndY(item) && !zrUtil.isArray(item.coord) && coordSys) {\n            var dims = coordSys.dimensions;\n            var axisInfo = getAxisInfo(item, data, coordSys, seriesModel);\n\n            // Clone the option\n            // Transform the properties xAxis, yAxis, radiusAxis, angleAxis, geoCoord to value\n            item = zrUtil.clone(item);\n\n            if (item.type\n                && markerTypeCalculator[item.type]\n                && axisInfo.baseAxis && axisInfo.valueAxis\n            ) {\n                var otherCoordIndex = indexOf(dims, axisInfo.baseAxis.dim);\n                var targetCoordIndex = indexOf(dims, axisInfo.valueAxis.dim);\n\n                item.coord = markerTypeCalculator[item.type](\n                    data, axisInfo.baseDataDim, axisInfo.valueDataDim,\n                    otherCoordIndex, targetCoordIndex\n                );\n                // Force to use the value of calculated value.\n                item.value = item.coord[targetCoordIndex];\n            }\n            else {\n                // FIXME Only has one of xAxis and yAxis.\n                var coord = [\n                    item.xAxis != null ? item.xAxis : item.radiusAxis,\n                    item.yAxis != null ? item.yAxis : item.angleAxis\n                ];\n                // Each coord support max, min, average\n                for (var i = 0; i < 2; i++) {\n                    if (markerTypeCalculator[coord[i]]) {\n                        var dataDim = seriesModel.coordDimToDataDim(dims[i])[0];\n                        coord[i] = numCalculate(data, dataDim, coord[i]);\n                    }\n                }\n                item.coord = coord;\n            }\n        }\n        return item;\n    };\n\n    var getAxisInfo = function (item, data, coordSys, seriesModel) {\n        var ret = {};\n\n        if (item.valueIndex != null || item.valueDim != null) {\n            ret.valueDataDim = item.valueIndex != null\n                ? data.getDimension(item.valueIndex) : item.valueDim;\n            ret.valueAxis = coordSys.getAxis(seriesModel.dataDimToCoordDim(ret.valueDataDim));\n            ret.baseAxis = coordSys.getOtherAxis(ret.valueAxis);\n            ret.baseDataDim = seriesModel.coordDimToDataDim(ret.baseAxis.dim)[0];\n        }\n        else {\n            ret.baseAxis = seriesModel.getBaseAxis();\n            ret.valueAxis = coordSys.getOtherAxis(ret.baseAxis);\n            ret.baseDataDim = seriesModel.coordDimToDataDim(ret.baseAxis.dim)[0];\n            ret.valueDataDim = seriesModel.coordDimToDataDim(ret.valueAxis.dim)[0];\n        }\n\n        return ret;\n    };\n\n    /**\n     * Filter data which is out of coordinateSystem range\n     * [dataFilter description]\n     * @param  {module:echarts/coord/*} [coordSys]\n     * @param  {Object} item\n     * @return {boolean}\n     */\n    var dataFilter = function (coordSys, item) {\n        // Alwalys return true if there is no coordSys\n        return (coordSys && coordSys.containData && item.coord && !hasXOrY(item))\n            ? coordSys.containData(item.coord) : true;\n    };\n\n    var dimValueGetter = function (item, dimName, dataIndex, dimIndex) {\n        // x, y, radius, angle\n        if (dimIndex < 2) {\n            return item.coord && item.coord[dimIndex];\n        }\n        return item.value;\n    };\n\n    var numCalculate = function (data, valueDataDim, type) {\n        if (type === 'average') {\n            var sum = 0;\n            var count = 0;\n            data.each(valueDataDim, function (val, idx) {\n                if (!isNaN(val)) {\n                    sum += val;\n                    count++;\n                }\n            }, true);\n            return sum / count;\n        }\n        else {\n            return data.getDataExtent(valueDataDim, true)[type === 'max' ? 1 : 0];\n        }\n    };\n\n    module.exports = {\n        dataTransform: dataTransform,\n        dataFilter: dataFilter,\n        dimValueGetter: dimValueGetter,\n        getAxisInfo: getAxisInfo,\n        numCalculate: numCalculate\n    };\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvY29tcG9uZW50L21hcmtlci9tYXJrZXJIZWxwZXIuanM/NjEwMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgbnVtYmVyVXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvbnVtYmVyJyk7XG4gICAgdmFyIGluZGV4T2YgPSB6clV0aWwuaW5kZXhPZjtcblxuICAgIGZ1bmN0aW9uIGhhc1hPclkoaXRlbSkge1xuICAgICAgICByZXR1cm4gIShpc05hTihwYXJzZUZsb2F0KGl0ZW0ueCkpICYmIGlzTmFOKHBhcnNlRmxvYXQoaXRlbS55KSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhc1hBbmRZKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuICFpc05hTihwYXJzZUZsb2F0KGl0ZW0ueCkpICYmICFpc05hTihwYXJzZUZsb2F0KGl0ZW0ueSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFByZWNpc2lvbihkYXRhLCB2YWx1ZUF4aXNEaW0sIGRhdGFJbmRleCkge1xuICAgICAgICB2YXIgcHJlY2lzaW9uID0gLTE7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIHByZWNpc2lvbiA9IE1hdGgubWF4KFxuICAgICAgICAgICAgICAgIG51bWJlclV0aWwuZ2V0UHJlY2lzaW9uKGRhdGEuZ2V0KFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZUF4aXNEaW0sIGRhdGFJbmRleFxuICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgIHByZWNpc2lvblxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGRhdGEgPSBkYXRhLnN0YWNrZWRPbjtcbiAgICAgICAgfSB3aGlsZSAoZGF0YSk7XG5cbiAgICAgICAgcmV0dXJuIHByZWNpc2lvbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYXJrZXJUeXBlQ2FsY3VsYXRvcldpdGhFeHRlbnQoXG4gICAgICAgIG1sVHlwZSwgZGF0YSwgb3RoZXJEYXRhRGltLCB0YXJnZXREYXRhRGltLCBvdGhlckNvb3JkSW5kZXgsIHRhcmdldENvb3JkSW5kZXhcbiAgICApIHtcbiAgICAgICAgdmFyIGNvb3JkQXJyID0gW107XG4gICAgICAgIHZhciB2YWx1ZSA9IG51bUNhbGN1bGF0ZShkYXRhLCB0YXJnZXREYXRhRGltLCBtbFR5cGUpO1xuXG4gICAgICAgIHZhciBkYXRhSW5kZXggPSBkYXRhLmluZGljZXNPZk5lYXJlc3QodGFyZ2V0RGF0YURpbSwgdmFsdWUsIHRydWUpWzBdO1xuICAgICAgICBjb29yZEFycltvdGhlckNvb3JkSW5kZXhdID0gZGF0YS5nZXQob3RoZXJEYXRhRGltLCBkYXRhSW5kZXgsIHRydWUpO1xuICAgICAgICBjb29yZEFyclt0YXJnZXRDb29yZEluZGV4XSA9IGRhdGEuZ2V0KHRhcmdldERhdGFEaW0sIGRhdGFJbmRleCwgdHJ1ZSk7XG5cbiAgICAgICAgdmFyIHByZWNpc2lvbiA9IGdldFByZWNpc2lvbihkYXRhLCB0YXJnZXREYXRhRGltLCBkYXRhSW5kZXgpO1xuICAgICAgICBpZiAocHJlY2lzaW9uID49IDApIHtcbiAgICAgICAgICAgIGNvb3JkQXJyW3RhcmdldENvb3JkSW5kZXhdID0gK2Nvb3JkQXJyW3RhcmdldENvb3JkSW5kZXhdLnRvRml4ZWQocHJlY2lzaW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb29yZEFycjtcbiAgICB9XG5cbiAgICB2YXIgY3VycnkgPSB6clV0aWwuY3Vycnk7XG4gICAgLy8gVE9ETyBTcGVjaWZpZWQgcGVyY2VudFxuICAgIHZhciBtYXJrZXJUeXBlQ2FsY3VsYXRvciA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9kYXRhL0xpc3R9IGRhdGFcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGJhc2VBeGlzRGltXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZUF4aXNEaW1cbiAgICAgICAgICovXG4gICAgICAgIG1pbjogY3VycnkobWFya2VyVHlwZUNhbGN1bGF0b3JXaXRoRXh0ZW50LCAnbWluJyksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvZGF0YS9MaXN0fSBkYXRhXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlQXhpc0RpbVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVBeGlzRGltXG4gICAgICAgICAqL1xuICAgICAgICBtYXg6IGN1cnJ5KG1hcmtlclR5cGVDYWxjdWxhdG9yV2l0aEV4dGVudCwgJ21heCcpLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvZGF0YS9MaXN0fSBkYXRhXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlQXhpc0RpbVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVBeGlzRGltXG4gICAgICAgICAqL1xuICAgICAgICBhdmVyYWdlOiBjdXJyeShtYXJrZXJUeXBlQ2FsY3VsYXRvcldpdGhFeHRlbnQsICdhdmVyYWdlJylcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtIG1hcmtQb2ludCBkYXRhIGl0ZW0gdG8gZm9ybWF0IHVzZWQgaW4gTGlzdCBieSBkbyB0aGUgZm9sbG93aW5nXG4gICAgICogMS4gQ2FsY3VsYXRlIHN0YXRpc3RpYyBsaWtlIGBtYXhgLCBgbWluYCwgYGF2ZXJhZ2VgXG4gICAgICogMi4gQ29udmVydCBgaXRlbS54QXhpc2AsIGBpdGVtLnlBeGlzYCB0byBgaXRlbS5jb29yZGAgYXJyYXlcbiAgICAgKiBAcGFyYW0gIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9TZXJpZXN9IHNlcmllc01vZGVsXG4gICAgICogQHBhcmFtICB7bW9kdWxlOmVjaGFydHMvY29vcmQvKn0gW2Nvb3JkU3lzXVxuICAgICAqIEBwYXJhbSAge09iamVjdH0gaXRlbVxuICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgKi9cbiAgICB2YXIgZGF0YVRyYW5zZm9ybSA9IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgaXRlbSkge1xuICAgICAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICAgICAgdmFyIGNvb3JkU3lzID0gc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcblxuICAgICAgICAvLyAxLiBJZiBub3Qgc3BlY2lmeSB0aGUgcG9zaXRpb24gd2l0aCBwaXhlbCBkaXJlY3RseVxuICAgICAgICAvLyAyLiBJZiBgY29vcmRgIGlzIG5vdCBhIGRhdGEgYXJyYXkuIFdoaWNoIHVzZXMgYHhBeGlzYCxcbiAgICAgICAgLy8gYHlBeGlzYCB0byBzcGVjaWZ5IHRoZSBjb29yZCBvbiBlYWNoIGRpbWVuc2lvblxuXG4gICAgICAgIC8vIHBhcnNlRmxvYXQgZmlyc3QgYmVjYXVzZSBpdGVtLnggYW5kIGl0ZW0ueSBjYW4gYmUgcGVyY2VudCBzdHJpbmcgbGlrZSAnMjAlJ1xuICAgICAgICBpZiAoaXRlbSAmJiAhaGFzWEFuZFkoaXRlbSkgJiYgIXpyVXRpbC5pc0FycmF5KGl0ZW0uY29vcmQpICYmIGNvb3JkU3lzKSB7XG4gICAgICAgICAgICB2YXIgZGltcyA9IGNvb3JkU3lzLmRpbWVuc2lvbnM7XG4gICAgICAgICAgICB2YXIgYXhpc0luZm8gPSBnZXRBeGlzSW5mbyhpdGVtLCBkYXRhLCBjb29yZFN5cywgc2VyaWVzTW9kZWwpO1xuXG4gICAgICAgICAgICAvLyBDbG9uZSB0aGUgb3B0aW9uXG4gICAgICAgICAgICAvLyBUcmFuc2Zvcm0gdGhlIHByb3BlcnRpZXMgeEF4aXMsIHlBeGlzLCByYWRpdXNBeGlzLCBhbmdsZUF4aXMsIGdlb0Nvb3JkIHRvIHZhbHVlXG4gICAgICAgICAgICBpdGVtID0genJVdGlsLmNsb25lKGl0ZW0pO1xuXG4gICAgICAgICAgICBpZiAoaXRlbS50eXBlXG4gICAgICAgICAgICAgICAgJiYgbWFya2VyVHlwZUNhbGN1bGF0b3JbaXRlbS50eXBlXVxuICAgICAgICAgICAgICAgICYmIGF4aXNJbmZvLmJhc2VBeGlzICYmIGF4aXNJbmZvLnZhbHVlQXhpc1xuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdmFyIG90aGVyQ29vcmRJbmRleCA9IGluZGV4T2YoZGltcywgYXhpc0luZm8uYmFzZUF4aXMuZGltKTtcbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0Q29vcmRJbmRleCA9IGluZGV4T2YoZGltcywgYXhpc0luZm8udmFsdWVBeGlzLmRpbSk7XG5cbiAgICAgICAgICAgICAgICBpdGVtLmNvb3JkID0gbWFya2VyVHlwZUNhbGN1bGF0b3JbaXRlbS50eXBlXShcbiAgICAgICAgICAgICAgICAgICAgZGF0YSwgYXhpc0luZm8uYmFzZURhdGFEaW0sIGF4aXNJbmZvLnZhbHVlRGF0YURpbSxcbiAgICAgICAgICAgICAgICAgICAgb3RoZXJDb29yZEluZGV4LCB0YXJnZXRDb29yZEluZGV4XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAvLyBGb3JjZSB0byB1c2UgdGhlIHZhbHVlIG9mIGNhbGN1bGF0ZWQgdmFsdWUuXG4gICAgICAgICAgICAgICAgaXRlbS52YWx1ZSA9IGl0ZW0uY29vcmRbdGFyZ2V0Q29vcmRJbmRleF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBGSVhNRSBPbmx5IGhhcyBvbmUgb2YgeEF4aXMgYW5kIHlBeGlzLlxuICAgICAgICAgICAgICAgIHZhciBjb29yZCA9IFtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS54QXhpcyAhPSBudWxsID8gaXRlbS54QXhpcyA6IGl0ZW0ucmFkaXVzQXhpcyxcbiAgICAgICAgICAgICAgICAgICAgaXRlbS55QXhpcyAhPSBudWxsID8gaXRlbS55QXhpcyA6IGl0ZW0uYW5nbGVBeGlzXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAvLyBFYWNoIGNvb3JkIHN1cHBvcnQgbWF4LCBtaW4sIGF2ZXJhZ2VcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWFya2VyVHlwZUNhbGN1bGF0b3JbY29vcmRbaV1dKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YURpbSA9IHNlcmllc01vZGVsLmNvb3JkRGltVG9EYXRhRGltKGRpbXNbaV0pWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29vcmRbaV0gPSBudW1DYWxjdWxhdGUoZGF0YSwgZGF0YURpbSwgY29vcmRbaV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGl0ZW0uY29vcmQgPSBjb29yZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICB9O1xuXG4gICAgdmFyIGdldEF4aXNJbmZvID0gZnVuY3Rpb24gKGl0ZW0sIGRhdGEsIGNvb3JkU3lzLCBzZXJpZXNNb2RlbCkge1xuICAgICAgICB2YXIgcmV0ID0ge307XG5cbiAgICAgICAgaWYgKGl0ZW0udmFsdWVJbmRleCAhPSBudWxsIHx8IGl0ZW0udmFsdWVEaW0gIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0LnZhbHVlRGF0YURpbSA9IGl0ZW0udmFsdWVJbmRleCAhPSBudWxsXG4gICAgICAgICAgICAgICAgPyBkYXRhLmdldERpbWVuc2lvbihpdGVtLnZhbHVlSW5kZXgpIDogaXRlbS52YWx1ZURpbTtcbiAgICAgICAgICAgIHJldC52YWx1ZUF4aXMgPSBjb29yZFN5cy5nZXRBeGlzKHNlcmllc01vZGVsLmRhdGFEaW1Ub0Nvb3JkRGltKHJldC52YWx1ZURhdGFEaW0pKTtcbiAgICAgICAgICAgIHJldC5iYXNlQXhpcyA9IGNvb3JkU3lzLmdldE90aGVyQXhpcyhyZXQudmFsdWVBeGlzKTtcbiAgICAgICAgICAgIHJldC5iYXNlRGF0YURpbSA9IHNlcmllc01vZGVsLmNvb3JkRGltVG9EYXRhRGltKHJldC5iYXNlQXhpcy5kaW0pWzBdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0LmJhc2VBeGlzID0gc2VyaWVzTW9kZWwuZ2V0QmFzZUF4aXMoKTtcbiAgICAgICAgICAgIHJldC52YWx1ZUF4aXMgPSBjb29yZFN5cy5nZXRPdGhlckF4aXMocmV0LmJhc2VBeGlzKTtcbiAgICAgICAgICAgIHJldC5iYXNlRGF0YURpbSA9IHNlcmllc01vZGVsLmNvb3JkRGltVG9EYXRhRGltKHJldC5iYXNlQXhpcy5kaW0pWzBdO1xuICAgICAgICAgICAgcmV0LnZhbHVlRGF0YURpbSA9IHNlcmllc01vZGVsLmNvb3JkRGltVG9EYXRhRGltKHJldC52YWx1ZUF4aXMuZGltKVswXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEZpbHRlciBkYXRhIHdoaWNoIGlzIG91dCBvZiBjb29yZGluYXRlU3lzdGVtIHJhbmdlXG4gICAgICogW2RhdGFGaWx0ZXIgZGVzY3JpcHRpb25dXG4gICAgICogQHBhcmFtICB7bW9kdWxlOmVjaGFydHMvY29vcmQvKn0gW2Nvb3JkU3lzXVxuICAgICAqIEBwYXJhbSAge09iamVjdH0gaXRlbVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgdmFyIGRhdGFGaWx0ZXIgPSBmdW5jdGlvbiAoY29vcmRTeXMsIGl0ZW0pIHtcbiAgICAgICAgLy8gQWx3YWx5cyByZXR1cm4gdHJ1ZSBpZiB0aGVyZSBpcyBubyBjb29yZFN5c1xuICAgICAgICByZXR1cm4gKGNvb3JkU3lzICYmIGNvb3JkU3lzLmNvbnRhaW5EYXRhICYmIGl0ZW0uY29vcmQgJiYgIWhhc1hPclkoaXRlbSkpXG4gICAgICAgICAgICA/IGNvb3JkU3lzLmNvbnRhaW5EYXRhKGl0ZW0uY29vcmQpIDogdHJ1ZTtcbiAgICB9O1xuXG4gICAgdmFyIGRpbVZhbHVlR2V0dGVyID0gZnVuY3Rpb24gKGl0ZW0sIGRpbU5hbWUsIGRhdGFJbmRleCwgZGltSW5kZXgpIHtcbiAgICAgICAgLy8geCwgeSwgcmFkaXVzLCBhbmdsZVxuICAgICAgICBpZiAoZGltSW5kZXggPCAyKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbS5jb29yZCAmJiBpdGVtLmNvb3JkW2RpbUluZGV4XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXRlbS52YWx1ZTtcbiAgICB9O1xuXG4gICAgdmFyIG51bUNhbGN1bGF0ZSA9IGZ1bmN0aW9uIChkYXRhLCB2YWx1ZURhdGFEaW0sIHR5cGUpIHtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdhdmVyYWdlJykge1xuICAgICAgICAgICAgdmFyIHN1bSA9IDA7XG4gICAgICAgICAgICB2YXIgY291bnQgPSAwO1xuICAgICAgICAgICAgZGF0YS5lYWNoKHZhbHVlRGF0YURpbSwgZnVuY3Rpb24gKHZhbCwgaWR4KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc05hTih2YWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1bSArPSB2YWw7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gc3VtIC8gY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YS5nZXREYXRhRXh0ZW50KHZhbHVlRGF0YURpbSwgdHJ1ZSlbdHlwZSA9PT0gJ21heCcgPyAxIDogMF07XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIGRhdGFUcmFuc2Zvcm06IGRhdGFUcmFuc2Zvcm0sXG4gICAgICAgIGRhdGFGaWx0ZXI6IGRhdGFGaWx0ZXIsXG4gICAgICAgIGRpbVZhbHVlR2V0dGVyOiBkaW1WYWx1ZUdldHRlcixcbiAgICAgICAgZ2V0QXhpc0luZm86IGdldEF4aXNJbmZvLFxuICAgICAgICBudW1DYWxjdWxhdGU6IG51bUNhbGN1bGF0ZVxuICAgIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9jb21wb25lbnQvbWFya2VyL21hcmtlckhlbHBlci5qc1xuLy8gbW9kdWxlIGlkID0gODdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 88 */,
/* 89 */
/* unknown exports provided */
/* all exports used */
/*!*********************************!*\
  !*** ./lib/visual/dataColor.js ***!
  \*********************************/
/***/ (function(module, exports) {

eval("// Pick color from palette for each data item.\n// Applicable for charts that require applying color palette\n// in data level (like pie, funnel, chord).\n\n\n    module.exports = function (seriesType, ecModel) {\n        // Pie and funnel may use diferrent scope\n        var paletteScope = {};\n        ecModel.eachRawSeriesByType(seriesType, function (seriesModel) {\n            var dataAll = seriesModel.getRawData();\n            var idxMap = {};\n            if (!ecModel.isSeriesFiltered(seriesModel)) {\n                var data = seriesModel.getData();\n                data.each(function (idx) {\n                    var rawIdx = data.getRawIndex(idx);\n                    idxMap[rawIdx] = idx;\n                });\n                dataAll.each(function (rawIdx) {\n                    var filteredIdx = idxMap[rawIdx];\n\n                    // If series.itemStyle.normal.color is a function. itemVisual may be encoded\n                    var singleDataColor = filteredIdx != null\n                        && data.getItemVisual(filteredIdx, 'color', true);\n\n                    if (!singleDataColor) {\n                        // FIXME Performance\n                        var itemModel = dataAll.getItemModel(rawIdx);\n                        var color = itemModel.get('itemStyle.normal.color')\n                            || seriesModel.getColorFromPalette(dataAll.getName(rawIdx), paletteScope);\n                        // Legend may use the visual info in data before processed\n                        dataAll.setItemVisual(rawIdx, 'color', color);\n\n                        // Data is not filtered\n                        if (filteredIdx != null) {\n                            data.setItemVisual(filteredIdx, 'color', color);\n                        }\n                    }\n                    else {\n                        // Set data all color for legend\n                        dataAll.setItemVisual(rawIdx, 'color', singleDataColor);\n                    }\n                });\n            }\n        });\n    };\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvdmlzdWFsL2RhdGFDb2xvci5qcz84ZmM3Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIFBpY2sgY29sb3IgZnJvbSBwYWxldHRlIGZvciBlYWNoIGRhdGEgaXRlbS5cbi8vIEFwcGxpY2FibGUgZm9yIGNoYXJ0cyB0aGF0IHJlcXVpcmUgYXBwbHlpbmcgY29sb3IgcGFsZXR0ZVxuLy8gaW4gZGF0YSBsZXZlbCAobGlrZSBwaWUsIGZ1bm5lbCwgY2hvcmQpLlxuXG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzZXJpZXNUeXBlLCBlY01vZGVsKSB7XG4gICAgICAgIC8vIFBpZSBhbmQgZnVubmVsIG1heSB1c2UgZGlmZXJyZW50IHNjb3BlXG4gICAgICAgIHZhciBwYWxldHRlU2NvcGUgPSB7fTtcbiAgICAgICAgZWNNb2RlbC5lYWNoUmF3U2VyaWVzQnlUeXBlKHNlcmllc1R5cGUsIGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgICAgICAgICAgdmFyIGRhdGFBbGwgPSBzZXJpZXNNb2RlbC5nZXRSYXdEYXRhKCk7XG4gICAgICAgICAgICB2YXIgaWR4TWFwID0ge307XG4gICAgICAgICAgICBpZiAoIWVjTW9kZWwuaXNTZXJpZXNGaWx0ZXJlZChzZXJpZXNNb2RlbCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICAgICAgICAgICAgICBkYXRhLmVhY2goZnVuY3Rpb24gKGlkeCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmF3SWR4ID0gZGF0YS5nZXRSYXdJbmRleChpZHgpO1xuICAgICAgICAgICAgICAgICAgICBpZHhNYXBbcmF3SWR4XSA9IGlkeDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBkYXRhQWxsLmVhY2goZnVuY3Rpb24gKHJhd0lkeCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZmlsdGVyZWRJZHggPSBpZHhNYXBbcmF3SWR4XTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBzZXJpZXMuaXRlbVN0eWxlLm5vcm1hbC5jb2xvciBpcyBhIGZ1bmN0aW9uLiBpdGVtVmlzdWFsIG1heSBiZSBlbmNvZGVkXG4gICAgICAgICAgICAgICAgICAgIHZhciBzaW5nbGVEYXRhQ29sb3IgPSBmaWx0ZXJlZElkeCAhPSBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiBkYXRhLmdldEl0ZW1WaXN1YWwoZmlsdGVyZWRJZHgsICdjb2xvcicsIHRydWUpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghc2luZ2xlRGF0YUNvbG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGSVhNRSBQZXJmb3JtYW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW1Nb2RlbCA9IGRhdGFBbGwuZ2V0SXRlbU1vZGVsKHJhd0lkeCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29sb3IgPSBpdGVtTW9kZWwuZ2V0KCdpdGVtU3R5bGUubm9ybWFsLmNvbG9yJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCBzZXJpZXNNb2RlbC5nZXRDb2xvckZyb21QYWxldHRlKGRhdGFBbGwuZ2V0TmFtZShyYXdJZHgpLCBwYWxldHRlU2NvcGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTGVnZW5kIG1heSB1c2UgdGhlIHZpc3VhbCBpbmZvIGluIGRhdGEgYmVmb3JlIHByb2Nlc3NlZFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YUFsbC5zZXRJdGVtVmlzdWFsKHJhd0lkeCwgJ2NvbG9yJywgY29sb3IpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEYXRhIGlzIG5vdCBmaWx0ZXJlZFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbHRlcmVkSWR4ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnNldEl0ZW1WaXN1YWwoZmlsdGVyZWRJZHgsICdjb2xvcicsIGNvbG9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNldCBkYXRhIGFsbCBjb2xvciBmb3IgbGVnZW5kXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhQWxsLnNldEl0ZW1WaXN1YWwocmF3SWR4LCAnY29sb3InLCBzaW5nbGVEYXRhQ29sb3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi92aXN1YWwvZGF0YUNvbG9yLmpzXG4vLyBtb2R1bGUgaWQgPSA4OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 90 */
/* unknown exports provided */
/* all exports used */
/*!**********************************************!*\
  !*** /home/yx/~/zrender/lib/contain/line.js ***!
  \**********************************************/
/***/ (function(module, exports) {

eval("\n    module.exports = {\n        /**\n         * 线段包含判断\n         * @param  {number}  x0\n         * @param  {number}  y0\n         * @param  {number}  x1\n         * @param  {number}  y1\n         * @param  {number}  lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {boolean}\n         */\n        containStroke: function (x0, y0, x1, y1, lineWidth, x, y) {\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n            var _a = 0;\n            var _b = x0;\n            // Quick reject\n            if (\n                (y > y0 + _l && y > y1 + _l)\n                || (y < y0 - _l && y < y1 - _l)\n                || (x > x0 + _l && x > x1 + _l)\n                || (x < x0 - _l && x < x1 - _l)\n            ) {\n                return false;\n            }\n\n            if (x0 !== x1) {\n                _a = (y0 - y1) / (x0 - x1);\n                _b = (x0 * y1 - x1 * y0) / (x0 - x1) ;\n            }\n            else {\n                return Math.abs(x - x0) <= _l / 2;\n            }\n            var tmp = _a * x - y + _b;\n            var _s = tmp * tmp / (_a * _a + 1);\n            return _s <= _l / 2 * _l / 2;\n        }\n    };\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL2hvbWUveXgvfi96cmVuZGVyL2xpYi9jb250YWluL2xpbmUuanM/YTA3NiJdLCJzb3VyY2VzQ29udGVudCI6WyJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOe6v+auteWMheWQq+WIpOaWrVxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICB4MFxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICB5MFxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICB4MVxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICB5MVxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICBsaW5lV2lkdGhcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeFxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICB5XG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBjb250YWluU3Ryb2tlOiBmdW5jdGlvbiAoeDAsIHkwLCB4MSwgeTEsIGxpbmVXaWR0aCwgeCwgeSkge1xuICAgICAgICAgICAgaWYgKGxpbmVXaWR0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBfbCA9IGxpbmVXaWR0aDtcbiAgICAgICAgICAgIHZhciBfYSA9IDA7XG4gICAgICAgICAgICB2YXIgX2IgPSB4MDtcbiAgICAgICAgICAgIC8vIFF1aWNrIHJlamVjdFxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICh5ID4geTAgKyBfbCAmJiB5ID4geTEgKyBfbClcbiAgICAgICAgICAgICAgICB8fCAoeSA8IHkwIC0gX2wgJiYgeSA8IHkxIC0gX2wpXG4gICAgICAgICAgICAgICAgfHwgKHggPiB4MCArIF9sICYmIHggPiB4MSArIF9sKVxuICAgICAgICAgICAgICAgIHx8ICh4IDwgeDAgLSBfbCAmJiB4IDwgeDEgLSBfbClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHgwICE9PSB4MSkge1xuICAgICAgICAgICAgICAgIF9hID0gKHkwIC0geTEpIC8gKHgwIC0geDEpO1xuICAgICAgICAgICAgICAgIF9iID0gKHgwICogeTEgLSB4MSAqIHkwKSAvICh4MCAtIHgxKSA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5hYnMoeCAtIHgwKSA8PSBfbCAvIDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdG1wID0gX2EgKiB4IC0geSArIF9iO1xuICAgICAgICAgICAgdmFyIF9zID0gdG1wICogdG1wIC8gKF9hICogX2EgKyAxKTtcbiAgICAgICAgICAgIHJldHVybiBfcyA8PSBfbCAvIDIgKiBfbCAvIDI7XG4gICAgICAgIH1cbiAgICB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2hvbWUveXgvfi96cmVuZGVyL2xpYi9jb250YWluL2xpbmUuanNcbi8vIG1vZHVsZSBpZCA9IDkwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 91 */
/* unknown exports provided */
/* all exports used */
/*!***************************************************!*\
  !*** /home/yx/~/zrender/lib/contain/quadratic.js ***!
  \***************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var curve = __webpack_require__(/*! ../core/curve */ 19);\n\n    module.exports = {\n        /**\n         * 二次贝塞尔曲线描边包含判断\n         * @param  {number}  x0\n         * @param  {number}  y0\n         * @param  {number}  x1\n         * @param  {number}  y1\n         * @param  {number}  x2\n         * @param  {number}  y2\n         * @param  {number}  lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {boolean}\n         */\n        containStroke: function (x0, y0, x1, y1, x2, y2, lineWidth, x, y) {\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n            // Quick reject\n            if (\n                (y > y0 + _l && y > y1 + _l && y > y2 + _l)\n                || (y < y0 - _l && y < y1 - _l && y < y2 - _l)\n                || (x > x0 + _l && x > x1 + _l && x > x2 + _l)\n                || (x < x0 - _l && x < x1 - _l && x < x2 - _l)\n            ) {\n                return false;\n            }\n            var d = curve.quadraticProjectPoint(\n                x0, y0, x1, y1, x2, y2,\n                x, y, null\n            );\n            return d <= _l / 2;\n        }\n    };\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL2hvbWUveXgvfi96cmVuZGVyL2xpYi9jb250YWluL3F1YWRyYXRpYy5qcz9jODM4Il0sInNvdXJjZXNDb250ZW50IjpbIlxuXG4gICAgdmFyIGN1cnZlID0gcmVxdWlyZSgnLi4vY29yZS9jdXJ2ZScpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDkuozmrKHotJ3loZ7lsJTmm7Lnur/mj4/ovrnljIXlkKvliKTmlq1cbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeDBcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeTBcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeDFcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeTFcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeDJcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeTJcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgbGluZVdpZHRoXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHhcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeVxuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgY29udGFpblN0cm9rZTogZnVuY3Rpb24gKHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIGxpbmVXaWR0aCwgeCwgeSkge1xuICAgICAgICAgICAgaWYgKGxpbmVXaWR0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBfbCA9IGxpbmVXaWR0aDtcbiAgICAgICAgICAgIC8vIFF1aWNrIHJlamVjdFxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICh5ID4geTAgKyBfbCAmJiB5ID4geTEgKyBfbCAmJiB5ID4geTIgKyBfbClcbiAgICAgICAgICAgICAgICB8fCAoeSA8IHkwIC0gX2wgJiYgeSA8IHkxIC0gX2wgJiYgeSA8IHkyIC0gX2wpXG4gICAgICAgICAgICAgICAgfHwgKHggPiB4MCArIF9sICYmIHggPiB4MSArIF9sICYmIHggPiB4MiArIF9sKVxuICAgICAgICAgICAgICAgIHx8ICh4IDwgeDAgLSBfbCAmJiB4IDwgeDEgLSBfbCAmJiB4IDwgeDIgLSBfbClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBkID0gY3VydmUucXVhZHJhdGljUHJvamVjdFBvaW50KFxuICAgICAgICAgICAgICAgIHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsXG4gICAgICAgICAgICAgICAgeCwgeSwgbnVsbFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybiBkIDw9IF9sIC8gMjtcbiAgICAgICAgfVxuICAgIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS95eC9+L3pyZW5kZXIvbGliL2NvbnRhaW4vcXVhZHJhdGljLmpzXG4vLyBtb2R1bGUgaWQgPSA5MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 92 */
/* unknown exports provided */
/* all exports used */
/*!*****************************************************!*\
  !*** /home/yx/~/zrender/lib/contain/windingLine.js ***!
  \*****************************************************/
/***/ (function(module, exports) {

eval("\n    module.exports = function windingLine(x0, y0, x1, y1, x, y) {\n        if ((y > y0 && y > y1) || (y < y0 && y < y1)) {\n            return 0;\n        }\n        // Ignore horizontal line\n        if (y1 === y0) {\n            return 0;\n        }\n        var dir = y1 < y0 ? 1 : -1;\n        var t = (y - y0) / (y1 - y0);\n\n        // Avoid winding error when intersection point is the connect point of two line of polygon\n        if (t === 1 || t === 0) {\n            dir = y1 < y0 ? 0.5 : -0.5;\n        }\n\n        var x_ = t * (x1 - x0) + x0;\n\n        return x_ > x ? dir : 0;\n    };\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL2hvbWUveXgvfi96cmVuZGVyL2xpYi9jb250YWluL3dpbmRpbmdMaW5lLmpzP2RhYmIiXSwic291cmNlc0NvbnRlbnQiOlsiXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB3aW5kaW5nTGluZSh4MCwgeTAsIHgxLCB5MSwgeCwgeSkge1xuICAgICAgICBpZiAoKHkgPiB5MCAmJiB5ID4geTEpIHx8ICh5IDwgeTAgJiYgeSA8IHkxKSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWdub3JlIGhvcml6b250YWwgbGluZVxuICAgICAgICBpZiAoeTEgPT09IHkwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGlyID0geTEgPCB5MCA/IDEgOiAtMTtcbiAgICAgICAgdmFyIHQgPSAoeSAtIHkwKSAvICh5MSAtIHkwKTtcblxuICAgICAgICAvLyBBdm9pZCB3aW5kaW5nIGVycm9yIHdoZW4gaW50ZXJzZWN0aW9uIHBvaW50IGlzIHRoZSBjb25uZWN0IHBvaW50IG9mIHR3byBsaW5lIG9mIHBvbHlnb25cbiAgICAgICAgaWYgKHQgPT09IDEgfHwgdCA9PT0gMCkge1xuICAgICAgICAgICAgZGlyID0geTEgPCB5MCA/IDAuNSA6IC0wLjU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgeF8gPSB0ICogKHgxIC0geDApICsgeDA7XG5cbiAgICAgICAgcmV0dXJuIHhfID4geCA/IGRpciA6IDA7XG4gICAgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9ob21lL3l4L34venJlbmRlci9saWIvY29udGFpbi93aW5kaW5nTGluZS5qc1xuLy8gbW9kdWxlIGlkID0gOTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 93 */
/* unknown exports provided */
/* all exports used */
/*!********************************************************!*\
  !*** /home/yx/~/zrender/lib/graphic/LinearGradient.js ***!
  \********************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\n    var zrUtil = __webpack_require__(/*! ../core/util */ 0);\n\n    var Gradient = __webpack_require__(/*! ./Gradient */ 37);\n\n    /**\n     * x, y, x2, y2 are all percent from 0 to 1\n     * @param {number} [x=0]\n     * @param {number} [y=0]\n     * @param {number} [x2=1]\n     * @param {number} [y2=0]\n     * @param {Array.<Object>} colorStops\n     * @param {boolean} [globalCoord=false]\n     */\n    var LinearGradient = function (x, y, x2, y2, colorStops, globalCoord) {\n        // Should do nothing more in this constructor. Because gradient can be\n        // declard by `color: {type: 'linear', colorStops: ...}`, where\n        // this constructor will not be called.\n\n        this.x = x == null ? 0 : x;\n\n        this.y = y == null ? 0 : y;\n\n        this.x2 = x2 == null ? 1 : x2;\n\n        this.y2 = y2 == null ? 0 : y2;\n\n        // Can be cloned\n        this.type = 'linear';\n\n        // If use global coord\n        this.global = globalCoord || false;\n\n        Gradient.call(this, colorStops);\n    };\n\n    LinearGradient.prototype = {\n\n        constructor: LinearGradient\n    };\n\n    zrUtil.inherits(LinearGradient, Gradient);\n\n    module.exports = LinearGradient;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL2hvbWUveXgvfi96cmVuZGVyL2xpYi9ncmFwaGljL0xpbmVhckdyYWRpZW50LmpzP2U0ZGQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJyk7XG5cbiAgICB2YXIgR3JhZGllbnQgPSByZXF1aXJlKCcuL0dyYWRpZW50Jyk7XG5cbiAgICAvKipcbiAgICAgKiB4LCB5LCB4MiwgeTIgYXJlIGFsbCBwZXJjZW50IGZyb20gMCB0byAxXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt4PTBdXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt5PTBdXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt4Mj0xXVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbeTI9MF1cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxPYmplY3Q+fSBjb2xvclN0b3BzXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZ2xvYmFsQ29vcmQ9ZmFsc2VdXG4gICAgICovXG4gICAgdmFyIExpbmVhckdyYWRpZW50ID0gZnVuY3Rpb24gKHgsIHksIHgyLCB5MiwgY29sb3JTdG9wcywgZ2xvYmFsQ29vcmQpIHtcbiAgICAgICAgLy8gU2hvdWxkIGRvIG5vdGhpbmcgbW9yZSBpbiB0aGlzIGNvbnN0cnVjdG9yLiBCZWNhdXNlIGdyYWRpZW50IGNhbiBiZVxuICAgICAgICAvLyBkZWNsYXJkIGJ5IGBjb2xvcjoge3R5cGU6ICdsaW5lYXInLCBjb2xvclN0b3BzOiAuLi59YCwgd2hlcmVcbiAgICAgICAgLy8gdGhpcyBjb25zdHJ1Y3RvciB3aWxsIG5vdCBiZSBjYWxsZWQuXG5cbiAgICAgICAgdGhpcy54ID0geCA9PSBudWxsID8gMCA6IHg7XG5cbiAgICAgICAgdGhpcy55ID0geSA9PSBudWxsID8gMCA6IHk7XG5cbiAgICAgICAgdGhpcy54MiA9IHgyID09IG51bGwgPyAxIDogeDI7XG5cbiAgICAgICAgdGhpcy55MiA9IHkyID09IG51bGwgPyAwIDogeTI7XG5cbiAgICAgICAgLy8gQ2FuIGJlIGNsb25lZFxuICAgICAgICB0aGlzLnR5cGUgPSAnbGluZWFyJztcblxuICAgICAgICAvLyBJZiB1c2UgZ2xvYmFsIGNvb3JkXG4gICAgICAgIHRoaXMuZ2xvYmFsID0gZ2xvYmFsQ29vcmQgfHwgZmFsc2U7XG5cbiAgICAgICAgR3JhZGllbnQuY2FsbCh0aGlzLCBjb2xvclN0b3BzKTtcbiAgICB9O1xuXG4gICAgTGluZWFyR3JhZGllbnQucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBMaW5lYXJHcmFkaWVudFxuICAgIH07XG5cbiAgICB6clV0aWwuaW5oZXJpdHMoTGluZWFyR3JhZGllbnQsIEdyYWRpZW50KTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gTGluZWFyR3JhZGllbnQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS95eC9+L3pyZW5kZXIvbGliL2dyYXBoaWMvTGluZWFyR3JhZGllbnQuanNcbi8vIG1vZHVsZSBpZCA9IDkzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 94 */
/* unknown exports provided */
/* all exports used */
/*!**********************************************!*\
  !*** ./lib/action/createDataSelectAction.js ***!
  \**********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\n    var echarts = __webpack_require__(/*! ../echarts */ 1);\n    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 0);\n    module.exports = function (seriesType, actionInfos) {\n        zrUtil.each(actionInfos, function (actionInfo) {\n            actionInfo.update = 'updateView';\n            /**\n             * @payload\n             * @property {string} seriesName\n             * @property {string} name\n             */\n            echarts.registerAction(actionInfo, function (payload, ecModel) {\n                var selected = {};\n                ecModel.eachComponent(\n                    {mainType: 'series', subType: seriesType, query: payload},\n                    function (seriesModel) {\n                        if (seriesModel[actionInfo.method]) {\n                            seriesModel[actionInfo.method](payload.name);\n                        }\n                        var data = seriesModel.getData();\n                        // Create selected map\n                        data.each(function (idx) {\n                            var name = data.getName(idx);\n                            selected[name] = seriesModel.isSelected(name) || false;\n                        });\n                    }\n                );\n                return {\n                    name: payload.name,\n                    selected: selected\n                };\n            });\n        });\n    };\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvYWN0aW9uL2NyZWF0ZURhdGFTZWxlY3RBY3Rpb24uanM/NmEwMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcbiAgICB2YXIgZWNoYXJ0cyA9IHJlcXVpcmUoJy4uL2VjaGFydHMnKTtcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc2VyaWVzVHlwZSwgYWN0aW9uSW5mb3MpIHtcbiAgICAgICAgenJVdGlsLmVhY2goYWN0aW9uSW5mb3MsIGZ1bmN0aW9uIChhY3Rpb25JbmZvKSB7XG4gICAgICAgICAgICBhY3Rpb25JbmZvLnVwZGF0ZSA9ICd1cGRhdGVWaWV3JztcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHBheWxvYWRcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzZXJpZXNOYW1lXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBlY2hhcnRzLnJlZ2lzdGVyQWN0aW9uKGFjdGlvbkluZm8sIGZ1bmN0aW9uIChwYXlsb2FkLCBlY01vZGVsKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGVjdGVkID0ge307XG4gICAgICAgICAgICAgICAgZWNNb2RlbC5lYWNoQ29tcG9uZW50KFxuICAgICAgICAgICAgICAgICAgICB7bWFpblR5cGU6ICdzZXJpZXMnLCBzdWJUeXBlOiBzZXJpZXNUeXBlLCBxdWVyeTogcGF5bG9hZH0sXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlcmllc01vZGVsW2FjdGlvbkluZm8ubWV0aG9kXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllc01vZGVsW2FjdGlvbkluZm8ubWV0aG9kXShwYXlsb2FkLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgc2VsZWN0ZWQgbWFwXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmVhY2goZnVuY3Rpb24gKGlkeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuYW1lID0gZGF0YS5nZXROYW1lKGlkeCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRbbmFtZV0gPSBzZXJpZXNNb2RlbC5pc1NlbGVjdGVkKG5hbWUpIHx8IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHBheWxvYWQubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQ6IHNlbGVjdGVkXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvYWN0aW9uL2NyZWF0ZURhdGFTZWxlY3RBY3Rpb24uanNcbi8vIG1vZHVsZSBpZCA9IDk0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 95 */
/* unknown exports provided */
/* all exports used */
/*!****************************************!*\
  !*** ./lib/chart/bar/BaseBarSeries.js ***!
  \****************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\n    var SeriesModel = __webpack_require__(/*! ../../model/Series */ 17);\n    var createListFromArray = __webpack_require__(/*! ../helper/createListFromArray */ 27);\n\n    module.exports = SeriesModel.extend({\n\n        type: 'series.__base_bar__',\n\n        getInitialData: function (option, ecModel) {\n            if (true) {\n                var coordSys = option.coordinateSystem;\n                if (coordSys !== 'cartesian2d') {\n                    throw new Error('Bar only support cartesian2d coordinateSystem');\n                }\n            }\n            return createListFromArray(option.data, this, ecModel);\n        },\n\n        getMarkerPosition: function (value) {\n            var coordSys = this.coordinateSystem;\n            if (coordSys) {\n                // PENDING if clamp ?\n                var pt = coordSys.dataToPoint(value, true);\n                var data = this.getData();\n                var offset = data.getLayout('offset');\n                var size = data.getLayout('size');\n                var offsetIndex = coordSys.getBaseAxis().isHorizontal() ? 0 : 1;\n                pt[offsetIndex] += offset + size / 2;\n                return pt;\n            }\n            return [NaN, NaN];\n        },\n\n        defaultOption: {\n            zlevel: 0,                  // 一级层叠\n            z: 2,                       // 二级层叠\n            coordinateSystem: 'cartesian2d',\n            legendHoverLink: true,\n            // stack: null\n\n            // Cartesian coordinate system\n            // xAxisIndex: 0,\n            // yAxisIndex: 0,\n\n            // 最小高度改为0\n            barMinHeight: 0,\n\n            // barMaxWidth: null,\n            // 默认自适应\n            // barWidth: null,\n            // 柱间距离，默认为柱形宽度的30%，可设固定值\n            // barGap: '30%',\n            // 类目间柱形距离，默认为类目间距的20%，可设固定值\n            // barCategoryGap: '20%',\n            // label: {\n            //     normal: {\n            //         show: false\n            //     }\n            // },\n            itemStyle: {\n                normal: {\n                    // color: '各异'\n                },\n                emphasis: {}\n            }\n        }\n    });\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvY2hhcnQvYmFyL0Jhc2VCYXJTZXJpZXMuanM/MzlhNCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciBTZXJpZXNNb2RlbCA9IHJlcXVpcmUoJy4uLy4uL21vZGVsL1NlcmllcycpO1xuICAgIHZhciBjcmVhdGVMaXN0RnJvbUFycmF5ID0gcmVxdWlyZSgnLi4vaGVscGVyL2NyZWF0ZUxpc3RGcm9tQXJyYXknKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gU2VyaWVzTW9kZWwuZXh0ZW5kKHtcblxuICAgICAgICB0eXBlOiAnc2VyaWVzLl9fYmFzZV9iYXJfXycsXG5cbiAgICAgICAgZ2V0SW5pdGlhbERhdGE6IGZ1bmN0aW9uIChvcHRpb24sIGVjTW9kZWwpIHtcbiAgICAgICAgICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvb3JkU3lzID0gb3B0aW9uLmNvb3JkaW5hdGVTeXN0ZW07XG4gICAgICAgICAgICAgICAgaWYgKGNvb3JkU3lzICE9PSAnY2FydGVzaWFuMmQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQmFyIG9ubHkgc3VwcG9ydCBjYXJ0ZXNpYW4yZCBjb29yZGluYXRlU3lzdGVtJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUxpc3RGcm9tQXJyYXkob3B0aW9uLmRhdGEsIHRoaXMsIGVjTW9kZWwpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldE1hcmtlclBvc2l0aW9uOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBjb29yZFN5cyA9IHRoaXMuY29vcmRpbmF0ZVN5c3RlbTtcbiAgICAgICAgICAgIGlmIChjb29yZFN5cykge1xuICAgICAgICAgICAgICAgIC8vIFBFTkRJTkcgaWYgY2xhbXAgP1xuICAgICAgICAgICAgICAgIHZhciBwdCA9IGNvb3JkU3lzLmRhdGFUb1BvaW50KHZhbHVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZ2V0RGF0YSgpO1xuICAgICAgICAgICAgICAgIHZhciBvZmZzZXQgPSBkYXRhLmdldExheW91dCgnb2Zmc2V0Jyk7XG4gICAgICAgICAgICAgICAgdmFyIHNpemUgPSBkYXRhLmdldExheW91dCgnc2l6ZScpO1xuICAgICAgICAgICAgICAgIHZhciBvZmZzZXRJbmRleCA9IGNvb3JkU3lzLmdldEJhc2VBeGlzKCkuaXNIb3Jpem9udGFsKCkgPyAwIDogMTtcbiAgICAgICAgICAgICAgICBwdFtvZmZzZXRJbmRleF0gKz0gb2Zmc2V0ICsgc2l6ZSAvIDI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHB0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtOYU4sIE5hTl07XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGVmYXVsdE9wdGlvbjoge1xuICAgICAgICAgICAgemxldmVsOiAwLCAgICAgICAgICAgICAgICAgIC8vIOS4gOe6p+WxguWPoFxuICAgICAgICAgICAgejogMiwgICAgICAgICAgICAgICAgICAgICAgIC8vIOS6jOe6p+WxguWPoFxuICAgICAgICAgICAgY29vcmRpbmF0ZVN5c3RlbTogJ2NhcnRlc2lhbjJkJyxcbiAgICAgICAgICAgIGxlZ2VuZEhvdmVyTGluazogdHJ1ZSxcbiAgICAgICAgICAgIC8vIHN0YWNrOiBudWxsXG5cbiAgICAgICAgICAgIC8vIENhcnRlc2lhbiBjb29yZGluYXRlIHN5c3RlbVxuICAgICAgICAgICAgLy8geEF4aXNJbmRleDogMCxcbiAgICAgICAgICAgIC8vIHlBeGlzSW5kZXg6IDAsXG5cbiAgICAgICAgICAgIC8vIOacgOWwj+mrmOW6puaUueS4ujBcbiAgICAgICAgICAgIGJhck1pbkhlaWdodDogMCxcblxuICAgICAgICAgICAgLy8gYmFyTWF4V2lkdGg6IG51bGwsXG4gICAgICAgICAgICAvLyDpu5jorqToh6rpgILlupRcbiAgICAgICAgICAgIC8vIGJhcldpZHRoOiBudWxsLFxuICAgICAgICAgICAgLy8g5p+x6Ze06Led56a777yM6buY6K6k5Li65p+x5b2i5a695bqm55qEMzAl77yM5Y+v6K6+5Zu65a6a5YC8XG4gICAgICAgICAgICAvLyBiYXJHYXA6ICczMCUnLFxuICAgICAgICAgICAgLy8g57G755uu6Ze05p+x5b2i6Led56a777yM6buY6K6k5Li657G755uu6Ze06Led55qEMjAl77yM5Y+v6K6+5Zu65a6a5YC8XG4gICAgICAgICAgICAvLyBiYXJDYXRlZ29yeUdhcDogJzIwJScsXG4gICAgICAgICAgICAvLyBsYWJlbDoge1xuICAgICAgICAgICAgLy8gICAgIG5vcm1hbDoge1xuICAgICAgICAgICAgLy8gICAgICAgICBzaG93OiBmYWxzZVxuICAgICAgICAgICAgLy8gICAgIH1cbiAgICAgICAgICAgIC8vIH0sXG4gICAgICAgICAgICBpdGVtU3R5bGU6IHtcbiAgICAgICAgICAgICAgICBub3JtYWw6IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29sb3I6ICflkITlvIInXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlbXBoYXNpczoge31cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvY2hhcnQvYmFyL0Jhc2VCYXJTZXJpZXMuanNcbi8vIG1vZHVsZSBpZCA9IDk1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 96 */
/* unknown exports provided */
/* all exports used */
/*!*********************************!*\
  !*** ./lib/chart/bar/helper.js ***!
  \*********************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 0);\n    var graphic = __webpack_require__(/*! ../../util/graphic */ 2);\n\n    var helper = {};\n\n    helper.setLabel = function (\n        normalStyle, hoverStyle, itemModel, color, seriesModel, dataIndex, labelPositionOutside\n    ) {\n        var labelModel = itemModel.getModel('label.normal');\n        var hoverLabelModel = itemModel.getModel('label.emphasis');\n\n        if (labelModel.get('show')) {\n            setLabel(\n                normalStyle, labelModel, color,\n                zrUtil.retrieve(\n                    seriesModel.getFormattedLabel(dataIndex, 'normal'),\n                    seriesModel.getRawValue(dataIndex)\n                ),\n                labelPositionOutside\n            );\n        }\n        else {\n            normalStyle.text = '';\n        }\n\n        if (hoverLabelModel.get('show')) {\n            setLabel(\n                hoverStyle, hoverLabelModel, color,\n                zrUtil.retrieve(\n                    seriesModel.getFormattedLabel(dataIndex, 'emphasis'),\n                    seriesModel.getRawValue(dataIndex)\n                ),\n                labelPositionOutside\n            );\n        }\n        else {\n            hoverStyle.text = '';\n        }\n    };\n\n    function setLabel(style, model, color, labelText, labelPositionOutside) {\n        graphic.setText(style, model, color);\n        style.text = labelText;\n        if (style.textPosition === 'outside') {\n            style.textPosition = labelPositionOutside;\n        }\n    }\n\n    module.exports = helper;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvY2hhcnQvYmFyL2hlbHBlci5qcz9jZWE1Il0sInNvdXJjZXNDb250ZW50IjpbIlxuXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuICAgIHZhciBncmFwaGljID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9ncmFwaGljJyk7XG5cbiAgICB2YXIgaGVscGVyID0ge307XG5cbiAgICBoZWxwZXIuc2V0TGFiZWwgPSBmdW5jdGlvbiAoXG4gICAgICAgIG5vcm1hbFN0eWxlLCBob3ZlclN0eWxlLCBpdGVtTW9kZWwsIGNvbG9yLCBzZXJpZXNNb2RlbCwgZGF0YUluZGV4LCBsYWJlbFBvc2l0aW9uT3V0c2lkZVxuICAgICkge1xuICAgICAgICB2YXIgbGFiZWxNb2RlbCA9IGl0ZW1Nb2RlbC5nZXRNb2RlbCgnbGFiZWwubm9ybWFsJyk7XG4gICAgICAgIHZhciBob3ZlckxhYmVsTW9kZWwgPSBpdGVtTW9kZWwuZ2V0TW9kZWwoJ2xhYmVsLmVtcGhhc2lzJyk7XG5cbiAgICAgICAgaWYgKGxhYmVsTW9kZWwuZ2V0KCdzaG93JykpIHtcbiAgICAgICAgICAgIHNldExhYmVsKFxuICAgICAgICAgICAgICAgIG5vcm1hbFN0eWxlLCBsYWJlbE1vZGVsLCBjb2xvcixcbiAgICAgICAgICAgICAgICB6clV0aWwucmV0cmlldmUoXG4gICAgICAgICAgICAgICAgICAgIHNlcmllc01vZGVsLmdldEZvcm1hdHRlZExhYmVsKGRhdGFJbmRleCwgJ25vcm1hbCcpLFxuICAgICAgICAgICAgICAgICAgICBzZXJpZXNNb2RlbC5nZXRSYXdWYWx1ZShkYXRhSW5kZXgpXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBsYWJlbFBvc2l0aW9uT3V0c2lkZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5vcm1hbFN0eWxlLnRleHQgPSAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChob3ZlckxhYmVsTW9kZWwuZ2V0KCdzaG93JykpIHtcbiAgICAgICAgICAgIHNldExhYmVsKFxuICAgICAgICAgICAgICAgIGhvdmVyU3R5bGUsIGhvdmVyTGFiZWxNb2RlbCwgY29sb3IsXG4gICAgICAgICAgICAgICAgenJVdGlsLnJldHJpZXZlKFxuICAgICAgICAgICAgICAgICAgICBzZXJpZXNNb2RlbC5nZXRGb3JtYXR0ZWRMYWJlbChkYXRhSW5kZXgsICdlbXBoYXNpcycpLFxuICAgICAgICAgICAgICAgICAgICBzZXJpZXNNb2RlbC5nZXRSYXdWYWx1ZShkYXRhSW5kZXgpXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBsYWJlbFBvc2l0aW9uT3V0c2lkZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGhvdmVyU3R5bGUudGV4dCA9ICcnO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHNldExhYmVsKHN0eWxlLCBtb2RlbCwgY29sb3IsIGxhYmVsVGV4dCwgbGFiZWxQb3NpdGlvbk91dHNpZGUpIHtcbiAgICAgICAgZ3JhcGhpYy5zZXRUZXh0KHN0eWxlLCBtb2RlbCwgY29sb3IpO1xuICAgICAgICBzdHlsZS50ZXh0ID0gbGFiZWxUZXh0O1xuICAgICAgICBpZiAoc3R5bGUudGV4dFBvc2l0aW9uID09PSAnb3V0c2lkZScpIHtcbiAgICAgICAgICAgIHN0eWxlLnRleHRQb3NpdGlvbiA9IGxhYmVsUG9zaXRpb25PdXRzaWRlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBoZWxwZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9jaGFydC9iYXIvaGVscGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA5NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 97 */
/* unknown exports provided */
/* all exports used */
/*!********************************!*\
  !*** ./lib/chart/line/poly.js ***!
  \********************************/
/***/ (function(module, exports, __webpack_require__) {

eval("// Poly path support NaN point\n\n\n    var Path = __webpack_require__(/*! zrender/lib/graphic/Path */ 7);\n    var vec2 = __webpack_require__(/*! zrender/lib/core/vector */ 4);\n\n    var vec2Min = vec2.min;\n    var vec2Max = vec2.max;\n\n    var scaleAndAdd = vec2.scaleAndAdd;\n    var v2Copy = vec2.copy;\n\n    // Temporary variable\n    var v = [];\n    var cp0 = [];\n    var cp1 = [];\n\n    function isPointNull(p) {\n        return isNaN(p[0]) || isNaN(p[1]);\n    }\n\n    function drawSegment(\n        ctx, points, start, segLen, allLen,\n        dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls\n    ) {\n        var prevIdx = 0;\n        var idx = start;\n        for (var k = 0; k < segLen; k++) {\n            var p = points[idx];\n            if (idx >= allLen || idx < 0) {\n                break;\n            }\n            if (isPointNull(p)) {\n                if (connectNulls) {\n                    idx += dir;\n                    continue;\n                }\n                break;\n            }\n\n            if (idx === start) {\n                ctx[dir > 0 ? 'moveTo' : 'lineTo'](p[0], p[1]);\n                v2Copy(cp0, p);\n            }\n            else {\n                if (smooth > 0) {\n                    var nextIdx = idx + dir;\n                    var nextP = points[nextIdx];\n                    if (connectNulls) {\n                        // Find next point not null\n                        while (nextP && isPointNull(points[nextIdx])) {\n                            nextIdx += dir;\n                            nextP = points[nextIdx];\n                        }\n                    }\n\n                    var ratioNextSeg = 0.5;\n                    var prevP = points[prevIdx];\n                    var nextP = points[nextIdx];\n                    // Last point\n                    if (!nextP || isPointNull(nextP)) {\n                        v2Copy(cp1, p);\n                    }\n                    else {\n                        // If next data is null in not connect case\n                        if (isPointNull(nextP) && !connectNulls) {\n                            nextP = p;\n                        }\n\n                        vec2.sub(v, nextP, prevP);\n\n                        var lenPrevSeg;\n                        var lenNextSeg;\n                        if (smoothMonotone === 'x' || smoothMonotone === 'y') {\n                            var dim = smoothMonotone === 'x' ? 0 : 1;\n                            lenPrevSeg = Math.abs(p[dim] - prevP[dim]);\n                            lenNextSeg = Math.abs(p[dim] - nextP[dim]);\n                        }\n                        else {\n                            lenPrevSeg = vec2.dist(p, prevP);\n                            lenNextSeg = vec2.dist(p, nextP);\n                        }\n\n                        // Use ratio of seg length\n                        ratioNextSeg = lenNextSeg / (lenNextSeg + lenPrevSeg);\n\n                        scaleAndAdd(cp1, p, v, -smooth * (1 - ratioNextSeg));\n                    }\n                    // Smooth constraint\n                    vec2Min(cp0, cp0, smoothMax);\n                    vec2Max(cp0, cp0, smoothMin);\n                    vec2Min(cp1, cp1, smoothMax);\n                    vec2Max(cp1, cp1, smoothMin);\n\n                    ctx.bezierCurveTo(\n                        cp0[0], cp0[1],\n                        cp1[0], cp1[1],\n                        p[0], p[1]\n                    );\n                    // cp0 of next segment\n                    scaleAndAdd(cp0, p, v, smooth * ratioNextSeg);\n                }\n                else {\n                    ctx.lineTo(p[0], p[1]);\n                }\n            }\n\n            prevIdx = idx;\n            idx += dir;\n        }\n\n        return k;\n    }\n\n    function getBoundingBox(points, smoothConstraint) {\n        var ptMin = [Infinity, Infinity];\n        var ptMax = [-Infinity, -Infinity];\n        if (smoothConstraint) {\n            for (var i = 0; i < points.length; i++) {\n                var pt = points[i];\n                if (pt[0] < ptMin[0]) { ptMin[0] = pt[0]; }\n                if (pt[1] < ptMin[1]) { ptMin[1] = pt[1]; }\n                if (pt[0] > ptMax[0]) { ptMax[0] = pt[0]; }\n                if (pt[1] > ptMax[1]) { ptMax[1] = pt[1]; }\n            }\n        }\n        return {\n            min: smoothConstraint ? ptMin : ptMax,\n            max: smoothConstraint ? ptMax : ptMin\n        };\n    }\n\n    module.exports = {\n\n        Polyline: Path.extend({\n\n            type: 'ec-polyline',\n\n            shape: {\n                points: [],\n\n                smooth: 0,\n\n                smoothConstraint: true,\n\n                smoothMonotone: null,\n\n                connectNulls: false\n            },\n\n            style: {\n                fill: null,\n\n                stroke: '#000'\n            },\n\n            buildPath: function (ctx, shape) {\n                var points = shape.points;\n\n                var i = 0;\n                var len = points.length;\n\n                var result = getBoundingBox(points, shape.smoothConstraint);\n\n                if (shape.connectNulls) {\n                    // Must remove first and last null values avoid draw error in polygon\n                    for (; len > 0; len--) {\n                        if (!isPointNull(points[len - 1])) {\n                            break;\n                        }\n                    }\n                    for (; i < len; i++) {\n                        if (!isPointNull(points[i])) {\n                            break;\n                        }\n                    }\n                }\n                while (i < len) {\n                    i += drawSegment(\n                        ctx, points, i, len, len,\n                        1, result.min, result.max, shape.smooth,\n                        shape.smoothMonotone, shape.connectNulls\n                    ) + 1;\n                }\n            }\n        }),\n\n        Polygon: Path.extend({\n\n            type: 'ec-polygon',\n\n            shape: {\n                points: [],\n\n                // Offset between stacked base points and points\n                stackedOnPoints: [],\n\n                smooth: 0,\n\n                stackedOnSmooth: 0,\n\n                smoothConstraint: true,\n\n                smoothMonotone: null,\n\n                connectNulls: false\n            },\n\n            buildPath: function (ctx, shape) {\n                var points = shape.points;\n                var stackedOnPoints = shape.stackedOnPoints;\n\n                var i = 0;\n                var len = points.length;\n                var smoothMonotone = shape.smoothMonotone;\n                var bbox = getBoundingBox(points, shape.smoothConstraint);\n                var stackedOnBBox = getBoundingBox(stackedOnPoints, shape.smoothConstraint);\n\n                if (shape.connectNulls) {\n                    // Must remove first and last null values avoid draw error in polygon\n                    for (; len > 0; len--) {\n                        if (!isPointNull(points[len - 1])) {\n                            break;\n                        }\n                    }\n                    for (; i < len; i++) {\n                        if (!isPointNull(points[i])) {\n                            break;\n                        }\n                    }\n                }\n                while (i < len) {\n                    var k = drawSegment(\n                        ctx, points, i, len, len,\n                        1, bbox.min, bbox.max, shape.smooth,\n                        smoothMonotone, shape.connectNulls\n                    );\n                    drawSegment(\n                        ctx, stackedOnPoints, i + k - 1, k, len,\n                        -1, stackedOnBBox.min, stackedOnBBox.max, shape.stackedOnSmooth,\n                        smoothMonotone, shape.connectNulls\n                    );\n                    i += k + 1;\n\n                    ctx.closePath();\n                }\n            }\n        })\n    };\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvY2hhcnQvbGluZS9wb2x5LmpzP2MxMGEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gUG9seSBwYXRoIHN1cHBvcnQgTmFOIHBvaW50XG5cblxuICAgIHZhciBQYXRoID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9QYXRoJyk7XG4gICAgdmFyIHZlYzIgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3ZlY3RvcicpO1xuXG4gICAgdmFyIHZlYzJNaW4gPSB2ZWMyLm1pbjtcbiAgICB2YXIgdmVjMk1heCA9IHZlYzIubWF4O1xuXG4gICAgdmFyIHNjYWxlQW5kQWRkID0gdmVjMi5zY2FsZUFuZEFkZDtcbiAgICB2YXIgdjJDb3B5ID0gdmVjMi5jb3B5O1xuXG4gICAgLy8gVGVtcG9yYXJ5IHZhcmlhYmxlXG4gICAgdmFyIHYgPSBbXTtcbiAgICB2YXIgY3AwID0gW107XG4gICAgdmFyIGNwMSA9IFtdO1xuXG4gICAgZnVuY3Rpb24gaXNQb2ludE51bGwocCkge1xuICAgICAgICByZXR1cm4gaXNOYU4ocFswXSkgfHwgaXNOYU4ocFsxXSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZHJhd1NlZ21lbnQoXG4gICAgICAgIGN0eCwgcG9pbnRzLCBzdGFydCwgc2VnTGVuLCBhbGxMZW4sXG4gICAgICAgIGRpciwgc21vb3RoTWluLCBzbW9vdGhNYXgsIHNtb290aCwgc21vb3RoTW9ub3RvbmUsIGNvbm5lY3ROdWxsc1xuICAgICkge1xuICAgICAgICB2YXIgcHJldklkeCA9IDA7XG4gICAgICAgIHZhciBpZHggPSBzdGFydDtcbiAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBzZWdMZW47IGsrKykge1xuICAgICAgICAgICAgdmFyIHAgPSBwb2ludHNbaWR4XTtcbiAgICAgICAgICAgIGlmIChpZHggPj0gYWxsTGVuIHx8IGlkeCA8IDApIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1BvaW50TnVsbChwKSkge1xuICAgICAgICAgICAgICAgIGlmIChjb25uZWN0TnVsbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWR4ICs9IGRpcjtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaWR4ID09PSBzdGFydCkge1xuICAgICAgICAgICAgICAgIGN0eFtkaXIgPiAwID8gJ21vdmVUbycgOiAnbGluZVRvJ10ocFswXSwgcFsxXSk7XG4gICAgICAgICAgICAgICAgdjJDb3B5KGNwMCwgcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoc21vb3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dElkeCA9IGlkeCArIGRpcjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5leHRQID0gcG9pbnRzW25leHRJZHhdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29ubmVjdE51bGxzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGaW5kIG5leHQgcG9pbnQgbm90IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChuZXh0UCAmJiBpc1BvaW50TnVsbChwb2ludHNbbmV4dElkeF0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dElkeCArPSBkaXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFAgPSBwb2ludHNbbmV4dElkeF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgcmF0aW9OZXh0U2VnID0gMC41O1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJldlAgPSBwb2ludHNbcHJldklkeF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0UCA9IHBvaW50c1tuZXh0SWR4XTtcbiAgICAgICAgICAgICAgICAgICAgLy8gTGFzdCBwb2ludFxuICAgICAgICAgICAgICAgICAgICBpZiAoIW5leHRQIHx8IGlzUG9pbnROdWxsKG5leHRQKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdjJDb3B5KGNwMSwgcCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBuZXh0IGRhdGEgaXMgbnVsbCBpbiBub3QgY29ubmVjdCBjYXNlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNQb2ludE51bGwobmV4dFApICYmICFjb25uZWN0TnVsbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0UCA9IHA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIuc3ViKHYsIG5leHRQLCBwcmV2UCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZW5QcmV2U2VnO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlbk5leHRTZWc7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc21vb3RoTW9ub3RvbmUgPT09ICd4JyB8fCBzbW9vdGhNb25vdG9uZSA9PT0gJ3knKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRpbSA9IHNtb290aE1vbm90b25lID09PSAneCcgPyAwIDogMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZW5QcmV2U2VnID0gTWF0aC5hYnMocFtkaW1dIC0gcHJldlBbZGltXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuTmV4dFNlZyA9IE1hdGguYWJzKHBbZGltXSAtIG5leHRQW2RpbV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuUHJldlNlZyA9IHZlYzIuZGlzdChwLCBwcmV2UCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuTmV4dFNlZyA9IHZlYzIuZGlzdChwLCBuZXh0UCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZSByYXRpbyBvZiBzZWcgbGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgICAgICByYXRpb05leHRTZWcgPSBsZW5OZXh0U2VnIC8gKGxlbk5leHRTZWcgKyBsZW5QcmV2U2VnKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGVBbmRBZGQoY3AxLCBwLCB2LCAtc21vb3RoICogKDEgLSByYXRpb05leHRTZWcpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBTbW9vdGggY29uc3RyYWludFxuICAgICAgICAgICAgICAgICAgICB2ZWMyTWluKGNwMCwgY3AwLCBzbW9vdGhNYXgpO1xuICAgICAgICAgICAgICAgICAgICB2ZWMyTWF4KGNwMCwgY3AwLCBzbW9vdGhNaW4pO1xuICAgICAgICAgICAgICAgICAgICB2ZWMyTWluKGNwMSwgY3AxLCBzbW9vdGhNYXgpO1xuICAgICAgICAgICAgICAgICAgICB2ZWMyTWF4KGNwMSwgY3AxLCBzbW9vdGhNaW4pO1xuXG4gICAgICAgICAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKFxuICAgICAgICAgICAgICAgICAgICAgICAgY3AwWzBdLCBjcDBbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBjcDFbMF0sIGNwMVsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBbMF0sIHBbMV1cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gY3AwIG9mIG5leHQgc2VnbWVudFxuICAgICAgICAgICAgICAgICAgICBzY2FsZUFuZEFkZChjcDAsIHAsIHYsIHNtb290aCAqIHJhdGlvTmV4dFNlZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKHBbMF0sIHBbMV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHJldklkeCA9IGlkeDtcbiAgICAgICAgICAgIGlkeCArPSBkaXI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRCb3VuZGluZ0JveChwb2ludHMsIHNtb290aENvbnN0cmFpbnQpIHtcbiAgICAgICAgdmFyIHB0TWluID0gW0luZmluaXR5LCBJbmZpbml0eV07XG4gICAgICAgIHZhciBwdE1heCA9IFstSW5maW5pdHksIC1JbmZpbml0eV07XG4gICAgICAgIGlmIChzbW9vdGhDb25zdHJhaW50KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBwdCA9IHBvaW50c1tpXTtcbiAgICAgICAgICAgICAgICBpZiAocHRbMF0gPCBwdE1pblswXSkgeyBwdE1pblswXSA9IHB0WzBdOyB9XG4gICAgICAgICAgICAgICAgaWYgKHB0WzFdIDwgcHRNaW5bMV0pIHsgcHRNaW5bMV0gPSBwdFsxXTsgfVxuICAgICAgICAgICAgICAgIGlmIChwdFswXSA+IHB0TWF4WzBdKSB7IHB0TWF4WzBdID0gcHRbMF07IH1cbiAgICAgICAgICAgICAgICBpZiAocHRbMV0gPiBwdE1heFsxXSkgeyBwdE1heFsxXSA9IHB0WzFdOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1pbjogc21vb3RoQ29uc3RyYWludCA/IHB0TWluIDogcHRNYXgsXG4gICAgICAgICAgICBtYXg6IHNtb290aENvbnN0cmFpbnQgPyBwdE1heCA6IHB0TWluXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgICAgICAgUG9seWxpbmU6IFBhdGguZXh0ZW5kKHtcblxuICAgICAgICAgICAgdHlwZTogJ2VjLXBvbHlsaW5lJyxcblxuICAgICAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgICAgICBwb2ludHM6IFtdLFxuXG4gICAgICAgICAgICAgICAgc21vb3RoOiAwLFxuXG4gICAgICAgICAgICAgICAgc21vb3RoQ29uc3RyYWludDogdHJ1ZSxcblxuICAgICAgICAgICAgICAgIHNtb290aE1vbm90b25lOiBudWxsLFxuXG4gICAgICAgICAgICAgICAgY29ubmVjdE51bGxzOiBmYWxzZVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICBmaWxsOiBudWxsLFxuXG4gICAgICAgICAgICAgICAgc3Ryb2tlOiAnIzAwMCdcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgcG9pbnRzID0gc2hhcGUucG9pbnRzO1xuXG4gICAgICAgICAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICAgICAgICAgIHZhciBsZW4gPSBwb2ludHMubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGdldEJvdW5kaW5nQm94KHBvaW50cywgc2hhcGUuc21vb3RoQ29uc3RyYWludCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoc2hhcGUuY29ubmVjdE51bGxzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE11c3QgcmVtb3ZlIGZpcnN0IGFuZCBsYXN0IG51bGwgdmFsdWVzIGF2b2lkIGRyYXcgZXJyb3IgaW4gcG9seWdvblxuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgbGVuID4gMDsgbGVuLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNQb2ludE51bGwocG9pbnRzW2xlbiAtIDFdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNQb2ludE51bGwocG9pbnRzW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIGkgKz0gZHJhd1NlZ21lbnQoXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgsIHBvaW50cywgaSwgbGVuLCBsZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAxLCByZXN1bHQubWluLCByZXN1bHQubWF4LCBzaGFwZS5zbW9vdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaGFwZS5zbW9vdGhNb25vdG9uZSwgc2hhcGUuY29ubmVjdE51bGxzXG4gICAgICAgICAgICAgICAgICAgICkgKyAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSksXG5cbiAgICAgICAgUG9seWdvbjogUGF0aC5leHRlbmQoe1xuXG4gICAgICAgICAgICB0eXBlOiAnZWMtcG9seWdvbicsXG5cbiAgICAgICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgICAgICAgcG9pbnRzOiBbXSxcblxuICAgICAgICAgICAgICAgIC8vIE9mZnNldCBiZXR3ZWVuIHN0YWNrZWQgYmFzZSBwb2ludHMgYW5kIHBvaW50c1xuICAgICAgICAgICAgICAgIHN0YWNrZWRPblBvaW50czogW10sXG5cbiAgICAgICAgICAgICAgICBzbW9vdGg6IDAsXG5cbiAgICAgICAgICAgICAgICBzdGFja2VkT25TbW9vdGg6IDAsXG5cbiAgICAgICAgICAgICAgICBzbW9vdGhDb25zdHJhaW50OiB0cnVlLFxuXG4gICAgICAgICAgICAgICAgc21vb3RoTW9ub3RvbmU6IG51bGwsXG5cbiAgICAgICAgICAgICAgICBjb25uZWN0TnVsbHM6IGZhbHNlXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBvaW50cyA9IHNoYXBlLnBvaW50cztcbiAgICAgICAgICAgICAgICB2YXIgc3RhY2tlZE9uUG9pbnRzID0gc2hhcGUuc3RhY2tlZE9uUG9pbnRzO1xuXG4gICAgICAgICAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICAgICAgICAgIHZhciBsZW4gPSBwb2ludHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHZhciBzbW9vdGhNb25vdG9uZSA9IHNoYXBlLnNtb290aE1vbm90b25lO1xuICAgICAgICAgICAgICAgIHZhciBiYm94ID0gZ2V0Qm91bmRpbmdCb3gocG9pbnRzLCBzaGFwZS5zbW9vdGhDb25zdHJhaW50KTtcbiAgICAgICAgICAgICAgICB2YXIgc3RhY2tlZE9uQkJveCA9IGdldEJvdW5kaW5nQm94KHN0YWNrZWRPblBvaW50cywgc2hhcGUuc21vb3RoQ29uc3RyYWludCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoc2hhcGUuY29ubmVjdE51bGxzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE11c3QgcmVtb3ZlIGZpcnN0IGFuZCBsYXN0IG51bGwgdmFsdWVzIGF2b2lkIGRyYXcgZXJyb3IgaW4gcG9seWdvblxuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgbGVuID4gMDsgbGVuLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNQb2ludE51bGwocG9pbnRzW2xlbiAtIDFdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNQb2ludE51bGwocG9pbnRzW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrID0gZHJhd1NlZ21lbnQoXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgsIHBvaW50cywgaSwgbGVuLCBsZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAxLCBiYm94Lm1pbiwgYmJveC5tYXgsIHNoYXBlLnNtb290aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNtb290aE1vbm90b25lLCBzaGFwZS5jb25uZWN0TnVsbHNcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgZHJhd1NlZ21lbnQoXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgsIHN0YWNrZWRPblBvaW50cywgaSArIGsgLSAxLCBrLCBsZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAtMSwgc3RhY2tlZE9uQkJveC5taW4sIHN0YWNrZWRPbkJCb3gubWF4LCBzaGFwZS5zdGFja2VkT25TbW9vdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBzbW9vdGhNb25vdG9uZSwgc2hhcGUuY29ubmVjdE51bGxzXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGkgKz0gayArIDE7XG5cbiAgICAgICAgICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvY2hhcnQvbGluZS9wb2x5LmpzXG4vLyBtb2R1bGUgaWQgPSA5N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 98 */,
/* 99 */
/* unknown exports provided */
/* all exports used */
/*!************************************************!*\
  !*** ./lib/component/helper/RoamController.js ***!
  \************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * @module echarts/component/helper/RoamController\n */\n\n\n    var Eventful = __webpack_require__(/*! zrender/lib/mixin/Eventful */ 22);\n    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 0);\n    var eventTool = __webpack_require__(/*! zrender/lib/core/event */ 20);\n    var interactionMutex = __webpack_require__(/*! ./interactionMutex */ 158);\n\n    /**\n     * @alias module:echarts/component/helper/RoamController\n     * @constructor\n     * @mixin {module:zrender/mixin/Eventful}\n     *\n     * @param {module:zrender/zrender~ZRender} zr\n     */\n    function RoamController(zr) {\n\n        /**\n         * @type {Function}\n         */\n        this.pointerChecker;\n\n        /**\n         * @type {module:zrender}\n         */\n        this._zr = zr;\n\n        // Avoid two roamController bind the same handler\n        var bind = zrUtil.bind;\n        var mousedownHandler = bind(mousedown, this);\n        var mousemoveHandler = bind(mousemove, this);\n        var mouseupHandler = bind(mouseup, this);\n        var mousewheelHandler = bind(mousewheel, this);\n        var pinchHandler = bind(pinch, this);\n\n        Eventful.call(this);\n\n        /**\n         * @param {Function} pointerChecker\n         *                   input: x, y\n         *                   output: boolean\n         */\n        this.setPointerChecker = function (pointerChecker) {\n            this.pointerChecker = pointerChecker;\n        };\n\n        /**\n         * Notice: only enable needed types. For example, if 'zoom'\n         * is not needed, 'zoom' should not be enabled, otherwise\n         * default mousewheel behaviour (scroll page) will be disabled.\n         *\n         * @param  {boolean|string} [controlType=true] Specify the control type,\n         *                          which can be null/undefined or true/false\n         *                          or 'pan/move' or 'zoom'/'scale'\n         */\n        this.enable = function (controlType) {\n            // Disable previous first\n            this.disable();\n\n            if (controlType == null) {\n                controlType = true;\n            }\n\n            if (controlType === true || (controlType === 'move' || controlType === 'pan')) {\n                zr.on('mousedown', mousedownHandler);\n                zr.on('mousemove', mousemoveHandler);\n                zr.on('mouseup', mouseupHandler);\n            }\n            if (controlType === true || (controlType === 'scale' || controlType === 'zoom')) {\n                zr.on('mousewheel', mousewheelHandler);\n                zr.on('pinch', pinchHandler);\n            }\n        };\n\n        this.disable = function () {\n            zr.off('mousedown', mousedownHandler);\n            zr.off('mousemove', mousemoveHandler);\n            zr.off('mouseup', mouseupHandler);\n            zr.off('mousewheel', mousewheelHandler);\n            zr.off('pinch', pinchHandler);\n        };\n\n        this.dispose = this.disable;\n\n        this.isDragging = function () {\n            return this._dragging;\n        };\n\n        this.isPinching = function () {\n            return this._pinching;\n        };\n    }\n\n    zrUtil.mixin(RoamController, Eventful);\n\n\n    function mousedown(e) {\n        if (e.target && e.target.draggable) {\n            return;\n        }\n\n        var x = e.offsetX;\n        var y = e.offsetY;\n\n        // Only check on mosedown, but not mousemove.\n        // Mouse can be out of target when mouse moving.\n        if (this.pointerChecker && this.pointerChecker(e, x, y)) {\n            this._x = x;\n            this._y = y;\n            this._dragging = true;\n        }\n    }\n\n    function mousemove(e) {\n        if (!this._dragging) {\n            return;\n        }\n\n        eventTool.stop(e.event);\n\n        if (e.gestureEvent !== 'pinch') {\n\n            if (interactionMutex.isTaken(this._zr, 'globalPan')) {\n                return;\n            }\n\n            var x = e.offsetX;\n            var y = e.offsetY;\n\n            var oldX = this._x;\n            var oldY = this._y;\n\n            var dx = x - oldX;\n            var dy = y - oldY;\n\n            this._x = x;\n            this._y = y;\n\n            eventTool.stop(e.event);\n            this.trigger('pan', dx, dy, oldX, oldY, x, y);\n        }\n    }\n\n    function mouseup(e) {\n        this._dragging = false;\n    }\n\n    function mousewheel(e) {\n        // wheelDelta maybe -0 in chrome mac.\n        if (e.wheelDelta === 0) {\n            return;\n        }\n        // Convenience:\n        // Mac and VM Windows on Mac: scroll up: zoom out.\n        // Windows: scroll up: zoom in.\n        var zoomDelta = e.wheelDelta > 0 ? 1.1 : 1 / 1.1;\n        zoom.call(this, e, zoomDelta, e.offsetX, e.offsetY);\n    }\n\n    function pinch(e) {\n        if (interactionMutex.isTaken(this._zr, 'globalPan')) {\n            return;\n        }\n        var zoomDelta = e.pinchScale > 1 ? 1.1 : 1 / 1.1;\n        zoom.call(this, e, zoomDelta, e.pinchX, e.pinchY);\n    }\n\n    function zoom(e, zoomDelta, zoomX, zoomY) {\n        if (this.pointerChecker && this.pointerChecker(e, zoomX, zoomY)) {\n            // When mouse is out of roamController rect,\n            // default befavoius should be be disabled, otherwise\n            // page sliding is disabled, contrary to expectation.\n            eventTool.stop(e.event);\n\n            this.trigger('zoom', zoomDelta, zoomX, zoomY);\n        }\n    }\n\n    module.exports = RoamController;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvY29tcG9uZW50L2hlbHBlci9Sb2FtQ29udHJvbGxlci5qcz84N2ZmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQG1vZHVsZSBlY2hhcnRzL2NvbXBvbmVudC9oZWxwZXIvUm9hbUNvbnRyb2xsZXJcbiAqL1xuXG5cbiAgICB2YXIgRXZlbnRmdWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9taXhpbi9FdmVudGZ1bCcpO1xuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgZXZlbnRUb29sID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS9ldmVudCcpO1xuICAgIHZhciBpbnRlcmFjdGlvbk11dGV4ID0gcmVxdWlyZSgnLi9pbnRlcmFjdGlvbk11dGV4Jyk7XG5cbiAgICAvKipcbiAgICAgKiBAYWxpYXMgbW9kdWxlOmVjaGFydHMvY29tcG9uZW50L2hlbHBlci9Sb2FtQ29udHJvbGxlclxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtaXhpbiB7bW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWx9XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL3pyZW5kZXJ+WlJlbmRlcn0genJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBSb2FtQ29udHJvbGxlcih6cikge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBvaW50ZXJDaGVja2VyO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl96ciA9IHpyO1xuXG4gICAgICAgIC8vIEF2b2lkIHR3byByb2FtQ29udHJvbGxlciBiaW5kIHRoZSBzYW1lIGhhbmRsZXJcbiAgICAgICAgdmFyIGJpbmQgPSB6clV0aWwuYmluZDtcbiAgICAgICAgdmFyIG1vdXNlZG93bkhhbmRsZXIgPSBiaW5kKG1vdXNlZG93biwgdGhpcyk7XG4gICAgICAgIHZhciBtb3VzZW1vdmVIYW5kbGVyID0gYmluZChtb3VzZW1vdmUsIHRoaXMpO1xuICAgICAgICB2YXIgbW91c2V1cEhhbmRsZXIgPSBiaW5kKG1vdXNldXAsIHRoaXMpO1xuICAgICAgICB2YXIgbW91c2V3aGVlbEhhbmRsZXIgPSBiaW5kKG1vdXNld2hlZWwsIHRoaXMpO1xuICAgICAgICB2YXIgcGluY2hIYW5kbGVyID0gYmluZChwaW5jaCwgdGhpcyk7XG5cbiAgICAgICAgRXZlbnRmdWwuY2FsbCh0aGlzKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcG9pbnRlckNoZWNrZXJcbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgaW5wdXQ6IHgsIHlcbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgb3V0cHV0OiBib29sZWFuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNldFBvaW50ZXJDaGVja2VyID0gZnVuY3Rpb24gKHBvaW50ZXJDaGVja2VyKSB7XG4gICAgICAgICAgICB0aGlzLnBvaW50ZXJDaGVja2VyID0gcG9pbnRlckNoZWNrZXI7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5vdGljZTogb25seSBlbmFibGUgbmVlZGVkIHR5cGVzLiBGb3IgZXhhbXBsZSwgaWYgJ3pvb20nXG4gICAgICAgICAqIGlzIG5vdCBuZWVkZWQsICd6b29tJyBzaG91bGQgbm90IGJlIGVuYWJsZWQsIG90aGVyd2lzZVxuICAgICAgICAgKiBkZWZhdWx0IG1vdXNld2hlZWwgYmVoYXZpb3VyIChzY3JvbGwgcGFnZSkgd2lsbCBiZSBkaXNhYmxlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtICB7Ym9vbGVhbnxzdHJpbmd9IFtjb250cm9sVHlwZT10cnVlXSBTcGVjaWZ5IHRoZSBjb250cm9sIHR5cGUsXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICB3aGljaCBjYW4gYmUgbnVsbC91bmRlZmluZWQgb3IgdHJ1ZS9mYWxzZVxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgb3IgJ3Bhbi9tb3ZlJyBvciAnem9vbScvJ3NjYWxlJ1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5lbmFibGUgPSBmdW5jdGlvbiAoY29udHJvbFR5cGUpIHtcbiAgICAgICAgICAgIC8vIERpc2FibGUgcHJldmlvdXMgZmlyc3RcbiAgICAgICAgICAgIHRoaXMuZGlzYWJsZSgpO1xuXG4gICAgICAgICAgICBpZiAoY29udHJvbFR5cGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xUeXBlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNvbnRyb2xUeXBlID09PSB0cnVlIHx8IChjb250cm9sVHlwZSA9PT0gJ21vdmUnIHx8IGNvbnRyb2xUeXBlID09PSAncGFuJykpIHtcbiAgICAgICAgICAgICAgICB6ci5vbignbW91c2Vkb3duJywgbW91c2Vkb3duSGFuZGxlcik7XG4gICAgICAgICAgICAgICAgenIub24oJ21vdXNlbW92ZScsIG1vdXNlbW92ZUhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIHpyLm9uKCdtb3VzZXVwJywgbW91c2V1cEhhbmRsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbnRyb2xUeXBlID09PSB0cnVlIHx8IChjb250cm9sVHlwZSA9PT0gJ3NjYWxlJyB8fCBjb250cm9sVHlwZSA9PT0gJ3pvb20nKSkge1xuICAgICAgICAgICAgICAgIHpyLm9uKCdtb3VzZXdoZWVsJywgbW91c2V3aGVlbEhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIHpyLm9uKCdwaW5jaCcsIHBpbmNoSGFuZGxlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5kaXNhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgenIub2ZmKCdtb3VzZWRvd24nLCBtb3VzZWRvd25IYW5kbGVyKTtcbiAgICAgICAgICAgIHpyLm9mZignbW91c2Vtb3ZlJywgbW91c2Vtb3ZlSGFuZGxlcik7XG4gICAgICAgICAgICB6ci5vZmYoJ21vdXNldXAnLCBtb3VzZXVwSGFuZGxlcik7XG4gICAgICAgICAgICB6ci5vZmYoJ21vdXNld2hlZWwnLCBtb3VzZXdoZWVsSGFuZGxlcik7XG4gICAgICAgICAgICB6ci5vZmYoJ3BpbmNoJywgcGluY2hIYW5kbGVyKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmRpc3Bvc2UgPSB0aGlzLmRpc2FibGU7XG5cbiAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RyYWdnaW5nO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuaXNQaW5jaGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9waW5jaGluZztcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB6clV0aWwubWl4aW4oUm9hbUNvbnRyb2xsZXIsIEV2ZW50ZnVsKTtcblxuXG4gICAgZnVuY3Rpb24gbW91c2Vkb3duKGUpIHtcbiAgICAgICAgaWYgKGUudGFyZ2V0ICYmIGUudGFyZ2V0LmRyYWdnYWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHggPSBlLm9mZnNldFg7XG4gICAgICAgIHZhciB5ID0gZS5vZmZzZXRZO1xuXG4gICAgICAgIC8vIE9ubHkgY2hlY2sgb24gbW9zZWRvd24sIGJ1dCBub3QgbW91c2Vtb3ZlLlxuICAgICAgICAvLyBNb3VzZSBjYW4gYmUgb3V0IG9mIHRhcmdldCB3aGVuIG1vdXNlIG1vdmluZy5cbiAgICAgICAgaWYgKHRoaXMucG9pbnRlckNoZWNrZXIgJiYgdGhpcy5wb2ludGVyQ2hlY2tlcihlLCB4LCB5KSkge1xuICAgICAgICAgICAgdGhpcy5feCA9IHg7XG4gICAgICAgICAgICB0aGlzLl95ID0geTtcbiAgICAgICAgICAgIHRoaXMuX2RyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vdXNlbW92ZShlKSB7XG4gICAgICAgIGlmICghdGhpcy5fZHJhZ2dpbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGV2ZW50VG9vbC5zdG9wKGUuZXZlbnQpO1xuXG4gICAgICAgIGlmIChlLmdlc3R1cmVFdmVudCAhPT0gJ3BpbmNoJykge1xuXG4gICAgICAgICAgICBpZiAoaW50ZXJhY3Rpb25NdXRleC5pc1Rha2VuKHRoaXMuX3pyLCAnZ2xvYmFsUGFuJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB4ID0gZS5vZmZzZXRYO1xuICAgICAgICAgICAgdmFyIHkgPSBlLm9mZnNldFk7XG5cbiAgICAgICAgICAgIHZhciBvbGRYID0gdGhpcy5feDtcbiAgICAgICAgICAgIHZhciBvbGRZID0gdGhpcy5feTtcblxuICAgICAgICAgICAgdmFyIGR4ID0geCAtIG9sZFg7XG4gICAgICAgICAgICB2YXIgZHkgPSB5IC0gb2xkWTtcblxuICAgICAgICAgICAgdGhpcy5feCA9IHg7XG4gICAgICAgICAgICB0aGlzLl95ID0geTtcblxuICAgICAgICAgICAgZXZlbnRUb29sLnN0b3AoZS5ldmVudCk7XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ3BhbicsIGR4LCBkeSwgb2xkWCwgb2xkWSwgeCwgeSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb3VzZXVwKGUpIHtcbiAgICAgICAgdGhpcy5fZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb3VzZXdoZWVsKGUpIHtcbiAgICAgICAgLy8gd2hlZWxEZWx0YSBtYXliZSAtMCBpbiBjaHJvbWUgbWFjLlxuICAgICAgICBpZiAoZS53aGVlbERlbHRhID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29udmVuaWVuY2U6XG4gICAgICAgIC8vIE1hYyBhbmQgVk0gV2luZG93cyBvbiBNYWM6IHNjcm9sbCB1cDogem9vbSBvdXQuXG4gICAgICAgIC8vIFdpbmRvd3M6IHNjcm9sbCB1cDogem9vbSBpbi5cbiAgICAgICAgdmFyIHpvb21EZWx0YSA9IGUud2hlZWxEZWx0YSA+IDAgPyAxLjEgOiAxIC8gMS4xO1xuICAgICAgICB6b29tLmNhbGwodGhpcywgZSwgem9vbURlbHRhLCBlLm9mZnNldFgsIGUub2Zmc2V0WSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGluY2goZSkge1xuICAgICAgICBpZiAoaW50ZXJhY3Rpb25NdXRleC5pc1Rha2VuKHRoaXMuX3pyLCAnZ2xvYmFsUGFuJykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgem9vbURlbHRhID0gZS5waW5jaFNjYWxlID4gMSA/IDEuMSA6IDEgLyAxLjE7XG4gICAgICAgIHpvb20uY2FsbCh0aGlzLCBlLCB6b29tRGVsdGEsIGUucGluY2hYLCBlLnBpbmNoWSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gem9vbShlLCB6b29tRGVsdGEsIHpvb21YLCB6b29tWSkge1xuICAgICAgICBpZiAodGhpcy5wb2ludGVyQ2hlY2tlciAmJiB0aGlzLnBvaW50ZXJDaGVja2VyKGUsIHpvb21YLCB6b29tWSkpIHtcbiAgICAgICAgICAgIC8vIFdoZW4gbW91c2UgaXMgb3V0IG9mIHJvYW1Db250cm9sbGVyIHJlY3QsXG4gICAgICAgICAgICAvLyBkZWZhdWx0IGJlZmF2b2l1cyBzaG91bGQgYmUgYmUgZGlzYWJsZWQsIG90aGVyd2lzZVxuICAgICAgICAgICAgLy8gcGFnZSBzbGlkaW5nIGlzIGRpc2FibGVkLCBjb250cmFyeSB0byBleHBlY3RhdGlvbi5cbiAgICAgICAgICAgIGV2ZW50VG9vbC5zdG9wKGUuZXZlbnQpO1xuXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ3pvb20nLCB6b29tRGVsdGEsIHpvb21YLCB6b29tWSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFJvYW1Db250cm9sbGVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvY29tcG9uZW50L2hlbHBlci9Sb2FtQ29udHJvbGxlci5qc1xuLy8gbW9kdWxlIGlkID0gOTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 100 */
/* unknown exports provided */
/* all exports used */
/*!**********************************!*\
  !*** ./lib/coord/axisDefault.js ***!
  \**********************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 0);\n\n    var defaultOption = {\n        show: true,\n        zlevel: 0,                  // 一级层叠\n        z: 0,                       // 二级层叠\n        // 反向坐标轴\n        inverse: false,\n\n        // 坐标轴名字，默认为空\n        name: '',\n        // 坐标轴名字位置，支持'start' | 'middle' | 'end'\n        nameLocation: 'end',\n        // 坐标轴名字旋转，degree。\n        nameRotate: null, // Adapt to axis rotate, when nameLocation is 'middle'.\n        nameTruncate: {\n            maxWidth: null,\n            ellipsis: '...',\n            placeholder: '.'\n        },\n        // 坐标轴文字样式，默认取全局样式\n        nameTextStyle: {},\n        // 文字与轴线距离\n        nameGap: 15,\n\n        silent: false, // Default false to support tooltip.\n        triggerEvent: false, // Default false to avoid legacy user event listener fail.\n\n        tooltip: {\n            show: false\n        },\n\n        axisPointer: {},\n\n        // 坐标轴线\n        axisLine: {\n            // 默认显示，属性show控制显示与否\n            show: true,\n            onZero: true,\n            // 属性lineStyle控制线条样式\n            lineStyle: {\n                color: '#333',\n                width: 1,\n                type: 'solid'\n            }\n        },\n        // 坐标轴小标记\n        axisTick: {\n            // 属性show控制显示与否，默认显示\n            show: true,\n            // 控制小标记是否在grid里\n            inside: false,\n            // 属性length控制线长\n            length: 5,\n            // 属性lineStyle控制线条样式\n            lineStyle: {\n                width: 1\n            }\n        },\n        // 坐标轴文本标签，详见axis.axisLabel\n        axisLabel: {\n            show: true,\n            // 控制文本标签是否在grid里\n            inside: false,\n            rotate: 0,\n            showMinLabel: null, // true | false | null (auto)\n            showMaxLabel: null, // true | false | null (auto)\n            margin: 8,\n            // formatter: null,\n            // 其余属性默认使用全局文本样式，详见TEXTSTYLE\n            textStyle: {\n                fontSize: 12\n            }\n        },\n        // 分隔线\n        splitLine: {\n            // 默认显示，属性show控制显示与否\n            show: true,\n            // 属性lineStyle（详见lineStyle）控制线条样式\n            lineStyle: {\n                color: ['#ccc'],\n                width: 1,\n                type: 'solid'\n            }\n        },\n        // 分隔区域\n        splitArea: {\n            // 默认不显示，属性show控制显示与否\n            show: false,\n            // 属性areaStyle（详见areaStyle）控制区域样式\n            areaStyle: {\n                color: ['rgba(250,250,250,0.3)','rgba(200,200,200,0.3)']\n            }\n        }\n    };\n\n    var categoryAxis = zrUtil.merge({\n        // 类目起始和结束两端空白策略\n        boundaryGap: true,\n        // splitArea: {\n            // show: false\n        // },\n        splitLine: {\n            show: false\n        },\n        // 坐标轴小标记\n        axisTick: {\n            // If tick is align with label when boundaryGap is true\n            alignWithLabel: false,\n            interval: 'auto'\n        },\n        // 坐标轴文本标签，详见axis.axisLabel\n        axisLabel: {\n            interval: 'auto'\n        }\n    }, defaultOption);\n\n    var valueAxis = zrUtil.merge({\n        // 数值起始和结束两端空白策略\n        boundaryGap: [0, 0],\n        // 最小值, 设置成 'dataMin' 则从数据中计算最小值\n        // min: null,\n        // 最大值，设置成 'dataMax' 则从数据中计算最大值\n        // max: null,\n        // Readonly prop, specifies start value of the range when using data zoom.\n        // rangeStart: null\n        // Readonly prop, specifies end value of the range when using data zoom.\n        // rangeEnd: null\n        // 脱离0值比例，放大聚焦到最终_min，_max区间\n        // scale: false,\n        // 分割段数，默认为5\n        splitNumber: 5\n        // Minimum interval\n        // minInterval: null\n    }, defaultOption);\n\n    // FIXME\n    var timeAxis = zrUtil.defaults({\n        scale: true,\n        min: 'dataMin',\n        max: 'dataMax'\n    }, valueAxis);\n    var logAxis = zrUtil.defaults({\n        logBase: 10\n    }, valueAxis);\n    logAxis.scale = true;\n\n    module.exports = {\n        categoryAxis: categoryAxis,\n        valueAxis: valueAxis,\n        timeAxis: timeAxis,\n        logAxis: logAxis\n    };\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2Nvb3JkL2F4aXNEZWZhdWx0LmpzPzc2N2QiXSwic291cmNlc0NvbnRlbnQiOlsiXG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG5cbiAgICB2YXIgZGVmYXVsdE9wdGlvbiA9IHtcbiAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgemxldmVsOiAwLCAgICAgICAgICAgICAgICAgIC8vIOS4gOe6p+WxguWPoFxuICAgICAgICB6OiAwLCAgICAgICAgICAgICAgICAgICAgICAgLy8g5LqM57qn5bGC5Y+gXG4gICAgICAgIC8vIOWPjeWQkeWdkOagh+i9tFxuICAgICAgICBpbnZlcnNlOiBmYWxzZSxcblxuICAgICAgICAvLyDlnZDmoIfovbTlkI3lrZfvvIzpu5jorqTkuLrnqbpcbiAgICAgICAgbmFtZTogJycsXG4gICAgICAgIC8vIOWdkOagh+i9tOWQjeWtl+S9jee9ru+8jOaUr+aMgSdzdGFydCcgfCAnbWlkZGxlJyB8ICdlbmQnXG4gICAgICAgIG5hbWVMb2NhdGlvbjogJ2VuZCcsXG4gICAgICAgIC8vIOWdkOagh+i9tOWQjeWtl+aXi+i9rO+8jGRlZ3JlZeOAglxuICAgICAgICBuYW1lUm90YXRlOiBudWxsLCAvLyBBZGFwdCB0byBheGlzIHJvdGF0ZSwgd2hlbiBuYW1lTG9jYXRpb24gaXMgJ21pZGRsZScuXG4gICAgICAgIG5hbWVUcnVuY2F0ZToge1xuICAgICAgICAgICAgbWF4V2lkdGg6IG51bGwsXG4gICAgICAgICAgICBlbGxpcHNpczogJy4uLicsXG4gICAgICAgICAgICBwbGFjZWhvbGRlcjogJy4nXG4gICAgICAgIH0sXG4gICAgICAgIC8vIOWdkOagh+i9tOaWh+Wtl+agt+W8j++8jOm7mOiupOWPluWFqOWxgOagt+W8j1xuICAgICAgICBuYW1lVGV4dFN0eWxlOiB7fSxcbiAgICAgICAgLy8g5paH5a2X5LiO6L2057q/6Led56a7XG4gICAgICAgIG5hbWVHYXA6IDE1LFxuXG4gICAgICAgIHNpbGVudDogZmFsc2UsIC8vIERlZmF1bHQgZmFsc2UgdG8gc3VwcG9ydCB0b29sdGlwLlxuICAgICAgICB0cmlnZ2VyRXZlbnQ6IGZhbHNlLCAvLyBEZWZhdWx0IGZhbHNlIHRvIGF2b2lkIGxlZ2FjeSB1c2VyIGV2ZW50IGxpc3RlbmVyIGZhaWwuXG5cbiAgICAgICAgdG9vbHRpcDoge1xuICAgICAgICAgICAgc2hvdzogZmFsc2VcbiAgICAgICAgfSxcblxuICAgICAgICBheGlzUG9pbnRlcjoge30sXG5cbiAgICAgICAgLy8g5Z2Q5qCH6L2057q/XG4gICAgICAgIGF4aXNMaW5lOiB7XG4gICAgICAgICAgICAvLyDpu5jorqTmmL7npLrvvIzlsZ7mgKdzaG935o6n5Yi25pi+56S65LiO5ZCmXG4gICAgICAgICAgICBzaG93OiB0cnVlLFxuICAgICAgICAgICAgb25aZXJvOiB0cnVlLFxuICAgICAgICAgICAgLy8g5bGe5oCnbGluZVN0eWxl5o6n5Yi257q/5p2h5qC35byPXG4gICAgICAgICAgICBsaW5lU3R5bGU6IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogJyMzMzMnLFxuICAgICAgICAgICAgICAgIHdpZHRoOiAxLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdzb2xpZCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLy8g5Z2Q5qCH6L205bCP5qCH6K6wXG4gICAgICAgIGF4aXNUaWNrOiB7XG4gICAgICAgICAgICAvLyDlsZ7mgKdzaG935o6n5Yi25pi+56S65LiO5ZCm77yM6buY6K6k5pi+56S6XG4gICAgICAgICAgICBzaG93OiB0cnVlLFxuICAgICAgICAgICAgLy8g5o6n5Yi25bCP5qCH6K6w5piv5ZCm5ZyoZ3JpZOmHjFxuICAgICAgICAgICAgaW5zaWRlOiBmYWxzZSxcbiAgICAgICAgICAgIC8vIOWxnuaAp2xlbmd0aOaOp+WItue6v+mVv1xuICAgICAgICAgICAgbGVuZ3RoOiA1LFxuICAgICAgICAgICAgLy8g5bGe5oCnbGluZVN0eWxl5o6n5Yi257q/5p2h5qC35byPXG4gICAgICAgICAgICBsaW5lU3R5bGU6IHtcbiAgICAgICAgICAgICAgICB3aWR0aDogMVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvLyDlnZDmoIfovbTmlofmnKzmoIfnrb7vvIzor6bop4FheGlzLmF4aXNMYWJlbFxuICAgICAgICBheGlzTGFiZWw6IHtcbiAgICAgICAgICAgIHNob3c6IHRydWUsXG4gICAgICAgICAgICAvLyDmjqfliLbmlofmnKzmoIfnrb7mmK/lkKblnKhncmlk6YeMXG4gICAgICAgICAgICBpbnNpZGU6IGZhbHNlLFxuICAgICAgICAgICAgcm90YXRlOiAwLFxuICAgICAgICAgICAgc2hvd01pbkxhYmVsOiBudWxsLCAvLyB0cnVlIHwgZmFsc2UgfCBudWxsIChhdXRvKVxuICAgICAgICAgICAgc2hvd01heExhYmVsOiBudWxsLCAvLyB0cnVlIHwgZmFsc2UgfCBudWxsIChhdXRvKVxuICAgICAgICAgICAgbWFyZ2luOiA4LFxuICAgICAgICAgICAgLy8gZm9ybWF0dGVyOiBudWxsLFxuICAgICAgICAgICAgLy8g5YW25L2Z5bGe5oCn6buY6K6k5L2/55So5YWo5bGA5paH5pys5qC35byP77yM6K+m6KeBVEVYVFNUWUxFXG4gICAgICAgICAgICB0ZXh0U3R5bGU6IHtcbiAgICAgICAgICAgICAgICBmb250U2l6ZTogMTJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLy8g5YiG6ZqU57q/XG4gICAgICAgIHNwbGl0TGluZToge1xuICAgICAgICAgICAgLy8g6buY6K6k5pi+56S677yM5bGe5oCnc2hvd+aOp+WItuaYvuekuuS4juWQplxuICAgICAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgICAgIC8vIOWxnuaAp2xpbmVTdHlsZe+8iOivpuingWxpbmVTdHlsZe+8ieaOp+WItue6v+adoeagt+W8j1xuICAgICAgICAgICAgbGluZVN0eWxlOiB7XG4gICAgICAgICAgICAgICAgY29sb3I6IFsnI2NjYyddLFxuICAgICAgICAgICAgICAgIHdpZHRoOiAxLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdzb2xpZCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLy8g5YiG6ZqU5Yy65Z+fXG4gICAgICAgIHNwbGl0QXJlYToge1xuICAgICAgICAgICAgLy8g6buY6K6k5LiN5pi+56S677yM5bGe5oCnc2hvd+aOp+WItuaYvuekuuS4juWQplxuICAgICAgICAgICAgc2hvdzogZmFsc2UsXG4gICAgICAgICAgICAvLyDlsZ7mgKdhcmVhU3R5bGXvvIjor6bop4FhcmVhU3R5bGXvvInmjqfliLbljLrln5/moLflvI9cbiAgICAgICAgICAgIGFyZWFTdHlsZToge1xuICAgICAgICAgICAgICAgIGNvbG9yOiBbJ3JnYmEoMjUwLDI1MCwyNTAsMC4zKScsJ3JnYmEoMjAwLDIwMCwyMDAsMC4zKSddXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGNhdGVnb3J5QXhpcyA9IHpyVXRpbC5tZXJnZSh7XG4gICAgICAgIC8vIOexu+ebrui1t+Wni+WSjOe7k+adn+S4pOerr+epuueZveetlueVpVxuICAgICAgICBib3VuZGFyeUdhcDogdHJ1ZSxcbiAgICAgICAgLy8gc3BsaXRBcmVhOiB7XG4gICAgICAgICAgICAvLyBzaG93OiBmYWxzZVxuICAgICAgICAvLyB9LFxuICAgICAgICBzcGxpdExpbmU6IHtcbiAgICAgICAgICAgIHNob3c6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIC8vIOWdkOagh+i9tOWwj+agh+iusFxuICAgICAgICBheGlzVGljazoge1xuICAgICAgICAgICAgLy8gSWYgdGljayBpcyBhbGlnbiB3aXRoIGxhYmVsIHdoZW4gYm91bmRhcnlHYXAgaXMgdHJ1ZVxuICAgICAgICAgICAgYWxpZ25XaXRoTGFiZWw6IGZhbHNlLFxuICAgICAgICAgICAgaW50ZXJ2YWw6ICdhdXRvJ1xuICAgICAgICB9LFxuICAgICAgICAvLyDlnZDmoIfovbTmlofmnKzmoIfnrb7vvIzor6bop4FheGlzLmF4aXNMYWJlbFxuICAgICAgICBheGlzTGFiZWw6IHtcbiAgICAgICAgICAgIGludGVydmFsOiAnYXV0bydcbiAgICAgICAgfVxuICAgIH0sIGRlZmF1bHRPcHRpb24pO1xuXG4gICAgdmFyIHZhbHVlQXhpcyA9IHpyVXRpbC5tZXJnZSh7XG4gICAgICAgIC8vIOaVsOWAvOi1t+Wni+WSjOe7k+adn+S4pOerr+epuueZveetlueVpVxuICAgICAgICBib3VuZGFyeUdhcDogWzAsIDBdLFxuICAgICAgICAvLyDmnIDlsI/lgLwsIOiuvue9ruaIkCAnZGF0YU1pbicg5YiZ5LuO5pWw5o2u5Lit6K6h566X5pyA5bCP5YC8XG4gICAgICAgIC8vIG1pbjogbnVsbCxcbiAgICAgICAgLy8g5pyA5aSn5YC877yM6K6+572u5oiQICdkYXRhTWF4JyDliJnku47mlbDmja7kuK3orqHnrpfmnIDlpKflgLxcbiAgICAgICAgLy8gbWF4OiBudWxsLFxuICAgICAgICAvLyBSZWFkb25seSBwcm9wLCBzcGVjaWZpZXMgc3RhcnQgdmFsdWUgb2YgdGhlIHJhbmdlIHdoZW4gdXNpbmcgZGF0YSB6b29tLlxuICAgICAgICAvLyByYW5nZVN0YXJ0OiBudWxsXG4gICAgICAgIC8vIFJlYWRvbmx5IHByb3AsIHNwZWNpZmllcyBlbmQgdmFsdWUgb2YgdGhlIHJhbmdlIHdoZW4gdXNpbmcgZGF0YSB6b29tLlxuICAgICAgICAvLyByYW5nZUVuZDogbnVsbFxuICAgICAgICAvLyDohLHnprsw5YC85q+U5L6L77yM5pS+5aSn6IGa54Sm5Yiw5pyA57uIX21pbu+8jF9tYXjljLrpl7RcbiAgICAgICAgLy8gc2NhbGU6IGZhbHNlLFxuICAgICAgICAvLyDliIblibLmrrXmlbDvvIzpu5jorqTkuLo1XG4gICAgICAgIHNwbGl0TnVtYmVyOiA1XG4gICAgICAgIC8vIE1pbmltdW0gaW50ZXJ2YWxcbiAgICAgICAgLy8gbWluSW50ZXJ2YWw6IG51bGxcbiAgICB9LCBkZWZhdWx0T3B0aW9uKTtcblxuICAgIC8vIEZJWE1FXG4gICAgdmFyIHRpbWVBeGlzID0genJVdGlsLmRlZmF1bHRzKHtcbiAgICAgICAgc2NhbGU6IHRydWUsXG4gICAgICAgIG1pbjogJ2RhdGFNaW4nLFxuICAgICAgICBtYXg6ICdkYXRhTWF4J1xuICAgIH0sIHZhbHVlQXhpcyk7XG4gICAgdmFyIGxvZ0F4aXMgPSB6clV0aWwuZGVmYXVsdHMoe1xuICAgICAgICBsb2dCYXNlOiAxMFxuICAgIH0sIHZhbHVlQXhpcyk7XG4gICAgbG9nQXhpcy5zY2FsZSA9IHRydWU7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgY2F0ZWdvcnlBeGlzOiBjYXRlZ29yeUF4aXMsXG4gICAgICAgIHZhbHVlQXhpczogdmFsdWVBeGlzLFxuICAgICAgICB0aW1lQXhpczogdGltZUF4aXMsXG4gICAgICAgIGxvZ0F4aXM6IGxvZ0F4aXNcbiAgICB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvY29vcmQvYXhpc0RlZmF1bHQuanNcbi8vIG1vZHVsZSBpZCA9IDEwMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 101 */
/* unknown exports provided */
/* all exports used */
/*!*******************************!*\
  !*** ./lib/layout/barGrid.js ***!
  \*******************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\n    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 0);\n    var numberUtil = __webpack_require__(/*! ../util/number */ 3);\n    var parsePercent = numberUtil.parsePercent;\n\n    function getSeriesStackId(seriesModel) {\n        return seriesModel.get('stack') || '__ec_stack_' + seriesModel.seriesIndex;\n    }\n\n    function getAxisKey(axis) {\n        return axis.dim + axis.index;\n    }\n\n    function calBarWidthAndOffset(barSeries, api) {\n        // Columns info on each category axis. Key is cartesian name\n        var columnsMap = {};\n\n        zrUtil.each(barSeries, function (seriesModel, idx) {\n            var data = seriesModel.getData();\n            var cartesian = seriesModel.coordinateSystem;\n\n            var baseAxis = cartesian.getBaseAxis();\n            var axisExtent = baseAxis.getExtent();\n            var bandWidth = baseAxis.type === 'category'\n                ? baseAxis.getBandWidth()\n                : (Math.abs(axisExtent[1] - axisExtent[0]) / data.count());\n\n            var columnsOnAxis = columnsMap[getAxisKey(baseAxis)] || {\n                bandWidth: bandWidth,\n                remainedWidth: bandWidth,\n                autoWidthCount: 0,\n                categoryGap: '20%',\n                gap: '30%',\n                stacks: {}\n            };\n            var stacks = columnsOnAxis.stacks;\n            columnsMap[getAxisKey(baseAxis)] = columnsOnAxis;\n\n            var stackId = getSeriesStackId(seriesModel);\n\n            if (!stacks[stackId]) {\n                columnsOnAxis.autoWidthCount++;\n            }\n            stacks[stackId] = stacks[stackId] || {\n                width: 0,\n                maxWidth: 0\n            };\n\n            var barWidth = parsePercent(\n                seriesModel.get('barWidth'), bandWidth\n            );\n            var barMaxWidth = parsePercent(\n                seriesModel.get('barMaxWidth'), bandWidth\n            );\n            var barGap = seriesModel.get('barGap');\n            var barCategoryGap = seriesModel.get('barCategoryGap');\n\n            // Caution: In a single coordinate system, these barGrid attributes\n            // will be shared by series. Consider that they have default values,\n            // only the attributes set on the last series will work.\n            // Do not change this fact unless there will be a break change.\n\n            // TODO\n            if (barWidth && !stacks[stackId].width) {\n                barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);\n                stacks[stackId].width = barWidth;\n                columnsOnAxis.remainedWidth -= barWidth;\n            }\n\n            barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);\n            (barGap != null) && (columnsOnAxis.gap = barGap);\n            (barCategoryGap != null) && (columnsOnAxis.categoryGap = barCategoryGap);\n        });\n\n        var result = {};\n\n        zrUtil.each(columnsMap, function (columnsOnAxis, coordSysName) {\n\n            result[coordSysName] = {};\n\n            var stacks = columnsOnAxis.stacks;\n            var bandWidth = columnsOnAxis.bandWidth;\n            var categoryGap = parsePercent(columnsOnAxis.categoryGap, bandWidth);\n            var barGapPercent = parsePercent(columnsOnAxis.gap, 1);\n\n            var remainedWidth = columnsOnAxis.remainedWidth;\n            var autoWidthCount = columnsOnAxis.autoWidthCount;\n            var autoWidth = (remainedWidth - categoryGap)\n                / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n            autoWidth = Math.max(autoWidth, 0);\n\n            // Find if any auto calculated bar exceeded maxBarWidth\n            zrUtil.each(stacks, function (column, stack) {\n                var maxWidth = column.maxWidth;\n                if (maxWidth && maxWidth < autoWidth) {\n                    maxWidth = Math.min(maxWidth, remainedWidth);\n                    if (column.width) {\n                        maxWidth = Math.min(maxWidth, column.width);\n                    }\n                    remainedWidth -= maxWidth;\n                    column.width = maxWidth;\n                    autoWidthCount--;\n                }\n            });\n\n            // Recalculate width again\n            autoWidth = (remainedWidth - categoryGap)\n                / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n            autoWidth = Math.max(autoWidth, 0);\n\n            var widthSum = 0;\n            var lastColumn;\n            zrUtil.each(stacks, function (column, idx) {\n                if (!column.width) {\n                    column.width = autoWidth;\n                }\n                lastColumn = column;\n                widthSum += column.width * (1 + barGapPercent);\n            });\n            if (lastColumn) {\n                widthSum -= lastColumn.width * barGapPercent;\n            }\n\n            var offset = -widthSum / 2;\n            zrUtil.each(stacks, function (column, stackId) {\n                result[coordSysName][stackId] = result[coordSysName][stackId] || {\n                    offset: offset,\n                    width: column.width\n                };\n\n                offset += column.width * (1 + barGapPercent);\n            });\n        });\n\n        return result;\n    }\n\n    /**\n     * @param {string} seriesType\n     * @param {module:echarts/model/Global} ecModel\n     * @param {module:echarts/ExtensionAPI} api\n     */\n    function barLayoutGrid(seriesType, ecModel, api) {\n\n        var barWidthAndOffset = calBarWidthAndOffset(\n            zrUtil.filter(\n                ecModel.getSeriesByType(seriesType),\n                function (seriesModel) {\n                    return !ecModel.isSeriesFiltered(seriesModel)\n                        && seriesModel.coordinateSystem\n                        && seriesModel.coordinateSystem.type === 'cartesian2d';\n                }\n            )\n        );\n\n        var lastStackCoords = {};\n        var lastStackCoordsOrigin = {};\n\n        ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n\n            var data = seriesModel.getData();\n            var cartesian = seriesModel.coordinateSystem;\n            var baseAxis = cartesian.getBaseAxis();\n\n            var stackId = getSeriesStackId(seriesModel);\n            var columnLayoutInfo = barWidthAndOffset[getAxisKey(baseAxis)][stackId];\n            var columnOffset = columnLayoutInfo.offset;\n            var columnWidth = columnLayoutInfo.width;\n            var valueAxis = cartesian.getOtherAxis(baseAxis);\n\n            var barMinHeight = seriesModel.get('barMinHeight') || 0;\n\n            var valueAxisStart = baseAxis.onZero\n                ? valueAxis.toGlobalCoord(valueAxis.dataToCoord(0))\n                : valueAxis.getGlobalExtent()[0];\n\n            var coords = cartesian.dataToPoints(data, true);\n            lastStackCoords[stackId] = lastStackCoords[stackId] || [];\n            lastStackCoordsOrigin[stackId] = lastStackCoordsOrigin[stackId] || []; // Fix #4243\n\n            data.setLayout({\n                offset: columnOffset,\n                size: columnWidth\n            });\n\n            data.each(valueAxis.dim, function (value, idx) {\n                if (isNaN(value)) {\n                    return;\n                }\n\n                if (!lastStackCoords[stackId][idx]) {\n                    lastStackCoords[stackId][idx] = {\n                        p: valueAxisStart, // Positive stack\n                        n: valueAxisStart  // Negative stack\n                    };\n                    lastStackCoordsOrigin[stackId][idx] = {\n                        p: valueAxisStart, // Positive stack\n                        n: valueAxisStart  // Negative stack\n                    };\n                }\n                var sign = value >= 0 ? 'p' : 'n';\n                var coord = coords[idx];\n                var lastCoord = lastStackCoords[stackId][idx][sign];\n                var lastCoordOrigin = lastStackCoordsOrigin[stackId][idx][sign];\n                var x;\n                var y;\n                var width;\n                var height;\n\n                if (valueAxis.isHorizontal()) {\n                    x = lastCoord;\n                    y = coord[1] + columnOffset;\n                    width = coord[0] - lastCoordOrigin;\n                    height = columnWidth;\n\n                    lastStackCoordsOrigin[stackId][idx][sign] += width;\n                    if (Math.abs(width) < barMinHeight) {\n                        width = (width < 0 ? -1 : 1) * barMinHeight;\n                    }\n                    lastStackCoords[stackId][idx][sign] += width;\n                }\n                else {\n                    x = coord[0] + columnOffset;\n                    y = lastCoord;\n                    width = columnWidth;\n                    height = coord[1] - lastCoordOrigin;\n\n                    lastStackCoordsOrigin[stackId][idx][sign] += height;\n                    if (Math.abs(height) < barMinHeight) {\n                        // Include zero to has a positive bar\n                        height = (height <= 0 ? -1 : 1) * barMinHeight;\n                    }\n                    lastStackCoords[stackId][idx][sign] += height;\n                }\n\n                data.setItemLayout(idx, {\n                    x: x,\n                    y: y,\n                    width: width,\n                    height: height\n                });\n            }, true);\n\n        }, this);\n    }\n\n    module.exports = barLayoutGrid;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAxLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2xheW91dC9iYXJHcmlkLmpzPzZiNWYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG4gICAgdmFyIG51bWJlclV0aWwgPSByZXF1aXJlKCcuLi91dGlsL251bWJlcicpO1xuICAgIHZhciBwYXJzZVBlcmNlbnQgPSBudW1iZXJVdGlsLnBhcnNlUGVyY2VudDtcblxuICAgIGZ1bmN0aW9uIGdldFNlcmllc1N0YWNrSWQoc2VyaWVzTW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIHNlcmllc01vZGVsLmdldCgnc3RhY2snKSB8fCAnX19lY19zdGFja18nICsgc2VyaWVzTW9kZWwuc2VyaWVzSW5kZXg7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0QXhpc0tleShheGlzKSB7XG4gICAgICAgIHJldHVybiBheGlzLmRpbSArIGF4aXMuaW5kZXg7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FsQmFyV2lkdGhBbmRPZmZzZXQoYmFyU2VyaWVzLCBhcGkpIHtcbiAgICAgICAgLy8gQ29sdW1ucyBpbmZvIG9uIGVhY2ggY2F0ZWdvcnkgYXhpcy4gS2V5IGlzIGNhcnRlc2lhbiBuYW1lXG4gICAgICAgIHZhciBjb2x1bW5zTWFwID0ge307XG5cbiAgICAgICAgenJVdGlsLmVhY2goYmFyU2VyaWVzLCBmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIGlkeCkge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgICAgICAgICB2YXIgY2FydGVzaWFuID0gc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcblxuICAgICAgICAgICAgdmFyIGJhc2VBeGlzID0gY2FydGVzaWFuLmdldEJhc2VBeGlzKCk7XG4gICAgICAgICAgICB2YXIgYXhpc0V4dGVudCA9IGJhc2VBeGlzLmdldEV4dGVudCgpO1xuICAgICAgICAgICAgdmFyIGJhbmRXaWR0aCA9IGJhc2VBeGlzLnR5cGUgPT09ICdjYXRlZ29yeSdcbiAgICAgICAgICAgICAgICA/IGJhc2VBeGlzLmdldEJhbmRXaWR0aCgpXG4gICAgICAgICAgICAgICAgOiAoTWF0aC5hYnMoYXhpc0V4dGVudFsxXSAtIGF4aXNFeHRlbnRbMF0pIC8gZGF0YS5jb3VudCgpKTtcblxuICAgICAgICAgICAgdmFyIGNvbHVtbnNPbkF4aXMgPSBjb2x1bW5zTWFwW2dldEF4aXNLZXkoYmFzZUF4aXMpXSB8fCB7XG4gICAgICAgICAgICAgICAgYmFuZFdpZHRoOiBiYW5kV2lkdGgsXG4gICAgICAgICAgICAgICAgcmVtYWluZWRXaWR0aDogYmFuZFdpZHRoLFxuICAgICAgICAgICAgICAgIGF1dG9XaWR0aENvdW50OiAwLFxuICAgICAgICAgICAgICAgIGNhdGVnb3J5R2FwOiAnMjAlJyxcbiAgICAgICAgICAgICAgICBnYXA6ICczMCUnLFxuICAgICAgICAgICAgICAgIHN0YWNrczoge31cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgc3RhY2tzID0gY29sdW1uc09uQXhpcy5zdGFja3M7XG4gICAgICAgICAgICBjb2x1bW5zTWFwW2dldEF4aXNLZXkoYmFzZUF4aXMpXSA9IGNvbHVtbnNPbkF4aXM7XG5cbiAgICAgICAgICAgIHZhciBzdGFja0lkID0gZ2V0U2VyaWVzU3RhY2tJZChzZXJpZXNNb2RlbCk7XG5cbiAgICAgICAgICAgIGlmICghc3RhY2tzW3N0YWNrSWRdKSB7XG4gICAgICAgICAgICAgICAgY29sdW1uc09uQXhpcy5hdXRvV2lkdGhDb3VudCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhY2tzW3N0YWNrSWRdID0gc3RhY2tzW3N0YWNrSWRdIHx8IHtcbiAgICAgICAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICAgICAgICBtYXhXaWR0aDogMFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIGJhcldpZHRoID0gcGFyc2VQZXJjZW50KFxuICAgICAgICAgICAgICAgIHNlcmllc01vZGVsLmdldCgnYmFyV2lkdGgnKSwgYmFuZFdpZHRoXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdmFyIGJhck1heFdpZHRoID0gcGFyc2VQZXJjZW50KFxuICAgICAgICAgICAgICAgIHNlcmllc01vZGVsLmdldCgnYmFyTWF4V2lkdGgnKSwgYmFuZFdpZHRoXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdmFyIGJhckdhcCA9IHNlcmllc01vZGVsLmdldCgnYmFyR2FwJyk7XG4gICAgICAgICAgICB2YXIgYmFyQ2F0ZWdvcnlHYXAgPSBzZXJpZXNNb2RlbC5nZXQoJ2JhckNhdGVnb3J5R2FwJyk7XG5cbiAgICAgICAgICAgIC8vIENhdXRpb246IEluIGEgc2luZ2xlIGNvb3JkaW5hdGUgc3lzdGVtLCB0aGVzZSBiYXJHcmlkIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgIC8vIHdpbGwgYmUgc2hhcmVkIGJ5IHNlcmllcy4gQ29uc2lkZXIgdGhhdCB0aGV5IGhhdmUgZGVmYXVsdCB2YWx1ZXMsXG4gICAgICAgICAgICAvLyBvbmx5IHRoZSBhdHRyaWJ1dGVzIHNldCBvbiB0aGUgbGFzdCBzZXJpZXMgd2lsbCB3b3JrLlxuICAgICAgICAgICAgLy8gRG8gbm90IGNoYW5nZSB0aGlzIGZhY3QgdW5sZXNzIHRoZXJlIHdpbGwgYmUgYSBicmVhayBjaGFuZ2UuXG5cbiAgICAgICAgICAgIC8vIFRPRE9cbiAgICAgICAgICAgIGlmIChiYXJXaWR0aCAmJiAhc3RhY2tzW3N0YWNrSWRdLndpZHRoKSB7XG4gICAgICAgICAgICAgICAgYmFyV2lkdGggPSBNYXRoLm1pbihjb2x1bW5zT25BeGlzLnJlbWFpbmVkV2lkdGgsIGJhcldpZHRoKTtcbiAgICAgICAgICAgICAgICBzdGFja3Nbc3RhY2tJZF0ud2lkdGggPSBiYXJXaWR0aDtcbiAgICAgICAgICAgICAgICBjb2x1bW5zT25BeGlzLnJlbWFpbmVkV2lkdGggLT0gYmFyV2lkdGg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJhck1heFdpZHRoICYmIChzdGFja3Nbc3RhY2tJZF0ubWF4V2lkdGggPSBiYXJNYXhXaWR0aCk7XG4gICAgICAgICAgICAoYmFyR2FwICE9IG51bGwpICYmIChjb2x1bW5zT25BeGlzLmdhcCA9IGJhckdhcCk7XG4gICAgICAgICAgICAoYmFyQ2F0ZWdvcnlHYXAgIT0gbnVsbCkgJiYgKGNvbHVtbnNPbkF4aXMuY2F0ZWdvcnlHYXAgPSBiYXJDYXRlZ29yeUdhcCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcblxuICAgICAgICB6clV0aWwuZWFjaChjb2x1bW5zTWFwLCBmdW5jdGlvbiAoY29sdW1uc09uQXhpcywgY29vcmRTeXNOYW1lKSB7XG5cbiAgICAgICAgICAgIHJlc3VsdFtjb29yZFN5c05hbWVdID0ge307XG5cbiAgICAgICAgICAgIHZhciBzdGFja3MgPSBjb2x1bW5zT25BeGlzLnN0YWNrcztcbiAgICAgICAgICAgIHZhciBiYW5kV2lkdGggPSBjb2x1bW5zT25BeGlzLmJhbmRXaWR0aDtcbiAgICAgICAgICAgIHZhciBjYXRlZ29yeUdhcCA9IHBhcnNlUGVyY2VudChjb2x1bW5zT25BeGlzLmNhdGVnb3J5R2FwLCBiYW5kV2lkdGgpO1xuICAgICAgICAgICAgdmFyIGJhckdhcFBlcmNlbnQgPSBwYXJzZVBlcmNlbnQoY29sdW1uc09uQXhpcy5nYXAsIDEpO1xuXG4gICAgICAgICAgICB2YXIgcmVtYWluZWRXaWR0aCA9IGNvbHVtbnNPbkF4aXMucmVtYWluZWRXaWR0aDtcbiAgICAgICAgICAgIHZhciBhdXRvV2lkdGhDb3VudCA9IGNvbHVtbnNPbkF4aXMuYXV0b1dpZHRoQ291bnQ7XG4gICAgICAgICAgICB2YXIgYXV0b1dpZHRoID0gKHJlbWFpbmVkV2lkdGggLSBjYXRlZ29yeUdhcClcbiAgICAgICAgICAgICAgICAvIChhdXRvV2lkdGhDb3VudCArIChhdXRvV2lkdGhDb3VudCAtIDEpICogYmFyR2FwUGVyY2VudCk7XG4gICAgICAgICAgICBhdXRvV2lkdGggPSBNYXRoLm1heChhdXRvV2lkdGgsIDApO1xuXG4gICAgICAgICAgICAvLyBGaW5kIGlmIGFueSBhdXRvIGNhbGN1bGF0ZWQgYmFyIGV4Y2VlZGVkIG1heEJhcldpZHRoXG4gICAgICAgICAgICB6clV0aWwuZWFjaChzdGFja3MsIGZ1bmN0aW9uIChjb2x1bW4sIHN0YWNrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1heFdpZHRoID0gY29sdW1uLm1heFdpZHRoO1xuICAgICAgICAgICAgICAgIGlmIChtYXhXaWR0aCAmJiBtYXhXaWR0aCA8IGF1dG9XaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICBtYXhXaWR0aCA9IE1hdGgubWluKG1heFdpZHRoLCByZW1haW5lZFdpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbHVtbi53aWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF4V2lkdGggPSBNYXRoLm1pbihtYXhXaWR0aCwgY29sdW1uLndpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZW1haW5lZFdpZHRoIC09IG1heFdpZHRoO1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW4ud2lkdGggPSBtYXhXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgYXV0b1dpZHRoQ291bnQtLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gUmVjYWxjdWxhdGUgd2lkdGggYWdhaW5cbiAgICAgICAgICAgIGF1dG9XaWR0aCA9IChyZW1haW5lZFdpZHRoIC0gY2F0ZWdvcnlHYXApXG4gICAgICAgICAgICAgICAgLyAoYXV0b1dpZHRoQ291bnQgKyAoYXV0b1dpZHRoQ291bnQgLSAxKSAqIGJhckdhcFBlcmNlbnQpO1xuICAgICAgICAgICAgYXV0b1dpZHRoID0gTWF0aC5tYXgoYXV0b1dpZHRoLCAwKTtcblxuICAgICAgICAgICAgdmFyIHdpZHRoU3VtID0gMDtcbiAgICAgICAgICAgIHZhciBsYXN0Q29sdW1uO1xuICAgICAgICAgICAgenJVdGlsLmVhY2goc3RhY2tzLCBmdW5jdGlvbiAoY29sdW1uLCBpZHgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNvbHVtbi53aWR0aCkge1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW4ud2lkdGggPSBhdXRvV2lkdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxhc3RDb2x1bW4gPSBjb2x1bW47XG4gICAgICAgICAgICAgICAgd2lkdGhTdW0gKz0gY29sdW1uLndpZHRoICogKDEgKyBiYXJHYXBQZXJjZW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGxhc3RDb2x1bW4pIHtcbiAgICAgICAgICAgICAgICB3aWR0aFN1bSAtPSBsYXN0Q29sdW1uLndpZHRoICogYmFyR2FwUGVyY2VudDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG9mZnNldCA9IC13aWR0aFN1bSAvIDI7XG4gICAgICAgICAgICB6clV0aWwuZWFjaChzdGFja3MsIGZ1bmN0aW9uIChjb2x1bW4sIHN0YWNrSWQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbY29vcmRTeXNOYW1lXVtzdGFja0lkXSA9IHJlc3VsdFtjb29yZFN5c05hbWVdW3N0YWNrSWRdIHx8IHtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBjb2x1bW4ud2lkdGhcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IGNvbHVtbi53aWR0aCAqICgxICsgYmFyR2FwUGVyY2VudCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VyaWVzVHlwZVxuICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvR2xvYmFsfSBlY01vZGVsXG4gICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9FeHRlbnNpb25BUEl9IGFwaVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhckxheW91dEdyaWQoc2VyaWVzVHlwZSwgZWNNb2RlbCwgYXBpKSB7XG5cbiAgICAgICAgdmFyIGJhcldpZHRoQW5kT2Zmc2V0ID0gY2FsQmFyV2lkdGhBbmRPZmZzZXQoXG4gICAgICAgICAgICB6clV0aWwuZmlsdGVyKFxuICAgICAgICAgICAgICAgIGVjTW9kZWwuZ2V0U2VyaWVzQnlUeXBlKHNlcmllc1R5cGUpLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gIWVjTW9kZWwuaXNTZXJpZXNGaWx0ZXJlZChzZXJpZXNNb2RlbClcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW1cbiAgICAgICAgICAgICAgICAgICAgICAgICYmIHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW0udHlwZSA9PT0gJ2NhcnRlc2lhbjJkJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApXG4gICAgICAgICk7XG5cbiAgICAgICAgdmFyIGxhc3RTdGFja0Nvb3JkcyA9IHt9O1xuICAgICAgICB2YXIgbGFzdFN0YWNrQ29vcmRzT3JpZ2luID0ge307XG5cbiAgICAgICAgZWNNb2RlbC5lYWNoU2VyaWVzQnlUeXBlKHNlcmllc1R5cGUsIGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuXG4gICAgICAgICAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICAgICAgICAgIHZhciBjYXJ0ZXNpYW4gPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICAgICAgICAgICAgdmFyIGJhc2VBeGlzID0gY2FydGVzaWFuLmdldEJhc2VBeGlzKCk7XG5cbiAgICAgICAgICAgIHZhciBzdGFja0lkID0gZ2V0U2VyaWVzU3RhY2tJZChzZXJpZXNNb2RlbCk7XG4gICAgICAgICAgICB2YXIgY29sdW1uTGF5b3V0SW5mbyA9IGJhcldpZHRoQW5kT2Zmc2V0W2dldEF4aXNLZXkoYmFzZUF4aXMpXVtzdGFja0lkXTtcbiAgICAgICAgICAgIHZhciBjb2x1bW5PZmZzZXQgPSBjb2x1bW5MYXlvdXRJbmZvLm9mZnNldDtcbiAgICAgICAgICAgIHZhciBjb2x1bW5XaWR0aCA9IGNvbHVtbkxheW91dEluZm8ud2lkdGg7XG4gICAgICAgICAgICB2YXIgdmFsdWVBeGlzID0gY2FydGVzaWFuLmdldE90aGVyQXhpcyhiYXNlQXhpcyk7XG5cbiAgICAgICAgICAgIHZhciBiYXJNaW5IZWlnaHQgPSBzZXJpZXNNb2RlbC5nZXQoJ2Jhck1pbkhlaWdodCcpIHx8IDA7XG5cbiAgICAgICAgICAgIHZhciB2YWx1ZUF4aXNTdGFydCA9IGJhc2VBeGlzLm9uWmVyb1xuICAgICAgICAgICAgICAgID8gdmFsdWVBeGlzLnRvR2xvYmFsQ29vcmQodmFsdWVBeGlzLmRhdGFUb0Nvb3JkKDApKVxuICAgICAgICAgICAgICAgIDogdmFsdWVBeGlzLmdldEdsb2JhbEV4dGVudCgpWzBdO1xuXG4gICAgICAgICAgICB2YXIgY29vcmRzID0gY2FydGVzaWFuLmRhdGFUb1BvaW50cyhkYXRhLCB0cnVlKTtcbiAgICAgICAgICAgIGxhc3RTdGFja0Nvb3Jkc1tzdGFja0lkXSA9IGxhc3RTdGFja0Nvb3Jkc1tzdGFja0lkXSB8fCBbXTtcbiAgICAgICAgICAgIGxhc3RTdGFja0Nvb3Jkc09yaWdpbltzdGFja0lkXSA9IGxhc3RTdGFja0Nvb3Jkc09yaWdpbltzdGFja0lkXSB8fCBbXTsgLy8gRml4ICM0MjQzXG5cbiAgICAgICAgICAgIGRhdGEuc2V0TGF5b3V0KHtcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IGNvbHVtbk9mZnNldCxcbiAgICAgICAgICAgICAgICBzaXplOiBjb2x1bW5XaWR0aFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGRhdGEuZWFjaCh2YWx1ZUF4aXMuZGltLCBmdW5jdGlvbiAodmFsdWUsIGlkeCkge1xuICAgICAgICAgICAgICAgIGlmIChpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghbGFzdFN0YWNrQ29vcmRzW3N0YWNrSWRdW2lkeF0pIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdFN0YWNrQ29vcmRzW3N0YWNrSWRdW2lkeF0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwOiB2YWx1ZUF4aXNTdGFydCwgLy8gUG9zaXRpdmUgc3RhY2tcbiAgICAgICAgICAgICAgICAgICAgICAgIG46IHZhbHVlQXhpc1N0YXJ0ICAvLyBOZWdhdGl2ZSBzdGFja1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBsYXN0U3RhY2tDb29yZHNPcmlnaW5bc3RhY2tJZF1baWR4XSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHA6IHZhbHVlQXhpc1N0YXJ0LCAvLyBQb3NpdGl2ZSBzdGFja1xuICAgICAgICAgICAgICAgICAgICAgICAgbjogdmFsdWVBeGlzU3RhcnQgIC8vIE5lZ2F0aXZlIHN0YWNrXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBzaWduID0gdmFsdWUgPj0gMCA/ICdwJyA6ICduJztcbiAgICAgICAgICAgICAgICB2YXIgY29vcmQgPSBjb29yZHNbaWR4XTtcbiAgICAgICAgICAgICAgICB2YXIgbGFzdENvb3JkID0gbGFzdFN0YWNrQ29vcmRzW3N0YWNrSWRdW2lkeF1bc2lnbl07XG4gICAgICAgICAgICAgICAgdmFyIGxhc3RDb29yZE9yaWdpbiA9IGxhc3RTdGFja0Nvb3Jkc09yaWdpbltzdGFja0lkXVtpZHhdW3NpZ25dO1xuICAgICAgICAgICAgICAgIHZhciB4O1xuICAgICAgICAgICAgICAgIHZhciB5O1xuICAgICAgICAgICAgICAgIHZhciB3aWR0aDtcbiAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0O1xuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlQXhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgICAgICAgICAgICAgICB4ID0gbGFzdENvb3JkO1xuICAgICAgICAgICAgICAgICAgICB5ID0gY29vcmRbMV0gKyBjb2x1bW5PZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoID0gY29vcmRbMF0gLSBsYXN0Q29vcmRPcmlnaW47XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCA9IGNvbHVtbldpZHRoO1xuXG4gICAgICAgICAgICAgICAgICAgIGxhc3RTdGFja0Nvb3Jkc09yaWdpbltzdGFja0lkXVtpZHhdW3NpZ25dICs9IHdpZHRoO1xuICAgICAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMod2lkdGgpIDwgYmFyTWluSGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCA9ICh3aWR0aCA8IDAgPyAtMSA6IDEpICogYmFyTWluSGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxhc3RTdGFja0Nvb3Jkc1tzdGFja0lkXVtpZHhdW3NpZ25dICs9IHdpZHRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgeCA9IGNvb3JkWzBdICsgY29sdW1uT2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICB5ID0gbGFzdENvb3JkO1xuICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IGNvbHVtbldpZHRoO1xuICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSBjb29yZFsxXSAtIGxhc3RDb29yZE9yaWdpbjtcblxuICAgICAgICAgICAgICAgICAgICBsYXN0U3RhY2tDb29yZHNPcmlnaW5bc3RhY2tJZF1baWR4XVtzaWduXSArPSBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhoZWlnaHQpIDwgYmFyTWluSGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJbmNsdWRlIHplcm8gdG8gaGFzIGEgcG9zaXRpdmUgYmFyXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSAoaGVpZ2h0IDw9IDAgPyAtMSA6IDEpICogYmFyTWluSGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxhc3RTdGFja0Nvb3Jkc1tzdGFja0lkXVtpZHhdW3NpZ25dICs9IGhlaWdodDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBkYXRhLnNldEl0ZW1MYXlvdXQoaWR4LCB7XG4gICAgICAgICAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICAgICAgICAgIHk6IHksXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIHRydWUpO1xuXG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gYmFyTGF5b3V0R3JpZDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2xheW91dC9iYXJHcmlkLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 102 */
/* unknown exports provided */
/* all exports used */
/*!*****************************************!*\
  !*** /home/yx/~/zrender/lib/Handler.js ***!
  \*****************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Handler\n * @module zrender/Handler\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n *         pissang (shenyi.914@gmail.com)\n */\n\n\n    var util = __webpack_require__(/*! ./core/util */ 0);\n    var Draggable = __webpack_require__(/*! ./mixin/Draggable */ 129);\n\n    var Eventful = __webpack_require__(/*! ./mixin/Eventful */ 22);\n\n    var SILENT = 'silent';\n\n    function makeEventPacket(eveType, targetInfo, event) {\n        return {\n            type: eveType,\n            event: event,\n            // target can only be an element that is not silent.\n            target: targetInfo.target,\n            // topTarget can be a silent element.\n            topTarget: targetInfo.topTarget,\n            cancelBubble: false,\n            offsetX: event.zrX,\n            offsetY: event.zrY,\n            gestureEvent: event.gestureEvent,\n            pinchX: event.pinchX,\n            pinchY: event.pinchY,\n            pinchScale: event.pinchScale,\n            wheelDelta: event.zrDelta,\n            zrByTouch: event.zrByTouch\n        };\n    }\n\n    function EmptyProxy () {}\n    EmptyProxy.prototype.dispose = function () {};\n\n    var handlerNames = [\n        'click', 'dblclick', 'mousewheel', 'mouseout',\n        'mouseup', 'mousedown', 'mousemove', 'contextmenu'\n    ];\n    /**\n     * @alias module:zrender/Handler\n     * @constructor\n     * @extends module:zrender/mixin/Eventful\n     * @param {module:zrender/Storage} storage Storage instance.\n     * @param {module:zrender/Painter} painter Painter instance.\n     * @param {module:zrender/dom/HandlerProxy} proxy HandlerProxy instance.\n     * @param {HTMLElement} painterRoot painter.root (not painter.getViewportRoot()).\n     */\n    var Handler = function(storage, painter, proxy, painterRoot) {\n        Eventful.call(this);\n\n        this.storage = storage;\n\n        this.painter = painter;\n\n        this.painterRoot = painterRoot;\n\n        proxy = proxy || new EmptyProxy();\n\n        /**\n         * Proxy of event. can be Dom, WebGLSurface, etc.\n         */\n        this.proxy = proxy;\n\n        // Attach handler\n        proxy.handler = this;\n\n        /**\n         * {target, topTarget}\n         * @private\n         * @type {Object}\n         */\n        this._hovered = {};\n\n        /**\n         * @private\n         * @type {Date}\n         */\n        this._lastTouchMoment;\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._lastX;\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._lastY;\n\n\n        Draggable.call(this);\n\n        util.each(handlerNames, function (name) {\n            proxy.on && proxy.on(name, this[name], this);\n        }, this);\n    };\n\n    Handler.prototype = {\n\n        constructor: Handler,\n\n        mousemove: function (event) {\n            var x = event.zrX;\n            var y = event.zrY;\n\n            var lastHovered = this._hovered;\n            var hovered = this._hovered = this.findHover(x, y);\n            var hoveredTarget = hovered.target;\n            var lastHoveredTarget = lastHovered.target;\n\n            var proxy = this.proxy;\n            proxy.setCursor && proxy.setCursor(hoveredTarget ? hoveredTarget.cursor : 'default');\n\n            // Mouse out on previous hovered element\n            if (lastHoveredTarget && hoveredTarget !== lastHoveredTarget && lastHoveredTarget.__zr) {\n                this.dispatchToElement(lastHovered, 'mouseout', event);\n            }\n\n            // Mouse moving on one element\n            this.dispatchToElement(hovered, 'mousemove', event);\n\n            // Mouse over on a new element\n            if (hoveredTarget && hoveredTarget !== lastHoveredTarget) {\n                this.dispatchToElement(hovered, 'mouseover', event);\n            }\n        },\n\n        mouseout: function (event) {\n            this.dispatchToElement(this._hovered, 'mouseout', event);\n\n            // There might be some doms created by upper layer application\n            // at the same level of painter.getViewportRoot() (e.g., tooltip\n            // dom created by echarts), where 'globalout' event should not\n            // be triggered when mouse enters these doms. (But 'mouseout'\n            // should be triggered at the original hovered element as usual).\n            var element = event.toElement || event.relatedTarget;\n            var innerDom;\n            do {\n                element = element && element.parentNode;\n            }\n            while (element && element.nodeType != 9 && !(\n                innerDom = element === this.painterRoot\n            ));\n\n            !innerDom && this.trigger('globalout', {event: event});\n        },\n\n        /**\n         * Resize\n         */\n        resize: function (event) {\n            this._hovered = {};\n        },\n\n        /**\n         * Dispatch event\n         * @param {string} eventName\n         * @param {event=} eventArgs\n         */\n        dispatch: function (eventName, eventArgs) {\n            var handler = this[eventName];\n            handler && handler.call(this, eventArgs);\n        },\n\n        /**\n         * Dispose\n         */\n        dispose: function () {\n\n            this.proxy.dispose();\n\n            this.storage =\n            this.proxy =\n            this.painter = null;\n        },\n\n        /**\n         * 设置默认的cursor style\n         * @param {string} [cursorStyle='default'] 例如 crosshair\n         */\n        setCursorStyle: function (cursorStyle) {\n            var proxy = this.proxy;\n            proxy.setCursor && proxy.setCursor(cursorStyle);\n        },\n\n        /**\n         * 事件分发代理\n         *\n         * @private\n         * @param {Object} targetInfo {target, topTarget} 目标图形元素\n         * @param {string} eventName 事件名称\n         * @param {Object} event 事件对象\n         */\n        dispatchToElement: function (targetInfo, eventName, event) {\n            targetInfo = targetInfo || {};\n            var eventHandler = 'on' + eventName;\n            var eventPacket = makeEventPacket(eventName, targetInfo, event);\n\n            var el = targetInfo.target;\n            while (el) {\n                el[eventHandler]\n                    && (eventPacket.cancelBubble = el[eventHandler].call(el, eventPacket));\n\n                el.trigger(eventName, eventPacket);\n\n                el = el.parent;\n\n                if (eventPacket.cancelBubble) {\n                    break;\n                }\n            }\n\n            if (!eventPacket.cancelBubble) {\n                // 冒泡到顶级 zrender 对象\n                this.trigger(eventName, eventPacket);\n                // 分发事件到用户自定义层\n                // 用户有可能在全局 click 事件中 dispose，所以需要判断下 painter 是否存在\n                this.painter && this.painter.eachOtherLayer(function (layer) {\n                    if (typeof(layer[eventHandler]) == 'function') {\n                        layer[eventHandler].call(layer, eventPacket);\n                    }\n                    if (layer.trigger) {\n                        layer.trigger(eventName, eventPacket);\n                    }\n                });\n            }\n        },\n\n        /**\n         * @private\n         * @param {number} x\n         * @param {number} y\n         * @param {module:zrender/graphic/Displayable} exclude\n         * @return {model:zrender/Element}\n         * @method\n         */\n        findHover: function(x, y, exclude) {\n            var list = this.storage.getDisplayList();\n            var out = {};\n\n            for (var i = list.length - 1; i >= 0 ; i--) {\n                var hoverCheckResult;\n                if (list[i] !== exclude\n                    // getDisplayList may include ignored item in VML mode\n                    && !list[i].ignore\n                    && (hoverCheckResult = isHover(list[i], x, y))\n                ) {\n                    !out.topTarget && (out.topTarget = list[i]);\n                    if (hoverCheckResult !== SILENT) {\n                        out.target = list[i];\n                        break;\n                    }\n                }\n            }\n\n            return out;\n        }\n    };\n\n    // Common handlers\n    util.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\n        Handler.prototype[name] = function (event) {\n            // Find hover again to avoid click event is dispatched manually. Or click is triggered without mouseover\n            var hovered = this.findHover(event.zrX, event.zrY);\n            var hoveredTarget = hovered.target;\n\n            if (name === 'mousedown') {\n                this._downel = hoveredTarget;\n                // In case click triggered before mouseup\n                this._upel = hoveredTarget;\n            }\n            else if (name === 'mosueup') {\n                this._upel = hoveredTarget;\n            }\n            else if (name === 'click') {\n                if (this._downel !== this._upel) {\n                    return;\n                }\n            }\n\n            this.dispatchToElement(hovered, name, event);\n        };\n    });\n\n    function isHover(displayable, x, y) {\n        if (displayable[displayable.rectHover ? 'rectContain' : 'contain'](x, y)) {\n            var el = displayable;\n            var isSilent;\n            while (el) {\n                // If clipped by ancestor.\n                if (el.clipPath && !el.clipPath.contain(x, y))  {\n                    return false;\n                }\n                if (el.silent) {\n                    isSilent = true;\n                }\n                el = el.parent;\n            }\n            return isSilent ? SILENT : true;\n        }\n\n        return false;\n    }\n\n    util.mixin(Handler, Eventful);\n    util.mixin(Handler, Draggable);\n\n    module.exports = Handler;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy9ob21lL3l4L34venJlbmRlci9saWIvSGFuZGxlci5qcz82MWVmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbi8qKlxuICogSGFuZGxlclxuICogQG1vZHVsZSB6cmVuZGVyL0hhbmRsZXJcbiAqIEBhdXRob3IgS2VuZXIgKEBLZW5lci3mnpfls7AsIGtlbmVyLmxpbmZlbmdAZ21haWwuY29tKVxuICogICAgICAgICBlcnJvcnJpayAoZXJyb3JyaWtAZ21haWwuY29tKVxuICogICAgICAgICBwaXNzYW5nIChzaGVueWkuOTE0QGdtYWlsLmNvbSlcbiAqL1xuXG5cbiAgICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4vY29yZS91dGlsJyk7XG4gICAgdmFyIERyYWdnYWJsZSA9IHJlcXVpcmUoJy4vbWl4aW4vRHJhZ2dhYmxlJyk7XG5cbiAgICB2YXIgRXZlbnRmdWwgPSByZXF1aXJlKCcuL21peGluL0V2ZW50ZnVsJyk7XG5cbiAgICB2YXIgU0lMRU5UID0gJ3NpbGVudCc7XG5cbiAgICBmdW5jdGlvbiBtYWtlRXZlbnRQYWNrZXQoZXZlVHlwZSwgdGFyZ2V0SW5mbywgZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IGV2ZVR5cGUsXG4gICAgICAgICAgICBldmVudDogZXZlbnQsXG4gICAgICAgICAgICAvLyB0YXJnZXQgY2FuIG9ubHkgYmUgYW4gZWxlbWVudCB0aGF0IGlzIG5vdCBzaWxlbnQuXG4gICAgICAgICAgICB0YXJnZXQ6IHRhcmdldEluZm8udGFyZ2V0LFxuICAgICAgICAgICAgLy8gdG9wVGFyZ2V0IGNhbiBiZSBhIHNpbGVudCBlbGVtZW50LlxuICAgICAgICAgICAgdG9wVGFyZ2V0OiB0YXJnZXRJbmZvLnRvcFRhcmdldCxcbiAgICAgICAgICAgIGNhbmNlbEJ1YmJsZTogZmFsc2UsXG4gICAgICAgICAgICBvZmZzZXRYOiBldmVudC56clgsXG4gICAgICAgICAgICBvZmZzZXRZOiBldmVudC56clksXG4gICAgICAgICAgICBnZXN0dXJlRXZlbnQ6IGV2ZW50Lmdlc3R1cmVFdmVudCxcbiAgICAgICAgICAgIHBpbmNoWDogZXZlbnQucGluY2hYLFxuICAgICAgICAgICAgcGluY2hZOiBldmVudC5waW5jaFksXG4gICAgICAgICAgICBwaW5jaFNjYWxlOiBldmVudC5waW5jaFNjYWxlLFxuICAgICAgICAgICAgd2hlZWxEZWx0YTogZXZlbnQuenJEZWx0YSxcbiAgICAgICAgICAgIHpyQnlUb3VjaDogZXZlbnQuenJCeVRvdWNoXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gRW1wdHlQcm94eSAoKSB7fVxuICAgIEVtcHR5UHJveHkucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgIHZhciBoYW5kbGVyTmFtZXMgPSBbXG4gICAgICAgICdjbGljaycsICdkYmxjbGljaycsICdtb3VzZXdoZWVsJywgJ21vdXNlb3V0JyxcbiAgICAgICAgJ21vdXNldXAnLCAnbW91c2Vkb3duJywgJ21vdXNlbW92ZScsICdjb250ZXh0bWVudSdcbiAgICBdO1xuICAgIC8qKlxuICAgICAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9IYW5kbGVyXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGV4dGVuZHMgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWxcbiAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL1N0b3JhZ2V9IHN0b3JhZ2UgU3RvcmFnZSBpbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL1BhaW50ZXJ9IHBhaW50ZXIgUGFpbnRlciBpbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2RvbS9IYW5kbGVyUHJveHl9IHByb3h5IEhhbmRsZXJQcm94eSBpbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwYWludGVyUm9vdCBwYWludGVyLnJvb3QgKG5vdCBwYWludGVyLmdldFZpZXdwb3J0Um9vdCgpKS5cbiAgICAgKi9cbiAgICB2YXIgSGFuZGxlciA9IGZ1bmN0aW9uKHN0b3JhZ2UsIHBhaW50ZXIsIHByb3h5LCBwYWludGVyUm9vdCkge1xuICAgICAgICBFdmVudGZ1bC5jYWxsKHRoaXMpO1xuXG4gICAgICAgIHRoaXMuc3RvcmFnZSA9IHN0b3JhZ2U7XG5cbiAgICAgICAgdGhpcy5wYWludGVyID0gcGFpbnRlcjtcblxuICAgICAgICB0aGlzLnBhaW50ZXJSb290ID0gcGFpbnRlclJvb3Q7XG5cbiAgICAgICAgcHJveHkgPSBwcm94eSB8fCBuZXcgRW1wdHlQcm94eSgpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm94eSBvZiBldmVudC4gY2FuIGJlIERvbSwgV2ViR0xTdXJmYWNlLCBldGMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnByb3h5ID0gcHJveHk7XG5cbiAgICAgICAgLy8gQXR0YWNoIGhhbmRsZXJcbiAgICAgICAgcHJveHkuaGFuZGxlciA9IHRoaXM7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHt0YXJnZXQsIHRvcFRhcmdldH1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2hvdmVyZWQgPSB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHR5cGUge0RhdGV9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9sYXN0VG91Y2hNb21lbnQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9sYXN0WDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2xhc3RZO1xuXG5cbiAgICAgICAgRHJhZ2dhYmxlLmNhbGwodGhpcyk7XG5cbiAgICAgICAgdXRpbC5lYWNoKGhhbmRsZXJOYW1lcywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHByb3h5Lm9uICYmIHByb3h5Lm9uKG5hbWUsIHRoaXNbbmFtZV0sIHRoaXMpO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICB9O1xuXG4gICAgSGFuZGxlci5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IEhhbmRsZXIsXG5cbiAgICAgICAgbW91c2Vtb3ZlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciB4ID0gZXZlbnQuenJYO1xuICAgICAgICAgICAgdmFyIHkgPSBldmVudC56clk7XG5cbiAgICAgICAgICAgIHZhciBsYXN0SG92ZXJlZCA9IHRoaXMuX2hvdmVyZWQ7XG4gICAgICAgICAgICB2YXIgaG92ZXJlZCA9IHRoaXMuX2hvdmVyZWQgPSB0aGlzLmZpbmRIb3Zlcih4LCB5KTtcbiAgICAgICAgICAgIHZhciBob3ZlcmVkVGFyZ2V0ID0gaG92ZXJlZC50YXJnZXQ7XG4gICAgICAgICAgICB2YXIgbGFzdEhvdmVyZWRUYXJnZXQgPSBsYXN0SG92ZXJlZC50YXJnZXQ7XG5cbiAgICAgICAgICAgIHZhciBwcm94eSA9IHRoaXMucHJveHk7XG4gICAgICAgICAgICBwcm94eS5zZXRDdXJzb3IgJiYgcHJveHkuc2V0Q3Vyc29yKGhvdmVyZWRUYXJnZXQgPyBob3ZlcmVkVGFyZ2V0LmN1cnNvciA6ICdkZWZhdWx0Jyk7XG5cbiAgICAgICAgICAgIC8vIE1vdXNlIG91dCBvbiBwcmV2aW91cyBob3ZlcmVkIGVsZW1lbnRcbiAgICAgICAgICAgIGlmIChsYXN0SG92ZXJlZFRhcmdldCAmJiBob3ZlcmVkVGFyZ2V0ICE9PSBsYXN0SG92ZXJlZFRhcmdldCAmJiBsYXN0SG92ZXJlZFRhcmdldC5fX3pyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaFRvRWxlbWVudChsYXN0SG92ZXJlZCwgJ21vdXNlb3V0JywgZXZlbnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBNb3VzZSBtb3Zpbmcgb24gb25lIGVsZW1lbnRcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hUb0VsZW1lbnQoaG92ZXJlZCwgJ21vdXNlbW92ZScsIGV2ZW50KTtcblxuICAgICAgICAgICAgLy8gTW91c2Ugb3ZlciBvbiBhIG5ldyBlbGVtZW50XG4gICAgICAgICAgICBpZiAoaG92ZXJlZFRhcmdldCAmJiBob3ZlcmVkVGFyZ2V0ICE9PSBsYXN0SG92ZXJlZFRhcmdldCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hUb0VsZW1lbnQoaG92ZXJlZCwgJ21vdXNlb3ZlcicsIGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBtb3VzZW91dDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoVG9FbGVtZW50KHRoaXMuX2hvdmVyZWQsICdtb3VzZW91dCcsIGV2ZW50KTtcblxuICAgICAgICAgICAgLy8gVGhlcmUgbWlnaHQgYmUgc29tZSBkb21zIGNyZWF0ZWQgYnkgdXBwZXIgbGF5ZXIgYXBwbGljYXRpb25cbiAgICAgICAgICAgIC8vIGF0IHRoZSBzYW1lIGxldmVsIG9mIHBhaW50ZXIuZ2V0Vmlld3BvcnRSb290KCkgKGUuZy4sIHRvb2x0aXBcbiAgICAgICAgICAgIC8vIGRvbSBjcmVhdGVkIGJ5IGVjaGFydHMpLCB3aGVyZSAnZ2xvYmFsb3V0JyBldmVudCBzaG91bGQgbm90XG4gICAgICAgICAgICAvLyBiZSB0cmlnZ2VyZWQgd2hlbiBtb3VzZSBlbnRlcnMgdGhlc2UgZG9tcy4gKEJ1dCAnbW91c2VvdXQnXG4gICAgICAgICAgICAvLyBzaG91bGQgYmUgdHJpZ2dlcmVkIGF0IHRoZSBvcmlnaW5hbCBob3ZlcmVkIGVsZW1lbnQgYXMgdXN1YWwpLlxuICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBldmVudC50b0VsZW1lbnQgfHwgZXZlbnQucmVsYXRlZFRhcmdldDtcbiAgICAgICAgICAgIHZhciBpbm5lckRvbTtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50ID0gZWxlbWVudCAmJiBlbGVtZW50LnBhcmVudE5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoZWxlbWVudCAmJiBlbGVtZW50Lm5vZGVUeXBlICE9IDkgJiYgIShcbiAgICAgICAgICAgICAgICBpbm5lckRvbSA9IGVsZW1lbnQgPT09IHRoaXMucGFpbnRlclJvb3RcbiAgICAgICAgICAgICkpO1xuXG4gICAgICAgICAgICAhaW5uZXJEb20gJiYgdGhpcy50cmlnZ2VyKCdnbG9iYWxvdXQnLCB7ZXZlbnQ6IGV2ZW50fSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlc2l6ZVxuICAgICAgICAgKi9cbiAgICAgICAgcmVzaXplOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX2hvdmVyZWQgPSB7fTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGlzcGF0Y2ggZXZlbnRcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZVxuICAgICAgICAgKiBAcGFyYW0ge2V2ZW50PX0gZXZlbnRBcmdzXG4gICAgICAgICAqL1xuICAgICAgICBkaXNwYXRjaDogZnVuY3Rpb24gKGV2ZW50TmFtZSwgZXZlbnRBcmdzKSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlciA9IHRoaXNbZXZlbnROYW1lXTtcbiAgICAgICAgICAgIGhhbmRsZXIgJiYgaGFuZGxlci5jYWxsKHRoaXMsIGV2ZW50QXJncyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc3Bvc2VcbiAgICAgICAgICovXG4gICAgICAgIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgdGhpcy5wcm94eS5kaXNwb3NlKCk7XG5cbiAgICAgICAgICAgIHRoaXMuc3RvcmFnZSA9XG4gICAgICAgICAgICB0aGlzLnByb3h5ID1cbiAgICAgICAgICAgIHRoaXMucGFpbnRlciA9IG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiuvue9rum7mOiupOeahGN1cnNvciBzdHlsZVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2N1cnNvclN0eWxlPSdkZWZhdWx0J10g5L6L5aaCIGNyb3NzaGFpclxuICAgICAgICAgKi9cbiAgICAgICAgc2V0Q3Vyc29yU3R5bGU6IGZ1bmN0aW9uIChjdXJzb3JTdHlsZSkge1xuICAgICAgICAgICAgdmFyIHByb3h5ID0gdGhpcy5wcm94eTtcbiAgICAgICAgICAgIHByb3h5LnNldEN1cnNvciAmJiBwcm94eS5zZXRDdXJzb3IoY3Vyc29yU3R5bGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDkuovku7bliIblj5Hku6PnkIZcbiAgICAgICAgICpcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldEluZm8ge3RhcmdldCwgdG9wVGFyZ2V0fSDnm67moIflm77lvaLlhYPntKBcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSDkuovku7blkI3np7BcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IOS6i+S7tuWvueixoVxuICAgICAgICAgKi9cbiAgICAgICAgZGlzcGF0Y2hUb0VsZW1lbnQ6IGZ1bmN0aW9uICh0YXJnZXRJbmZvLCBldmVudE5hbWUsIGV2ZW50KSB7XG4gICAgICAgICAgICB0YXJnZXRJbmZvID0gdGFyZ2V0SW5mbyB8fCB7fTtcbiAgICAgICAgICAgIHZhciBldmVudEhhbmRsZXIgPSAnb24nICsgZXZlbnROYW1lO1xuICAgICAgICAgICAgdmFyIGV2ZW50UGFja2V0ID0gbWFrZUV2ZW50UGFja2V0KGV2ZW50TmFtZSwgdGFyZ2V0SW5mbywgZXZlbnQpO1xuXG4gICAgICAgICAgICB2YXIgZWwgPSB0YXJnZXRJbmZvLnRhcmdldDtcbiAgICAgICAgICAgIHdoaWxlIChlbCkge1xuICAgICAgICAgICAgICAgIGVsW2V2ZW50SGFuZGxlcl1cbiAgICAgICAgICAgICAgICAgICAgJiYgKGV2ZW50UGFja2V0LmNhbmNlbEJ1YmJsZSA9IGVsW2V2ZW50SGFuZGxlcl0uY2FsbChlbCwgZXZlbnRQYWNrZXQpKTtcblxuICAgICAgICAgICAgICAgIGVsLnRyaWdnZXIoZXZlbnROYW1lLCBldmVudFBhY2tldCk7XG5cbiAgICAgICAgICAgICAgICBlbCA9IGVsLnBhcmVudDtcblxuICAgICAgICAgICAgICAgIGlmIChldmVudFBhY2tldC5jYW5jZWxCdWJibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWV2ZW50UGFja2V0LmNhbmNlbEJ1YmJsZSkge1xuICAgICAgICAgICAgICAgIC8vIOWGkuazoeWIsOmhtue6pyB6cmVuZGVyIOWvueixoVxuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcihldmVudE5hbWUsIGV2ZW50UGFja2V0KTtcbiAgICAgICAgICAgICAgICAvLyDliIblj5Hkuovku7bliLDnlKjmiLfoh6rlrprkuYnlsYJcbiAgICAgICAgICAgICAgICAvLyDnlKjmiLfmnInlj6/og73lnKjlhajlsYAgY2xpY2sg5LqL5Lu25LitIGRpc3Bvc2XvvIzmiYDku6XpnIDopoHliKTmlq3kuIsgcGFpbnRlciDmmK/lkKblrZjlnKhcbiAgICAgICAgICAgICAgICB0aGlzLnBhaW50ZXIgJiYgdGhpcy5wYWludGVyLmVhY2hPdGhlckxheWVyKGZ1bmN0aW9uIChsYXllcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mKGxheWVyW2V2ZW50SGFuZGxlcl0pID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheWVyW2V2ZW50SGFuZGxlcl0uY2FsbChsYXllciwgZXZlbnRQYWNrZXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChsYXllci50cmlnZ2VyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXllci50cmlnZ2VyKGV2ZW50TmFtZSwgZXZlbnRQYWNrZXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZX0gZXhjbHVkZVxuICAgICAgICAgKiBAcmV0dXJuIHttb2RlbDp6cmVuZGVyL0VsZW1lbnR9XG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICovXG4gICAgICAgIGZpbmRIb3ZlcjogZnVuY3Rpb24oeCwgeSwgZXhjbHVkZSkge1xuICAgICAgICAgICAgdmFyIGxpc3QgPSB0aGlzLnN0b3JhZ2UuZ2V0RGlzcGxheUxpc3QoKTtcbiAgICAgICAgICAgIHZhciBvdXQgPSB7fTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IGxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwIDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgdmFyIGhvdmVyQ2hlY2tSZXN1bHQ7XG4gICAgICAgICAgICAgICAgaWYgKGxpc3RbaV0gIT09IGV4Y2x1ZGVcbiAgICAgICAgICAgICAgICAgICAgLy8gZ2V0RGlzcGxheUxpc3QgbWF5IGluY2x1ZGUgaWdub3JlZCBpdGVtIGluIFZNTCBtb2RlXG4gICAgICAgICAgICAgICAgICAgICYmICFsaXN0W2ldLmlnbm9yZVxuICAgICAgICAgICAgICAgICAgICAmJiAoaG92ZXJDaGVja1Jlc3VsdCA9IGlzSG92ZXIobGlzdFtpXSwgeCwgeSkpXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICFvdXQudG9wVGFyZ2V0ICYmIChvdXQudG9wVGFyZ2V0ID0gbGlzdFtpXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChob3ZlckNoZWNrUmVzdWx0ICE9PSBTSUxFTlQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dC50YXJnZXQgPSBsaXN0W2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gQ29tbW9uIGhhbmRsZXJzXG4gICAgdXRpbC5lYWNoKFsnY2xpY2snLCAnbW91c2Vkb3duJywgJ21vdXNldXAnLCAnbW91c2V3aGVlbCcsICdkYmxjbGljaycsICdjb250ZXh0bWVudSddLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBIYW5kbGVyLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgLy8gRmluZCBob3ZlciBhZ2FpbiB0byBhdm9pZCBjbGljayBldmVudCBpcyBkaXNwYXRjaGVkIG1hbnVhbGx5LiBPciBjbGljayBpcyB0cmlnZ2VyZWQgd2l0aG91dCBtb3VzZW92ZXJcbiAgICAgICAgICAgIHZhciBob3ZlcmVkID0gdGhpcy5maW5kSG92ZXIoZXZlbnQuenJYLCBldmVudC56clkpO1xuICAgICAgICAgICAgdmFyIGhvdmVyZWRUYXJnZXQgPSBob3ZlcmVkLnRhcmdldDtcblxuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdtb3VzZWRvd24nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZG93bmVsID0gaG92ZXJlZFRhcmdldDtcbiAgICAgICAgICAgICAgICAvLyBJbiBjYXNlIGNsaWNrIHRyaWdnZXJlZCBiZWZvcmUgbW91c2V1cFxuICAgICAgICAgICAgICAgIHRoaXMuX3VwZWwgPSBob3ZlcmVkVGFyZ2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobmFtZSA9PT0gJ21vc3VldXAnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBlbCA9IGhvdmVyZWRUYXJnZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChuYW1lID09PSAnY2xpY2snKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2Rvd25lbCAhPT0gdGhpcy5fdXBlbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoVG9FbGVtZW50KGhvdmVyZWQsIG5hbWUsIGV2ZW50KTtcbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGlzSG92ZXIoZGlzcGxheWFibGUsIHgsIHkpIHtcbiAgICAgICAgaWYgKGRpc3BsYXlhYmxlW2Rpc3BsYXlhYmxlLnJlY3RIb3ZlciA/ICdyZWN0Q29udGFpbicgOiAnY29udGFpbiddKHgsIHkpKSB7XG4gICAgICAgICAgICB2YXIgZWwgPSBkaXNwbGF5YWJsZTtcbiAgICAgICAgICAgIHZhciBpc1NpbGVudDtcbiAgICAgICAgICAgIHdoaWxlIChlbCkge1xuICAgICAgICAgICAgICAgIC8vIElmIGNsaXBwZWQgYnkgYW5jZXN0b3IuXG4gICAgICAgICAgICAgICAgaWYgKGVsLmNsaXBQYXRoICYmICFlbC5jbGlwUGF0aC5jb250YWluKHgsIHkpKSAge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChlbC5zaWxlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNTaWxlbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbCA9IGVsLnBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpc1NpbGVudCA/IFNJTEVOVCA6IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdXRpbC5taXhpbihIYW5kbGVyLCBFdmVudGZ1bCk7XG4gICAgdXRpbC5taXhpbihIYW5kbGVyLCBEcmFnZ2FibGUpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBIYW5kbGVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2hvbWUveXgvfi96cmVuZGVyL2xpYi9IYW5kbGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 103 */
/* unknown exports provided */
/* all exports used */
/*!***************************************!*\
  !*** /home/yx/~/zrender/lib/Layer.js ***!
  \***************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * @module zrender/Layer\n * @author pissang(https://www.github.com/pissang)\n */\n\n\n    var util = __webpack_require__(/*! ./core/util */ 0);\n    var config = __webpack_require__(/*! ./config */ 32);\n    var Style = __webpack_require__(/*! ./graphic/Style */ 64);\n    var Pattern = __webpack_require__(/*! ./graphic/Pattern */ 63);\n\n    function returnFalse() {\n        return false;\n    }\n\n    /**\n     * 创建dom\n     *\n     * @inner\n     * @param {string} id dom id 待用\n     * @param {string} type dom type，such as canvas, div etc.\n     * @param {Painter} painter painter instance\n     * @param {number} number\n     */\n    function createDom(id, type, painter, dpr) {\n        var newDom = document.createElement(type);\n        var width = painter.getWidth();\n        var height = painter.getHeight();\n\n        var newDomStyle = newDom.style;\n        // 没append呢，请原谅我这样写，清晰~\n        newDomStyle.position = 'absolute';\n        newDomStyle.left = 0;\n        newDomStyle.top = 0;\n        newDomStyle.width = width + 'px';\n        newDomStyle.height = height + 'px';\n        newDom.width = width * dpr;\n        newDom.height = height * dpr;\n\n        // id不作为索引用，避免可能造成的重名，定义为私有属性\n        newDom.setAttribute('data-zr-dom-id', id);\n        return newDom;\n    }\n\n    /**\n     * @alias module:zrender/Layer\n     * @constructor\n     * @extends module:zrender/mixin/Transformable\n     * @param {string} id\n     * @param {module:zrender/Painter} painter\n     * @param {number} [dpr]\n     */\n    var Layer = function(id, painter, dpr) {\n        var dom;\n        dpr = dpr || config.devicePixelRatio;\n        if (typeof id === 'string') {\n            dom = createDom(id, 'canvas', painter, dpr);\n        }\n        // Not using isDom because in node it will return false\n        else if (util.isObject(id)) {\n            dom = id;\n            id = dom.id;\n        }\n        this.id = id;\n        this.dom = dom;\n\n        var domStyle = dom.style;\n        if (domStyle) { // Not in node\n            dom.onselectstart = returnFalse; // 避免页面选中的尴尬\n            domStyle['-webkit-user-select'] = 'none';\n            domStyle['user-select'] = 'none';\n            domStyle['-webkit-touch-callout'] = 'none';\n            domStyle['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)';\n            domStyle['padding'] = 0;\n            domStyle['margin'] = 0;\n            domStyle['border-width'] = 0;\n        }\n\n        this.domBack = null;\n        this.ctxBack = null;\n\n        this.painter = painter;\n\n        this.config = null;\n\n        // Configs\n        /**\n         * 每次清空画布的颜色\n         * @type {string}\n         * @default 0\n         */\n        this.clearColor = 0;\n        /**\n         * 是否开启动态模糊\n         * @type {boolean}\n         * @default false\n         */\n        this.motionBlur = false;\n        /**\n         * 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显\n         * @type {number}\n         * @default 0.7\n         */\n        this.lastFrameAlpha = 0.7;\n\n        /**\n         * Layer dpr\n         * @type {number}\n         */\n        this.dpr = dpr;\n    };\n\n    Layer.prototype = {\n\n        constructor: Layer,\n\n        elCount: 0,\n\n        __dirty: true,\n\n        initContext: function () {\n            this.ctx = this.dom.getContext('2d');\n\n            this.ctx.dpr = this.dpr;\n        },\n\n        createBackBuffer: function () {\n            var dpr = this.dpr;\n\n            this.domBack = createDom('back-' + this.id, 'canvas', this.painter, dpr);\n            this.ctxBack = this.domBack.getContext('2d');\n\n            if (dpr != 1) {\n                this.ctxBack.scale(dpr, dpr);\n            }\n        },\n\n        /**\n         * @param  {number} width\n         * @param  {number} height\n         */\n        resize: function (width, height) {\n            var dpr = this.dpr;\n\n            var dom = this.dom;\n            var domStyle = dom.style;\n            var domBack = this.domBack;\n\n            domStyle.width = width + 'px';\n            domStyle.height = height + 'px';\n\n            dom.width = width * dpr;\n            dom.height = height * dpr;\n\n            if (domBack) {\n                domBack.width = width * dpr;\n                domBack.height = height * dpr;\n\n                if (dpr != 1) {\n                    this.ctxBack.scale(dpr, dpr);\n                }\n            }\n        },\n\n        /**\n         * 清空该层画布\n         * @param {boolean} clearAll Clear all with out motion blur\n         */\n        clear: function (clearAll) {\n            var dom = this.dom;\n            var ctx = this.ctx;\n            var width = dom.width;\n            var height = dom.height;\n\n            var clearColor = this.clearColor;\n            var haveMotionBLur = this.motionBlur && !clearAll;\n            var lastFrameAlpha = this.lastFrameAlpha;\n\n            var dpr = this.dpr;\n\n            if (haveMotionBLur) {\n                if (!this.domBack) {\n                    this.createBackBuffer();\n                }\n\n                this.ctxBack.globalCompositeOperation = 'copy';\n                this.ctxBack.drawImage(\n                    dom, 0, 0,\n                    width / dpr,\n                    height / dpr\n                );\n            }\n\n            ctx.clearRect(0, 0, width, height);\n            if (clearColor) {\n                var clearColorGradientOrPattern;\n                // Gradient\n                if (clearColor.colorStops) {\n                    // Cache canvas gradient\n                    clearColorGradientOrPattern = clearColor.__canvasGradient || Style.getGradient(ctx, clearColor, {\n                        x: 0,\n                        y: 0,\n                        width: width,\n                        height: height\n                    });\n\n                    clearColor.__canvasGradient = clearColorGradientOrPattern;\n                }\n                // Pattern\n                else if (clearColor.image) {\n                    clearColorGradientOrPattern = Pattern.prototype.getCanvasPattern.call(clearColor, ctx);\n                }\n                ctx.save();\n                ctx.fillStyle = clearColorGradientOrPattern || clearColor;\n                ctx.fillRect(0, 0, width, height);\n                ctx.restore();\n            }\n\n            if (haveMotionBLur) {\n                var domBack = this.domBack;\n                ctx.save();\n                ctx.globalAlpha = lastFrameAlpha;\n                ctx.drawImage(domBack, 0, 0, width, height);\n                ctx.restore();\n            }\n        }\n    };\n\n    module.exports = Layer;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy9ob21lL3l4L34venJlbmRlci9saWIvTGF5ZXIuanM/YTlhMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgenJlbmRlci9MYXllclxuICogQGF1dGhvciBwaXNzYW5nKGh0dHBzOi8vd3d3LmdpdGh1Yi5jb20vcGlzc2FuZylcbiAqL1xuXG5cbiAgICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4vY29yZS91dGlsJyk7XG4gICAgdmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4vY29uZmlnJyk7XG4gICAgdmFyIFN0eWxlID0gcmVxdWlyZSgnLi9ncmFwaGljL1N0eWxlJyk7XG4gICAgdmFyIFBhdHRlcm4gPSByZXF1aXJlKCcuL2dyYXBoaWMvUGF0dGVybicpO1xuXG4gICAgZnVuY3Rpb24gcmV0dXJuRmFsc2UoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDliJvlu7pkb21cbiAgICAgKlxuICAgICAqIEBpbm5lclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBkb20gaWQg5b6F55SoXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgZG9tIHR5cGXvvIxzdWNoIGFzIGNhbnZhcywgZGl2IGV0Yy5cbiAgICAgKiBAcGFyYW0ge1BhaW50ZXJ9IHBhaW50ZXIgcGFpbnRlciBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVEb20oaWQsIHR5cGUsIHBhaW50ZXIsIGRwcikge1xuICAgICAgICB2YXIgbmV3RG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0eXBlKTtcbiAgICAgICAgdmFyIHdpZHRoID0gcGFpbnRlci5nZXRXaWR0aCgpO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gcGFpbnRlci5nZXRIZWlnaHQoKTtcblxuICAgICAgICB2YXIgbmV3RG9tU3R5bGUgPSBuZXdEb20uc3R5bGU7XG4gICAgICAgIC8vIOayoWFwcGVuZOWRou+8jOivt+WOn+iwheaIkei/meagt+WGme+8jOa4heaZsH5cbiAgICAgICAgbmV3RG9tU3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICBuZXdEb21TdHlsZS5sZWZ0ID0gMDtcbiAgICAgICAgbmV3RG9tU3R5bGUudG9wID0gMDtcbiAgICAgICAgbmV3RG9tU3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gICAgICAgIG5ld0RvbVN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG4gICAgICAgIG5ld0RvbS53aWR0aCA9IHdpZHRoICogZHByO1xuICAgICAgICBuZXdEb20uaGVpZ2h0ID0gaGVpZ2h0ICogZHByO1xuXG4gICAgICAgIC8vIGlk5LiN5L2c5Li657Si5byV55So77yM6YG/5YWN5Y+v6IO96YCg5oiQ55qE6YeN5ZCN77yM5a6a5LmJ5Li656eB5pyJ5bGe5oCnXG4gICAgICAgIG5ld0RvbS5zZXRBdHRyaWJ1dGUoJ2RhdGEtenItZG9tLWlkJywgaWQpO1xuICAgICAgICByZXR1cm4gbmV3RG9tO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9MYXllclxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBleHRlbmRzIG1vZHVsZTp6cmVuZGVyL21peGluL1RyYW5zZm9ybWFibGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWRcbiAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL1BhaW50ZXJ9IHBhaW50ZXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Rwcl1cbiAgICAgKi9cbiAgICB2YXIgTGF5ZXIgPSBmdW5jdGlvbihpZCwgcGFpbnRlciwgZHByKSB7XG4gICAgICAgIHZhciBkb207XG4gICAgICAgIGRwciA9IGRwciB8fCBjb25maWcuZGV2aWNlUGl4ZWxSYXRpbztcbiAgICAgICAgaWYgKHR5cGVvZiBpZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGRvbSA9IGNyZWF0ZURvbShpZCwgJ2NhbnZhcycsIHBhaW50ZXIsIGRwcik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm90IHVzaW5nIGlzRG9tIGJlY2F1c2UgaW4gbm9kZSBpdCB3aWxsIHJldHVybiBmYWxzZVxuICAgICAgICBlbHNlIGlmICh1dGlsLmlzT2JqZWN0KGlkKSkge1xuICAgICAgICAgICAgZG9tID0gaWQ7XG4gICAgICAgICAgICBpZCA9IGRvbS5pZDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHRoaXMuZG9tID0gZG9tO1xuXG4gICAgICAgIHZhciBkb21TdHlsZSA9IGRvbS5zdHlsZTtcbiAgICAgICAgaWYgKGRvbVN0eWxlKSB7IC8vIE5vdCBpbiBub2RlXG4gICAgICAgICAgICBkb20ub25zZWxlY3RzdGFydCA9IHJldHVybkZhbHNlOyAvLyDpgb/lhY3pobXpnaLpgInkuK3nmoTlsLTlsKxcbiAgICAgICAgICAgIGRvbVN0eWxlWyctd2Via2l0LXVzZXItc2VsZWN0J10gPSAnbm9uZSc7XG4gICAgICAgICAgICBkb21TdHlsZVsndXNlci1zZWxlY3QnXSA9ICdub25lJztcbiAgICAgICAgICAgIGRvbVN0eWxlWyctd2Via2l0LXRvdWNoLWNhbGxvdXQnXSA9ICdub25lJztcbiAgICAgICAgICAgIGRvbVN0eWxlWyctd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3InXSA9ICdyZ2JhKDAsMCwwLDApJztcbiAgICAgICAgICAgIGRvbVN0eWxlWydwYWRkaW5nJ10gPSAwO1xuICAgICAgICAgICAgZG9tU3R5bGVbJ21hcmdpbiddID0gMDtcbiAgICAgICAgICAgIGRvbVN0eWxlWydib3JkZXItd2lkdGgnXSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRvbUJhY2sgPSBudWxsO1xuICAgICAgICB0aGlzLmN0eEJhY2sgPSBudWxsO1xuXG4gICAgICAgIHRoaXMucGFpbnRlciA9IHBhaW50ZXI7XG5cbiAgICAgICAgdGhpcy5jb25maWcgPSBudWxsO1xuXG4gICAgICAgIC8vIENvbmZpZ3NcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOavj+asoea4heepuueUu+W4g+eahOminOiJslxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAwXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNsZWFyQ29sb3IgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICog5piv5ZCm5byA5ZCv5Yqo5oCB5qih57OKXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tb3Rpb25CbHVyID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlnKjlvIDlkK/liqjmgIHmqKHns4rnmoTml7blgJnkvb/nlKjvvIzkuI7kuIrkuIDluKfmt7flkIjnmoRhbHBoYeWAvO+8jOWAvOi2iuWkp+Wwvui/uei2iuaYjuaYvlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAwLjdcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGFzdEZyYW1lQWxwaGEgPSAwLjc7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIExheWVyIGRwclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kcHIgPSBkcHI7XG4gICAgfTtcblxuICAgIExheWVyLnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogTGF5ZXIsXG5cbiAgICAgICAgZWxDb3VudDogMCxcblxuICAgICAgICBfX2RpcnR5OiB0cnVlLFxuXG4gICAgICAgIGluaXRDb250ZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmN0eCA9IHRoaXMuZG9tLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAgICAgICAgIHRoaXMuY3R4LmRwciA9IHRoaXMuZHByO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZUJhY2tCdWZmZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBkcHIgPSB0aGlzLmRwcjtcblxuICAgICAgICAgICAgdGhpcy5kb21CYWNrID0gY3JlYXRlRG9tKCdiYWNrLScgKyB0aGlzLmlkLCAnY2FudmFzJywgdGhpcy5wYWludGVyLCBkcHIpO1xuICAgICAgICAgICAgdGhpcy5jdHhCYWNrID0gdGhpcy5kb21CYWNrLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAgICAgICAgIGlmIChkcHIgIT0gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3R4QmFjay5zY2FsZShkcHIsIGRwcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gd2lkdGhcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSBoZWlnaHRcbiAgICAgICAgICovXG4gICAgICAgIHJlc2l6ZTogZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgICAgIHZhciBkcHIgPSB0aGlzLmRwcjtcblxuICAgICAgICAgICAgdmFyIGRvbSA9IHRoaXMuZG9tO1xuICAgICAgICAgICAgdmFyIGRvbVN0eWxlID0gZG9tLnN0eWxlO1xuICAgICAgICAgICAgdmFyIGRvbUJhY2sgPSB0aGlzLmRvbUJhY2s7XG5cbiAgICAgICAgICAgIGRvbVN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICAgICAgICAgICAgZG9tU3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcblxuICAgICAgICAgICAgZG9tLndpZHRoID0gd2lkdGggKiBkcHI7XG4gICAgICAgICAgICBkb20uaGVpZ2h0ID0gaGVpZ2h0ICogZHByO1xuXG4gICAgICAgICAgICBpZiAoZG9tQmFjaykge1xuICAgICAgICAgICAgICAgIGRvbUJhY2sud2lkdGggPSB3aWR0aCAqIGRwcjtcbiAgICAgICAgICAgICAgICBkb21CYWNrLmhlaWdodCA9IGhlaWdodCAqIGRwcjtcblxuICAgICAgICAgICAgICAgIGlmIChkcHIgIT0gMSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN0eEJhY2suc2NhbGUoZHByLCBkcHIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5riF56m66K+l5bGC55S75biDXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gY2xlYXJBbGwgQ2xlYXIgYWxsIHdpdGggb3V0IG1vdGlvbiBibHVyXG4gICAgICAgICAqL1xuICAgICAgICBjbGVhcjogZnVuY3Rpb24gKGNsZWFyQWxsKSB7XG4gICAgICAgICAgICB2YXIgZG9tID0gdGhpcy5kb207XG4gICAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5jdHg7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSBkb20ud2lkdGg7XG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gZG9tLmhlaWdodDtcblxuICAgICAgICAgICAgdmFyIGNsZWFyQ29sb3IgPSB0aGlzLmNsZWFyQ29sb3I7XG4gICAgICAgICAgICB2YXIgaGF2ZU1vdGlvbkJMdXIgPSB0aGlzLm1vdGlvbkJsdXIgJiYgIWNsZWFyQWxsO1xuICAgICAgICAgICAgdmFyIGxhc3RGcmFtZUFscGhhID0gdGhpcy5sYXN0RnJhbWVBbHBoYTtcblxuICAgICAgICAgICAgdmFyIGRwciA9IHRoaXMuZHByO1xuXG4gICAgICAgICAgICBpZiAoaGF2ZU1vdGlvbkJMdXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZG9tQmFjaykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZUJhY2tCdWZmZXIoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmN0eEJhY2suZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2NvcHknO1xuICAgICAgICAgICAgICAgIHRoaXMuY3R4QmFjay5kcmF3SW1hZ2UoXG4gICAgICAgICAgICAgICAgICAgIGRvbSwgMCwgMCxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGggLyBkcHIsXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCAvIGRwclxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICBpZiAoY2xlYXJDb2xvcikge1xuICAgICAgICAgICAgICAgIHZhciBjbGVhckNvbG9yR3JhZGllbnRPclBhdHRlcm47XG4gICAgICAgICAgICAgICAgLy8gR3JhZGllbnRcbiAgICAgICAgICAgICAgICBpZiAoY2xlYXJDb2xvci5jb2xvclN0b3BzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENhY2hlIGNhbnZhcyBncmFkaWVudFxuICAgICAgICAgICAgICAgICAgICBjbGVhckNvbG9yR3JhZGllbnRPclBhdHRlcm4gPSBjbGVhckNvbG9yLl9fY2FudmFzR3JhZGllbnQgfHwgU3R5bGUuZ2V0R3JhZGllbnQoY3R4LCBjbGVhckNvbG9yLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGNsZWFyQ29sb3IuX19jYW52YXNHcmFkaWVudCA9IGNsZWFyQ29sb3JHcmFkaWVudE9yUGF0dGVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUGF0dGVyblxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNsZWFyQ29sb3IuaW1hZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJDb2xvckdyYWRpZW50T3JQYXR0ZXJuID0gUGF0dGVybi5wcm90b3R5cGUuZ2V0Q2FudmFzUGF0dGVybi5jYWxsKGNsZWFyQ29sb3IsIGN0eCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGNsZWFyQ29sb3JHcmFkaWVudE9yUGF0dGVybiB8fCBjbGVhckNvbG9yO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaGF2ZU1vdGlvbkJMdXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgZG9tQmFjayA9IHRoaXMuZG9tQmFjaztcbiAgICAgICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IGxhc3RGcmFtZUFscGhhO1xuICAgICAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UoZG9tQmFjaywgMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IExheWVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2hvbWUveXgvfi96cmVuZGVyL2xpYi9MYXllci5qc1xuLy8gbW9kdWxlIGlkID0gMTAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 104 */
/* unknown exports provided */
/* all exports used */
/*!*****************************************!*\
  !*** /home/yx/~/zrender/lib/Painter.js ***!
  \*****************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Default canvas painter\n * @module zrender/Painter\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n *         pissang (https://www.github.com/pissang)\n */\n \n\n    var config = __webpack_require__(/*! ./config */ 32);\n    var util = __webpack_require__(/*! ./core/util */ 0);\n    var log = __webpack_require__(/*! ./core/log */ 52);\n    var BoundingRect = __webpack_require__(/*! ./core/BoundingRect */ 10);\n    var timsort = __webpack_require__(/*! ./core/timsort */ 43);\n\n    var Layer = __webpack_require__(/*! ./Layer */ 103);\n\n    var requestAnimationFrame = __webpack_require__(/*! ./animation/requestAnimationFrame */ 59);\n\n    // PENDIGN\n    // Layer exceeds MAX_PROGRESSIVE_LAYER_NUMBER may have some problem when flush directly second time.\n    //\n    // Maximum progressive layer. When exceeding this number. All elements will be drawed in the last layer.\n    var MAX_PROGRESSIVE_LAYER_NUMBER = 5;\n\n    function parseInt10(val) {\n        return parseInt(val, 10);\n    }\n\n    function isLayerValid(layer) {\n        if (!layer) {\n            return false;\n        }\n\n        if (layer.__builtin__) {\n            return true;\n        }\n\n        if (typeof(layer.resize) !== 'function'\n            || typeof(layer.refresh) !== 'function'\n        ) {\n            return false;\n        }\n\n        return true;\n    }\n\n    function preProcessLayer(layer) {\n        layer.__unusedCount++;\n    }\n\n    function postProcessLayer(layer) {\n        if (layer.__unusedCount == 1) {\n            layer.clear();\n        }\n    }\n\n    var tmpRect = new BoundingRect(0, 0, 0, 0);\n    var viewRect = new BoundingRect(0, 0, 0, 0);\n    function isDisplayableCulled(el, width, height) {\n        tmpRect.copy(el.getBoundingRect());\n        if (el.transform) {\n            tmpRect.applyTransform(el.transform);\n        }\n        viewRect.width = width;\n        viewRect.height = height;\n        return !tmpRect.intersect(viewRect);\n    }\n\n    function isClipPathChanged(clipPaths, prevClipPaths) {\n        if (clipPaths == prevClipPaths) { // Can both be null or undefined\n            return false;\n        }\n\n        if (!clipPaths || !prevClipPaths || (clipPaths.length !== prevClipPaths.length)) {\n            return true;\n        }\n        for (var i = 0; i < clipPaths.length; i++) {\n            if (clipPaths[i] !== prevClipPaths[i]) {\n                return true;\n            }\n        }\n    }\n\n    function doClip(clipPaths, ctx) {\n        for (var i = 0; i < clipPaths.length; i++) {\n            var clipPath = clipPaths[i];\n\n            clipPath.setTransform(ctx);\n            ctx.beginPath();\n            clipPath.buildPath(ctx, clipPath.shape);\n            ctx.clip();\n            // Transform back\n            clipPath.restoreTransform(ctx);\n        }\n    }\n\n    function createRoot(width, height) {\n        var domRoot = document.createElement('div');\n\n        // domRoot.onselectstart = returnFalse; // 避免页面选中的尴尬\n        domRoot.style.cssText = [\n            'position:relative',\n            'overflow:hidden',\n            'width:' + width + 'px',\n            'height:' + height + 'px',\n            'padding:0',\n            'margin:0',\n            'border-width:0'\n        ].join(';') + ';';\n\n        return domRoot;\n    }\n\n    /**\n     * @alias module:zrender/Painter\n     * @constructor\n     * @param {HTMLElement} root 绘图容器\n     * @param {module:zrender/Storage} storage\n     * @param {Ojbect} opts\n     */\n    var Painter = function (root, storage, opts) {\n        // In node environment using node-canvas\n        var singleCanvas = !root.nodeName // In node ?\n            || root.nodeName.toUpperCase() === 'CANVAS';\n\n        this._opts = opts = util.extend({}, opts || {});\n\n        /**\n         * @type {number}\n         */\n        this.dpr = opts.devicePixelRatio || config.devicePixelRatio;\n        /**\n         * @type {boolean}\n         * @private\n         */\n        this._singleCanvas = singleCanvas;\n        /**\n         * 绘图容器\n         * @type {HTMLElement}\n         */\n        this.root = root;\n\n        var rootStyle = root.style;\n\n        if (rootStyle) {\n            rootStyle['-webkit-tap-highlight-color'] = 'transparent';\n            rootStyle['-webkit-user-select'] =\n            rootStyle['user-select'] =\n            rootStyle['-webkit-touch-callout'] = 'none';\n\n            root.innerHTML = '';\n        }\n\n        /**\n         * @type {module:zrender/Storage}\n         */\n        this.storage = storage;\n\n        /**\n         * @type {Array.<number>}\n         * @private\n         */\n        var zlevelList = this._zlevelList = [];\n\n        /**\n         * @type {Object.<string, module:zrender/Layer>}\n         * @private\n         */\n        var layers = this._layers = {};\n\n        /**\n         * @type {Object.<string, Object>}\n         * @type {private}\n         */\n        this._layerConfig = {};\n\n        if (!singleCanvas) {\n            this._width = this._getSize(0);\n            this._height = this._getSize(1);\n\n            var domRoot = this._domRoot = createRoot(\n                this._width, this._height\n            );\n            root.appendChild(domRoot);\n        }\n        else {\n            if (opts.width != null) {\n                root.width = opts.width;\n            }\n            if (opts.height != null) {\n                root.height = opts.height;\n            }\n            // Use canvas width and height directly\n            var width = root.width;\n            var height = root.height;\n            this._width = width;\n            this._height = height;\n\n            // Create layer if only one given canvas\n            // Device pixel ratio is fixed to 1 because given canvas has its specified width and height\n            var mainLayer = new Layer(root, this, 1);\n            mainLayer.initContext();\n            // FIXME Use canvas width and height\n            // mainLayer.resize(width, height);\n            layers[0] = mainLayer;\n            zlevelList.push(0);\n\n            this._domRoot = root;\n        }\n\n        // Layers for progressive rendering\n        this._progressiveLayers = [];\n\n        /**\n         * @type {module:zrender/Layer}\n         * @private\n         */\n        this._hoverlayer;\n\n        this._hoverElements = [];\n    };\n\n    Painter.prototype = {\n\n        constructor: Painter,\n\n        /**\n         * If painter use a single canvas\n         * @return {boolean}\n         */\n        isSingleCanvas: function () {\n            return this._singleCanvas;\n        },\n        /**\n         * @return {HTMLDivElement}\n         */\n        getViewportRoot: function () {\n            return this._domRoot;\n        },\n\n        /**\n         * 刷新\n         * @param {boolean} [paintAll=false] 强制绘制所有displayable\n         */\n        refresh: function (paintAll) {\n\n            var list = this.storage.getDisplayList(true);\n\n            var zlevelList = this._zlevelList;\n\n            this._paintList(list, paintAll);\n\n            // Paint custum layers\n            for (var i = 0; i < zlevelList.length; i++) {\n                var z = zlevelList[i];\n                var layer = this._layers[z];\n                if (!layer.__builtin__ && layer.refresh) {\n                    layer.refresh();\n                }\n            }\n\n            this.refreshHover();\n\n            if (this._progressiveLayers.length) {\n                this._startProgessive();\n            }\n\n            return this;\n        },\n\n        addHover: function (el, hoverStyle) {\n            if (el.__hoverMir) {\n                return;\n            }\n            var elMirror = new el.constructor({\n                style: el.style,\n                shape: el.shape\n            });\n            elMirror.__from = el;\n            el.__hoverMir = elMirror;\n            elMirror.setStyle(hoverStyle);\n            this._hoverElements.push(elMirror);\n        },\n\n        removeHover: function (el) {\n            var elMirror = el.__hoverMir;\n            var hoverElements = this._hoverElements;\n            var idx = util.indexOf(hoverElements, elMirror);\n            if (idx >= 0) {\n                hoverElements.splice(idx, 1);\n            }\n            el.__hoverMir = null;\n        },\n\n        clearHover: function (el) {\n            var hoverElements = this._hoverElements;\n            for (var i = 0; i < hoverElements.length; i++) {\n                var from = hoverElements[i].__from;\n                if (from) {\n                    from.__hoverMir = null;\n                }\n            }\n            hoverElements.length = 0;\n        },\n\n        refreshHover: function () {\n            var hoverElements = this._hoverElements;\n            var len = hoverElements.length;\n            var hoverLayer = this._hoverlayer;\n            hoverLayer && hoverLayer.clear();\n\n            if (!len) {\n                return;\n            }\n            timsort(hoverElements, this.storage.displayableSortFunc);\n\n            // Use a extream large zlevel\n            // FIXME?\n            if (!hoverLayer) {\n                hoverLayer = this._hoverlayer = this.getLayer(1e5);\n            }\n\n            var scope = {};\n            hoverLayer.ctx.save();\n            for (var i = 0; i < len;) {\n                var el = hoverElements[i];\n                var originalEl = el.__from;\n                // Original el is removed\n                // PENDING\n                if (!(originalEl && originalEl.__zr)) {\n                    hoverElements.splice(i, 1);\n                    originalEl.__hoverMir = null;\n                    len--;\n                    continue;\n                }\n                i++;\n\n                // Use transform\n                // FIXME style and shape ?\n                if (!originalEl.invisible) {\n                    el.transform = originalEl.transform;\n                    el.invTransform = originalEl.invTransform;\n                    el.__clipPaths = originalEl.__clipPaths;\n                    // el.\n                    this._doPaintEl(el, hoverLayer, true, scope);\n                }\n            }\n            hoverLayer.ctx.restore();\n        },\n\n        _startProgessive: function () {\n            var self = this;\n\n            if (!self._furtherProgressive) {\n                return;\n            }\n\n            // Use a token to stop progress steps triggered by\n            // previous zr.refresh calling.\n            var token = self._progressiveToken = +new Date();\n\n            self._progress++;\n            requestAnimationFrame(step);\n\n            function step() {\n                // In case refreshed or disposed\n                if (token === self._progressiveToken && self.storage) {\n\n                    self._doPaintList(self.storage.getDisplayList());\n\n                    if (self._furtherProgressive) {\n                        self._progress++;\n                        requestAnimationFrame(step);\n                    }\n                    else {\n                        self._progressiveToken = -1;\n                    }\n                }\n            }\n        },\n\n        _clearProgressive: function () {\n            this._progressiveToken = -1;\n            this._progress = 0;\n            util.each(this._progressiveLayers, function (layer) {\n                layer.__dirty && layer.clear();\n            });\n        },\n\n        _paintList: function (list, paintAll) {\n\n            if (paintAll == null) {\n                paintAll = false;\n            }\n\n            this._updateLayerStatus(list);\n\n            this._clearProgressive();\n\n            this.eachBuiltinLayer(preProcessLayer);\n\n            this._doPaintList(list, paintAll);\n\n            this.eachBuiltinLayer(postProcessLayer);\n        },\n\n        _doPaintList: function (list, paintAll) {\n            var currentLayer;\n            var currentZLevel;\n            var ctx;\n\n            // var invTransform = [];\n            var scope;\n\n            var progressiveLayerIdx = 0;\n            var currentProgressiveLayer;\n\n            var width = this._width;\n            var height = this._height;\n            var layerProgress;\n            var frame = this._progress;\n            function flushProgressiveLayer(layer) {\n                var dpr = ctx.dpr || 1;\n                ctx.save();\n                ctx.globalAlpha = 1;\n                ctx.shadowBlur = 0;\n                // Avoid layer don't clear in next progressive frame\n                currentLayer.__dirty = true;\n                ctx.setTransform(1, 0, 0, 1, 0, 0);\n                ctx.drawImage(layer.dom, 0, 0, width * dpr, height * dpr);\n                ctx.restore();\n            }\n\n            for (var i = 0, l = list.length; i < l; i++) {\n                var el = list[i];\n                var elZLevel = this._singleCanvas ? 0 : el.zlevel;\n\n                var elFrame = el.__frame;\n\n                // Flush at current context\n                // PENDING\n                if (elFrame < 0 && currentProgressiveLayer) {\n                    flushProgressiveLayer(currentProgressiveLayer);\n                    currentProgressiveLayer = null;\n                }\n\n                // Change draw layer\n                if (currentZLevel !== elZLevel) {\n                    if (ctx) {\n                        ctx.restore();\n                    }\n\n                    // Reset scope\n                    scope = {};\n\n                    // Only 0 zlevel if only has one canvas\n                    currentZLevel = elZLevel;\n                    currentLayer = this.getLayer(currentZLevel);\n\n                    if (!currentLayer.__builtin__) {\n                        log(\n                            'ZLevel ' + currentZLevel\n                            + ' has been used by unkown layer ' + currentLayer.id\n                        );\n                    }\n\n                    ctx = currentLayer.ctx;\n                    ctx.save();\n\n                    // Reset the count\n                    currentLayer.__unusedCount = 0;\n\n                    if (currentLayer.__dirty || paintAll) {\n                        currentLayer.clear();\n                    }\n                }\n\n                if (!(currentLayer.__dirty || paintAll)) {\n                    continue;\n                }\n\n                if (elFrame >= 0) {\n                    // Progressive layer changed\n                    if (!currentProgressiveLayer) {\n                        currentProgressiveLayer = this._progressiveLayers[\n                            Math.min(progressiveLayerIdx++, MAX_PROGRESSIVE_LAYER_NUMBER - 1)\n                        ];\n\n                        currentProgressiveLayer.ctx.save();\n                        currentProgressiveLayer.renderScope = {};\n\n                        if (currentProgressiveLayer\n                            && (currentProgressiveLayer.__progress > currentProgressiveLayer.__maxProgress)\n                        ) {\n                            // flushProgressiveLayer(currentProgressiveLayer);\n                            // Quick jump all progressive elements\n                            // All progressive element are not dirty, jump over and flush directly\n                            i = currentProgressiveLayer.__nextIdxNotProg - 1;\n                            // currentProgressiveLayer = null;\n                            continue;\n                        }\n\n                        layerProgress = currentProgressiveLayer.__progress;\n\n                        if (!currentProgressiveLayer.__dirty) {\n                            // Keep rendering\n                            frame = layerProgress;\n                        }\n\n                        currentProgressiveLayer.__progress = frame + 1;\n                    }\n\n                    if (elFrame === frame) {\n                        this._doPaintEl(el, currentProgressiveLayer, true, currentProgressiveLayer.renderScope);\n                    }\n                }\n                else {\n                    this._doPaintEl(el, currentLayer, paintAll, scope);\n                }\n\n                el.__dirty = false;\n            }\n\n            if (currentProgressiveLayer) {\n                flushProgressiveLayer(currentProgressiveLayer);\n            }\n\n            // Restore the lastLayer ctx\n            ctx && ctx.restore();\n            // If still has clipping state\n            // if (scope.prevElClipPaths) {\n            //     ctx.restore();\n            // }\n\n            this._furtherProgressive = false;\n            util.each(this._progressiveLayers, function (layer) {\n                if (layer.__maxProgress >= layer.__progress) {\n                    this._furtherProgressive = true;\n                }\n            }, this);\n        },\n\n        _doPaintEl: function (el, currentLayer, forcePaint, scope) {\n            var ctx = currentLayer.ctx;\n            var m = el.transform;\n            if (\n                (currentLayer.__dirty || forcePaint)\n                // Ignore invisible element\n                && !el.invisible\n                // Ignore transparent element\n                && el.style.opacity !== 0\n                // Ignore scale 0 element, in some environment like node-canvas\n                // Draw a scale 0 element can cause all following draw wrong\n                // And setTransform with scale 0 will cause set back transform failed.\n                && !(m && !m[0] && !m[3])\n                // Ignore culled element\n                && !(el.culling && isDisplayableCulled(el, this._width, this._height))\n            ) {\n\n                var clipPaths = el.__clipPaths;\n\n                // Optimize when clipping on group with several elements\n                if (scope.prevClipLayer !== currentLayer\n                    || isClipPathChanged(clipPaths, scope.prevElClipPaths)\n                ) {\n                    // If has previous clipping state, restore from it\n                    if (scope.prevElClipPaths) {\n                        scope.prevClipLayer.ctx.restore();\n                        scope.prevClipLayer = scope.prevElClipPaths = null;\n\n                        // Reset prevEl since context has been restored\n                        scope.prevEl = null;\n                    }\n                    // New clipping state\n                    if (clipPaths) {\n                        ctx.save();\n                        doClip(clipPaths, ctx);\n                        scope.prevClipLayer = currentLayer;\n                        scope.prevElClipPaths = clipPaths;\n                    }\n                }\n                el.beforeBrush && el.beforeBrush(ctx);\n\n                el.brush(ctx, scope.prevEl || null);\n                scope.prevEl = el;\n\n                el.afterBrush && el.afterBrush(ctx);\n            }\n        },\n\n        /**\n         * 获取 zlevel 所在层，如果不存在则会创建一个新的层\n         * @param {number} zlevel\n         * @return {module:zrender/Layer}\n         */\n        getLayer: function (zlevel) {\n            if (this._singleCanvas) {\n                return this._layers[0];\n            }\n\n            var layer = this._layers[zlevel];\n            if (!layer) {\n                // Create a new layer\n                layer = new Layer('zr_' + zlevel, this, this.dpr);\n                layer.__builtin__ = true;\n\n                if (this._layerConfig[zlevel]) {\n                    util.merge(layer, this._layerConfig[zlevel], true);\n                }\n\n                this.insertLayer(zlevel, layer);\n\n                // Context is created after dom inserted to document\n                // Or excanvas will get 0px clientWidth and clientHeight\n                layer.initContext();\n            }\n\n            return layer;\n        },\n\n        insertLayer: function (zlevel, layer) {\n\n            var layersMap = this._layers;\n            var zlevelList = this._zlevelList;\n            var len = zlevelList.length;\n            var prevLayer = null;\n            var i = -1;\n            var domRoot = this._domRoot;\n\n            if (layersMap[zlevel]) {\n                log('ZLevel ' + zlevel + ' has been used already');\n                return;\n            }\n            // Check if is a valid layer\n            if (!isLayerValid(layer)) {\n                log('Layer of zlevel ' + zlevel + ' is not valid');\n                return;\n            }\n\n            if (len > 0 && zlevel > zlevelList[0]) {\n                for (i = 0; i < len - 1; i++) {\n                    if (\n                        zlevelList[i] < zlevel\n                        && zlevelList[i + 1] > zlevel\n                    ) {\n                        break;\n                    }\n                }\n                prevLayer = layersMap[zlevelList[i]];\n            }\n            zlevelList.splice(i + 1, 0, zlevel);\n\n            layersMap[zlevel] = layer;\n\n            // Vitual layer will not directly show on the screen.\n            // (It can be a WebGL layer and assigned to a ZImage element)\n            // But it still under management of zrender.\n            if (!layer.virtual) {\n                if (prevLayer) {\n                    var prevDom = prevLayer.dom;\n                    if (prevDom.nextSibling) {\n                        domRoot.insertBefore(\n                            layer.dom,\n                            prevDom.nextSibling\n                        );\n                    }\n                    else {\n                        domRoot.appendChild(layer.dom);\n                    }\n                }\n                else {\n                    if (domRoot.firstChild) {\n                        domRoot.insertBefore(layer.dom, domRoot.firstChild);\n                    }\n                    else {\n                        domRoot.appendChild(layer.dom);\n                    }\n                }\n            }\n        },\n\n        // Iterate each layer\n        eachLayer: function (cb, context) {\n            var zlevelList = this._zlevelList;\n            var z;\n            var i;\n            for (i = 0; i < zlevelList.length; i++) {\n                z = zlevelList[i];\n                cb.call(context, this._layers[z], z);\n            }\n        },\n\n        // Iterate each buildin layer\n        eachBuiltinLayer: function (cb, context) {\n            var zlevelList = this._zlevelList;\n            var layer;\n            var z;\n            var i;\n            for (i = 0; i < zlevelList.length; i++) {\n                z = zlevelList[i];\n                layer = this._layers[z];\n                if (layer.__builtin__) {\n                    cb.call(context, layer, z);\n                }\n            }\n        },\n\n        // Iterate each other layer except buildin layer\n        eachOtherLayer: function (cb, context) {\n            var zlevelList = this._zlevelList;\n            var layer;\n            var z;\n            var i;\n            for (i = 0; i < zlevelList.length; i++) {\n                z = zlevelList[i];\n                layer = this._layers[z];\n                if (!layer.__builtin__) {\n                    cb.call(context, layer, z);\n                }\n            }\n        },\n\n        /**\n         * 获取所有已创建的层\n         * @param {Array.<module:zrender/Layer>} [prevLayer]\n         */\n        getLayers: function () {\n            return this._layers;\n        },\n\n        _updateLayerStatus: function (list) {\n\n            var layers = this._layers;\n            var progressiveLayers = this._progressiveLayers;\n\n            var elCountsLastFrame = {};\n            var progressiveElCountsLastFrame = {};\n\n            this.eachBuiltinLayer(function (layer, z) {\n                elCountsLastFrame[z] = layer.elCount;\n                layer.elCount = 0;\n                layer.__dirty = false;\n            });\n\n            util.each(progressiveLayers, function (layer, idx) {\n                progressiveElCountsLastFrame[idx] = layer.elCount;\n                layer.elCount = 0;\n                layer.__dirty = false;\n            });\n\n            var progressiveLayerCount = 0;\n            var currentProgressiveLayer;\n            var lastProgressiveKey;\n            var frameCount = 0;\n            for (var i = 0, l = list.length; i < l; i++) {\n                var el = list[i];\n                var zlevel = this._singleCanvas ? 0 : el.zlevel;\n                var layer = layers[zlevel];\n                var elProgress = el.progressive;\n                if (layer) {\n                    layer.elCount++;\n                    layer.__dirty = layer.__dirty || el.__dirty;\n                }\n\n                /////// Update progressive\n                if (elProgress >= 0) {\n                    // Fix wrong progressive sequence problem.\n                    if (lastProgressiveKey !== elProgress) {\n                        lastProgressiveKey = elProgress;\n                        frameCount++;\n                    }\n                    var elFrame = el.__frame = frameCount - 1;\n                    if (!currentProgressiveLayer) {\n                        var idx = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER - 1);\n                        currentProgressiveLayer = progressiveLayers[idx];\n                        if (!currentProgressiveLayer) {\n                            currentProgressiveLayer = progressiveLayers[idx] = new Layer(\n                                'progressive', this, this.dpr\n                            );\n                            currentProgressiveLayer.initContext();\n                        }\n                        currentProgressiveLayer.__maxProgress = 0;\n                    }\n                    currentProgressiveLayer.__dirty = currentProgressiveLayer.__dirty || el.__dirty;\n                    currentProgressiveLayer.elCount++;\n\n                    currentProgressiveLayer.__maxProgress = Math.max(\n                        currentProgressiveLayer.__maxProgress, elFrame\n                    );\n\n                    if (currentProgressiveLayer.__maxProgress >= currentProgressiveLayer.__progress) {\n                        // Should keep rendering this  layer because progressive rendering is not finished yet\n                        layer.__dirty = true;\n                    }\n                }\n                else {\n                    el.__frame = -1;\n\n                    if (currentProgressiveLayer) {\n                        currentProgressiveLayer.__nextIdxNotProg = i;\n                        progressiveLayerCount++;\n                        currentProgressiveLayer = null;\n                    }\n                }\n            }\n\n            if (currentProgressiveLayer) {\n                progressiveLayerCount++;\n                currentProgressiveLayer.__nextIdxNotProg = i;\n            }\n\n            // 层中的元素数量有发生变化\n            this.eachBuiltinLayer(function (layer, z) {\n                if (elCountsLastFrame[z] !== layer.elCount) {\n                    layer.__dirty = true;\n                }\n            });\n\n            progressiveLayers.length = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER);\n            util.each(progressiveLayers, function (layer, idx) {\n                if (progressiveElCountsLastFrame[idx] !== layer.elCount) {\n                    el.__dirty = true;\n                }\n                if (layer.__dirty) {\n                    layer.__progress = 0;\n                }\n            });\n        },\n\n        /**\n         * 清除hover层外所有内容\n         */\n        clear: function () {\n            this.eachBuiltinLayer(this._clearLayer);\n            return this;\n        },\n\n        _clearLayer: function (layer) {\n            layer.clear();\n        },\n\n        /**\n         * 修改指定zlevel的绘制参数\n         *\n         * @param {string} zlevel\n         * @param {Object} config 配置对象\n         * @param {string} [config.clearColor=0] 每次清空画布的颜色\n         * @param {string} [config.motionBlur=false] 是否开启动态模糊\n         * @param {number} [config.lastFrameAlpha=0.7]\n         *                 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显\n         */\n        configLayer: function (zlevel, config) {\n            if (config) {\n                var layerConfig = this._layerConfig;\n                if (!layerConfig[zlevel]) {\n                    layerConfig[zlevel] = config;\n                }\n                else {\n                    util.merge(layerConfig[zlevel], config, true);\n                }\n\n                var layer = this._layers[zlevel];\n\n                if (layer) {\n                    util.merge(layer, layerConfig[zlevel], true);\n                }\n            }\n        },\n\n        /**\n         * 删除指定层\n         * @param {number} zlevel 层所在的zlevel\n         */\n        delLayer: function (zlevel) {\n            var layers = this._layers;\n            var zlevelList = this._zlevelList;\n            var layer = layers[zlevel];\n            if (!layer) {\n                return;\n            }\n            layer.dom.parentNode.removeChild(layer.dom);\n            delete layers[zlevel];\n\n            zlevelList.splice(util.indexOf(zlevelList, zlevel), 1);\n        },\n\n        /**\n         * 区域大小变化后重绘\n         */\n        resize: function (width, height) {\n            var domRoot = this._domRoot;\n            // FIXME Why ?\n            domRoot.style.display = 'none';\n\n            // Save input w/h\n            var opts = this._opts;\n            width != null && (opts.width = width);\n            height != null && (opts.height = height);\n\n            width = this._getSize(0);\n            height = this._getSize(1);\n\n            domRoot.style.display = '';\n\n            // 优化没有实际改变的resize\n            if (this._width != width || height != this._height) {\n                domRoot.style.width = width + 'px';\n                domRoot.style.height = height + 'px';\n\n                for (var id in this._layers) {\n                    if (this._layers.hasOwnProperty(id)) {\n                        this._layers[id].resize(width, height);\n                    }\n                }\n                util.each(this._progressiveLayers, function (layer) {\n                    layer.resize(width, height);\n                });\n\n                this.refresh(true);\n            }\n\n            this._width = width;\n            this._height = height;\n\n            return this;\n        },\n\n        /**\n         * 清除单独的一个层\n         * @param {number} zlevel\n         */\n        clearLayer: function (zlevel) {\n            var layer = this._layers[zlevel];\n            if (layer) {\n                layer.clear();\n            }\n        },\n\n        /**\n         * 释放\n         */\n        dispose: function () {\n            this.root.innerHTML = '';\n\n            this.root =\n            this.storage =\n\n            this._domRoot =\n            this._layers = null;\n        },\n\n        /**\n         * Get canvas which has all thing rendered\n         * @param {Object} opts\n         * @param {string} [opts.backgroundColor]\n         */\n        getRenderedCanvas: function (opts) {\n            opts = opts || {};\n            if (this._singleCanvas) {\n                return this._layers[0].dom;\n            }\n\n            var imageLayer = new Layer('image', this, opts.pixelRatio || this.dpr);\n            imageLayer.initContext();\n\n            imageLayer.clearColor = opts.backgroundColor;\n            imageLayer.clear();\n\n            var displayList = this.storage.getDisplayList(true);\n\n            var scope = {};\n            for (var i = 0; i < displayList.length; i++) {\n                var el = displayList[i];\n                this._doPaintEl(el, imageLayer, true, scope);\n            }\n\n            return imageLayer.dom;\n        },\n        /**\n         * 获取绘图区域宽度\n         */\n        getWidth: function () {\n            return this._width;\n        },\n\n        /**\n         * 获取绘图区域高度\n         */\n        getHeight: function () {\n            return this._height;\n        },\n\n        _getSize: function (whIdx) {\n            var opts = this._opts;\n            var wh = ['width', 'height'][whIdx];\n            var cwh = ['clientWidth', 'clientHeight'][whIdx];\n            var plt = ['paddingLeft', 'paddingTop'][whIdx];\n            var prb = ['paddingRight', 'paddingBottom'][whIdx];\n\n            if (opts[wh] != null && opts[wh] !== 'auto') {\n                return parseFloat(opts[wh]);\n            }\n\n            var root = this.root;\n            var stl = document.defaultView.getComputedStyle(root);\n\n            return (\n                (root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh]))\n                - (parseInt10(stl[plt]) || 0)\n                - (parseInt10(stl[prb]) || 0)\n            ) | 0;\n        },\n\n        pathToImage: function (path, dpr) {\n            dpr = dpr || this.dpr;\n\n            var canvas = document.createElement('canvas');\n            var ctx = canvas.getContext('2d');\n            var rect = path.getBoundingRect();\n            var style = path.style;\n            var shadowBlurSize = style.shadowBlur;\n            var shadowOffsetX = style.shadowOffsetX;\n            var shadowOffsetY = style.shadowOffsetY;\n            var lineWidth = style.hasStroke() ? style.lineWidth : 0;\n\n            var leftMargin = Math.max(lineWidth / 2, -shadowOffsetX + shadowBlurSize);\n            var rightMargin = Math.max(lineWidth / 2, shadowOffsetX + shadowBlurSize);\n            var topMargin = Math.max(lineWidth / 2, -shadowOffsetY + shadowBlurSize);\n            var bottomMargin = Math.max(lineWidth / 2, shadowOffsetY + shadowBlurSize);\n            var width = rect.width + leftMargin + rightMargin;\n            var height = rect.height + topMargin + bottomMargin;\n\n            canvas.width = width * dpr;\n            canvas.height = height * dpr;\n\n            ctx.scale(dpr, dpr);\n            ctx.clearRect(0, 0, width, height);\n            ctx.dpr = dpr;\n\n            var pathTransform = {\n                position: path.position,\n                rotation: path.rotation,\n                scale: path.scale\n            };\n            path.position = [leftMargin - rect.x, topMargin - rect.y];\n            path.rotation = 0;\n            path.scale = [1, 1];\n            path.updateTransform();\n            if (path) {\n                path.brush(ctx);\n            }\n\n            var ImageShape = __webpack_require__(/*! ./graphic/Image */ 53);\n            var imgShape = new ImageShape({\n                style: {\n                    x: 0,\n                    y: 0,\n                    image: canvas\n                }\n            });\n\n            if (pathTransform.position != null) {\n                imgShape.position = path.position = pathTransform.position;\n            }\n\n            if (pathTransform.rotation != null) {\n                imgShape.rotation = path.rotation = pathTransform.rotation;\n            }\n\n            if (pathTransform.scale != null) {\n                imgShape.scale = path.scale = pathTransform.scale;\n            }\n\n            return imgShape;\n        }\n    };\n\n    module.exports = Painter;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTA0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy9ob21lL3l4L34venJlbmRlci9saWIvUGFpbnRlci5qcz9mMDY5Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbi8qKlxuICogRGVmYXVsdCBjYW52YXMgcGFpbnRlclxuICogQG1vZHVsZSB6cmVuZGVyL1BhaW50ZXJcbiAqIEBhdXRob3IgS2VuZXIgKEBLZW5lci3mnpfls7AsIGtlbmVyLmxpbmZlbmdAZ21haWwuY29tKVxuICogICAgICAgICBlcnJvcnJpayAoZXJyb3JyaWtAZ21haWwuY29tKVxuICogICAgICAgICBwaXNzYW5nIChodHRwczovL3d3dy5naXRodWIuY29tL3Bpc3NhbmcpXG4gKi9cbiBcblxuICAgIHZhciBjb25maWcgPSByZXF1aXJlKCcuL2NvbmZpZycpO1xuICAgIHZhciB1dGlsID0gcmVxdWlyZSgnLi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgbG9nID0gcmVxdWlyZSgnLi9jb3JlL2xvZycpO1xuICAgIHZhciBCb3VuZGluZ1JlY3QgPSByZXF1aXJlKCcuL2NvcmUvQm91bmRpbmdSZWN0Jyk7XG4gICAgdmFyIHRpbXNvcnQgPSByZXF1aXJlKCcuL2NvcmUvdGltc29ydCcpO1xuXG4gICAgdmFyIExheWVyID0gcmVxdWlyZSgnLi9MYXllcicpO1xuXG4gICAgdmFyIHJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHJlcXVpcmUoJy4vYW5pbWF0aW9uL3JlcXVlc3RBbmltYXRpb25GcmFtZScpO1xuXG4gICAgLy8gUEVORElHTlxuICAgIC8vIExheWVyIGV4Y2VlZHMgTUFYX1BST0dSRVNTSVZFX0xBWUVSX05VTUJFUiBtYXkgaGF2ZSBzb21lIHByb2JsZW0gd2hlbiBmbHVzaCBkaXJlY3RseSBzZWNvbmQgdGltZS5cbiAgICAvL1xuICAgIC8vIE1heGltdW0gcHJvZ3Jlc3NpdmUgbGF5ZXIuIFdoZW4gZXhjZWVkaW5nIHRoaXMgbnVtYmVyLiBBbGwgZWxlbWVudHMgd2lsbCBiZSBkcmF3ZWQgaW4gdGhlIGxhc3QgbGF5ZXIuXG4gICAgdmFyIE1BWF9QUk9HUkVTU0lWRV9MQVlFUl9OVU1CRVIgPSA1O1xuXG4gICAgZnVuY3Rpb24gcGFyc2VJbnQxMCh2YWwpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KHZhbCwgMTApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTGF5ZXJWYWxpZChsYXllcikge1xuICAgICAgICBpZiAoIWxheWVyKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGF5ZXIuX19idWlsdGluX18pIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZihsYXllci5yZXNpemUpICE9PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICB8fCB0eXBlb2YobGF5ZXIucmVmcmVzaCkgIT09ICdmdW5jdGlvbidcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmVQcm9jZXNzTGF5ZXIobGF5ZXIpIHtcbiAgICAgICAgbGF5ZXIuX191bnVzZWRDb3VudCsrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBvc3RQcm9jZXNzTGF5ZXIobGF5ZXIpIHtcbiAgICAgICAgaWYgKGxheWVyLl9fdW51c2VkQ291bnQgPT0gMSkge1xuICAgICAgICAgICAgbGF5ZXIuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciB0bXBSZWN0ID0gbmV3IEJvdW5kaW5nUmVjdCgwLCAwLCAwLCAwKTtcbiAgICB2YXIgdmlld1JlY3QgPSBuZXcgQm91bmRpbmdSZWN0KDAsIDAsIDAsIDApO1xuICAgIGZ1bmN0aW9uIGlzRGlzcGxheWFibGVDdWxsZWQoZWwsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgdG1wUmVjdC5jb3B5KGVsLmdldEJvdW5kaW5nUmVjdCgpKTtcbiAgICAgICAgaWYgKGVsLnRyYW5zZm9ybSkge1xuICAgICAgICAgICAgdG1wUmVjdC5hcHBseVRyYW5zZm9ybShlbC50cmFuc2Zvcm0pO1xuICAgICAgICB9XG4gICAgICAgIHZpZXdSZWN0LndpZHRoID0gd2lkdGg7XG4gICAgICAgIHZpZXdSZWN0LmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgcmV0dXJuICF0bXBSZWN0LmludGVyc2VjdCh2aWV3UmVjdCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNDbGlwUGF0aENoYW5nZWQoY2xpcFBhdGhzLCBwcmV2Q2xpcFBhdGhzKSB7XG4gICAgICAgIGlmIChjbGlwUGF0aHMgPT0gcHJldkNsaXBQYXRocykgeyAvLyBDYW4gYm90aCBiZSBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFjbGlwUGF0aHMgfHwgIXByZXZDbGlwUGF0aHMgfHwgKGNsaXBQYXRocy5sZW5ndGggIT09IHByZXZDbGlwUGF0aHMubGVuZ3RoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGlwUGF0aHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChjbGlwUGF0aHNbaV0gIT09IHByZXZDbGlwUGF0aHNbaV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRvQ2xpcChjbGlwUGF0aHMsIGN0eCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsaXBQYXRocy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNsaXBQYXRoID0gY2xpcFBhdGhzW2ldO1xuXG4gICAgICAgICAgICBjbGlwUGF0aC5zZXRUcmFuc2Zvcm0oY3R4KTtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGNsaXBQYXRoLmJ1aWxkUGF0aChjdHgsIGNsaXBQYXRoLnNoYXBlKTtcbiAgICAgICAgICAgIGN0eC5jbGlwKCk7XG4gICAgICAgICAgICAvLyBUcmFuc2Zvcm0gYmFja1xuICAgICAgICAgICAgY2xpcFBhdGgucmVzdG9yZVRyYW5zZm9ybShjdHgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlUm9vdCh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHZhciBkb21Sb290ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICAgICAgLy8gZG9tUm9vdC5vbnNlbGVjdHN0YXJ0ID0gcmV0dXJuRmFsc2U7IC8vIOmBv+WFjemhtemdoumAieS4reeahOWwtOWwrFxuICAgICAgICBkb21Sb290LnN0eWxlLmNzc1RleHQgPSBbXG4gICAgICAgICAgICAncG9zaXRpb246cmVsYXRpdmUnLFxuICAgICAgICAgICAgJ292ZXJmbG93OmhpZGRlbicsXG4gICAgICAgICAgICAnd2lkdGg6JyArIHdpZHRoICsgJ3B4JyxcbiAgICAgICAgICAgICdoZWlnaHQ6JyArIGhlaWdodCArICdweCcsXG4gICAgICAgICAgICAncGFkZGluZzowJyxcbiAgICAgICAgICAgICdtYXJnaW46MCcsXG4gICAgICAgICAgICAnYm9yZGVyLXdpZHRoOjAnXG4gICAgICAgIF0uam9pbignOycpICsgJzsnO1xuXG4gICAgICAgIHJldHVybiBkb21Sb290O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9QYWludGVyXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcm9vdCDnu5jlm77lrrnlmahcbiAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL1N0b3JhZ2V9IHN0b3JhZ2VcbiAgICAgKiBAcGFyYW0ge09qYmVjdH0gb3B0c1xuICAgICAqL1xuICAgIHZhciBQYWludGVyID0gZnVuY3Rpb24gKHJvb3QsIHN0b3JhZ2UsIG9wdHMpIHtcbiAgICAgICAgLy8gSW4gbm9kZSBlbnZpcm9ubWVudCB1c2luZyBub2RlLWNhbnZhc1xuICAgICAgICB2YXIgc2luZ2xlQ2FudmFzID0gIXJvb3Qubm9kZU5hbWUgLy8gSW4gbm9kZSA/XG4gICAgICAgICAgICB8fCByb290Lm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgPT09ICdDQU5WQVMnO1xuXG4gICAgICAgIHRoaXMuX29wdHMgPSBvcHRzID0gdXRpbC5leHRlbmQoe30sIG9wdHMgfHwge30pO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kcHIgPSBvcHRzLmRldmljZVBpeGVsUmF0aW8gfHwgY29uZmlnLmRldmljZVBpeGVsUmF0aW87XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3NpbmdsZUNhbnZhcyA9IHNpbmdsZUNhbnZhcztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOe7mOWbvuWuueWZqFxuICAgICAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJvb3QgPSByb290O1xuXG4gICAgICAgIHZhciByb290U3R5bGUgPSByb290LnN0eWxlO1xuXG4gICAgICAgIGlmIChyb290U3R5bGUpIHtcbiAgICAgICAgICAgIHJvb3RTdHlsZVsnLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yJ10gPSAndHJhbnNwYXJlbnQnO1xuICAgICAgICAgICAgcm9vdFN0eWxlWyctd2Via2l0LXVzZXItc2VsZWN0J10gPVxuICAgICAgICAgICAgcm9vdFN0eWxlWyd1c2VyLXNlbGVjdCddID1cbiAgICAgICAgICAgIHJvb3RTdHlsZVsnLXdlYmtpdC10b3VjaC1jYWxsb3V0J10gPSAnbm9uZSc7XG5cbiAgICAgICAgICAgIHJvb3QuaW5uZXJIVE1MID0gJyc7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL1N0b3JhZ2V9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0b3JhZ2UgPSBzdG9yYWdlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgemxldmVsTGlzdCA9IHRoaXMuX3psZXZlbExpc3QgPSBbXTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLCBtb2R1bGU6enJlbmRlci9MYXllcj59XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgbGF5ZXJzID0gdGhpcy5fbGF5ZXJzID0ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywgT2JqZWN0Pn1cbiAgICAgICAgICogQHR5cGUge3ByaXZhdGV9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9sYXllckNvbmZpZyA9IHt9O1xuXG4gICAgICAgIGlmICghc2luZ2xlQ2FudmFzKSB7XG4gICAgICAgICAgICB0aGlzLl93aWR0aCA9IHRoaXMuX2dldFNpemUoMCk7XG4gICAgICAgICAgICB0aGlzLl9oZWlnaHQgPSB0aGlzLl9nZXRTaXplKDEpO1xuXG4gICAgICAgICAgICB2YXIgZG9tUm9vdCA9IHRoaXMuX2RvbVJvb3QgPSBjcmVhdGVSb290KFxuICAgICAgICAgICAgICAgIHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByb290LmFwcGVuZENoaWxkKGRvbVJvb3QpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKG9wdHMud2lkdGggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJvb3Qud2lkdGggPSBvcHRzLndpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdHMuaGVpZ2h0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByb290LmhlaWdodCA9IG9wdHMuaGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVXNlIGNhbnZhcyB3aWR0aCBhbmQgaGVpZ2h0IGRpcmVjdGx5XG4gICAgICAgICAgICB2YXIgd2lkdGggPSByb290LndpZHRoO1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IHJvb3QuaGVpZ2h0O1xuICAgICAgICAgICAgdGhpcy5fd2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgIHRoaXMuX2hlaWdodCA9IGhlaWdodDtcblxuICAgICAgICAgICAgLy8gQ3JlYXRlIGxheWVyIGlmIG9ubHkgb25lIGdpdmVuIGNhbnZhc1xuICAgICAgICAgICAgLy8gRGV2aWNlIHBpeGVsIHJhdGlvIGlzIGZpeGVkIHRvIDEgYmVjYXVzZSBnaXZlbiBjYW52YXMgaGFzIGl0cyBzcGVjaWZpZWQgd2lkdGggYW5kIGhlaWdodFxuICAgICAgICAgICAgdmFyIG1haW5MYXllciA9IG5ldyBMYXllcihyb290LCB0aGlzLCAxKTtcbiAgICAgICAgICAgIG1haW5MYXllci5pbml0Q29udGV4dCgpO1xuICAgICAgICAgICAgLy8gRklYTUUgVXNlIGNhbnZhcyB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgICAgICAgICAvLyBtYWluTGF5ZXIucmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgbGF5ZXJzWzBdID0gbWFpbkxheWVyO1xuICAgICAgICAgICAgemxldmVsTGlzdC5wdXNoKDApO1xuXG4gICAgICAgICAgICB0aGlzLl9kb21Sb290ID0gcm9vdDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIExheWVycyBmb3IgcHJvZ3Jlc3NpdmUgcmVuZGVyaW5nXG4gICAgICAgIHRoaXMuX3Byb2dyZXNzaXZlTGF5ZXJzID0gW107XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9MYXllcn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2hvdmVybGF5ZXI7XG5cbiAgICAgICAgdGhpcy5faG92ZXJFbGVtZW50cyA9IFtdO1xuICAgIH07XG5cbiAgICBQYWludGVyLnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogUGFpbnRlcixcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgcGFpbnRlciB1c2UgYSBzaW5nbGUgY2FudmFzXG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBpc1NpbmdsZUNhbnZhczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NpbmdsZUNhbnZhcztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge0hUTUxEaXZFbGVtZW50fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0Vmlld3BvcnRSb290OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZG9tUm9vdDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5Yi35pawXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3BhaW50QWxsPWZhbHNlXSDlvLrliLbnu5jliLbmiYDmnIlkaXNwbGF5YWJsZVxuICAgICAgICAgKi9cbiAgICAgICAgcmVmcmVzaDogZnVuY3Rpb24gKHBhaW50QWxsKSB7XG5cbiAgICAgICAgICAgIHZhciBsaXN0ID0gdGhpcy5zdG9yYWdlLmdldERpc3BsYXlMaXN0KHRydWUpO1xuXG4gICAgICAgICAgICB2YXIgemxldmVsTGlzdCA9IHRoaXMuX3psZXZlbExpc3Q7XG5cbiAgICAgICAgICAgIHRoaXMuX3BhaW50TGlzdChsaXN0LCBwYWludEFsbCk7XG5cbiAgICAgICAgICAgIC8vIFBhaW50IGN1c3R1bSBsYXllcnNcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgemxldmVsTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciB6ID0gemxldmVsTGlzdFtpXTtcbiAgICAgICAgICAgICAgICB2YXIgbGF5ZXIgPSB0aGlzLl9sYXllcnNbel07XG4gICAgICAgICAgICAgICAgaWYgKCFsYXllci5fX2J1aWx0aW5fXyAmJiBsYXllci5yZWZyZXNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGxheWVyLnJlZnJlc2goKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMucmVmcmVzaEhvdmVyKCk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9wcm9ncmVzc2l2ZUxheWVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFydFByb2dlc3NpdmUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWRkSG92ZXI6IGZ1bmN0aW9uIChlbCwgaG92ZXJTdHlsZSkge1xuICAgICAgICAgICAgaWYgKGVsLl9faG92ZXJNaXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZWxNaXJyb3IgPSBuZXcgZWwuY29uc3RydWN0b3Ioe1xuICAgICAgICAgICAgICAgIHN0eWxlOiBlbC5zdHlsZSxcbiAgICAgICAgICAgICAgICBzaGFwZTogZWwuc2hhcGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZWxNaXJyb3IuX19mcm9tID0gZWw7XG4gICAgICAgICAgICBlbC5fX2hvdmVyTWlyID0gZWxNaXJyb3I7XG4gICAgICAgICAgICBlbE1pcnJvci5zZXRTdHlsZShob3ZlclN0eWxlKTtcbiAgICAgICAgICAgIHRoaXMuX2hvdmVyRWxlbWVudHMucHVzaChlbE1pcnJvcik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVtb3ZlSG92ZXI6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgdmFyIGVsTWlycm9yID0gZWwuX19ob3Zlck1pcjtcbiAgICAgICAgICAgIHZhciBob3ZlckVsZW1lbnRzID0gdGhpcy5faG92ZXJFbGVtZW50cztcbiAgICAgICAgICAgIHZhciBpZHggPSB1dGlsLmluZGV4T2YoaG92ZXJFbGVtZW50cywgZWxNaXJyb3IpO1xuICAgICAgICAgICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgaG92ZXJFbGVtZW50cy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsLl9faG92ZXJNaXIgPSBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNsZWFySG92ZXI6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgdmFyIGhvdmVyRWxlbWVudHMgPSB0aGlzLl9ob3ZlckVsZW1lbnRzO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBob3ZlckVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZyb20gPSBob3ZlckVsZW1lbnRzW2ldLl9fZnJvbTtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbSkge1xuICAgICAgICAgICAgICAgICAgICBmcm9tLl9faG92ZXJNaXIgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhvdmVyRWxlbWVudHMubGVuZ3RoID0gMDtcbiAgICAgICAgfSxcblxuICAgICAgICByZWZyZXNoSG92ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBob3ZlckVsZW1lbnRzID0gdGhpcy5faG92ZXJFbGVtZW50cztcbiAgICAgICAgICAgIHZhciBsZW4gPSBob3ZlckVsZW1lbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBob3ZlckxheWVyID0gdGhpcy5faG92ZXJsYXllcjtcbiAgICAgICAgICAgIGhvdmVyTGF5ZXIgJiYgaG92ZXJMYXllci5jbGVhcigpO1xuXG4gICAgICAgICAgICBpZiAoIWxlbikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRpbXNvcnQoaG92ZXJFbGVtZW50cywgdGhpcy5zdG9yYWdlLmRpc3BsYXlhYmxlU29ydEZ1bmMpO1xuXG4gICAgICAgICAgICAvLyBVc2UgYSBleHRyZWFtIGxhcmdlIHpsZXZlbFxuICAgICAgICAgICAgLy8gRklYTUU/XG4gICAgICAgICAgICBpZiAoIWhvdmVyTGF5ZXIpIHtcbiAgICAgICAgICAgICAgICBob3ZlckxheWVyID0gdGhpcy5faG92ZXJsYXllciA9IHRoaXMuZ2V0TGF5ZXIoMWU1KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHNjb3BlID0ge307XG4gICAgICAgICAgICBob3ZlckxheWVyLmN0eC5zYXZlKCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjspIHtcbiAgICAgICAgICAgICAgICB2YXIgZWwgPSBob3ZlckVsZW1lbnRzW2ldO1xuICAgICAgICAgICAgICAgIHZhciBvcmlnaW5hbEVsID0gZWwuX19mcm9tO1xuICAgICAgICAgICAgICAgIC8vIE9yaWdpbmFsIGVsIGlzIHJlbW92ZWRcbiAgICAgICAgICAgICAgICAvLyBQRU5ESU5HXG4gICAgICAgICAgICAgICAgaWYgKCEob3JpZ2luYWxFbCAmJiBvcmlnaW5hbEVsLl9fenIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGhvdmVyRWxlbWVudHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEVsLl9faG92ZXJNaXIgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBsZW4tLTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGkrKztcblxuICAgICAgICAgICAgICAgIC8vIFVzZSB0cmFuc2Zvcm1cbiAgICAgICAgICAgICAgICAvLyBGSVhNRSBzdHlsZSBhbmQgc2hhcGUgP1xuICAgICAgICAgICAgICAgIGlmICghb3JpZ2luYWxFbC5pbnZpc2libGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZWwudHJhbnNmb3JtID0gb3JpZ2luYWxFbC50cmFuc2Zvcm07XG4gICAgICAgICAgICAgICAgICAgIGVsLmludlRyYW5zZm9ybSA9IG9yaWdpbmFsRWwuaW52VHJhbnNmb3JtO1xuICAgICAgICAgICAgICAgICAgICBlbC5fX2NsaXBQYXRocyA9IG9yaWdpbmFsRWwuX19jbGlwUGF0aHM7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVsLlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kb1BhaW50RWwoZWwsIGhvdmVyTGF5ZXIsIHRydWUsIHNjb3BlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBob3ZlckxheWVyLmN0eC5yZXN0b3JlKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3N0YXJ0UHJvZ2Vzc2l2ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgICAgICBpZiAoIXNlbGYuX2Z1cnRoZXJQcm9ncmVzc2l2ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVXNlIGEgdG9rZW4gdG8gc3RvcCBwcm9ncmVzcyBzdGVwcyB0cmlnZ2VyZWQgYnlcbiAgICAgICAgICAgIC8vIHByZXZpb3VzIHpyLnJlZnJlc2ggY2FsbGluZy5cbiAgICAgICAgICAgIHZhciB0b2tlbiA9IHNlbGYuX3Byb2dyZXNzaXZlVG9rZW4gPSArbmV3IERhdGUoKTtcblxuICAgICAgICAgICAgc2VsZi5fcHJvZ3Jlc3MrKztcbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShzdGVwKTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gc3RlcCgpIHtcbiAgICAgICAgICAgICAgICAvLyBJbiBjYXNlIHJlZnJlc2hlZCBvciBkaXNwb3NlZFxuICAgICAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gc2VsZi5fcHJvZ3Jlc3NpdmVUb2tlbiAmJiBzZWxmLnN0b3JhZ2UpIHtcblxuICAgICAgICAgICAgICAgICAgICBzZWxmLl9kb1BhaW50TGlzdChzZWxmLnN0b3JhZ2UuZ2V0RGlzcGxheUxpc3QoKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuX2Z1cnRoZXJQcm9ncmVzc2l2ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fcHJvZ3Jlc3MrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShzdGVwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX3Byb2dyZXNzaXZlVG9rZW4gPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfY2xlYXJQcm9ncmVzc2l2ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fcHJvZ3Jlc3NpdmVUb2tlbiA9IC0xO1xuICAgICAgICAgICAgdGhpcy5fcHJvZ3Jlc3MgPSAwO1xuICAgICAgICAgICAgdXRpbC5lYWNoKHRoaXMuX3Byb2dyZXNzaXZlTGF5ZXJzLCBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgICAgICAgICAgICBsYXllci5fX2RpcnR5ICYmIGxheWVyLmNsZWFyKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBfcGFpbnRMaXN0OiBmdW5jdGlvbiAobGlzdCwgcGFpbnRBbGwpIHtcblxuICAgICAgICAgICAgaWYgKHBhaW50QWxsID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwYWludEFsbCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl91cGRhdGVMYXllclN0YXR1cyhsaXN0KTtcblxuICAgICAgICAgICAgdGhpcy5fY2xlYXJQcm9ncmVzc2l2ZSgpO1xuXG4gICAgICAgICAgICB0aGlzLmVhY2hCdWlsdGluTGF5ZXIocHJlUHJvY2Vzc0xheWVyKTtcblxuICAgICAgICAgICAgdGhpcy5fZG9QYWludExpc3QobGlzdCwgcGFpbnRBbGwpO1xuXG4gICAgICAgICAgICB0aGlzLmVhY2hCdWlsdGluTGF5ZXIocG9zdFByb2Nlc3NMYXllcik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2RvUGFpbnRMaXN0OiBmdW5jdGlvbiAobGlzdCwgcGFpbnRBbGwpIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50TGF5ZXI7XG4gICAgICAgICAgICB2YXIgY3VycmVudFpMZXZlbDtcbiAgICAgICAgICAgIHZhciBjdHg7XG5cbiAgICAgICAgICAgIC8vIHZhciBpbnZUcmFuc2Zvcm0gPSBbXTtcbiAgICAgICAgICAgIHZhciBzY29wZTtcblxuICAgICAgICAgICAgdmFyIHByb2dyZXNzaXZlTGF5ZXJJZHggPSAwO1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyO1xuXG4gICAgICAgICAgICB2YXIgd2lkdGggPSB0aGlzLl93aWR0aDtcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLl9oZWlnaHQ7XG4gICAgICAgICAgICB2YXIgbGF5ZXJQcm9ncmVzcztcbiAgICAgICAgICAgIHZhciBmcmFtZSA9IHRoaXMuX3Byb2dyZXNzO1xuICAgICAgICAgICAgZnVuY3Rpb24gZmx1c2hQcm9ncmVzc2l2ZUxheWVyKGxheWVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRwciA9IGN0eC5kcHIgfHwgMTtcbiAgICAgICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDE7XG4gICAgICAgICAgICAgICAgY3R4LnNoYWRvd0JsdXIgPSAwO1xuICAgICAgICAgICAgICAgIC8vIEF2b2lkIGxheWVyIGRvbid0IGNsZWFyIGluIG5leHQgcHJvZ3Jlc3NpdmUgZnJhbWVcbiAgICAgICAgICAgICAgICBjdXJyZW50TGF5ZXIuX19kaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICAgICAgY3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICAgICAgICAgICAgICBjdHguZHJhd0ltYWdlKGxheWVyLmRvbSwgMCwgMCwgd2lkdGggKiBkcHIsIGhlaWdodCAqIGRwcik7XG4gICAgICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBlbCA9IGxpc3RbaV07XG4gICAgICAgICAgICAgICAgdmFyIGVsWkxldmVsID0gdGhpcy5fc2luZ2xlQ2FudmFzID8gMCA6IGVsLnpsZXZlbDtcblxuICAgICAgICAgICAgICAgIHZhciBlbEZyYW1lID0gZWwuX19mcmFtZTtcblxuICAgICAgICAgICAgICAgIC8vIEZsdXNoIGF0IGN1cnJlbnQgY29udGV4dFxuICAgICAgICAgICAgICAgIC8vIFBFTkRJTkdcbiAgICAgICAgICAgICAgICBpZiAoZWxGcmFtZSA8IDAgJiYgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZmx1c2hQcm9ncmVzc2l2ZUxheWVyKGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIENoYW5nZSBkcmF3IGxheWVyXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRaTGV2ZWwgIT09IGVsWkxldmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBSZXNldCBzY29wZVxuICAgICAgICAgICAgICAgICAgICBzY29wZSA9IHt9O1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgMCB6bGV2ZWwgaWYgb25seSBoYXMgb25lIGNhbnZhc1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50WkxldmVsID0gZWxaTGV2ZWw7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRMYXllciA9IHRoaXMuZ2V0TGF5ZXIoY3VycmVudFpMZXZlbCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjdXJyZW50TGF5ZXIuX19idWlsdGluX18pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnWkxldmVsICcgKyBjdXJyZW50WkxldmVsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKyAnIGhhcyBiZWVuIHVzZWQgYnkgdW5rb3duIGxheWVyICcgKyBjdXJyZW50TGF5ZXIuaWRcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjdHggPSBjdXJyZW50TGF5ZXIuY3R4O1xuICAgICAgICAgICAgICAgICAgICBjdHguc2F2ZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlc2V0IHRoZSBjb3VudFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50TGF5ZXIuX191bnVzZWRDb3VudCA9IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRMYXllci5fX2RpcnR5IHx8IHBhaW50QWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50TGF5ZXIuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghKGN1cnJlbnRMYXllci5fX2RpcnR5IHx8IHBhaW50QWxsKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoZWxGcmFtZSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFByb2dyZXNzaXZlIGxheWVyIGNoYW5nZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjdXJyZW50UHJvZ3Jlc3NpdmVMYXllcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIgPSB0aGlzLl9wcm9ncmVzc2l2ZUxheWVyc1tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLm1pbihwcm9ncmVzc2l2ZUxheWVySWR4KyssIE1BWF9QUk9HUkVTU0lWRV9MQVlFUl9OVU1CRVIgLSAxKVxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuY3R4LnNhdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLnJlbmRlclNjb3BlID0ge307XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50UHJvZ3Jlc3NpdmVMYXllclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIChjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX3Byb2dyZXNzID4gY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuX19tYXhQcm9ncmVzcylcbiAgICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZsdXNoUHJvZ3Jlc3NpdmVMYXllcihjdXJyZW50UHJvZ3Jlc3NpdmVMYXllcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUXVpY2sganVtcCBhbGwgcHJvZ3Jlc3NpdmUgZWxlbWVudHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBbGwgcHJvZ3Jlc3NpdmUgZWxlbWVudCBhcmUgbm90IGRpcnR5LCBqdW1wIG92ZXIgYW5kIGZsdXNoIGRpcmVjdGx5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSA9IGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fbmV4dElkeE5vdFByb2cgLSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXJQcm9ncmVzcyA9IGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fcHJvZ3Jlc3M7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuX19kaXJ0eSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEtlZXAgcmVuZGVyaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWUgPSBsYXllclByb2dyZXNzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX3Byb2dyZXNzID0gZnJhbWUgKyAxO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsRnJhbWUgPT09IGZyYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kb1BhaW50RWwoZWwsIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLCB0cnVlLCBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5yZW5kZXJTY29wZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RvUGFpbnRFbChlbCwgY3VycmVudExheWVyLCBwYWludEFsbCwgc2NvcGUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGVsLl9fZGlydHkgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyKSB7XG4gICAgICAgICAgICAgICAgZmx1c2hQcm9ncmVzc2l2ZUxheWVyKGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUmVzdG9yZSB0aGUgbGFzdExheWVyIGN0eFxuICAgICAgICAgICAgY3R4ICYmIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgICAvLyBJZiBzdGlsbCBoYXMgY2xpcHBpbmcgc3RhdGVcbiAgICAgICAgICAgIC8vIGlmIChzY29wZS5wcmV2RWxDbGlwUGF0aHMpIHtcbiAgICAgICAgICAgIC8vICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgLy8gfVxuXG4gICAgICAgICAgICB0aGlzLl9mdXJ0aGVyUHJvZ3Jlc3NpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIHV0aWwuZWFjaCh0aGlzLl9wcm9ncmVzc2l2ZUxheWVycywgZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxheWVyLl9fbWF4UHJvZ3Jlc3MgPj0gbGF5ZXIuX19wcm9ncmVzcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9mdXJ0aGVyUHJvZ3Jlc3NpdmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9kb1BhaW50RWw6IGZ1bmN0aW9uIChlbCwgY3VycmVudExheWVyLCBmb3JjZVBhaW50LCBzY29wZSkge1xuICAgICAgICAgICAgdmFyIGN0eCA9IGN1cnJlbnRMYXllci5jdHg7XG4gICAgICAgICAgICB2YXIgbSA9IGVsLnRyYW5zZm9ybTtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAoY3VycmVudExheWVyLl9fZGlydHkgfHwgZm9yY2VQYWludClcbiAgICAgICAgICAgICAgICAvLyBJZ25vcmUgaW52aXNpYmxlIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAmJiAhZWwuaW52aXNpYmxlXG4gICAgICAgICAgICAgICAgLy8gSWdub3JlIHRyYW5zcGFyZW50IGVsZW1lbnRcbiAgICAgICAgICAgICAgICAmJiBlbC5zdHlsZS5vcGFjaXR5ICE9PSAwXG4gICAgICAgICAgICAgICAgLy8gSWdub3JlIHNjYWxlIDAgZWxlbWVudCwgaW4gc29tZSBlbnZpcm9ubWVudCBsaWtlIG5vZGUtY2FudmFzXG4gICAgICAgICAgICAgICAgLy8gRHJhdyBhIHNjYWxlIDAgZWxlbWVudCBjYW4gY2F1c2UgYWxsIGZvbGxvd2luZyBkcmF3IHdyb25nXG4gICAgICAgICAgICAgICAgLy8gQW5kIHNldFRyYW5zZm9ybSB3aXRoIHNjYWxlIDAgd2lsbCBjYXVzZSBzZXQgYmFjayB0cmFuc2Zvcm0gZmFpbGVkLlxuICAgICAgICAgICAgICAgICYmICEobSAmJiAhbVswXSAmJiAhbVszXSlcbiAgICAgICAgICAgICAgICAvLyBJZ25vcmUgY3VsbGVkIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAmJiAhKGVsLmN1bGxpbmcgJiYgaXNEaXNwbGF5YWJsZUN1bGxlZChlbCwgdGhpcy5fd2lkdGgsIHRoaXMuX2hlaWdodCkpXG4gICAgICAgICAgICApIHtcblxuICAgICAgICAgICAgICAgIHZhciBjbGlwUGF0aHMgPSBlbC5fX2NsaXBQYXRocztcblxuICAgICAgICAgICAgICAgIC8vIE9wdGltaXplIHdoZW4gY2xpcHBpbmcgb24gZ3JvdXAgd2l0aCBzZXZlcmFsIGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgaWYgKHNjb3BlLnByZXZDbGlwTGF5ZXIgIT09IGN1cnJlbnRMYXllclxuICAgICAgICAgICAgICAgICAgICB8fCBpc0NsaXBQYXRoQ2hhbmdlZChjbGlwUGF0aHMsIHNjb3BlLnByZXZFbENsaXBQYXRocylcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgaGFzIHByZXZpb3VzIGNsaXBwaW5nIHN0YXRlLCByZXN0b3JlIGZyb20gaXRcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjb3BlLnByZXZFbENsaXBQYXRocykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUucHJldkNsaXBMYXllci5jdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUucHJldkNsaXBMYXllciA9IHNjb3BlLnByZXZFbENsaXBQYXRocyA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlc2V0IHByZXZFbCBzaW5jZSBjb250ZXh0IGhhcyBiZWVuIHJlc3RvcmVkXG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZS5wcmV2RWwgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIE5ldyBjbGlwcGluZyBzdGF0ZVxuICAgICAgICAgICAgICAgICAgICBpZiAoY2xpcFBhdGhzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9DbGlwKGNsaXBQYXRocywgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlLnByZXZDbGlwTGF5ZXIgPSBjdXJyZW50TGF5ZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZS5wcmV2RWxDbGlwUGF0aHMgPSBjbGlwUGF0aHM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWwuYmVmb3JlQnJ1c2ggJiYgZWwuYmVmb3JlQnJ1c2goY3R4KTtcblxuICAgICAgICAgICAgICAgIGVsLmJydXNoKGN0eCwgc2NvcGUucHJldkVsIHx8IG51bGwpO1xuICAgICAgICAgICAgICAgIHNjb3BlLnByZXZFbCA9IGVsO1xuXG4gICAgICAgICAgICAgICAgZWwuYWZ0ZXJCcnVzaCAmJiBlbC5hZnRlckJydXNoKGN0eCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiOt+WPliB6bGV2ZWwg5omA5Zyo5bGC77yM5aaC5p6c5LiN5a2Y5Zyo5YiZ5Lya5Yib5bu65LiA5Liq5paw55qE5bGCXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB6bGV2ZWxcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvTGF5ZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRMYXllcjogZnVuY3Rpb24gKHpsZXZlbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3NpbmdsZUNhbnZhcykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9sYXllcnNbMF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBsYXllciA9IHRoaXMuX2xheWVyc1t6bGV2ZWxdO1xuICAgICAgICAgICAgaWYgKCFsYXllcikge1xuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhIG5ldyBsYXllclxuICAgICAgICAgICAgICAgIGxheWVyID0gbmV3IExheWVyKCd6cl8nICsgemxldmVsLCB0aGlzLCB0aGlzLmRwcik7XG4gICAgICAgICAgICAgICAgbGF5ZXIuX19idWlsdGluX18gPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2xheWVyQ29uZmlnW3psZXZlbF0pIHtcbiAgICAgICAgICAgICAgICAgICAgdXRpbC5tZXJnZShsYXllciwgdGhpcy5fbGF5ZXJDb25maWdbemxldmVsXSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5pbnNlcnRMYXllcih6bGV2ZWwsIGxheWVyKTtcblxuICAgICAgICAgICAgICAgIC8vIENvbnRleHQgaXMgY3JlYXRlZCBhZnRlciBkb20gaW5zZXJ0ZWQgdG8gZG9jdW1lbnRcbiAgICAgICAgICAgICAgICAvLyBPciBleGNhbnZhcyB3aWxsIGdldCAwcHggY2xpZW50V2lkdGggYW5kIGNsaWVudEhlaWdodFxuICAgICAgICAgICAgICAgIGxheWVyLmluaXRDb250ZXh0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBsYXllcjtcbiAgICAgICAgfSxcblxuICAgICAgICBpbnNlcnRMYXllcjogZnVuY3Rpb24gKHpsZXZlbCwgbGF5ZXIpIHtcblxuICAgICAgICAgICAgdmFyIGxheWVyc01hcCA9IHRoaXMuX2xheWVycztcbiAgICAgICAgICAgIHZhciB6bGV2ZWxMaXN0ID0gdGhpcy5femxldmVsTGlzdDtcbiAgICAgICAgICAgIHZhciBsZW4gPSB6bGV2ZWxMaXN0Lmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBwcmV2TGF5ZXIgPSBudWxsO1xuICAgICAgICAgICAgdmFyIGkgPSAtMTtcbiAgICAgICAgICAgIHZhciBkb21Sb290ID0gdGhpcy5fZG9tUm9vdDtcblxuICAgICAgICAgICAgaWYgKGxheWVyc01hcFt6bGV2ZWxdKSB7XG4gICAgICAgICAgICAgICAgbG9nKCdaTGV2ZWwgJyArIHpsZXZlbCArICcgaGFzIGJlZW4gdXNlZCBhbHJlYWR5Jyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgaXMgYSB2YWxpZCBsYXllclxuICAgICAgICAgICAgaWYgKCFpc0xheWVyVmFsaWQobGF5ZXIpKSB7XG4gICAgICAgICAgICAgICAgbG9nKCdMYXllciBvZiB6bGV2ZWwgJyArIHpsZXZlbCArICcgaXMgbm90IHZhbGlkJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobGVuID4gMCAmJiB6bGV2ZWwgPiB6bGV2ZWxMaXN0WzBdKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbiAtIDE7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICB6bGV2ZWxMaXN0W2ldIDwgemxldmVsXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiB6bGV2ZWxMaXN0W2kgKyAxXSA+IHpsZXZlbFxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByZXZMYXllciA9IGxheWVyc01hcFt6bGV2ZWxMaXN0W2ldXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHpsZXZlbExpc3Quc3BsaWNlKGkgKyAxLCAwLCB6bGV2ZWwpO1xuXG4gICAgICAgICAgICBsYXllcnNNYXBbemxldmVsXSA9IGxheWVyO1xuXG4gICAgICAgICAgICAvLyBWaXR1YWwgbGF5ZXIgd2lsbCBub3QgZGlyZWN0bHkgc2hvdyBvbiB0aGUgc2NyZWVuLlxuICAgICAgICAgICAgLy8gKEl0IGNhbiBiZSBhIFdlYkdMIGxheWVyIGFuZCBhc3NpZ25lZCB0byBhIFpJbWFnZSBlbGVtZW50KVxuICAgICAgICAgICAgLy8gQnV0IGl0IHN0aWxsIHVuZGVyIG1hbmFnZW1lbnQgb2YgenJlbmRlci5cbiAgICAgICAgICAgIGlmICghbGF5ZXIudmlydHVhbCkge1xuICAgICAgICAgICAgICAgIGlmIChwcmV2TGF5ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByZXZEb20gPSBwcmV2TGF5ZXIuZG9tO1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJldkRvbS5uZXh0U2libGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9tUm9vdC5pbnNlcnRCZWZvcmUoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXIuZG9tLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZEb20ubmV4dFNpYmxpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb21Sb290LmFwcGVuZENoaWxkKGxheWVyLmRvbSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkb21Sb290LmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbVJvb3QuaW5zZXJ0QmVmb3JlKGxheWVyLmRvbSwgZG9tUm9vdC5maXJzdENoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbVJvb3QuYXBwZW5kQ2hpbGQobGF5ZXIuZG9tKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBJdGVyYXRlIGVhY2ggbGF5ZXJcbiAgICAgICAgZWFjaExheWVyOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciB6bGV2ZWxMaXN0ID0gdGhpcy5femxldmVsTGlzdDtcbiAgICAgICAgICAgIHZhciB6O1xuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgemxldmVsTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHogPSB6bGV2ZWxMaXN0W2ldO1xuICAgICAgICAgICAgICAgIGNiLmNhbGwoY29udGV4dCwgdGhpcy5fbGF5ZXJzW3pdLCB6KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBJdGVyYXRlIGVhY2ggYnVpbGRpbiBsYXllclxuICAgICAgICBlYWNoQnVpbHRpbkxheWVyOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciB6bGV2ZWxMaXN0ID0gdGhpcy5femxldmVsTGlzdDtcbiAgICAgICAgICAgIHZhciBsYXllcjtcbiAgICAgICAgICAgIHZhciB6O1xuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgemxldmVsTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHogPSB6bGV2ZWxMaXN0W2ldO1xuICAgICAgICAgICAgICAgIGxheWVyID0gdGhpcy5fbGF5ZXJzW3pdO1xuICAgICAgICAgICAgICAgIGlmIChsYXllci5fX2J1aWx0aW5fXykge1xuICAgICAgICAgICAgICAgICAgICBjYi5jYWxsKGNvbnRleHQsIGxheWVyLCB6KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gSXRlcmF0ZSBlYWNoIG90aGVyIGxheWVyIGV4Y2VwdCBidWlsZGluIGxheWVyXG4gICAgICAgIGVhY2hPdGhlckxheWVyOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciB6bGV2ZWxMaXN0ID0gdGhpcy5femxldmVsTGlzdDtcbiAgICAgICAgICAgIHZhciBsYXllcjtcbiAgICAgICAgICAgIHZhciB6O1xuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgemxldmVsTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHogPSB6bGV2ZWxMaXN0W2ldO1xuICAgICAgICAgICAgICAgIGxheWVyID0gdGhpcy5fbGF5ZXJzW3pdO1xuICAgICAgICAgICAgICAgIGlmICghbGF5ZXIuX19idWlsdGluX18pIHtcbiAgICAgICAgICAgICAgICAgICAgY2IuY2FsbChjb250ZXh0LCBsYXllciwgeik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDojrflj5bmiYDmnInlt7LliJvlu7rnmoTlsYJcbiAgICAgICAgICogQHBhcmFtIHtBcnJheS48bW9kdWxlOnpyZW5kZXIvTGF5ZXI+fSBbcHJldkxheWVyXVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0TGF5ZXJzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbGF5ZXJzO1xuICAgICAgICB9LFxuXG4gICAgICAgIF91cGRhdGVMYXllclN0YXR1czogZnVuY3Rpb24gKGxpc3QpIHtcblxuICAgICAgICAgICAgdmFyIGxheWVycyA9IHRoaXMuX2xheWVycztcbiAgICAgICAgICAgIHZhciBwcm9ncmVzc2l2ZUxheWVycyA9IHRoaXMuX3Byb2dyZXNzaXZlTGF5ZXJzO1xuXG4gICAgICAgICAgICB2YXIgZWxDb3VudHNMYXN0RnJhbWUgPSB7fTtcbiAgICAgICAgICAgIHZhciBwcm9ncmVzc2l2ZUVsQ291bnRzTGFzdEZyYW1lID0ge307XG5cbiAgICAgICAgICAgIHRoaXMuZWFjaEJ1aWx0aW5MYXllcihmdW5jdGlvbiAobGF5ZXIsIHopIHtcbiAgICAgICAgICAgICAgICBlbENvdW50c0xhc3RGcmFtZVt6XSA9IGxheWVyLmVsQ291bnQ7XG4gICAgICAgICAgICAgICAgbGF5ZXIuZWxDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgbGF5ZXIuX19kaXJ0eSA9IGZhbHNlO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHV0aWwuZWFjaChwcm9ncmVzc2l2ZUxheWVycywgZnVuY3Rpb24gKGxheWVyLCBpZHgpIHtcbiAgICAgICAgICAgICAgICBwcm9ncmVzc2l2ZUVsQ291bnRzTGFzdEZyYW1lW2lkeF0gPSBsYXllci5lbENvdW50O1xuICAgICAgICAgICAgICAgIGxheWVyLmVsQ291bnQgPSAwO1xuICAgICAgICAgICAgICAgIGxheWVyLl9fZGlydHkgPSBmYWxzZTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB2YXIgcHJvZ3Jlc3NpdmVMYXllckNvdW50ID0gMDtcbiAgICAgICAgICAgIHZhciBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllcjtcbiAgICAgICAgICAgIHZhciBsYXN0UHJvZ3Jlc3NpdmVLZXk7XG4gICAgICAgICAgICB2YXIgZnJhbWVDb3VudCA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsID0gbGlzdFtpXTtcbiAgICAgICAgICAgICAgICB2YXIgemxldmVsID0gdGhpcy5fc2luZ2xlQ2FudmFzID8gMCA6IGVsLnpsZXZlbDtcbiAgICAgICAgICAgICAgICB2YXIgbGF5ZXIgPSBsYXllcnNbemxldmVsXTtcbiAgICAgICAgICAgICAgICB2YXIgZWxQcm9ncmVzcyA9IGVsLnByb2dyZXNzaXZlO1xuICAgICAgICAgICAgICAgIGlmIChsYXllcikge1xuICAgICAgICAgICAgICAgICAgICBsYXllci5lbENvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgIGxheWVyLl9fZGlydHkgPSBsYXllci5fX2RpcnR5IHx8IGVsLl9fZGlydHk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8vLy8vLyBVcGRhdGUgcHJvZ3Jlc3NpdmVcbiAgICAgICAgICAgICAgICBpZiAoZWxQcm9ncmVzcyA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZpeCB3cm9uZyBwcm9ncmVzc2l2ZSBzZXF1ZW5jZSBwcm9ibGVtLlxuICAgICAgICAgICAgICAgICAgICBpZiAobGFzdFByb2dyZXNzaXZlS2V5ICE9PSBlbFByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0UHJvZ3Jlc3NpdmVLZXkgPSBlbFByb2dyZXNzO1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWVDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbEZyYW1lID0gZWwuX19mcmFtZSA9IGZyYW1lQ291bnQgLSAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaWR4ID0gTWF0aC5taW4ocHJvZ3Jlc3NpdmVMYXllckNvdW50LCBNQVhfUFJPR1JFU1NJVkVfTEFZRVJfTlVNQkVSIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllciA9IHByb2dyZXNzaXZlTGF5ZXJzW2lkeF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIgPSBwcm9ncmVzc2l2ZUxheWVyc1tpZHhdID0gbmV3IExheWVyKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAncHJvZ3Jlc3NpdmUnLCB0aGlzLCB0aGlzLmRwclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuaW5pdENvbnRleHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fbWF4UHJvZ3Jlc3MgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fZGlydHkgPSBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX2RpcnR5IHx8IGVsLl9fZGlydHk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLmVsQ291bnQrKztcblxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX21heFByb2dyZXNzID0gTWF0aC5tYXgoXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX21heFByb2dyZXNzLCBlbEZyYW1lXG4gICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fbWF4UHJvZ3Jlc3MgPj0gY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuX19wcm9ncmVzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2hvdWxkIGtlZXAgcmVuZGVyaW5nIHRoaXMgIGxheWVyIGJlY2F1c2UgcHJvZ3Jlc3NpdmUgcmVuZGVyaW5nIGlzIG5vdCBmaW5pc2hlZCB5ZXRcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheWVyLl9fZGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlbC5fX2ZyYW1lID0gLTE7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX25leHRJZHhOb3RQcm9nID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2dyZXNzaXZlTGF5ZXJDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY3VycmVudFByb2dyZXNzaXZlTGF5ZXIpIHtcbiAgICAgICAgICAgICAgICBwcm9ncmVzc2l2ZUxheWVyQ291bnQrKztcbiAgICAgICAgICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX25leHRJZHhOb3RQcm9nID0gaTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8g5bGC5Lit55qE5YWD57Sg5pWw6YeP5pyJ5Y+R55Sf5Y+Y5YyWXG4gICAgICAgICAgICB0aGlzLmVhY2hCdWlsdGluTGF5ZXIoZnVuY3Rpb24gKGxheWVyLCB6KSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsQ291bnRzTGFzdEZyYW1lW3pdICE9PSBsYXllci5lbENvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGxheWVyLl9fZGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBwcm9ncmVzc2l2ZUxheWVycy5sZW5ndGggPSBNYXRoLm1pbihwcm9ncmVzc2l2ZUxheWVyQ291bnQsIE1BWF9QUk9HUkVTU0lWRV9MQVlFUl9OVU1CRVIpO1xuICAgICAgICAgICAgdXRpbC5lYWNoKHByb2dyZXNzaXZlTGF5ZXJzLCBmdW5jdGlvbiAobGF5ZXIsIGlkeCkge1xuICAgICAgICAgICAgICAgIGlmIChwcm9ncmVzc2l2ZUVsQ291bnRzTGFzdEZyYW1lW2lkeF0gIT09IGxheWVyLmVsQ291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZWwuX19kaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChsYXllci5fX2RpcnR5KSB7XG4gICAgICAgICAgICAgICAgICAgIGxheWVyLl9fcHJvZ3Jlc3MgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmuIXpmaRob3ZlcuWxguWkluaJgOacieWGheWuuVxuICAgICAgICAgKi9cbiAgICAgICAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuZWFjaEJ1aWx0aW5MYXllcih0aGlzLl9jbGVhckxheWVyKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9jbGVhckxheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgICAgICAgIGxheWVyLmNsZWFyKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOS/ruaUueaMh+WumnpsZXZlbOeahOe7mOWItuWPguaVsFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gemxldmVsXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcg6YWN572u5a+56LGhXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY29uZmlnLmNsZWFyQ29sb3I9MF0g5q+P5qyh5riF56m655S75biD55qE6aKc6ImyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY29uZmlnLm1vdGlvbkJsdXI9ZmFsc2VdIOaYr+WQpuW8gOWQr+WKqOaAgeaooeezilxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2NvbmZpZy5sYXN0RnJhbWVBbHBoYT0wLjddXG4gICAgICAgICAqICAgICAgICAgICAgICAgICDlnKjlvIDlkK/liqjmgIHmqKHns4rnmoTml7blgJnkvb/nlKjvvIzkuI7kuIrkuIDluKfmt7flkIjnmoRhbHBoYeWAvO+8jOWAvOi2iuWkp+Wwvui/uei2iuaYjuaYvlxuICAgICAgICAgKi9cbiAgICAgICAgY29uZmlnTGF5ZXI6IGZ1bmN0aW9uICh6bGV2ZWwsIGNvbmZpZykge1xuICAgICAgICAgICAgaWYgKGNvbmZpZykge1xuICAgICAgICAgICAgICAgIHZhciBsYXllckNvbmZpZyA9IHRoaXMuX2xheWVyQ29uZmlnO1xuICAgICAgICAgICAgICAgIGlmICghbGF5ZXJDb25maWdbemxldmVsXSkge1xuICAgICAgICAgICAgICAgICAgICBsYXllckNvbmZpZ1t6bGV2ZWxdID0gY29uZmlnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdXRpbC5tZXJnZShsYXllckNvbmZpZ1t6bGV2ZWxdLCBjb25maWcsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBsYXllciA9IHRoaXMuX2xheWVyc1t6bGV2ZWxdO1xuXG4gICAgICAgICAgICAgICAgaWYgKGxheWVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHV0aWwubWVyZ2UobGF5ZXIsIGxheWVyQ29uZmlnW3psZXZlbF0sIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5Yig6Zmk5oyH5a6a5bGCXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB6bGV2ZWwg5bGC5omA5Zyo55qEemxldmVsXG4gICAgICAgICAqL1xuICAgICAgICBkZWxMYXllcjogZnVuY3Rpb24gKHpsZXZlbCkge1xuICAgICAgICAgICAgdmFyIGxheWVycyA9IHRoaXMuX2xheWVycztcbiAgICAgICAgICAgIHZhciB6bGV2ZWxMaXN0ID0gdGhpcy5femxldmVsTGlzdDtcbiAgICAgICAgICAgIHZhciBsYXllciA9IGxheWVyc1t6bGV2ZWxdO1xuICAgICAgICAgICAgaWYgKCFsYXllcikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxheWVyLmRvbS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGxheWVyLmRvbSk7XG4gICAgICAgICAgICBkZWxldGUgbGF5ZXJzW3psZXZlbF07XG5cbiAgICAgICAgICAgIHpsZXZlbExpc3Quc3BsaWNlKHV0aWwuaW5kZXhPZih6bGV2ZWxMaXN0LCB6bGV2ZWwpLCAxKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5Yy65Z+f5aSn5bCP5Y+Y5YyW5ZCO6YeN57uYXG4gICAgICAgICAqL1xuICAgICAgICByZXNpemU6IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgICAgICB2YXIgZG9tUm9vdCA9IHRoaXMuX2RvbVJvb3Q7XG4gICAgICAgICAgICAvLyBGSVhNRSBXaHkgP1xuICAgICAgICAgICAgZG9tUm9vdC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuXG4gICAgICAgICAgICAvLyBTYXZlIGlucHV0IHcvaFxuICAgICAgICAgICAgdmFyIG9wdHMgPSB0aGlzLl9vcHRzO1xuICAgICAgICAgICAgd2lkdGggIT0gbnVsbCAmJiAob3B0cy53aWR0aCA9IHdpZHRoKTtcbiAgICAgICAgICAgIGhlaWdodCAhPSBudWxsICYmIChvcHRzLmhlaWdodCA9IGhlaWdodCk7XG5cbiAgICAgICAgICAgIHdpZHRoID0gdGhpcy5fZ2V0U2l6ZSgwKTtcbiAgICAgICAgICAgIGhlaWdodCA9IHRoaXMuX2dldFNpemUoMSk7XG5cbiAgICAgICAgICAgIGRvbVJvb3Quc3R5bGUuZGlzcGxheSA9ICcnO1xuXG4gICAgICAgICAgICAvLyDkvJjljJbmsqHmnInlrp7pmYXmlLnlj5jnmoRyZXNpemVcbiAgICAgICAgICAgIGlmICh0aGlzLl93aWR0aCAhPSB3aWR0aCB8fCBoZWlnaHQgIT0gdGhpcy5faGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgZG9tUm9vdC5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcbiAgICAgICAgICAgICAgICBkb21Sb290LnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpZCBpbiB0aGlzLl9sYXllcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2xheWVycy5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2xheWVyc1tpZF0ucmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHV0aWwuZWFjaCh0aGlzLl9wcm9ncmVzc2l2ZUxheWVycywgZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxheWVyLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHRoaXMucmVmcmVzaCh0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fd2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgIHRoaXMuX2hlaWdodCA9IGhlaWdodDtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOa4hemZpOWNleeLrOeahOS4gOS4quWxglxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gemxldmVsXG4gICAgICAgICAqL1xuICAgICAgICBjbGVhckxheWVyOiBmdW5jdGlvbiAoemxldmVsKSB7XG4gICAgICAgICAgICB2YXIgbGF5ZXIgPSB0aGlzLl9sYXllcnNbemxldmVsXTtcbiAgICAgICAgICAgIGlmIChsYXllcikge1xuICAgICAgICAgICAgICAgIGxheWVyLmNsZWFyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOmHiuaUvlxuICAgICAgICAgKi9cbiAgICAgICAgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5yb290LmlubmVySFRNTCA9ICcnO1xuXG4gICAgICAgICAgICB0aGlzLnJvb3QgPVxuICAgICAgICAgICAgdGhpcy5zdG9yYWdlID1cblxuICAgICAgICAgICAgdGhpcy5fZG9tUm9vdCA9XG4gICAgICAgICAgICB0aGlzLl9sYXllcnMgPSBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgY2FudmFzIHdoaWNoIGhhcyBhbGwgdGhpbmcgcmVuZGVyZWRcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmJhY2tncm91bmRDb2xvcl1cbiAgICAgICAgICovXG4gICAgICAgIGdldFJlbmRlcmVkQ2FudmFzOiBmdW5jdGlvbiAob3B0cykge1xuICAgICAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgICAgICAgICBpZiAodGhpcy5fc2luZ2xlQ2FudmFzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xheWVyc1swXS5kb207XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBpbWFnZUxheWVyID0gbmV3IExheWVyKCdpbWFnZScsIHRoaXMsIG9wdHMucGl4ZWxSYXRpbyB8fCB0aGlzLmRwcik7XG4gICAgICAgICAgICBpbWFnZUxheWVyLmluaXRDb250ZXh0KCk7XG5cbiAgICAgICAgICAgIGltYWdlTGF5ZXIuY2xlYXJDb2xvciA9IG9wdHMuYmFja2dyb3VuZENvbG9yO1xuICAgICAgICAgICAgaW1hZ2VMYXllci5jbGVhcigpO1xuXG4gICAgICAgICAgICB2YXIgZGlzcGxheUxpc3QgPSB0aGlzLnN0b3JhZ2UuZ2V0RGlzcGxheUxpc3QodHJ1ZSk7XG5cbiAgICAgICAgICAgIHZhciBzY29wZSA9IHt9O1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXNwbGF5TGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBlbCA9IGRpc3BsYXlMaXN0W2ldO1xuICAgICAgICAgICAgICAgIHRoaXMuX2RvUGFpbnRFbChlbCwgaW1hZ2VMYXllciwgdHJ1ZSwgc2NvcGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gaW1hZ2VMYXllci5kb207XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDojrflj5bnu5jlm77ljLrln5/lrr3luqZcbiAgICAgICAgICovXG4gICAgICAgIGdldFdpZHRoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2lkdGg7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiOt+WPlue7mOWbvuWMuuWfn+mrmOW6plxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0SGVpZ2h0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faGVpZ2h0O1xuICAgICAgICB9LFxuXG4gICAgICAgIF9nZXRTaXplOiBmdW5jdGlvbiAod2hJZHgpIHtcbiAgICAgICAgICAgIHZhciBvcHRzID0gdGhpcy5fb3B0cztcbiAgICAgICAgICAgIHZhciB3aCA9IFsnd2lkdGgnLCAnaGVpZ2h0J11bd2hJZHhdO1xuICAgICAgICAgICAgdmFyIGN3aCA9IFsnY2xpZW50V2lkdGgnLCAnY2xpZW50SGVpZ2h0J11bd2hJZHhdO1xuICAgICAgICAgICAgdmFyIHBsdCA9IFsncGFkZGluZ0xlZnQnLCAncGFkZGluZ1RvcCddW3doSWR4XTtcbiAgICAgICAgICAgIHZhciBwcmIgPSBbJ3BhZGRpbmdSaWdodCcsICdwYWRkaW5nQm90dG9tJ11bd2hJZHhdO1xuXG4gICAgICAgICAgICBpZiAob3B0c1t3aF0gIT0gbnVsbCAmJiBvcHRzW3doXSAhPT0gJ2F1dG8nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQob3B0c1t3aF0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcm9vdCA9IHRoaXMucm9vdDtcbiAgICAgICAgICAgIHZhciBzdGwgPSBkb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKHJvb3QpO1xuXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIChyb290W2N3aF0gfHwgcGFyc2VJbnQxMChzdGxbd2hdKSB8fCBwYXJzZUludDEwKHJvb3Quc3R5bGVbd2hdKSlcbiAgICAgICAgICAgICAgICAtIChwYXJzZUludDEwKHN0bFtwbHRdKSB8fCAwKVxuICAgICAgICAgICAgICAgIC0gKHBhcnNlSW50MTAoc3RsW3ByYl0pIHx8IDApXG4gICAgICAgICAgICApIHwgMDtcbiAgICAgICAgfSxcblxuICAgICAgICBwYXRoVG9JbWFnZTogZnVuY3Rpb24gKHBhdGgsIGRwcikge1xuICAgICAgICAgICAgZHByID0gZHByIHx8IHRoaXMuZHByO1xuXG4gICAgICAgICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgICB2YXIgcmVjdCA9IHBhdGguZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgICAgICAgICB2YXIgc3R5bGUgPSBwYXRoLnN0eWxlO1xuICAgICAgICAgICAgdmFyIHNoYWRvd0JsdXJTaXplID0gc3R5bGUuc2hhZG93Qmx1cjtcbiAgICAgICAgICAgIHZhciBzaGFkb3dPZmZzZXRYID0gc3R5bGUuc2hhZG93T2Zmc2V0WDtcbiAgICAgICAgICAgIHZhciBzaGFkb3dPZmZzZXRZID0gc3R5bGUuc2hhZG93T2Zmc2V0WTtcbiAgICAgICAgICAgIHZhciBsaW5lV2lkdGggPSBzdHlsZS5oYXNTdHJva2UoKSA/IHN0eWxlLmxpbmVXaWR0aCA6IDA7XG5cbiAgICAgICAgICAgIHZhciBsZWZ0TWFyZ2luID0gTWF0aC5tYXgobGluZVdpZHRoIC8gMiwgLXNoYWRvd09mZnNldFggKyBzaGFkb3dCbHVyU2l6ZSk7XG4gICAgICAgICAgICB2YXIgcmlnaHRNYXJnaW4gPSBNYXRoLm1heChsaW5lV2lkdGggLyAyLCBzaGFkb3dPZmZzZXRYICsgc2hhZG93Qmx1clNpemUpO1xuICAgICAgICAgICAgdmFyIHRvcE1hcmdpbiA9IE1hdGgubWF4KGxpbmVXaWR0aCAvIDIsIC1zaGFkb3dPZmZzZXRZICsgc2hhZG93Qmx1clNpemUpO1xuICAgICAgICAgICAgdmFyIGJvdHRvbU1hcmdpbiA9IE1hdGgubWF4KGxpbmVXaWR0aCAvIDIsIHNoYWRvd09mZnNldFkgKyBzaGFkb3dCbHVyU2l6ZSk7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSByZWN0LndpZHRoICsgbGVmdE1hcmdpbiArIHJpZ2h0TWFyZ2luO1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IHJlY3QuaGVpZ2h0ICsgdG9wTWFyZ2luICsgYm90dG9tTWFyZ2luO1xuXG4gICAgICAgICAgICBjYW52YXMud2lkdGggPSB3aWR0aCAqIGRwcjtcbiAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQgKiBkcHI7XG5cbiAgICAgICAgICAgIGN0eC5zY2FsZShkcHIsIGRwcik7XG4gICAgICAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgY3R4LmRwciA9IGRwcjtcblxuICAgICAgICAgICAgdmFyIHBhdGhUcmFuc2Zvcm0gPSB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb246IHBhdGgucG9zaXRpb24sXG4gICAgICAgICAgICAgICAgcm90YXRpb246IHBhdGgucm90YXRpb24sXG4gICAgICAgICAgICAgICAgc2NhbGU6IHBhdGguc2NhbGVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBwYXRoLnBvc2l0aW9uID0gW2xlZnRNYXJnaW4gLSByZWN0LngsIHRvcE1hcmdpbiAtIHJlY3QueV07XG4gICAgICAgICAgICBwYXRoLnJvdGF0aW9uID0gMDtcbiAgICAgICAgICAgIHBhdGguc2NhbGUgPSBbMSwgMV07XG4gICAgICAgICAgICBwYXRoLnVwZGF0ZVRyYW5zZm9ybSgpO1xuICAgICAgICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgICAgICAgICBwYXRoLmJydXNoKGN0eCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBJbWFnZVNoYXBlID0gcmVxdWlyZSgnLi9ncmFwaGljL0ltYWdlJyk7XG4gICAgICAgICAgICB2YXIgaW1nU2hhcGUgPSBuZXcgSW1hZ2VTaGFwZSh7XG4gICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgICAgICAgeTogMCxcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2U6IGNhbnZhc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAocGF0aFRyYW5zZm9ybS5wb3NpdGlvbiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaW1nU2hhcGUucG9zaXRpb24gPSBwYXRoLnBvc2l0aW9uID0gcGF0aFRyYW5zZm9ybS5wb3NpdGlvbjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHBhdGhUcmFuc2Zvcm0ucm90YXRpb24gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGltZ1NoYXBlLnJvdGF0aW9uID0gcGF0aC5yb3RhdGlvbiA9IHBhdGhUcmFuc2Zvcm0ucm90YXRpb247XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwYXRoVHJhbnNmb3JtLnNjYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpbWdTaGFwZS5zY2FsZSA9IHBhdGguc2NhbGUgPSBwYXRoVHJhbnNmb3JtLnNjYWxlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gaW1nU2hhcGU7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBQYWludGVyO1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS95eC9+L3pyZW5kZXIvbGliL1BhaW50ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDEwNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 105 */
/* unknown exports provided */
/* all exports used */
/*!*****************************************!*\
  !*** /home/yx/~/zrender/lib/Storage.js ***!
  \*****************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Storage内容仓库模块\n * @module zrender/Storage\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n * @author errorrik (errorrik@gmail.com)\n * @author pissang (https://github.com/pissang/)\n */\n\n\n    var util = __webpack_require__(/*! ./core/util */ 0);\n    var env = __webpack_require__(/*! ./core/env */ 8);\n\n    var Group = __webpack_require__(/*! ./container/Group */ 33);\n\n    // Use timsort because in most case elements are partially sorted\n    // https://jsfiddle.net/pissang/jr4x7mdm/8/\n    var timsort = __webpack_require__(/*! ./core/timsort */ 43);\n\n    function shapeCompareFunc(a, b) {\n        if (a.zlevel === b.zlevel) {\n            if (a.z === b.z) {\n                // if (a.z2 === b.z2) {\n                //     // FIXME Slow has renderidx compare\n                //     // http://stackoverflow.com/questions/20883421/sorting-in-javascript-should-every-compare-function-have-a-return-0-statement\n                //     // https://github.com/v8/v8/blob/47cce544a31ed5577ffe2963f67acb4144ee0232/src/js/array.js#L1012\n                //     return a.__renderidx - b.__renderidx;\n                // }\n                return a.z2 - b.z2;\n            }\n            return a.z - b.z;\n        }\n        return a.zlevel - b.zlevel;\n    }\n    /**\n     * 内容仓库 (M)\n     * @alias module:zrender/Storage\n     * @constructor\n     */\n    var Storage = function () {\n        this._roots = [];\n\n        this._displayList = [];\n\n        this._displayListLen = 0;\n    };\n\n    Storage.prototype = {\n\n        constructor: Storage,\n\n        /**\n         * @param  {Function} cb\n         *\n         */\n        traverse: function (cb, context) {\n            for (var i = 0; i < this._roots.length; i++) {\n                this._roots[i].traverse(cb, context);\n            }\n        },\n\n        /**\n         * 返回所有图形的绘制队列\n         * @param {boolean} [update=false] 是否在返回前更新该数组\n         * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组, 在 update 为 true 的时候有效\n         *\n         * 详见{@link module:zrender/graphic/Displayable.prototype.updateDisplayList}\n         * @return {Array.<module:zrender/graphic/Displayable>}\n         */\n        getDisplayList: function (update, includeIgnore) {\n            includeIgnore = includeIgnore || false;\n            if (update) {\n                this.updateDisplayList(includeIgnore);\n            }\n            return this._displayList;\n        },\n\n        /**\n         * 更新图形的绘制队列。\n         * 每次绘制前都会调用，该方法会先深度优先遍历整个树，更新所有Group和Shape的变换并且把所有可见的Shape保存到数组中，\n         * 最后根据绘制的优先级（zlevel > z > 插入顺序）排序得到绘制队列\n         * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组\n         */\n        updateDisplayList: function (includeIgnore) {\n            this._displayListLen = 0;\n            var roots = this._roots;\n            var displayList = this._displayList;\n            for (var i = 0, len = roots.length; i < len; i++) {\n                this._updateAndAddDisplayable(roots[i], null, includeIgnore);\n            }\n            displayList.length = this._displayListLen;\n\n            // for (var i = 0, len = displayList.length; i < len; i++) {\n            //     displayList[i].__renderidx = i;\n            // }\n\n            // displayList.sort(shapeCompareFunc);\n            env.canvasSupported && timsort(displayList, shapeCompareFunc);\n        },\n\n        _updateAndAddDisplayable: function (el, clipPaths, includeIgnore) {\n\n            if (el.ignore && !includeIgnore) {\n                return;\n            }\n\n            el.beforeUpdate();\n\n            if (el.__dirty) {\n\n                el.update();\n\n            }\n\n            el.afterUpdate();\n\n            var userSetClipPath = el.clipPath;\n            if (userSetClipPath) {\n\n                // FIXME 效率影响\n                if (clipPaths) {\n                    clipPaths = clipPaths.slice();\n                }\n                else {\n                    clipPaths = [];\n                }\n\n                var currentClipPath = userSetClipPath;\n                var parentClipPath = el;\n                // Recursively add clip path\n                while (currentClipPath) {\n                    // clipPath 的变换是基于使用这个 clipPath 的元素\n                    currentClipPath.parent = parentClipPath;\n                    currentClipPath.updateTransform();\n\n                    clipPaths.push(currentClipPath);\n\n                    parentClipPath = currentClipPath;\n                    currentClipPath = currentClipPath.clipPath;\n                }\n            }\n\n            if (el.isGroup) {\n                var children = el._children;\n\n                for (var i = 0; i < children.length; i++) {\n                    var child = children[i];\n\n                    // Force to mark as dirty if group is dirty\n                    // FIXME __dirtyPath ?\n                    if (el.__dirty) {\n                        child.__dirty = true;\n                    }\n\n                    this._updateAndAddDisplayable(child, clipPaths, includeIgnore);\n                }\n\n                // Mark group clean here\n                el.__dirty = false;\n\n            }\n            else {\n                el.__clipPaths = clipPaths;\n\n                this._displayList[this._displayListLen++] = el;\n            }\n        },\n\n        /**\n         * 添加图形(Shape)或者组(Group)到根节点\n         * @param {module:zrender/Element} el\n         */\n        addRoot: function (el) {\n            if (el.__storage === this) {\n                return;\n            }\n\n            if (el instanceof Group) {\n                el.addChildrenToStorage(this);\n            }\n\n            this.addToStorage(el);\n            this._roots.push(el);\n        },\n\n        /**\n         * 删除指定的图形(Shape)或者组(Group)\n         * @param {string|Array.<string>} [el] 如果为空清空整个Storage\n         */\n        delRoot: function (el) {\n            if (el == null) {\n                // 不指定el清空\n                for (var i = 0; i < this._roots.length; i++) {\n                    var root = this._roots[i];\n                    if (root instanceof Group) {\n                        root.delChildrenFromStorage(this);\n                    }\n                }\n\n                this._roots = [];\n                this._displayList = [];\n                this._displayListLen = 0;\n\n                return;\n            }\n\n            if (el instanceof Array) {\n                for (var i = 0, l = el.length; i < l; i++) {\n                    this.delRoot(el[i]);\n                }\n                return;\n            }\n\n\n            var idx = util.indexOf(this._roots, el);\n            if (idx >= 0) {\n                this.delFromStorage(el);\n                this._roots.splice(idx, 1);\n                if (el instanceof Group) {\n                    el.delChildrenFromStorage(this);\n                }\n            }\n        },\n\n        addToStorage: function (el) {\n            el.__storage = this;\n            el.dirty(false);\n\n            return this;\n        },\n\n        delFromStorage: function (el) {\n            if (el) {\n                el.__storage = null;\n            }\n\n            return this;\n        },\n\n        /**\n         * 清空并且释放Storage\n         */\n        dispose: function () {\n            this._renderList =\n            this._roots = null;\n        },\n\n        displayableSortFunc: shapeCompareFunc\n    };\n\n    module.exports = Storage;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTA1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy9ob21lL3l4L34venJlbmRlci9saWIvU3RvcmFnZS5qcz81YmU0Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbi8qKlxuICogU3RvcmFnZeWGheWuueS7k+W6k+aooeWdl1xuICogQG1vZHVsZSB6cmVuZGVyL1N0b3JhZ2VcbiAqIEBhdXRob3IgS2VuZXIgKEBLZW5lci3mnpfls7AsIGtlbmVyLmxpbmZlbmdAZ21haWwuY29tKVxuICogQGF1dGhvciBlcnJvcnJpayAoZXJyb3JyaWtAZ21haWwuY29tKVxuICogQGF1dGhvciBwaXNzYW5nIChodHRwczovL2dpdGh1Yi5jb20vcGlzc2FuZy8pXG4gKi9cblxuXG4gICAgdmFyIHV0aWwgPSByZXF1aXJlKCcuL2NvcmUvdXRpbCcpO1xuICAgIHZhciBlbnYgPSByZXF1aXJlKCcuL2NvcmUvZW52Jyk7XG5cbiAgICB2YXIgR3JvdXAgPSByZXF1aXJlKCcuL2NvbnRhaW5lci9Hcm91cCcpO1xuXG4gICAgLy8gVXNlIHRpbXNvcnQgYmVjYXVzZSBpbiBtb3N0IGNhc2UgZWxlbWVudHMgYXJlIHBhcnRpYWxseSBzb3J0ZWRcbiAgICAvLyBodHRwczovL2pzZmlkZGxlLm5ldC9waXNzYW5nL2pyNHg3bWRtLzgvXG4gICAgdmFyIHRpbXNvcnQgPSByZXF1aXJlKCcuL2NvcmUvdGltc29ydCcpO1xuXG4gICAgZnVuY3Rpb24gc2hhcGVDb21wYXJlRnVuYyhhLCBiKSB7XG4gICAgICAgIGlmIChhLnpsZXZlbCA9PT0gYi56bGV2ZWwpIHtcbiAgICAgICAgICAgIGlmIChhLnogPT09IGIueikge1xuICAgICAgICAgICAgICAgIC8vIGlmIChhLnoyID09PSBiLnoyKSB7XG4gICAgICAgICAgICAgICAgLy8gICAgIC8vIEZJWE1FIFNsb3cgaGFzIHJlbmRlcmlkeCBjb21wYXJlXG4gICAgICAgICAgICAgICAgLy8gICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjA4ODM0MjEvc29ydGluZy1pbi1qYXZhc2NyaXB0LXNob3VsZC1ldmVyeS1jb21wYXJlLWZ1bmN0aW9uLWhhdmUtYS1yZXR1cm4tMC1zdGF0ZW1lbnRcbiAgICAgICAgICAgICAgICAvLyAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3Y4L3Y4L2Jsb2IvNDdjY2U1NDRhMzFlZDU1NzdmZmUyOTYzZjY3YWNiNDE0NGVlMDIzMi9zcmMvanMvYXJyYXkuanMjTDEwMTJcbiAgICAgICAgICAgICAgICAvLyAgICAgcmV0dXJuIGEuX19yZW5kZXJpZHggLSBiLl9fcmVuZGVyaWR4O1xuICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYS56MiAtIGIuejI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYS56IC0gYi56O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhLnpsZXZlbCAtIGIuemxldmVsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiDlhoXlrrnku5PlupMgKE0pXG4gICAgICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL1N0b3JhZ2VcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICB2YXIgU3RvcmFnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fcm9vdHMgPSBbXTtcblxuICAgICAgICB0aGlzLl9kaXNwbGF5TGlzdCA9IFtdO1xuXG4gICAgICAgIHRoaXMuX2Rpc3BsYXlMaXN0TGVuID0gMDtcbiAgICB9O1xuXG4gICAgU3RvcmFnZS5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IFN0b3JhZ2UsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYlxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgdHJhdmVyc2U6IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9yb290cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Jvb3RzW2ldLnRyYXZlcnNlKGNiLCBjb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog6L+U5Zue5omA5pyJ5Zu+5b2i55qE57uY5Yi26Zif5YiXXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VwZGF0ZT1mYWxzZV0g5piv5ZCm5Zyo6L+U5Zue5YmN5pu05paw6K+l5pWw57uEXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luY2x1ZGVJZ25vcmU9ZmFsc2VdIOaYr+WQpuWMheWQqyBpZ25vcmUg55qE5pWw57uELCDlnKggdXBkYXRlIOS4uiB0cnVlIOeahOaXtuWAmeacieaViFxuICAgICAgICAgKlxuICAgICAgICAgKiDor6bop4F7QGxpbmsgbW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZS5wcm90b3R5cGUudXBkYXRlRGlzcGxheUxpc3R9XG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5Ljxtb2R1bGU6enJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlPn1cbiAgICAgICAgICovXG4gICAgICAgIGdldERpc3BsYXlMaXN0OiBmdW5jdGlvbiAodXBkYXRlLCBpbmNsdWRlSWdub3JlKSB7XG4gICAgICAgICAgICBpbmNsdWRlSWdub3JlID0gaW5jbHVkZUlnbm9yZSB8fCBmYWxzZTtcbiAgICAgICAgICAgIGlmICh1cGRhdGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZURpc3BsYXlMaXN0KGluY2x1ZGVJZ25vcmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc3BsYXlMaXN0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmm7TmlrDlm77lvaLnmoTnu5jliLbpmJ/liJfjgIJcbiAgICAgICAgICog5q+P5qyh57uY5Yi25YmN6YO95Lya6LCD55So77yM6K+l5pa55rOV5Lya5YWI5rex5bqm5LyY5YWI6YGN5Y6G5pW05Liq5qCR77yM5pu05paw5omA5pyJR3JvdXDlkoxTaGFwZeeahOWPmOaNouW5tuS4lOaKiuaJgOacieWPr+ingeeahFNoYXBl5L+d5a2Y5Yiw5pWw57uE5Lit77yMXG4gICAgICAgICAqIOacgOWQjuagueaNrue7mOWItueahOS8mOWFiOe6p++8iHpsZXZlbCA+IHogPiDmj5LlhaXpobrluo/vvInmjpLluo/lvpfliLDnu5jliLbpmJ/liJdcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbaW5jbHVkZUlnbm9yZT1mYWxzZV0g5piv5ZCm5YyF5ZCrIGlnbm9yZSDnmoTmlbDnu4RcbiAgICAgICAgICovXG4gICAgICAgIHVwZGF0ZURpc3BsYXlMaXN0OiBmdW5jdGlvbiAoaW5jbHVkZUlnbm9yZSkge1xuICAgICAgICAgICAgdGhpcy5fZGlzcGxheUxpc3RMZW4gPSAwO1xuICAgICAgICAgICAgdmFyIHJvb3RzID0gdGhpcy5fcm9vdHM7XG4gICAgICAgICAgICB2YXIgZGlzcGxheUxpc3QgPSB0aGlzLl9kaXNwbGF5TGlzdDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSByb290cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUFuZEFkZERpc3BsYXlhYmxlKHJvb3RzW2ldLCBudWxsLCBpbmNsdWRlSWdub3JlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRpc3BsYXlMaXN0Lmxlbmd0aCA9IHRoaXMuX2Rpc3BsYXlMaXN0TGVuO1xuXG4gICAgICAgICAgICAvLyBmb3IgKHZhciBpID0gMCwgbGVuID0gZGlzcGxheUxpc3QubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIC8vICAgICBkaXNwbGF5TGlzdFtpXS5fX3JlbmRlcmlkeCA9IGk7XG4gICAgICAgICAgICAvLyB9XG5cbiAgICAgICAgICAgIC8vIGRpc3BsYXlMaXN0LnNvcnQoc2hhcGVDb21wYXJlRnVuYyk7XG4gICAgICAgICAgICBlbnYuY2FudmFzU3VwcG9ydGVkICYmIHRpbXNvcnQoZGlzcGxheUxpc3QsIHNoYXBlQ29tcGFyZUZ1bmMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF91cGRhdGVBbmRBZGREaXNwbGF5YWJsZTogZnVuY3Rpb24gKGVsLCBjbGlwUGF0aHMsIGluY2x1ZGVJZ25vcmUpIHtcblxuICAgICAgICAgICAgaWYgKGVsLmlnbm9yZSAmJiAhaW5jbHVkZUlnbm9yZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZWwuYmVmb3JlVXBkYXRlKCk7XG5cbiAgICAgICAgICAgIGlmIChlbC5fX2RpcnR5KSB7XG5cbiAgICAgICAgICAgICAgICBlbC51cGRhdGUoKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlbC5hZnRlclVwZGF0ZSgpO1xuXG4gICAgICAgICAgICB2YXIgdXNlclNldENsaXBQYXRoID0gZWwuY2xpcFBhdGg7XG4gICAgICAgICAgICBpZiAodXNlclNldENsaXBQYXRoKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBGSVhNRSDmlYjnjoflvbHlk41cbiAgICAgICAgICAgICAgICBpZiAoY2xpcFBhdGhzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsaXBQYXRocyA9IGNsaXBQYXRocy5zbGljZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2xpcFBhdGhzID0gW107XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRDbGlwUGF0aCA9IHVzZXJTZXRDbGlwUGF0aDtcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50Q2xpcFBhdGggPSBlbDtcbiAgICAgICAgICAgICAgICAvLyBSZWN1cnNpdmVseSBhZGQgY2xpcCBwYXRoXG4gICAgICAgICAgICAgICAgd2hpbGUgKGN1cnJlbnRDbGlwUGF0aCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBjbGlwUGF0aCDnmoTlj5jmjaLmmK/ln7rkuo7kvb/nlKjov5nkuKogY2xpcFBhdGgg55qE5YWD57SgXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDbGlwUGF0aC5wYXJlbnQgPSBwYXJlbnRDbGlwUGF0aDtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudENsaXBQYXRoLnVwZGF0ZVRyYW5zZm9ybSgpO1xuXG4gICAgICAgICAgICAgICAgICAgIGNsaXBQYXRocy5wdXNoKGN1cnJlbnRDbGlwUGF0aCk7XG5cbiAgICAgICAgICAgICAgICAgICAgcGFyZW50Q2xpcFBhdGggPSBjdXJyZW50Q2xpcFBhdGg7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDbGlwUGF0aCA9IGN1cnJlbnRDbGlwUGF0aC5jbGlwUGF0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChlbC5pc0dyb3VwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gZWwuX2NoaWxkcmVuO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBGb3JjZSB0byBtYXJrIGFzIGRpcnR5IGlmIGdyb3VwIGlzIGRpcnR5XG4gICAgICAgICAgICAgICAgICAgIC8vIEZJWE1FIF9fZGlydHlQYXRoID9cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsLl9fZGlydHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkLl9fZGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlQW5kQWRkRGlzcGxheWFibGUoY2hpbGQsIGNsaXBQYXRocywgaW5jbHVkZUlnbm9yZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gTWFyayBncm91cCBjbGVhbiBoZXJlXG4gICAgICAgICAgICAgICAgZWwuX19kaXJ0eSA9IGZhbHNlO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbC5fX2NsaXBQYXRocyA9IGNsaXBQYXRocztcblxuICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3BsYXlMaXN0W3RoaXMuX2Rpc3BsYXlMaXN0TGVuKytdID0gZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOa3u+WKoOWbvuW9oihTaGFwZSnmiJbogIXnu4QoR3JvdXAp5Yiw5qC56IqC54K5XG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gZWxcbiAgICAgICAgICovXG4gICAgICAgIGFkZFJvb3Q6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgaWYgKGVsLl9fc3RvcmFnZSA9PT0gdGhpcykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGVsIGluc3RhbmNlb2YgR3JvdXApIHtcbiAgICAgICAgICAgICAgICBlbC5hZGRDaGlsZHJlblRvU3RvcmFnZSh0aGlzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5hZGRUb1N0b3JhZ2UoZWwpO1xuICAgICAgICAgICAgdGhpcy5fcm9vdHMucHVzaChlbCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWIoOmZpOaMh+WumueahOWbvuW9oihTaGFwZSnmiJbogIXnu4QoR3JvdXApXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfEFycmF5LjxzdHJpbmc+fSBbZWxdIOWmguaenOS4uuepuua4heepuuaVtOS4qlN0b3JhZ2VcbiAgICAgICAgICovXG4gICAgICAgIGRlbFJvb3Q6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgaWYgKGVsID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyDkuI3mjIflrpplbOa4heepulxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fcm9vdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJvb3QgPSB0aGlzLl9yb290c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJvb3QgaW5zdGFuY2VvZiBHcm91cCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcm9vdC5kZWxDaGlsZHJlbkZyb21TdG9yYWdlKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5fcm9vdHMgPSBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9kaXNwbGF5TGlzdCA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3BsYXlMaXN0TGVuID0gMDtcblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGVsIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGVsLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlbFJvb3QoZWxbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgdmFyIGlkeCA9IHV0aWwuaW5kZXhPZih0aGlzLl9yb290cywgZWwpO1xuICAgICAgICAgICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWxGcm9tU3RvcmFnZShlbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcm9vdHMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgICAgICAgICAgaWYgKGVsIGluc3RhbmNlb2YgR3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgZWwuZGVsQ2hpbGRyZW5Gcm9tU3RvcmFnZSh0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWRkVG9TdG9yYWdlOiBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIGVsLl9fc3RvcmFnZSA9IHRoaXM7XG4gICAgICAgICAgICBlbC5kaXJ0eShmYWxzZSk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRlbEZyb21TdG9yYWdlOiBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIGlmIChlbCkge1xuICAgICAgICAgICAgICAgIGVsLl9fc3RvcmFnZSA9IG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmuIXnqbrlubbkuJTph4rmlL5TdG9yYWdlXG4gICAgICAgICAqL1xuICAgICAgICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJMaXN0ID1cbiAgICAgICAgICAgIHRoaXMuX3Jvb3RzID0gbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICBkaXNwbGF5YWJsZVNvcnRGdW5jOiBzaGFwZUNvbXBhcmVGdW5jXG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gU3RvcmFnZTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2hvbWUveXgvfi96cmVuZGVyL2xpYi9TdG9yYWdlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 106 */
/* unknown exports provided */
/* all exports used */
/*!*****************************************************!*\
  !*** /home/yx/~/zrender/lib/animation/Animation.js ***!
  \*****************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * 动画主类, 调度和管理所有动画控制器\n *\n * @module zrender/animation/Animation\n * @author pissang(https://github.com/pissang)\n */\n// TODO Additive animation\n// http://iosoteric.com/additive-animations-animatewithduration-in-ios-8/\n// https://developer.apple.com/videos/wwdc2014/#236\n\n\n    var util = __webpack_require__(/*! ../core/util */ 0);\n    var Dispatcher = __webpack_require__(/*! ../core/event */ 20).Dispatcher;\n\n    var requestAnimationFrame = __webpack_require__(/*! ./requestAnimationFrame */ 59);\n\n    var Animator = __webpack_require__(/*! ./Animator */ 58);\n    /**\n     * @typedef {Object} IZRenderStage\n     * @property {Function} update\n     */\n\n    /**\n     * @alias module:zrender/animation/Animation\n     * @constructor\n     * @param {Object} [options]\n     * @param {Function} [options.onframe]\n     * @param {IZRenderStage} [options.stage]\n     * @example\n     *     var animation = new Animation();\n     *     var obj = {\n     *         x: 100,\n     *         y: 100\n     *     };\n     *     animation.animate(node.position)\n     *         .when(1000, {\n     *             x: 500,\n     *             y: 500\n     *         })\n     *         .when(2000, {\n     *             x: 100,\n     *             y: 100\n     *         })\n     *         .start('spline');\n     */\n    var Animation = function (options) {\n\n        options = options || {};\n\n        this.stage = options.stage || {};\n\n        this.onframe = options.onframe || function() {};\n\n        // private properties\n        this._clips = [];\n\n        this._running = false;\n\n        this._time;\n\n        this._pausedTime;\n\n        this._pauseStart;\n\n        this._paused = false;\n\n        Dispatcher.call(this);\n    };\n\n    Animation.prototype = {\n\n        constructor: Animation,\n        /**\n         * 添加 clip\n         * @param {module:zrender/animation/Clip} clip\n         */\n        addClip: function (clip) {\n            this._clips.push(clip);\n        },\n        /**\n         * 添加 animator\n         * @param {module:zrender/animation/Animator} animator\n         */\n        addAnimator: function (animator) {\n            animator.animation = this;\n            var clips = animator.getClips();\n            for (var i = 0; i < clips.length; i++) {\n                this.addClip(clips[i]);\n            }\n        },\n        /**\n         * 删除动画片段\n         * @param {module:zrender/animation/Clip} clip\n         */\n        removeClip: function(clip) {\n            var idx = util.indexOf(this._clips, clip);\n            if (idx >= 0) {\n                this._clips.splice(idx, 1);\n            }\n        },\n\n        /**\n         * 删除动画片段\n         * @param {module:zrender/animation/Animator} animator\n         */\n        removeAnimator: function (animator) {\n            var clips = animator.getClips();\n            for (var i = 0; i < clips.length; i++) {\n                this.removeClip(clips[i]);\n            }\n            animator.animation = null;\n        },\n\n        _update: function() {\n\n            var time = new Date().getTime() - this._pausedTime;\n            var delta = time - this._time;\n            var clips = this._clips;\n            var len = clips.length;\n\n            var deferredEvents = [];\n            var deferredClips = [];\n            for (var i = 0; i < len; i++) {\n                var clip = clips[i];\n                var e = clip.step(time, delta);\n                // Throw out the events need to be called after\n                // stage.update, like destroy\n                if (e) {\n                    deferredEvents.push(e);\n                    deferredClips.push(clip);\n                }\n            }\n\n            // Remove the finished clip\n            for (var i = 0; i < len;) {\n                if (clips[i]._needsRemove) {\n                    clips[i] = clips[len - 1];\n                    clips.pop();\n                    len--;\n                }\n                else {\n                    i++;\n                }\n            }\n\n            len = deferredEvents.length;\n            for (var i = 0; i < len; i++) {\n                deferredClips[i].fire(deferredEvents[i]);\n            }\n\n            this._time = time;\n\n            this.onframe(delta);\n\n            this.trigger('frame', delta);\n\n            if (this.stage.update) {\n                this.stage.update();\n            }\n        },\n\n        _startLoop: function () {\n            var self = this;\n\n            this._running = true;\n\n            function step() {\n                if (self._running) {\n\n                    requestAnimationFrame(step);\n\n                    !self._paused && self._update();\n                }\n            }\n\n            requestAnimationFrame(step);\n        },\n\n        /**\n         * 开始运行动画\n         */\n        start: function () {\n\n            this._time = new Date().getTime();\n            this._pausedTime = 0;\n\n            this._startLoop();\n        },\n        /**\n         * 停止运行动画\n         */\n        stop: function () {\n            this._running = false;\n        },\n\n        /**\n         * Pause\n         */\n        pause: function () {\n            if (!this._paused) {\n                this._pauseStart = new Date().getTime();\n                this._paused = true;\n            }\n        },\n\n        /**\n         * Resume\n         */\n        resume: function () {\n            if (this._paused) {\n                this._pausedTime += (new Date().getTime()) - this._pauseStart;\n                this._paused = false;\n            }\n        },\n\n        /**\n         * 清除所有动画片段\n         */\n        clear: function () {\n            this._clips = [];\n        },\n        /**\n         * 对一个目标创建一个animator对象，可以指定目标中的属性使用动画\n         * @param  {Object} target\n         * @param  {Object} options\n         * @param  {boolean} [options.loop=false] 是否循环播放动画\n         * @param  {Function} [options.getter=null]\n         *         如果指定getter函数，会通过getter函数取属性值\n         * @param  {Function} [options.setter=null]\n         *         如果指定setter函数，会通过setter函数设置属性值\n         * @return {module:zrender/animation/Animation~Animator}\n         */\n        // TODO Gap\n        animate: function (target, options) {\n            options = options || {};\n\n            var animator = new Animator(\n                target,\n                options.loop,\n                options.getter,\n                options.setter\n            );\n\n            this.addAnimator(animator);\n\n            return animator;\n        }\n    };\n\n    util.mixin(Animation, Dispatcher);\n\n    module.exports = Animation;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTA2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy9ob21lL3l4L34venJlbmRlci9saWIvYW5pbWF0aW9uL0FuaW1hdGlvbi5qcz9mNDBmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbi8qKlxuICog5Yqo55S75Li757G7LCDosIPluqblkoznrqHnkIbmiYDmnInliqjnlLvmjqfliLblmahcbiAqXG4gKiBAbW9kdWxlIHpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdGlvblxuICogQGF1dGhvciBwaXNzYW5nKGh0dHBzOi8vZ2l0aHViLmNvbS9waXNzYW5nKVxuICovXG4vLyBUT0RPIEFkZGl0aXZlIGFuaW1hdGlvblxuLy8gaHR0cDovL2lvc290ZXJpYy5jb20vYWRkaXRpdmUtYW5pbWF0aW9ucy1hbmltYXRld2l0aGR1cmF0aW9uLWluLWlvcy04L1xuLy8gaHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL3ZpZGVvcy93d2RjMjAxNC8jMjM2XG5cblxuICAgIHZhciB1dGlsID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJyk7XG4gICAgdmFyIERpc3BhdGNoZXIgPSByZXF1aXJlKCcuLi9jb3JlL2V2ZW50JykuRGlzcGF0Y2hlcjtcblxuICAgIHZhciByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSByZXF1aXJlKCcuL3JlcXVlc3RBbmltYXRpb25GcmFtZScpO1xuXG4gICAgdmFyIEFuaW1hdG9yID0gcmVxdWlyZSgnLi9BbmltYXRvcicpO1xuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IElaUmVuZGVyU3RhZ2VcbiAgICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSB1cGRhdGVcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0aW9uXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLm9uZnJhbWVdXG4gICAgICogQHBhcmFtIHtJWlJlbmRlclN0YWdlfSBbb3B0aW9ucy5zdGFnZV1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgICB2YXIgYW5pbWF0aW9uID0gbmV3IEFuaW1hdGlvbigpO1xuICAgICAqICAgICB2YXIgb2JqID0ge1xuICAgICAqICAgICAgICAgeDogMTAwLFxuICAgICAqICAgICAgICAgeTogMTAwXG4gICAgICogICAgIH07XG4gICAgICogICAgIGFuaW1hdGlvbi5hbmltYXRlKG5vZGUucG9zaXRpb24pXG4gICAgICogICAgICAgICAud2hlbigxMDAwLCB7XG4gICAgICogICAgICAgICAgICAgeDogNTAwLFxuICAgICAqICAgICAgICAgICAgIHk6IDUwMFxuICAgICAqICAgICAgICAgfSlcbiAgICAgKiAgICAgICAgIC53aGVuKDIwMDAsIHtcbiAgICAgKiAgICAgICAgICAgICB4OiAxMDAsXG4gICAgICogICAgICAgICAgICAgeTogMTAwXG4gICAgICogICAgICAgICB9KVxuICAgICAqICAgICAgICAgLnN0YXJ0KCdzcGxpbmUnKTtcbiAgICAgKi9cbiAgICB2YXIgQW5pbWF0aW9uID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcblxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICB0aGlzLnN0YWdlID0gb3B0aW9ucy5zdGFnZSB8fCB7fTtcblxuICAgICAgICB0aGlzLm9uZnJhbWUgPSBvcHRpb25zLm9uZnJhbWUgfHwgZnVuY3Rpb24oKSB7fTtcblxuICAgICAgICAvLyBwcml2YXRlIHByb3BlcnRpZXNcbiAgICAgICAgdGhpcy5fY2xpcHMgPSBbXTtcblxuICAgICAgICB0aGlzLl9ydW5uaW5nID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5fdGltZTtcblxuICAgICAgICB0aGlzLl9wYXVzZWRUaW1lO1xuXG4gICAgICAgIHRoaXMuX3BhdXNlU3RhcnQ7XG5cbiAgICAgICAgdGhpcy5fcGF1c2VkID0gZmFsc2U7XG5cbiAgICAgICAgRGlzcGF0Y2hlci5jYWxsKHRoaXMpO1xuICAgIH07XG5cbiAgICBBbmltYXRpb24ucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBBbmltYXRpb24sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmt7vliqAgY2xpcFxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9DbGlwfSBjbGlwXG4gICAgICAgICAqL1xuICAgICAgICBhZGRDbGlwOiBmdW5jdGlvbiAoY2xpcCkge1xuICAgICAgICAgICAgdGhpcy5fY2xpcHMucHVzaChjbGlwKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOa3u+WKoCBhbmltYXRvclxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRvcn0gYW5pbWF0b3JcbiAgICAgICAgICovXG4gICAgICAgIGFkZEFuaW1hdG9yOiBmdW5jdGlvbiAoYW5pbWF0b3IpIHtcbiAgICAgICAgICAgIGFuaW1hdG9yLmFuaW1hdGlvbiA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgY2xpcHMgPSBhbmltYXRvci5nZXRDbGlwcygpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGlwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkQ2xpcChjbGlwc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDliKDpmaTliqjnlLvniYfmrrVcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQ2xpcH0gY2xpcFxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3ZlQ2xpcDogZnVuY3Rpb24oY2xpcCkge1xuICAgICAgICAgICAgdmFyIGlkeCA9IHV0aWwuaW5kZXhPZih0aGlzLl9jbGlwcywgY2xpcCk7XG4gICAgICAgICAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jbGlwcy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5Yig6Zmk5Yqo55S754mH5q61XG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdG9yfSBhbmltYXRvclxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3ZlQW5pbWF0b3I6IGZ1bmN0aW9uIChhbmltYXRvcikge1xuICAgICAgICAgICAgdmFyIGNsaXBzID0gYW5pbWF0b3IuZ2V0Q2xpcHMoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xpcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUNsaXAoY2xpcHNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYW5pbWF0b3IuYW5pbWF0aW9uID0gbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICBfdXBkYXRlOiBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgdmFyIHRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHRoaXMuX3BhdXNlZFRpbWU7XG4gICAgICAgICAgICB2YXIgZGVsdGEgPSB0aW1lIC0gdGhpcy5fdGltZTtcbiAgICAgICAgICAgIHZhciBjbGlwcyA9IHRoaXMuX2NsaXBzO1xuICAgICAgICAgICAgdmFyIGxlbiA9IGNsaXBzLmxlbmd0aDtcblxuICAgICAgICAgICAgdmFyIGRlZmVycmVkRXZlbnRzID0gW107XG4gICAgICAgICAgICB2YXIgZGVmZXJyZWRDbGlwcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBjbGlwID0gY2xpcHNbaV07XG4gICAgICAgICAgICAgICAgdmFyIGUgPSBjbGlwLnN0ZXAodGltZSwgZGVsdGEpO1xuICAgICAgICAgICAgICAgIC8vIFRocm93IG91dCB0aGUgZXZlbnRzIG5lZWQgdG8gYmUgY2FsbGVkIGFmdGVyXG4gICAgICAgICAgICAgICAgLy8gc3RhZ2UudXBkYXRlLCBsaWtlIGRlc3Ryb3lcbiAgICAgICAgICAgICAgICBpZiAoZSkge1xuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZEV2ZW50cy5wdXNoKGUpO1xuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZENsaXBzLnB1c2goY2xpcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSZW1vdmUgdGhlIGZpbmlzaGVkIGNsaXBcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOykge1xuICAgICAgICAgICAgICAgIGlmIChjbGlwc1tpXS5fbmVlZHNSZW1vdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xpcHNbaV0gPSBjbGlwc1tsZW4gLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgY2xpcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIGxlbi0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGVuID0gZGVmZXJyZWRFdmVudHMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGRlZmVycmVkQ2xpcHNbaV0uZmlyZShkZWZlcnJlZEV2ZW50c1tpXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX3RpbWUgPSB0aW1lO1xuXG4gICAgICAgICAgICB0aGlzLm9uZnJhbWUoZGVsdGEpO1xuXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2ZyYW1lJywgZGVsdGEpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5zdGFnZS51cGRhdGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YWdlLnVwZGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIF9zdGFydExvb3A6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICAgICAgdGhpcy5fcnVubmluZyA9IHRydWU7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHN0ZXAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuX3J1bm5pbmcpIHtcblxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc3RlcCk7XG5cbiAgICAgICAgICAgICAgICAgICAgIXNlbGYuX3BhdXNlZCAmJiBzZWxmLl91cGRhdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShzdGVwKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5byA5aeL6L+Q6KGM5Yqo55S7XG4gICAgICAgICAqL1xuICAgICAgICBzdGFydDogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICB0aGlzLl90aW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICB0aGlzLl9wYXVzZWRUaW1lID0gMDtcblxuICAgICAgICAgICAgdGhpcy5fc3RhcnRMb29wKCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlgZzmraLov5DooYzliqjnlLtcbiAgICAgICAgICovXG4gICAgICAgIHN0b3A6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX3J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUGF1c2VcbiAgICAgICAgICovXG4gICAgICAgIHBhdXNlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3BhdXNlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhdXNlU3RhcnQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXVzZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXN1bWVcbiAgICAgICAgICovXG4gICAgICAgIHJlc3VtZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3BhdXNlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhdXNlZFRpbWUgKz0gKG5ldyBEYXRlKCkuZ2V0VGltZSgpKSAtIHRoaXMuX3BhdXNlU3RhcnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGF1c2VkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOa4hemZpOaJgOacieWKqOeUu+eJh+autVxuICAgICAgICAgKi9cbiAgICAgICAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX2NsaXBzID0gW107XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlr7nkuIDkuKrnm67moIfliJvlu7rkuIDkuKphbmltYXRvcuWvueixoe+8jOWPr+S7peaMh+Wumuebruagh+S4reeahOWxnuaAp+S9v+eUqOWKqOeUu1xuICAgICAgICAgKiBAcGFyYW0gIHtPYmplY3R9IHRhcmdldFxuICAgICAgICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgICAgICogQHBhcmFtICB7Ym9vbGVhbn0gW29wdGlvbnMubG9vcD1mYWxzZV0g5piv5ZCm5b6q546v5pKt5pS+5Yqo55S7XG4gICAgICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBbb3B0aW9ucy5nZXR0ZXI9bnVsbF1cbiAgICAgICAgICogICAgICAgICDlpoLmnpzmjIflrppnZXR0ZXLlh73mlbDvvIzkvJrpgJrov4dnZXR0ZXLlh73mlbDlj5blsZ7mgKflgLxcbiAgICAgICAgICogQHBhcmFtICB7RnVuY3Rpb259IFtvcHRpb25zLnNldHRlcj1udWxsXVxuICAgICAgICAgKiAgICAgICAgIOWmguaenOaMh+WumnNldHRlcuWHveaVsO+8jOS8mumAmui/h3NldHRlcuWHveaVsOiuvue9ruWxnuaAp+WAvFxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0aW9ufkFuaW1hdG9yfVxuICAgICAgICAgKi9cbiAgICAgICAgLy8gVE9ETyBHYXBcbiAgICAgICAgYW5pbWF0ZTogZnVuY3Rpb24gKHRhcmdldCwgb3B0aW9ucykge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgICAgIHZhciBhbmltYXRvciA9IG5ldyBBbmltYXRvcihcbiAgICAgICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5sb29wLFxuICAgICAgICAgICAgICAgIG9wdGlvbnMuZ2V0dGVyLFxuICAgICAgICAgICAgICAgIG9wdGlvbnMuc2V0dGVyXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICB0aGlzLmFkZEFuaW1hdG9yKGFuaW1hdG9yKTtcblxuICAgICAgICAgICAgcmV0dXJuIGFuaW1hdG9yO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHV0aWwubWl4aW4oQW5pbWF0aW9uLCBEaXNwYXRjaGVyKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gQW5pbWF0aW9uO1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS95eC9+L3pyZW5kZXIvbGliL2FuaW1hdGlvbi9BbmltYXRpb24uanNcbi8vIG1vZHVsZSBpZCA9IDEwNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 107 */
/* unknown exports provided */
/* all exports used */
/*!************************************************!*\
  !*** /home/yx/~/zrender/lib/animation/Clip.js ***!
  \************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * 动画主控制器\n * @config target 动画对象，可以是数组，如果是数组的话会批量分发onframe等事件\n * @config life(1000) 动画时长\n * @config delay(0) 动画延迟时间\n * @config loop(true)\n * @config gap(0) 循环的间隔时间\n * @config onframe\n * @config easing(optional)\n * @config ondestroy(optional)\n * @config onrestart(optional)\n *\n * TODO pause\n */\n\n\n    var easingFuncs = __webpack_require__(/*! ./easing */ 108);\n\n    function Clip(options) {\n\n        this._target = options.target;\n\n        // 生命周期\n        this._life = options.life || 1000;\n        // 延时\n        this._delay = options.delay || 0;\n        // 开始时间\n        // this._startTime = new Date().getTime() + this._delay;// 单位毫秒\n        this._initialized = false;\n\n        // 是否循环\n        this.loop = options.loop == null ? false : options.loop;\n\n        this.gap = options.gap || 0;\n\n        this.easing = options.easing || 'Linear';\n\n        this.onframe = options.onframe;\n        this.ondestroy = options.ondestroy;\n        this.onrestart = options.onrestart;\n\n        this._pausedTime = 0;\n        this._paused = false;\n    }\n\n    Clip.prototype = {\n\n        constructor: Clip,\n\n        step: function (globalTime, deltaTime) {\n            // Set startTime on first step, or _startTime may has milleseconds different between clips\n            // PENDING\n            if (!this._initialized) {\n                this._startTime = globalTime + this._delay;\n                this._initialized = true;\n            }\n\n            if (this._paused) {\n                this._pausedTime += deltaTime;\n                return;\n            }\n\n            var percent = (globalTime - this._startTime - this._pausedTime) / this._life;\n\n            // 还没开始\n            if (percent < 0) {\n                return;\n            }\n\n            percent = Math.min(percent, 1);\n\n            var easing = this.easing;\n            var easingFunc = typeof easing == 'string' ? easingFuncs[easing] : easing;\n            var schedule = typeof easingFunc === 'function'\n                ? easingFunc(percent)\n                : percent;\n\n            this.fire('frame', schedule);\n\n            // 结束\n            if (percent == 1) {\n                if (this.loop) {\n                    this.restart (globalTime);\n                    // 重新开始周期\n                    // 抛出而不是直接调用事件直到 stage.update 后再统一调用这些事件\n                    return 'restart';\n                }\n\n                // 动画完成将这个控制器标识为待删除\n                // 在Animation.update中进行批量删除\n                this._needsRemove = true;\n                return 'destroy';\n            }\n\n            return null;\n        },\n\n        restart: function (globalTime) {\n            var remainder = (globalTime - this._startTime - this._pausedTime) % this._life;\n            this._startTime = globalTime - remainder + this.gap;\n            this._pausedTime = 0;\n\n            this._needsRemove = false;\n        },\n\n        fire: function (eventType, arg) {\n            eventType = 'on' + eventType;\n            if (this[eventType]) {\n                this[eventType](this._target, arg);\n            }\n        },\n\n        pause: function () {\n            this._paused = true;\n        },\n\n        resume: function () {\n            this._paused = false;\n        }\n    };\n\n    module.exports = Clip;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTA3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy9ob21lL3l4L34venJlbmRlci9saWIvYW5pbWF0aW9uL0NsaXAuanM/YjIxOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIOWKqOeUu+S4u+aOp+WItuWZqFxuICogQGNvbmZpZyB0YXJnZXQg5Yqo55S75a+56LGh77yM5Y+v5Lul5piv5pWw57uE77yM5aaC5p6c5piv5pWw57uE55qE6K+d5Lya5om56YeP5YiG5Y+Rb25mcmFtZeetieS6i+S7tlxuICogQGNvbmZpZyBsaWZlKDEwMDApIOWKqOeUu+aXtumVv1xuICogQGNvbmZpZyBkZWxheSgwKSDliqjnlLvlu7bov5/ml7bpl7RcbiAqIEBjb25maWcgbG9vcCh0cnVlKVxuICogQGNvbmZpZyBnYXAoMCkg5b6q546v55qE6Ze06ZqU5pe26Ze0XG4gKiBAY29uZmlnIG9uZnJhbWVcbiAqIEBjb25maWcgZWFzaW5nKG9wdGlvbmFsKVxuICogQGNvbmZpZyBvbmRlc3Ryb3kob3B0aW9uYWwpXG4gKiBAY29uZmlnIG9ucmVzdGFydChvcHRpb25hbClcbiAqXG4gKiBUT0RPIHBhdXNlXG4gKi9cblxuXG4gICAgdmFyIGVhc2luZ0Z1bmNzID0gcmVxdWlyZSgnLi9lYXNpbmcnKTtcblxuICAgIGZ1bmN0aW9uIENsaXAob3B0aW9ucykge1xuXG4gICAgICAgIHRoaXMuX3RhcmdldCA9IG9wdGlvbnMudGFyZ2V0O1xuXG4gICAgICAgIC8vIOeUn+WRveWRqOacn1xuICAgICAgICB0aGlzLl9saWZlID0gb3B0aW9ucy5saWZlIHx8IDEwMDA7XG4gICAgICAgIC8vIOW7tuaXtlxuICAgICAgICB0aGlzLl9kZWxheSA9IG9wdGlvbnMuZGVsYXkgfHwgMDtcbiAgICAgICAgLy8g5byA5aeL5pe26Ze0XG4gICAgICAgIC8vIHRoaXMuX3N0YXJ0VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpICsgdGhpcy5fZGVsYXk7Ly8g5Y2V5L2N5q+r56eSXG4gICAgICAgIHRoaXMuX2luaXRpYWxpemVkID0gZmFsc2U7XG5cbiAgICAgICAgLy8g5piv5ZCm5b6q546vXG4gICAgICAgIHRoaXMubG9vcCA9IG9wdGlvbnMubG9vcCA9PSBudWxsID8gZmFsc2UgOiBvcHRpb25zLmxvb3A7XG5cbiAgICAgICAgdGhpcy5nYXAgPSBvcHRpb25zLmdhcCB8fCAwO1xuXG4gICAgICAgIHRoaXMuZWFzaW5nID0gb3B0aW9ucy5lYXNpbmcgfHwgJ0xpbmVhcic7XG5cbiAgICAgICAgdGhpcy5vbmZyYW1lID0gb3B0aW9ucy5vbmZyYW1lO1xuICAgICAgICB0aGlzLm9uZGVzdHJveSA9IG9wdGlvbnMub25kZXN0cm95O1xuICAgICAgICB0aGlzLm9ucmVzdGFydCA9IG9wdGlvbnMub25yZXN0YXJ0O1xuXG4gICAgICAgIHRoaXMuX3BhdXNlZFRpbWUgPSAwO1xuICAgICAgICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBDbGlwLnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogQ2xpcCxcblxuICAgICAgICBzdGVwOiBmdW5jdGlvbiAoZ2xvYmFsVGltZSwgZGVsdGFUaW1lKSB7XG4gICAgICAgICAgICAvLyBTZXQgc3RhcnRUaW1lIG9uIGZpcnN0IHN0ZXAsIG9yIF9zdGFydFRpbWUgbWF5IGhhcyBtaWxsZXNlY29uZHMgZGlmZmVyZW50IGJldHdlZW4gY2xpcHNcbiAgICAgICAgICAgIC8vIFBFTkRJTkdcbiAgICAgICAgICAgIGlmICghdGhpcy5faW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFydFRpbWUgPSBnbG9iYWxUaW1lICsgdGhpcy5fZGVsYXk7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5fcGF1c2VkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGF1c2VkVGltZSArPSBkZWx0YVRpbWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcGVyY2VudCA9IChnbG9iYWxUaW1lIC0gdGhpcy5fc3RhcnRUaW1lIC0gdGhpcy5fcGF1c2VkVGltZSkgLyB0aGlzLl9saWZlO1xuXG4gICAgICAgICAgICAvLyDov5jmsqHlvIDlp4tcbiAgICAgICAgICAgIGlmIChwZXJjZW50IDwgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcGVyY2VudCA9IE1hdGgubWluKHBlcmNlbnQsIDEpO1xuXG4gICAgICAgICAgICB2YXIgZWFzaW5nID0gdGhpcy5lYXNpbmc7XG4gICAgICAgICAgICB2YXIgZWFzaW5nRnVuYyA9IHR5cGVvZiBlYXNpbmcgPT0gJ3N0cmluZycgPyBlYXNpbmdGdW5jc1tlYXNpbmddIDogZWFzaW5nO1xuICAgICAgICAgICAgdmFyIHNjaGVkdWxlID0gdHlwZW9mIGVhc2luZ0Z1bmMgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgICAgICA/IGVhc2luZ0Z1bmMocGVyY2VudClcbiAgICAgICAgICAgICAgICA6IHBlcmNlbnQ7XG5cbiAgICAgICAgICAgIHRoaXMuZmlyZSgnZnJhbWUnLCBzY2hlZHVsZSk7XG5cbiAgICAgICAgICAgIC8vIOe7k+adn1xuICAgICAgICAgICAgaWYgKHBlcmNlbnQgPT0gMSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxvb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXN0YXJ0IChnbG9iYWxUaW1lKTtcbiAgICAgICAgICAgICAgICAgICAgLy8g6YeN5paw5byA5aeL5ZGo5pyfXG4gICAgICAgICAgICAgICAgICAgIC8vIOaKm+WHuuiAjOS4jeaYr+ebtOaOpeiwg+eUqOS6i+S7tuebtOWIsCBzdGFnZS51cGRhdGUg5ZCO5YaN57uf5LiA6LCD55So6L+Z5Lqb5LqL5Lu2XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAncmVzdGFydCc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8g5Yqo55S75a6M5oiQ5bCG6L+Z5Liq5o6n5Yi25Zmo5qCH6K+G5Li65b6F5Yig6ZmkXG4gICAgICAgICAgICAgICAgLy8g5ZyoQW5pbWF0aW9uLnVwZGF0ZeS4rei/m+ihjOaJuemHj+WIoOmZpFxuICAgICAgICAgICAgICAgIHRoaXMuX25lZWRzUmVtb3ZlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2Rlc3Ryb3knO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICByZXN0YXJ0OiBmdW5jdGlvbiAoZ2xvYmFsVGltZSkge1xuICAgICAgICAgICAgdmFyIHJlbWFpbmRlciA9IChnbG9iYWxUaW1lIC0gdGhpcy5fc3RhcnRUaW1lIC0gdGhpcy5fcGF1c2VkVGltZSkgJSB0aGlzLl9saWZlO1xuICAgICAgICAgICAgdGhpcy5fc3RhcnRUaW1lID0gZ2xvYmFsVGltZSAtIHJlbWFpbmRlciArIHRoaXMuZ2FwO1xuICAgICAgICAgICAgdGhpcy5fcGF1c2VkVGltZSA9IDA7XG5cbiAgICAgICAgICAgIHRoaXMuX25lZWRzUmVtb3ZlID0gZmFsc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmlyZTogZnVuY3Rpb24gKGV2ZW50VHlwZSwgYXJnKSB7XG4gICAgICAgICAgICBldmVudFR5cGUgPSAnb24nICsgZXZlbnRUeXBlO1xuICAgICAgICAgICAgaWYgKHRoaXNbZXZlbnRUeXBlXSkge1xuICAgICAgICAgICAgICAgIHRoaXNbZXZlbnRUeXBlXSh0aGlzLl90YXJnZXQsIGFyZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgcGF1c2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX3BhdXNlZCA9IHRydWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVzdW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IENsaXA7XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9ob21lL3l4L34venJlbmRlci9saWIvYW5pbWF0aW9uL0NsaXAuanNcbi8vIG1vZHVsZSBpZCA9IDEwN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 108 */
/* unknown exports provided */
/* all exports used */
/*!**************************************************!*\
  !*** /home/yx/~/zrender/lib/animation/easing.js ***!
  \**************************************************/
/***/ (function(module, exports) {

eval("/**\n * 缓动代码来自 https://github.com/sole/tween.js/blob/master/src/Tween.js\n * @see http://sole.github.io/tween.js/examples/03_graphs.html\n * @exports zrender/animation/easing\n */\n\n    var easing = {\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        linear: function (k) {\n            return k;\n        },\n\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quadraticIn: function (k) {\n            return k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quadraticOut: function (k) {\n            return k * (2 - k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quadraticInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k;\n            }\n            return -0.5 * (--k * (k - 2) - 1);\n        },\n\n        // 三次方的缓动（t^3）\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        cubicIn: function (k) {\n            return k * k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        cubicOut: function (k) {\n            return --k * k * k + 1;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        cubicInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k * k;\n            }\n            return 0.5 * ((k -= 2) * k * k + 2);\n        },\n\n        // 四次方的缓动（t^4）\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quarticIn: function (k) {\n            return k * k * k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quarticOut: function (k) {\n            return 1 - (--k * k * k * k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quarticInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k * k * k;\n            }\n            return -0.5 * ((k -= 2) * k * k * k - 2);\n        },\n\n        // 五次方的缓动（t^5）\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quinticIn: function (k) {\n            return k * k * k * k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quinticOut: function (k) {\n            return --k * k * k * k * k + 1;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quinticInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k * k * k * k;\n            }\n            return 0.5 * ((k -= 2) * k * k * k * k + 2);\n        },\n\n        // 正弦曲线的缓动（sin(t)）\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        sinusoidalIn: function (k) {\n            return 1 - Math.cos(k * Math.PI / 2);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        sinusoidalOut: function (k) {\n            return Math.sin(k * Math.PI / 2);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        sinusoidalInOut: function (k) {\n            return 0.5 * (1 - Math.cos(Math.PI * k));\n        },\n\n        // 指数曲线的缓动（2^t）\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        exponentialIn: function (k) {\n            return k === 0 ? 0 : Math.pow(1024, k - 1);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        exponentialOut: function (k) {\n            return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        exponentialInOut: function (k) {\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if ((k *= 2) < 1) {\n                return 0.5 * Math.pow(1024, k - 1);\n            }\n            return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);\n        },\n\n        // 圆形曲线的缓动（sqrt(1-t^2)）\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        circularIn: function (k) {\n            return 1 - Math.sqrt(1 - k * k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        circularOut: function (k) {\n            return Math.sqrt(1 - (--k * k));\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        circularInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return -0.5 * (Math.sqrt(1 - k * k) - 1);\n            }\n            return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);\n        },\n\n        // 创建类似于弹簧在停止前来回振荡的动画\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        elasticIn: function (k) {\n            var s;\n            var a = 0.1;\n            var p = 0.4;\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if (!a || a < 1) {\n                a = 1; s = p / 4;\n            }\n            else {\n                s = p * Math.asin(1 / a) / (2 * Math.PI);\n            }\n            return -(a * Math.pow(2, 10 * (k -= 1)) *\n                        Math.sin((k - s) * (2 * Math.PI) / p));\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        elasticOut: function (k) {\n            var s;\n            var a = 0.1;\n            var p = 0.4;\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if (!a || a < 1) {\n                a = 1; s = p / 4;\n            }\n            else {\n                s = p * Math.asin(1 / a) / (2 * Math.PI);\n            }\n            return (a * Math.pow(2, -10 * k) *\n                    Math.sin((k - s) * (2 * Math.PI) / p) + 1);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        elasticInOut: function (k) {\n            var s;\n            var a = 0.1;\n            var p = 0.4;\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if (!a || a < 1) {\n                a = 1; s = p / 4;\n            }\n            else {\n                s = p * Math.asin(1 / a) / (2 * Math.PI);\n            }\n            if ((k *= 2) < 1) {\n                return -0.5 * (a * Math.pow(2, 10 * (k -= 1))\n                    * Math.sin((k - s) * (2 * Math.PI) / p));\n            }\n            return a * Math.pow(2, -10 * (k -= 1))\n                    * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;\n\n        },\n\n        // 在某一动画开始沿指示的路径进行动画处理前稍稍收回该动画的移动\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        backIn: function (k) {\n            var s = 1.70158;\n            return k * k * ((s + 1) * k - s);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        backOut: function (k) {\n            var s = 1.70158;\n            return --k * k * ((s + 1) * k + s) + 1;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        backInOut: function (k) {\n            var s = 1.70158 * 1.525;\n            if ((k *= 2) < 1) {\n                return 0.5 * (k * k * ((s + 1) * k - s));\n            }\n            return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);\n        },\n\n        // 创建弹跳效果\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        bounceIn: function (k) {\n            return 1 - easing.bounceOut(1 - k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        bounceOut: function (k) {\n            if (k < (1 / 2.75)) {\n                return 7.5625 * k * k;\n            }\n            else if (k < (2 / 2.75)) {\n                return 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;\n            }\n            else if (k < (2.5 / 2.75)) {\n                return 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;\n            }\n            else {\n                return 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;\n            }\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        bounceInOut: function (k) {\n            if (k < 0.5) {\n                return easing.bounceIn(k * 2) * 0.5;\n            }\n            return easing.bounceOut(k * 2 - 1) * 0.5 + 0.5;\n        }\n    };\n\n    module.exports = easing;\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTA4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy9ob21lL3l4L34venJlbmRlci9saWIvYW5pbWF0aW9uL2Vhc2luZy5qcz9hZGY1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICog57yT5Yqo5Luj56CB5p2l6IeqIGh0dHBzOi8vZ2l0aHViLmNvbS9zb2xlL3R3ZWVuLmpzL2Jsb2IvbWFzdGVyL3NyYy9Ud2Vlbi5qc1xuICogQHNlZSBodHRwOi8vc29sZS5naXRodWIuaW8vdHdlZW4uanMvZXhhbXBsZXMvMDNfZ3JhcGhzLmh0bWxcbiAqIEBleHBvcnRzIHpyZW5kZXIvYW5pbWF0aW9uL2Vhc2luZ1xuICovXG5cbiAgICB2YXIgZWFzaW5nID0ge1xuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgbGluZWFyOiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgcmV0dXJuIGs7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIHF1YWRyYXRpY0luOiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgcmV0dXJuIGsgKiBrO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgcXVhZHJhdGljT3V0OiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgcmV0dXJuIGsgKiAoMiAtIGspO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgcXVhZHJhdGljSW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICBpZiAoKGsgKj0gMikgPCAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDAuNSAqIGsgKiBrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIC0wLjUgKiAoLS1rICogKGsgLSAyKSAtIDEpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIOS4ieasoeaWueeahOe8k+WKqO+8iHReM++8iVxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgY3ViaWNJbjogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHJldHVybiBrICogayAqIGs7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBjdWJpY091dDogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHJldHVybiAtLWsgKiBrICogayArIDE7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBjdWJpY0luT3V0OiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgaWYgKChrICo9IDIpIDwgMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwLjUgKiBrICogayAqIGs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gMC41ICogKChrIC09IDIpICogayAqIGsgKyAyKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyDlm5vmrKHmlrnnmoTnvJPliqjvvIh0XjTvvIlcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIHF1YXJ0aWNJbjogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHJldHVybiBrICogayAqIGsgKiBrO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgcXVhcnRpY091dDogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHJldHVybiAxIC0gKC0tayAqIGsgKiBrICogayk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBxdWFydGljSW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICBpZiAoKGsgKj0gMikgPCAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDAuNSAqIGsgKiBrICogayAqIGs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gLTAuNSAqICgoayAtPSAyKSAqIGsgKiBrICogayAtIDIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIOS6lOasoeaWueeahOe8k+WKqO+8iHReNe+8iVxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgcXVpbnRpY0luOiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgcmV0dXJuIGsgKiBrICogayAqIGsgKiBrO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgcXVpbnRpY091dDogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHJldHVybiAtLWsgKiBrICogayAqIGsgKiBrICsgMTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIHF1aW50aWNJbk91dDogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIGlmICgoayAqPSAyKSA8IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMC41ICogayAqIGsgKiBrICogayAqIGs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gMC41ICogKChrIC09IDIpICogayAqIGsgKiBrICogayArIDIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIOato+W8puabsue6v+eahOe8k+WKqO+8iHNpbih0Ke+8iVxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgc2ludXNvaWRhbEluOiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgcmV0dXJuIDEgLSBNYXRoLmNvcyhrICogTWF0aC5QSSAvIDIpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgc2ludXNvaWRhbE91dDogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnNpbihrICogTWF0aC5QSSAvIDIpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgc2ludXNvaWRhbEluT3V0OiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgcmV0dXJuIDAuNSAqICgxIC0gTWF0aC5jb3MoTWF0aC5QSSAqIGspKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyDmjIfmlbDmm7Lnur/nmoTnvJPliqjvvIgyXnTvvIlcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIGV4cG9uZW50aWFsSW46IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICByZXR1cm4gayA9PT0gMCA/IDAgOiBNYXRoLnBvdygxMDI0LCBrIC0gMSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBleHBvbmVudGlhbE91dDogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHJldHVybiBrID09PSAxID8gMSA6IDEgLSBNYXRoLnBvdygyLCAtMTAgKiBrKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIGV4cG9uZW50aWFsSW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICBpZiAoayA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGsgPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoayAqPSAyKSA8IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMC41ICogTWF0aC5wb3coMTAyNCwgayAtIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDAuNSAqICgtTWF0aC5wb3coMiwgLTEwICogKGsgLSAxKSkgKyAyKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyDlnIblvaLmm7Lnur/nmoTnvJPliqjvvIhzcXJ0KDEtdF4yKe+8iVxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgY2lyY3VsYXJJbjogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHJldHVybiAxIC0gTWF0aC5zcXJ0KDEgLSBrICogayk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBjaXJjdWxhck91dDogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnNxcnQoMSAtICgtLWsgKiBrKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBjaXJjdWxhckluT3V0OiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgaWYgKChrICo9IDIpIDwgMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAtMC41ICogKE1hdGguc3FydCgxIC0gayAqIGspIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gMC41ICogKE1hdGguc3FydCgxIC0gKGsgLT0gMikgKiBrKSArIDEpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIOWIm+W7uuexu+S8vOS6juW8ueewp+WcqOWBnOatouWJjeadpeWbnuaMr+iNoeeahOWKqOeUu1xuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgZWxhc3RpY0luOiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgdmFyIHM7XG4gICAgICAgICAgICB2YXIgYSA9IDAuMTtcbiAgICAgICAgICAgIHZhciBwID0gMC40O1xuICAgICAgICAgICAgaWYgKGsgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWEgfHwgYSA8IDEpIHtcbiAgICAgICAgICAgICAgICBhID0gMTsgcyA9IHAgLyA0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcyA9IHAgKiBNYXRoLmFzaW4oMSAvIGEpIC8gKDIgKiBNYXRoLlBJKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAtKGEgKiBNYXRoLnBvdygyLCAxMCAqIChrIC09IDEpKSAqXG4gICAgICAgICAgICAgICAgICAgICAgICBNYXRoLnNpbigoayAtIHMpICogKDIgKiBNYXRoLlBJKSAvIHApKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIGVsYXN0aWNPdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICB2YXIgcztcbiAgICAgICAgICAgIHZhciBhID0gMC4xO1xuICAgICAgICAgICAgdmFyIHAgPSAwLjQ7XG4gICAgICAgICAgICBpZiAoayA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGsgPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghYSB8fCBhIDwgMSkge1xuICAgICAgICAgICAgICAgIGEgPSAxOyBzID0gcCAvIDQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzID0gcCAqIE1hdGguYXNpbigxIC8gYSkgLyAoMiAqIE1hdGguUEkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIChhICogTWF0aC5wb3coMiwgLTEwICogaykgKlxuICAgICAgICAgICAgICAgICAgICBNYXRoLnNpbigoayAtIHMpICogKDIgKiBNYXRoLlBJKSAvIHApICsgMSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBlbGFzdGljSW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICB2YXIgcztcbiAgICAgICAgICAgIHZhciBhID0gMC4xO1xuICAgICAgICAgICAgdmFyIHAgPSAwLjQ7XG4gICAgICAgICAgICBpZiAoayA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGsgPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghYSB8fCBhIDwgMSkge1xuICAgICAgICAgICAgICAgIGEgPSAxOyBzID0gcCAvIDQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzID0gcCAqIE1hdGguYXNpbigxIC8gYSkgLyAoMiAqIE1hdGguUEkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChrICo9IDIpIDwgMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAtMC41ICogKGEgKiBNYXRoLnBvdygyLCAxMCAqIChrIC09IDEpKVxuICAgICAgICAgICAgICAgICAgICAqIE1hdGguc2luKChrIC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGEgKiBNYXRoLnBvdygyLCAtMTAgKiAoayAtPSAxKSlcbiAgICAgICAgICAgICAgICAgICAgKiBNYXRoLnNpbigoayAtIHMpICogKDIgKiBNYXRoLlBJKSAvIHApICogMC41ICsgMTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIOWcqOafkOS4gOWKqOeUu+W8gOWni+ayv+aMh+ekuueahOi3r+W+hOi/m+ihjOWKqOeUu+WkhOeQhuWJjeeojeeojeaUtuWbnuivpeWKqOeUu+eahOenu+WKqFxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgYmFja0luOiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgdmFyIHMgPSAxLjcwMTU4O1xuICAgICAgICAgICAgcmV0dXJuIGsgKiBrICogKChzICsgMSkgKiBrIC0gcyk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBiYWNrT3V0OiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgdmFyIHMgPSAxLjcwMTU4O1xuICAgICAgICAgICAgcmV0dXJuIC0tayAqIGsgKiAoKHMgKyAxKSAqIGsgKyBzKSArIDE7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBiYWNrSW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICB2YXIgcyA9IDEuNzAxNTggKiAxLjUyNTtcbiAgICAgICAgICAgIGlmICgoayAqPSAyKSA8IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMC41ICogKGsgKiBrICogKChzICsgMSkgKiBrIC0gcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDAuNSAqICgoayAtPSAyKSAqIGsgKiAoKHMgKyAxKSAqIGsgKyBzKSArIDIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIOWIm+W7uuW8uei3s+aViOaenFxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgYm91bmNlSW46IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICByZXR1cm4gMSAtIGVhc2luZy5ib3VuY2VPdXQoMSAtIGspO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgYm91bmNlT3V0OiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgaWYgKGsgPCAoMSAvIDIuNzUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDcuNTYyNSAqIGsgKiBrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoayA8ICgyIC8gMi43NSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gNy41NjI1ICogKGsgLT0gKDEuNSAvIDIuNzUpKSAqIGsgKyAwLjc1O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoayA8ICgyLjUgLyAyLjc1KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiA3LjU2MjUgKiAoayAtPSAoMi4yNSAvIDIuNzUpKSAqIGsgKyAwLjkzNzU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gNy41NjI1ICogKGsgLT0gKDIuNjI1IC8gMi43NSkpICogayArIDAuOTg0Mzc1O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgYm91bmNlSW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICBpZiAoayA8IDAuNSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlYXNpbmcuYm91bmNlSW4oayAqIDIpICogMC41O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGVhc2luZy5ib3VuY2VPdXQoayAqIDIgLSAxKSAqIDAuNSArIDAuNTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGVhc2luZztcblxuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS95eC9+L3pyZW5kZXIvbGliL2FuaW1hdGlvbi9lYXNpbmcuanNcbi8vIG1vZHVsZSBpZCA9IDEwOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 109 */
/* unknown exports provided */
/* all exports used */
/*!*********************************************!*\
  !*** /home/yx/~/zrender/lib/contain/arc.js ***!
  \*********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var normalizeRadian = __webpack_require__(/*! ./util */ 60).normalizeRadian;\n    var PI2 = Math.PI * 2;\n\n    module.exports = {\n        /**\n         * 圆弧描边包含判断\n         * @param  {number}  cx\n         * @param  {number}  cy\n         * @param  {number}  r\n         * @param  {number}  startAngle\n         * @param  {number}  endAngle\n         * @param  {boolean}  anticlockwise\n         * @param  {number} lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {Boolean}\n         */\n        containStroke: function (\n            cx, cy, r, startAngle, endAngle, anticlockwise,\n            lineWidth, x, y\n        ) {\n\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n\n            x -= cx;\n            y -= cy;\n            var d = Math.sqrt(x * x + y * y);\n\n            if ((d - _l > r) || (d + _l < r)) {\n                return false;\n            }\n            if (Math.abs(startAngle - endAngle) % PI2 < 1e-4) {\n                // Is a circle\n                return true;\n            }\n            if (anticlockwise) {\n                var tmp = startAngle;\n                startAngle = normalizeRadian(endAngle);\n                endAngle = normalizeRadian(tmp);\n            } else {\n                startAngle = normalizeRadian(startAngle);\n                endAngle = normalizeRadian(endAngle);\n            }\n            if (startAngle > endAngle) {\n                endAngle += PI2;\n            }\n\n            var angle = Math.atan2(y, x);\n            if (angle < 0) {\n                angle += PI2;\n            }\n            return (angle >= startAngle && angle <= endAngle)\n                || (angle + PI2 >= startAngle && angle + PI2 <= endAngle);\n        }\n    };\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTA5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy9ob21lL3l4L34venJlbmRlci9saWIvY29udGFpbi9hcmMuanM/NGQ5NSJdLCJzb3VyY2VzQ29udGVudCI6WyJcblxuICAgIHZhciBub3JtYWxpemVSYWRpYW4gPSByZXF1aXJlKCcuL3V0aWwnKS5ub3JtYWxpemVSYWRpYW47XG4gICAgdmFyIFBJMiA9IE1hdGguUEkgKiAyO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlnIblvKfmj4/ovrnljIXlkKvliKTmlq1cbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgY3hcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgY3lcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgclxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICBzdGFydEFuZ2xlXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIGVuZEFuZ2xlXG4gICAgICAgICAqIEBwYXJhbSAge2Jvb2xlYW59ICBhbnRpY2xvY2t3aXNlXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gbGluZVdpZHRoXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHhcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeVxuICAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgY29udGFpblN0cm9rZTogZnVuY3Rpb24gKFxuICAgICAgICAgICAgY3gsIGN5LCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYW50aWNsb2Nrd2lzZSxcbiAgICAgICAgICAgIGxpbmVXaWR0aCwgeCwgeVxuICAgICAgICApIHtcblxuICAgICAgICAgICAgaWYgKGxpbmVXaWR0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBfbCA9IGxpbmVXaWR0aDtcblxuICAgICAgICAgICAgeCAtPSBjeDtcbiAgICAgICAgICAgIHkgLT0gY3k7XG4gICAgICAgICAgICB2YXIgZCA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcblxuICAgICAgICAgICAgaWYgKChkIC0gX2wgPiByKSB8fCAoZCArIF9sIDwgcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMoc3RhcnRBbmdsZSAtIGVuZEFuZ2xlKSAlIFBJMiA8IDFlLTQpIHtcbiAgICAgICAgICAgICAgICAvLyBJcyBhIGNpcmNsZVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFudGljbG9ja3dpc2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgdG1wID0gc3RhcnRBbmdsZTtcbiAgICAgICAgICAgICAgICBzdGFydEFuZ2xlID0gbm9ybWFsaXplUmFkaWFuKGVuZEFuZ2xlKTtcbiAgICAgICAgICAgICAgICBlbmRBbmdsZSA9IG5vcm1hbGl6ZVJhZGlhbih0bXApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGFydEFuZ2xlID0gbm9ybWFsaXplUmFkaWFuKHN0YXJ0QW5nbGUpO1xuICAgICAgICAgICAgICAgIGVuZEFuZ2xlID0gbm9ybWFsaXplUmFkaWFuKGVuZEFuZ2xlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGFydEFuZ2xlID4gZW5kQW5nbGUpIHtcbiAgICAgICAgICAgICAgICBlbmRBbmdsZSArPSBQSTI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBhbmdsZSA9IE1hdGguYXRhbjIoeSwgeCk7XG4gICAgICAgICAgICBpZiAoYW5nbGUgPCAwKSB7XG4gICAgICAgICAgICAgICAgYW5nbGUgKz0gUEkyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIChhbmdsZSA+PSBzdGFydEFuZ2xlICYmIGFuZ2xlIDw9IGVuZEFuZ2xlKVxuICAgICAgICAgICAgICAgIHx8IChhbmdsZSArIFBJMiA+PSBzdGFydEFuZ2xlICYmIGFuZ2xlICsgUEkyIDw9IGVuZEFuZ2xlKTtcbiAgICAgICAgfVxuICAgIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS95eC9+L3pyZW5kZXIvbGliL2NvbnRhaW4vYXJjLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 110 */
/* unknown exports provided */
/* all exports used */
/*!***********************************************!*\
  !*** /home/yx/~/zrender/lib/contain/cubic.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var curve = __webpack_require__(/*! ../core/curve */ 19);\n\n    module.exports = {\n        /**\n         * 三次贝塞尔曲线描边包含判断\n         * @param  {number}  x0\n         * @param  {number}  y0\n         * @param  {number}  x1\n         * @param  {number}  y1\n         * @param  {number}  x2\n         * @param  {number}  y2\n         * @param  {number}  x3\n         * @param  {number}  y3\n         * @param  {number}  lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {boolean}\n         */\n        containStroke: function(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n            // Quick reject\n            if (\n                (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l)\n                || (y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l)\n                || (x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l)\n                || (x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l)\n            ) {\n                return false;\n            }\n            var d = curve.cubicProjectPoint(\n                x0, y0, x1, y1, x2, y2, x3, y3,\n                x, y, null\n            );\n            return d <= _l / 2;\n        }\n    };\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTEwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy9ob21lL3l4L34venJlbmRlci9saWIvY29udGFpbi9jdWJpYy5qcz9mNmUzIl0sInNvdXJjZXNDb250ZW50IjpbIlxuXG4gICAgdmFyIGN1cnZlID0gcmVxdWlyZSgnLi4vY29yZS9jdXJ2ZScpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDkuInmrKHotJ3loZ7lsJTmm7Lnur/mj4/ovrnljIXlkKvliKTmlq1cbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeDBcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeTBcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeDFcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeTFcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeDJcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeTJcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeDNcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeTNcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgbGluZVdpZHRoXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHhcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeVxuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgY29udGFpblN0cm9rZTogZnVuY3Rpb24oeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCBsaW5lV2lkdGgsIHgsIHkpIHtcbiAgICAgICAgICAgIGlmIChsaW5lV2lkdGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgX2wgPSBsaW5lV2lkdGg7XG4gICAgICAgICAgICAvLyBRdWljayByZWplY3RcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAoeSA+IHkwICsgX2wgJiYgeSA+IHkxICsgX2wgJiYgeSA+IHkyICsgX2wgJiYgeSA+IHkzICsgX2wpXG4gICAgICAgICAgICAgICAgfHwgKHkgPCB5MCAtIF9sICYmIHkgPCB5MSAtIF9sICYmIHkgPCB5MiAtIF9sICYmIHkgPCB5MyAtIF9sKVxuICAgICAgICAgICAgICAgIHx8ICh4ID4geDAgKyBfbCAmJiB4ID4geDEgKyBfbCAmJiB4ID4geDIgKyBfbCAmJiB4ID4geDMgKyBfbClcbiAgICAgICAgICAgICAgICB8fCAoeCA8IHgwIC0gX2wgJiYgeCA8IHgxIC0gX2wgJiYgeCA8IHgyIC0gX2wgJiYgeCA8IHgzIC0gX2wpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZCA9IGN1cnZlLmN1YmljUHJvamVjdFBvaW50KFxuICAgICAgICAgICAgICAgIHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5MyxcbiAgICAgICAgICAgICAgICB4LCB5LCBudWxsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIGQgPD0gX2wgLyAyO1xuICAgICAgICB9XG4gICAgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9ob21lL3l4L34venJlbmRlci9saWIvY29udGFpbi9jdWJpYy5qc1xuLy8gbW9kdWxlIGlkID0gMTEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 111 */
/* unknown exports provided */
/* all exports used */
/*!**********************************************!*\
  !*** /home/yx/~/zrender/lib/contain/path.js ***!
  \**********************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\n    var CMD = __webpack_require__(/*! ../core/PathProxy */ 25).CMD;\n    var line = __webpack_require__(/*! ./line */ 90);\n    var cubic = __webpack_require__(/*! ./cubic */ 110);\n    var quadratic = __webpack_require__(/*! ./quadratic */ 91);\n    var arc = __webpack_require__(/*! ./arc */ 109);\n    var normalizeRadian = __webpack_require__(/*! ./util */ 60).normalizeRadian;\n    var curve = __webpack_require__(/*! ../core/curve */ 19);\n\n    var windingLine = __webpack_require__(/*! ./windingLine */ 92);\n\n    var containStroke = line.containStroke;\n\n    var PI2 = Math.PI * 2;\n\n    var EPSILON = 1e-4;\n\n    function isAroundEqual(a, b) {\n        return Math.abs(a - b) < EPSILON;\n    }\n\n    // 临时数组\n    var roots = [-1, -1, -1];\n    var extrema = [-1, -1];\n\n    function swapExtrema() {\n        var tmp = extrema[0];\n        extrema[0] = extrema[1];\n        extrema[1] = tmp;\n    }\n\n    function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {\n        // Quick reject\n        if (\n            (y > y0 && y > y1 && y > y2 && y > y3)\n            || (y < y0 && y < y1 && y < y2 && y < y3)\n        ) {\n            return 0;\n        }\n        var nRoots = curve.cubicRootAt(y0, y1, y2, y3, y, roots);\n        if (nRoots === 0) {\n            return 0;\n        }\n        else {\n            var w = 0;\n            var nExtrema = -1;\n            var y0_, y1_;\n            for (var i = 0; i < nRoots; i++) {\n                var t = roots[i];\n\n                // Avoid winding error when intersection point is the connect point of two line of polygon\n                var unit = (t === 0 || t === 1) ? 0.5 : 1;\n\n                var x_ = curve.cubicAt(x0, x1, x2, x3, t);\n                if (x_ < x) { // Quick reject\n                    continue;\n                }\n                if (nExtrema < 0) {\n                    nExtrema = curve.cubicExtrema(y0, y1, y2, y3, extrema);\n                    if (extrema[1] < extrema[0] && nExtrema > 1) {\n                        swapExtrema();\n                    }\n                    y0_ = curve.cubicAt(y0, y1, y2, y3, extrema[0]);\n                    if (nExtrema > 1) {\n                        y1_ = curve.cubicAt(y0, y1, y2, y3, extrema[1]);\n                    }\n                }\n                if (nExtrema == 2) {\n                    // 分成三段单调函数\n                    if (t < extrema[0]) {\n                        w += y0_ < y0 ? unit : -unit;\n                    }\n                    else if (t < extrema[1]) {\n                        w += y1_ < y0_ ? unit : -unit;\n                    }\n                    else {\n                        w += y3 < y1_ ? unit : -unit;\n                    }\n                }\n                else {\n                    // 分成两段单调函数\n                    if (t < extrema[0]) {\n                        w += y0_ < y0 ? unit : -unit;\n                    }\n                    else {\n                        w += y3 < y0_ ? unit : -unit;\n                    }\n                }\n            }\n            return w;\n        }\n    }\n\n    function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {\n        // Quick reject\n        if (\n            (y > y0 && y > y1 && y > y2)\n            || (y < y0 && y < y1 && y < y2)\n        ) {\n            return 0;\n        }\n        var nRoots = curve.quadraticRootAt(y0, y1, y2, y, roots);\n        if (nRoots === 0) {\n            return 0;\n        }\n        else {\n            var t = curve.quadraticExtremum(y0, y1, y2);\n            if (t >= 0 && t <= 1) {\n                var w = 0;\n                var y_ = curve.quadraticAt(y0, y1, y2, t);\n                for (var i = 0; i < nRoots; i++) {\n                    // Remove one endpoint.\n                    var unit = (roots[i] === 0 || roots[i] === 1) ? 0.5 : 1;\n\n                    var x_ = curve.quadraticAt(x0, x1, x2, roots[i]);\n                    if (x_ < x) {   // Quick reject\n                        continue;\n                    }\n                    if (roots[i] < t) {\n                        w += y_ < y0 ? unit : -unit;\n                    }\n                    else {\n                        w += y2 < y_ ? unit : -unit;\n                    }\n                }\n                return w;\n            }\n            else {\n                // Remove one endpoint.\n                var unit = (roots[0] === 0 || roots[0] === 1) ? 0.5 : 1;\n\n                var x_ = curve.quadraticAt(x0, x1, x2, roots[0]);\n                if (x_ < x) {   // Quick reject\n                    return 0;\n                }\n                return y2 < y0 ? unit : -unit;\n            }\n        }\n    }\n\n    // TODO\n    // Arc 旋转\n    function windingArc(\n        cx, cy, r, startAngle, endAngle, anticlockwise, x, y\n    ) {\n        y -= cy;\n        if (y > r || y < -r) {\n            return 0;\n        }\n        var tmp = Math.sqrt(r * r - y * y);\n        roots[0] = -tmp;\n        roots[1] = tmp;\n\n        var diff = Math.abs(startAngle - endAngle);\n        if (diff < 1e-4) {\n            return 0;\n        }\n        if (diff % PI2 < 1e-4) {\n            // Is a circle\n            startAngle = 0;\n            endAngle = PI2;\n            var dir = anticlockwise ? 1 : -1;\n            if (x >= roots[0] + cx && x <= roots[1] + cx) {\n                return dir;\n            } else {\n                return 0;\n            }\n        }\n\n        if (anticlockwise) {\n            var tmp = startAngle;\n            startAngle = normalizeRadian(endAngle);\n            endAngle = normalizeRadian(tmp);\n        }\n        else {\n            startAngle = normalizeRadian(startAngle);\n            endAngle = normalizeRadian(endAngle);\n        }\n        if (startAngle > endAngle) {\n            endAngle += PI2;\n        }\n\n        var w = 0;\n        for (var i = 0; i < 2; i++) {\n            var x_ = roots[i];\n            if (x_ + cx > x) {\n                var angle = Math.atan2(y, x_);\n                var dir = anticlockwise ? 1 : -1;\n                if (angle < 0) {\n                    angle = PI2 + angle;\n                }\n                if (\n                    (angle >= startAngle && angle <= endAngle)\n                    || (angle + PI2 >= startAngle && angle + PI2 <= endAngle)\n                ) {\n                    if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {\n                        dir = -dir;\n                    }\n                    w += dir;\n                }\n            }\n        }\n        return w;\n    }\n\n    function containPath(data, lineWidth, isStroke, x, y) {\n        var w = 0;\n        var xi = 0;\n        var yi = 0;\n        var x0 = 0;\n        var y0 = 0;\n\n        for (var i = 0; i < data.length;) {\n            var cmd = data[i++];\n            // Begin a new subpath\n            if (cmd === CMD.M && i > 1) {\n                // Close previous subpath\n                if (!isStroke) {\n                    w += windingLine(xi, yi, x0, y0, x, y);\n                }\n                // 如果被任何一个 subpath 包含\n                // if (w !== 0) {\n                //     return true;\n                // }\n            }\n\n            if (i == 1) {\n                // 如果第一个命令是 L, C, Q\n                // 则 previous point 同绘制命令的第一个 point\n                //\n                // 第一个命令为 Arc 的情况下会在后面特殊处理\n                xi = data[i];\n                yi = data[i + 1];\n\n                x0 = xi;\n                y0 = yi;\n            }\n\n            switch (cmd) {\n                case CMD.M:\n                    // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点\n                    // 在 closePath 的时候使用\n                    x0 = data[i++];\n                    y0 = data[i++];\n                    xi = x0;\n                    yi = y0;\n                    break;\n                case CMD.L:\n                    if (isStroke) {\n                        if (containStroke(xi, yi, data[i], data[i + 1], lineWidth, x, y)) {\n                            return true;\n                        }\n                    }\n                    else {\n                        // NOTE 在第一个命令为 L, C, Q 的时候会计算出 NaN\n                        w += windingLine(xi, yi, data[i], data[i + 1], x, y) || 0;\n                    }\n                    xi = data[i++];\n                    yi = data[i++];\n                    break;\n                case CMD.C:\n                    if (isStroke) {\n                        if (cubic.containStroke(xi, yi,\n                            data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n                            lineWidth, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        w += windingCubic(\n                            xi, yi,\n                            data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n                            x, y\n                        ) || 0;\n                    }\n                    xi = data[i++];\n                    yi = data[i++];\n                    break;\n                case CMD.Q:\n                    if (isStroke) {\n                        if (quadratic.containStroke(xi, yi,\n                            data[i++], data[i++], data[i], data[i + 1],\n                            lineWidth, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        w += windingQuadratic(\n                            xi, yi,\n                            data[i++], data[i++], data[i], data[i + 1],\n                            x, y\n                        ) || 0;\n                    }\n                    xi = data[i++];\n                    yi = data[i++];\n                    break;\n                case CMD.A:\n                    // TODO Arc 判断的开销比较大\n                    var cx = data[i++];\n                    var cy = data[i++];\n                    var rx = data[i++];\n                    var ry = data[i++];\n                    var theta = data[i++];\n                    var dTheta = data[i++];\n                    // TODO Arc 旋转\n                    var psi = data[i++];\n                    var anticlockwise = 1 - data[i++];\n                    var x1 = Math.cos(theta) * rx + cx;\n                    var y1 = Math.sin(theta) * ry + cy;\n                    // 不是直接使用 arc 命令\n                    if (i > 1) {\n                        w += windingLine(xi, yi, x1, y1, x, y);\n                    }\n                    else {\n                        // 第一个命令起点还未定义\n                        x0 = x1;\n                        y0 = y1;\n                    }\n                    // zr 使用scale来模拟椭圆, 这里也对x做一定的缩放\n                    var _x = (x - cx) * ry / rx + cx;\n                    if (isStroke) {\n                        if (arc.containStroke(\n                            cx, cy, ry, theta, theta + dTheta, anticlockwise,\n                            lineWidth, _x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        w += windingArc(\n                            cx, cy, ry, theta, theta + dTheta, anticlockwise,\n                            _x, y\n                        );\n                    }\n                    xi = Math.cos(theta + dTheta) * rx + cx;\n                    yi = Math.sin(theta + dTheta) * ry + cy;\n                    break;\n                case CMD.R:\n                    x0 = xi = data[i++];\n                    y0 = yi = data[i++];\n                    var width = data[i++];\n                    var height = data[i++];\n                    var x1 = x0 + width;\n                    var y1 = y0 + height;\n                    if (isStroke) {\n                        if (containStroke(x0, y0, x1, y0, lineWidth, x, y)\n                          || containStroke(x1, y0, x1, y1, lineWidth, x, y)\n                          || containStroke(x1, y1, x0, y1, lineWidth, x, y)\n                          || containStroke(x0, y1, x0, y0, lineWidth, x, y)\n                        ) {\n                            return true;\n                        }\n                    }\n                    else {\n                        // FIXME Clockwise ?\n                        w += windingLine(x1, y0, x1, y1, x, y);\n                        w += windingLine(x0, y1, x0, y0, x, y);\n                    }\n                    break;\n                case CMD.Z:\n                    if (isStroke) {\n                        if (containStroke(\n                            xi, yi, x0, y0, lineWidth, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        // Close a subpath\n                        w += windingLine(xi, yi, x0, y0, x, y);\n                        // 如果被任何一个 subpath 包含\n                        // FIXME subpaths may overlap\n                        // if (w !== 0) {\n                        //     return true;\n                        // }\n                    }\n                    xi = x0;\n                    yi = y0;\n                    break;\n            }\n        }\n        if (!isStroke && !isAroundEqual(yi, y0)) {\n            w += windingLine(xi, yi, x0, y0, x, y) || 0;\n        }\n        return w !== 0;\n    }\n\n    module.exports = {\n        contain: function (pathData, x, y) {\n            return containPath(pathData, 0, false, x, y);\n        },\n\n        containStroke: function (pathData, lineWidth, x, y) {\n            return containPath(pathData, lineWidth, true, x, y);\n        }\n    };\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTExLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy9ob21lL3l4L34venJlbmRlci9saWIvY29udGFpbi9wYXRoLmpzP2E5ZGIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgQ01EID0gcmVxdWlyZSgnLi4vY29yZS9QYXRoUHJveHknKS5DTUQ7XG4gICAgdmFyIGxpbmUgPSByZXF1aXJlKCcuL2xpbmUnKTtcbiAgICB2YXIgY3ViaWMgPSByZXF1aXJlKCcuL2N1YmljJyk7XG4gICAgdmFyIHF1YWRyYXRpYyA9IHJlcXVpcmUoJy4vcXVhZHJhdGljJyk7XG4gICAgdmFyIGFyYyA9IHJlcXVpcmUoJy4vYXJjJyk7XG4gICAgdmFyIG5vcm1hbGl6ZVJhZGlhbiA9IHJlcXVpcmUoJy4vdXRpbCcpLm5vcm1hbGl6ZVJhZGlhbjtcbiAgICB2YXIgY3VydmUgPSByZXF1aXJlKCcuLi9jb3JlL2N1cnZlJyk7XG5cbiAgICB2YXIgd2luZGluZ0xpbmUgPSByZXF1aXJlKCcuL3dpbmRpbmdMaW5lJyk7XG5cbiAgICB2YXIgY29udGFpblN0cm9rZSA9IGxpbmUuY29udGFpblN0cm9rZTtcblxuICAgIHZhciBQSTIgPSBNYXRoLlBJICogMjtcblxuICAgIHZhciBFUFNJTE9OID0gMWUtNDtcblxuICAgIGZ1bmN0aW9uIGlzQXJvdW5kRXF1YWwoYSwgYikge1xuICAgICAgICByZXR1cm4gTWF0aC5hYnMoYSAtIGIpIDwgRVBTSUxPTjtcbiAgICB9XG5cbiAgICAvLyDkuLTml7bmlbDnu4RcbiAgICB2YXIgcm9vdHMgPSBbLTEsIC0xLCAtMV07XG4gICAgdmFyIGV4dHJlbWEgPSBbLTEsIC0xXTtcblxuICAgIGZ1bmN0aW9uIHN3YXBFeHRyZW1hKCkge1xuICAgICAgICB2YXIgdG1wID0gZXh0cmVtYVswXTtcbiAgICAgICAgZXh0cmVtYVswXSA9IGV4dHJlbWFbMV07XG4gICAgICAgIGV4dHJlbWFbMV0gPSB0bXA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2luZGluZ0N1YmljKHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgeCwgeSkge1xuICAgICAgICAvLyBRdWljayByZWplY3RcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgKHkgPiB5MCAmJiB5ID4geTEgJiYgeSA+IHkyICYmIHkgPiB5MylcbiAgICAgICAgICAgIHx8ICh5IDwgeTAgJiYgeSA8IHkxICYmIHkgPCB5MiAmJiB5IDwgeTMpXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5Sb290cyA9IGN1cnZlLmN1YmljUm9vdEF0KHkwLCB5MSwgeTIsIHkzLCB5LCByb290cyk7XG4gICAgICAgIGlmIChuUm9vdHMgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHcgPSAwO1xuICAgICAgICAgICAgdmFyIG5FeHRyZW1hID0gLTE7XG4gICAgICAgICAgICB2YXIgeTBfLCB5MV87XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5Sb290czsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHQgPSByb290c1tpXTtcblxuICAgICAgICAgICAgICAgIC8vIEF2b2lkIHdpbmRpbmcgZXJyb3Igd2hlbiBpbnRlcnNlY3Rpb24gcG9pbnQgaXMgdGhlIGNvbm5lY3QgcG9pbnQgb2YgdHdvIGxpbmUgb2YgcG9seWdvblxuICAgICAgICAgICAgICAgIHZhciB1bml0ID0gKHQgPT09IDAgfHwgdCA9PT0gMSkgPyAwLjUgOiAxO1xuXG4gICAgICAgICAgICAgICAgdmFyIHhfID0gY3VydmUuY3ViaWNBdCh4MCwgeDEsIHgyLCB4MywgdCk7XG4gICAgICAgICAgICAgICAgaWYgKHhfIDwgeCkgeyAvLyBRdWljayByZWplY3RcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChuRXh0cmVtYSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbkV4dHJlbWEgPSBjdXJ2ZS5jdWJpY0V4dHJlbWEoeTAsIHkxLCB5MiwgeTMsIGV4dHJlbWEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXh0cmVtYVsxXSA8IGV4dHJlbWFbMF0gJiYgbkV4dHJlbWEgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2FwRXh0cmVtYSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHkwXyA9IGN1cnZlLmN1YmljQXQoeTAsIHkxLCB5MiwgeTMsIGV4dHJlbWFbMF0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAobkV4dHJlbWEgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB5MV8gPSBjdXJ2ZS5jdWJpY0F0KHkwLCB5MSwgeTIsIHkzLCBleHRyZW1hWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobkV4dHJlbWEgPT0gMikge1xuICAgICAgICAgICAgICAgICAgICAvLyDliIbmiJDkuInmrrXljZXosIPlh73mlbBcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgPCBleHRyZW1hWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3ICs9IHkwXyA8IHkwID8gdW5pdCA6IC11bml0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHQgPCBleHRyZW1hWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3ICs9IHkxXyA8IHkwXyA/IHVuaXQgOiAtdW5pdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHcgKz0geTMgPCB5MV8gPyB1bml0IDogLXVuaXQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIOWIhuaIkOS4pOauteWNleiwg+WHveaVsFxuICAgICAgICAgICAgICAgICAgICBpZiAodCA8IGV4dHJlbWFbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHcgKz0geTBfIDwgeTAgPyB1bml0IDogLXVuaXQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3ICs9IHkzIDwgeTBfID8gdW5pdCA6IC11bml0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3aW5kaW5nUXVhZHJhdGljKHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgsIHkpIHtcbiAgICAgICAgLy8gUXVpY2sgcmVqZWN0XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgICh5ID4geTAgJiYgeSA+IHkxICYmIHkgPiB5MilcbiAgICAgICAgICAgIHx8ICh5IDwgeTAgJiYgeSA8IHkxICYmIHkgPCB5MilcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgblJvb3RzID0gY3VydmUucXVhZHJhdGljUm9vdEF0KHkwLCB5MSwgeTIsIHksIHJvb3RzKTtcbiAgICAgICAgaWYgKG5Sb290cyA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgdCA9IGN1cnZlLnF1YWRyYXRpY0V4dHJlbXVtKHkwLCB5MSwgeTIpO1xuICAgICAgICAgICAgaWYgKHQgPj0gMCAmJiB0IDw9IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgdyA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIHlfID0gY3VydmUucXVhZHJhdGljQXQoeTAsIHkxLCB5MiwgdCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuUm9vdHM7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgb25lIGVuZHBvaW50LlxuICAgICAgICAgICAgICAgICAgICB2YXIgdW5pdCA9IChyb290c1tpXSA9PT0gMCB8fCByb290c1tpXSA9PT0gMSkgPyAwLjUgOiAxO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciB4XyA9IGN1cnZlLnF1YWRyYXRpY0F0KHgwLCB4MSwgeDIsIHJvb3RzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHhfIDwgeCkgeyAgIC8vIFF1aWNrIHJlamVjdFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJvb3RzW2ldIDwgdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdyArPSB5XyA8IHkwID8gdW5pdCA6IC11bml0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdyArPSB5MiA8IHlfID8gdW5pdCA6IC11bml0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB3O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIG9uZSBlbmRwb2ludC5cbiAgICAgICAgICAgICAgICB2YXIgdW5pdCA9IChyb290c1swXSA9PT0gMCB8fCByb290c1swXSA9PT0gMSkgPyAwLjUgOiAxO1xuXG4gICAgICAgICAgICAgICAgdmFyIHhfID0gY3VydmUucXVhZHJhdGljQXQoeDAsIHgxLCB4Miwgcm9vdHNbMF0pO1xuICAgICAgICAgICAgICAgIGlmICh4XyA8IHgpIHsgICAvLyBRdWljayByZWplY3RcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB5MiA8IHkwID8gdW5pdCA6IC11bml0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVE9ET1xuICAgIC8vIEFyYyDml4vovaxcbiAgICBmdW5jdGlvbiB3aW5kaW5nQXJjKFxuICAgICAgICBjeCwgY3ksIHIsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBhbnRpY2xvY2t3aXNlLCB4LCB5XG4gICAgKSB7XG4gICAgICAgIHkgLT0gY3k7XG4gICAgICAgIGlmICh5ID4gciB8fCB5IDwgLXIpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0bXAgPSBNYXRoLnNxcnQociAqIHIgLSB5ICogeSk7XG4gICAgICAgIHJvb3RzWzBdID0gLXRtcDtcbiAgICAgICAgcm9vdHNbMV0gPSB0bXA7XG5cbiAgICAgICAgdmFyIGRpZmYgPSBNYXRoLmFicyhzdGFydEFuZ2xlIC0gZW5kQW5nbGUpO1xuICAgICAgICBpZiAoZGlmZiA8IDFlLTQpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkaWZmICUgUEkyIDwgMWUtNCkge1xuICAgICAgICAgICAgLy8gSXMgYSBjaXJjbGVcbiAgICAgICAgICAgIHN0YXJ0QW5nbGUgPSAwO1xuICAgICAgICAgICAgZW5kQW5nbGUgPSBQSTI7XG4gICAgICAgICAgICB2YXIgZGlyID0gYW50aWNsb2Nrd2lzZSA/IDEgOiAtMTtcbiAgICAgICAgICAgIGlmICh4ID49IHJvb3RzWzBdICsgY3ggJiYgeCA8PSByb290c1sxXSArIGN4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpcjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYW50aWNsb2Nrd2lzZSkge1xuICAgICAgICAgICAgdmFyIHRtcCA9IHN0YXJ0QW5nbGU7XG4gICAgICAgICAgICBzdGFydEFuZ2xlID0gbm9ybWFsaXplUmFkaWFuKGVuZEFuZ2xlKTtcbiAgICAgICAgICAgIGVuZEFuZ2xlID0gbm9ybWFsaXplUmFkaWFuKHRtcCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGFydEFuZ2xlID0gbm9ybWFsaXplUmFkaWFuKHN0YXJ0QW5nbGUpO1xuICAgICAgICAgICAgZW5kQW5nbGUgPSBub3JtYWxpemVSYWRpYW4oZW5kQW5nbGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydEFuZ2xlID4gZW5kQW5nbGUpIHtcbiAgICAgICAgICAgIGVuZEFuZ2xlICs9IFBJMjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB3ID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB4XyA9IHJvb3RzW2ldO1xuICAgICAgICAgICAgaWYgKHhfICsgY3ggPiB4KSB7XG4gICAgICAgICAgICAgICAgdmFyIGFuZ2xlID0gTWF0aC5hdGFuMih5LCB4Xyk7XG4gICAgICAgICAgICAgICAgdmFyIGRpciA9IGFudGljbG9ja3dpc2UgPyAxIDogLTE7XG4gICAgICAgICAgICAgICAgaWYgKGFuZ2xlIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBhbmdsZSA9IFBJMiArIGFuZ2xlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIChhbmdsZSA+PSBzdGFydEFuZ2xlICYmIGFuZ2xlIDw9IGVuZEFuZ2xlKVxuICAgICAgICAgICAgICAgICAgICB8fCAoYW5nbGUgKyBQSTIgPj0gc3RhcnRBbmdsZSAmJiBhbmdsZSArIFBJMiA8PSBlbmRBbmdsZSlcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFuZ2xlID4gTWF0aC5QSSAvIDIgJiYgYW5nbGUgPCBNYXRoLlBJICogMS41KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXIgPSAtZGlyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHcgKz0gZGlyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb250YWluUGF0aChkYXRhLCBsaW5lV2lkdGgsIGlzU3Ryb2tlLCB4LCB5KSB7XG4gICAgICAgIHZhciB3ID0gMDtcbiAgICAgICAgdmFyIHhpID0gMDtcbiAgICAgICAgdmFyIHlpID0gMDtcbiAgICAgICAgdmFyIHgwID0gMDtcbiAgICAgICAgdmFyIHkwID0gMDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOykge1xuICAgICAgICAgICAgdmFyIGNtZCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgIC8vIEJlZ2luIGEgbmV3IHN1YnBhdGhcbiAgICAgICAgICAgIGlmIChjbWQgPT09IENNRC5NICYmIGkgPiAxKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2xvc2UgcHJldmlvdXMgc3VicGF0aFxuICAgICAgICAgICAgICAgIGlmICghaXNTdHJva2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdyArPSB3aW5kaW5nTGluZSh4aSwgeWksIHgwLCB5MCwgeCwgeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIOWmguaenOiiq+S7u+S9leS4gOS4qiBzdWJwYXRoIOWMheWQq1xuICAgICAgICAgICAgICAgIC8vIGlmICh3ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGkgPT0gMSkge1xuICAgICAgICAgICAgICAgIC8vIOWmguaenOesrOS4gOS4quWRveS7pOaYryBMLCBDLCBRXG4gICAgICAgICAgICAgICAgLy8g5YiZIHByZXZpb3VzIHBvaW50IOWQjOe7mOWItuWRveS7pOeahOesrOS4gOS4qiBwb2ludFxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8g56ys5LiA5Liq5ZG95Luk5Li6IEFyYyDnmoTmg4XlhrXkuIvkvJrlnKjlkI7pnaLnibnmrorlpITnkIZcbiAgICAgICAgICAgICAgICB4aSA9IGRhdGFbaV07XG4gICAgICAgICAgICAgICAgeWkgPSBkYXRhW2kgKyAxXTtcblxuICAgICAgICAgICAgICAgIHgwID0geGk7XG4gICAgICAgICAgICAgICAgeTAgPSB5aTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3dpdGNoIChjbWQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIENNRC5NOlxuICAgICAgICAgICAgICAgICAgICAvLyBtb3ZlVG8g5ZG95Luk6YeN5paw5Yib5bu65LiA5Liq5paw55qEIHN1YnBhdGgsIOW5tuS4lOabtOaWsOaWsOeahOi1t+eCuVxuICAgICAgICAgICAgICAgICAgICAvLyDlnKggY2xvc2VQYXRoIOeahOaXtuWAmeS9v+eUqFxuICAgICAgICAgICAgICAgICAgICB4MCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgeTAgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHhpID0geDA7XG4gICAgICAgICAgICAgICAgICAgIHlpID0geTA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQ01ELkw6XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1N0cm9rZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRhaW5TdHJva2UoeGksIHlpLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSwgbGluZVdpZHRoLCB4LCB5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTk9URSDlnKjnrKzkuIDkuKrlkb3ku6TkuLogTCwgQywgUSDnmoTml7blgJnkvJrorqHnrpflh7ogTmFOXG4gICAgICAgICAgICAgICAgICAgICAgICB3ICs9IHdpbmRpbmdMaW5lKHhpLCB5aSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sIHgsIHkpIHx8IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgeGkgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHlpID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIENNRC5DOlxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNTdHJva2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdWJpYy5jb250YWluU3Ryb2tlKHhpLCB5aSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaV0sIGRhdGFbaSArIDFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVXaWR0aCwgeCwgeVxuICAgICAgICAgICAgICAgICAgICAgICAgKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdyArPSB3aW5kaW5nQ3ViaWMoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeGksIHlpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeCwgeVxuICAgICAgICAgICAgICAgICAgICAgICAgKSB8fCAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHhpID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICB5aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBDTUQuUTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzU3Ryb2tlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocXVhZHJhdGljLmNvbnRhaW5TdHJva2UoeGksIHlpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lV2lkdGgsIHgsIHlcbiAgICAgICAgICAgICAgICAgICAgICAgICkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHcgKz0gd2luZGluZ1F1YWRyYXRpYyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aSwgeWksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaV0sIGRhdGFbaSArIDFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgsIHlcbiAgICAgICAgICAgICAgICAgICAgICAgICkgfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB4aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgeWkgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQ01ELkE6XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gQXJjIOWIpOaWreeahOW8gOmUgOavlOi+g+Wkp1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3ggPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHZhciBjeSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJ4ID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcnkgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHZhciB0aGV0YSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRUaGV0YSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBBcmMg5peL6L2sXG4gICAgICAgICAgICAgICAgICAgIHZhciBwc2kgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHZhciBhbnRpY2xvY2t3aXNlID0gMSAtIGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHgxID0gTWF0aC5jb3ModGhldGEpICogcnggKyBjeDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHkxID0gTWF0aC5zaW4odGhldGEpICogcnkgKyBjeTtcbiAgICAgICAgICAgICAgICAgICAgLy8g5LiN5piv55u05o6l5L2/55SoIGFyYyDlkb3ku6RcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3ICs9IHdpbmRpbmdMaW5lKHhpLCB5aSwgeDEsIHkxLCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIOesrOS4gOS4quWRveS7pOi1t+eCuei/mOacquWumuS5iVxuICAgICAgICAgICAgICAgICAgICAgICAgeDAgPSB4MTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkwID0geTE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8genIg5L2/55Soc2NhbGXmnaXmqKHmi5/mpK3lnIYsIOi/memHjOS5n+WvuXjlgZrkuIDlrprnmoTnvKnmlL5cbiAgICAgICAgICAgICAgICAgICAgdmFyIF94ID0gKHggLSBjeCkgKiByeSAvIHJ4ICsgY3g7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1N0cm9rZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFyYy5jb250YWluU3Ryb2tlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN4LCBjeSwgcnksIHRoZXRhLCB0aGV0YSArIGRUaGV0YSwgYW50aWNsb2Nrd2lzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lV2lkdGgsIF94LCB5XG4gICAgICAgICAgICAgICAgICAgICAgICApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3ICs9IHdpbmRpbmdBcmMoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3gsIGN5LCByeSwgdGhldGEsIHRoZXRhICsgZFRoZXRhLCBhbnRpY2xvY2t3aXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF94LCB5XG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHhpID0gTWF0aC5jb3ModGhldGEgKyBkVGhldGEpICogcnggKyBjeDtcbiAgICAgICAgICAgICAgICAgICAgeWkgPSBNYXRoLnNpbih0aGV0YSArIGRUaGV0YSkgKiByeSArIGN5O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIENNRC5SOlxuICAgICAgICAgICAgICAgICAgICB4MCA9IHhpID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICB5MCA9IHlpID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHZhciBoZWlnaHQgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHZhciB4MSA9IHgwICsgd2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIHZhciB5MSA9IHkwICsgaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNTdHJva2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250YWluU3Ryb2tlKHgwLCB5MCwgeDEsIHkwLCBsaW5lV2lkdGgsIHgsIHkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHx8IGNvbnRhaW5TdHJva2UoeDEsIHkwLCB4MSwgeTEsIGxpbmVXaWR0aCwgeCwgeSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgY29udGFpblN0cm9rZSh4MSwgeTEsIHgwLCB5MSwgbGluZVdpZHRoLCB4LCB5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICB8fCBjb250YWluU3Ryb2tlKHgwLCB5MSwgeDAsIHkwLCBsaW5lV2lkdGgsIHgsIHkpXG4gICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZJWE1FIENsb2Nrd2lzZSA/XG4gICAgICAgICAgICAgICAgICAgICAgICB3ICs9IHdpbmRpbmdMaW5lKHgxLCB5MCwgeDEsIHkxLCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHcgKz0gd2luZGluZ0xpbmUoeDAsIHkxLCB4MCwgeTAsIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQ01ELlo6XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1N0cm9rZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRhaW5TdHJva2UoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeGksIHlpLCB4MCwgeTAsIGxpbmVXaWR0aCwgeCwgeVxuICAgICAgICAgICAgICAgICAgICAgICAgKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2xvc2UgYSBzdWJwYXRoXG4gICAgICAgICAgICAgICAgICAgICAgICB3ICs9IHdpbmRpbmdMaW5lKHhpLCB5aSwgeDAsIHkwLCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIOWmguaenOiiq+S7u+S9leS4gOS4qiBzdWJwYXRoIOWMheWQq1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRklYTUUgc3VicGF0aHMgbWF5IG92ZXJsYXBcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmICh3ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgeGkgPSB4MDtcbiAgICAgICAgICAgICAgICAgICAgeWkgPSB5MDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1N0cm9rZSAmJiAhaXNBcm91bmRFcXVhbCh5aSwgeTApKSB7XG4gICAgICAgICAgICB3ICs9IHdpbmRpbmdMaW5lKHhpLCB5aSwgeDAsIHkwLCB4LCB5KSB8fCAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3ICE9PSAwO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBjb250YWluOiBmdW5jdGlvbiAocGF0aERhdGEsIHgsIHkpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250YWluUGF0aChwYXRoRGF0YSwgMCwgZmFsc2UsIHgsIHkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNvbnRhaW5TdHJva2U6IGZ1bmN0aW9uIChwYXRoRGF0YSwgbGluZVdpZHRoLCB4LCB5KSB7XG4gICAgICAgICAgICByZXR1cm4gY29udGFpblBhdGgocGF0aERhdGEsIGxpbmVXaWR0aCwgdHJ1ZSwgeCwgeSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2hvbWUveXgvfi96cmVuZGVyL2xpYi9jb250YWluL3BhdGguanNcbi8vIG1vZHVsZSBpZCA9IDExMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 112 */
/* unknown exports provided */
/* all exports used */
/*!*************************************************!*\
  !*** /home/yx/~/zrender/lib/core/GestureMgr.js ***!
  \*************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Only implements needed gestures for mobile.\n */\n\n\n    var eventUtil = __webpack_require__(/*! ./event */ 20);\n\n    var GestureMgr = function () {\n\n        /**\n         * @private\n         * @type {Array.<Object>}\n         */\n        this._track = [];\n    };\n\n    GestureMgr.prototype = {\n\n        constructor: GestureMgr,\n\n        recognize: function (event, target, root) {\n            this._doTrack(event, target, root);\n            return this._recognize(event);\n        },\n\n        clear: function () {\n            this._track.length = 0;\n            return this;\n        },\n\n        _doTrack: function (event, target, root) {\n            var touches = event.touches;\n\n            if (!touches) {\n                return;\n            }\n\n            var trackItem = {\n                points: [],\n                touches: [],\n                target: target,\n                event: event\n            };\n\n            for (var i = 0, len = touches.length; i < len; i++) {\n                var touch = touches[i];\n                var pos = eventUtil.clientToLocal(root, touch, {});\n                trackItem.points.push([pos.zrX, pos.zrY]);\n                trackItem.touches.push(touch);\n            }\n\n            this._track.push(trackItem);\n        },\n\n        _recognize: function (event) {\n            for (var eventName in recognizers) {\n                if (recognizers.hasOwnProperty(eventName)) {\n                    var gestureInfo = recognizers[eventName](this._track, event);\n                    if (gestureInfo) {\n                        return gestureInfo;\n                    }\n                }\n            }\n        }\n    };\n\n    function dist(pointPair) {\n        var dx = pointPair[1][0] - pointPair[0][0];\n        var dy = pointPair[1][1] - pointPair[0][1];\n\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n\n    function center(pointPair) {\n        return [\n            (pointPair[0][0] + pointPair[1][0]) / 2,\n            (pointPair[0][1] + pointPair[1][1]) / 2\n        ];\n    }\n\n    var recognizers = {\n\n        pinch: function (track, event) {\n            var trackLen = track.length;\n\n            if (!trackLen) {\n                return;\n            }\n\n            var pinchEnd = (track[trackLen - 1] || {}).points;\n            var pinchPre = (track[trackLen - 2] || {}).points || pinchEnd;\n\n            if (pinchPre\n                && pinchPre.length > 1\n                && pinchEnd\n                && pinchEnd.length > 1\n            ) {\n                var pinchScale = dist(pinchEnd) / dist(pinchPre);\n                !isFinite(pinchScale) && (pinchScale = 1);\n\n                event.pinchScale = pinchScale;\n\n                var pinchCenter = center(pinchEnd);\n                event.pinchX = pinchCenter[0];\n                event.pinchY = pinchCenter[1];\n\n                return {\n                    type: 'pinch',\n                    target: track[0].target,\n                    event: event\n                };\n            }\n        }\n\n        // Only pinch currently.\n    };\n\n    module.exports = GestureMgr;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTEyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy9ob21lL3l4L34venJlbmRlci9saWIvY29yZS9HZXN0dXJlTWdyLmpzPzBlOWEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuLyoqXG4gKiBPbmx5IGltcGxlbWVudHMgbmVlZGVkIGdlc3R1cmVzIGZvciBtb2JpbGUuXG4gKi9cblxuXG4gICAgdmFyIGV2ZW50VXRpbCA9IHJlcXVpcmUoJy4vZXZlbnQnKTtcblxuICAgIHZhciBHZXN0dXJlTWdyID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPE9iamVjdD59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl90cmFjayA9IFtdO1xuICAgIH07XG5cbiAgICBHZXN0dXJlTWdyLnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogR2VzdHVyZU1ncixcblxuICAgICAgICByZWNvZ25pemU6IGZ1bmN0aW9uIChldmVudCwgdGFyZ2V0LCByb290KSB7XG4gICAgICAgICAgICB0aGlzLl9kb1RyYWNrKGV2ZW50LCB0YXJnZXQsIHJvb3QpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlY29nbml6ZShldmVudCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX3RyYWNrLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBfZG9UcmFjazogZnVuY3Rpb24gKGV2ZW50LCB0YXJnZXQsIHJvb3QpIHtcbiAgICAgICAgICAgIHZhciB0b3VjaGVzID0gZXZlbnQudG91Y2hlcztcblxuICAgICAgICAgICAgaWYgKCF0b3VjaGVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdHJhY2tJdGVtID0ge1xuICAgICAgICAgICAgICAgIHBvaW50czogW10sXG4gICAgICAgICAgICAgICAgdG91Y2hlczogW10sXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICAgICAgICAgICAgZXZlbnQ6IGV2ZW50XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdG91Y2hlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciB0b3VjaCA9IHRvdWNoZXNbaV07XG4gICAgICAgICAgICAgICAgdmFyIHBvcyA9IGV2ZW50VXRpbC5jbGllbnRUb0xvY2FsKHJvb3QsIHRvdWNoLCB7fSk7XG4gICAgICAgICAgICAgICAgdHJhY2tJdGVtLnBvaW50cy5wdXNoKFtwb3MuenJYLCBwb3MuenJZXSk7XG4gICAgICAgICAgICAgICAgdHJhY2tJdGVtLnRvdWNoZXMucHVzaCh0b3VjaCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX3RyYWNrLnB1c2godHJhY2tJdGVtKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfcmVjb2duaXplOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGV2ZW50TmFtZSBpbiByZWNvZ25pemVycykge1xuICAgICAgICAgICAgICAgIGlmIChyZWNvZ25pemVycy5oYXNPd25Qcm9wZXJ0eShldmVudE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBnZXN0dXJlSW5mbyA9IHJlY29nbml6ZXJzW2V2ZW50TmFtZV0odGhpcy5fdHJhY2ssIGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdlc3R1cmVJbmZvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2VzdHVyZUluZm87XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZGlzdChwb2ludFBhaXIpIHtcbiAgICAgICAgdmFyIGR4ID0gcG9pbnRQYWlyWzFdWzBdIC0gcG9pbnRQYWlyWzBdWzBdO1xuICAgICAgICB2YXIgZHkgPSBwb2ludFBhaXJbMV1bMV0gLSBwb2ludFBhaXJbMF1bMV07XG5cbiAgICAgICAgcmV0dXJuIE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2VudGVyKHBvaW50UGFpcikge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgKHBvaW50UGFpclswXVswXSArIHBvaW50UGFpclsxXVswXSkgLyAyLFxuICAgICAgICAgICAgKHBvaW50UGFpclswXVsxXSArIHBvaW50UGFpclsxXVsxXSkgLyAyXG4gICAgICAgIF07XG4gICAgfVxuXG4gICAgdmFyIHJlY29nbml6ZXJzID0ge1xuXG4gICAgICAgIHBpbmNoOiBmdW5jdGlvbiAodHJhY2ssIGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgdHJhY2tMZW4gPSB0cmFjay5sZW5ndGg7XG5cbiAgICAgICAgICAgIGlmICghdHJhY2tMZW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBwaW5jaEVuZCA9ICh0cmFja1t0cmFja0xlbiAtIDFdIHx8IHt9KS5wb2ludHM7XG4gICAgICAgICAgICB2YXIgcGluY2hQcmUgPSAodHJhY2tbdHJhY2tMZW4gLSAyXSB8fCB7fSkucG9pbnRzIHx8IHBpbmNoRW5kO1xuXG4gICAgICAgICAgICBpZiAocGluY2hQcmVcbiAgICAgICAgICAgICAgICAmJiBwaW5jaFByZS5sZW5ndGggPiAxXG4gICAgICAgICAgICAgICAgJiYgcGluY2hFbmRcbiAgICAgICAgICAgICAgICAmJiBwaW5jaEVuZC5sZW5ndGggPiAxXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB2YXIgcGluY2hTY2FsZSA9IGRpc3QocGluY2hFbmQpIC8gZGlzdChwaW5jaFByZSk7XG4gICAgICAgICAgICAgICAgIWlzRmluaXRlKHBpbmNoU2NhbGUpICYmIChwaW5jaFNjYWxlID0gMSk7XG5cbiAgICAgICAgICAgICAgICBldmVudC5waW5jaFNjYWxlID0gcGluY2hTY2FsZTtcblxuICAgICAgICAgICAgICAgIHZhciBwaW5jaENlbnRlciA9IGNlbnRlcihwaW5jaEVuZCk7XG4gICAgICAgICAgICAgICAgZXZlbnQucGluY2hYID0gcGluY2hDZW50ZXJbMF07XG4gICAgICAgICAgICAgICAgZXZlbnQucGluY2hZID0gcGluY2hDZW50ZXJbMV07XG5cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAncGluY2gnLFxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IHRyYWNrWzBdLnRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IGV2ZW50XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE9ubHkgcGluY2ggY3VycmVudGx5LlxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IEdlc3R1cmVNZ3I7XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9ob21lL3l4L34venJlbmRlci9saWIvY29yZS9HZXN0dXJlTWdyLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 113 */
/* unknown exports provided */
/* all exports used */
/*!**************************************************!*\
  !*** /home/yx/~/zrender/lib/dom/HandlerProxy.js ***!
  \**************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var eventTool = __webpack_require__(/*! ../core/event */ 20);\n    var zrUtil = __webpack_require__(/*! ../core/util */ 0);\n    var Eventful = __webpack_require__(/*! ../mixin/Eventful */ 22);\n    var env = __webpack_require__(/*! ../core/env */ 8);\n    var GestureMgr = __webpack_require__(/*! ../core/GestureMgr */ 112);\n\n    var addEventListener = eventTool.addEventListener;\n    var removeEventListener = eventTool.removeEventListener;\n    var normalizeEvent = eventTool.normalizeEvent;\n\n    var TOUCH_CLICK_DELAY = 300;\n\n    var mouseHandlerNames = [\n        'click', 'dblclick', 'mousewheel', 'mouseout',\n        'mouseup', 'mousedown', 'mousemove', 'contextmenu'\n    ];\n\n    var touchHandlerNames = [\n        'touchstart', 'touchend', 'touchmove'\n    ];\n\n    var pointerEventNames = {\n        pointerdown: 1, pointerup: 1, pointermove: 1, pointerout: 1\n    };\n\n    var pointerHandlerNames = zrUtil.map(mouseHandlerNames, function (name) {\n        var nm = name.replace('mouse', 'pointer');\n        return pointerEventNames[nm] ? nm : name;\n    });\n\n    function eventNameFix(name) {\n        return (name === 'mousewheel' && env.browser.firefox) ? 'DOMMouseScroll' : name;\n    }\n\n    function processGesture(proxy, event, stage) {\n        var gestureMgr = proxy._gestureMgr;\n\n        stage === 'start' && gestureMgr.clear();\n\n        var gestureInfo = gestureMgr.recognize(\n            event,\n            proxy.handler.findHover(event.zrX, event.zrY, null).target,\n            proxy.dom\n        );\n\n        stage === 'end' && gestureMgr.clear();\n\n        // Do not do any preventDefault here. Upper application do that if necessary.\n        if (gestureInfo) {\n            var type = gestureInfo.type;\n            event.gestureEvent = type;\n\n            proxy.handler.dispatchToElement({target: gestureInfo.target}, type, gestureInfo.event);\n        }\n    }\n\n    // function onMSGestureChange(proxy, event) {\n    //     if (event.translationX || event.translationY) {\n    //         // mousemove is carried by MSGesture to reduce the sensitivity.\n    //         proxy.handler.dispatchToElement(event.target, 'mousemove', event);\n    //     }\n    //     if (event.scale !== 1) {\n    //         event.pinchX = event.offsetX;\n    //         event.pinchY = event.offsetY;\n    //         event.pinchScale = event.scale;\n    //         proxy.handler.dispatchToElement(event.target, 'pinch', event);\n    //     }\n    // }\n\n    /**\n     * Prevent mouse event from being dispatched after Touch Events action\n     * @see <https://github.com/deltakosh/handjs/blob/master/src/hand.base.js>\n     * 1. Mobile browsers dispatch mouse events 300ms after touchend.\n     * 2. Chrome for Android dispatch mousedown for long-touch about 650ms\n     * Result: Blocking Mouse Events for 700ms.\n     */\n    function setTouchTimer(instance) {\n        instance._touching = true;\n        clearTimeout(instance._touchTimer);\n        instance._touchTimer = setTimeout(function () {\n            instance._touching = false;\n        }, 700);\n    }\n\n\n    var domHandlers = {\n        /**\n         * Mouse move handler\n         * @inner\n         * @param {Event} event\n         */\n        mousemove: function (event) {\n            event = normalizeEvent(this.dom, event);\n\n            this.trigger('mousemove', event);\n        },\n\n        /**\n         * Mouse out handler\n         * @inner\n         * @param {Event} event\n         */\n        mouseout: function (event) {\n            event = normalizeEvent(this.dom, event);\n\n            var element = event.toElement || event.relatedTarget;\n            if (element != this.dom) {\n                while (element && element.nodeType != 9) {\n                    // 忽略包含在root中的dom引起的mouseOut\n                    if (element === this.dom) {\n                        return;\n                    }\n\n                    element = element.parentNode;\n                }\n            }\n\n            this.trigger('mouseout', event);\n        },\n\n        /**\n         * Touch开始响应函数\n         * @inner\n         * @param {Event} event\n         */\n        touchstart: function (event) {\n            // Default mouse behaviour should not be disabled here.\n            // For example, page may needs to be slided.\n            event = normalizeEvent(this.dom, event);\n\n            // Mark touch, which is useful in distinguish touch and\n            // mouse event in upper applicatoin.\n            event.zrByTouch = true;\n\n            this._lastTouchMoment = new Date();\n\n            processGesture(this, event, 'start');\n\n            // In touch device, trigger `mousemove`(`mouseover`) should\n            // be triggered, and must before `mousedown` triggered.\n            domHandlers.mousemove.call(this, event);\n\n            domHandlers.mousedown.call(this, event);\n\n            setTouchTimer(this);\n        },\n\n        /**\n         * Touch移动响应函数\n         * @inner\n         * @param {Event} event\n         */\n        touchmove: function (event) {\n\n            event = normalizeEvent(this.dom, event);\n\n            // Mark touch, which is useful in distinguish touch and\n            // mouse event in upper applicatoin.\n            event.zrByTouch = true;\n\n            processGesture(this, event, 'change');\n\n            // Mouse move should always be triggered no matter whether\n            // there is gestrue event, because mouse move and pinch may\n            // be used at the same time.\n            domHandlers.mousemove.call(this, event);\n\n            setTouchTimer(this);\n        },\n\n        /**\n         * Touch结束响应函数\n         * @inner\n         * @param {Event} event\n         */\n        touchend: function (event) {\n\n            event = normalizeEvent(this.dom, event);\n\n            // Mark touch, which is useful in distinguish touch and\n            // mouse event in upper applicatoin.\n            event.zrByTouch = true;\n\n            processGesture(this, event, 'end');\n\n            domHandlers.mouseup.call(this, event);\n\n            // Do not trigger `mouseout` here, in spite of `mousemove`(`mouseover`) is\n            // triggered in `touchstart`. This seems to be illogical, but by this mechanism,\n            // we can conveniently implement \"hover style\" in both PC and touch device just\n            // by listening to `mouseover` to add \"hover style\" and listening to `mouseout`\n            // to remove \"hover style\" on an element, without any additional code for\n            // compatibility. (`mouseout` will not be triggered in `touchend`, so \"hover\n            // style\" will remain for user view)\n\n            // click event should always be triggered no matter whether\n            // there is gestrue event. System click can not be prevented.\n            if (+new Date() - this._lastTouchMoment < TOUCH_CLICK_DELAY) {\n                domHandlers.click.call(this, event);\n            }\n\n            setTouchTimer(this);\n        },\n\n        pointerdown: function (event) {\n            domHandlers.mousedown.call(this, event);\n\n            // if (useMSGuesture(this, event)) {\n            //     this._msGesture.addPointer(event.pointerId);\n            // }\n        },\n\n        pointermove: function (event) {\n            // FIXME\n            // pointermove is so sensitive that it always triggered when\n            // tap(click) on touch screen, which affect some judgement in\n            // upper application. So, we dont support mousemove on MS touch\n            // device yet.\n            if (!isPointerFromTouch(event)) {\n                domHandlers.mousemove.call(this, event);\n            }\n        },\n\n        pointerup: function (event) {\n            domHandlers.mouseup.call(this, event);\n        },\n\n        pointerout: function (event) {\n            // pointerout will be triggered when tap on touch screen\n            // (IE11+/Edge on MS Surface) after click event triggered,\n            // which is inconsistent with the mousout behavior we defined\n            // in touchend. So we unify them.\n            // (check domHandlers.touchend for detailed explanation)\n            if (!isPointerFromTouch(event)) {\n                domHandlers.mouseout.call(this, event);\n            }\n        }\n    };\n\n    function isPointerFromTouch(event) {\n        var pointerType = event.pointerType;\n        return pointerType === 'pen' || pointerType === 'touch';\n    }\n\n    // function useMSGuesture(handlerProxy, event) {\n    //     return isPointerFromTouch(event) && !!handlerProxy._msGesture;\n    // }\n\n    // Common handlers\n    zrUtil.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\n        domHandlers[name] = function (event) {\n            event = normalizeEvent(this.dom, event);\n            this.trigger(name, event);\n        };\n    });\n\n    /**\n     * 为控制类实例初始化dom 事件处理函数\n     *\n     * @inner\n     * @param {module:zrender/Handler} instance 控制类实例\n     */\n    function initDomHandler(instance) {\n        zrUtil.each(touchHandlerNames, function (name) {\n            instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);\n        });\n\n        zrUtil.each(pointerHandlerNames, function (name) {\n            instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);\n        });\n\n        zrUtil.each(mouseHandlerNames, function (name) {\n            instance._handlers[name] = makeMouseHandler(domHandlers[name], instance);\n        });\n\n        function makeMouseHandler(fn, instance) {\n            return function () {\n                if (instance._touching) {\n                    return;\n                }\n                return fn.apply(instance, arguments);\n            };\n        }\n    }\n\n\n    function HandlerDomProxy(dom) {\n        Eventful.call(this);\n\n        this.dom = dom;\n\n        /**\n         * @private\n         * @type {boolean}\n         */\n        this._touching = false;\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._touchTimer;\n\n        /**\n         * @private\n         * @type {module:zrender/core/GestureMgr}\n         */\n        this._gestureMgr = new GestureMgr();\n\n        this._handlers = {};\n\n        initDomHandler(this);\n\n        if (env.pointerEventsSupported) { // Only IE11+/Edge\n            // 1. On devices that both enable touch and mouse (e.g., MS Surface and lenovo X240),\n            // IE11+/Edge do not trigger touch event, but trigger pointer event and mouse event\n            // at the same time.\n            // 2. On MS Surface, it probablely only trigger mousedown but no mouseup when tap on\n            // screen, which do not occurs in pointer event.\n            // So we use pointer event to both detect touch gesture and mouse behavior.\n            mountHandlers(pointerHandlerNames, this);\n\n            // FIXME\n            // Note: MS Gesture require CSS touch-action set. But touch-action is not reliable,\n            // which does not prevent defuault behavior occasionally (which may cause view port\n            // zoomed in but use can not zoom it back). And event.preventDefault() does not work.\n            // So we have to not to use MSGesture and not to support touchmove and pinch on MS\n            // touch screen. And we only support click behavior on MS touch screen now.\n\n            // MS Gesture Event is only supported on IE11+/Edge and on Windows 8+.\n            // We dont support touch on IE on win7.\n            // See <https://msdn.microsoft.com/en-us/library/dn433243(v=vs.85).aspx>\n            // if (typeof MSGesture === 'function') {\n            //     (this._msGesture = new MSGesture()).target = dom; // jshint ignore:line\n            //     dom.addEventListener('MSGestureChange', onMSGestureChange);\n            // }\n        }\n        else {\n            if (env.touchEventsSupported) {\n                mountHandlers(touchHandlerNames, this);\n                // Handler of 'mouseout' event is needed in touch mode, which will be mounted below.\n                // addEventListener(root, 'mouseout', this._mouseoutHandler);\n            }\n\n            // 1. Considering some devices that both enable touch and mouse event (like on MS Surface\n            // and lenovo X240, @see #2350), we make mouse event be always listened, otherwise\n            // mouse event can not be handle in those devices.\n            // 2. On MS Surface, Chrome will trigger both touch event and mouse event. How to prevent\n            // mouseevent after touch event triggered, see `setTouchTimer`.\n            mountHandlers(mouseHandlerNames, this);\n        }\n\n        function mountHandlers(handlerNames, instance) {\n            zrUtil.each(handlerNames, function (name) {\n                addEventListener(dom, eventNameFix(name), instance._handlers[name]);\n            }, instance);\n        }\n    }\n\n    var handlerDomProxyProto = HandlerDomProxy.prototype;\n    handlerDomProxyProto.dispose = function () {\n        var handlerNames = mouseHandlerNames.concat(touchHandlerNames);\n\n        for (var i = 0; i < handlerNames.length; i++) {\n            var name = handlerNames[i];\n            removeEventListener(this.dom, eventNameFix(name), this._handlers[name]);\n        }\n    };\n\n    handlerDomProxyProto.setCursor = function (cursorStyle) {\n        this.dom.style.cursor = cursorStyle || 'default';\n    };\n\n    zrUtil.mixin(HandlerDomProxy, Eventful);\n\n    module.exports = HandlerDomProxy;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTEzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy9ob21lL3l4L34venJlbmRlci9saWIvZG9tL0hhbmRsZXJQcm94eS5qcz85YjkwIl0sInNvdXJjZXNDb250ZW50IjpbIlxuXG4gICAgdmFyIGV2ZW50VG9vbCA9IHJlcXVpcmUoJy4uL2NvcmUvZXZlbnQnKTtcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJyk7XG4gICAgdmFyIEV2ZW50ZnVsID0gcmVxdWlyZSgnLi4vbWl4aW4vRXZlbnRmdWwnKTtcbiAgICB2YXIgZW52ID0gcmVxdWlyZSgnLi4vY29yZS9lbnYnKTtcbiAgICB2YXIgR2VzdHVyZU1nciA9IHJlcXVpcmUoJy4uL2NvcmUvR2VzdHVyZU1ncicpO1xuXG4gICAgdmFyIGFkZEV2ZW50TGlzdGVuZXIgPSBldmVudFRvb2wuYWRkRXZlbnRMaXN0ZW5lcjtcbiAgICB2YXIgcmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGV2ZW50VG9vbC5yZW1vdmVFdmVudExpc3RlbmVyO1xuICAgIHZhciBub3JtYWxpemVFdmVudCA9IGV2ZW50VG9vbC5ub3JtYWxpemVFdmVudDtcblxuICAgIHZhciBUT1VDSF9DTElDS19ERUxBWSA9IDMwMDtcblxuICAgIHZhciBtb3VzZUhhbmRsZXJOYW1lcyA9IFtcbiAgICAgICAgJ2NsaWNrJywgJ2RibGNsaWNrJywgJ21vdXNld2hlZWwnLCAnbW91c2VvdXQnLFxuICAgICAgICAnbW91c2V1cCcsICdtb3VzZWRvd24nLCAnbW91c2Vtb3ZlJywgJ2NvbnRleHRtZW51J1xuICAgIF07XG5cbiAgICB2YXIgdG91Y2hIYW5kbGVyTmFtZXMgPSBbXG4gICAgICAgICd0b3VjaHN0YXJ0JywgJ3RvdWNoZW5kJywgJ3RvdWNobW92ZSdcbiAgICBdO1xuXG4gICAgdmFyIHBvaW50ZXJFdmVudE5hbWVzID0ge1xuICAgICAgICBwb2ludGVyZG93bjogMSwgcG9pbnRlcnVwOiAxLCBwb2ludGVybW92ZTogMSwgcG9pbnRlcm91dDogMVxuICAgIH07XG5cbiAgICB2YXIgcG9pbnRlckhhbmRsZXJOYW1lcyA9IHpyVXRpbC5tYXAobW91c2VIYW5kbGVyTmFtZXMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHZhciBubSA9IG5hbWUucmVwbGFjZSgnbW91c2UnLCAncG9pbnRlcicpO1xuICAgICAgICByZXR1cm4gcG9pbnRlckV2ZW50TmFtZXNbbm1dID8gbm0gOiBuYW1lO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gZXZlbnROYW1lRml4KG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIChuYW1lID09PSAnbW91c2V3aGVlbCcgJiYgZW52LmJyb3dzZXIuZmlyZWZveCkgPyAnRE9NTW91c2VTY3JvbGwnIDogbmFtZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcm9jZXNzR2VzdHVyZShwcm94eSwgZXZlbnQsIHN0YWdlKSB7XG4gICAgICAgIHZhciBnZXN0dXJlTWdyID0gcHJveHkuX2dlc3R1cmVNZ3I7XG5cbiAgICAgICAgc3RhZ2UgPT09ICdzdGFydCcgJiYgZ2VzdHVyZU1nci5jbGVhcigpO1xuXG4gICAgICAgIHZhciBnZXN0dXJlSW5mbyA9IGdlc3R1cmVNZ3IucmVjb2duaXplKFxuICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICBwcm94eS5oYW5kbGVyLmZpbmRIb3ZlcihldmVudC56clgsIGV2ZW50LnpyWSwgbnVsbCkudGFyZ2V0LFxuICAgICAgICAgICAgcHJveHkuZG9tXG4gICAgICAgICk7XG5cbiAgICAgICAgc3RhZ2UgPT09ICdlbmQnICYmIGdlc3R1cmVNZ3IuY2xlYXIoKTtcblxuICAgICAgICAvLyBEbyBub3QgZG8gYW55IHByZXZlbnREZWZhdWx0IGhlcmUuIFVwcGVyIGFwcGxpY2F0aW9uIGRvIHRoYXQgaWYgbmVjZXNzYXJ5LlxuICAgICAgICBpZiAoZ2VzdHVyZUluZm8pIHtcbiAgICAgICAgICAgIHZhciB0eXBlID0gZ2VzdHVyZUluZm8udHlwZTtcbiAgICAgICAgICAgIGV2ZW50Lmdlc3R1cmVFdmVudCA9IHR5cGU7XG5cbiAgICAgICAgICAgIHByb3h5LmhhbmRsZXIuZGlzcGF0Y2hUb0VsZW1lbnQoe3RhcmdldDogZ2VzdHVyZUluZm8udGFyZ2V0fSwgdHlwZSwgZ2VzdHVyZUluZm8uZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gZnVuY3Rpb24gb25NU0dlc3R1cmVDaGFuZ2UocHJveHksIGV2ZW50KSB7XG4gICAgLy8gICAgIGlmIChldmVudC50cmFuc2xhdGlvblggfHwgZXZlbnQudHJhbnNsYXRpb25ZKSB7XG4gICAgLy8gICAgICAgICAvLyBtb3VzZW1vdmUgaXMgY2FycmllZCBieSBNU0dlc3R1cmUgdG8gcmVkdWNlIHRoZSBzZW5zaXRpdml0eS5cbiAgICAvLyAgICAgICAgIHByb3h5LmhhbmRsZXIuZGlzcGF0Y2hUb0VsZW1lbnQoZXZlbnQudGFyZ2V0LCAnbW91c2Vtb3ZlJywgZXZlbnQpO1xuICAgIC8vICAgICB9XG4gICAgLy8gICAgIGlmIChldmVudC5zY2FsZSAhPT0gMSkge1xuICAgIC8vICAgICAgICAgZXZlbnQucGluY2hYID0gZXZlbnQub2Zmc2V0WDtcbiAgICAvLyAgICAgICAgIGV2ZW50LnBpbmNoWSA9IGV2ZW50Lm9mZnNldFk7XG4gICAgLy8gICAgICAgICBldmVudC5waW5jaFNjYWxlID0gZXZlbnQuc2NhbGU7XG4gICAgLy8gICAgICAgICBwcm94eS5oYW5kbGVyLmRpc3BhdGNoVG9FbGVtZW50KGV2ZW50LnRhcmdldCwgJ3BpbmNoJywgZXZlbnQpO1xuICAgIC8vICAgICB9XG4gICAgLy8gfVxuXG4gICAgLyoqXG4gICAgICogUHJldmVudCBtb3VzZSBldmVudCBmcm9tIGJlaW5nIGRpc3BhdGNoZWQgYWZ0ZXIgVG91Y2ggRXZlbnRzIGFjdGlvblxuICAgICAqIEBzZWUgPGh0dHBzOi8vZ2l0aHViLmNvbS9kZWx0YWtvc2gvaGFuZGpzL2Jsb2IvbWFzdGVyL3NyYy9oYW5kLmJhc2UuanM+XG4gICAgICogMS4gTW9iaWxlIGJyb3dzZXJzIGRpc3BhdGNoIG1vdXNlIGV2ZW50cyAzMDBtcyBhZnRlciB0b3VjaGVuZC5cbiAgICAgKiAyLiBDaHJvbWUgZm9yIEFuZHJvaWQgZGlzcGF0Y2ggbW91c2Vkb3duIGZvciBsb25nLXRvdWNoIGFib3V0IDY1MG1zXG4gICAgICogUmVzdWx0OiBCbG9ja2luZyBNb3VzZSBFdmVudHMgZm9yIDcwMG1zLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldFRvdWNoVGltZXIoaW5zdGFuY2UpIHtcbiAgICAgICAgaW5zdGFuY2UuX3RvdWNoaW5nID0gdHJ1ZTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGluc3RhbmNlLl90b3VjaFRpbWVyKTtcbiAgICAgICAgaW5zdGFuY2UuX3RvdWNoVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGluc3RhbmNlLl90b3VjaGluZyA9IGZhbHNlO1xuICAgICAgICB9LCA3MDApO1xuICAgIH1cblxuXG4gICAgdmFyIGRvbUhhbmRsZXJzID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogTW91c2UgbW92ZSBoYW5kbGVyXG4gICAgICAgICAqIEBpbm5lclxuICAgICAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgICAgICAgKi9cbiAgICAgICAgbW91c2Vtb3ZlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQodGhpcy5kb20sIGV2ZW50KTtcblxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdtb3VzZW1vdmUnLCBldmVudCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1vdXNlIG91dCBoYW5kbGVyXG4gICAgICAgICAqIEBpbm5lclxuICAgICAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgICAgICAgKi9cbiAgICAgICAgbW91c2VvdXQ6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgZXZlbnQgPSBub3JtYWxpemVFdmVudCh0aGlzLmRvbSwgZXZlbnQpO1xuXG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IGV2ZW50LnRvRWxlbWVudCB8fCBldmVudC5yZWxhdGVkVGFyZ2V0O1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQgIT0gdGhpcy5kb20pIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoZWxlbWVudCAmJiBlbGVtZW50Lm5vZGVUeXBlICE9IDkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8g5b+955Wl5YyF5ZCr5Zyocm9vdOS4reeahGRvbeW8lei1t+eahG1vdXNlT3V0XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50ID09PSB0aGlzLmRvbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcignbW91c2VvdXQnLCBldmVudCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRvdWNo5byA5aeL5ZON5bqU5Ye95pWwXG4gICAgICAgICAqIEBpbm5lclxuICAgICAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgICAgICAgKi9cbiAgICAgICAgdG91Y2hzdGFydDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAvLyBEZWZhdWx0IG1vdXNlIGJlaGF2aW91ciBzaG91bGQgbm90IGJlIGRpc2FibGVkIGhlcmUuXG4gICAgICAgICAgICAvLyBGb3IgZXhhbXBsZSwgcGFnZSBtYXkgbmVlZHMgdG8gYmUgc2xpZGVkLlxuICAgICAgICAgICAgZXZlbnQgPSBub3JtYWxpemVFdmVudCh0aGlzLmRvbSwgZXZlbnQpO1xuXG4gICAgICAgICAgICAvLyBNYXJrIHRvdWNoLCB3aGljaCBpcyB1c2VmdWwgaW4gZGlzdGluZ3Vpc2ggdG91Y2ggYW5kXG4gICAgICAgICAgICAvLyBtb3VzZSBldmVudCBpbiB1cHBlciBhcHBsaWNhdG9pbi5cbiAgICAgICAgICAgIGV2ZW50LnpyQnlUb3VjaCA9IHRydWU7XG5cbiAgICAgICAgICAgIHRoaXMuX2xhc3RUb3VjaE1vbWVudCA9IG5ldyBEYXRlKCk7XG5cbiAgICAgICAgICAgIHByb2Nlc3NHZXN0dXJlKHRoaXMsIGV2ZW50LCAnc3RhcnQnKTtcblxuICAgICAgICAgICAgLy8gSW4gdG91Y2ggZGV2aWNlLCB0cmlnZ2VyIGBtb3VzZW1vdmVgKGBtb3VzZW92ZXJgKSBzaG91bGRcbiAgICAgICAgICAgIC8vIGJlIHRyaWdnZXJlZCwgYW5kIG11c3QgYmVmb3JlIGBtb3VzZWRvd25gIHRyaWdnZXJlZC5cbiAgICAgICAgICAgIGRvbUhhbmRsZXJzLm1vdXNlbW92ZS5jYWxsKHRoaXMsIGV2ZW50KTtcblxuICAgICAgICAgICAgZG9tSGFuZGxlcnMubW91c2Vkb3duLmNhbGwodGhpcywgZXZlbnQpO1xuXG4gICAgICAgICAgICBzZXRUb3VjaFRpbWVyKHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUb3VjaOenu+WKqOWTjeW6lOWHveaVsFxuICAgICAgICAgKiBAaW5uZXJcbiAgICAgICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICAgICAgICovXG4gICAgICAgIHRvdWNobW92ZTogZnVuY3Rpb24gKGV2ZW50KSB7XG5cbiAgICAgICAgICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQodGhpcy5kb20sIGV2ZW50KTtcblxuICAgICAgICAgICAgLy8gTWFyayB0b3VjaCwgd2hpY2ggaXMgdXNlZnVsIGluIGRpc3Rpbmd1aXNoIHRvdWNoIGFuZFxuICAgICAgICAgICAgLy8gbW91c2UgZXZlbnQgaW4gdXBwZXIgYXBwbGljYXRvaW4uXG4gICAgICAgICAgICBldmVudC56ckJ5VG91Y2ggPSB0cnVlO1xuXG4gICAgICAgICAgICBwcm9jZXNzR2VzdHVyZSh0aGlzLCBldmVudCwgJ2NoYW5nZScpO1xuXG4gICAgICAgICAgICAvLyBNb3VzZSBtb3ZlIHNob3VsZCBhbHdheXMgYmUgdHJpZ2dlcmVkIG5vIG1hdHRlciB3aGV0aGVyXG4gICAgICAgICAgICAvLyB0aGVyZSBpcyBnZXN0cnVlIGV2ZW50LCBiZWNhdXNlIG1vdXNlIG1vdmUgYW5kIHBpbmNoIG1heVxuICAgICAgICAgICAgLy8gYmUgdXNlZCBhdCB0aGUgc2FtZSB0aW1lLlxuICAgICAgICAgICAgZG9tSGFuZGxlcnMubW91c2Vtb3ZlLmNhbGwodGhpcywgZXZlbnQpO1xuXG4gICAgICAgICAgICBzZXRUb3VjaFRpbWVyKHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUb3VjaOe7k+adn+WTjeW6lOWHveaVsFxuICAgICAgICAgKiBAaW5uZXJcbiAgICAgICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICAgICAgICovXG4gICAgICAgIHRvdWNoZW5kOiBmdW5jdGlvbiAoZXZlbnQpIHtcblxuICAgICAgICAgICAgZXZlbnQgPSBub3JtYWxpemVFdmVudCh0aGlzLmRvbSwgZXZlbnQpO1xuXG4gICAgICAgICAgICAvLyBNYXJrIHRvdWNoLCB3aGljaCBpcyB1c2VmdWwgaW4gZGlzdGluZ3Vpc2ggdG91Y2ggYW5kXG4gICAgICAgICAgICAvLyBtb3VzZSBldmVudCBpbiB1cHBlciBhcHBsaWNhdG9pbi5cbiAgICAgICAgICAgIGV2ZW50LnpyQnlUb3VjaCA9IHRydWU7XG5cbiAgICAgICAgICAgIHByb2Nlc3NHZXN0dXJlKHRoaXMsIGV2ZW50LCAnZW5kJyk7XG5cbiAgICAgICAgICAgIGRvbUhhbmRsZXJzLm1vdXNldXAuY2FsbCh0aGlzLCBldmVudCk7XG5cbiAgICAgICAgICAgIC8vIERvIG5vdCB0cmlnZ2VyIGBtb3VzZW91dGAgaGVyZSwgaW4gc3BpdGUgb2YgYG1vdXNlbW92ZWAoYG1vdXNlb3ZlcmApIGlzXG4gICAgICAgICAgICAvLyB0cmlnZ2VyZWQgaW4gYHRvdWNoc3RhcnRgLiBUaGlzIHNlZW1zIHRvIGJlIGlsbG9naWNhbCwgYnV0IGJ5IHRoaXMgbWVjaGFuaXNtLFxuICAgICAgICAgICAgLy8gd2UgY2FuIGNvbnZlbmllbnRseSBpbXBsZW1lbnQgXCJob3ZlciBzdHlsZVwiIGluIGJvdGggUEMgYW5kIHRvdWNoIGRldmljZSBqdXN0XG4gICAgICAgICAgICAvLyBieSBsaXN0ZW5pbmcgdG8gYG1vdXNlb3ZlcmAgdG8gYWRkIFwiaG92ZXIgc3R5bGVcIiBhbmQgbGlzdGVuaW5nIHRvIGBtb3VzZW91dGBcbiAgICAgICAgICAgIC8vIHRvIHJlbW92ZSBcImhvdmVyIHN0eWxlXCIgb24gYW4gZWxlbWVudCwgd2l0aG91dCBhbnkgYWRkaXRpb25hbCBjb2RlIGZvclxuICAgICAgICAgICAgLy8gY29tcGF0aWJpbGl0eS4gKGBtb3VzZW91dGAgd2lsbCBub3QgYmUgdHJpZ2dlcmVkIGluIGB0b3VjaGVuZGAsIHNvIFwiaG92ZXJcbiAgICAgICAgICAgIC8vIHN0eWxlXCIgd2lsbCByZW1haW4gZm9yIHVzZXIgdmlldylcblxuICAgICAgICAgICAgLy8gY2xpY2sgZXZlbnQgc2hvdWxkIGFsd2F5cyBiZSB0cmlnZ2VyZWQgbm8gbWF0dGVyIHdoZXRoZXJcbiAgICAgICAgICAgIC8vIHRoZXJlIGlzIGdlc3RydWUgZXZlbnQuIFN5c3RlbSBjbGljayBjYW4gbm90IGJlIHByZXZlbnRlZC5cbiAgICAgICAgICAgIGlmICgrbmV3IERhdGUoKSAtIHRoaXMuX2xhc3RUb3VjaE1vbWVudCA8IFRPVUNIX0NMSUNLX0RFTEFZKSB7XG4gICAgICAgICAgICAgICAgZG9tSGFuZGxlcnMuY2xpY2suY2FsbCh0aGlzLCBldmVudCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNldFRvdWNoVGltZXIodGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcG9pbnRlcmRvd246IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgZG9tSGFuZGxlcnMubW91c2Vkb3duLmNhbGwodGhpcywgZXZlbnQpO1xuXG4gICAgICAgICAgICAvLyBpZiAodXNlTVNHdWVzdHVyZSh0aGlzLCBldmVudCkpIHtcbiAgICAgICAgICAgIC8vICAgICB0aGlzLl9tc0dlc3R1cmUuYWRkUG9pbnRlcihldmVudC5wb2ludGVySWQpO1xuICAgICAgICAgICAgLy8gfVxuICAgICAgICB9LFxuXG4gICAgICAgIHBvaW50ZXJtb3ZlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIC8vIEZJWE1FXG4gICAgICAgICAgICAvLyBwb2ludGVybW92ZSBpcyBzbyBzZW5zaXRpdmUgdGhhdCBpdCBhbHdheXMgdHJpZ2dlcmVkIHdoZW5cbiAgICAgICAgICAgIC8vIHRhcChjbGljaykgb24gdG91Y2ggc2NyZWVuLCB3aGljaCBhZmZlY3Qgc29tZSBqdWRnZW1lbnQgaW5cbiAgICAgICAgICAgIC8vIHVwcGVyIGFwcGxpY2F0aW9uLiBTbywgd2UgZG9udCBzdXBwb3J0IG1vdXNlbW92ZSBvbiBNUyB0b3VjaFxuICAgICAgICAgICAgLy8gZGV2aWNlIHlldC5cbiAgICAgICAgICAgIGlmICghaXNQb2ludGVyRnJvbVRvdWNoKGV2ZW50KSkge1xuICAgICAgICAgICAgICAgIGRvbUhhbmRsZXJzLm1vdXNlbW92ZS5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBwb2ludGVydXA6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgZG9tSGFuZGxlcnMubW91c2V1cC5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICAgICAgfSxcblxuICAgICAgICBwb2ludGVyb3V0OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIC8vIHBvaW50ZXJvdXQgd2lsbCBiZSB0cmlnZ2VyZWQgd2hlbiB0YXAgb24gdG91Y2ggc2NyZWVuXG4gICAgICAgICAgICAvLyAoSUUxMSsvRWRnZSBvbiBNUyBTdXJmYWNlKSBhZnRlciBjbGljayBldmVudCB0cmlnZ2VyZWQsXG4gICAgICAgICAgICAvLyB3aGljaCBpcyBpbmNvbnNpc3RlbnQgd2l0aCB0aGUgbW91c291dCBiZWhhdmlvciB3ZSBkZWZpbmVkXG4gICAgICAgICAgICAvLyBpbiB0b3VjaGVuZC4gU28gd2UgdW5pZnkgdGhlbS5cbiAgICAgICAgICAgIC8vIChjaGVjayBkb21IYW5kbGVycy50b3VjaGVuZCBmb3IgZGV0YWlsZWQgZXhwbGFuYXRpb24pXG4gICAgICAgICAgICBpZiAoIWlzUG9pbnRlckZyb21Ub3VjaChldmVudCkpIHtcbiAgICAgICAgICAgICAgICBkb21IYW5kbGVycy5tb3VzZW91dC5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBpc1BvaW50ZXJGcm9tVG91Y2goZXZlbnQpIHtcbiAgICAgICAgdmFyIHBvaW50ZXJUeXBlID0gZXZlbnQucG9pbnRlclR5cGU7XG4gICAgICAgIHJldHVybiBwb2ludGVyVHlwZSA9PT0gJ3BlbicgfHwgcG9pbnRlclR5cGUgPT09ICd0b3VjaCc7XG4gICAgfVxuXG4gICAgLy8gZnVuY3Rpb24gdXNlTVNHdWVzdHVyZShoYW5kbGVyUHJveHksIGV2ZW50KSB7XG4gICAgLy8gICAgIHJldHVybiBpc1BvaW50ZXJGcm9tVG91Y2goZXZlbnQpICYmICEhaGFuZGxlclByb3h5Ll9tc0dlc3R1cmU7XG4gICAgLy8gfVxuXG4gICAgLy8gQ29tbW9uIGhhbmRsZXJzXG4gICAgenJVdGlsLmVhY2goWydjbGljaycsICdtb3VzZWRvd24nLCAnbW91c2V1cCcsICdtb3VzZXdoZWVsJywgJ2RibGNsaWNrJywgJ2NvbnRleHRtZW51J10sIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIGRvbUhhbmRsZXJzW25hbWVdID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KHRoaXMuZG9tLCBldmVudCk7XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIobmFtZSwgZXZlbnQpO1xuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICog5Li65o6n5Yi257G75a6e5L6L5Yid5aeL5YyWZG9tIOS6i+S7tuWkhOeQhuWHveaVsFxuICAgICAqXG4gICAgICogQGlubmVyXG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9IYW5kbGVyfSBpbnN0YW5jZSDmjqfliLbnsbvlrp7kvotcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbml0RG9tSGFuZGxlcihpbnN0YW5jZSkge1xuICAgICAgICB6clV0aWwuZWFjaCh0b3VjaEhhbmRsZXJOYW1lcywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIGluc3RhbmNlLl9oYW5kbGVyc1tuYW1lXSA9IHpyVXRpbC5iaW5kKGRvbUhhbmRsZXJzW25hbWVdLCBpbnN0YW5jZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHpyVXRpbC5lYWNoKHBvaW50ZXJIYW5kbGVyTmFtZXMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5faGFuZGxlcnNbbmFtZV0gPSB6clV0aWwuYmluZChkb21IYW5kbGVyc1tuYW1lXSwgaW5zdGFuY2UpO1xuICAgICAgICB9KTtcblxuICAgICAgICB6clV0aWwuZWFjaChtb3VzZUhhbmRsZXJOYW1lcywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIGluc3RhbmNlLl9oYW5kbGVyc1tuYW1lXSA9IG1ha2VNb3VzZUhhbmRsZXIoZG9tSGFuZGxlcnNbbmFtZV0sIGluc3RhbmNlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZnVuY3Rpb24gbWFrZU1vdXNlSGFuZGxlcihmbiwgaW5zdGFuY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLl90b3VjaGluZykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmbi5hcHBseShpbnN0YW5jZSwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIEhhbmRsZXJEb21Qcm94eShkb20pIHtcbiAgICAgICAgRXZlbnRmdWwuY2FsbCh0aGlzKTtcblxuICAgICAgICB0aGlzLmRvbSA9IGRvbTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl90b3VjaGluZyA9IGZhbHNlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fdG91Y2hUaW1lcjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2NvcmUvR2VzdHVyZU1ncn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2dlc3R1cmVNZ3IgPSBuZXcgR2VzdHVyZU1ncigpO1xuXG4gICAgICAgIHRoaXMuX2hhbmRsZXJzID0ge307XG5cbiAgICAgICAgaW5pdERvbUhhbmRsZXIodGhpcyk7XG5cbiAgICAgICAgaWYgKGVudi5wb2ludGVyRXZlbnRzU3VwcG9ydGVkKSB7IC8vIE9ubHkgSUUxMSsvRWRnZVxuICAgICAgICAgICAgLy8gMS4gT24gZGV2aWNlcyB0aGF0IGJvdGggZW5hYmxlIHRvdWNoIGFuZCBtb3VzZSAoZS5nLiwgTVMgU3VyZmFjZSBhbmQgbGVub3ZvIFgyNDApLFxuICAgICAgICAgICAgLy8gSUUxMSsvRWRnZSBkbyBub3QgdHJpZ2dlciB0b3VjaCBldmVudCwgYnV0IHRyaWdnZXIgcG9pbnRlciBldmVudCBhbmQgbW91c2UgZXZlbnRcbiAgICAgICAgICAgIC8vIGF0IHRoZSBzYW1lIHRpbWUuXG4gICAgICAgICAgICAvLyAyLiBPbiBNUyBTdXJmYWNlLCBpdCBwcm9iYWJsZWx5IG9ubHkgdHJpZ2dlciBtb3VzZWRvd24gYnV0IG5vIG1vdXNldXAgd2hlbiB0YXAgb25cbiAgICAgICAgICAgIC8vIHNjcmVlbiwgd2hpY2ggZG8gbm90IG9jY3VycyBpbiBwb2ludGVyIGV2ZW50LlxuICAgICAgICAgICAgLy8gU28gd2UgdXNlIHBvaW50ZXIgZXZlbnQgdG8gYm90aCBkZXRlY3QgdG91Y2ggZ2VzdHVyZSBhbmQgbW91c2UgYmVoYXZpb3IuXG4gICAgICAgICAgICBtb3VudEhhbmRsZXJzKHBvaW50ZXJIYW5kbGVyTmFtZXMsIHRoaXMpO1xuXG4gICAgICAgICAgICAvLyBGSVhNRVxuICAgICAgICAgICAgLy8gTm90ZTogTVMgR2VzdHVyZSByZXF1aXJlIENTUyB0b3VjaC1hY3Rpb24gc2V0LiBCdXQgdG91Y2gtYWN0aW9uIGlzIG5vdCByZWxpYWJsZSxcbiAgICAgICAgICAgIC8vIHdoaWNoIGRvZXMgbm90IHByZXZlbnQgZGVmdWF1bHQgYmVoYXZpb3Igb2NjYXNpb25hbGx5ICh3aGljaCBtYXkgY2F1c2UgdmlldyBwb3J0XG4gICAgICAgICAgICAvLyB6b29tZWQgaW4gYnV0IHVzZSBjYW4gbm90IHpvb20gaXQgYmFjaykuIEFuZCBldmVudC5wcmV2ZW50RGVmYXVsdCgpIGRvZXMgbm90IHdvcmsuXG4gICAgICAgICAgICAvLyBTbyB3ZSBoYXZlIHRvIG5vdCB0byB1c2UgTVNHZXN0dXJlIGFuZCBub3QgdG8gc3VwcG9ydCB0b3VjaG1vdmUgYW5kIHBpbmNoIG9uIE1TXG4gICAgICAgICAgICAvLyB0b3VjaCBzY3JlZW4uIEFuZCB3ZSBvbmx5IHN1cHBvcnQgY2xpY2sgYmVoYXZpb3Igb24gTVMgdG91Y2ggc2NyZWVuIG5vdy5cblxuICAgICAgICAgICAgLy8gTVMgR2VzdHVyZSBFdmVudCBpcyBvbmx5IHN1cHBvcnRlZCBvbiBJRTExKy9FZGdlIGFuZCBvbiBXaW5kb3dzIDgrLlxuICAgICAgICAgICAgLy8gV2UgZG9udCBzdXBwb3J0IHRvdWNoIG9uIElFIG9uIHdpbjcuXG4gICAgICAgICAgICAvLyBTZWUgPGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvZG40MzMyNDModj12cy44NSkuYXNweD5cbiAgICAgICAgICAgIC8vIGlmICh0eXBlb2YgTVNHZXN0dXJlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyAgICAgKHRoaXMuX21zR2VzdHVyZSA9IG5ldyBNU0dlc3R1cmUoKSkudGFyZ2V0ID0gZG9tOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICAgICAgICAgIC8vICAgICBkb20uYWRkRXZlbnRMaXN0ZW5lcignTVNHZXN0dXJlQ2hhbmdlJywgb25NU0dlc3R1cmVDaGFuZ2UpO1xuICAgICAgICAgICAgLy8gfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGVudi50b3VjaEV2ZW50c1N1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgIG1vdW50SGFuZGxlcnModG91Y2hIYW5kbGVyTmFtZXMsIHRoaXMpO1xuICAgICAgICAgICAgICAgIC8vIEhhbmRsZXIgb2YgJ21vdXNlb3V0JyBldmVudCBpcyBuZWVkZWQgaW4gdG91Y2ggbW9kZSwgd2hpY2ggd2lsbCBiZSBtb3VudGVkIGJlbG93LlxuICAgICAgICAgICAgICAgIC8vIGFkZEV2ZW50TGlzdGVuZXIocm9vdCwgJ21vdXNlb3V0JywgdGhpcy5fbW91c2VvdXRIYW5kbGVyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gMS4gQ29uc2lkZXJpbmcgc29tZSBkZXZpY2VzIHRoYXQgYm90aCBlbmFibGUgdG91Y2ggYW5kIG1vdXNlIGV2ZW50IChsaWtlIG9uIE1TIFN1cmZhY2VcbiAgICAgICAgICAgIC8vIGFuZCBsZW5vdm8gWDI0MCwgQHNlZSAjMjM1MCksIHdlIG1ha2UgbW91c2UgZXZlbnQgYmUgYWx3YXlzIGxpc3RlbmVkLCBvdGhlcndpc2VcbiAgICAgICAgICAgIC8vIG1vdXNlIGV2ZW50IGNhbiBub3QgYmUgaGFuZGxlIGluIHRob3NlIGRldmljZXMuXG4gICAgICAgICAgICAvLyAyLiBPbiBNUyBTdXJmYWNlLCBDaHJvbWUgd2lsbCB0cmlnZ2VyIGJvdGggdG91Y2ggZXZlbnQgYW5kIG1vdXNlIGV2ZW50LiBIb3cgdG8gcHJldmVudFxuICAgICAgICAgICAgLy8gbW91c2VldmVudCBhZnRlciB0b3VjaCBldmVudCB0cmlnZ2VyZWQsIHNlZSBgc2V0VG91Y2hUaW1lcmAuXG4gICAgICAgICAgICBtb3VudEhhbmRsZXJzKG1vdXNlSGFuZGxlck5hbWVzLCB0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG1vdW50SGFuZGxlcnMoaGFuZGxlck5hbWVzLCBpbnN0YW5jZSkge1xuICAgICAgICAgICAgenJVdGlsLmVhY2goaGFuZGxlck5hbWVzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoZG9tLCBldmVudE5hbWVGaXgobmFtZSksIGluc3RhbmNlLl9oYW5kbGVyc1tuYW1lXSk7XG4gICAgICAgICAgICB9LCBpbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgaGFuZGxlckRvbVByb3h5UHJvdG8gPSBIYW5kbGVyRG9tUHJveHkucHJvdG90eXBlO1xuICAgIGhhbmRsZXJEb21Qcm94eVByb3RvLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBoYW5kbGVyTmFtZXMgPSBtb3VzZUhhbmRsZXJOYW1lcy5jb25jYXQodG91Y2hIYW5kbGVyTmFtZXMpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGFuZGxlck5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IGhhbmRsZXJOYW1lc1tpXTtcbiAgICAgICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcy5kb20sIGV2ZW50TmFtZUZpeChuYW1lKSwgdGhpcy5faGFuZGxlcnNbbmFtZV0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGhhbmRsZXJEb21Qcm94eVByb3RvLnNldEN1cnNvciA9IGZ1bmN0aW9uIChjdXJzb3JTdHlsZSkge1xuICAgICAgICB0aGlzLmRvbS5zdHlsZS5jdXJzb3IgPSBjdXJzb3JTdHlsZSB8fCAnZGVmYXVsdCc7XG4gICAgfTtcblxuICAgIHpyVXRpbC5taXhpbihIYW5kbGVyRG9tUHJveHksIEV2ZW50ZnVsKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gSGFuZGxlckRvbVByb3h5O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2hvbWUveXgvfi96cmVuZGVyL2xpYi9kb20vSGFuZGxlclByb3h5LmpzXG4vLyBtb2R1bGUgaWQgPSAxMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 114 */
/* unknown exports provided */
/* all exports used */
/*!******************************************************!*\
  !*** /home/yx/~/zrender/lib/graphic/CompoundPath.js ***!
  \******************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("// CompoundPath to improve performance\n\n\n    var Path = __webpack_require__(/*! ./Path */ 7);\n\n    module.exports = Path.extend({\n\n        type: 'compound',\n\n        shape: {\n\n            paths: null\n        },\n\n        _updatePathDirty: function () {\n            var dirtyPath = this.__dirtyPath;\n            var paths = this.shape.paths;\n            for (var i = 0; i < paths.length; i++) {\n                // Mark as dirty if any subpath is dirty\n                dirtyPath = dirtyPath || paths[i].__dirtyPath;\n            }\n            this.__dirtyPath = dirtyPath;\n            this.__dirty = this.__dirty || dirtyPath;\n        },\n\n        beforeBrush: function () {\n            this._updatePathDirty();\n            var paths = this.shape.paths || [];\n            var scale = this.getGlobalScale();\n            // Update path scale\n            for (var i = 0; i < paths.length; i++) {\n                if (!paths[i].path) {\n                    paths[i].createPathProxy();\n                }\n                paths[i].path.setScale(scale[0], scale[1]);\n            }\n        },\n\n        buildPath: function (ctx, shape) {\n            var paths = shape.paths || [];\n            for (var i = 0; i < paths.length; i++) {\n                paths[i].buildPath(ctx, paths[i].shape, true);\n            }\n        },\n\n        afterBrush: function () {\n            var paths = this.shape.paths;\n            for (var i = 0; i < paths.length; i++) {\n                paths[i].__dirtyPath = false;\n            }\n        },\n\n        getBoundingRect: function () {\n            this._updatePathDirty();\n            return Path.prototype.getBoundingRect.call(this);\n        }\n    });\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTE0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy9ob21lL3l4L34venJlbmRlci9saWIvZ3JhcGhpYy9Db21wb3VuZFBhdGguanM/YjliMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb21wb3VuZFBhdGggdG8gaW1wcm92ZSBwZXJmb3JtYW5jZVxuXG5cbiAgICB2YXIgUGF0aCA9IHJlcXVpcmUoJy4vUGF0aCcpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBQYXRoLmV4dGVuZCh7XG5cbiAgICAgICAgdHlwZTogJ2NvbXBvdW5kJyxcblxuICAgICAgICBzaGFwZToge1xuXG4gICAgICAgICAgICBwYXRoczogbnVsbFxuICAgICAgICB9LFxuXG4gICAgICAgIF91cGRhdGVQYXRoRGlydHk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBkaXJ0eVBhdGggPSB0aGlzLl9fZGlydHlQYXRoO1xuICAgICAgICAgICAgdmFyIHBhdGhzID0gdGhpcy5zaGFwZS5wYXRocztcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAvLyBNYXJrIGFzIGRpcnR5IGlmIGFueSBzdWJwYXRoIGlzIGRpcnR5XG4gICAgICAgICAgICAgICAgZGlydHlQYXRoID0gZGlydHlQYXRoIHx8IHBhdGhzW2ldLl9fZGlydHlQYXRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fX2RpcnR5UGF0aCA9IGRpcnR5UGF0aDtcbiAgICAgICAgICAgIHRoaXMuX19kaXJ0eSA9IHRoaXMuX19kaXJ0eSB8fCBkaXJ0eVBhdGg7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYmVmb3JlQnJ1c2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVBhdGhEaXJ0eSgpO1xuICAgICAgICAgICAgdmFyIHBhdGhzID0gdGhpcy5zaGFwZS5wYXRocyB8fCBbXTtcbiAgICAgICAgICAgIHZhciBzY2FsZSA9IHRoaXMuZ2V0R2xvYmFsU2NhbGUoKTtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBwYXRoIHNjYWxlXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFwYXRoc1tpXS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGhzW2ldLmNyZWF0ZVBhdGhQcm94eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXRoc1tpXS5wYXRoLnNldFNjYWxlKHNjYWxlWzBdLCBzY2FsZVsxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xuICAgICAgICAgICAgdmFyIHBhdGhzID0gc2hhcGUucGF0aHMgfHwgW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcGF0aHNbaV0uYnVpbGRQYXRoKGN0eCwgcGF0aHNbaV0uc2hhcGUsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGFmdGVyQnJ1c2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBwYXRocyA9IHRoaXMuc2hhcGUucGF0aHM7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcGF0aHNbaV0uX19kaXJ0eVBhdGggPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBnZXRCb3VuZGluZ1JlY3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVBhdGhEaXJ0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIFBhdGgucHJvdG90eXBlLmdldEJvdW5kaW5nUmVjdC5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgfSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS95eC9+L3pyZW5kZXIvbGliL2dyYXBoaWMvQ29tcG91bmRQYXRoLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 115 */
/* unknown exports provided */
/* all exports used */
/*!********************************************************!*\
  !*** /home/yx/~/zrender/lib/graphic/RadialGradient.js ***!
  \********************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\n    var zrUtil = __webpack_require__(/*! ../core/util */ 0);\n\n    var Gradient = __webpack_require__(/*! ./Gradient */ 37);\n\n    /**\n     * x, y, r are all percent from 0 to 1\n     * @param {number} [x=0.5]\n     * @param {number} [y=0.5]\n     * @param {number} [r=0.5]\n     * @param {Array.<Object>} [colorStops]\n     * @param {boolean} [globalCoord=false]\n     */\n    var RadialGradient = function (x, y, r, colorStops, globalCoord) {\n        // Should do nothing more in this constructor. Because gradient can be\n        // declard by `color: {type: 'radial', colorStops: ...}`, where\n        // this constructor will not be called.\n\n        this.x = x == null ? 0.5 : x;\n\n        this.y = y == null ? 0.5 : y;\n\n        this.r = r == null ? 0.5 : r;\n\n        // Can be cloned\n        this.type = 'radial';\n\n        // If use global coord\n        this.global = globalCoord || false;\n\n        Gradient.call(this, colorStops);\n    };\n\n    RadialGradient.prototype = {\n\n        constructor: RadialGradient\n    };\n\n    zrUtil.inherits(RadialGradient, Gradient);\n\n    module.exports = RadialGradient;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTE1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy9ob21lL3l4L34venJlbmRlci9saWIvZ3JhcGhpYy9SYWRpYWxHcmFkaWVudC5qcz80Y2QyIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpO1xuXG4gICAgdmFyIEdyYWRpZW50ID0gcmVxdWlyZSgnLi9HcmFkaWVudCcpO1xuXG4gICAgLyoqXG4gICAgICogeCwgeSwgciBhcmUgYWxsIHBlcmNlbnQgZnJvbSAwIHRvIDFcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3g9MC41XVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbeT0wLjVdXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtyPTAuNV1cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxPYmplY3Q+fSBbY29sb3JTdG9wc11cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtnbG9iYWxDb29yZD1mYWxzZV1cbiAgICAgKi9cbiAgICB2YXIgUmFkaWFsR3JhZGllbnQgPSBmdW5jdGlvbiAoeCwgeSwgciwgY29sb3JTdG9wcywgZ2xvYmFsQ29vcmQpIHtcbiAgICAgICAgLy8gU2hvdWxkIGRvIG5vdGhpbmcgbW9yZSBpbiB0aGlzIGNvbnN0cnVjdG9yLiBCZWNhdXNlIGdyYWRpZW50IGNhbiBiZVxuICAgICAgICAvLyBkZWNsYXJkIGJ5IGBjb2xvcjoge3R5cGU6ICdyYWRpYWwnLCBjb2xvclN0b3BzOiAuLi59YCwgd2hlcmVcbiAgICAgICAgLy8gdGhpcyBjb25zdHJ1Y3RvciB3aWxsIG5vdCBiZSBjYWxsZWQuXG5cbiAgICAgICAgdGhpcy54ID0geCA9PSBudWxsID8gMC41IDogeDtcblxuICAgICAgICB0aGlzLnkgPSB5ID09IG51bGwgPyAwLjUgOiB5O1xuXG4gICAgICAgIHRoaXMuciA9IHIgPT0gbnVsbCA/IDAuNSA6IHI7XG5cbiAgICAgICAgLy8gQ2FuIGJlIGNsb25lZFxuICAgICAgICB0aGlzLnR5cGUgPSAncmFkaWFsJztcblxuICAgICAgICAvLyBJZiB1c2UgZ2xvYmFsIGNvb3JkXG4gICAgICAgIHRoaXMuZ2xvYmFsID0gZ2xvYmFsQ29vcmQgfHwgZmFsc2U7XG5cbiAgICAgICAgR3JhZGllbnQuY2FsbCh0aGlzLCBjb2xvclN0b3BzKTtcbiAgICB9O1xuXG4gICAgUmFkaWFsR3JhZGllbnQucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBSYWRpYWxHcmFkaWVudFxuICAgIH07XG5cbiAgICB6clV0aWwuaW5oZXJpdHMoUmFkaWFsR3JhZGllbnQsIEdyYWRpZW50KTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gUmFkaWFsR3JhZGllbnQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS95eC9+L3pyZW5kZXIvbGliL2dyYXBoaWMvUmFkaWFsR3JhZGllbnQuanNcbi8vIG1vZHVsZSBpZCA9IDExNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 116 */
/* unknown exports provided */
/* all exports used */
/*!**********************************************************!*\
  !*** /home/yx/~/zrender/lib/graphic/helper/roundRect.js ***!
  \**********************************************************/
/***/ (function(module, exports) {

eval("\n\n    module.exports = {\n        buildPath: function (ctx, shape) {\n            var x = shape.x;\n            var y = shape.y;\n            var width = shape.width;\n            var height = shape.height;\n            var r = shape.r;\n            var r1;\n            var r2;\n            var r3;\n            var r4;\n\n            // Convert width and height to positive for better borderRadius\n            if (width < 0) {\n                x = x + width;\n                width = -width;\n            }\n            if (height < 0) {\n                y = y + height;\n                height = -height;\n            }\n\n            if (typeof r === 'number') {\n                r1 = r2 = r3 = r4 = r;\n            }\n            else if (r instanceof Array) {\n                if (r.length === 1) {\n                    r1 = r2 = r3 = r4 = r[0];\n                }\n                else if (r.length === 2) {\n                    r1 = r3 = r[0];\n                    r2 = r4 = r[1];\n                }\n                else if (r.length === 3) {\n                    r1 = r[0];\n                    r2 = r4 = r[1];\n                    r3 = r[2];\n                }\n                else {\n                    r1 = r[0];\n                    r2 = r[1];\n                    r3 = r[2];\n                    r4 = r[3];\n                }\n            }\n            else {\n                r1 = r2 = r3 = r4 = 0;\n            }\n\n            var total;\n            if (r1 + r2 > width) {\n                total = r1 + r2;\n                r1 *= width / total;\n                r2 *= width / total;\n            }\n            if (r3 + r4 > width) {\n                total = r3 + r4;\n                r3 *= width / total;\n                r4 *= width / total;\n            }\n            if (r2 + r3 > height) {\n                total = r2 + r3;\n                r2 *= height / total;\n                r3 *= height / total;\n            }\n            if (r1 + r4 > height) {\n                total = r1 + r4;\n                r1 *= height / total;\n                r4 *= height / total;\n            }\n            ctx.moveTo(x + r1, y);\n            ctx.lineTo(x + width - r2, y);\n            r2 !== 0 && ctx.quadraticCurveTo(\n                x + width, y, x + width, y + r2\n            );\n            ctx.lineTo(x + width, y + height - r3);\n            r3 !== 0 && ctx.quadraticCurveTo(\n                x + width, y + height, x + width - r3, y + height\n            );\n            ctx.lineTo(x + r4, y + height);\n            r4 !== 0 && ctx.quadraticCurveTo(\n                x, y + height, x, y + height - r4\n            );\n            ctx.lineTo(x, y + r1);\n            r1 !== 0 && ctx.quadraticCurveTo(x, y, x + r1, y);\n        }\n    };\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTE2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy9ob21lL3l4L34venJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvcm91bmRSZWN0LmpzP2U5YzEiXSwic291cmNlc0NvbnRlbnQiOlsiXG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xuICAgICAgICAgICAgdmFyIHggPSBzaGFwZS54O1xuICAgICAgICAgICAgdmFyIHkgPSBzaGFwZS55O1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gc2hhcGUud2lkdGg7XG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gc2hhcGUuaGVpZ2h0O1xuICAgICAgICAgICAgdmFyIHIgPSBzaGFwZS5yO1xuICAgICAgICAgICAgdmFyIHIxO1xuICAgICAgICAgICAgdmFyIHIyO1xuICAgICAgICAgICAgdmFyIHIzO1xuICAgICAgICAgICAgdmFyIHI0O1xuXG4gICAgICAgICAgICAvLyBDb252ZXJ0IHdpZHRoIGFuZCBoZWlnaHQgdG8gcG9zaXRpdmUgZm9yIGJldHRlciBib3JkZXJSYWRpdXNcbiAgICAgICAgICAgIGlmICh3aWR0aCA8IDApIHtcbiAgICAgICAgICAgICAgICB4ID0geCArIHdpZHRoO1xuICAgICAgICAgICAgICAgIHdpZHRoID0gLXdpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhlaWdodCA8IDApIHtcbiAgICAgICAgICAgICAgICB5ID0geSArIGhlaWdodDtcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSAtaGVpZ2h0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHIgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgcjEgPSByMiA9IHIzID0gcjQgPSByO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAociBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgaWYgKHIubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHIxID0gcjIgPSByMyA9IHI0ID0gclswXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoci5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgcjEgPSByMyA9IHJbMF07XG4gICAgICAgICAgICAgICAgICAgIHIyID0gcjQgPSByWzFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyLmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgICAgICAgICByMSA9IHJbMF07XG4gICAgICAgICAgICAgICAgICAgIHIyID0gcjQgPSByWzFdO1xuICAgICAgICAgICAgICAgICAgICByMyA9IHJbMl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByMSA9IHJbMF07XG4gICAgICAgICAgICAgICAgICAgIHIyID0gclsxXTtcbiAgICAgICAgICAgICAgICAgICAgcjMgPSByWzJdO1xuICAgICAgICAgICAgICAgICAgICByNCA9IHJbM107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcjEgPSByMiA9IHIzID0gcjQgPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdG90YWw7XG4gICAgICAgICAgICBpZiAocjEgKyByMiA+IHdpZHRoKSB7XG4gICAgICAgICAgICAgICAgdG90YWwgPSByMSArIHIyO1xuICAgICAgICAgICAgICAgIHIxICo9IHdpZHRoIC8gdG90YWw7XG4gICAgICAgICAgICAgICAgcjIgKj0gd2lkdGggLyB0b3RhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyMyArIHI0ID4gd2lkdGgpIHtcbiAgICAgICAgICAgICAgICB0b3RhbCA9IHIzICsgcjQ7XG4gICAgICAgICAgICAgICAgcjMgKj0gd2lkdGggLyB0b3RhbDtcbiAgICAgICAgICAgICAgICByNCAqPSB3aWR0aCAvIHRvdGFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHIyICsgcjMgPiBoZWlnaHQpIHtcbiAgICAgICAgICAgICAgICB0b3RhbCA9IHIyICsgcjM7XG4gICAgICAgICAgICAgICAgcjIgKj0gaGVpZ2h0IC8gdG90YWw7XG4gICAgICAgICAgICAgICAgcjMgKj0gaGVpZ2h0IC8gdG90YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocjEgKyByNCA+IGhlaWdodCkge1xuICAgICAgICAgICAgICAgIHRvdGFsID0gcjEgKyByNDtcbiAgICAgICAgICAgICAgICByMSAqPSBoZWlnaHQgLyB0b3RhbDtcbiAgICAgICAgICAgICAgICByNCAqPSBoZWlnaHQgLyB0b3RhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oeCArIHIxLCB5KTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCArIHdpZHRoIC0gcjIsIHkpO1xuICAgICAgICAgICAgcjIgIT09IDAgJiYgY3R4LnF1YWRyYXRpY0N1cnZlVG8oXG4gICAgICAgICAgICAgICAgeCArIHdpZHRoLCB5LCB4ICsgd2lkdGgsIHkgKyByMlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0IC0gcjMpO1xuICAgICAgICAgICAgcjMgIT09IDAgJiYgY3R4LnF1YWRyYXRpY0N1cnZlVG8oXG4gICAgICAgICAgICAgICAgeCArIHdpZHRoLCB5ICsgaGVpZ2h0LCB4ICsgd2lkdGggLSByMywgeSArIGhlaWdodFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCArIHI0LCB5ICsgaGVpZ2h0KTtcbiAgICAgICAgICAgIHI0ICE9PSAwICYmIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKFxuICAgICAgICAgICAgICAgIHgsIHkgKyBoZWlnaHQsIHgsIHkgKyBoZWlnaHQgLSByNFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCwgeSArIHIxKTtcbiAgICAgICAgICAgIHIxICE9PSAwICYmIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHgsIHksIHggKyByMSwgeSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2hvbWUveXgvfi96cmVuZGVyL2xpYi9ncmFwaGljL2hlbHBlci9yb3VuZFJlY3QuanNcbi8vIG1vZHVsZSBpZCA9IDExNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 117 */
/* unknown exports provided */
/* all exports used */
/*!*************************************************************!*\
  !*** /home/yx/~/zrender/lib/graphic/helper/smoothBezier.js ***!
  \*************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * 贝塞尔平滑曲线\n * @module zrender/shape/util/smoothBezier\n * @author pissang (https://www.github.com/pissang)\n *         Kener (@Kener-林峰, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n */\n\n\n    var vec2 = __webpack_require__(/*! ../../core/vector */ 4);\n    var v2Min = vec2.min;\n    var v2Max = vec2.max;\n    var v2Scale = vec2.scale;\n    var v2Distance = vec2.distance;\n    var v2Add = vec2.add;\n\n    /**\n     * 贝塞尔平滑曲线\n     * @alias module:zrender/shape/util/smoothBezier\n     * @param {Array} points 线段顶点数组\n     * @param {number} smooth 平滑等级, 0-1\n     * @param {boolean} isLoop\n     * @param {Array} constraint 将计算出来的控制点约束在一个包围盒内\n     *                           比如 [[0, 0], [100, 100]], 这个包围盒会与\n     *                           整个折线的包围盒做一个并集用来约束控制点。\n     * @param {Array} 计算出来的控制点数组\n     */\n    module.exports = function (points, smooth, isLoop, constraint) {\n        var cps = [];\n\n        var v = [];\n        var v1 = [];\n        var v2 = [];\n        var prevPoint;\n        var nextPoint;\n\n        var min, max;\n        if (constraint) {\n            min = [Infinity, Infinity];\n            max = [-Infinity, -Infinity];\n            for (var i = 0, len = points.length; i < len; i++) {\n                v2Min(min, min, points[i]);\n                v2Max(max, max, points[i]);\n            }\n            // 与指定的包围盒做并集\n            v2Min(min, min, constraint[0]);\n            v2Max(max, max, constraint[1]);\n        }\n\n        for (var i = 0, len = points.length; i < len; i++) {\n            var point = points[i];\n\n            if (isLoop) {\n                prevPoint = points[i ? i - 1 : len - 1];\n                nextPoint = points[(i + 1) % len];\n            }\n            else {\n                if (i === 0 || i === len - 1) {\n                    cps.push(vec2.clone(points[i]));\n                    continue;\n                }\n                else {\n                    prevPoint = points[i - 1];\n                    nextPoint = points[i + 1];\n                }\n            }\n\n            vec2.sub(v, nextPoint, prevPoint);\n\n            // use degree to scale the handle length\n            v2Scale(v, v, smooth);\n\n            var d0 = v2Distance(point, prevPoint);\n            var d1 = v2Distance(point, nextPoint);\n            var sum = d0 + d1;\n            if (sum !== 0) {\n                d0 /= sum;\n                d1 /= sum;\n            }\n\n            v2Scale(v1, v, -d0);\n            v2Scale(v2, v, d1);\n            var cp0 = v2Add([], point, v1);\n            var cp1 = v2Add([], point, v2);\n            if (constraint) {\n                v2Max(cp0, cp0, min);\n                v2Min(cp0, cp0, max);\n                v2Max(cp1, cp1, min);\n                v2Min(cp1, cp1, max);\n            }\n            cps.push(cp0);\n            cps.push(cp1);\n        }\n\n        if (isLoop) {\n            cps.push(cps.shift());\n        }\n\n        return cps;\n    };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTE3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy9ob21lL3l4L34venJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvc21vb3RoQmV6aWVyLmpzPzVkNjEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiDotJ3loZ7lsJTlubPmu5Hmm7Lnur9cbiAqIEBtb2R1bGUgenJlbmRlci9zaGFwZS91dGlsL3Ntb290aEJlemllclxuICogQGF1dGhvciBwaXNzYW5nIChodHRwczovL3d3dy5naXRodWIuY29tL3Bpc3NhbmcpXG4gKiAgICAgICAgIEtlbmVyIChAS2VuZXIt5p6X5bOwLCBrZW5lci5saW5mZW5nQGdtYWlsLmNvbSlcbiAqICAgICAgICAgZXJyb3JyaWsgKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqL1xuXG5cbiAgICB2YXIgdmVjMiA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvdmVjdG9yJyk7XG4gICAgdmFyIHYyTWluID0gdmVjMi5taW47XG4gICAgdmFyIHYyTWF4ID0gdmVjMi5tYXg7XG4gICAgdmFyIHYyU2NhbGUgPSB2ZWMyLnNjYWxlO1xuICAgIHZhciB2MkRpc3RhbmNlID0gdmVjMi5kaXN0YW5jZTtcbiAgICB2YXIgdjJBZGQgPSB2ZWMyLmFkZDtcblxuICAgIC8qKlxuICAgICAqIOi0neWhnuWwlOW5s+a7keabsue6v1xuICAgICAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9zaGFwZS91dGlsL3Ntb290aEJlemllclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBvaW50cyDnur/mrrXpobbngrnmlbDnu4RcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc21vb3RoIOW5s+a7keetiee6pywgMC0xXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc0xvb3BcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBjb25zdHJhaW50IOWwhuiuoeeul+WHuuadpeeahOaOp+WItueCuee6puadn+WcqOS4gOS4quWMheWbtOebkuWGhVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAg5q+U5aaCIFtbMCwgMF0sIFsxMDAsIDEwMF1dLCDov5nkuKrljIXlm7Tnm5LkvJrkuI5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIOaVtOS4quaKmOe6v+eahOWMheWbtOebkuWBmuS4gOS4quW5tumbhueUqOadpee6puadn+aOp+WItueCueOAglxuICAgICAqIEBwYXJhbSB7QXJyYXl9IOiuoeeul+WHuuadpeeahOaOp+WItueCueaVsOe7hFxuICAgICAqL1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHBvaW50cywgc21vb3RoLCBpc0xvb3AsIGNvbnN0cmFpbnQpIHtcbiAgICAgICAgdmFyIGNwcyA9IFtdO1xuXG4gICAgICAgIHZhciB2ID0gW107XG4gICAgICAgIHZhciB2MSA9IFtdO1xuICAgICAgICB2YXIgdjIgPSBbXTtcbiAgICAgICAgdmFyIHByZXZQb2ludDtcbiAgICAgICAgdmFyIG5leHRQb2ludDtcblxuICAgICAgICB2YXIgbWluLCBtYXg7XG4gICAgICAgIGlmIChjb25zdHJhaW50KSB7XG4gICAgICAgICAgICBtaW4gPSBbSW5maW5pdHksIEluZmluaXR5XTtcbiAgICAgICAgICAgIG1heCA9IFstSW5maW5pdHksIC1JbmZpbml0eV07XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdjJNaW4obWluLCBtaW4sIHBvaW50c1tpXSk7XG4gICAgICAgICAgICAgICAgdjJNYXgobWF4LCBtYXgsIHBvaW50c1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyDkuI7mjIflrprnmoTljIXlm7Tnm5LlgZrlubbpm4ZcbiAgICAgICAgICAgIHYyTWluKG1pbiwgbWluLCBjb25zdHJhaW50WzBdKTtcbiAgICAgICAgICAgIHYyTWF4KG1heCwgbWF4LCBjb25zdHJhaW50WzFdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwb2ludCA9IHBvaW50c1tpXTtcblxuICAgICAgICAgICAgaWYgKGlzTG9vcCkge1xuICAgICAgICAgICAgICAgIHByZXZQb2ludCA9IHBvaW50c1tpID8gaSAtIDEgOiBsZW4gLSAxXTtcbiAgICAgICAgICAgICAgICBuZXh0UG9pbnQgPSBwb2ludHNbKGkgKyAxKSAlIGxlbl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMCB8fCBpID09PSBsZW4gLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNwcy5wdXNoKHZlYzIuY2xvbmUocG9pbnRzW2ldKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldlBvaW50ID0gcG9pbnRzW2kgLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFBvaW50ID0gcG9pbnRzW2kgKyAxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZlYzIuc3ViKHYsIG5leHRQb2ludCwgcHJldlBvaW50KTtcblxuICAgICAgICAgICAgLy8gdXNlIGRlZ3JlZSB0byBzY2FsZSB0aGUgaGFuZGxlIGxlbmd0aFxuICAgICAgICAgICAgdjJTY2FsZSh2LCB2LCBzbW9vdGgpO1xuXG4gICAgICAgICAgICB2YXIgZDAgPSB2MkRpc3RhbmNlKHBvaW50LCBwcmV2UG9pbnQpO1xuICAgICAgICAgICAgdmFyIGQxID0gdjJEaXN0YW5jZShwb2ludCwgbmV4dFBvaW50KTtcbiAgICAgICAgICAgIHZhciBzdW0gPSBkMCArIGQxO1xuICAgICAgICAgICAgaWYgKHN1bSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGQwIC89IHN1bTtcbiAgICAgICAgICAgICAgICBkMSAvPSBzdW07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHYyU2NhbGUodjEsIHYsIC1kMCk7XG4gICAgICAgICAgICB2MlNjYWxlKHYyLCB2LCBkMSk7XG4gICAgICAgICAgICB2YXIgY3AwID0gdjJBZGQoW10sIHBvaW50LCB2MSk7XG4gICAgICAgICAgICB2YXIgY3AxID0gdjJBZGQoW10sIHBvaW50LCB2Mik7XG4gICAgICAgICAgICBpZiAoY29uc3RyYWludCkge1xuICAgICAgICAgICAgICAgIHYyTWF4KGNwMCwgY3AwLCBtaW4pO1xuICAgICAgICAgICAgICAgIHYyTWluKGNwMCwgY3AwLCBtYXgpO1xuICAgICAgICAgICAgICAgIHYyTWF4KGNwMSwgY3AxLCBtaW4pO1xuICAgICAgICAgICAgICAgIHYyTWluKGNwMSwgY3AxLCBtYXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3BzLnB1c2goY3AwKTtcbiAgICAgICAgICAgIGNwcy5wdXNoKGNwMSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNMb29wKSB7XG4gICAgICAgICAgICBjcHMucHVzaChjcHMuc2hpZnQoKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY3BzO1xuICAgIH07XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9ob21lL3l4L34venJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvc21vb3RoQmV6aWVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 118 */
/* unknown exports provided */
/* all exports used */
/*!*************************************************************!*\
  !*** /home/yx/~/zrender/lib/graphic/helper/smoothSpline.js ***!
  \*************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Catmull-Rom spline 插值折线\n * @module zrender/shape/util/smoothSpline\n * @author pissang (https://www.github.com/pissang)\n *         Kener (@Kener-林峰, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n */\n\n    var vec2 = __webpack_require__(/*! ../../core/vector */ 4);\n\n    /**\n     * @inner\n     */\n    function interpolate(p0, p1, p2, p3, t, t2, t3) {\n        var v0 = (p2 - p0) * 0.5;\n        var v1 = (p3 - p1) * 0.5;\n        return (2 * (p1 - p2) + v0 + v1) * t3\n                + (-3 * (p1 - p2) - 2 * v0 - v1) * t2\n                + v0 * t + p1;\n    }\n\n    /**\n     * @alias module:zrender/shape/util/smoothSpline\n     * @param {Array} points 线段顶点数组\n     * @param {boolean} isLoop\n     * @return {Array}\n     */\n    module.exports = function (points, isLoop) {\n        var len = points.length;\n        var ret = [];\n\n        var distance = 0;\n        for (var i = 1; i < len; i++) {\n            distance += vec2.distance(points[i - 1], points[i]);\n        }\n\n        var segs = distance / 2;\n        segs = segs < len ? len : segs;\n        for (var i = 0; i < segs; i++) {\n            var pos = i / (segs - 1) * (isLoop ? len : len - 1);\n            var idx = Math.floor(pos);\n\n            var w = pos - idx;\n\n            var p0;\n            var p1 = points[idx % len];\n            var p2;\n            var p3;\n            if (!isLoop) {\n                p0 = points[idx === 0 ? idx : idx - 1];\n                p2 = points[idx > len - 2 ? len - 1 : idx + 1];\n                p3 = points[idx > len - 3 ? len - 1 : idx + 2];\n            }\n            else {\n                p0 = points[(idx - 1 + len) % len];\n                p2 = points[(idx + 1) % len];\n                p3 = points[(idx + 2) % len];\n            }\n\n            var w2 = w * w;\n            var w3 = w * w2;\n\n            ret.push([\n                interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3),\n                interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)\n            ]);\n        }\n        return ret;\n    };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTE4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy9ob21lL3l4L34venJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvc21vb3RoU3BsaW5lLmpzP2U4ZGMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDYXRtdWxsLVJvbSBzcGxpbmUg5o+S5YC85oqY57q/XG4gKiBAbW9kdWxlIHpyZW5kZXIvc2hhcGUvdXRpbC9zbW9vdGhTcGxpbmVcbiAqIEBhdXRob3IgcGlzc2FuZyAoaHR0cHM6Ly93d3cuZ2l0aHViLmNvbS9waXNzYW5nKVxuICogICAgICAgICBLZW5lciAoQEtlbmVyLeael+WzsCwga2VuZXIubGluZmVuZ0BnbWFpbC5jb20pXG4gKiAgICAgICAgIGVycm9ycmlrIChlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuICAgIHZhciB2ZWMyID0gcmVxdWlyZSgnLi4vLi4vY29yZS92ZWN0b3InKTtcblxuICAgIC8qKlxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGludGVycG9sYXRlKHAwLCBwMSwgcDIsIHAzLCB0LCB0MiwgdDMpIHtcbiAgICAgICAgdmFyIHYwID0gKHAyIC0gcDApICogMC41O1xuICAgICAgICB2YXIgdjEgPSAocDMgLSBwMSkgKiAwLjU7XG4gICAgICAgIHJldHVybiAoMiAqIChwMSAtIHAyKSArIHYwICsgdjEpICogdDNcbiAgICAgICAgICAgICAgICArICgtMyAqIChwMSAtIHAyKSAtIDIgKiB2MCAtIHYxKSAqIHQyXG4gICAgICAgICAgICAgICAgKyB2MCAqIHQgKyBwMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvc2hhcGUvdXRpbC9zbW9vdGhTcGxpbmVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwb2ludHMg57q/5q616aG254K55pWw57uEXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc0xvb3BcbiAgICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICAgKi9cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChwb2ludHMsIGlzTG9vcCkge1xuICAgICAgICB2YXIgbGVuID0gcG9pbnRzLmxlbmd0aDtcbiAgICAgICAgdmFyIHJldCA9IFtdO1xuXG4gICAgICAgIHZhciBkaXN0YW5jZSA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGRpc3RhbmNlICs9IHZlYzIuZGlzdGFuY2UocG9pbnRzW2kgLSAxXSwgcG9pbnRzW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzZWdzID0gZGlzdGFuY2UgLyAyO1xuICAgICAgICBzZWdzID0gc2VncyA8IGxlbiA/IGxlbiA6IHNlZ3M7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VnczsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcG9zID0gaSAvIChzZWdzIC0gMSkgKiAoaXNMb29wID8gbGVuIDogbGVuIC0gMSk7XG4gICAgICAgICAgICB2YXIgaWR4ID0gTWF0aC5mbG9vcihwb3MpO1xuXG4gICAgICAgICAgICB2YXIgdyA9IHBvcyAtIGlkeDtcblxuICAgICAgICAgICAgdmFyIHAwO1xuICAgICAgICAgICAgdmFyIHAxID0gcG9pbnRzW2lkeCAlIGxlbl07XG4gICAgICAgICAgICB2YXIgcDI7XG4gICAgICAgICAgICB2YXIgcDM7XG4gICAgICAgICAgICBpZiAoIWlzTG9vcCkge1xuICAgICAgICAgICAgICAgIHAwID0gcG9pbnRzW2lkeCA9PT0gMCA/IGlkeCA6IGlkeCAtIDFdO1xuICAgICAgICAgICAgICAgIHAyID0gcG9pbnRzW2lkeCA+IGxlbiAtIDIgPyBsZW4gLSAxIDogaWR4ICsgMV07XG4gICAgICAgICAgICAgICAgcDMgPSBwb2ludHNbaWR4ID4gbGVuIC0gMyA/IGxlbiAtIDEgOiBpZHggKyAyXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHAwID0gcG9pbnRzWyhpZHggLSAxICsgbGVuKSAlIGxlbl07XG4gICAgICAgICAgICAgICAgcDIgPSBwb2ludHNbKGlkeCArIDEpICUgbGVuXTtcbiAgICAgICAgICAgICAgICBwMyA9IHBvaW50c1soaWR4ICsgMikgJSBsZW5dO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdzIgPSB3ICogdztcbiAgICAgICAgICAgIHZhciB3MyA9IHcgKiB3MjtcblxuICAgICAgICAgICAgcmV0LnB1c2goW1xuICAgICAgICAgICAgICAgIGludGVycG9sYXRlKHAwWzBdLCBwMVswXSwgcDJbMF0sIHAzWzBdLCB3LCB3MiwgdzMpLFxuICAgICAgICAgICAgICAgIGludGVycG9sYXRlKHAwWzFdLCBwMVsxXSwgcDJbMV0sIHAzWzFdLCB3LCB3MiwgdzMpXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9ob21lL3l4L34venJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvc21vb3RoU3BsaW5lLmpzXG4vLyBtb2R1bGUgaWQgPSAxMThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 119 */
/* unknown exports provided */
/* all exports used */
/*!***************************************************!*\
  !*** /home/yx/~/zrender/lib/graphic/shape/Arc.js ***!
  \***************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * 圆弧\n * @module zrender/graphic/shape/Arc\n */\n \n\n    module.exports = __webpack_require__(/*! ../Path */ 7).extend({\n\n        type: 'arc',\n\n        shape: {\n\n            cx: 0,\n\n            cy: 0,\n\n            r: 0,\n\n            startAngle: 0,\n\n            endAngle: Math.PI * 2,\n\n            clockwise: true\n        },\n\n        style: {\n\n            stroke: '#000',\n\n            fill: null\n        },\n\n        buildPath: function (ctx, shape) {\n\n            var x = shape.cx;\n            var y = shape.cy;\n            var r = Math.max(shape.r, 0);\n            var startAngle = shape.startAngle;\n            var endAngle = shape.endAngle;\n            var clockwise = shape.clockwise;\n\n            var unitX = Math.cos(startAngle);\n            var unitY = Math.sin(startAngle);\n\n            ctx.moveTo(unitX * r + x, unitY * r + y);\n            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n        }\n    });\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTE5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy9ob21lL3l4L34venJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9BcmMuanM/ZGI0MSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIOWchuW8p1xuICogQG1vZHVsZSB6cmVuZGVyL2dyYXBoaWMvc2hhcGUvQXJjXG4gKi9cbiBcblxuICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vUGF0aCcpLmV4dGVuZCh7XG5cbiAgICAgICAgdHlwZTogJ2FyYycsXG5cbiAgICAgICAgc2hhcGU6IHtcblxuICAgICAgICAgICAgY3g6IDAsXG5cbiAgICAgICAgICAgIGN5OiAwLFxuXG4gICAgICAgICAgICByOiAwLFxuXG4gICAgICAgICAgICBzdGFydEFuZ2xlOiAwLFxuXG4gICAgICAgICAgICBlbmRBbmdsZTogTWF0aC5QSSAqIDIsXG5cbiAgICAgICAgICAgIGNsb2Nrd2lzZTogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIHN0eWxlOiB7XG5cbiAgICAgICAgICAgIHN0cm9rZTogJyMwMDAnLFxuXG4gICAgICAgICAgICBmaWxsOiBudWxsXG4gICAgICAgIH0sXG5cbiAgICAgICAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xuXG4gICAgICAgICAgICB2YXIgeCA9IHNoYXBlLmN4O1xuICAgICAgICAgICAgdmFyIHkgPSBzaGFwZS5jeTtcbiAgICAgICAgICAgIHZhciByID0gTWF0aC5tYXgoc2hhcGUuciwgMCk7XG4gICAgICAgICAgICB2YXIgc3RhcnRBbmdsZSA9IHNoYXBlLnN0YXJ0QW5nbGU7XG4gICAgICAgICAgICB2YXIgZW5kQW5nbGUgPSBzaGFwZS5lbmRBbmdsZTtcbiAgICAgICAgICAgIHZhciBjbG9ja3dpc2UgPSBzaGFwZS5jbG9ja3dpc2U7XG5cbiAgICAgICAgICAgIHZhciB1bml0WCA9IE1hdGguY29zKHN0YXJ0QW5nbGUpO1xuICAgICAgICAgICAgdmFyIHVuaXRZID0gTWF0aC5zaW4oc3RhcnRBbmdsZSk7XG5cbiAgICAgICAgICAgIGN0eC5tb3ZlVG8odW5pdFggKiByICsgeCwgdW5pdFkgKiByICsgeSk7XG4gICAgICAgICAgICBjdHguYXJjKHgsIHksIHIsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCAhY2xvY2t3aXNlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2hvbWUveXgvfi96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL0FyYy5qc1xuLy8gbW9kdWxlIGlkID0gMTE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 120 */
/* unknown exports provided */
/* all exports used */
/*!***********************************************************!*\
  !*** /home/yx/~/zrender/lib/graphic/shape/BezierCurve.js ***!
  \***********************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * 贝塞尔曲线\n * @module zrender/shape/BezierCurve\n */\n\n\n    var curveTool = __webpack_require__(/*! ../../core/curve */ 19);\n    var vec2 = __webpack_require__(/*! ../../core/vector */ 4);\n    var quadraticSubdivide = curveTool.quadraticSubdivide;\n    var cubicSubdivide = curveTool.cubicSubdivide;\n    var quadraticAt = curveTool.quadraticAt;\n    var cubicAt = curveTool.cubicAt;\n    var quadraticDerivativeAt = curveTool.quadraticDerivativeAt;\n    var cubicDerivativeAt = curveTool.cubicDerivativeAt;\n\n    var out = [];\n\n    function someVectorAt(shape, t, isTangent) {\n        var cpx2 = shape.cpx2;\n        var cpy2 = shape.cpy2;\n        if (cpx2 === null || cpy2 === null) {\n            return [\n                (isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t),\n                (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)\n            ];\n        }\n        else {\n            return [\n                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t),\n                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)\n            ];\n        }\n    }\n    module.exports = __webpack_require__(/*! ../Path */ 7).extend({\n\n        type: 'bezier-curve',\n\n        shape: {\n            x1: 0,\n            y1: 0,\n            x2: 0,\n            y2: 0,\n            cpx1: 0,\n            cpy1: 0,\n            // cpx2: 0,\n            // cpy2: 0\n\n            // Curve show percent, for animating\n            percent: 1\n        },\n\n        style: {\n            stroke: '#000',\n            fill: null\n        },\n\n        buildPath: function (ctx, shape) {\n            var x1 = shape.x1;\n            var y1 = shape.y1;\n            var x2 = shape.x2;\n            var y2 = shape.y2;\n            var cpx1 = shape.cpx1;\n            var cpy1 = shape.cpy1;\n            var cpx2 = shape.cpx2;\n            var cpy2 = shape.cpy2;\n            var percent = shape.percent;\n            if (percent === 0) {\n                return;\n            }\n\n            ctx.moveTo(x1, y1);\n\n            if (cpx2 == null || cpy2 == null) {\n                if (percent < 1) {\n                    quadraticSubdivide(\n                        x1, cpx1, x2, percent, out\n                    );\n                    cpx1 = out[1];\n                    x2 = out[2];\n                    quadraticSubdivide(\n                        y1, cpy1, y2, percent, out\n                    );\n                    cpy1 = out[1];\n                    y2 = out[2];\n                }\n\n                ctx.quadraticCurveTo(\n                    cpx1, cpy1,\n                    x2, y2\n                );\n            }\n            else {\n                if (percent < 1) {\n                    cubicSubdivide(\n                        x1, cpx1, cpx2, x2, percent, out\n                    );\n                    cpx1 = out[1];\n                    cpx2 = out[2];\n                    x2 = out[3];\n                    cubicSubdivide(\n                        y1, cpy1, cpy2, y2, percent, out\n                    );\n                    cpy1 = out[1];\n                    cpy2 = out[2];\n                    y2 = out[3];\n                }\n                ctx.bezierCurveTo(\n                    cpx1, cpy1,\n                    cpx2, cpy2,\n                    x2, y2\n                );\n            }\n        },\n\n        /**\n         * Get point at percent\n         * @param  {number} t\n         * @return {Array.<number>}\n         */\n        pointAt: function (t) {\n            return someVectorAt(this.shape, t, false);\n        },\n\n        /**\n         * Get tangent at percent\n         * @param  {number} t\n         * @return {Array.<number>}\n         */\n        tangentAt: function (t) {\n            var p = someVectorAt(this.shape, t, true);\n            return vec2.normalize(p, p);\n        }\n    });\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTIwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy9ob21lL3l4L34venJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9CZXppZXJDdXJ2ZS5qcz83NTg0Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbi8qKlxuICog6LSd5aGe5bCU5puy57q/XG4gKiBAbW9kdWxlIHpyZW5kZXIvc2hhcGUvQmV6aWVyQ3VydmVcbiAqL1xuXG5cbiAgICB2YXIgY3VydmVUb29sID0gcmVxdWlyZSgnLi4vLi4vY29yZS9jdXJ2ZScpO1xuICAgIHZhciB2ZWMyID0gcmVxdWlyZSgnLi4vLi4vY29yZS92ZWN0b3InKTtcbiAgICB2YXIgcXVhZHJhdGljU3ViZGl2aWRlID0gY3VydmVUb29sLnF1YWRyYXRpY1N1YmRpdmlkZTtcbiAgICB2YXIgY3ViaWNTdWJkaXZpZGUgPSBjdXJ2ZVRvb2wuY3ViaWNTdWJkaXZpZGU7XG4gICAgdmFyIHF1YWRyYXRpY0F0ID0gY3VydmVUb29sLnF1YWRyYXRpY0F0O1xuICAgIHZhciBjdWJpY0F0ID0gY3VydmVUb29sLmN1YmljQXQ7XG4gICAgdmFyIHF1YWRyYXRpY0Rlcml2YXRpdmVBdCA9IGN1cnZlVG9vbC5xdWFkcmF0aWNEZXJpdmF0aXZlQXQ7XG4gICAgdmFyIGN1YmljRGVyaXZhdGl2ZUF0ID0gY3VydmVUb29sLmN1YmljRGVyaXZhdGl2ZUF0O1xuXG4gICAgdmFyIG91dCA9IFtdO1xuXG4gICAgZnVuY3Rpb24gc29tZVZlY3RvckF0KHNoYXBlLCB0LCBpc1RhbmdlbnQpIHtcbiAgICAgICAgdmFyIGNweDIgPSBzaGFwZS5jcHgyO1xuICAgICAgICB2YXIgY3B5MiA9IHNoYXBlLmNweTI7XG4gICAgICAgIGlmIChjcHgyID09PSBudWxsIHx8IGNweTIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgKGlzVGFuZ2VudCA/IGN1YmljRGVyaXZhdGl2ZUF0IDogY3ViaWNBdCkoc2hhcGUueDEsIHNoYXBlLmNweDEsIHNoYXBlLmNweDIsIHNoYXBlLngyLCB0KSxcbiAgICAgICAgICAgICAgICAoaXNUYW5nZW50ID8gY3ViaWNEZXJpdmF0aXZlQXQgOiBjdWJpY0F0KShzaGFwZS55MSwgc2hhcGUuY3B5MSwgc2hhcGUuY3B5Miwgc2hhcGUueTIsIHQpXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAoaXNUYW5nZW50ID8gcXVhZHJhdGljRGVyaXZhdGl2ZUF0IDogcXVhZHJhdGljQXQpKHNoYXBlLngxLCBzaGFwZS5jcHgxLCBzaGFwZS54MiwgdCksXG4gICAgICAgICAgICAgICAgKGlzVGFuZ2VudCA/IHF1YWRyYXRpY0Rlcml2YXRpdmVBdCA6IHF1YWRyYXRpY0F0KShzaGFwZS55MSwgc2hhcGUuY3B5MSwgc2hhcGUueTIsIHQpXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vUGF0aCcpLmV4dGVuZCh7XG5cbiAgICAgICAgdHlwZTogJ2Jlemllci1jdXJ2ZScsXG5cbiAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgIHgxOiAwLFxuICAgICAgICAgICAgeTE6IDAsXG4gICAgICAgICAgICB4MjogMCxcbiAgICAgICAgICAgIHkyOiAwLFxuICAgICAgICAgICAgY3B4MTogMCxcbiAgICAgICAgICAgIGNweTE6IDAsXG4gICAgICAgICAgICAvLyBjcHgyOiAwLFxuICAgICAgICAgICAgLy8gY3B5MjogMFxuXG4gICAgICAgICAgICAvLyBDdXJ2ZSBzaG93IHBlcmNlbnQsIGZvciBhbmltYXRpbmdcbiAgICAgICAgICAgIHBlcmNlbnQ6IDFcbiAgICAgICAgfSxcblxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgc3Ryb2tlOiAnIzAwMCcsXG4gICAgICAgICAgICBmaWxsOiBudWxsXG4gICAgICAgIH0sXG5cbiAgICAgICAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xuICAgICAgICAgICAgdmFyIHgxID0gc2hhcGUueDE7XG4gICAgICAgICAgICB2YXIgeTEgPSBzaGFwZS55MTtcbiAgICAgICAgICAgIHZhciB4MiA9IHNoYXBlLngyO1xuICAgICAgICAgICAgdmFyIHkyID0gc2hhcGUueTI7XG4gICAgICAgICAgICB2YXIgY3B4MSA9IHNoYXBlLmNweDE7XG4gICAgICAgICAgICB2YXIgY3B5MSA9IHNoYXBlLmNweTE7XG4gICAgICAgICAgICB2YXIgY3B4MiA9IHNoYXBlLmNweDI7XG4gICAgICAgICAgICB2YXIgY3B5MiA9IHNoYXBlLmNweTI7XG4gICAgICAgICAgICB2YXIgcGVyY2VudCA9IHNoYXBlLnBlcmNlbnQ7XG4gICAgICAgICAgICBpZiAocGVyY2VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY3R4Lm1vdmVUbyh4MSwgeTEpO1xuXG4gICAgICAgICAgICBpZiAoY3B4MiA9PSBudWxsIHx8IGNweTIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChwZXJjZW50IDwgMSkge1xuICAgICAgICAgICAgICAgICAgICBxdWFkcmF0aWNTdWJkaXZpZGUoXG4gICAgICAgICAgICAgICAgICAgICAgICB4MSwgY3B4MSwgeDIsIHBlcmNlbnQsIG91dFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBjcHgxID0gb3V0WzFdO1xuICAgICAgICAgICAgICAgICAgICB4MiA9IG91dFsyXTtcbiAgICAgICAgICAgICAgICAgICAgcXVhZHJhdGljU3ViZGl2aWRlKFxuICAgICAgICAgICAgICAgICAgICAgICAgeTEsIGNweTEsIHkyLCBwZXJjZW50LCBvdXRcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgY3B5MSA9IG91dFsxXTtcbiAgICAgICAgICAgICAgICAgICAgeTIgPSBvdXRbMl07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oXG4gICAgICAgICAgICAgICAgICAgIGNweDEsIGNweTEsXG4gICAgICAgICAgICAgICAgICAgIHgyLCB5MlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAocGVyY2VudCA8IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY3ViaWNTdWJkaXZpZGUoXG4gICAgICAgICAgICAgICAgICAgICAgICB4MSwgY3B4MSwgY3B4MiwgeDIsIHBlcmNlbnQsIG91dFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBjcHgxID0gb3V0WzFdO1xuICAgICAgICAgICAgICAgICAgICBjcHgyID0gb3V0WzJdO1xuICAgICAgICAgICAgICAgICAgICB4MiA9IG91dFszXTtcbiAgICAgICAgICAgICAgICAgICAgY3ViaWNTdWJkaXZpZGUoXG4gICAgICAgICAgICAgICAgICAgICAgICB5MSwgY3B5MSwgY3B5MiwgeTIsIHBlcmNlbnQsIG91dFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBjcHkxID0gb3V0WzFdO1xuICAgICAgICAgICAgICAgICAgICBjcHkyID0gb3V0WzJdO1xuICAgICAgICAgICAgICAgICAgICB5MiA9IG91dFszXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3R4LmJlemllckN1cnZlVG8oXG4gICAgICAgICAgICAgICAgICAgIGNweDEsIGNweTEsXG4gICAgICAgICAgICAgICAgICAgIGNweDIsIGNweTIsXG4gICAgICAgICAgICAgICAgICAgIHgyLCB5MlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBwb2ludCBhdCBwZXJjZW50XG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gdFxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAgICAgICAgICovXG4gICAgICAgIHBvaW50QXQ6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICByZXR1cm4gc29tZVZlY3RvckF0KHRoaXMuc2hhcGUsIHQsIGZhbHNlKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRhbmdlbnQgYXQgcGVyY2VudFxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAgICAgICAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gICAgICAgICAqL1xuICAgICAgICB0YW5nZW50QXQ6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICB2YXIgcCA9IHNvbWVWZWN0b3JBdCh0aGlzLnNoYXBlLCB0LCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiB2ZWMyLm5vcm1hbGl6ZShwLCBwKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS95eC9+L3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvQmV6aWVyQ3VydmUuanNcbi8vIG1vZHVsZSBpZCA9IDEyMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 121 */
/* unknown exports provided */
/* all exports used */
/*!******************************************************!*\
  !*** /home/yx/~/zrender/lib/graphic/shape/Circle.js ***!
  \******************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * 圆形\n * @module zrender/shape/Circle\n */\n\n\n\n    module.exports = __webpack_require__(/*! ../Path */ 7).extend({\n\n        type: 'circle',\n\n        shape: {\n            cx: 0,\n            cy: 0,\n            r: 0\n        },\n\n\n        buildPath : function (ctx, shape, inBundle) {\n            // Better stroking in ShapeBundle\n            // Always do it may have performence issue ( fill may be 2x more cost)\n            if (inBundle) {\n                ctx.moveTo(shape.cx + shape.r, shape.cy);\n            }\n            // else {\n            //     if (ctx.allocate && !ctx.data.length) {\n            //         ctx.allocate(ctx.CMD_MEM_SIZE.A);\n            //     }\n            // }\n            // Better stroking in ShapeBundle\n            // ctx.moveTo(shape.cx + shape.r, shape.cy);\n            ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2, true);\n        }\n    });\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTIxLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy9ob21lL3l4L34venJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9DaXJjbGUuanM/NzZjOCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG4vKipcbiAqIOWchuW9olxuICogQG1vZHVsZSB6cmVuZGVyL3NoYXBlL0NpcmNsZVxuICovXG5cblxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9QYXRoJykuZXh0ZW5kKHtcblxuICAgICAgICB0eXBlOiAnY2lyY2xlJyxcblxuICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgY3g6IDAsXG4gICAgICAgICAgICBjeTogMCxcbiAgICAgICAgICAgIHI6IDBcbiAgICAgICAgfSxcblxuXG4gICAgICAgIGJ1aWxkUGF0aCA6IGZ1bmN0aW9uIChjdHgsIHNoYXBlLCBpbkJ1bmRsZSkge1xuICAgICAgICAgICAgLy8gQmV0dGVyIHN0cm9raW5nIGluIFNoYXBlQnVuZGxlXG4gICAgICAgICAgICAvLyBBbHdheXMgZG8gaXQgbWF5IGhhdmUgcGVyZm9ybWVuY2UgaXNzdWUgKCBmaWxsIG1heSBiZSAyeCBtb3JlIGNvc3QpXG4gICAgICAgICAgICBpZiAoaW5CdW5kbGUpIHtcbiAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHNoYXBlLmN4ICsgc2hhcGUuciwgc2hhcGUuY3kpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZWxzZSB7XG4gICAgICAgICAgICAvLyAgICAgaWYgKGN0eC5hbGxvY2F0ZSAmJiAhY3R4LmRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyAgICAgICAgIGN0eC5hbGxvY2F0ZShjdHguQ01EX01FTV9TSVpFLkEpO1xuICAgICAgICAgICAgLy8gICAgIH1cbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgIC8vIEJldHRlciBzdHJva2luZyBpbiBTaGFwZUJ1bmRsZVxuICAgICAgICAgICAgLy8gY3R4Lm1vdmVUbyhzaGFwZS5jeCArIHNoYXBlLnIsIHNoYXBlLmN5KTtcbiAgICAgICAgICAgIGN0eC5hcmMoc2hhcGUuY3gsIHNoYXBlLmN5LCBzaGFwZS5yLCAwLCBNYXRoLlBJICogMiwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2hvbWUveXgvfi96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL0NpcmNsZS5qc1xuLy8gbW9kdWxlIGlkID0gMTIxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 122 */
/* unknown exports provided */
/* all exports used */
/*!****************************************************!*\
  !*** /home/yx/~/zrender/lib/graphic/shape/Line.js ***!
  \****************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * 直线\n * @module zrender/graphic/shape/Line\n */\n\n    module.exports = __webpack_require__(/*! ../Path */ 7).extend({\n\n        type: 'line',\n\n        shape: {\n            // Start point\n            x1: 0,\n            y1: 0,\n            // End point\n            x2: 0,\n            y2: 0,\n\n            percent: 1\n        },\n\n        style: {\n            stroke: '#000',\n            fill: null\n        },\n\n        buildPath: function (ctx, shape) {\n            var x1 = shape.x1;\n            var y1 = shape.y1;\n            var x2 = shape.x2;\n            var y2 = shape.y2;\n            var percent = shape.percent;\n\n            if (percent === 0) {\n                return;\n            }\n\n            ctx.moveTo(x1, y1);\n\n            if (percent < 1) {\n                x2 = x1 * (1 - percent) + x2 * percent;\n                y2 = y1 * (1 - percent) + y2 * percent;\n            }\n            ctx.lineTo(x2, y2);\n        },\n\n        /**\n         * Get point at percent\n         * @param  {number} percent\n         * @return {Array.<number>}\n         */\n        pointAt: function (p) {\n            var shape = this.shape;\n            return [\n                shape.x1 * (1 - p) + shape.x2 * p,\n                shape.y1 * (1 - p) + shape.y2 * p\n            ];\n        }\n    });\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTIyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy9ob21lL3l4L34venJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9MaW5lLmpzP2FiYjYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiDnm7Tnur9cbiAqIEBtb2R1bGUgenJlbmRlci9ncmFwaGljL3NoYXBlL0xpbmVcbiAqL1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9QYXRoJykuZXh0ZW5kKHtcblxuICAgICAgICB0eXBlOiAnbGluZScsXG5cbiAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgIC8vIFN0YXJ0IHBvaW50XG4gICAgICAgICAgICB4MTogMCxcbiAgICAgICAgICAgIHkxOiAwLFxuICAgICAgICAgICAgLy8gRW5kIHBvaW50XG4gICAgICAgICAgICB4MjogMCxcbiAgICAgICAgICAgIHkyOiAwLFxuXG4gICAgICAgICAgICBwZXJjZW50OiAxXG4gICAgICAgIH0sXG5cbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIHN0cm9rZTogJyMwMDAnLFxuICAgICAgICAgICAgZmlsbDogbnVsbFxuICAgICAgICB9LFxuXG4gICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcbiAgICAgICAgICAgIHZhciB4MSA9IHNoYXBlLngxO1xuICAgICAgICAgICAgdmFyIHkxID0gc2hhcGUueTE7XG4gICAgICAgICAgICB2YXIgeDIgPSBzaGFwZS54MjtcbiAgICAgICAgICAgIHZhciB5MiA9IHNoYXBlLnkyO1xuICAgICAgICAgICAgdmFyIHBlcmNlbnQgPSBzaGFwZS5wZXJjZW50O1xuXG4gICAgICAgICAgICBpZiAocGVyY2VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY3R4Lm1vdmVUbyh4MSwgeTEpO1xuXG4gICAgICAgICAgICBpZiAocGVyY2VudCA8IDEpIHtcbiAgICAgICAgICAgICAgICB4MiA9IHgxICogKDEgLSBwZXJjZW50KSArIHgyICogcGVyY2VudDtcbiAgICAgICAgICAgICAgICB5MiA9IHkxICogKDEgLSBwZXJjZW50KSArIHkyICogcGVyY2VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5saW5lVG8oeDIsIHkyKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHBvaW50IGF0IHBlcmNlbnRcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSBwZXJjZW50XG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICAgICAgICAgKi9cbiAgICAgICAgcG9pbnRBdDogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICAgIHZhciBzaGFwZSA9IHRoaXMuc2hhcGU7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHNoYXBlLngxICogKDEgLSBwKSArIHNoYXBlLngyICogcCxcbiAgICAgICAgICAgICAgICBzaGFwZS55MSAqICgxIC0gcCkgKyBzaGFwZS55MiAqIHBcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICB9KTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2hvbWUveXgvfi96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL0xpbmUuanNcbi8vIG1vZHVsZSBpZCA9IDEyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 123 */
/* unknown exports provided */
/* all exports used */
/*!*******************************************************!*\
  !*** /home/yx/~/zrender/lib/graphic/shape/Polygon.js ***!
  \*******************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * 多边形\n * @module zrender/shape/Polygon\n */\n\n\n    var polyHelper = __webpack_require__(/*! ../helper/poly */ 65);\n\n    module.exports = __webpack_require__(/*! ../Path */ 7).extend({\n        \n        type: 'polygon',\n\n        shape: {\n            points: null,\n\n            smooth: false,\n\n            smoothConstraint: null\n        },\n\n        buildPath: function (ctx, shape) {\n            polyHelper.buildPath(ctx, shape, true);\n        }\n    });\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTIzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy9ob21lL3l4L34venJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9Qb2x5Z29uLmpzP2VmNjkiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiDlpJrovrnlvaJcbiAqIEBtb2R1bGUgenJlbmRlci9zaGFwZS9Qb2x5Z29uXG4gKi9cblxuXG4gICAgdmFyIHBvbHlIZWxwZXIgPSByZXF1aXJlKCcuLi9oZWxwZXIvcG9seScpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9QYXRoJykuZXh0ZW5kKHtcbiAgICAgICAgXG4gICAgICAgIHR5cGU6ICdwb2x5Z29uJyxcblxuICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgcG9pbnRzOiBudWxsLFxuXG4gICAgICAgICAgICBzbW9vdGg6IGZhbHNlLFxuXG4gICAgICAgICAgICBzbW9vdGhDb25zdHJhaW50OiBudWxsXG4gICAgICAgIH0sXG5cbiAgICAgICAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xuICAgICAgICAgICAgcG9seUhlbHBlci5idWlsZFBhdGgoY3R4LCBzaGFwZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9ob21lL3l4L34venJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9Qb2x5Z29uLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 124 */
/* unknown exports provided */
/* all exports used */
/*!********************************************************!*\
  !*** /home/yx/~/zrender/lib/graphic/shape/Polyline.js ***!
  \********************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * @module zrender/graphic/shape/Polyline\n */\n\n\n    var polyHelper = __webpack_require__(/*! ../helper/poly */ 65);\n\n    module.exports = __webpack_require__(/*! ../Path */ 7).extend({\n        \n        type: 'polyline',\n\n        shape: {\n            points: null,\n\n            smooth: false,\n\n            smoothConstraint: null\n        },\n\n        style: {\n            stroke: '#000',\n\n            fill: null\n        },\n\n        buildPath: function (ctx, shape) {\n            polyHelper.buildPath(ctx, shape, false);\n        }\n    });\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy9ob21lL3l4L34venJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9Qb2x5bGluZS5qcz9iNTg2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQG1vZHVsZSB6cmVuZGVyL2dyYXBoaWMvc2hhcGUvUG9seWxpbmVcbiAqL1xuXG5cbiAgICB2YXIgcG9seUhlbHBlciA9IHJlcXVpcmUoJy4uL2hlbHBlci9wb2x5Jyk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL1BhdGgnKS5leHRlbmQoe1xuICAgICAgICBcbiAgICAgICAgdHlwZTogJ3BvbHlsaW5lJyxcblxuICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgcG9pbnRzOiBudWxsLFxuXG4gICAgICAgICAgICBzbW9vdGg6IGZhbHNlLFxuXG4gICAgICAgICAgICBzbW9vdGhDb25zdHJhaW50OiBudWxsXG4gICAgICAgIH0sXG5cbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIHN0cm9rZTogJyMwMDAnLFxuXG4gICAgICAgICAgICBmaWxsOiBudWxsXG4gICAgICAgIH0sXG5cbiAgICAgICAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xuICAgICAgICAgICAgcG9seUhlbHBlci5idWlsZFBhdGgoY3R4LCBzaGFwZSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgfSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS95eC9+L3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvUG9seWxpbmUuanNcbi8vIG1vZHVsZSBpZCA9IDEyNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 125 */
/* unknown exports provided */
/* all exports used */
/*!****************************************************!*\
  !*** /home/yx/~/zrender/lib/graphic/shape/Rect.js ***!
  \****************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * 矩形\n * @module zrender/graphic/shape/Rect\n */\n\n\n    var roundRectHelper = __webpack_require__(/*! ../helper/roundRect */ 116);\n\n    module.exports = __webpack_require__(/*! ../Path */ 7).extend({\n\n        type: 'rect',\n\n        shape: {\n            // 左上、右上、右下、左下角的半径依次为r1、r2、r3、r4\n            // r缩写为1         相当于 [1, 1, 1, 1]\n            // r缩写为[1]       相当于 [1, 1, 1, 1]\n            // r缩写为[1, 2]    相当于 [1, 2, 1, 2]\n            // r缩写为[1, 2, 3] 相当于 [1, 2, 3, 2]\n            r: 0,\n\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        },\n\n        buildPath: function (ctx, shape) {\n            var x = shape.x;\n            var y = shape.y;\n            var width = shape.width;\n            var height = shape.height;\n            if (!shape.r) {\n                ctx.rect(x, y, width, height);\n            }\n            else {\n                roundRectHelper.buildPath(ctx, shape);\n            }\n            ctx.closePath();\n            return;\n        }\n    });\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy9ob21lL3l4L34venJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9SZWN0LmpzPzlhZjgiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiDnn6nlvaJcbiAqIEBtb2R1bGUgenJlbmRlci9ncmFwaGljL3NoYXBlL1JlY3RcbiAqL1xuXG5cbiAgICB2YXIgcm91bmRSZWN0SGVscGVyID0gcmVxdWlyZSgnLi4vaGVscGVyL3JvdW5kUmVjdCcpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9QYXRoJykuZXh0ZW5kKHtcblxuICAgICAgICB0eXBlOiAncmVjdCcsXG5cbiAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgIC8vIOW3puS4iuOAgeWPs+S4iuOAgeWPs+S4i+OAgeW3puS4i+inkueahOWNiuW+hOS+neasoeS4unIx44CBcjLjgIFyM+OAgXI0XG4gICAgICAgICAgICAvLyBy57yp5YaZ5Li6MSAgICAgICAgIOebuOW9k+S6jiBbMSwgMSwgMSwgMV1cbiAgICAgICAgICAgIC8vIHLnvKnlhpnkuLpbMV0gICAgICAg55u45b2T5LqOIFsxLCAxLCAxLCAxXVxuICAgICAgICAgICAgLy8gcue8qeWGmeS4ulsxLCAyXSAgICDnm7jlvZPkuo4gWzEsIDIsIDEsIDJdXG4gICAgICAgICAgICAvLyBy57yp5YaZ5Li6WzEsIDIsIDNdIOebuOW9k+S6jiBbMSwgMiwgMywgMl1cbiAgICAgICAgICAgIHI6IDAsXG5cbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgICAgICBoZWlnaHQ6IDBcbiAgICAgICAgfSxcblxuICAgICAgICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XG4gICAgICAgICAgICB2YXIgeCA9IHNoYXBlLng7XG4gICAgICAgICAgICB2YXIgeSA9IHNoYXBlLnk7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSBzaGFwZS53aWR0aDtcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSBzaGFwZS5oZWlnaHQ7XG4gICAgICAgICAgICBpZiAoIXNoYXBlLnIpIHtcbiAgICAgICAgICAgICAgICBjdHgucmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJvdW5kUmVjdEhlbHBlci5idWlsZFBhdGgoY3R4LCBzaGFwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9KTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2hvbWUveXgvfi96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1JlY3QuanNcbi8vIG1vZHVsZSBpZCA9IDEyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 126 */
/* unknown exports provided */
/* all exports used */
/*!****************************************************!*\
  !*** /home/yx/~/zrender/lib/graphic/shape/Ring.js ***!
  \****************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * 圆环\n * @module zrender/graphic/shape/Ring\n */\n\n\n    module.exports = __webpack_require__(/*! ../Path */ 7).extend({\n\n        type: 'ring',\n\n        shape: {\n            cx: 0,\n            cy: 0,\n            r: 0,\n            r0: 0\n        },\n\n        buildPath: function (ctx, shape) {\n            var x = shape.cx;\n            var y = shape.cy;\n            var PI2 = Math.PI * 2;\n            ctx.moveTo(x + shape.r, y);\n            ctx.arc(x, y, shape.r, 0, PI2, false);\n            ctx.moveTo(x + shape.r0, y);\n            ctx.arc(x, y, shape.r0, 0, PI2, true);\n        }\n    });\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy9ob21lL3l4L34venJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9SaW5nLmpzP2VhMGIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiDlnIbnjq9cbiAqIEBtb2R1bGUgenJlbmRlci9ncmFwaGljL3NoYXBlL1JpbmdcbiAqL1xuXG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL1BhdGgnKS5leHRlbmQoe1xuXG4gICAgICAgIHR5cGU6ICdyaW5nJyxcblxuICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgY3g6IDAsXG4gICAgICAgICAgICBjeTogMCxcbiAgICAgICAgICAgIHI6IDAsXG4gICAgICAgICAgICByMDogMFxuICAgICAgICB9LFxuXG4gICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcbiAgICAgICAgICAgIHZhciB4ID0gc2hhcGUuY3g7XG4gICAgICAgICAgICB2YXIgeSA9IHNoYXBlLmN5O1xuICAgICAgICAgICAgdmFyIFBJMiA9IE1hdGguUEkgKiAyO1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyh4ICsgc2hhcGUuciwgeSk7XG4gICAgICAgICAgICBjdHguYXJjKHgsIHksIHNoYXBlLnIsIDAsIFBJMiwgZmFsc2UpO1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyh4ICsgc2hhcGUucjAsIHkpO1xuICAgICAgICAgICAgY3R4LmFyYyh4LCB5LCBzaGFwZS5yMCwgMCwgUEkyLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS95eC9+L3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvUmluZy5qc1xuLy8gbW9kdWxlIGlkID0gMTI2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 127 */
/* unknown exports provided */
/* all exports used */
/*!******************************************************!*\
  !*** /home/yx/~/zrender/lib/graphic/shape/Sector.js ***!
  \******************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * 扇形\n * @module zrender/graphic/shape/Sector\n */\n\n\n\n    var env = __webpack_require__(/*! ../../core/env */ 8);\n    var Path = __webpack_require__(/*! ../Path */ 7);\n\n    var shadowTemp = [\n        ['shadowBlur', 0],\n        ['shadowColor', '#000'],\n        ['shadowOffsetX', 0],\n        ['shadowOffsetY', 0]\n    ];\n\n    module.exports = Path.extend({\n\n        type: 'sector',\n\n        shape: {\n\n            cx: 0,\n\n            cy: 0,\n\n            r0: 0,\n\n            r: 0,\n\n            startAngle: 0,\n\n            endAngle: Math.PI * 2,\n\n            clockwise: true\n        },\n\n        brush: (env.browser.ie && env.browser.version >= 11) // version: '11.0'\n            // Fix weird bug in some version of IE11 (like 11.0.9600.17801),\n            // where exception \"unexpected call to method or property access\"\n            // might be thrown when calling ctx.fill after a path whose area size\n            // is zero is drawn and ctx.clip() is called and shadowBlur is set.\n            // (e.g.,\n            //  ctx.moveTo(10, 10);\n            //  ctx.lineTo(20, 10);\n            //  ctx.closePath();\n            //  ctx.clip();\n            //  ctx.shadowBlur = 10;\n            //  ...\n            //  ctx.fill();\n            // )\n            ? function () {\n                var clipPaths = this.__clipPaths;\n                var style = this.style;\n                var modified;\n\n                if (clipPaths) {\n                    for (var i = 0; i < clipPaths.length; i++) {\n                        var shape = clipPaths[i] && clipPaths[i].shape;\n                        if (shape && shape.startAngle === shape.endAngle) {\n                            for (var j = 0; j < shadowTemp.length; j++) {\n                                shadowTemp[j][2] = style[shadowTemp[j][0]];\n                                style[shadowTemp[j][0]] = shadowTemp[j][1];\n                            }\n                            modified = true;\n                            break;\n                        }\n                    }\n                }\n\n                Path.prototype.brush.apply(this, arguments);\n\n                if (modified) {\n                    for (var j = 0; j < shadowTemp.length; j++) {\n                        style[shadowTemp[j][0]] = shadowTemp[j][2];\n                    }\n                }\n            }\n            : Path.prototype.brush,\n\n        buildPath: function (ctx, shape) {\n\n            var x = shape.cx;\n            var y = shape.cy;\n            var r0 = Math.max(shape.r0 || 0, 0);\n            var r = Math.max(shape.r, 0);\n            var startAngle = shape.startAngle;\n            var endAngle = shape.endAngle;\n            var clockwise = shape.clockwise;\n\n            var unitX = Math.cos(startAngle);\n            var unitY = Math.sin(startAngle);\n\n            ctx.moveTo(unitX * r0 + x, unitY * r0 + y);\n\n            ctx.lineTo(unitX * r + x, unitY * r + y);\n\n            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n\n            ctx.lineTo(\n                Math.cos(endAngle) * r0 + x,\n                Math.sin(endAngle) * r0 + y\n            );\n\n            if (r0 !== 0) {\n                ctx.arc(x, y, r0, endAngle, startAngle, clockwise);\n            }\n\n            ctx.closePath();\n        }\n    });\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy9ob21lL3l4L34venJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9TZWN0b3IuanM/ZWZlZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIOaJh+W9olxuICogQG1vZHVsZSB6cmVuZGVyL2dyYXBoaWMvc2hhcGUvU2VjdG9yXG4gKi9cblxuXG5cbiAgICB2YXIgZW52ID0gcmVxdWlyZSgnLi4vLi4vY29yZS9lbnYnKTtcbiAgICB2YXIgUGF0aCA9IHJlcXVpcmUoJy4uL1BhdGgnKTtcblxuICAgIHZhciBzaGFkb3dUZW1wID0gW1xuICAgICAgICBbJ3NoYWRvd0JsdXInLCAwXSxcbiAgICAgICAgWydzaGFkb3dDb2xvcicsICcjMDAwJ10sXG4gICAgICAgIFsnc2hhZG93T2Zmc2V0WCcsIDBdLFxuICAgICAgICBbJ3NoYWRvd09mZnNldFknLCAwXVxuICAgIF07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFBhdGguZXh0ZW5kKHtcblxuICAgICAgICB0eXBlOiAnc2VjdG9yJyxcblxuICAgICAgICBzaGFwZToge1xuXG4gICAgICAgICAgICBjeDogMCxcblxuICAgICAgICAgICAgY3k6IDAsXG5cbiAgICAgICAgICAgIHIwOiAwLFxuXG4gICAgICAgICAgICByOiAwLFxuXG4gICAgICAgICAgICBzdGFydEFuZ2xlOiAwLFxuXG4gICAgICAgICAgICBlbmRBbmdsZTogTWF0aC5QSSAqIDIsXG5cbiAgICAgICAgICAgIGNsb2Nrd2lzZTogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIGJydXNoOiAoZW52LmJyb3dzZXIuaWUgJiYgZW52LmJyb3dzZXIudmVyc2lvbiA+PSAxMSkgLy8gdmVyc2lvbjogJzExLjAnXG4gICAgICAgICAgICAvLyBGaXggd2VpcmQgYnVnIGluIHNvbWUgdmVyc2lvbiBvZiBJRTExIChsaWtlIDExLjAuOTYwMC4xNzgwMSksXG4gICAgICAgICAgICAvLyB3aGVyZSBleGNlcHRpb24gXCJ1bmV4cGVjdGVkIGNhbGwgdG8gbWV0aG9kIG9yIHByb3BlcnR5IGFjY2Vzc1wiXG4gICAgICAgICAgICAvLyBtaWdodCBiZSB0aHJvd24gd2hlbiBjYWxsaW5nIGN0eC5maWxsIGFmdGVyIGEgcGF0aCB3aG9zZSBhcmVhIHNpemVcbiAgICAgICAgICAgIC8vIGlzIHplcm8gaXMgZHJhd24gYW5kIGN0eC5jbGlwKCkgaXMgY2FsbGVkIGFuZCBzaGFkb3dCbHVyIGlzIHNldC5cbiAgICAgICAgICAgIC8vIChlLmcuLFxuICAgICAgICAgICAgLy8gIGN0eC5tb3ZlVG8oMTAsIDEwKTtcbiAgICAgICAgICAgIC8vICBjdHgubGluZVRvKDIwLCAxMCk7XG4gICAgICAgICAgICAvLyAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgLy8gIGN0eC5jbGlwKCk7XG4gICAgICAgICAgICAvLyAgY3R4LnNoYWRvd0JsdXIgPSAxMDtcbiAgICAgICAgICAgIC8vICAuLi5cbiAgICAgICAgICAgIC8vICBjdHguZmlsbCgpO1xuICAgICAgICAgICAgLy8gKVxuICAgICAgICAgICAgPyBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNsaXBQYXRocyA9IHRoaXMuX19jbGlwUGF0aHM7XG4gICAgICAgICAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTtcbiAgICAgICAgICAgICAgICB2YXIgbW9kaWZpZWQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoY2xpcFBhdGhzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xpcFBhdGhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2hhcGUgPSBjbGlwUGF0aHNbaV0gJiYgY2xpcFBhdGhzW2ldLnNoYXBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNoYXBlICYmIHNoYXBlLnN0YXJ0QW5nbGUgPT09IHNoYXBlLmVuZEFuZ2xlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzaGFkb3dUZW1wLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYWRvd1RlbXBbal1bMl0gPSBzdHlsZVtzaGFkb3dUZW1wW2pdWzBdXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVbc2hhZG93VGVtcFtqXVswXV0gPSBzaGFkb3dUZW1wW2pdWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RpZmllZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBQYXRoLnByb3RvdHlwZS5icnVzaC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG1vZGlmaWVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc2hhZG93VGVtcC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVbc2hhZG93VGVtcFtqXVswXV0gPSBzaGFkb3dUZW1wW2pdWzJdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiBQYXRoLnByb3RvdHlwZS5icnVzaCxcblxuICAgICAgICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XG5cbiAgICAgICAgICAgIHZhciB4ID0gc2hhcGUuY3g7XG4gICAgICAgICAgICB2YXIgeSA9IHNoYXBlLmN5O1xuICAgICAgICAgICAgdmFyIHIwID0gTWF0aC5tYXgoc2hhcGUucjAgfHwgMCwgMCk7XG4gICAgICAgICAgICB2YXIgciA9IE1hdGgubWF4KHNoYXBlLnIsIDApO1xuICAgICAgICAgICAgdmFyIHN0YXJ0QW5nbGUgPSBzaGFwZS5zdGFydEFuZ2xlO1xuICAgICAgICAgICAgdmFyIGVuZEFuZ2xlID0gc2hhcGUuZW5kQW5nbGU7XG4gICAgICAgICAgICB2YXIgY2xvY2t3aXNlID0gc2hhcGUuY2xvY2t3aXNlO1xuXG4gICAgICAgICAgICB2YXIgdW5pdFggPSBNYXRoLmNvcyhzdGFydEFuZ2xlKTtcbiAgICAgICAgICAgIHZhciB1bml0WSA9IE1hdGguc2luKHN0YXJ0QW5nbGUpO1xuXG4gICAgICAgICAgICBjdHgubW92ZVRvKHVuaXRYICogcjAgKyB4LCB1bml0WSAqIHIwICsgeSk7XG5cbiAgICAgICAgICAgIGN0eC5saW5lVG8odW5pdFggKiByICsgeCwgdW5pdFkgKiByICsgeSk7XG5cbiAgICAgICAgICAgIGN0eC5hcmMoeCwgeSwgciwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsICFjbG9ja3dpc2UpO1xuXG4gICAgICAgICAgICBjdHgubGluZVRvKFxuICAgICAgICAgICAgICAgIE1hdGguY29zKGVuZEFuZ2xlKSAqIHIwICsgeCxcbiAgICAgICAgICAgICAgICBNYXRoLnNpbihlbmRBbmdsZSkgKiByMCArIHlcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGlmIChyMCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGN0eC5hcmMoeCwgeSwgcjAsIGVuZEFuZ2xlLCBzdGFydEFuZ2xlLCBjbG9ja3dpc2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2hvbWUveXgvfi96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1NlY3Rvci5qc1xuLy8gbW9kdWxlIGlkID0gMTI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 128 */
/* unknown exports provided */
/* all exports used */
/*!**************************************************!*\
  !*** /home/yx/~/zrender/lib/mixin/Animatable.js ***!
  \**************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * @module zrender/mixin/Animatable\n */\n\n\n    var Animator = __webpack_require__(/*! ../animation/Animator */ 58);\n    var util = __webpack_require__(/*! ../core/util */ 0);\n    var isString = util.isString;\n    var isFunction = util.isFunction;\n    var isObject = util.isObject;\n    var log = __webpack_require__(/*! ../core/log */ 52);\n\n    /**\n     * @alias modue:zrender/mixin/Animatable\n     * @constructor\n     */\n    var Animatable = function () {\n\n        /**\n         * @type {Array.<module:zrender/animation/Animator>}\n         * @readOnly\n         */\n        this.animators = [];\n    };\n\n    Animatable.prototype = {\n\n        constructor: Animatable,\n\n        /**\n         * 动画\n         *\n         * @param {string} path 需要添加动画的属性获取路径，可以通过a.b.c来获取深层的属性\n         * @param {boolean} [loop] 动画是否循环\n         * @return {module:zrender/animation/Animator}\n         * @example:\n         *     el.animate('style', false)\n         *         .when(1000, {x: 10} )\n         *         .done(function(){ // Animation done })\n         *         .start()\n         */\n        animate: function (path, loop) {\n            var target;\n            var animatingShape = false;\n            var el = this;\n            var zr = this.__zr;\n            if (path) {\n                var pathSplitted = path.split('.');\n                var prop = el;\n                // If animating shape\n                animatingShape = pathSplitted[0] === 'shape';\n                for (var i = 0, l = pathSplitted.length; i < l; i++) {\n                    if (!prop) {\n                        continue;\n                    }\n                    prop = prop[pathSplitted[i]];\n                }\n                if (prop) {\n                    target = prop;\n                }\n            }\n            else {\n                target = el;\n            }\n\n            if (!target) {\n                log(\n                    'Property \"'\n                    + path\n                    + '\" is not existed in element '\n                    + el.id\n                );\n                return;\n            }\n\n            var animators = el.animators;\n\n            var animator = new Animator(target, loop);\n\n            animator.during(function (target) {\n                el.dirty(animatingShape);\n            })\n            .done(function () {\n                // FIXME Animator will not be removed if use `Animator#stop` to stop animation\n                animators.splice(util.indexOf(animators, animator), 1);\n            });\n\n            animators.push(animator);\n\n            // If animate after added to the zrender\n            if (zr) {\n                zr.animation.addAnimator(animator);\n            }\n\n            return animator;\n        },\n\n        /**\n         * 停止动画\n         * @param {boolean} forwardToLast If move to last frame before stop\n         */\n        stopAnimation: function (forwardToLast) {\n            var animators = this.animators;\n            var len = animators.length;\n            for (var i = 0; i < len; i++) {\n                animators[i].stop(forwardToLast);\n            }\n            animators.length = 0;\n\n            return this;\n        },\n\n        /**\n         * @param {Object} target\n         * @param {number} [time=500] Time in ms\n         * @param {string} [easing='linear']\n         * @param {number} [delay=0]\n         * @param {Function} [callback]\n         *\n         * @example\n         *  // Animate position\n         *  el.animateTo({\n         *      position: [10, 10]\n         *  }, function () { // done })\n         *\n         *  // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing\n         *  el.animateTo({\n         *      shape: {\n         *          width: 500\n         *      },\n         *      style: {\n         *          fill: 'red'\n         *      }\n         *      position: [10, 10]\n         *  }, 100, 100, 'cubicOut', function () { // done })\n         */\n         // TODO Return animation key\n        animateTo: function (target, time, delay, easing, callback) {\n            // animateTo(target, time, easing, callback);\n            if (isString(delay)) {\n                callback = easing;\n                easing = delay;\n                delay = 0;\n            }\n            // animateTo(target, time, delay, callback);\n            else if (isFunction(easing)) {\n                callback = easing;\n                easing = 'linear';\n                delay = 0;\n            }\n            // animateTo(target, time, callback);\n            else if (isFunction(delay)) {\n                callback = delay;\n                delay = 0;\n            }\n            // animateTo(target, callback)\n            else if (isFunction(time)) {\n                callback = time;\n                time = 500;\n            }\n            // animateTo(target)\n            else if (!time) {\n                time = 500;\n            }\n            // Stop all previous animations\n            this.stopAnimation();\n            this._animateToShallow('', this, target, time, delay, easing, callback);\n\n            // Animators may be removed immediately after start\n            // if there is nothing to animate\n            var animators = this.animators.slice();\n            var count = animators.length;\n            function done() {\n                count--;\n                if (!count) {\n                    callback && callback();\n                }\n            }\n\n            // No animators. This should be checked before animators[i].start(),\n            // because 'done' may be executed immediately if no need to animate.\n            if (!count) {\n                callback && callback();\n            }\n            // Start after all animators created\n            // Incase any animator is done immediately when all animation properties are not changed\n            for (var i = 0; i < animators.length; i++) {\n                animators[i]\n                    .done(done)\n                    .start(easing);\n            }\n        },\n\n        /**\n         * @private\n         * @param {string} path=''\n         * @param {Object} source=this\n         * @param {Object} target\n         * @param {number} [time=500]\n         * @param {number} [delay=0]\n         *\n         * @example\n         *  // Animate position\n         *  el._animateToShallow({\n         *      position: [10, 10]\n         *  })\n         *\n         *  // Animate shape, style and position in 100ms, delayed 100ms\n         *  el._animateToShallow({\n         *      shape: {\n         *          width: 500\n         *      },\n         *      style: {\n         *          fill: 'red'\n         *      }\n         *      position: [10, 10]\n         *  }, 100, 100)\n         */\n        _animateToShallow: function (path, source, target, time, delay) {\n            var objShallow = {};\n            var propertyCount = 0;\n            for (var name in target) {\n                if (!target.hasOwnProperty(name)) {\n                    continue;\n                }\n\n                if (source[name] != null) {\n                    if (isObject(target[name]) && !util.isArrayLike(target[name])) {\n                        this._animateToShallow(\n                            path ? path + '.' + name : name,\n                            source[name],\n                            target[name],\n                            time,\n                            delay\n                        );\n                    }\n                    else {\n                        objShallow[name] = target[name];\n                        propertyCount++;\n                    }\n                }\n                else if (target[name] != null) {\n                    // Attr directly if not has property\n                    // FIXME, if some property not needed for element ?\n                    if (!path) {\n                        this.attr(name, target[name]);\n                    }\n                    else {  // Shape or style\n                        var props = {};\n                        props[path] = {};\n                        props[path][name] = target[name];\n                        this.attr(props);\n                    }\n                }\n            }\n\n            if (propertyCount > 0) {\n                this.animate(path, false)\n                    .when(time == null ? 500 : time, objShallow)\n                    .delay(delay || 0);\n            }\n\n            return this;\n        }\n    };\n\n    module.exports = Animatable;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy9ob21lL3l4L34venJlbmRlci9saWIvbWl4aW4vQW5pbWF0YWJsZS5qcz9mZjY4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbi8qKlxuICogQG1vZHVsZSB6cmVuZGVyL21peGluL0FuaW1hdGFibGVcbiAqL1xuXG5cbiAgICB2YXIgQW5pbWF0b3IgPSByZXF1aXJlKCcuLi9hbmltYXRpb24vQW5pbWF0b3InKTtcbiAgICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpO1xuICAgIHZhciBpc1N0cmluZyA9IHV0aWwuaXNTdHJpbmc7XG4gICAgdmFyIGlzRnVuY3Rpb24gPSB1dGlsLmlzRnVuY3Rpb247XG4gICAgdmFyIGlzT2JqZWN0ID0gdXRpbC5pc09iamVjdDtcbiAgICB2YXIgbG9nID0gcmVxdWlyZSgnLi4vY29yZS9sb2cnKTtcblxuICAgIC8qKlxuICAgICAqIEBhbGlhcyBtb2R1ZTp6cmVuZGVyL21peGluL0FuaW1hdGFibGVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICB2YXIgQW5pbWF0YWJsZSA9IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge0FycmF5Ljxtb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0b3I+fVxuICAgICAgICAgKiBAcmVhZE9ubHlcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYW5pbWF0b3JzID0gW107XG4gICAgfTtcblxuICAgIEFuaW1hdGFibGUucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBBbmltYXRhYmxlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDliqjnlLtcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGgg6ZyA6KaB5re75Yqg5Yqo55S755qE5bGe5oCn6I635Y+W6Lev5b6E77yM5Y+v5Lul6YCa6L+HYS5iLmPmnaXojrflj5bmt7HlsYLnmoTlsZ7mgKdcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbbG9vcF0g5Yqo55S75piv5ZCm5b6q546vXG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRvcn1cbiAgICAgICAgICogQGV4YW1wbGU6XG4gICAgICAgICAqICAgICBlbC5hbmltYXRlKCdzdHlsZScsIGZhbHNlKVxuICAgICAgICAgKiAgICAgICAgIC53aGVuKDEwMDAsIHt4OiAxMH0gKVxuICAgICAgICAgKiAgICAgICAgIC5kb25lKGZ1bmN0aW9uKCl7IC8vIEFuaW1hdGlvbiBkb25lIH0pXG4gICAgICAgICAqICAgICAgICAgLnN0YXJ0KClcbiAgICAgICAgICovXG4gICAgICAgIGFuaW1hdGU6IGZ1bmN0aW9uIChwYXRoLCBsb29wKSB7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0O1xuICAgICAgICAgICAgdmFyIGFuaW1hdGluZ1NoYXBlID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgZWwgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIHpyID0gdGhpcy5fX3pyO1xuICAgICAgICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGF0aFNwbGl0dGVkID0gcGF0aC5zcGxpdCgnLicpO1xuICAgICAgICAgICAgICAgIHZhciBwcm9wID0gZWw7XG4gICAgICAgICAgICAgICAgLy8gSWYgYW5pbWF0aW5nIHNoYXBlXG4gICAgICAgICAgICAgICAgYW5pbWF0aW5nU2hhcGUgPSBwYXRoU3BsaXR0ZWRbMF0gPT09ICdzaGFwZSc7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBwYXRoU3BsaXR0ZWQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcHJvcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcHJvcCA9IHByb3BbcGF0aFNwbGl0dGVkW2ldXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHByb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0ID0gcHJvcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQgPSBlbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICBsb2coXG4gICAgICAgICAgICAgICAgICAgICdQcm9wZXJ0eSBcIidcbiAgICAgICAgICAgICAgICAgICAgKyBwYXRoXG4gICAgICAgICAgICAgICAgICAgICsgJ1wiIGlzIG5vdCBleGlzdGVkIGluIGVsZW1lbnQgJ1xuICAgICAgICAgICAgICAgICAgICArIGVsLmlkXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBhbmltYXRvcnMgPSBlbC5hbmltYXRvcnM7XG5cbiAgICAgICAgICAgIHZhciBhbmltYXRvciA9IG5ldyBBbmltYXRvcih0YXJnZXQsIGxvb3ApO1xuXG4gICAgICAgICAgICBhbmltYXRvci5kdXJpbmcoZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICAgICAgICAgIGVsLmRpcnR5KGFuaW1hdGluZ1NoYXBlKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuZG9uZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gRklYTUUgQW5pbWF0b3Igd2lsbCBub3QgYmUgcmVtb3ZlZCBpZiB1c2UgYEFuaW1hdG9yI3N0b3BgIHRvIHN0b3AgYW5pbWF0aW9uXG4gICAgICAgICAgICAgICAgYW5pbWF0b3JzLnNwbGljZSh1dGlsLmluZGV4T2YoYW5pbWF0b3JzLCBhbmltYXRvciksIDEpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGFuaW1hdG9ycy5wdXNoKGFuaW1hdG9yKTtcblxuICAgICAgICAgICAgLy8gSWYgYW5pbWF0ZSBhZnRlciBhZGRlZCB0byB0aGUgenJlbmRlclxuICAgICAgICAgICAgaWYgKHpyKSB7XG4gICAgICAgICAgICAgICAgenIuYW5pbWF0aW9uLmFkZEFuaW1hdG9yKGFuaW1hdG9yKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGFuaW1hdG9yO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlgZzmraLliqjnlLtcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBmb3J3YXJkVG9MYXN0IElmIG1vdmUgdG8gbGFzdCBmcmFtZSBiZWZvcmUgc3RvcFxuICAgICAgICAgKi9cbiAgICAgICAgc3RvcEFuaW1hdGlvbjogZnVuY3Rpb24gKGZvcndhcmRUb0xhc3QpIHtcbiAgICAgICAgICAgIHZhciBhbmltYXRvcnMgPSB0aGlzLmFuaW1hdG9ycztcbiAgICAgICAgICAgIHZhciBsZW4gPSBhbmltYXRvcnMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGFuaW1hdG9yc1tpXS5zdG9wKGZvcndhcmRUb0xhc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYW5pbWF0b3JzLmxlbmd0aCA9IDA7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbdGltZT01MDBdIFRpbWUgaW4gbXNcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtlYXNpbmc9J2xpbmVhciddXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZGVsYXk9MF1cbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXVxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiAgLy8gQW5pbWF0ZSBwb3NpdGlvblxuICAgICAgICAgKiAgZWwuYW5pbWF0ZVRvKHtcbiAgICAgICAgICogICAgICBwb3NpdGlvbjogWzEwLCAxMF1cbiAgICAgICAgICogIH0sIGZ1bmN0aW9uICgpIHsgLy8gZG9uZSB9KVxuICAgICAgICAgKlxuICAgICAgICAgKiAgLy8gQW5pbWF0ZSBzaGFwZSwgc3R5bGUgYW5kIHBvc2l0aW9uIGluIDEwMG1zLCBkZWxheWVkIDEwMG1zLCB3aXRoIGN1YmljT3V0IGVhc2luZ1xuICAgICAgICAgKiAgZWwuYW5pbWF0ZVRvKHtcbiAgICAgICAgICogICAgICBzaGFwZToge1xuICAgICAgICAgKiAgICAgICAgICB3aWR0aDogNTAwXG4gICAgICAgICAqICAgICAgfSxcbiAgICAgICAgICogICAgICBzdHlsZToge1xuICAgICAgICAgKiAgICAgICAgICBmaWxsOiAncmVkJ1xuICAgICAgICAgKiAgICAgIH1cbiAgICAgICAgICogICAgICBwb3NpdGlvbjogWzEwLCAxMF1cbiAgICAgICAgICogIH0sIDEwMCwgMTAwLCAnY3ViaWNPdXQnLCBmdW5jdGlvbiAoKSB7IC8vIGRvbmUgfSlcbiAgICAgICAgICovXG4gICAgICAgICAvLyBUT0RPIFJldHVybiBhbmltYXRpb24ga2V5XG4gICAgICAgIGFuaW1hdGVUbzogZnVuY3Rpb24gKHRhcmdldCwgdGltZSwgZGVsYXksIGVhc2luZywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIC8vIGFuaW1hdGVUbyh0YXJnZXQsIHRpbWUsIGVhc2luZywgY2FsbGJhY2spO1xuICAgICAgICAgICAgaWYgKGlzU3RyaW5nKGRlbGF5KSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gZWFzaW5nO1xuICAgICAgICAgICAgICAgIGVhc2luZyA9IGRlbGF5O1xuICAgICAgICAgICAgICAgIGRlbGF5ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFuaW1hdGVUbyh0YXJnZXQsIHRpbWUsIGRlbGF5LCBjYWxsYmFjayk7XG4gICAgICAgICAgICBlbHNlIGlmIChpc0Z1bmN0aW9uKGVhc2luZykpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IGVhc2luZztcbiAgICAgICAgICAgICAgICBlYXNpbmcgPSAnbGluZWFyJztcbiAgICAgICAgICAgICAgICBkZWxheSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhbmltYXRlVG8odGFyZ2V0LCB0aW1lLCBjYWxsYmFjayk7XG4gICAgICAgICAgICBlbHNlIGlmIChpc0Z1bmN0aW9uKGRlbGF5KSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gZGVsYXk7XG4gICAgICAgICAgICAgICAgZGVsYXkgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYW5pbWF0ZVRvKHRhcmdldCwgY2FsbGJhY2spXG4gICAgICAgICAgICBlbHNlIGlmIChpc0Z1bmN0aW9uKHRpbWUpKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSB0aW1lO1xuICAgICAgICAgICAgICAgIHRpbWUgPSA1MDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhbmltYXRlVG8odGFyZ2V0KVxuICAgICAgICAgICAgZWxzZSBpZiAoIXRpbWUpIHtcbiAgICAgICAgICAgICAgICB0aW1lID0gNTAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU3RvcCBhbGwgcHJldmlvdXMgYW5pbWF0aW9uc1xuICAgICAgICAgICAgdGhpcy5zdG9wQW5pbWF0aW9uKCk7XG4gICAgICAgICAgICB0aGlzLl9hbmltYXRlVG9TaGFsbG93KCcnLCB0aGlzLCB0YXJnZXQsIHRpbWUsIGRlbGF5LCBlYXNpbmcsIGNhbGxiYWNrKTtcblxuICAgICAgICAgICAgLy8gQW5pbWF0b3JzIG1heSBiZSByZW1vdmVkIGltbWVkaWF0ZWx5IGFmdGVyIHN0YXJ0XG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBub3RoaW5nIHRvIGFuaW1hdGVcbiAgICAgICAgICAgIHZhciBhbmltYXRvcnMgPSB0aGlzLmFuaW1hdG9ycy5zbGljZSgpO1xuICAgICAgICAgICAgdmFyIGNvdW50ID0gYW5pbWF0b3JzLmxlbmd0aDtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGRvbmUoKSB7XG4gICAgICAgICAgICAgICAgY291bnQtLTtcbiAgICAgICAgICAgICAgICBpZiAoIWNvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBObyBhbmltYXRvcnMuIFRoaXMgc2hvdWxkIGJlIGNoZWNrZWQgYmVmb3JlIGFuaW1hdG9yc1tpXS5zdGFydCgpLFxuICAgICAgICAgICAgLy8gYmVjYXVzZSAnZG9uZScgbWF5IGJlIGV4ZWN1dGVkIGltbWVkaWF0ZWx5IGlmIG5vIG5lZWQgdG8gYW5pbWF0ZS5cbiAgICAgICAgICAgIGlmICghY291bnQpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU3RhcnQgYWZ0ZXIgYWxsIGFuaW1hdG9ycyBjcmVhdGVkXG4gICAgICAgICAgICAvLyBJbmNhc2UgYW55IGFuaW1hdG9yIGlzIGRvbmUgaW1tZWRpYXRlbHkgd2hlbiBhbGwgYW5pbWF0aW9uIHByb3BlcnRpZXMgYXJlIG5vdCBjaGFuZ2VkXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFuaW1hdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGFuaW1hdG9yc1tpXVxuICAgICAgICAgICAgICAgICAgICAuZG9uZShkb25lKVxuICAgICAgICAgICAgICAgICAgICAuc3RhcnQoZWFzaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGg9JydcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZT10aGlzXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFt0aW1lPTUwMF1cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtkZWxheT0wXVxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiAgLy8gQW5pbWF0ZSBwb3NpdGlvblxuICAgICAgICAgKiAgZWwuX2FuaW1hdGVUb1NoYWxsb3coe1xuICAgICAgICAgKiAgICAgIHBvc2l0aW9uOiBbMTAsIDEwXVxuICAgICAgICAgKiAgfSlcbiAgICAgICAgICpcbiAgICAgICAgICogIC8vIEFuaW1hdGUgc2hhcGUsIHN0eWxlIGFuZCBwb3NpdGlvbiBpbiAxMDBtcywgZGVsYXllZCAxMDBtc1xuICAgICAgICAgKiAgZWwuX2FuaW1hdGVUb1NoYWxsb3coe1xuICAgICAgICAgKiAgICAgIHNoYXBlOiB7XG4gICAgICAgICAqICAgICAgICAgIHdpZHRoOiA1MDBcbiAgICAgICAgICogICAgICB9LFxuICAgICAgICAgKiAgICAgIHN0eWxlOiB7XG4gICAgICAgICAqICAgICAgICAgIGZpbGw6ICdyZWQnXG4gICAgICAgICAqICAgICAgfVxuICAgICAgICAgKiAgICAgIHBvc2l0aW9uOiBbMTAsIDEwXVxuICAgICAgICAgKiAgfSwgMTAwLCAxMDApXG4gICAgICAgICAqL1xuICAgICAgICBfYW5pbWF0ZVRvU2hhbGxvdzogZnVuY3Rpb24gKHBhdGgsIHNvdXJjZSwgdGFyZ2V0LCB0aW1lLCBkZWxheSkge1xuICAgICAgICAgICAgdmFyIG9ialNoYWxsb3cgPSB7fTtcbiAgICAgICAgICAgIHZhciBwcm9wZXJ0eUNvdW50ID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIG5hbWUgaW4gdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0YXJnZXQuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZVtuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc09iamVjdCh0YXJnZXRbbmFtZV0pICYmICF1dGlsLmlzQXJyYXlMaWtlKHRhcmdldFtuYW1lXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FuaW1hdGVUb1NoYWxsb3coXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aCA/IHBhdGggKyAnLicgKyBuYW1lIDogbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VbbmFtZV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W25hbWVdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsYXlcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmpTaGFsbG93W25hbWVdID0gdGFyZ2V0W25hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHlDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRhcmdldFtuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEF0dHIgZGlyZWN0bHkgaWYgbm90IGhhcyBwcm9wZXJ0eVxuICAgICAgICAgICAgICAgICAgICAvLyBGSVhNRSwgaWYgc29tZSBwcm9wZXJ0eSBub3QgbmVlZGVkIGZvciBlbGVtZW50ID9cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dHIobmFtZSwgdGFyZ2V0W25hbWVdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHsgIC8vIFNoYXBlIG9yIHN0eWxlXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcHMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzW3BhdGhdID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wc1twYXRoXVtuYW1lXSA9IHRhcmdldFtuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cihwcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwcm9wZXJ0eUNvdW50ID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYW5pbWF0ZShwYXRoLCBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgLndoZW4odGltZSA9PSBudWxsID8gNTAwIDogdGltZSwgb2JqU2hhbGxvdylcbiAgICAgICAgICAgICAgICAgICAgLmRlbGF5KGRlbGF5IHx8IDApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IEFuaW1hdGFibGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS95eC9+L3pyZW5kZXIvbGliL21peGluL0FuaW1hdGFibGUuanNcbi8vIG1vZHVsZSBpZCA9IDEyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 129 */
/* unknown exports provided */
/* all exports used */
/*!*************************************************!*\
  !*** /home/yx/~/zrender/lib/mixin/Draggable.js ***!
  \*************************************************/
/***/ (function(module, exports) {

eval("// TODO Draggable for group\n// FIXME Draggable on element which has parent rotation or scale\n\n    function Draggable() {\n\n        this.on('mousedown', this._dragStart, this);\n        this.on('mousemove', this._drag, this);\n        this.on('mouseup', this._dragEnd, this);\n        this.on('globalout', this._dragEnd, this);\n        // this._dropTarget = null;\n        // this._draggingTarget = null;\n\n        // this._x = 0;\n        // this._y = 0;\n    }\n\n    Draggable.prototype = {\n\n        constructor: Draggable,\n\n        _dragStart: function (e) {\n            var draggingTarget = e.target;\n            if (draggingTarget && draggingTarget.draggable) {\n                this._draggingTarget = draggingTarget;\n                draggingTarget.dragging = true;\n                this._x = e.offsetX;\n                this._y = e.offsetY;\n\n                this.dispatchToElement(param(draggingTarget, e), 'dragstart', e.event);\n            }\n        },\n\n        _drag: function (e) {\n            var draggingTarget = this._draggingTarget;\n            if (draggingTarget) {\n\n                var x = e.offsetX;\n                var y = e.offsetY;\n\n                var dx = x - this._x;\n                var dy = y - this._y;\n                this._x = x;\n                this._y = y;\n\n                draggingTarget.drift(dx, dy, e);\n                this.dispatchToElement(param(draggingTarget, e), 'drag', e.event);\n\n                var dropTarget = this.findHover(x, y, draggingTarget).target;\n                var lastDropTarget = this._dropTarget;\n                this._dropTarget = dropTarget;\n\n                if (draggingTarget !== dropTarget) {\n                    if (lastDropTarget && dropTarget !== lastDropTarget) {\n                        this.dispatchToElement(param(lastDropTarget, e), 'dragleave', e.event);\n                    }\n                    if (dropTarget && dropTarget !== lastDropTarget) {\n                        this.dispatchToElement(param(dropTarget, e), 'dragenter', e.event);\n                    }\n                }\n            }\n        },\n\n        _dragEnd: function (e) {\n            var draggingTarget = this._draggingTarget;\n\n            if (draggingTarget) {\n                draggingTarget.dragging = false;\n            }\n\n            this.dispatchToElement(param(draggingTarget, e), 'dragend', e.event);\n\n            if (this._dropTarget) {\n                this.dispatchToElement(param(this._dropTarget, e), 'drop', e.event);\n            }\n\n            this._draggingTarget = null;\n            this._dropTarget = null;\n        }\n\n    };\n\n    function param(target, e) {\n        return {target: target, topTarget: e && e.topTarget};\n    }\n\n    module.exports = Draggable;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy9ob21lL3l4L34venJlbmRlci9saWIvbWl4aW4vRHJhZ2dhYmxlLmpzPzcwMmIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVE9ETyBEcmFnZ2FibGUgZm9yIGdyb3VwXG4vLyBGSVhNRSBEcmFnZ2FibGUgb24gZWxlbWVudCB3aGljaCBoYXMgcGFyZW50IHJvdGF0aW9uIG9yIHNjYWxlXG5cbiAgICBmdW5jdGlvbiBEcmFnZ2FibGUoKSB7XG5cbiAgICAgICAgdGhpcy5vbignbW91c2Vkb3duJywgdGhpcy5fZHJhZ1N0YXJ0LCB0aGlzKTtcbiAgICAgICAgdGhpcy5vbignbW91c2Vtb3ZlJywgdGhpcy5fZHJhZywgdGhpcyk7XG4gICAgICAgIHRoaXMub24oJ21vdXNldXAnLCB0aGlzLl9kcmFnRW5kLCB0aGlzKTtcbiAgICAgICAgdGhpcy5vbignZ2xvYmFsb3V0JywgdGhpcy5fZHJhZ0VuZCwgdGhpcyk7XG4gICAgICAgIC8vIHRoaXMuX2Ryb3BUYXJnZXQgPSBudWxsO1xuICAgICAgICAvLyB0aGlzLl9kcmFnZ2luZ1RhcmdldCA9IG51bGw7XG5cbiAgICAgICAgLy8gdGhpcy5feCA9IDA7XG4gICAgICAgIC8vIHRoaXMuX3kgPSAwO1xuICAgIH1cblxuICAgIERyYWdnYWJsZS5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IERyYWdnYWJsZSxcblxuICAgICAgICBfZHJhZ1N0YXJ0OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdmFyIGRyYWdnaW5nVGFyZ2V0ID0gZS50YXJnZXQ7XG4gICAgICAgICAgICBpZiAoZHJhZ2dpbmdUYXJnZXQgJiYgZHJhZ2dpbmdUYXJnZXQuZHJhZ2dhYmxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhZ2dpbmdUYXJnZXQgPSBkcmFnZ2luZ1RhcmdldDtcbiAgICAgICAgICAgICAgICBkcmFnZ2luZ1RhcmdldC5kcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5feCA9IGUub2Zmc2V0WDtcbiAgICAgICAgICAgICAgICB0aGlzLl95ID0gZS5vZmZzZXRZO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaFRvRWxlbWVudChwYXJhbShkcmFnZ2luZ1RhcmdldCwgZSksICdkcmFnc3RhcnQnLCBlLmV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfZHJhZzogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciBkcmFnZ2luZ1RhcmdldCA9IHRoaXMuX2RyYWdnaW5nVGFyZ2V0O1xuICAgICAgICAgICAgaWYgKGRyYWdnaW5nVGFyZ2V0KSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgeCA9IGUub2Zmc2V0WDtcbiAgICAgICAgICAgICAgICB2YXIgeSA9IGUub2Zmc2V0WTtcblxuICAgICAgICAgICAgICAgIHZhciBkeCA9IHggLSB0aGlzLl94O1xuICAgICAgICAgICAgICAgIHZhciBkeSA9IHkgLSB0aGlzLl95O1xuICAgICAgICAgICAgICAgIHRoaXMuX3ggPSB4O1xuICAgICAgICAgICAgICAgIHRoaXMuX3kgPSB5O1xuXG4gICAgICAgICAgICAgICAgZHJhZ2dpbmdUYXJnZXQuZHJpZnQoZHgsIGR5LCBlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoVG9FbGVtZW50KHBhcmFtKGRyYWdnaW5nVGFyZ2V0LCBlKSwgJ2RyYWcnLCBlLmV2ZW50KTtcblxuICAgICAgICAgICAgICAgIHZhciBkcm9wVGFyZ2V0ID0gdGhpcy5maW5kSG92ZXIoeCwgeSwgZHJhZ2dpbmdUYXJnZXQpLnRhcmdldDtcbiAgICAgICAgICAgICAgICB2YXIgbGFzdERyb3BUYXJnZXQgPSB0aGlzLl9kcm9wVGFyZ2V0O1xuICAgICAgICAgICAgICAgIHRoaXMuX2Ryb3BUYXJnZXQgPSBkcm9wVGFyZ2V0O1xuXG4gICAgICAgICAgICAgICAgaWYgKGRyYWdnaW5nVGFyZ2V0ICE9PSBkcm9wVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsYXN0RHJvcFRhcmdldCAmJiBkcm9wVGFyZ2V0ICE9PSBsYXN0RHJvcFRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaFRvRWxlbWVudChwYXJhbShsYXN0RHJvcFRhcmdldCwgZSksICdkcmFnbGVhdmUnLCBlLmV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZHJvcFRhcmdldCAmJiBkcm9wVGFyZ2V0ICE9PSBsYXN0RHJvcFRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaFRvRWxlbWVudChwYXJhbShkcm9wVGFyZ2V0LCBlKSwgJ2RyYWdlbnRlcicsIGUuZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIF9kcmFnRW5kOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdmFyIGRyYWdnaW5nVGFyZ2V0ID0gdGhpcy5fZHJhZ2dpbmdUYXJnZXQ7XG5cbiAgICAgICAgICAgIGlmIChkcmFnZ2luZ1RhcmdldCkge1xuICAgICAgICAgICAgICAgIGRyYWdnaW5nVGFyZ2V0LmRyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hUb0VsZW1lbnQocGFyYW0oZHJhZ2dpbmdUYXJnZXQsIGUpLCAnZHJhZ2VuZCcsIGUuZXZlbnQpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fZHJvcFRhcmdldCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hUb0VsZW1lbnQocGFyYW0odGhpcy5fZHJvcFRhcmdldCwgZSksICdkcm9wJywgZS5ldmVudCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX2RyYWdnaW5nVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX2Ryb3BUYXJnZXQgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcGFyYW0odGFyZ2V0LCBlKSB7XG4gICAgICAgIHJldHVybiB7dGFyZ2V0OiB0YXJnZXQsIHRvcFRhcmdldDogZSAmJiBlLnRvcFRhcmdldH07XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBEcmFnZ2FibGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS95eC9+L3pyZW5kZXIvbGliL21peGluL0RyYWdnYWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gMTI5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 130 */
/* unknown exports provided */
/* all exports used */
/*!*******************************************!*\
  !*** /home/yx/~/zrender/lib/tool/path.js ***!
  \*******************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var Path = __webpack_require__(/*! ../graphic/Path */ 7);\n    var PathProxy = __webpack_require__(/*! ../core/PathProxy */ 25);\n    var transformPath = __webpack_require__(/*! ./transformPath */ 131);\n\n    // command chars\n    var cc = [\n        'm', 'M', 'l', 'L', 'v', 'V', 'h', 'H', 'z', 'Z',\n        'c', 'C', 'q', 'Q', 't', 'T', 's', 'S', 'a', 'A'\n    ];\n\n    var mathSqrt = Math.sqrt;\n    var mathSin = Math.sin;\n    var mathCos = Math.cos;\n    var PI = Math.PI;\n\n    var vMag = function(v) {\n        return Math.sqrt(v[0] * v[0] + v[1] * v[1]);\n    };\n    var vRatio = function(u, v) {\n        return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));\n    };\n    var vAngle = function(u, v) {\n        return (u[0] * v[1] < u[1] * v[0] ? -1 : 1)\n                * Math.acos(vRatio(u, v));\n    };\n\n    function processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {\n        var psi = psiDeg * (PI / 180.0);\n        var xp = mathCos(psi) * (x1 - x2) / 2.0\n                 + mathSin(psi) * (y1 - y2) / 2.0;\n        var yp = -1 * mathSin(psi) * (x1 - x2) / 2.0\n                 + mathCos(psi) * (y1 - y2) / 2.0;\n\n        var lambda = (xp * xp) / (rx * rx) + (yp * yp) / (ry * ry);\n\n        if (lambda > 1) {\n            rx *= mathSqrt(lambda);\n            ry *= mathSqrt(lambda);\n        }\n\n        var f = (fa === fs ? -1 : 1)\n            * mathSqrt((((rx * rx) * (ry * ry))\n                    - ((rx * rx) * (yp * yp))\n                    - ((ry * ry) * (xp * xp))) / ((rx * rx) * (yp * yp)\n                    + (ry * ry) * (xp * xp))\n                ) || 0;\n\n        var cxp = f * rx * yp / ry;\n        var cyp = f * -ry * xp / rx;\n\n        var cx = (x1 + x2) / 2.0\n                 + mathCos(psi) * cxp\n                 - mathSin(psi) * cyp;\n        var cy = (y1 + y2) / 2.0\n                + mathSin(psi) * cxp\n                + mathCos(psi) * cyp;\n\n        var theta = vAngle([ 1, 0 ], [ (xp - cxp) / rx, (yp - cyp) / ry ]);\n        var u = [ (xp - cxp) / rx, (yp - cyp) / ry ];\n        var v = [ (-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry ];\n        var dTheta = vAngle(u, v);\n\n        if (vRatio(u, v) <= -1) {\n            dTheta = PI;\n        }\n        if (vRatio(u, v) >= 1) {\n            dTheta = 0;\n        }\n        if (fs === 0 && dTheta > 0) {\n            dTheta = dTheta - 2 * PI;\n        }\n        if (fs === 1 && dTheta < 0) {\n            dTheta = dTheta + 2 * PI;\n        }\n\n        path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);\n    }\n\n    function createPathProxyFromString(data) {\n        if (!data) {\n            return [];\n        }\n\n        // command string\n        var cs = data.replace(/-/g, ' -')\n            .replace(/  /g, ' ')\n            .replace(/ /g, ',')\n            .replace(/,,/g, ',');\n\n        var n;\n        // create pipes so that we can split the data\n        for (n = 0; n < cc.length; n++) {\n            cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);\n        }\n\n        // create array\n        var arr = cs.split('|');\n        // init context point\n        var cpx = 0;\n        var cpy = 0;\n\n        var path = new PathProxy();\n        var CMD = PathProxy.CMD;\n\n        var prevCmd;\n        for (n = 1; n < arr.length; n++) {\n            var str = arr[n];\n            var c = str.charAt(0);\n            var off = 0;\n            var p = str.slice(1).replace(/e,-/g, 'e-').split(',');\n            var cmd;\n\n            if (p.length > 0 && p[0] === '') {\n                p.shift();\n            }\n\n            for (var i = 0; i < p.length; i++) {\n                p[i] = parseFloat(p[i]);\n            }\n            while (off < p.length && !isNaN(p[off])) {\n                if (isNaN(p[0])) {\n                    break;\n                }\n                var ctlPtx;\n                var ctlPty;\n\n                var rx;\n                var ry;\n                var psi;\n                var fa;\n                var fs;\n\n                var x1 = cpx;\n                var y1 = cpy;\n\n                // convert l, H, h, V, and v to L\n                switch (c) {\n                    case 'l':\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'L':\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'm':\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.M;\n                        path.addData(cmd, cpx, cpy);\n                        c = 'l';\n                        break;\n                    case 'M':\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.M;\n                        path.addData(cmd, cpx, cpy);\n                        c = 'L';\n                        break;\n                    case 'h':\n                        cpx += p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'H':\n                        cpx = p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'v':\n                        cpy += p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'V':\n                        cpy = p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'C':\n                        cmd = CMD.C;\n                        path.addData(\n                            cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]\n                        );\n                        cpx = p[off - 2];\n                        cpy = p[off - 1];\n                        break;\n                    case 'c':\n                        cmd = CMD.C;\n                        path.addData(\n                            cmd,\n                            p[off++] + cpx, p[off++] + cpy,\n                            p[off++] + cpx, p[off++] + cpy,\n                            p[off++] + cpx, p[off++] + cpy\n                        );\n                        cpx += p[off - 2];\n                        cpy += p[off - 1];\n                        break;\n                    case 'S':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        var len = path.len();\n                        var pathData = path.data;\n                        if (prevCmd === CMD.C) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cmd = CMD.C;\n                        x1 = p[off++];\n                        y1 = p[off++];\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n                        break;\n                    case 's':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        var len = path.len();\n                        var pathData = path.data;\n                        if (prevCmd === CMD.C) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cmd = CMD.C;\n                        x1 = cpx + p[off++];\n                        y1 = cpy + p[off++];\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n                        break;\n                    case 'Q':\n                        x1 = p[off++];\n                        y1 = p[off++];\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, x1, y1, cpx, cpy);\n                        break;\n                    case 'q':\n                        x1 = p[off++] + cpx;\n                        y1 = p[off++] + cpy;\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, x1, y1, cpx, cpy);\n                        break;\n                    case 'T':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        var len = path.len();\n                        var pathData = path.data;\n                        if (prevCmd === CMD.Q) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n                        break;\n                    case 't':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        var len = path.len();\n                        var pathData = path.data;\n                        if (prevCmd === CMD.Q) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n                        break;\n                    case 'A':\n                        rx = p[off++];\n                        ry = p[off++];\n                        psi = p[off++];\n                        fa = p[off++];\n                        fs = p[off++];\n\n                        x1 = cpx, y1 = cpy;\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.A;\n                        processArc(\n                            x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path\n                        );\n                        break;\n                    case 'a':\n                        rx = p[off++];\n                        ry = p[off++];\n                        psi = p[off++];\n                        fa = p[off++];\n                        fs = p[off++];\n\n                        x1 = cpx, y1 = cpy;\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.A;\n                        processArc(\n                            x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path\n                        );\n                        break;\n                }\n            }\n\n            if (c === 'z' || c === 'Z') {\n                cmd = CMD.Z;\n                path.addData(cmd);\n            }\n\n            prevCmd = cmd;\n        }\n\n        path.toStatic();\n\n        return path;\n    }\n\n    // TODO Optimize double memory cost problem\n    function createPathOptions(str, opts) {\n        var pathProxy = createPathProxyFromString(str);\n        opts = opts || {};\n        opts.buildPath = function (path) {\n            if (path.setData) {\n                path.setData(pathProxy.data);\n                // Svg and vml renderer don't have context\n                var ctx = path.getContext();\n                if (ctx) {\n                    path.rebuildPath(ctx);\n                }\n            }\n            else {\n                var ctx = path;\n                pathProxy.rebuildPath(ctx);\n            }\n        };\n\n        opts.applyTransform = function (m) {\n            transformPath(pathProxy, m);\n\n            this.dirty(true);\n        };\n\n        return opts;\n    }\n\n    module.exports = {\n        /**\n         * Create a Path object from path string data\n         * http://www.w3.org/TR/SVG/paths.html#PathData\n         * @param  {Object} opts Other options\n         */\n        createFromString: function (str, opts) {\n            return new Path(createPathOptions(str, opts));\n        },\n\n        /**\n         * Create a Path class from path string data\n         * @param  {string} str\n         * @param  {Object} opts Other options\n         */\n        extendFromString: function (str, opts) {\n            return Path.extend(createPathOptions(str, opts));\n        },\n\n        /**\n         * Merge multiple paths\n         */\n        // TODO Apply transform\n        // TODO stroke dash\n        // TODO Optimize double memory cost problem\n        mergePath: function (pathEls, opts) {\n            var pathList = [];\n            var len = pathEls.length;\n            for (var i = 0; i < len; i++) {\n                var pathEl = pathEls[i];\n                if (!pathEl.path) {\n                    pathEl.createPathProxy();\n                }\n                if (pathEl.__dirtyPath) {\n                    pathEl.buildPath(pathEl.path, pathEl.shape, true);\n                }\n                pathList.push(pathEl.path);\n            }\n\n            var pathBundle = new Path(opts);\n            // Need path proxy.\n            pathBundle.createPathProxy();\n            pathBundle.buildPath = function (path) {\n                path.appendPath(pathList);\n                // Svg and vml renderer don't have context\n                var ctx = path.getContext();\n                if (ctx) {\n                    path.rebuildPath(ctx);\n                }\n            };\n\n            return pathBundle;\n        }\n    };\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy9ob21lL3l4L34venJlbmRlci9saWIvdG9vbC9wYXRoLmpzPzJmZWEiXSwic291cmNlc0NvbnRlbnQiOlsiXG5cbiAgICB2YXIgUGF0aCA9IHJlcXVpcmUoJy4uL2dyYXBoaWMvUGF0aCcpO1xuICAgIHZhciBQYXRoUHJveHkgPSByZXF1aXJlKCcuLi9jb3JlL1BhdGhQcm94eScpO1xuICAgIHZhciB0cmFuc2Zvcm1QYXRoID0gcmVxdWlyZSgnLi90cmFuc2Zvcm1QYXRoJyk7XG5cbiAgICAvLyBjb21tYW5kIGNoYXJzXG4gICAgdmFyIGNjID0gW1xuICAgICAgICAnbScsICdNJywgJ2wnLCAnTCcsICd2JywgJ1YnLCAnaCcsICdIJywgJ3onLCAnWicsXG4gICAgICAgICdjJywgJ0MnLCAncScsICdRJywgJ3QnLCAnVCcsICdzJywgJ1MnLCAnYScsICdBJ1xuICAgIF07XG5cbiAgICB2YXIgbWF0aFNxcnQgPSBNYXRoLnNxcnQ7XG4gICAgdmFyIG1hdGhTaW4gPSBNYXRoLnNpbjtcbiAgICB2YXIgbWF0aENvcyA9IE1hdGguY29zO1xuICAgIHZhciBQSSA9IE1hdGguUEk7XG5cbiAgICB2YXIgdk1hZyA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydCh2WzBdICogdlswXSArIHZbMV0gKiB2WzFdKTtcbiAgICB9O1xuICAgIHZhciB2UmF0aW8gPSBmdW5jdGlvbih1LCB2KSB7XG4gICAgICAgIHJldHVybiAodVswXSAqIHZbMF0gKyB1WzFdICogdlsxXSkgLyAodk1hZyh1KSAqIHZNYWcodikpO1xuICAgIH07XG4gICAgdmFyIHZBbmdsZSA9IGZ1bmN0aW9uKHUsIHYpIHtcbiAgICAgICAgcmV0dXJuICh1WzBdICogdlsxXSA8IHVbMV0gKiB2WzBdID8gLTEgOiAxKVxuICAgICAgICAgICAgICAgICogTWF0aC5hY29zKHZSYXRpbyh1LCB2KSk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHByb2Nlc3NBcmMoeDEsIHkxLCB4MiwgeTIsIGZhLCBmcywgcngsIHJ5LCBwc2lEZWcsIGNtZCwgcGF0aCkge1xuICAgICAgICB2YXIgcHNpID0gcHNpRGVnICogKFBJIC8gMTgwLjApO1xuICAgICAgICB2YXIgeHAgPSBtYXRoQ29zKHBzaSkgKiAoeDEgLSB4MikgLyAyLjBcbiAgICAgICAgICAgICAgICAgKyBtYXRoU2luKHBzaSkgKiAoeTEgLSB5MikgLyAyLjA7XG4gICAgICAgIHZhciB5cCA9IC0xICogbWF0aFNpbihwc2kpICogKHgxIC0geDIpIC8gMi4wXG4gICAgICAgICAgICAgICAgICsgbWF0aENvcyhwc2kpICogKHkxIC0geTIpIC8gMi4wO1xuXG4gICAgICAgIHZhciBsYW1iZGEgPSAoeHAgKiB4cCkgLyAocnggKiByeCkgKyAoeXAgKiB5cCkgLyAocnkgKiByeSk7XG5cbiAgICAgICAgaWYgKGxhbWJkYSA+IDEpIHtcbiAgICAgICAgICAgIHJ4ICo9IG1hdGhTcXJ0KGxhbWJkYSk7XG4gICAgICAgICAgICByeSAqPSBtYXRoU3FydChsYW1iZGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGYgPSAoZmEgPT09IGZzID8gLTEgOiAxKVxuICAgICAgICAgICAgKiBtYXRoU3FydCgoKChyeCAqIHJ4KSAqIChyeSAqIHJ5KSlcbiAgICAgICAgICAgICAgICAgICAgLSAoKHJ4ICogcngpICogKHlwICogeXApKVxuICAgICAgICAgICAgICAgICAgICAtICgocnkgKiByeSkgKiAoeHAgKiB4cCkpKSAvICgocnggKiByeCkgKiAoeXAgKiB5cClcbiAgICAgICAgICAgICAgICAgICAgKyAocnkgKiByeSkgKiAoeHAgKiB4cCkpXG4gICAgICAgICAgICAgICAgKSB8fCAwO1xuXG4gICAgICAgIHZhciBjeHAgPSBmICogcnggKiB5cCAvIHJ5O1xuICAgICAgICB2YXIgY3lwID0gZiAqIC1yeSAqIHhwIC8gcng7XG5cbiAgICAgICAgdmFyIGN4ID0gKHgxICsgeDIpIC8gMi4wXG4gICAgICAgICAgICAgICAgICsgbWF0aENvcyhwc2kpICogY3hwXG4gICAgICAgICAgICAgICAgIC0gbWF0aFNpbihwc2kpICogY3lwO1xuICAgICAgICB2YXIgY3kgPSAoeTEgKyB5MikgLyAyLjBcbiAgICAgICAgICAgICAgICArIG1hdGhTaW4ocHNpKSAqIGN4cFxuICAgICAgICAgICAgICAgICsgbWF0aENvcyhwc2kpICogY3lwO1xuXG4gICAgICAgIHZhciB0aGV0YSA9IHZBbmdsZShbIDEsIDAgXSwgWyAoeHAgLSBjeHApIC8gcngsICh5cCAtIGN5cCkgLyByeSBdKTtcbiAgICAgICAgdmFyIHUgPSBbICh4cCAtIGN4cCkgLyByeCwgKHlwIC0gY3lwKSAvIHJ5IF07XG4gICAgICAgIHZhciB2ID0gWyAoLTEgKiB4cCAtIGN4cCkgLyByeCwgKC0xICogeXAgLSBjeXApIC8gcnkgXTtcbiAgICAgICAgdmFyIGRUaGV0YSA9IHZBbmdsZSh1LCB2KTtcblxuICAgICAgICBpZiAodlJhdGlvKHUsIHYpIDw9IC0xKSB7XG4gICAgICAgICAgICBkVGhldGEgPSBQSTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodlJhdGlvKHUsIHYpID49IDEpIHtcbiAgICAgICAgICAgIGRUaGV0YSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZzID09PSAwICYmIGRUaGV0YSA+IDApIHtcbiAgICAgICAgICAgIGRUaGV0YSA9IGRUaGV0YSAtIDIgKiBQSTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnMgPT09IDEgJiYgZFRoZXRhIDwgMCkge1xuICAgICAgICAgICAgZFRoZXRhID0gZFRoZXRhICsgMiAqIFBJO1xuICAgICAgICB9XG5cbiAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgY3gsIGN5LCByeCwgcnksIHRoZXRhLCBkVGhldGEsIHBzaSwgZnMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVBhdGhQcm94eUZyb21TdHJpbmcoZGF0YSkge1xuICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbW1hbmQgc3RyaW5nXG4gICAgICAgIHZhciBjcyA9IGRhdGEucmVwbGFjZSgvLS9nLCAnIC0nKVxuICAgICAgICAgICAgLnJlcGxhY2UoLyAgL2csICcgJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC8gL2csICcsJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC8sLC9nLCAnLCcpO1xuXG4gICAgICAgIHZhciBuO1xuICAgICAgICAvLyBjcmVhdGUgcGlwZXMgc28gdGhhdCB3ZSBjYW4gc3BsaXQgdGhlIGRhdGFcbiAgICAgICAgZm9yIChuID0gMDsgbiA8IGNjLmxlbmd0aDsgbisrKSB7XG4gICAgICAgICAgICBjcyA9IGNzLnJlcGxhY2UobmV3IFJlZ0V4cChjY1tuXSwgJ2cnKSwgJ3wnICsgY2Nbbl0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY3JlYXRlIGFycmF5XG4gICAgICAgIHZhciBhcnIgPSBjcy5zcGxpdCgnfCcpO1xuICAgICAgICAvLyBpbml0IGNvbnRleHQgcG9pbnRcbiAgICAgICAgdmFyIGNweCA9IDA7XG4gICAgICAgIHZhciBjcHkgPSAwO1xuXG4gICAgICAgIHZhciBwYXRoID0gbmV3IFBhdGhQcm94eSgpO1xuICAgICAgICB2YXIgQ01EID0gUGF0aFByb3h5LkNNRDtcblxuICAgICAgICB2YXIgcHJldkNtZDtcbiAgICAgICAgZm9yIChuID0gMTsgbiA8IGFyci5sZW5ndGg7IG4rKykge1xuICAgICAgICAgICAgdmFyIHN0ciA9IGFycltuXTtcbiAgICAgICAgICAgIHZhciBjID0gc3RyLmNoYXJBdCgwKTtcbiAgICAgICAgICAgIHZhciBvZmYgPSAwO1xuICAgICAgICAgICAgdmFyIHAgPSBzdHIuc2xpY2UoMSkucmVwbGFjZSgvZSwtL2csICdlLScpLnNwbGl0KCcsJyk7XG4gICAgICAgICAgICB2YXIgY21kO1xuXG4gICAgICAgICAgICBpZiAocC5sZW5ndGggPiAwICYmIHBbMF0gPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgcC5zaGlmdCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBwW2ldID0gcGFyc2VGbG9hdChwW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChvZmYgPCBwLmxlbmd0aCAmJiAhaXNOYU4ocFtvZmZdKSkge1xuICAgICAgICAgICAgICAgIGlmIChpc05hTihwWzBdKSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGN0bFB0eDtcbiAgICAgICAgICAgICAgICB2YXIgY3RsUHR5O1xuXG4gICAgICAgICAgICAgICAgdmFyIHJ4O1xuICAgICAgICAgICAgICAgIHZhciByeTtcbiAgICAgICAgICAgICAgICB2YXIgcHNpO1xuICAgICAgICAgICAgICAgIHZhciBmYTtcbiAgICAgICAgICAgICAgICB2YXIgZnM7XG5cbiAgICAgICAgICAgICAgICB2YXIgeDEgPSBjcHg7XG4gICAgICAgICAgICAgICAgdmFyIHkxID0gY3B5O1xuXG4gICAgICAgICAgICAgICAgLy8gY29udmVydCBsLCBILCBoLCBWLCBhbmQgdiB0byBMXG4gICAgICAgICAgICAgICAgc3dpdGNoIChjKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2wnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ICs9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ICs9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gQ01ELkw7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjcHgsIGNweSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnTCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gQ01ELkw7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjcHgsIGNweSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggKz0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgKz0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSBDTUQuTTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGNweCwgY3B5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMgPSAnbCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnTSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gQ01ELk07XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjcHgsIGNweSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjID0gJ0wnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2gnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ICs9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gQ01ELkw7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjcHgsIGNweSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnSCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9IENNRC5MO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgY3B4LCBjcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3YnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ICs9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gQ01ELkw7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjcHgsIGNweSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnVic6XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9IENNRC5MO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgY3B4LCBjcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0MnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gQ01ELkM7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoLmFkZERhdGEoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY21kLCBwW29mZisrXSwgcFtvZmYrK10sIHBbb2ZmKytdLCBwW29mZisrXSwgcFtvZmYrK10sIHBbb2ZmKytdXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ID0gcFtvZmYgLSAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSA9IHBbb2ZmIC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSBDTUQuQztcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGguYWRkRGF0YShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcFtvZmYrK10gKyBjcHgsIHBbb2ZmKytdICsgY3B5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBbb2ZmKytdICsgY3B4LCBwW29mZisrXSArIGNweSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwW29mZisrXSArIGNweCwgcFtvZmYrK10gKyBjcHlcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggKz0gcFtvZmYgLSAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSArPSBwW29mZiAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1MnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR4ID0gY3B4O1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR5ID0gY3B5O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlbiA9IHBhdGgubGVuKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGF0aERhdGEgPSBwYXRoLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJldkNtZCA9PT0gQ01ELkMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHggKz0gY3B4IC0gcGF0aERhdGFbbGVuIC0gNF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR5ICs9IGNweSAtIHBhdGhEYXRhW2xlbiAtIDNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gQ01ELkM7XG4gICAgICAgICAgICAgICAgICAgICAgICB4MSA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgeTEgPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjdGxQdHgsIGN0bFB0eSwgeDEsIHkxLCBjcHgsIGNweSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHggPSBjcHg7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHkgPSBjcHk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGVuID0gcGF0aC5sZW4oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXRoRGF0YSA9IHBhdGguZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmV2Q21kID09PSBDTUQuQykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eCArPSBjcHggLSBwYXRoRGF0YVtsZW4gLSA0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHkgKz0gY3B5IC0gcGF0aERhdGFbbGVuIC0gM107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSBDTUQuQztcbiAgICAgICAgICAgICAgICAgICAgICAgIHgxID0gY3B4ICsgcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICB5MSA9IGNweSArIHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ICs9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ICs9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgY3RsUHR4LCBjdGxQdHksIHgxLCB5MSwgY3B4LCBjcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1EnOlxuICAgICAgICAgICAgICAgICAgICAgICAgeDEgPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkxID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gQ01ELlE7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCB4MSwgeTEsIGNweCwgY3B5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdxJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHgxID0gcFtvZmYrK10gKyBjcHg7XG4gICAgICAgICAgICAgICAgICAgICAgICB5MSA9IHBbb2ZmKytdICsgY3B5O1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ICs9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ICs9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gQ01ELlE7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCB4MSwgeTEsIGNweCwgY3B5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdUJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eCA9IGNweDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eSA9IGNweTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZW4gPSBwYXRoLmxlbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhdGhEYXRhID0gcGF0aC5kYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZDbWQgPT09IENNRC5RKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR4ICs9IGNweCAtIHBhdGhEYXRhW2xlbiAtIDRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eSArPSBjcHkgLSBwYXRoRGF0YVtsZW4gLSAzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSBDTUQuUTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGN0bFB0eCwgY3RsUHR5LCBjcHgsIGNweSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHggPSBjcHg7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHkgPSBjcHk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGVuID0gcGF0aC5sZW4oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXRoRGF0YSA9IHBhdGguZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmV2Q21kID09PSBDTUQuUSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eCArPSBjcHggLSBwYXRoRGF0YVtsZW4gLSA0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHkgKz0gY3B5IC0gcGF0aERhdGFbbGVuIC0gM107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggKz0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgKz0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSBDTUQuUTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGN0bFB0eCwgY3RsUHR5LCBjcHgsIGNweSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnQSc6XG4gICAgICAgICAgICAgICAgICAgICAgICByeCA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcnkgPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBzaSA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmEgPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZzID0gcFtvZmYrK107XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHgxID0gY3B4LCB5MSA9IGNweTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSBDTUQuQTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3NBcmMoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDEsIHkxLCBjcHgsIGNweSwgZmEsIGZzLCByeCwgcnksIHBzaSwgY21kLCBwYXRoXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2EnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcnggPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ5ID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBwc2kgPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBmcyA9IHBbb2ZmKytdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB4MSA9IGNweCwgeTEgPSBjcHk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggKz0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgKz0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSBDTUQuQTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3NBcmMoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDEsIHkxLCBjcHgsIGNweSwgZmEsIGZzLCByeCwgcnksIHBzaSwgY21kLCBwYXRoXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYyA9PT0gJ3onIHx8IGMgPT09ICdaJykge1xuICAgICAgICAgICAgICAgIGNtZCA9IENNRC5aO1xuICAgICAgICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwcmV2Q21kID0gY21kO1xuICAgICAgICB9XG5cbiAgICAgICAgcGF0aC50b1N0YXRpYygpO1xuXG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgIH1cblxuICAgIC8vIFRPRE8gT3B0aW1pemUgZG91YmxlIG1lbW9yeSBjb3N0IHByb2JsZW1cbiAgICBmdW5jdGlvbiBjcmVhdGVQYXRoT3B0aW9ucyhzdHIsIG9wdHMpIHtcbiAgICAgICAgdmFyIHBhdGhQcm94eSA9IGNyZWF0ZVBhdGhQcm94eUZyb21TdHJpbmcoc3RyKTtcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgICAgIG9wdHMuYnVpbGRQYXRoID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgICAgIGlmIChwYXRoLnNldERhdGEpIHtcbiAgICAgICAgICAgICAgICBwYXRoLnNldERhdGEocGF0aFByb3h5LmRhdGEpO1xuICAgICAgICAgICAgICAgIC8vIFN2ZyBhbmQgdm1sIHJlbmRlcmVyIGRvbid0IGhhdmUgY29udGV4dFxuICAgICAgICAgICAgICAgIHZhciBjdHggPSBwYXRoLmdldENvbnRleHQoKTtcbiAgICAgICAgICAgICAgICBpZiAoY3R4KSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGgucmVidWlsZFBhdGgoY3R4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgY3R4ID0gcGF0aDtcbiAgICAgICAgICAgICAgICBwYXRoUHJveHkucmVidWlsZFBhdGgoY3R4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBvcHRzLmFwcGx5VHJhbnNmb3JtID0gZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybVBhdGgocGF0aFByb3h5LCBtKTtcblxuICAgICAgICAgICAgdGhpcy5kaXJ0eSh0cnVlKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gb3B0cztcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIFBhdGggb2JqZWN0IGZyb20gcGF0aCBzdHJpbmcgZGF0YVxuICAgICAgICAgKiBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvcGF0aHMuaHRtbCNQYXRoRGF0YVxuICAgICAgICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wdHMgT3RoZXIgb3B0aW9uc1xuICAgICAgICAgKi9cbiAgICAgICAgY3JlYXRlRnJvbVN0cmluZzogZnVuY3Rpb24gKHN0ciwgb3B0cykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQYXRoKGNyZWF0ZVBhdGhPcHRpb25zKHN0ciwgb3B0cykpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYSBQYXRoIGNsYXNzIGZyb20gcGF0aCBzdHJpbmcgZGF0YVxuICAgICAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IHN0clxuICAgICAgICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wdHMgT3RoZXIgb3B0aW9uc1xuICAgICAgICAgKi9cbiAgICAgICAgZXh0ZW5kRnJvbVN0cmluZzogZnVuY3Rpb24gKHN0ciwgb3B0cykge1xuICAgICAgICAgICAgcmV0dXJuIFBhdGguZXh0ZW5kKGNyZWF0ZVBhdGhPcHRpb25zKHN0ciwgb3B0cykpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNZXJnZSBtdWx0aXBsZSBwYXRoc1xuICAgICAgICAgKi9cbiAgICAgICAgLy8gVE9ETyBBcHBseSB0cmFuc2Zvcm1cbiAgICAgICAgLy8gVE9ETyBzdHJva2UgZGFzaFxuICAgICAgICAvLyBUT0RPIE9wdGltaXplIGRvdWJsZSBtZW1vcnkgY29zdCBwcm9ibGVtXG4gICAgICAgIG1lcmdlUGF0aDogZnVuY3Rpb24gKHBhdGhFbHMsIG9wdHMpIHtcbiAgICAgICAgICAgIHZhciBwYXRoTGlzdCA9IFtdO1xuICAgICAgICAgICAgdmFyIGxlbiA9IHBhdGhFbHMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBwYXRoRWwgPSBwYXRoRWxzW2ldO1xuICAgICAgICAgICAgICAgIGlmICghcGF0aEVsLnBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aEVsLmNyZWF0ZVBhdGhQcm94eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocGF0aEVsLl9fZGlydHlQYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGhFbC5idWlsZFBhdGgocGF0aEVsLnBhdGgsIHBhdGhFbC5zaGFwZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhdGhMaXN0LnB1c2gocGF0aEVsLnBhdGgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcGF0aEJ1bmRsZSA9IG5ldyBQYXRoKG9wdHMpO1xuICAgICAgICAgICAgLy8gTmVlZCBwYXRoIHByb3h5LlxuICAgICAgICAgICAgcGF0aEJ1bmRsZS5jcmVhdGVQYXRoUHJveHkoKTtcbiAgICAgICAgICAgIHBhdGhCdW5kbGUuYnVpbGRQYXRoID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgICAgICAgICBwYXRoLmFwcGVuZFBhdGgocGF0aExpc3QpO1xuICAgICAgICAgICAgICAgIC8vIFN2ZyBhbmQgdm1sIHJlbmRlcmVyIGRvbid0IGhhdmUgY29udGV4dFxuICAgICAgICAgICAgICAgIHZhciBjdHggPSBwYXRoLmdldENvbnRleHQoKTtcbiAgICAgICAgICAgICAgICBpZiAoY3R4KSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGgucmVidWlsZFBhdGgoY3R4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXR1cm4gcGF0aEJ1bmRsZTtcbiAgICAgICAgfVxuICAgIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS95eC9+L3pyZW5kZXIvbGliL3Rvb2wvcGF0aC5qc1xuLy8gbW9kdWxlIGlkID0gMTMwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 131 */
/* unknown exports provided */
/* all exports used */
/*!****************************************************!*\
  !*** /home/yx/~/zrender/lib/tool/transformPath.js ***!
  \****************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var CMD = __webpack_require__(/*! ../core/PathProxy */ 25).CMD;\n    var vec2 = __webpack_require__(/*! ../core/vector */ 4);\n    var v2ApplyTransform = vec2.applyTransform;\n\n    var points = [[], [], []];\n    var mathSqrt = Math.sqrt;\n    var mathAtan2 = Math.atan2;\n    function transformPath(path, m) {\n        var data = path.data;\n        var cmd;\n        var nPoint;\n        var i;\n        var j;\n        var k;\n        var p;\n\n        var M = CMD.M;\n        var C = CMD.C;\n        var L = CMD.L;\n        var R = CMD.R;\n        var A = CMD.A;\n        var Q = CMD.Q;\n\n        for (i = 0, j = 0; i < data.length;) {\n            cmd = data[i++];\n            j = i;\n            nPoint = 0;\n\n            switch (cmd) {\n                case M:\n                    nPoint = 1;\n                    break;\n                case L:\n                    nPoint = 1;\n                    break;\n                case C:\n                    nPoint = 3;\n                    break;\n                case Q:\n                    nPoint = 2;\n                    break;\n                case A:\n                    var x = m[4];\n                    var y = m[5];\n                    var sx = mathSqrt(m[0] * m[0] + m[1] * m[1]);\n                    var sy = mathSqrt(m[2] * m[2] + m[3] * m[3]);\n                    var angle = mathAtan2(-m[1] / sy, m[0] / sx);\n                    // cx\n                    data[i] *= sx;\n                    data[i++] += x;\n                    // cy\n                    data[i] *= sy;\n                    data[i++] += y;\n                    // Scale rx and ry\n                    // FIXME Assume psi is 0 here\n                    data[i++] *= sx;\n                    data[i++] *= sy;\n\n                    // Start angle\n                    data[i++] += angle;\n                    // end angle\n                    data[i++] += angle;\n                    // FIXME psi\n                    i += 2;\n                    j = i;\n                    break;\n                case R:\n                    // x0, y0\n                    p[0] = data[i++];\n                    p[1] = data[i++];\n                    v2ApplyTransform(p, p, m);\n                    data[j++] = p[0];\n                    data[j++] = p[1];\n                    // x1, y1\n                    p[0] += data[i++];\n                    p[1] += data[i++];\n                    v2ApplyTransform(p, p, m);\n                    data[j++] = p[0];\n                    data[j++] = p[1];\n            }\n\n            for (k = 0; k < nPoint; k++) {\n                var p = points[k];\n                p[0] = data[i++];\n                p[1] = data[i++];\n\n                v2ApplyTransform(p, p, m);\n                // Write back\n                data[j++] = p[0];\n                data[j++] = p[1];\n            }\n        }\n    }\n\n    module.exports = transformPath;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMxLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy9ob21lL3l4L34venJlbmRlci9saWIvdG9vbC90cmFuc2Zvcm1QYXRoLmpzP2Y0ODQiXSwic291cmNlc0NvbnRlbnQiOlsiXG5cbiAgICB2YXIgQ01EID0gcmVxdWlyZSgnLi4vY29yZS9QYXRoUHJveHknKS5DTUQ7XG4gICAgdmFyIHZlYzIgPSByZXF1aXJlKCcuLi9jb3JlL3ZlY3RvcicpO1xuICAgIHZhciB2MkFwcGx5VHJhbnNmb3JtID0gdmVjMi5hcHBseVRyYW5zZm9ybTtcblxuICAgIHZhciBwb2ludHMgPSBbW10sIFtdLCBbXV07XG4gICAgdmFyIG1hdGhTcXJ0ID0gTWF0aC5zcXJ0O1xuICAgIHZhciBtYXRoQXRhbjIgPSBNYXRoLmF0YW4yO1xuICAgIGZ1bmN0aW9uIHRyYW5zZm9ybVBhdGgocGF0aCwgbSkge1xuICAgICAgICB2YXIgZGF0YSA9IHBhdGguZGF0YTtcbiAgICAgICAgdmFyIGNtZDtcbiAgICAgICAgdmFyIG5Qb2ludDtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciBqO1xuICAgICAgICB2YXIgaztcbiAgICAgICAgdmFyIHA7XG5cbiAgICAgICAgdmFyIE0gPSBDTUQuTTtcbiAgICAgICAgdmFyIEMgPSBDTUQuQztcbiAgICAgICAgdmFyIEwgPSBDTUQuTDtcbiAgICAgICAgdmFyIFIgPSBDTUQuUjtcbiAgICAgICAgdmFyIEEgPSBDTUQuQTtcbiAgICAgICAgdmFyIFEgPSBDTUQuUTtcblxuICAgICAgICBmb3IgKGkgPSAwLCBqID0gMDsgaSA8IGRhdGEubGVuZ3RoOykge1xuICAgICAgICAgICAgY21kID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgaiA9IGk7XG4gICAgICAgICAgICBuUG9pbnQgPSAwO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKGNtZCkge1xuICAgICAgICAgICAgICAgIGNhc2UgTTpcbiAgICAgICAgICAgICAgICAgICAgblBvaW50ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBMOlxuICAgICAgICAgICAgICAgICAgICBuUG9pbnQgPSAxO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEM6XG4gICAgICAgICAgICAgICAgICAgIG5Qb2ludCA9IDM7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgUTpcbiAgICAgICAgICAgICAgICAgICAgblBvaW50ID0gMjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBBOlxuICAgICAgICAgICAgICAgICAgICB2YXIgeCA9IG1bNF07XG4gICAgICAgICAgICAgICAgICAgIHZhciB5ID0gbVs1XTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN4ID0gbWF0aFNxcnQobVswXSAqIG1bMF0gKyBtWzFdICogbVsxXSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzeSA9IG1hdGhTcXJ0KG1bMl0gKiBtWzJdICsgbVszXSAqIG1bM10pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYW5nbGUgPSBtYXRoQXRhbjIoLW1bMV0gLyBzeSwgbVswXSAvIHN4KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gY3hcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtpXSAqPSBzeDtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtpKytdICs9IHg7XG4gICAgICAgICAgICAgICAgICAgIC8vIGN5XG4gICAgICAgICAgICAgICAgICAgIGRhdGFbaV0gKj0gc3k7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFbaSsrXSArPSB5O1xuICAgICAgICAgICAgICAgICAgICAvLyBTY2FsZSByeCBhbmQgcnlcbiAgICAgICAgICAgICAgICAgICAgLy8gRklYTUUgQXNzdW1lIHBzaSBpcyAwIGhlcmVcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtpKytdICo9IHN4O1xuICAgICAgICAgICAgICAgICAgICBkYXRhW2krK10gKj0gc3k7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gU3RhcnQgYW5nbGVcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtpKytdICs9IGFuZ2xlO1xuICAgICAgICAgICAgICAgICAgICAvLyBlbmQgYW5nbGVcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtpKytdICs9IGFuZ2xlO1xuICAgICAgICAgICAgICAgICAgICAvLyBGSVhNRSBwc2lcbiAgICAgICAgICAgICAgICAgICAgaSArPSAyO1xuICAgICAgICAgICAgICAgICAgICBqID0gaTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBSOlxuICAgICAgICAgICAgICAgICAgICAvLyB4MCwgeTBcbiAgICAgICAgICAgICAgICAgICAgcFswXSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgcFsxXSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgdjJBcHBseVRyYW5zZm9ybShwLCBwLCBtKTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtqKytdID0gcFswXTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtqKytdID0gcFsxXTtcbiAgICAgICAgICAgICAgICAgICAgLy8geDEsIHkxXG4gICAgICAgICAgICAgICAgICAgIHBbMF0gKz0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICBwWzFdICs9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgdjJBcHBseVRyYW5zZm9ybShwLCBwLCBtKTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtqKytdID0gcFswXTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtqKytdID0gcFsxXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IG5Qb2ludDsgaysrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHAgPSBwb2ludHNba107XG4gICAgICAgICAgICAgICAgcFswXSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICBwWzFdID0gZGF0YVtpKytdO1xuXG4gICAgICAgICAgICAgICAgdjJBcHBseVRyYW5zZm9ybShwLCBwLCBtKTtcbiAgICAgICAgICAgICAgICAvLyBXcml0ZSBiYWNrXG4gICAgICAgICAgICAgICAgZGF0YVtqKytdID0gcFswXTtcbiAgICAgICAgICAgICAgICBkYXRhW2orK10gPSBwWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB0cmFuc2Zvcm1QYXRoO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL2hvbWUveXgvfi96cmVuZGVyL2xpYi90b29sL3RyYW5zZm9ybVBhdGguanNcbi8vIG1vZHVsZSBpZCA9IDEzMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 132 */
/* unknown exports provided */
/* all exports used */
/*!******************************************!*\
  !*** /home/yx/~/zrender/lib/vml/core.js ***!
  \******************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\n\nif (!__webpack_require__(/*! ../core/env */ 8).canvasSupported) {\n    var urn = 'urn:schemas-microsoft-com:vml';\n\n    var createNode;\n    var win = window;\n    var doc = win.document;\n\n    var vmlInited = false;\n\n    try {\n        !doc.namespaces.zrvml && doc.namespaces.add('zrvml', urn);\n        createNode = function (tagName) {\n            return doc.createElement('<zrvml:' + tagName + ' class=\"zrvml\">');\n        };\n    }\n    catch (e) {\n        createNode = function (tagName) {\n            return doc.createElement('<' + tagName + ' xmlns=\"' + urn + '\" class=\"zrvml\">');\n        };\n    }\n\n    // From raphael\n    var initVML = function () {\n        if (vmlInited) {\n            return;\n        }\n        vmlInited = true;\n\n        var styleSheets = doc.styleSheets;\n        if (styleSheets.length < 31) {\n            doc.createStyleSheet().addRule('.zrvml', 'behavior:url(#default#VML)');\n        }\n        else {\n            // http://msdn.microsoft.com/en-us/library/ms531194%28VS.85%29.aspx\n            styleSheets[0].addRule('.zrvml', 'behavior:url(#default#VML)');\n        }\n    };\n\n    // Not useing return to avoid error when converting to CommonJS module\n    module.exports = {\n        doc: doc,\n        initVML: initVML,\n        createNode: createNode\n    };\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy9ob21lL3l4L34venJlbmRlci9saWIvdm1sL2NvcmUuanM/YjhkMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcblxuaWYgKCFyZXF1aXJlKCcuLi9jb3JlL2VudicpLmNhbnZhc1N1cHBvcnRlZCkge1xuICAgIHZhciB1cm4gPSAndXJuOnNjaGVtYXMtbWljcm9zb2Z0LWNvbTp2bWwnO1xuXG4gICAgdmFyIGNyZWF0ZU5vZGU7XG4gICAgdmFyIHdpbiA9IHdpbmRvdztcbiAgICB2YXIgZG9jID0gd2luLmRvY3VtZW50O1xuXG4gICAgdmFyIHZtbEluaXRlZCA9IGZhbHNlO1xuXG4gICAgdHJ5IHtcbiAgICAgICAgIWRvYy5uYW1lc3BhY2VzLnpydm1sICYmIGRvYy5uYW1lc3BhY2VzLmFkZCgnenJ2bWwnLCB1cm4pO1xuICAgICAgICBjcmVhdGVOb2RlID0gZnVuY3Rpb24gKHRhZ05hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBkb2MuY3JlYXRlRWxlbWVudCgnPHpydm1sOicgKyB0YWdOYW1lICsgJyBjbGFzcz1cInpydm1sXCI+Jyk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGNyZWF0ZU5vZGUgPSBmdW5jdGlvbiAodGFnTmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIGRvYy5jcmVhdGVFbGVtZW50KCc8JyArIHRhZ05hbWUgKyAnIHhtbG5zPVwiJyArIHVybiArICdcIiBjbGFzcz1cInpydm1sXCI+Jyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gRnJvbSByYXBoYWVsXG4gICAgdmFyIGluaXRWTUwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh2bWxJbml0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2bWxJbml0ZWQgPSB0cnVlO1xuXG4gICAgICAgIHZhciBzdHlsZVNoZWV0cyA9IGRvYy5zdHlsZVNoZWV0cztcbiAgICAgICAgaWYgKHN0eWxlU2hlZXRzLmxlbmd0aCA8IDMxKSB7XG4gICAgICAgICAgICBkb2MuY3JlYXRlU3R5bGVTaGVldCgpLmFkZFJ1bGUoJy56cnZtbCcsICdiZWhhdmlvcjp1cmwoI2RlZmF1bHQjVk1MKScpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L21zNTMxMTk0JTI4VlMuODUlMjkuYXNweFxuICAgICAgICAgICAgc3R5bGVTaGVldHNbMF0uYWRkUnVsZSgnLnpydm1sJywgJ2JlaGF2aW9yOnVybCgjZGVmYXVsdCNWTUwpJyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gTm90IHVzZWluZyByZXR1cm4gdG8gYXZvaWQgZXJyb3Igd2hlbiBjb252ZXJ0aW5nIHRvIENvbW1vbkpTIG1vZHVsZVxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBkb2M6IGRvYyxcbiAgICAgICAgaW5pdFZNTDogaW5pdFZNTCxcbiAgICAgICAgY3JlYXRlTm9kZTogY3JlYXRlTm9kZVxuICAgIH07XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS95eC9+L3pyZW5kZXIvbGliL3ZtbC9jb3JlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 133 */
/* unknown exports provided */
/* all exports used */
/*!*****************************!*\
  !*** ./lib/ExtensionAPI.js ***!
  \*****************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\n    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 0);\n\n    var echartsAPIList = [\n        'getDom', 'getZr', 'getWidth', 'getHeight', 'getDevicePixelRatio', 'dispatchAction', 'isDisposed',\n        'on', 'off', 'getDataURL', 'getConnectedDataURL', 'getModel', 'getOption',\n        'getViewOfComponentModel', 'getViewOfSeriesModel'\n    ];\n    // And `getCoordinateSystems` and `getComponentByElement` will be injected in echarts.js\n\n    function ExtensionAPI(chartInstance) {\n        zrUtil.each(echartsAPIList, function (name) {\n            this[name] = zrUtil.bind(chartInstance[name], chartInstance);\n        }, this);\n    }\n\n    module.exports = ExtensionAPI;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL0V4dGVuc2lvbkFQSS5qcz8wMjRiIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuXG4gICAgdmFyIGVjaGFydHNBUElMaXN0ID0gW1xuICAgICAgICAnZ2V0RG9tJywgJ2dldFpyJywgJ2dldFdpZHRoJywgJ2dldEhlaWdodCcsICdnZXREZXZpY2VQaXhlbFJhdGlvJywgJ2Rpc3BhdGNoQWN0aW9uJywgJ2lzRGlzcG9zZWQnLFxuICAgICAgICAnb24nLCAnb2ZmJywgJ2dldERhdGFVUkwnLCAnZ2V0Q29ubmVjdGVkRGF0YVVSTCcsICdnZXRNb2RlbCcsICdnZXRPcHRpb24nLFxuICAgICAgICAnZ2V0Vmlld09mQ29tcG9uZW50TW9kZWwnLCAnZ2V0Vmlld09mU2VyaWVzTW9kZWwnXG4gICAgXTtcbiAgICAvLyBBbmQgYGdldENvb3JkaW5hdGVTeXN0ZW1zYCBhbmQgYGdldENvbXBvbmVudEJ5RWxlbWVudGAgd2lsbCBiZSBpbmplY3RlZCBpbiBlY2hhcnRzLmpzXG5cbiAgICBmdW5jdGlvbiBFeHRlbnNpb25BUEkoY2hhcnRJbnN0YW5jZSkge1xuICAgICAgICB6clV0aWwuZWFjaChlY2hhcnRzQVBJTGlzdCwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHRoaXNbbmFtZV0gPSB6clV0aWwuYmluZChjaGFydEluc3RhbmNlW25hbWVdLCBjaGFydEluc3RhbmNlKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBFeHRlbnNpb25BUEk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9FeHRlbnNpb25BUEkuanNcbi8vIG1vZHVsZSBpZCA9IDEzM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 134 */
/* unknown exports provided */
/* all exports used */
/*!************************************!*\
  !*** ./lib/chart/bar/BarSeries.js ***!
  \************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    module.exports = __webpack_require__(/*! ./BaseBarSeries */ 95).extend({\n\n        type: 'series.bar',\n\n        dependencies: ['grid', 'polar'],\n\n        brushSelector: 'rect'\n    });\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTM0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2NoYXJ0L2Jhci9CYXJTZXJpZXMuanM/M2I4NSJdLCJzb3VyY2VzQ29udGVudCI6WyJcblxuICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9CYXNlQmFyU2VyaWVzJykuZXh0ZW5kKHtcblxuICAgICAgICB0eXBlOiAnc2VyaWVzLmJhcicsXG5cbiAgICAgICAgZGVwZW5kZW5jaWVzOiBbJ2dyaWQnLCAncG9sYXInXSxcblxuICAgICAgICBicnVzaFNlbGVjdG9yOiAncmVjdCdcbiAgICB9KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2NoYXJ0L2Jhci9CYXJTZXJpZXMuanNcbi8vIG1vZHVsZSBpZCA9IDEzNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 135 */
/* unknown exports provided */
/* all exports used */
/*!**********************************!*\
  !*** ./lib/chart/bar/BarView.js ***!
  \**********************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\n    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 0);\n    var graphic = __webpack_require__(/*! ../../util/graphic */ 2);\n    var helper = __webpack_require__(/*! ./helper */ 96);\n\n    var BAR_BORDER_WIDTH_QUERY = ['itemStyle', 'normal', 'barBorderWidth'];\n\n    // FIXME\n    // Just for compatible with ec2.\n    zrUtil.extend(__webpack_require__(/*! ../../model/Model */ 9).prototype, __webpack_require__(/*! ./barItemStyle */ 136));\n\n    var BarView = __webpack_require__(/*! ../../echarts */ 1).extendChartView({\n\n        type: 'bar',\n\n        render: function (seriesModel, ecModel, api) {\n            var coordinateSystemType = seriesModel.get('coordinateSystem');\n\n            if (coordinateSystemType === 'cartesian2d') {\n                this._renderOnCartesian(seriesModel, ecModel, api);\n            }\n\n            return this.group;\n        },\n\n        dispose: zrUtil.noop,\n\n        _renderOnCartesian: function (seriesModel, ecModel, api) {\n            var group = this.group;\n            var data = seriesModel.getData();\n            var oldData = this._data;\n\n            var cartesian = seriesModel.coordinateSystem;\n            var baseAxis = cartesian.getBaseAxis();\n            var isHorizontal = baseAxis.isHorizontal();\n            var animationModel = seriesModel.isAnimationEnabled() ? seriesModel : null;\n\n            data.diff(oldData)\n                .add(function (dataIndex) {\n                    if (!data.hasValue(dataIndex)) {\n                        return;\n                    }\n\n                    var itemModel = data.getItemModel(dataIndex);\n                    var layout = getRectItemLayout(data, dataIndex, itemModel);\n                    var el = createRect(data, dataIndex, itemModel, layout, isHorizontal, animationModel);\n                    data.setItemGraphicEl(dataIndex, el);\n                    group.add(el);\n\n                    updateStyle(el, data, dataIndex, itemModel, layout, seriesModel, isHorizontal);\n                })\n                .update(function (newIndex, oldIndex) {\n                    var el = oldData.getItemGraphicEl(oldIndex);\n\n                    if (!data.hasValue(newIndex)) {\n                        group.remove(el);\n                        return;\n                    }\n\n                    var itemModel = data.getItemModel(newIndex);\n                    var layout = getRectItemLayout(data, newIndex, itemModel);\n\n                    if (el) {\n                        graphic.updateProps(el, {shape: layout}, animationModel, newIndex);\n                    }\n                    else {\n                        el = createRect(data, newIndex, itemModel, layout, isHorizontal, animationModel, true);\n                    }\n\n                    data.setItemGraphicEl(newIndex, el);\n                    // Add back\n                    group.add(el);\n\n                    updateStyle(el, data, newIndex, itemModel, layout, seriesModel, isHorizontal);\n                })\n                .remove(function (dataIndex) {\n                    var el = oldData.getItemGraphicEl(dataIndex);\n                    el && removeRect(dataIndex, animationModel, el);\n                })\n                .execute();\n\n            this._data = data;\n        },\n\n        remove: function (ecModel, api) {\n            var group = this.group;\n            var data = this._data;\n            if (ecModel.get('animation')) {\n                if (data) {\n                    data.eachItemGraphicEl(function (el) {\n                        removeRect(el.dataIndex, ecModel, el);\n                    });\n                }\n            }\n            else {\n                group.removeAll();\n            }\n        }\n    });\n\n    function createRect(data, dataIndex, itemModel, layout, isHorizontal, animationModel, isUpdate) {\n        var rect = new graphic.Rect({shape: zrUtil.extend({}, layout)});\n\n        // Animation\n        if (animationModel) {\n            var rectShape = rect.shape;\n            var animateProperty = isHorizontal ? 'height' : 'width';\n            var animateTarget = {};\n            rectShape[animateProperty] = 0;\n            animateTarget[animateProperty] = layout[animateProperty];\n            graphic[isUpdate ? 'updateProps' : 'initProps'](rect, {\n                shape: animateTarget\n            }, animationModel, dataIndex);\n        }\n\n        return rect;\n    }\n\n    function removeRect(dataIndex, animationModel, el) {\n        // Not show text when animating\n        el.style.text = '';\n        graphic.updateProps(el, {\n            shape: {\n                width: 0\n            }\n        }, animationModel, dataIndex, function () {\n            el.parent && el.parent.remove(el);\n        });\n    }\n\n    function getRectItemLayout(data, dataIndex, itemModel) {\n        var layout = data.getItemLayout(dataIndex);\n        var fixedLineWidth = getLineWidth(itemModel, layout);\n\n        // fix layout with lineWidth\n        var signX = layout.width > 0 ? 1 : -1;\n        var signY = layout.height > 0 ? 1 : -1;\n        return {\n            x: layout.x + signX * fixedLineWidth / 2,\n            y: layout.y + signY * fixedLineWidth / 2,\n            width: layout.width - signX * fixedLineWidth,\n            height: layout.height - signY * fixedLineWidth\n        };\n    }\n\n    function updateStyle(el, data, dataIndex, itemModel, layout, seriesModel, isHorizontal) {\n        var color = data.getItemVisual(dataIndex, 'color');\n        var opacity = data.getItemVisual(dataIndex, 'opacity');\n        var itemStyleModel = itemModel.getModel('itemStyle.normal');\n        var hoverStyle = itemModel.getModel('itemStyle.emphasis').getBarItemStyle();\n\n        el.setShape('r', itemStyleModel.get('barBorderRadius') || 0);\n\n        el.useStyle(zrUtil.defaults(\n            {\n                fill: color,\n                opacity: opacity\n            },\n            itemStyleModel.getBarItemStyle()\n        ));\n\n        var labelPositionOutside = isHorizontal\n            ? (layout.height > 0 ? 'bottom' : 'top')\n            : (layout.width > 0 ? 'left' : 'right');\n\n        helper.setLabel(\n            el.style, hoverStyle, itemModel, color,\n            seriesModel, dataIndex, labelPositionOutside\n        );\n\n        graphic.setHoverStyle(el, hoverStyle);\n    }\n\n    // In case width or height are too small.\n    function getLineWidth(itemModel, rawLayout) {\n        var lineWidth = itemModel.get(BAR_BORDER_WIDTH_QUERY) || 0;\n        return Math.min(lineWidth, Math.abs(rawLayout.width), Math.abs(rawLayout.height));\n    }\n\n    module.exports = BarView;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTM1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2NoYXJ0L2Jhci9CYXJWaWV3LmpzPzlmNWQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKCcuLi8uLi91dGlsL2dyYXBoaWMnKTtcbiAgICB2YXIgaGVscGVyID0gcmVxdWlyZSgnLi9oZWxwZXInKTtcblxuICAgIHZhciBCQVJfQk9SREVSX1dJRFRIX1FVRVJZID0gWydpdGVtU3R5bGUnLCAnbm9ybWFsJywgJ2JhckJvcmRlcldpZHRoJ107XG5cbiAgICAvLyBGSVhNRVxuICAgIC8vIEp1c3QgZm9yIGNvbXBhdGlibGUgd2l0aCBlYzIuXG4gICAgenJVdGlsLmV4dGVuZChyZXF1aXJlKCcuLi8uLi9tb2RlbC9Nb2RlbCcpLnByb3RvdHlwZSwgcmVxdWlyZSgnLi9iYXJJdGVtU3R5bGUnKSk7XG5cbiAgICB2YXIgQmFyVmlldyA9IHJlcXVpcmUoJy4uLy4uL2VjaGFydHMnKS5leHRlbmRDaGFydFZpZXcoe1xuXG4gICAgICAgIHR5cGU6ICdiYXInLFxuXG4gICAgICAgIHJlbmRlcjogZnVuY3Rpb24gKHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgICAgICAgICAgIHZhciBjb29yZGluYXRlU3lzdGVtVHlwZSA9IHNlcmllc01vZGVsLmdldCgnY29vcmRpbmF0ZVN5c3RlbScpO1xuXG4gICAgICAgICAgICBpZiAoY29vcmRpbmF0ZVN5c3RlbVR5cGUgPT09ICdjYXJ0ZXNpYW4yZCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJPbkNhcnRlc2lhbihzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ3JvdXA7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGlzcG9zZTogenJVdGlsLm5vb3AsXG5cbiAgICAgICAgX3JlbmRlck9uQ2FydGVzaWFuOiBmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGFwaSkge1xuICAgICAgICAgICAgdmFyIGdyb3VwID0gdGhpcy5ncm91cDtcbiAgICAgICAgICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgICAgICAgICAgdmFyIG9sZERhdGEgPSB0aGlzLl9kYXRhO1xuXG4gICAgICAgICAgICB2YXIgY2FydGVzaWFuID0gc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcbiAgICAgICAgICAgIHZhciBiYXNlQXhpcyA9IGNhcnRlc2lhbi5nZXRCYXNlQXhpcygpO1xuICAgICAgICAgICAgdmFyIGlzSG9yaXpvbnRhbCA9IGJhc2VBeGlzLmlzSG9yaXpvbnRhbCgpO1xuICAgICAgICAgICAgdmFyIGFuaW1hdGlvbk1vZGVsID0gc2VyaWVzTW9kZWwuaXNBbmltYXRpb25FbmFibGVkKCkgPyBzZXJpZXNNb2RlbCA6IG51bGw7XG5cbiAgICAgICAgICAgIGRhdGEuZGlmZihvbGREYXRhKVxuICAgICAgICAgICAgICAgIC5hZGQoZnVuY3Rpb24gKGRhdGFJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWRhdGEuaGFzVmFsdWUoZGF0YUluZGV4KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW1Nb2RlbCA9IGRhdGEuZ2V0SXRlbU1vZGVsKGRhdGFJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsYXlvdXQgPSBnZXRSZWN0SXRlbUxheW91dChkYXRhLCBkYXRhSW5kZXgsIGl0ZW1Nb2RlbCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbCA9IGNyZWF0ZVJlY3QoZGF0YSwgZGF0YUluZGV4LCBpdGVtTW9kZWwsIGxheW91dCwgaXNIb3Jpem9udGFsLCBhbmltYXRpb25Nb2RlbCk7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEuc2V0SXRlbUdyYXBoaWNFbChkYXRhSW5kZXgsIGVsKTtcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXAuYWRkKGVsKTtcblxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVTdHlsZShlbCwgZGF0YSwgZGF0YUluZGV4LCBpdGVtTW9kZWwsIGxheW91dCwgc2VyaWVzTW9kZWwsIGlzSG9yaXpvbnRhbCk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudXBkYXRlKGZ1bmN0aW9uIChuZXdJbmRleCwgb2xkSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsID0gb2xkRGF0YS5nZXRJdGVtR3JhcGhpY0VsKG9sZEluZGV4KTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIWRhdGEuaGFzVmFsdWUobmV3SW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBncm91cC5yZW1vdmUoZWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW1Nb2RlbCA9IGRhdGEuZ2V0SXRlbU1vZGVsKG5ld0luZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxheW91dCA9IGdldFJlY3RJdGVtTGF5b3V0KGRhdGEsIG5ld0luZGV4LCBpdGVtTW9kZWwpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ3JhcGhpYy51cGRhdGVQcm9wcyhlbCwge3NoYXBlOiBsYXlvdXR9LCBhbmltYXRpb25Nb2RlbCwgbmV3SW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwgPSBjcmVhdGVSZWN0KGRhdGEsIG5ld0luZGV4LCBpdGVtTW9kZWwsIGxheW91dCwgaXNIb3Jpem9udGFsLCBhbmltYXRpb25Nb2RlbCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBkYXRhLnNldEl0ZW1HcmFwaGljRWwobmV3SW5kZXgsIGVsKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIGJhY2tcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXAuYWRkKGVsKTtcblxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVTdHlsZShlbCwgZGF0YSwgbmV3SW5kZXgsIGl0ZW1Nb2RlbCwgbGF5b3V0LCBzZXJpZXNNb2RlbCwgaXNIb3Jpem9udGFsKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5yZW1vdmUoZnVuY3Rpb24gKGRhdGFJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZWwgPSBvbGREYXRhLmdldEl0ZW1HcmFwaGljRWwoZGF0YUluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgZWwgJiYgcmVtb3ZlUmVjdChkYXRhSW5kZXgsIGFuaW1hdGlvbk1vZGVsLCBlbCk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuZXhlY3V0ZSgpO1xuXG4gICAgICAgICAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgICAgICAgfSxcblxuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHtcbiAgICAgICAgICAgIHZhciBncm91cCA9IHRoaXMuZ3JvdXA7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX2RhdGE7XG4gICAgICAgICAgICBpZiAoZWNNb2RlbC5nZXQoJ2FuaW1hdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5lYWNoSXRlbUdyYXBoaWNFbChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZVJlY3QoZWwuZGF0YUluZGV4LCBlY01vZGVsLCBlbCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGdyb3VwLnJlbW92ZUFsbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVSZWN0KGRhdGEsIGRhdGFJbmRleCwgaXRlbU1vZGVsLCBsYXlvdXQsIGlzSG9yaXpvbnRhbCwgYW5pbWF0aW9uTW9kZWwsIGlzVXBkYXRlKSB7XG4gICAgICAgIHZhciByZWN0ID0gbmV3IGdyYXBoaWMuUmVjdCh7c2hhcGU6IHpyVXRpbC5leHRlbmQoe30sIGxheW91dCl9KTtcblxuICAgICAgICAvLyBBbmltYXRpb25cbiAgICAgICAgaWYgKGFuaW1hdGlvbk1vZGVsKSB7XG4gICAgICAgICAgICB2YXIgcmVjdFNoYXBlID0gcmVjdC5zaGFwZTtcbiAgICAgICAgICAgIHZhciBhbmltYXRlUHJvcGVydHkgPSBpc0hvcml6b250YWwgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG4gICAgICAgICAgICB2YXIgYW5pbWF0ZVRhcmdldCA9IHt9O1xuICAgICAgICAgICAgcmVjdFNoYXBlW2FuaW1hdGVQcm9wZXJ0eV0gPSAwO1xuICAgICAgICAgICAgYW5pbWF0ZVRhcmdldFthbmltYXRlUHJvcGVydHldID0gbGF5b3V0W2FuaW1hdGVQcm9wZXJ0eV07XG4gICAgICAgICAgICBncmFwaGljW2lzVXBkYXRlID8gJ3VwZGF0ZVByb3BzJyA6ICdpbml0UHJvcHMnXShyZWN0LCB7XG4gICAgICAgICAgICAgICAgc2hhcGU6IGFuaW1hdGVUYXJnZXRcbiAgICAgICAgICAgIH0sIGFuaW1hdGlvbk1vZGVsLCBkYXRhSW5kZXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlUmVjdChkYXRhSW5kZXgsIGFuaW1hdGlvbk1vZGVsLCBlbCkge1xuICAgICAgICAvLyBOb3Qgc2hvdyB0ZXh0IHdoZW4gYW5pbWF0aW5nXG4gICAgICAgIGVsLnN0eWxlLnRleHQgPSAnJztcbiAgICAgICAgZ3JhcGhpYy51cGRhdGVQcm9wcyhlbCwge1xuICAgICAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgICAgICB3aWR0aDogMFxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBhbmltYXRpb25Nb2RlbCwgZGF0YUluZGV4LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBlbC5wYXJlbnQgJiYgZWwucGFyZW50LnJlbW92ZShlbCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFJlY3RJdGVtTGF5b3V0KGRhdGEsIGRhdGFJbmRleCwgaXRlbU1vZGVsKSB7XG4gICAgICAgIHZhciBsYXlvdXQgPSBkYXRhLmdldEl0ZW1MYXlvdXQoZGF0YUluZGV4KTtcbiAgICAgICAgdmFyIGZpeGVkTGluZVdpZHRoID0gZ2V0TGluZVdpZHRoKGl0ZW1Nb2RlbCwgbGF5b3V0KTtcblxuICAgICAgICAvLyBmaXggbGF5b3V0IHdpdGggbGluZVdpZHRoXG4gICAgICAgIHZhciBzaWduWCA9IGxheW91dC53aWR0aCA+IDAgPyAxIDogLTE7XG4gICAgICAgIHZhciBzaWduWSA9IGxheW91dC5oZWlnaHQgPiAwID8gMSA6IC0xO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogbGF5b3V0LnggKyBzaWduWCAqIGZpeGVkTGluZVdpZHRoIC8gMixcbiAgICAgICAgICAgIHk6IGxheW91dC55ICsgc2lnblkgKiBmaXhlZExpbmVXaWR0aCAvIDIsXG4gICAgICAgICAgICB3aWR0aDogbGF5b3V0LndpZHRoIC0gc2lnblggKiBmaXhlZExpbmVXaWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogbGF5b3V0LmhlaWdodCAtIHNpZ25ZICogZml4ZWRMaW5lV2lkdGhcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVTdHlsZShlbCwgZGF0YSwgZGF0YUluZGV4LCBpdGVtTW9kZWwsIGxheW91dCwgc2VyaWVzTW9kZWwsIGlzSG9yaXpvbnRhbCkge1xuICAgICAgICB2YXIgY29sb3IgPSBkYXRhLmdldEl0ZW1WaXN1YWwoZGF0YUluZGV4LCAnY29sb3InKTtcbiAgICAgICAgdmFyIG9wYWNpdHkgPSBkYXRhLmdldEl0ZW1WaXN1YWwoZGF0YUluZGV4LCAnb3BhY2l0eScpO1xuICAgICAgICB2YXIgaXRlbVN0eWxlTW9kZWwgPSBpdGVtTW9kZWwuZ2V0TW9kZWwoJ2l0ZW1TdHlsZS5ub3JtYWwnKTtcbiAgICAgICAgdmFyIGhvdmVyU3R5bGUgPSBpdGVtTW9kZWwuZ2V0TW9kZWwoJ2l0ZW1TdHlsZS5lbXBoYXNpcycpLmdldEJhckl0ZW1TdHlsZSgpO1xuXG4gICAgICAgIGVsLnNldFNoYXBlKCdyJywgaXRlbVN0eWxlTW9kZWwuZ2V0KCdiYXJCb3JkZXJSYWRpdXMnKSB8fCAwKTtcblxuICAgICAgICBlbC51c2VTdHlsZSh6clV0aWwuZGVmYXVsdHMoXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZmlsbDogY29sb3IsXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogb3BhY2l0eVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGl0ZW1TdHlsZU1vZGVsLmdldEJhckl0ZW1TdHlsZSgpXG4gICAgICAgICkpO1xuXG4gICAgICAgIHZhciBsYWJlbFBvc2l0aW9uT3V0c2lkZSA9IGlzSG9yaXpvbnRhbFxuICAgICAgICAgICAgPyAobGF5b3V0LmhlaWdodCA+IDAgPyAnYm90dG9tJyA6ICd0b3AnKVxuICAgICAgICAgICAgOiAobGF5b3V0LndpZHRoID4gMCA/ICdsZWZ0JyA6ICdyaWdodCcpO1xuXG4gICAgICAgIGhlbHBlci5zZXRMYWJlbChcbiAgICAgICAgICAgIGVsLnN0eWxlLCBob3ZlclN0eWxlLCBpdGVtTW9kZWwsIGNvbG9yLFxuICAgICAgICAgICAgc2VyaWVzTW9kZWwsIGRhdGFJbmRleCwgbGFiZWxQb3NpdGlvbk91dHNpZGVcbiAgICAgICAgKTtcblxuICAgICAgICBncmFwaGljLnNldEhvdmVyU3R5bGUoZWwsIGhvdmVyU3R5bGUpO1xuICAgIH1cblxuICAgIC8vIEluIGNhc2Ugd2lkdGggb3IgaGVpZ2h0IGFyZSB0b28gc21hbGwuXG4gICAgZnVuY3Rpb24gZ2V0TGluZVdpZHRoKGl0ZW1Nb2RlbCwgcmF3TGF5b3V0KSB7XG4gICAgICAgIHZhciBsaW5lV2lkdGggPSBpdGVtTW9kZWwuZ2V0KEJBUl9CT1JERVJfV0lEVEhfUVVFUlkpIHx8IDA7XG4gICAgICAgIHJldHVybiBNYXRoLm1pbihsaW5lV2lkdGgsIE1hdGguYWJzKHJhd0xheW91dC53aWR0aCksIE1hdGguYWJzKHJhd0xheW91dC5oZWlnaHQpKTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IEJhclZpZXc7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9jaGFydC9iYXIvQmFyVmlldy5qc1xuLy8gbW9kdWxlIGlkID0gMTM1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 136 */
/* unknown exports provided */
/* all exports used */
/*!***************************************!*\
  !*** ./lib/chart/bar/barItemStyle.js ***!
  \***************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n\n    var getBarItemStyle = __webpack_require__(/*! ../../model/mixin/makeStyleMapper */ 30)(\n        [\n            ['fill', 'color'],\n            ['stroke', 'borderColor'],\n            ['lineWidth', 'borderWidth'],\n            // Compatitable with 2\n            ['stroke', 'barBorderColor'],\n            ['lineWidth', 'barBorderWidth'],\n            ['opacity'],\n            ['shadowBlur'],\n            ['shadowOffsetX'],\n            ['shadowOffsetY'],\n            ['shadowColor']\n        ]\n    );\n    module.exports = {\n        getBarItemStyle: function (excludes) {\n            var style = getBarItemStyle.call(this, excludes);\n            if (this.getBorderLineDash) {\n                var lineDash = this.getBorderLineDash();\n                lineDash && (style.lineDash = lineDash);\n            }\n            return style;\n        }\n    };\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTM2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2NoYXJ0L2Jhci9iYXJJdGVtU3R5bGUuanM/ZGEwMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcblxuXG4gICAgdmFyIGdldEJhckl0ZW1TdHlsZSA9IHJlcXVpcmUoJy4uLy4uL21vZGVsL21peGluL21ha2VTdHlsZU1hcHBlcicpKFxuICAgICAgICBbXG4gICAgICAgICAgICBbJ2ZpbGwnLCAnY29sb3InXSxcbiAgICAgICAgICAgIFsnc3Ryb2tlJywgJ2JvcmRlckNvbG9yJ10sXG4gICAgICAgICAgICBbJ2xpbmVXaWR0aCcsICdib3JkZXJXaWR0aCddLFxuICAgICAgICAgICAgLy8gQ29tcGF0aXRhYmxlIHdpdGggMlxuICAgICAgICAgICAgWydzdHJva2UnLCAnYmFyQm9yZGVyQ29sb3InXSxcbiAgICAgICAgICAgIFsnbGluZVdpZHRoJywgJ2JhckJvcmRlcldpZHRoJ10sXG4gICAgICAgICAgICBbJ29wYWNpdHknXSxcbiAgICAgICAgICAgIFsnc2hhZG93Qmx1ciddLFxuICAgICAgICAgICAgWydzaGFkb3dPZmZzZXRYJ10sXG4gICAgICAgICAgICBbJ3NoYWRvd09mZnNldFknXSxcbiAgICAgICAgICAgIFsnc2hhZG93Q29sb3InXVxuICAgICAgICBdXG4gICAgKTtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgZ2V0QmFySXRlbVN0eWxlOiBmdW5jdGlvbiAoZXhjbHVkZXMpIHtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IGdldEJhckl0ZW1TdHlsZS5jYWxsKHRoaXMsIGV4Y2x1ZGVzKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmdldEJvcmRlckxpbmVEYXNoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxpbmVEYXNoID0gdGhpcy5nZXRCb3JkZXJMaW5lRGFzaCgpO1xuICAgICAgICAgICAgICAgIGxpbmVEYXNoICYmIChzdHlsZS5saW5lRGFzaCA9IGxpbmVEYXNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdHlsZTtcbiAgICAgICAgfVxuICAgIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9jaGFydC9iYXIvYmFySXRlbVN0eWxlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 137 */
/* unknown exports provided */
/* all exports used */
/*!**********************************!*\
  !*** ./lib/chart/helper/Line.js ***!
  \**********************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * @module echarts/chart/helper/Line\n */\n\n\n    var symbolUtil = __webpack_require__(/*! ../../util/symbol */ 23);\n    var vector = __webpack_require__(/*! zrender/lib/core/vector */ 4);\n    // var matrix = require('zrender/lib/core/matrix');\n    var LinePath = __webpack_require__(/*! ./LinePath */ 203);\n    var graphic = __webpack_require__(/*! ../../util/graphic */ 2);\n    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 0);\n    var numberUtil = __webpack_require__(/*! ../../util/number */ 3);\n\n    var SYMBOL_CATEGORIES = ['fromSymbol', 'toSymbol'];\n    function makeSymbolTypeKey(symbolCategory) {\n        return '_' + symbolCategory + 'Type';\n    }\n    /**\n     * @inner\n     */\n    function createSymbol(name, lineData, idx) {\n        var color = lineData.getItemVisual(idx, 'color');\n        var symbolType = lineData.getItemVisual(idx, name);\n        var symbolSize = lineData.getItemVisual(idx, name + 'Size');\n\n        if (!symbolType || symbolType === 'none') {\n            return;\n        }\n\n        if (!zrUtil.isArray(symbolSize)) {\n            symbolSize = [symbolSize, symbolSize];\n        }\n        var symbolPath = symbolUtil.createSymbol(\n            symbolType, -symbolSize[0] / 2, -symbolSize[1] / 2,\n            symbolSize[0], symbolSize[1], color\n        );\n\n        symbolPath.name = name;\n\n        return symbolPath;\n    }\n\n    function createLine(points) {\n        var line = new LinePath({\n            name: 'line'\n        });\n        setLinePoints(line.shape, points);\n        return line;\n    }\n\n    function setLinePoints(targetShape, points) {\n        var p1 = points[0];\n        var p2 = points[1];\n        var cp1 = points[2];\n        targetShape.x1 = p1[0];\n        targetShape.y1 = p1[1];\n        targetShape.x2 = p2[0];\n        targetShape.y2 = p2[1];\n        targetShape.percent = 1;\n\n        if (cp1) {\n            targetShape.cpx1 = cp1[0];\n            targetShape.cpy1 = cp1[1];\n        }\n        else {\n            targetShape.cpx1 = NaN;\n            targetShape.cpy1 = NaN;\n        }\n    }\n\n    function updateSymbolAndLabelBeforeLineUpdate () {\n        var lineGroup = this;\n        var symbolFrom = lineGroup.childOfName('fromSymbol');\n        var symbolTo = lineGroup.childOfName('toSymbol');\n        var label = lineGroup.childOfName('label');\n        // Quick reject\n        if (!symbolFrom && !symbolTo && label.ignore) {\n            return;\n        }\n\n        var invScale = 1;\n        var parentNode = this.parent;\n        while (parentNode) {\n            if (parentNode.scale) {\n                invScale /= parentNode.scale[0];\n            }\n            parentNode = parentNode.parent;\n        }\n\n        var line = lineGroup.childOfName('line');\n        // If line not changed\n        // FIXME Parent scale changed\n        if (!this.__dirty && !line.__dirty) {\n            return;\n        }\n\n        var percent = line.shape.percent;\n        var fromPos = line.pointAt(0);\n        var toPos = line.pointAt(percent);\n\n        var d = vector.sub([], toPos, fromPos);\n        vector.normalize(d, d);\n\n        if (symbolFrom) {\n            symbolFrom.attr('position', fromPos);\n            var tangent = line.tangentAt(0);\n            symbolFrom.attr('rotation', Math.PI / 2 - Math.atan2(\n                tangent[1], tangent[0]\n            ));\n            symbolFrom.attr('scale', [invScale * percent, invScale * percent]);\n        }\n        if (symbolTo) {\n            symbolTo.attr('position', toPos);\n            var tangent = line.tangentAt(1);\n            symbolTo.attr('rotation', -Math.PI / 2 - Math.atan2(\n                tangent[1], tangent[0]\n            ));\n            symbolTo.attr('scale', [invScale * percent, invScale * percent]);\n        }\n\n        if (!label.ignore) {\n            label.attr('position', toPos);\n\n            var textPosition;\n            var textAlign;\n            var textVerticalAlign;\n\n            var distance = 5 * invScale;\n            // End\n            if (label.__position === 'end') {\n                textPosition = [d[0] * distance + toPos[0], d[1] * distance + toPos[1]];\n                textAlign = d[0] > 0.8 ? 'left' : (d[0] < -0.8 ? 'right' : 'center');\n                textVerticalAlign = d[1] > 0.8 ? 'top' : (d[1] < -0.8 ? 'bottom' : 'middle');\n            }\n            // Middle\n            else if (label.__position === 'middle') {\n                var halfPercent = percent / 2;\n                var tangent = line.tangentAt(halfPercent);\n                var n = [tangent[1], -tangent[0]];\n                var cp = line.pointAt(halfPercent);\n                if (n[1] > 0) {\n                    n[0] = -n[0];\n                    n[1] = -n[1];\n                }\n                textPosition = [cp[0] + n[0] * distance, cp[1] + n[1] * distance];\n                textAlign = 'center';\n                textVerticalAlign = 'bottom';\n                var rotation = -Math.atan2(tangent[1], tangent[0]);\n                if (toPos[0] < fromPos[0]) {\n                    rotation = Math.PI + rotation;\n                }\n                label.attr('rotation', rotation);\n            }\n            // Start\n            else {\n                textPosition = [-d[0] * distance + fromPos[0], -d[1] * distance + fromPos[1]];\n                textAlign = d[0] > 0.8 ? 'right' : (d[0] < -0.8 ? 'left' : 'center');\n                textVerticalAlign = d[1] > 0.8 ? 'bottom' : (d[1] < -0.8 ? 'top' : 'middle');\n            }\n            label.attr({\n                style: {\n                    // Use the user specified text align and baseline first\n                    textVerticalAlign: label.__verticalAlign || textVerticalAlign,\n                    textAlign: label.__textAlign || textAlign\n                },\n                position: textPosition,\n                scale: [invScale, invScale]\n            });\n        }\n    }\n\n    /**\n     * @constructor\n     * @extends {module:zrender/graphic/Group}\n     * @alias {module:echarts/chart/helper/Line}\n     */\n    function Line(lineData, idx, seriesScope) {\n        graphic.Group.call(this);\n\n        this._createLine(lineData, idx, seriesScope);\n    }\n\n    var lineProto = Line.prototype;\n\n    // Update symbol position and rotation\n    lineProto.beforeUpdate = updateSymbolAndLabelBeforeLineUpdate;\n\n    lineProto._createLine = function (lineData, idx, seriesScope) {\n        var seriesModel = lineData.hostModel;\n        var linePoints = lineData.getItemLayout(idx);\n\n        var line = createLine(linePoints);\n        line.shape.percent = 0;\n        graphic.initProps(line, {\n            shape: {\n                percent: 1\n            }\n        }, seriesModel, idx);\n\n        this.add(line);\n\n        var label = new graphic.Text({\n            name: 'label'\n        });\n        this.add(label);\n\n        zrUtil.each(SYMBOL_CATEGORIES, function (symbolCategory) {\n            var symbol = createSymbol(symbolCategory, lineData, idx);\n            // symbols must added after line to make sure\n            // it will be updated after line#update.\n            // Or symbol position and rotation update in line#beforeUpdate will be one frame slow\n            this.add(symbol);\n            this[makeSymbolTypeKey(symbolCategory)] = lineData.getItemVisual(idx, symbolCategory);\n        }, this);\n\n        this._updateCommonStl(lineData, idx, seriesScope);\n    };\n\n    lineProto.updateData = function (lineData, idx, seriesScope) {\n        var seriesModel = lineData.hostModel;\n\n        var line = this.childOfName('line');\n        var linePoints = lineData.getItemLayout(idx);\n        var target = {\n            shape: {}\n        };\n        setLinePoints(target.shape, linePoints);\n        graphic.updateProps(line, target, seriesModel, idx);\n\n        zrUtil.each(SYMBOL_CATEGORIES, function (symbolCategory) {\n            var symbolType = lineData.getItemVisual(idx, symbolCategory);\n            var key = makeSymbolTypeKey(symbolCategory);\n            // Symbol changed\n            if (this[key] !== symbolType) {\n                this.remove(this.childOfName(symbolCategory));\n                var symbol = createSymbol(symbolCategory, lineData, idx);\n                this.add(symbol);\n            }\n            this[key] = symbolType;\n        }, this);\n\n        this._updateCommonStl(lineData, idx, seriesScope);\n    };\n\n    lineProto._updateCommonStl = function (lineData, idx, seriesScope) {\n        var seriesModel = lineData.hostModel;\n\n        var line = this.childOfName('line');\n\n        var lineStyle = seriesScope && seriesScope.lineStyle;\n        var hoverLineStyle = seriesScope && seriesScope.hoverLineStyle;\n        var labelModel = seriesScope && seriesScope.labelModel;\n        var hoverLabelModel = seriesScope && seriesScope.hoverLabelModel;\n\n        // Optimization for large dataset\n        if (!seriesScope || lineData.hasItemOption) {\n            var itemModel = lineData.getItemModel(idx);\n\n            lineStyle = itemModel.getModel('lineStyle.normal').getLineStyle();\n            hoverLineStyle = itemModel.getModel('lineStyle.emphasis').getLineStyle();\n\n            labelModel = itemModel.getModel('label.normal');\n            hoverLabelModel = itemModel.getModel('label.emphasis');\n        }\n\n        var visualColor = lineData.getItemVisual(idx, 'color');\n        var visualOpacity = zrUtil.retrieve(\n            lineData.getItemVisual(idx, 'opacity'),\n            lineStyle.opacity,\n            1\n        );\n\n        line.useStyle(zrUtil.defaults(\n            {\n                strokeNoScale: true,\n                fill: 'none',\n                stroke: visualColor,\n                opacity: visualOpacity\n            },\n            lineStyle\n        ));\n        line.hoverStyle = hoverLineStyle;\n\n        // Update symbol\n        zrUtil.each(SYMBOL_CATEGORIES, function (symbolCategory) {\n            var symbol = this.childOfName(symbolCategory);\n            if (symbol) {\n                symbol.setColor(visualColor);\n                symbol.setStyle({\n                    opacity: visualOpacity\n                });\n            }\n        }, this);\n\n        var showLabel = labelModel.getShallow('show');\n        var hoverShowLabel = hoverLabelModel.getShallow('show');\n\n        var label = this.childOfName('label');\n        var defaultLabelColor;\n        var defaultText;\n\n        if (showLabel || hoverShowLabel) {\n            var rawVal = seriesModel.getRawValue(idx);\n            defaultText = rawVal == null\n                ? defaultText = lineData.getName(idx)\n                : isFinite(rawVal)\n                ? numberUtil.round(rawVal)\n                : rawVal;\n            defaultLabelColor = visualColor || '#000';\n        }\n\n        // label.afterUpdate = lineAfterUpdate;\n        if (showLabel) {\n            var textStyleModel = labelModel.getModel('textStyle');\n            label.setStyle({\n                text: zrUtil.retrieve(\n                    seriesModel.getFormattedLabel(idx, 'normal', lineData.dataType),\n                    defaultText\n                ),\n                textFont: textStyleModel.getFont(),\n                fill: textStyleModel.getTextColor() || defaultLabelColor\n            });\n\n            label.__textAlign = textStyleModel.get('align');\n            label.__verticalAlign = textStyleModel.get('baseline');\n            label.__position = labelModel.get('position');\n        }\n        else {\n            label.setStyle('text', '');\n        }\n        if (hoverShowLabel) {\n            var textStyleHoverModel = hoverLabelModel.getModel('textStyle');\n\n            label.hoverStyle = {\n                text: zrUtil.retrieve(\n                    seriesModel.getFormattedLabel(idx, 'emphasis', lineData.dataType),\n                    defaultText\n                ),\n                textFont: textStyleHoverModel.getFont(),\n                fill: textStyleHoverModel.getTextColor() || defaultLabelColor\n            };\n        }\n        else {\n            label.hoverStyle = {\n                text: ''\n            };\n        }\n\n        label.ignore = !showLabel && !hoverShowLabel;\n\n        graphic.setHoverStyle(this);\n    };\n\n    lineProto.updateLayout = function (lineData, idx) {\n        this.setLinePoints(lineData.getItemLayout(idx));\n    };\n\n    lineProto.setLinePoints = function (points) {\n        var linePath = this.childOfName('line');\n        setLinePoints(linePath.shape, points);\n        linePath.dirty();\n    };\n\n    zrUtil.inherits(Line, graphic.Group);\n\n    module.exports = Line;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTM3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2NoYXJ0L2hlbHBlci9MaW5lLmpzP2FlYjAiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9kdWxlIGVjaGFydHMvY2hhcnQvaGVscGVyL0xpbmVcbiAqL1xuXG5cbiAgICB2YXIgc3ltYm9sVXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvc3ltYm9sJyk7XG4gICAgdmFyIHZlY3RvciA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdmVjdG9yJyk7XG4gICAgLy8gdmFyIG1hdHJpeCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvbWF0cml4Jyk7XG4gICAgdmFyIExpbmVQYXRoID0gcmVxdWlyZSgnLi9MaW5lUGF0aCcpO1xuICAgIHZhciBncmFwaGljID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9ncmFwaGljJyk7XG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuICAgIHZhciBudW1iZXJVdGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9udW1iZXInKTtcblxuICAgIHZhciBTWU1CT0xfQ0FURUdPUklFUyA9IFsnZnJvbVN5bWJvbCcsICd0b1N5bWJvbCddO1xuICAgIGZ1bmN0aW9uIG1ha2VTeW1ib2xUeXBlS2V5KHN5bWJvbENhdGVnb3J5KSB7XG4gICAgICAgIHJldHVybiAnXycgKyBzeW1ib2xDYXRlZ29yeSArICdUeXBlJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlU3ltYm9sKG5hbWUsIGxpbmVEYXRhLCBpZHgpIHtcbiAgICAgICAgdmFyIGNvbG9yID0gbGluZURhdGEuZ2V0SXRlbVZpc3VhbChpZHgsICdjb2xvcicpO1xuICAgICAgICB2YXIgc3ltYm9sVHlwZSA9IGxpbmVEYXRhLmdldEl0ZW1WaXN1YWwoaWR4LCBuYW1lKTtcbiAgICAgICAgdmFyIHN5bWJvbFNpemUgPSBsaW5lRGF0YS5nZXRJdGVtVmlzdWFsKGlkeCwgbmFtZSArICdTaXplJyk7XG5cbiAgICAgICAgaWYgKCFzeW1ib2xUeXBlIHx8IHN5bWJvbFR5cGUgPT09ICdub25lJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF6clV0aWwuaXNBcnJheShzeW1ib2xTaXplKSkge1xuICAgICAgICAgICAgc3ltYm9sU2l6ZSA9IFtzeW1ib2xTaXplLCBzeW1ib2xTaXplXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3ltYm9sUGF0aCA9IHN5bWJvbFV0aWwuY3JlYXRlU3ltYm9sKFxuICAgICAgICAgICAgc3ltYm9sVHlwZSwgLXN5bWJvbFNpemVbMF0gLyAyLCAtc3ltYm9sU2l6ZVsxXSAvIDIsXG4gICAgICAgICAgICBzeW1ib2xTaXplWzBdLCBzeW1ib2xTaXplWzFdLCBjb2xvclxuICAgICAgICApO1xuXG4gICAgICAgIHN5bWJvbFBhdGgubmFtZSA9IG5hbWU7XG5cbiAgICAgICAgcmV0dXJuIHN5bWJvbFBhdGg7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlTGluZShwb2ludHMpIHtcbiAgICAgICAgdmFyIGxpbmUgPSBuZXcgTGluZVBhdGgoe1xuICAgICAgICAgICAgbmFtZTogJ2xpbmUnXG4gICAgICAgIH0pO1xuICAgICAgICBzZXRMaW5lUG9pbnRzKGxpbmUuc2hhcGUsIHBvaW50cyk7XG4gICAgICAgIHJldHVybiBsaW5lO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldExpbmVQb2ludHModGFyZ2V0U2hhcGUsIHBvaW50cykge1xuICAgICAgICB2YXIgcDEgPSBwb2ludHNbMF07XG4gICAgICAgIHZhciBwMiA9IHBvaW50c1sxXTtcbiAgICAgICAgdmFyIGNwMSA9IHBvaW50c1syXTtcbiAgICAgICAgdGFyZ2V0U2hhcGUueDEgPSBwMVswXTtcbiAgICAgICAgdGFyZ2V0U2hhcGUueTEgPSBwMVsxXTtcbiAgICAgICAgdGFyZ2V0U2hhcGUueDIgPSBwMlswXTtcbiAgICAgICAgdGFyZ2V0U2hhcGUueTIgPSBwMlsxXTtcbiAgICAgICAgdGFyZ2V0U2hhcGUucGVyY2VudCA9IDE7XG5cbiAgICAgICAgaWYgKGNwMSkge1xuICAgICAgICAgICAgdGFyZ2V0U2hhcGUuY3B4MSA9IGNwMVswXTtcbiAgICAgICAgICAgIHRhcmdldFNoYXBlLmNweTEgPSBjcDFbMV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0YXJnZXRTaGFwZS5jcHgxID0gTmFOO1xuICAgICAgICAgICAgdGFyZ2V0U2hhcGUuY3B5MSA9IE5hTjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVwZGF0ZVN5bWJvbEFuZExhYmVsQmVmb3JlTGluZVVwZGF0ZSAoKSB7XG4gICAgICAgIHZhciBsaW5lR3JvdXAgPSB0aGlzO1xuICAgICAgICB2YXIgc3ltYm9sRnJvbSA9IGxpbmVHcm91cC5jaGlsZE9mTmFtZSgnZnJvbVN5bWJvbCcpO1xuICAgICAgICB2YXIgc3ltYm9sVG8gPSBsaW5lR3JvdXAuY2hpbGRPZk5hbWUoJ3RvU3ltYm9sJyk7XG4gICAgICAgIHZhciBsYWJlbCA9IGxpbmVHcm91cC5jaGlsZE9mTmFtZSgnbGFiZWwnKTtcbiAgICAgICAgLy8gUXVpY2sgcmVqZWN0XG4gICAgICAgIGlmICghc3ltYm9sRnJvbSAmJiAhc3ltYm9sVG8gJiYgbGFiZWwuaWdub3JlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaW52U2NhbGUgPSAxO1xuICAgICAgICB2YXIgcGFyZW50Tm9kZSA9IHRoaXMucGFyZW50O1xuICAgICAgICB3aGlsZSAocGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgaWYgKHBhcmVudE5vZGUuc2NhbGUpIHtcbiAgICAgICAgICAgICAgICBpbnZTY2FsZSAvPSBwYXJlbnROb2RlLnNjYWxlWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxpbmUgPSBsaW5lR3JvdXAuY2hpbGRPZk5hbWUoJ2xpbmUnKTtcbiAgICAgICAgLy8gSWYgbGluZSBub3QgY2hhbmdlZFxuICAgICAgICAvLyBGSVhNRSBQYXJlbnQgc2NhbGUgY2hhbmdlZFxuICAgICAgICBpZiAoIXRoaXMuX19kaXJ0eSAmJiAhbGluZS5fX2RpcnR5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGVyY2VudCA9IGxpbmUuc2hhcGUucGVyY2VudDtcbiAgICAgICAgdmFyIGZyb21Qb3MgPSBsaW5lLnBvaW50QXQoMCk7XG4gICAgICAgIHZhciB0b1BvcyA9IGxpbmUucG9pbnRBdChwZXJjZW50KTtcblxuICAgICAgICB2YXIgZCA9IHZlY3Rvci5zdWIoW10sIHRvUG9zLCBmcm9tUG9zKTtcbiAgICAgICAgdmVjdG9yLm5vcm1hbGl6ZShkLCBkKTtcblxuICAgICAgICBpZiAoc3ltYm9sRnJvbSkge1xuICAgICAgICAgICAgc3ltYm9sRnJvbS5hdHRyKCdwb3NpdGlvbicsIGZyb21Qb3MpO1xuICAgICAgICAgICAgdmFyIHRhbmdlbnQgPSBsaW5lLnRhbmdlbnRBdCgwKTtcbiAgICAgICAgICAgIHN5bWJvbEZyb20uYXR0cigncm90YXRpb24nLCBNYXRoLlBJIC8gMiAtIE1hdGguYXRhbjIoXG4gICAgICAgICAgICAgICAgdGFuZ2VudFsxXSwgdGFuZ2VudFswXVxuICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICBzeW1ib2xGcm9tLmF0dHIoJ3NjYWxlJywgW2ludlNjYWxlICogcGVyY2VudCwgaW52U2NhbGUgKiBwZXJjZW50XSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN5bWJvbFRvKSB7XG4gICAgICAgICAgICBzeW1ib2xUby5hdHRyKCdwb3NpdGlvbicsIHRvUG9zKTtcbiAgICAgICAgICAgIHZhciB0YW5nZW50ID0gbGluZS50YW5nZW50QXQoMSk7XG4gICAgICAgICAgICBzeW1ib2xUby5hdHRyKCdyb3RhdGlvbicsIC1NYXRoLlBJIC8gMiAtIE1hdGguYXRhbjIoXG4gICAgICAgICAgICAgICAgdGFuZ2VudFsxXSwgdGFuZ2VudFswXVxuICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICBzeW1ib2xUby5hdHRyKCdzY2FsZScsIFtpbnZTY2FsZSAqIHBlcmNlbnQsIGludlNjYWxlICogcGVyY2VudF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFsYWJlbC5pZ25vcmUpIHtcbiAgICAgICAgICAgIGxhYmVsLmF0dHIoJ3Bvc2l0aW9uJywgdG9Qb3MpO1xuXG4gICAgICAgICAgICB2YXIgdGV4dFBvc2l0aW9uO1xuICAgICAgICAgICAgdmFyIHRleHRBbGlnbjtcbiAgICAgICAgICAgIHZhciB0ZXh0VmVydGljYWxBbGlnbjtcblxuICAgICAgICAgICAgdmFyIGRpc3RhbmNlID0gNSAqIGludlNjYWxlO1xuICAgICAgICAgICAgLy8gRW5kXG4gICAgICAgICAgICBpZiAobGFiZWwuX19wb3NpdGlvbiA9PT0gJ2VuZCcpIHtcbiAgICAgICAgICAgICAgICB0ZXh0UG9zaXRpb24gPSBbZFswXSAqIGRpc3RhbmNlICsgdG9Qb3NbMF0sIGRbMV0gKiBkaXN0YW5jZSArIHRvUG9zWzFdXTtcbiAgICAgICAgICAgICAgICB0ZXh0QWxpZ24gPSBkWzBdID4gMC44ID8gJ2xlZnQnIDogKGRbMF0gPCAtMC44ID8gJ3JpZ2h0JyA6ICdjZW50ZXInKTtcbiAgICAgICAgICAgICAgICB0ZXh0VmVydGljYWxBbGlnbiA9IGRbMV0gPiAwLjggPyAndG9wJyA6IChkWzFdIDwgLTAuOCA/ICdib3R0b20nIDogJ21pZGRsZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTWlkZGxlXG4gICAgICAgICAgICBlbHNlIGlmIChsYWJlbC5fX3Bvc2l0aW9uID09PSAnbWlkZGxlJykge1xuICAgICAgICAgICAgICAgIHZhciBoYWxmUGVyY2VudCA9IHBlcmNlbnQgLyAyO1xuICAgICAgICAgICAgICAgIHZhciB0YW5nZW50ID0gbGluZS50YW5nZW50QXQoaGFsZlBlcmNlbnQpO1xuICAgICAgICAgICAgICAgIHZhciBuID0gW3RhbmdlbnRbMV0sIC10YW5nZW50WzBdXTtcbiAgICAgICAgICAgICAgICB2YXIgY3AgPSBsaW5lLnBvaW50QXQoaGFsZlBlcmNlbnQpO1xuICAgICAgICAgICAgICAgIGlmIChuWzFdID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBuWzBdID0gLW5bMF07XG4gICAgICAgICAgICAgICAgICAgIG5bMV0gPSAtblsxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGV4dFBvc2l0aW9uID0gW2NwWzBdICsgblswXSAqIGRpc3RhbmNlLCBjcFsxXSArIG5bMV0gKiBkaXN0YW5jZV07XG4gICAgICAgICAgICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgICAgICAgdGV4dFZlcnRpY2FsQWxpZ24gPSAnYm90dG9tJztcbiAgICAgICAgICAgICAgICB2YXIgcm90YXRpb24gPSAtTWF0aC5hdGFuMih0YW5nZW50WzFdLCB0YW5nZW50WzBdKTtcbiAgICAgICAgICAgICAgICBpZiAodG9Qb3NbMF0gPCBmcm9tUG9zWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvdGF0aW9uID0gTWF0aC5QSSArIHJvdGF0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsYWJlbC5hdHRyKCdyb3RhdGlvbicsIHJvdGF0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFN0YXJ0XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0ZXh0UG9zaXRpb24gPSBbLWRbMF0gKiBkaXN0YW5jZSArIGZyb21Qb3NbMF0sIC1kWzFdICogZGlzdGFuY2UgKyBmcm9tUG9zWzFdXTtcbiAgICAgICAgICAgICAgICB0ZXh0QWxpZ24gPSBkWzBdID4gMC44ID8gJ3JpZ2h0JyA6IChkWzBdIDwgLTAuOCA/ICdsZWZ0JyA6ICdjZW50ZXInKTtcbiAgICAgICAgICAgICAgICB0ZXh0VmVydGljYWxBbGlnbiA9IGRbMV0gPiAwLjggPyAnYm90dG9tJyA6IChkWzFdIDwgLTAuOCA/ICd0b3AnIDogJ21pZGRsZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFiZWwuYXR0cih7XG4gICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVXNlIHRoZSB1c2VyIHNwZWNpZmllZCB0ZXh0IGFsaWduIGFuZCBiYXNlbGluZSBmaXJzdFxuICAgICAgICAgICAgICAgICAgICB0ZXh0VmVydGljYWxBbGlnbjogbGFiZWwuX192ZXJ0aWNhbEFsaWduIHx8IHRleHRWZXJ0aWNhbEFsaWduLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0QWxpZ246IGxhYmVsLl9fdGV4dEFsaWduIHx8IHRleHRBbGlnblxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IHRleHRQb3NpdGlvbixcbiAgICAgICAgICAgICAgICBzY2FsZTogW2ludlNjYWxlLCBpbnZTY2FsZV1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGV4dGVuZHMge21vZHVsZTp6cmVuZGVyL2dyYXBoaWMvR3JvdXB9XG4gICAgICogQGFsaWFzIHttb2R1bGU6ZWNoYXJ0cy9jaGFydC9oZWxwZXIvTGluZX1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBMaW5lKGxpbmVEYXRhLCBpZHgsIHNlcmllc1Njb3BlKSB7XG4gICAgICAgIGdyYXBoaWMuR3JvdXAuY2FsbCh0aGlzKTtcblxuICAgICAgICB0aGlzLl9jcmVhdGVMaW5lKGxpbmVEYXRhLCBpZHgsIHNlcmllc1Njb3BlKTtcbiAgICB9XG5cbiAgICB2YXIgbGluZVByb3RvID0gTGluZS5wcm90b3R5cGU7XG5cbiAgICAvLyBVcGRhdGUgc3ltYm9sIHBvc2l0aW9uIGFuZCByb3RhdGlvblxuICAgIGxpbmVQcm90by5iZWZvcmVVcGRhdGUgPSB1cGRhdGVTeW1ib2xBbmRMYWJlbEJlZm9yZUxpbmVVcGRhdGU7XG5cbiAgICBsaW5lUHJvdG8uX2NyZWF0ZUxpbmUgPSBmdW5jdGlvbiAobGluZURhdGEsIGlkeCwgc2VyaWVzU2NvcGUpIHtcbiAgICAgICAgdmFyIHNlcmllc01vZGVsID0gbGluZURhdGEuaG9zdE1vZGVsO1xuICAgICAgICB2YXIgbGluZVBvaW50cyA9IGxpbmVEYXRhLmdldEl0ZW1MYXlvdXQoaWR4KTtcblxuICAgICAgICB2YXIgbGluZSA9IGNyZWF0ZUxpbmUobGluZVBvaW50cyk7XG4gICAgICAgIGxpbmUuc2hhcGUucGVyY2VudCA9IDA7XG4gICAgICAgIGdyYXBoaWMuaW5pdFByb3BzKGxpbmUsIHtcbiAgICAgICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgICAgICAgcGVyY2VudDogMVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBzZXJpZXNNb2RlbCwgaWR4KTtcblxuICAgICAgICB0aGlzLmFkZChsaW5lKTtcblxuICAgICAgICB2YXIgbGFiZWwgPSBuZXcgZ3JhcGhpYy5UZXh0KHtcbiAgICAgICAgICAgIG5hbWU6ICdsYWJlbCdcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYWRkKGxhYmVsKTtcblxuICAgICAgICB6clV0aWwuZWFjaChTWU1CT0xfQ0FURUdPUklFUywgZnVuY3Rpb24gKHN5bWJvbENhdGVnb3J5KSB7XG4gICAgICAgICAgICB2YXIgc3ltYm9sID0gY3JlYXRlU3ltYm9sKHN5bWJvbENhdGVnb3J5LCBsaW5lRGF0YSwgaWR4KTtcbiAgICAgICAgICAgIC8vIHN5bWJvbHMgbXVzdCBhZGRlZCBhZnRlciBsaW5lIHRvIG1ha2Ugc3VyZVxuICAgICAgICAgICAgLy8gaXQgd2lsbCBiZSB1cGRhdGVkIGFmdGVyIGxpbmUjdXBkYXRlLlxuICAgICAgICAgICAgLy8gT3Igc3ltYm9sIHBvc2l0aW9uIGFuZCByb3RhdGlvbiB1cGRhdGUgaW4gbGluZSNiZWZvcmVVcGRhdGUgd2lsbCBiZSBvbmUgZnJhbWUgc2xvd1xuICAgICAgICAgICAgdGhpcy5hZGQoc3ltYm9sKTtcbiAgICAgICAgICAgIHRoaXNbbWFrZVN5bWJvbFR5cGVLZXkoc3ltYm9sQ2F0ZWdvcnkpXSA9IGxpbmVEYXRhLmdldEl0ZW1WaXN1YWwoaWR4LCBzeW1ib2xDYXRlZ29yeSk7XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIHRoaXMuX3VwZGF0ZUNvbW1vblN0bChsaW5lRGF0YSwgaWR4LCBzZXJpZXNTY29wZSk7XG4gICAgfTtcblxuICAgIGxpbmVQcm90by51cGRhdGVEYXRhID0gZnVuY3Rpb24gKGxpbmVEYXRhLCBpZHgsIHNlcmllc1Njb3BlKSB7XG4gICAgICAgIHZhciBzZXJpZXNNb2RlbCA9IGxpbmVEYXRhLmhvc3RNb2RlbDtcblxuICAgICAgICB2YXIgbGluZSA9IHRoaXMuY2hpbGRPZk5hbWUoJ2xpbmUnKTtcbiAgICAgICAgdmFyIGxpbmVQb2ludHMgPSBsaW5lRGF0YS5nZXRJdGVtTGF5b3V0KGlkeCk7XG4gICAgICAgIHZhciB0YXJnZXQgPSB7XG4gICAgICAgICAgICBzaGFwZToge31cbiAgICAgICAgfTtcbiAgICAgICAgc2V0TGluZVBvaW50cyh0YXJnZXQuc2hhcGUsIGxpbmVQb2ludHMpO1xuICAgICAgICBncmFwaGljLnVwZGF0ZVByb3BzKGxpbmUsIHRhcmdldCwgc2VyaWVzTW9kZWwsIGlkeCk7XG5cbiAgICAgICAgenJVdGlsLmVhY2goU1lNQk9MX0NBVEVHT1JJRVMsIGZ1bmN0aW9uIChzeW1ib2xDYXRlZ29yeSkge1xuICAgICAgICAgICAgdmFyIHN5bWJvbFR5cGUgPSBsaW5lRGF0YS5nZXRJdGVtVmlzdWFsKGlkeCwgc3ltYm9sQ2F0ZWdvcnkpO1xuICAgICAgICAgICAgdmFyIGtleSA9IG1ha2VTeW1ib2xUeXBlS2V5KHN5bWJvbENhdGVnb3J5KTtcbiAgICAgICAgICAgIC8vIFN5bWJvbCBjaGFuZ2VkXG4gICAgICAgICAgICBpZiAodGhpc1trZXldICE9PSBzeW1ib2xUeXBlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmUodGhpcy5jaGlsZE9mTmFtZShzeW1ib2xDYXRlZ29yeSkpO1xuICAgICAgICAgICAgICAgIHZhciBzeW1ib2wgPSBjcmVhdGVTeW1ib2woc3ltYm9sQ2F0ZWdvcnksIGxpbmVEYXRhLCBpZHgpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkKHN5bWJvbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzW2tleV0gPSBzeW1ib2xUeXBlO1xuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICB0aGlzLl91cGRhdGVDb21tb25TdGwobGluZURhdGEsIGlkeCwgc2VyaWVzU2NvcGUpO1xuICAgIH07XG5cbiAgICBsaW5lUHJvdG8uX3VwZGF0ZUNvbW1vblN0bCA9IGZ1bmN0aW9uIChsaW5lRGF0YSwgaWR4LCBzZXJpZXNTY29wZSkge1xuICAgICAgICB2YXIgc2VyaWVzTW9kZWwgPSBsaW5lRGF0YS5ob3N0TW9kZWw7XG5cbiAgICAgICAgdmFyIGxpbmUgPSB0aGlzLmNoaWxkT2ZOYW1lKCdsaW5lJyk7XG5cbiAgICAgICAgdmFyIGxpbmVTdHlsZSA9IHNlcmllc1Njb3BlICYmIHNlcmllc1Njb3BlLmxpbmVTdHlsZTtcbiAgICAgICAgdmFyIGhvdmVyTGluZVN0eWxlID0gc2VyaWVzU2NvcGUgJiYgc2VyaWVzU2NvcGUuaG92ZXJMaW5lU3R5bGU7XG4gICAgICAgIHZhciBsYWJlbE1vZGVsID0gc2VyaWVzU2NvcGUgJiYgc2VyaWVzU2NvcGUubGFiZWxNb2RlbDtcbiAgICAgICAgdmFyIGhvdmVyTGFiZWxNb2RlbCA9IHNlcmllc1Njb3BlICYmIHNlcmllc1Njb3BlLmhvdmVyTGFiZWxNb2RlbDtcblxuICAgICAgICAvLyBPcHRpbWl6YXRpb24gZm9yIGxhcmdlIGRhdGFzZXRcbiAgICAgICAgaWYgKCFzZXJpZXNTY29wZSB8fCBsaW5lRGF0YS5oYXNJdGVtT3B0aW9uKSB7XG4gICAgICAgICAgICB2YXIgaXRlbU1vZGVsID0gbGluZURhdGEuZ2V0SXRlbU1vZGVsKGlkeCk7XG5cbiAgICAgICAgICAgIGxpbmVTdHlsZSA9IGl0ZW1Nb2RlbC5nZXRNb2RlbCgnbGluZVN0eWxlLm5vcm1hbCcpLmdldExpbmVTdHlsZSgpO1xuICAgICAgICAgICAgaG92ZXJMaW5lU3R5bGUgPSBpdGVtTW9kZWwuZ2V0TW9kZWwoJ2xpbmVTdHlsZS5lbXBoYXNpcycpLmdldExpbmVTdHlsZSgpO1xuXG4gICAgICAgICAgICBsYWJlbE1vZGVsID0gaXRlbU1vZGVsLmdldE1vZGVsKCdsYWJlbC5ub3JtYWwnKTtcbiAgICAgICAgICAgIGhvdmVyTGFiZWxNb2RlbCA9IGl0ZW1Nb2RlbC5nZXRNb2RlbCgnbGFiZWwuZW1waGFzaXMnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB2aXN1YWxDb2xvciA9IGxpbmVEYXRhLmdldEl0ZW1WaXN1YWwoaWR4LCAnY29sb3InKTtcbiAgICAgICAgdmFyIHZpc3VhbE9wYWNpdHkgPSB6clV0aWwucmV0cmlldmUoXG4gICAgICAgICAgICBsaW5lRGF0YS5nZXRJdGVtVmlzdWFsKGlkeCwgJ29wYWNpdHknKSxcbiAgICAgICAgICAgIGxpbmVTdHlsZS5vcGFjaXR5LFxuICAgICAgICAgICAgMVxuICAgICAgICApO1xuXG4gICAgICAgIGxpbmUudXNlU3R5bGUoenJVdGlsLmRlZmF1bHRzKFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHN0cm9rZU5vU2NhbGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZmlsbDogJ25vbmUnLFxuICAgICAgICAgICAgICAgIHN0cm9rZTogdmlzdWFsQ29sb3IsXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogdmlzdWFsT3BhY2l0eVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxpbmVTdHlsZVxuICAgICAgICApKTtcbiAgICAgICAgbGluZS5ob3ZlclN0eWxlID0gaG92ZXJMaW5lU3R5bGU7XG5cbiAgICAgICAgLy8gVXBkYXRlIHN5bWJvbFxuICAgICAgICB6clV0aWwuZWFjaChTWU1CT0xfQ0FURUdPUklFUywgZnVuY3Rpb24gKHN5bWJvbENhdGVnb3J5KSB7XG4gICAgICAgICAgICB2YXIgc3ltYm9sID0gdGhpcy5jaGlsZE9mTmFtZShzeW1ib2xDYXRlZ29yeSk7XG4gICAgICAgICAgICBpZiAoc3ltYm9sKSB7XG4gICAgICAgICAgICAgICAgc3ltYm9sLnNldENvbG9yKHZpc3VhbENvbG9yKTtcbiAgICAgICAgICAgICAgICBzeW1ib2wuc2V0U3R5bGUoe1xuICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiB2aXN1YWxPcGFjaXR5XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIHZhciBzaG93TGFiZWwgPSBsYWJlbE1vZGVsLmdldFNoYWxsb3coJ3Nob3cnKTtcbiAgICAgICAgdmFyIGhvdmVyU2hvd0xhYmVsID0gaG92ZXJMYWJlbE1vZGVsLmdldFNoYWxsb3coJ3Nob3cnKTtcblxuICAgICAgICB2YXIgbGFiZWwgPSB0aGlzLmNoaWxkT2ZOYW1lKCdsYWJlbCcpO1xuICAgICAgICB2YXIgZGVmYXVsdExhYmVsQ29sb3I7XG4gICAgICAgIHZhciBkZWZhdWx0VGV4dDtcblxuICAgICAgICBpZiAoc2hvd0xhYmVsIHx8IGhvdmVyU2hvd0xhYmVsKSB7XG4gICAgICAgICAgICB2YXIgcmF3VmFsID0gc2VyaWVzTW9kZWwuZ2V0UmF3VmFsdWUoaWR4KTtcbiAgICAgICAgICAgIGRlZmF1bHRUZXh0ID0gcmF3VmFsID09IG51bGxcbiAgICAgICAgICAgICAgICA/IGRlZmF1bHRUZXh0ID0gbGluZURhdGEuZ2V0TmFtZShpZHgpXG4gICAgICAgICAgICAgICAgOiBpc0Zpbml0ZShyYXdWYWwpXG4gICAgICAgICAgICAgICAgPyBudW1iZXJVdGlsLnJvdW5kKHJhd1ZhbClcbiAgICAgICAgICAgICAgICA6IHJhd1ZhbDtcbiAgICAgICAgICAgIGRlZmF1bHRMYWJlbENvbG9yID0gdmlzdWFsQ29sb3IgfHwgJyMwMDAnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbGFiZWwuYWZ0ZXJVcGRhdGUgPSBsaW5lQWZ0ZXJVcGRhdGU7XG4gICAgICAgIGlmIChzaG93TGFiZWwpIHtcbiAgICAgICAgICAgIHZhciB0ZXh0U3R5bGVNb2RlbCA9IGxhYmVsTW9kZWwuZ2V0TW9kZWwoJ3RleHRTdHlsZScpO1xuICAgICAgICAgICAgbGFiZWwuc2V0U3R5bGUoe1xuICAgICAgICAgICAgICAgIHRleHQ6IHpyVXRpbC5yZXRyaWV2ZShcbiAgICAgICAgICAgICAgICAgICAgc2VyaWVzTW9kZWwuZ2V0Rm9ybWF0dGVkTGFiZWwoaWR4LCAnbm9ybWFsJywgbGluZURhdGEuZGF0YVR5cGUpLFxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0VGV4dFxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgdGV4dEZvbnQ6IHRleHRTdHlsZU1vZGVsLmdldEZvbnQoKSxcbiAgICAgICAgICAgICAgICBmaWxsOiB0ZXh0U3R5bGVNb2RlbC5nZXRUZXh0Q29sb3IoKSB8fCBkZWZhdWx0TGFiZWxDb2xvclxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGxhYmVsLl9fdGV4dEFsaWduID0gdGV4dFN0eWxlTW9kZWwuZ2V0KCdhbGlnbicpO1xuICAgICAgICAgICAgbGFiZWwuX192ZXJ0aWNhbEFsaWduID0gdGV4dFN0eWxlTW9kZWwuZ2V0KCdiYXNlbGluZScpO1xuICAgICAgICAgICAgbGFiZWwuX19wb3NpdGlvbiA9IGxhYmVsTW9kZWwuZ2V0KCdwb3NpdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGFiZWwuc2V0U3R5bGUoJ3RleHQnLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhvdmVyU2hvd0xhYmVsKSB7XG4gICAgICAgICAgICB2YXIgdGV4dFN0eWxlSG92ZXJNb2RlbCA9IGhvdmVyTGFiZWxNb2RlbC5nZXRNb2RlbCgndGV4dFN0eWxlJyk7XG5cbiAgICAgICAgICAgIGxhYmVsLmhvdmVyU3R5bGUgPSB7XG4gICAgICAgICAgICAgICAgdGV4dDogenJVdGlsLnJldHJpZXZlKFxuICAgICAgICAgICAgICAgICAgICBzZXJpZXNNb2RlbC5nZXRGb3JtYXR0ZWRMYWJlbChpZHgsICdlbXBoYXNpcycsIGxpbmVEYXRhLmRhdGFUeXBlKSxcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFRleHRcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIHRleHRGb250OiB0ZXh0U3R5bGVIb3Zlck1vZGVsLmdldEZvbnQoKSxcbiAgICAgICAgICAgICAgICBmaWxsOiB0ZXh0U3R5bGVIb3Zlck1vZGVsLmdldFRleHRDb2xvcigpIHx8IGRlZmF1bHRMYWJlbENvbG9yXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGFiZWwuaG92ZXJTdHlsZSA9IHtcbiAgICAgICAgICAgICAgICB0ZXh0OiAnJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxhYmVsLmlnbm9yZSA9ICFzaG93TGFiZWwgJiYgIWhvdmVyU2hvd0xhYmVsO1xuXG4gICAgICAgIGdyYXBoaWMuc2V0SG92ZXJTdHlsZSh0aGlzKTtcbiAgICB9O1xuXG4gICAgbGluZVByb3RvLnVwZGF0ZUxheW91dCA9IGZ1bmN0aW9uIChsaW5lRGF0YSwgaWR4KSB7XG4gICAgICAgIHRoaXMuc2V0TGluZVBvaW50cyhsaW5lRGF0YS5nZXRJdGVtTGF5b3V0KGlkeCkpO1xuICAgIH07XG5cbiAgICBsaW5lUHJvdG8uc2V0TGluZVBvaW50cyA9IGZ1bmN0aW9uIChwb2ludHMpIHtcbiAgICAgICAgdmFyIGxpbmVQYXRoID0gdGhpcy5jaGlsZE9mTmFtZSgnbGluZScpO1xuICAgICAgICBzZXRMaW5lUG9pbnRzKGxpbmVQYXRoLnNoYXBlLCBwb2ludHMpO1xuICAgICAgICBsaW5lUGF0aC5kaXJ0eSgpO1xuICAgIH07XG5cbiAgICB6clV0aWwuaW5oZXJpdHMoTGluZSwgZ3JhcGhpYy5Hcm91cCk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IExpbmU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9jaGFydC9oZWxwZXIvTGluZS5qc1xuLy8gbW9kdWxlIGlkID0gMTM3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 138 */
/* unknown exports provided */
/* all exports used */
/*!**************************************!*\
  !*** ./lib/chart/helper/LineDraw.js ***!
  \**************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * @module echarts/chart/helper/LineDraw\n */\n\n\n    var graphic = __webpack_require__(/*! ../../util/graphic */ 2);\n    var LineGroup = __webpack_require__(/*! ./Line */ 137);\n\n\n    function isPointNaN(pt) {\n        return isNaN(pt[0]) || isNaN(pt[1]);\n    }\n    function lineNeedsDraw(pts) {\n        return !isPointNaN(pts[0]) && !isPointNaN(pts[1]);\n    }\n    /**\n     * @alias module:echarts/component/marker/LineDraw\n     * @constructor\n     */\n    function LineDraw(ctor) {\n        this._ctor = ctor || LineGroup;\n        this.group = new graphic.Group();\n    }\n\n    var lineDrawProto = LineDraw.prototype;\n\n    /**\n     * @param {module:echarts/data/List} lineData\n     */\n    lineDrawProto.updateData = function (lineData) {\n\n        var oldLineData = this._lineData;\n        var group = this.group;\n        var LineCtor = this._ctor;\n\n        var hostModel = lineData.hostModel;\n\n        var seriesScope = {\n            lineStyle: hostModel.getModel('lineStyle.normal').getLineStyle(),\n            hoverLineStyle: hostModel.getModel('lineStyle.emphasis').getLineStyle(),\n            labelModel: hostModel.getModel('label.normal'),\n            hoverLabelModel: hostModel.getModel('label.emphasis')\n        };\n\n        lineData.diff(oldLineData)\n            .add(function (idx) {\n                if (!lineNeedsDraw(lineData.getItemLayout(idx))) {\n                    return;\n                }\n                var lineGroup = new LineCtor(lineData, idx, seriesScope);\n\n                lineData.setItemGraphicEl(idx, lineGroup);\n\n                group.add(lineGroup);\n            })\n            .update(function (newIdx, oldIdx) {\n                var lineGroup = oldLineData.getItemGraphicEl(oldIdx);\n                if (!lineNeedsDraw(lineData.getItemLayout(newIdx))) {\n                    group.remove(lineGroup);\n                    return;\n                }\n\n                if (!lineGroup) {\n                    lineGroup = new LineCtor(lineData, newIdx, seriesScope);\n                }\n                else {\n                    lineGroup.updateData(lineData, newIdx, seriesScope);\n                }\n\n                lineData.setItemGraphicEl(newIdx, lineGroup);\n\n                group.add(lineGroup);\n            })\n            .remove(function (idx) {\n                group.remove(oldLineData.getItemGraphicEl(idx));\n            })\n            .execute();\n\n        this._lineData = lineData;\n    };\n\n    lineDrawProto.updateLayout = function () {\n        var lineData = this._lineData;\n        lineData.eachItemGraphicEl(function (el, idx) {\n            el.updateLayout(lineData, idx);\n        }, this);\n    };\n\n    lineDrawProto.remove = function () {\n        this.group.removeAll();\n    };\n\n    module.exports = LineDraw;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTM4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2NoYXJ0L2hlbHBlci9MaW5lRHJhdy5qcz84ZGU4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQG1vZHVsZSBlY2hhcnRzL2NoYXJ0L2hlbHBlci9MaW5lRHJhd1xuICovXG5cblxuICAgIHZhciBncmFwaGljID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9ncmFwaGljJyk7XG4gICAgdmFyIExpbmVHcm91cCA9IHJlcXVpcmUoJy4vTGluZScpO1xuXG5cbiAgICBmdW5jdGlvbiBpc1BvaW50TmFOKHB0KSB7XG4gICAgICAgIHJldHVybiBpc05hTihwdFswXSkgfHwgaXNOYU4ocHRbMV0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBsaW5lTmVlZHNEcmF3KHB0cykge1xuICAgICAgICByZXR1cm4gIWlzUG9pbnROYU4ocHRzWzBdKSAmJiAhaXNQb2ludE5hTihwdHNbMV0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAYWxpYXMgbW9kdWxlOmVjaGFydHMvY29tcG9uZW50L21hcmtlci9MaW5lRHJhd1xuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIExpbmVEcmF3KGN0b3IpIHtcbiAgICAgICAgdGhpcy5fY3RvciA9IGN0b3IgfHwgTGluZUdyb3VwO1xuICAgICAgICB0aGlzLmdyb3VwID0gbmV3IGdyYXBoaWMuR3JvdXAoKTtcbiAgICB9XG5cbiAgICB2YXIgbGluZURyYXdQcm90byA9IExpbmVEcmF3LnByb3RvdHlwZTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvZGF0YS9MaXN0fSBsaW5lRGF0YVxuICAgICAqL1xuICAgIGxpbmVEcmF3UHJvdG8udXBkYXRlRGF0YSA9IGZ1bmN0aW9uIChsaW5lRGF0YSkge1xuXG4gICAgICAgIHZhciBvbGRMaW5lRGF0YSA9IHRoaXMuX2xpbmVEYXRhO1xuICAgICAgICB2YXIgZ3JvdXAgPSB0aGlzLmdyb3VwO1xuICAgICAgICB2YXIgTGluZUN0b3IgPSB0aGlzLl9jdG9yO1xuXG4gICAgICAgIHZhciBob3N0TW9kZWwgPSBsaW5lRGF0YS5ob3N0TW9kZWw7XG5cbiAgICAgICAgdmFyIHNlcmllc1Njb3BlID0ge1xuICAgICAgICAgICAgbGluZVN0eWxlOiBob3N0TW9kZWwuZ2V0TW9kZWwoJ2xpbmVTdHlsZS5ub3JtYWwnKS5nZXRMaW5lU3R5bGUoKSxcbiAgICAgICAgICAgIGhvdmVyTGluZVN0eWxlOiBob3N0TW9kZWwuZ2V0TW9kZWwoJ2xpbmVTdHlsZS5lbXBoYXNpcycpLmdldExpbmVTdHlsZSgpLFxuICAgICAgICAgICAgbGFiZWxNb2RlbDogaG9zdE1vZGVsLmdldE1vZGVsKCdsYWJlbC5ub3JtYWwnKSxcbiAgICAgICAgICAgIGhvdmVyTGFiZWxNb2RlbDogaG9zdE1vZGVsLmdldE1vZGVsKCdsYWJlbC5lbXBoYXNpcycpXG4gICAgICAgIH07XG5cbiAgICAgICAgbGluZURhdGEuZGlmZihvbGRMaW5lRGF0YSlcbiAgICAgICAgICAgIC5hZGQoZnVuY3Rpb24gKGlkeCkge1xuICAgICAgICAgICAgICAgIGlmICghbGluZU5lZWRzRHJhdyhsaW5lRGF0YS5nZXRJdGVtTGF5b3V0KGlkeCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGxpbmVHcm91cCA9IG5ldyBMaW5lQ3RvcihsaW5lRGF0YSwgaWR4LCBzZXJpZXNTY29wZSk7XG5cbiAgICAgICAgICAgICAgICBsaW5lRGF0YS5zZXRJdGVtR3JhcGhpY0VsKGlkeCwgbGluZUdyb3VwKTtcblxuICAgICAgICAgICAgICAgIGdyb3VwLmFkZChsaW5lR3JvdXApO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC51cGRhdGUoZnVuY3Rpb24gKG5ld0lkeCwgb2xkSWR4KSB7XG4gICAgICAgICAgICAgICAgdmFyIGxpbmVHcm91cCA9IG9sZExpbmVEYXRhLmdldEl0ZW1HcmFwaGljRWwob2xkSWR4KTtcbiAgICAgICAgICAgICAgICBpZiAoIWxpbmVOZWVkc0RyYXcobGluZURhdGEuZ2V0SXRlbUxheW91dChuZXdJZHgpKSkge1xuICAgICAgICAgICAgICAgICAgICBncm91cC5yZW1vdmUobGluZUdyb3VwKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghbGluZUdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVHcm91cCA9IG5ldyBMaW5lQ3RvcihsaW5lRGF0YSwgbmV3SWR4LCBzZXJpZXNTY29wZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsaW5lR3JvdXAudXBkYXRlRGF0YShsaW5lRGF0YSwgbmV3SWR4LCBzZXJpZXNTY29wZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGluZURhdGEuc2V0SXRlbUdyYXBoaWNFbChuZXdJZHgsIGxpbmVHcm91cCk7XG5cbiAgICAgICAgICAgICAgICBncm91cC5hZGQobGluZUdyb3VwKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAucmVtb3ZlKGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgICAgICAgICBncm91cC5yZW1vdmUob2xkTGluZURhdGEuZ2V0SXRlbUdyYXBoaWNFbChpZHgpKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuZXhlY3V0ZSgpO1xuXG4gICAgICAgIHRoaXMuX2xpbmVEYXRhID0gbGluZURhdGE7XG4gICAgfTtcblxuICAgIGxpbmVEcmF3UHJvdG8udXBkYXRlTGF5b3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbGluZURhdGEgPSB0aGlzLl9saW5lRGF0YTtcbiAgICAgICAgbGluZURhdGEuZWFjaEl0ZW1HcmFwaGljRWwoZnVuY3Rpb24gKGVsLCBpZHgpIHtcbiAgICAgICAgICAgIGVsLnVwZGF0ZUxheW91dChsaW5lRGF0YSwgaWR4KTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfTtcblxuICAgIGxpbmVEcmF3UHJvdG8ucmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmdyb3VwLnJlbW92ZUFsbCgpO1xuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IExpbmVEcmF3O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvY2hhcnQvaGVscGVyL0xpbmVEcmF3LmpzXG4vLyBtb2R1bGUgaWQgPSAxMzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 139 */
/* unknown exports provided */
/* all exports used */
/*!**************************************!*\
  !*** ./lib/chart/line/LineSeries.js ***!
  \**************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\n    var createListFromArray = __webpack_require__(/*! ../helper/createListFromArray */ 27);\n    var SeriesModel = __webpack_require__(/*! ../../model/Series */ 17);\n\n    module.exports = SeriesModel.extend({\n\n        type: 'series.line',\n\n        dependencies: ['grid', 'polar'],\n\n        getInitialData: function (option, ecModel) {\n            if (true) {\n                var coordSys = option.coordinateSystem;\n                if (coordSys !== 'polar' && coordSys !== 'cartesian2d') {\n                    throw new Error('Line not support coordinateSystem besides cartesian and polar');\n                }\n            }\n            return createListFromArray(option.data, this, ecModel);\n        },\n\n        defaultOption: {\n            zlevel: 0,                  // 一级层叠\n            z: 2,                       // 二级层叠\n            coordinateSystem: 'cartesian2d',\n            legendHoverLink: true,\n\n            hoverAnimation: true,\n            // stack: null\n            // xAxisIndex: 0,\n            // yAxisIndex: 0,\n\n            // polarIndex: 0,\n\n            // If clip the overflow value\n            clipOverflow: true,\n\n            label: {\n                normal: {\n                    position: 'top'\n                }\n            },\n            // itemStyle: {\n            //     normal: {},\n            //     emphasis: {}\n            // },\n            lineStyle: {\n                normal: {\n                    width: 2,\n                    type: 'solid'\n                }\n            },\n            // areaStyle: {},\n            // false, 'start', 'end', 'middle'\n            step: false,\n\n            // Disabled if step is true\n            smooth: false,\n            smoothMonotone: null,\n            // 拐点图形类型\n            symbol: 'emptyCircle',\n            // 拐点图形大小\n            symbolSize: 4,\n            // 拐点图形旋转控制\n            symbolRotate: null,\n\n            // 是否显示 symbol, 只有在 tooltip hover 的时候显示\n            showSymbol: true,\n            // 标志图形默认只有主轴显示（随主轴标签间隔隐藏策略）\n            showAllSymbol: false,\n\n            // 是否连接断点\n            connectNulls: false,\n\n            // 数据过滤，'average', 'max', 'min', 'sum'\n            sampling: 'none',\n\n            animationEasing: 'linear',\n\n            // Disable progressive\n            progressive: 0,\n            hoverLayerThreshold: Infinity\n        }\n    });\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTM5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2NoYXJ0L2xpbmUvTGluZVNlcmllcy5qcz9jMDlhIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuXG4gICAgdmFyIGNyZWF0ZUxpc3RGcm9tQXJyYXkgPSByZXF1aXJlKCcuLi9oZWxwZXIvY3JlYXRlTGlzdEZyb21BcnJheScpO1xuICAgIHZhciBTZXJpZXNNb2RlbCA9IHJlcXVpcmUoJy4uLy4uL21vZGVsL1NlcmllcycpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBTZXJpZXNNb2RlbC5leHRlbmQoe1xuXG4gICAgICAgIHR5cGU6ICdzZXJpZXMubGluZScsXG5cbiAgICAgICAgZGVwZW5kZW5jaWVzOiBbJ2dyaWQnLCAncG9sYXInXSxcblxuICAgICAgICBnZXRJbml0aWFsRGF0YTogZnVuY3Rpb24gKG9wdGlvbiwgZWNNb2RlbCkge1xuICAgICAgICAgICAgaWYgKF9fREVWX18pIHtcbiAgICAgICAgICAgICAgICB2YXIgY29vcmRTeXMgPSBvcHRpb24uY29vcmRpbmF0ZVN5c3RlbTtcbiAgICAgICAgICAgICAgICBpZiAoY29vcmRTeXMgIT09ICdwb2xhcicgJiYgY29vcmRTeXMgIT09ICdjYXJ0ZXNpYW4yZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdMaW5lIG5vdCBzdXBwb3J0IGNvb3JkaW5hdGVTeXN0ZW0gYmVzaWRlcyBjYXJ0ZXNpYW4gYW5kIHBvbGFyJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUxpc3RGcm9tQXJyYXkob3B0aW9uLmRhdGEsIHRoaXMsIGVjTW9kZWwpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRlZmF1bHRPcHRpb246IHtcbiAgICAgICAgICAgIHpsZXZlbDogMCwgICAgICAgICAgICAgICAgICAvLyDkuIDnuqflsYLlj6BcbiAgICAgICAgICAgIHo6IDIsICAgICAgICAgICAgICAgICAgICAgICAvLyDkuoznuqflsYLlj6BcbiAgICAgICAgICAgIGNvb3JkaW5hdGVTeXN0ZW06ICdjYXJ0ZXNpYW4yZCcsXG4gICAgICAgICAgICBsZWdlbmRIb3Zlckxpbms6IHRydWUsXG5cbiAgICAgICAgICAgIGhvdmVyQW5pbWF0aW9uOiB0cnVlLFxuICAgICAgICAgICAgLy8gc3RhY2s6IG51bGxcbiAgICAgICAgICAgIC8vIHhBeGlzSW5kZXg6IDAsXG4gICAgICAgICAgICAvLyB5QXhpc0luZGV4OiAwLFxuXG4gICAgICAgICAgICAvLyBwb2xhckluZGV4OiAwLFxuXG4gICAgICAgICAgICAvLyBJZiBjbGlwIHRoZSBvdmVyZmxvdyB2YWx1ZVxuICAgICAgICAgICAgY2xpcE92ZXJmbG93OiB0cnVlLFxuXG4gICAgICAgICAgICBsYWJlbDoge1xuICAgICAgICAgICAgICAgIG5vcm1hbDoge1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ3RvcCdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gaXRlbVN0eWxlOiB7XG4gICAgICAgICAgICAvLyAgICAgbm9ybWFsOiB7fSxcbiAgICAgICAgICAgIC8vICAgICBlbXBoYXNpczoge31cbiAgICAgICAgICAgIC8vIH0sXG4gICAgICAgICAgICBsaW5lU3R5bGU6IHtcbiAgICAgICAgICAgICAgICBub3JtYWw6IHtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDIsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdzb2xpZCdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gYXJlYVN0eWxlOiB7fSxcbiAgICAgICAgICAgIC8vIGZhbHNlLCAnc3RhcnQnLCAnZW5kJywgJ21pZGRsZSdcbiAgICAgICAgICAgIHN0ZXA6IGZhbHNlLFxuXG4gICAgICAgICAgICAvLyBEaXNhYmxlZCBpZiBzdGVwIGlzIHRydWVcbiAgICAgICAgICAgIHNtb290aDogZmFsc2UsXG4gICAgICAgICAgICBzbW9vdGhNb25vdG9uZTogbnVsbCxcbiAgICAgICAgICAgIC8vIOaLkOeCueWbvuW9ouexu+Wei1xuICAgICAgICAgICAgc3ltYm9sOiAnZW1wdHlDaXJjbGUnLFxuICAgICAgICAgICAgLy8g5ouQ54K55Zu+5b2i5aSn5bCPXG4gICAgICAgICAgICBzeW1ib2xTaXplOiA0LFxuICAgICAgICAgICAgLy8g5ouQ54K55Zu+5b2i5peL6L2s5o6n5Yi2XG4gICAgICAgICAgICBzeW1ib2xSb3RhdGU6IG51bGwsXG5cbiAgICAgICAgICAgIC8vIOaYr+WQpuaYvuekuiBzeW1ib2wsIOWPquacieWcqCB0b29sdGlwIGhvdmVyIOeahOaXtuWAmeaYvuekulxuICAgICAgICAgICAgc2hvd1N5bWJvbDogdHJ1ZSxcbiAgICAgICAgICAgIC8vIOagh+W/l+WbvuW9oum7mOiupOWPquacieS4u+i9tOaYvuekuu+8iOmaj+S4u+i9tOagh+etvumXtOmalOmakOiXj+etlueVpe+8iVxuICAgICAgICAgICAgc2hvd0FsbFN5bWJvbDogZmFsc2UsXG5cbiAgICAgICAgICAgIC8vIOaYr+WQpui/nuaOpeaWreeCuVxuICAgICAgICAgICAgY29ubmVjdE51bGxzOiBmYWxzZSxcblxuICAgICAgICAgICAgLy8g5pWw5o2u6L+H5ruk77yMJ2F2ZXJhZ2UnLCAnbWF4JywgJ21pbicsICdzdW0nXG4gICAgICAgICAgICBzYW1wbGluZzogJ25vbmUnLFxuXG4gICAgICAgICAgICBhbmltYXRpb25FYXNpbmc6ICdsaW5lYXInLFxuXG4gICAgICAgICAgICAvLyBEaXNhYmxlIHByb2dyZXNzaXZlXG4gICAgICAgICAgICBwcm9ncmVzc2l2ZTogMCxcbiAgICAgICAgICAgIGhvdmVyTGF5ZXJUaHJlc2hvbGQ6IEluZmluaXR5XG4gICAgICAgIH1cbiAgICB9KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2NoYXJ0L2xpbmUvTGluZVNlcmllcy5qc1xuLy8gbW9kdWxlIGlkID0gMTM5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 140 */
/* unknown exports provided */
/* all exports used */
/*!************************************!*\
  !*** ./lib/chart/line/LineView.js ***!
  \************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n// FIXME step not support polar\n\n\n    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 0);\n    var SymbolDraw = __webpack_require__(/*! ../helper/SymbolDraw */ 44);\n    var Symbol = __webpack_require__(/*! ../helper/Symbol */ 55);\n    var lineAnimationDiff = __webpack_require__(/*! ./lineAnimationDiff */ 141);\n    var graphic = __webpack_require__(/*! ../../util/graphic */ 2);\n    var modelUtil = __webpack_require__(/*! ../../util/model */ 5);\n    var polyHelper = __webpack_require__(/*! ./poly */ 97);\n    var ChartView = __webpack_require__(/*! ../../view/Chart */ 29);\n\n    function isPointsSame(points1, points2) {\n        if (points1.length !== points2.length) {\n            return;\n        }\n        for (var i = 0; i < points1.length; i++) {\n            var p1 = points1[i];\n            var p2 = points2[i];\n            if (p1[0] !== p2[0] || p1[1] !== p2[1]) {\n                return;\n            }\n        }\n        return true;\n    }\n\n    function getSmooth(smooth) {\n        return typeof (smooth) === 'number' ? smooth : (smooth ? 0.3 : 0);\n    }\n\n    function getAxisExtentWithGap(axis) {\n        var extent = axis.getGlobalExtent();\n        if (axis.onBand) {\n            // Remove extra 1px to avoid line miter in clipped edge\n            var halfBandWidth = axis.getBandWidth() / 2 - 1;\n            var dir = extent[1] > extent[0] ? 1 : -1;\n            extent[0] += dir * halfBandWidth;\n            extent[1] -= dir * halfBandWidth;\n        }\n        return extent;\n    }\n\n    function sign(val) {\n        return val >= 0 ? 1 : -1;\n    }\n    /**\n     * @param {module:echarts/coord/cartesian/Cartesian2D|module:echarts/coord/polar/Polar} coordSys\n     * @param {module:echarts/data/List} data\n     * @param {Array.<Array.<number>>} points\n     * @private\n     */\n    function getStackedOnPoints(coordSys, data) {\n        var baseAxis = coordSys.getBaseAxis();\n        var valueAxis = coordSys.getOtherAxis(baseAxis);\n        var valueStart = baseAxis.onZero\n            ? 0 : valueAxis.scale.getExtent()[0];\n\n        var valueDim = valueAxis.dim;\n\n        var baseDataOffset = valueDim === 'x' || valueDim === 'radius' ? 1 : 0;\n\n        return data.mapArray([valueDim], function (val, idx) {\n            var stackedOnSameSign;\n            var stackedOn = data.stackedOn;\n            // Find first stacked value with same sign\n            while (stackedOn &&\n                sign(stackedOn.get(valueDim, idx)) === sign(val)\n            ) {\n                stackedOnSameSign = stackedOn;\n                break;\n            }\n            var stackedData = [];\n            stackedData[baseDataOffset] = data.get(baseAxis.dim, idx);\n            stackedData[1 - baseDataOffset] = stackedOnSameSign\n                ? stackedOnSameSign.get(valueDim, idx, true) : valueStart;\n\n            return coordSys.dataToPoint(stackedData);\n        }, true);\n    }\n\n    function createGridClipShape(cartesian, hasAnimation, seriesModel) {\n        var xExtent = getAxisExtentWithGap(cartesian.getAxis('x'));\n        var yExtent = getAxisExtentWithGap(cartesian.getAxis('y'));\n        var isHorizontal = cartesian.getBaseAxis().isHorizontal();\n\n        var x = Math.min(xExtent[0], xExtent[1]);\n        var y = Math.min(yExtent[0], yExtent[1]);\n        var width = Math.max(xExtent[0], xExtent[1]) - x;\n        var height = Math.max(yExtent[0], yExtent[1]) - y;\n        var lineWidth = seriesModel.get('lineStyle.normal.width') || 2;\n        // Expand clip shape to avoid clipping when line value exceeds axis\n        var expandSize = seriesModel.get('clipOverflow') ? lineWidth / 2 : Math.max(width, height);\n        if (isHorizontal) {\n            y -= expandSize;\n            height += expandSize * 2;\n        }\n        else {\n            x -= expandSize;\n            width += expandSize * 2;\n        }\n\n        var clipPath = new graphic.Rect({\n            shape: {\n                x: x,\n                y: y,\n                width: width,\n                height: height\n            }\n        });\n\n        if (hasAnimation) {\n            clipPath.shape[isHorizontal ? 'width' : 'height'] = 0;\n            graphic.initProps(clipPath, {\n                shape: {\n                    width: width,\n                    height: height\n                }\n            }, seriesModel);\n        }\n\n        return clipPath;\n    }\n\n    function createPolarClipShape(polar, hasAnimation, seriesModel) {\n        var angleAxis = polar.getAngleAxis();\n        var radiusAxis = polar.getRadiusAxis();\n\n        var radiusExtent = radiusAxis.getExtent();\n        var angleExtent = angleAxis.getExtent();\n\n        var RADIAN = Math.PI / 180;\n\n        var clipPath = new graphic.Sector({\n            shape: {\n                cx: polar.cx,\n                cy: polar.cy,\n                r0: radiusExtent[0],\n                r: radiusExtent[1],\n                startAngle: -angleExtent[0] * RADIAN,\n                endAngle: -angleExtent[1] * RADIAN,\n                clockwise: angleAxis.inverse\n            }\n        });\n\n        if (hasAnimation) {\n            clipPath.shape.endAngle = -angleExtent[0] * RADIAN;\n            graphic.initProps(clipPath, {\n                shape: {\n                    endAngle: -angleExtent[1] * RADIAN\n                }\n            }, seriesModel);\n        }\n\n        return clipPath;\n    }\n\n    function createClipShape(coordSys, hasAnimation, seriesModel) {\n        return coordSys.type === 'polar'\n            ? createPolarClipShape(coordSys, hasAnimation, seriesModel)\n            : createGridClipShape(coordSys, hasAnimation, seriesModel);\n    }\n\n    function turnPointsIntoStep(points, coordSys, stepTurnAt) {\n        var baseAxis = coordSys.getBaseAxis();\n        var baseIndex = baseAxis.dim === 'x' || baseAxis.dim === 'radius' ? 0 : 1;\n\n        var stepPoints = [];\n        for (var i = 0; i < points.length - 1; i++) {\n            var nextPt = points[i + 1];\n            var pt = points[i];\n            stepPoints.push(pt);\n\n            var stepPt = [];\n            switch (stepTurnAt) {\n                case 'end':\n                    stepPt[baseIndex] = nextPt[baseIndex];\n                    stepPt[1 - baseIndex] = pt[1 - baseIndex];\n                    // default is start\n                    stepPoints.push(stepPt);\n                    break;\n                case 'middle':\n                    // default is start\n                    var middle = (pt[baseIndex] + nextPt[baseIndex]) / 2;\n                    var stepPt2 = [];\n                    stepPt[baseIndex] = stepPt2[baseIndex] = middle;\n                    stepPt[1 - baseIndex] = pt[1 - baseIndex];\n                    stepPt2[1 - baseIndex] = nextPt[1 - baseIndex];\n                    stepPoints.push(stepPt);\n                    stepPoints.push(stepPt2);\n                    break;\n                default:\n                    stepPt[baseIndex] = pt[baseIndex];\n                    stepPt[1 - baseIndex] = nextPt[1 - baseIndex];\n                    // default is start\n                    stepPoints.push(stepPt);\n            }\n        }\n        // Last points\n        points[i] && stepPoints.push(points[i]);\n        return stepPoints;\n    }\n\n    function getVisualGradient(data, coordSys) {\n        var visualMetaList = data.getVisual('visualMeta');\n        if (!visualMetaList || !visualMetaList.length || !data.count()) {\n            // When data.count() is 0, gradient range can not be calculated.\n            return;\n        }\n\n        var visualMeta;\n        for (var i = visualMetaList.length - 1; i >= 0; i--) {\n            // Can only be x or y\n            if (visualMetaList[i].dimension < 2) {\n                visualMeta = visualMetaList[i];\n                break;\n            }\n        }\n        if (!visualMeta || coordSys.type !== 'cartesian2d') {\n            if (true) {\n                console.warn('Visual map on line style only support x or y dimension.');\n            }\n            return;\n        }\n\n        // If the area to be rendered is bigger than area defined by LinearGradient,\n        // the canvas spec prescribes that the color of the first stop and the last\n        // stop should be used. But if two stops are added at offset 0, in effect\n        // browsers use the color of the second stop to render area outside\n        // LinearGradient. So we can only infinitesimally extend area defined in\n        // LinearGradient to render `outerColors`.\n\n        var dimension = visualMeta.dimension;\n        var dimName = data.dimensions[dimension];\n        var axis = coordSys.getAxis(dimName);\n\n        // dataToCoor mapping may not be linear, but must be monotonic.\n        var colorStops = zrUtil.map(visualMeta.stops, function (stop) {\n            return {\n                coord: axis.toGlobalCoord(axis.dataToCoord(stop.value)),\n                color: stop.color\n            };\n        });\n        var stopLen = colorStops.length;\n        var outerColors = visualMeta.outerColors.slice();\n\n        if (stopLen && colorStops[0].coord > colorStops[stopLen - 1].coord) {\n            colorStops.reverse();\n            outerColors.reverse();\n        }\n\n        var tinyExtent = 10; // Arbitrary value: 10px\n        var minCoord = colorStops[0].coord - tinyExtent;\n        var maxCoord = colorStops[stopLen - 1].coord + tinyExtent;\n        var coordSpan = maxCoord - minCoord;\n\n        if (coordSpan < 1e-3) {\n            return 'transparent';\n        }\n\n        zrUtil.each(colorStops, function (stop) {\n            stop.offset = (stop.coord - minCoord) / coordSpan;\n        });\n        colorStops.push({\n            offset: stopLen ? colorStops[stopLen - 1].offset : 0.5,\n            color: outerColors[1] || 'transparent'\n        });\n        colorStops.unshift({ // notice colorStops.length have been changed.\n            offset: stopLen ? colorStops[0].offset : 0.5,\n            color: outerColors[0] || 'transparent'\n        });\n\n        // zrUtil.each(colorStops, function (colorStop) {\n        //     // Make sure each offset has rounded px to avoid not sharp edge\n        //     colorStop.offset = (Math.round(colorStop.offset * (end - start) + start) - start) / (end - start);\n        // });\n\n        var gradient = new graphic.LinearGradient(0, 0, 0, 0, colorStops, true);\n        gradient[dimName] = minCoord;\n        gradient[dimName + '2'] = maxCoord;\n\n        return gradient;\n    }\n\n    module.exports = ChartView.extend({\n\n        type: 'line',\n\n        init: function () {\n            var lineGroup = new graphic.Group();\n\n            var symbolDraw = new SymbolDraw();\n            this.group.add(symbolDraw.group);\n\n            this._symbolDraw = symbolDraw;\n            this._lineGroup = lineGroup;\n        },\n\n        render: function (seriesModel, ecModel, api) {\n            var coordSys = seriesModel.coordinateSystem;\n            var group = this.group;\n            var data = seriesModel.getData();\n            var lineStyleModel = seriesModel.getModel('lineStyle.normal');\n            var areaStyleModel = seriesModel.getModel('areaStyle.normal');\n\n            var points = data.mapArray(data.getItemLayout, true);\n\n            var isCoordSysPolar = coordSys.type === 'polar';\n            var prevCoordSys = this._coordSys;\n\n            var symbolDraw = this._symbolDraw;\n            var polyline = this._polyline;\n            var polygon = this._polygon;\n\n            var lineGroup = this._lineGroup;\n\n            var hasAnimation = seriesModel.get('animation');\n\n            var isAreaChart = !areaStyleModel.isEmpty();\n            var stackedOnPoints = getStackedOnPoints(coordSys, data);\n\n            var showSymbol = seriesModel.get('showSymbol');\n\n            var isSymbolIgnore = showSymbol && !isCoordSysPolar && !seriesModel.get('showAllSymbol')\n                && this._getSymbolIgnoreFunc(data, coordSys);\n\n            // Remove temporary symbols\n            var oldData = this._data;\n            oldData && oldData.eachItemGraphicEl(function (el, idx) {\n                if (el.__temp) {\n                    group.remove(el);\n                    oldData.setItemGraphicEl(idx, null);\n                }\n            });\n\n            // Remove previous created symbols if showSymbol changed to false\n            if (!showSymbol) {\n                symbolDraw.remove();\n            }\n\n            group.add(lineGroup);\n\n            // FIXME step not support polar\n            var step = !isCoordSysPolar && seriesModel.get('step');\n            // Initialization animation or coordinate system changed\n            if (\n                !(polyline && prevCoordSys.type === coordSys.type && step === this._step)\n            ) {\n                showSymbol && symbolDraw.updateData(data, isSymbolIgnore);\n\n                if (step) {\n                    // TODO If stacked series is not step\n                    points = turnPointsIntoStep(points, coordSys, step);\n                    stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);\n                }\n\n                polyline = this._newPolyline(points, coordSys, hasAnimation);\n                if (isAreaChart) {\n                    polygon = this._newPolygon(\n                        points, stackedOnPoints,\n                        coordSys, hasAnimation\n                    );\n                }\n                lineGroup.setClipPath(createClipShape(coordSys, true, seriesModel));\n            }\n            else {\n                if (isAreaChart && !polygon) {\n                    // If areaStyle is added\n                    polygon = this._newPolygon(\n                        points, stackedOnPoints,\n                        coordSys, hasAnimation\n                    );\n                }\n                else if (polygon && !isAreaChart) {\n                    // If areaStyle is removed\n                    lineGroup.remove(polygon);\n                    polygon = this._polygon = null;\n                }\n\n                // Update clipPath\n                lineGroup.setClipPath(createClipShape(coordSys, false, seriesModel));\n\n                // Always update, or it is wrong in the case turning on legend\n                // because points are not changed\n                showSymbol && symbolDraw.updateData(data, isSymbolIgnore);\n\n                // Stop symbol animation and sync with line points\n                // FIXME performance?\n                data.eachItemGraphicEl(function (el) {\n                    el.stopAnimation(true);\n                });\n\n                // In the case data zoom triggerred refreshing frequently\n                // Data may not change if line has a category axis. So it should animate nothing\n                if (!isPointsSame(this._stackedOnPoints, stackedOnPoints)\n                    || !isPointsSame(this._points, points)\n                ) {\n                    if (hasAnimation) {\n                        this._updateAnimation(\n                            data, stackedOnPoints, coordSys, api, step\n                        );\n                    }\n                    else {\n                        // Not do it in update with animation\n                        if (step) {\n                            // TODO If stacked series is not step\n                            points = turnPointsIntoStep(points, coordSys, step);\n                            stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);\n                        }\n\n                        polyline.setShape({\n                            points: points\n                        });\n                        polygon && polygon.setShape({\n                            points: points,\n                            stackedOnPoints: stackedOnPoints\n                        });\n                    }\n                }\n            }\n\n            var visualColor = getVisualGradient(data, coordSys) || data.getVisual('color');\n\n            polyline.useStyle(zrUtil.defaults(\n                // Use color in lineStyle first\n                lineStyleModel.getLineStyle(),\n                {\n                    fill: 'none',\n                    stroke: visualColor,\n                    lineJoin: 'bevel'\n                }\n            ));\n\n            var smooth = seriesModel.get('smooth');\n            smooth = getSmooth(seriesModel.get('smooth'));\n            polyline.setShape({\n                smooth: smooth,\n                smoothMonotone: seriesModel.get('smoothMonotone'),\n                connectNulls: seriesModel.get('connectNulls')\n            });\n\n            if (polygon) {\n                var stackedOn = data.stackedOn;\n                var stackedOnSmooth = 0;\n\n                polygon.useStyle(zrUtil.defaults(\n                    areaStyleModel.getAreaStyle(),\n                    {\n                        fill: visualColor,\n                        opacity: 0.7,\n                        lineJoin: 'bevel'\n                    }\n                ));\n\n                if (stackedOn) {\n                    var stackedOnSeries = stackedOn.hostModel;\n                    stackedOnSmooth = getSmooth(stackedOnSeries.get('smooth'));\n                }\n\n                polygon.setShape({\n                    smooth: smooth,\n                    stackedOnSmooth: stackedOnSmooth,\n                    smoothMonotone: seriesModel.get('smoothMonotone'),\n                    connectNulls: seriesModel.get('connectNulls')\n                });\n            }\n\n            this._data = data;\n            // Save the coordinate system for transition animation when data changed\n            this._coordSys = coordSys;\n            this._stackedOnPoints = stackedOnPoints;\n            this._points = points;\n            this._step = step;\n        },\n\n        dispose: function () {},\n\n        highlight: function (seriesModel, ecModel, api, payload) {\n            var data = seriesModel.getData();\n            var dataIndex = modelUtil.queryDataIndex(data, payload);\n\n            if (!(dataIndex instanceof Array) && dataIndex != null && dataIndex >= 0) {\n                var symbol = data.getItemGraphicEl(dataIndex);\n                if (!symbol) {\n                    // Create a temporary symbol if it is not exists\n                    var pt = data.getItemLayout(dataIndex);\n                    if (!pt) {\n                        // Null data\n                        return;\n                    }\n                    symbol = new Symbol(data, dataIndex);\n                    symbol.position = pt;\n                    symbol.setZ(\n                        seriesModel.get('zlevel'),\n                        seriesModel.get('z')\n                    );\n                    symbol.ignore = isNaN(pt[0]) || isNaN(pt[1]);\n                    symbol.__temp = true;\n                    data.setItemGraphicEl(dataIndex, symbol);\n\n                    // Stop scale animation\n                    symbol.stopSymbolAnimation(true);\n\n                    this.group.add(symbol);\n                }\n                symbol.highlight();\n            }\n            else {\n                // Highlight whole series\n                ChartView.prototype.highlight.call(\n                    this, seriesModel, ecModel, api, payload\n                );\n            }\n        },\n\n        downplay: function (seriesModel, ecModel, api, payload) {\n            var data = seriesModel.getData();\n            var dataIndex = modelUtil.queryDataIndex(data, payload);\n            if (dataIndex != null && dataIndex >= 0) {\n                var symbol = data.getItemGraphicEl(dataIndex);\n                if (symbol) {\n                    if (symbol.__temp) {\n                        data.setItemGraphicEl(dataIndex, null);\n                        this.group.remove(symbol);\n                    }\n                    else {\n                        symbol.downplay();\n                    }\n                }\n            }\n            else {\n                // FIXME\n                // can not downplay completely.\n                // Downplay whole series\n                ChartView.prototype.downplay.call(\n                    this, seriesModel, ecModel, api, payload\n                );\n            }\n        },\n\n        /**\n         * @param {module:zrender/container/Group} group\n         * @param {Array.<Array.<number>>} points\n         * @private\n         */\n        _newPolyline: function (points) {\n            var polyline = this._polyline;\n            // Remove previous created polyline\n            if (polyline) {\n                this._lineGroup.remove(polyline);\n            }\n\n            polyline = new polyHelper.Polyline({\n                shape: {\n                    points: points\n                },\n                silent: true,\n                z2: 10\n            });\n\n            this._lineGroup.add(polyline);\n\n            this._polyline = polyline;\n\n            return polyline;\n        },\n\n        /**\n         * @param {module:zrender/container/Group} group\n         * @param {Array.<Array.<number>>} stackedOnPoints\n         * @param {Array.<Array.<number>>} points\n         * @private\n         */\n        _newPolygon: function (points, stackedOnPoints) {\n            var polygon = this._polygon;\n            // Remove previous created polygon\n            if (polygon) {\n                this._lineGroup.remove(polygon);\n            }\n\n            polygon = new polyHelper.Polygon({\n                shape: {\n                    points: points,\n                    stackedOnPoints: stackedOnPoints\n                },\n                silent: true\n            });\n\n            this._lineGroup.add(polygon);\n\n            this._polygon = polygon;\n            return polygon;\n        },\n        /**\n         * @private\n         */\n        _getSymbolIgnoreFunc: function (data, coordSys) {\n            var categoryAxis = coordSys.getAxesByScale('ordinal')[0];\n            // `getLabelInterval` is provided by echarts/component/axis\n            if (categoryAxis && categoryAxis.isLabelIgnored) {\n                return zrUtil.bind(categoryAxis.isLabelIgnored, categoryAxis);\n            }\n        },\n\n        /**\n         * @private\n         */\n        // FIXME Two value axis\n        _updateAnimation: function (data, stackedOnPoints, coordSys, api, step) {\n            var polyline = this._polyline;\n            var polygon = this._polygon;\n            var seriesModel = data.hostModel;\n\n            var diff = lineAnimationDiff(\n                this._data, data,\n                this._stackedOnPoints, stackedOnPoints,\n                this._coordSys, coordSys\n            );\n\n            var current = diff.current;\n            var stackedOnCurrent = diff.stackedOnCurrent;\n            var next = diff.next;\n            var stackedOnNext = diff.stackedOnNext;\n            if (step) {\n                // TODO If stacked series is not step\n                current = turnPointsIntoStep(diff.current, coordSys, step);\n                stackedOnCurrent = turnPointsIntoStep(diff.stackedOnCurrent, coordSys, step);\n                next = turnPointsIntoStep(diff.next, coordSys, step);\n                stackedOnNext = turnPointsIntoStep(diff.stackedOnNext, coordSys, step);\n            }\n            // `diff.current` is subset of `current` (which should be ensured by\n            // turnPointsIntoStep), so points in `__points` can be updated when\n            // points in `current` are update during animation.\n            polyline.shape.__points = diff.current;\n            polyline.shape.points = current;\n\n            graphic.updateProps(polyline, {\n                shape: {\n                    points: next\n                }\n            }, seriesModel);\n\n            if (polygon) {\n                polygon.setShape({\n                    points: current,\n                    stackedOnPoints: stackedOnCurrent\n                });\n                graphic.updateProps(polygon, {\n                    shape: {\n                        points: next,\n                        stackedOnPoints: stackedOnNext\n                    }\n                }, seriesModel);\n            }\n\n            var updatedDataInfo = [];\n            var diffStatus = diff.status;\n\n            for (var i = 0; i < diffStatus.length; i++) {\n                var cmd = diffStatus[i].cmd;\n                if (cmd === '=') {\n                    var el = data.getItemGraphicEl(diffStatus[i].idx1);\n                    if (el) {\n                        updatedDataInfo.push({\n                            el: el,\n                            ptIdx: i    // Index of points\n                        });\n                    }\n                }\n            }\n\n            if (polyline.animators && polyline.animators.length) {\n                polyline.animators[0].during(function () {\n                    for (var i = 0; i < updatedDataInfo.length; i++) {\n                        var el = updatedDataInfo[i].el;\n                        el.attr('position', polyline.shape.__points[updatedDataInfo[i].ptIdx]);\n                    }\n                });\n            }\n        },\n\n        remove: function (ecModel) {\n            var group = this.group;\n            var oldData = this._data;\n            this._lineGroup.removeAll();\n            this._symbolDraw.remove(true);\n            // Remove temporary created elements when highlighting\n            oldData && oldData.eachItemGraphicEl(function (el, idx) {\n                if (el.__temp) {\n                    group.remove(el);\n                    oldData.setItemGraphicEl(idx, null);\n                }\n            });\n\n            this._polyline =\n            this._polygon =\n            this._coordSys =\n            this._points =\n            this._stackedOnPoints =\n            this._data = null;\n        }\n    });\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2NoYXJ0L2xpbmUvTGluZVZpZXcuanM/Yzc2YyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG4vLyBGSVhNRSBzdGVwIG5vdCBzdXBwb3J0IHBvbGFyXG5cblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgU3ltYm9sRHJhdyA9IHJlcXVpcmUoJy4uL2hlbHBlci9TeW1ib2xEcmF3Jyk7XG4gICAgdmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4uL2hlbHBlci9TeW1ib2wnKTtcbiAgICB2YXIgbGluZUFuaW1hdGlvbkRpZmYgPSByZXF1aXJlKCcuL2xpbmVBbmltYXRpb25EaWZmJyk7XG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKCcuLi8uLi91dGlsL2dyYXBoaWMnKTtcbiAgICB2YXIgbW9kZWxVdGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9tb2RlbCcpO1xuICAgIHZhciBwb2x5SGVscGVyID0gcmVxdWlyZSgnLi9wb2x5Jyk7XG4gICAgdmFyIENoYXJ0VmlldyA9IHJlcXVpcmUoJy4uLy4uL3ZpZXcvQ2hhcnQnKTtcblxuICAgIGZ1bmN0aW9uIGlzUG9pbnRzU2FtZShwb2ludHMxLCBwb2ludHMyKSB7XG4gICAgICAgIGlmIChwb2ludHMxLmxlbmd0aCAhPT0gcG9pbnRzMi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50czEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwMSA9IHBvaW50czFbaV07XG4gICAgICAgICAgICB2YXIgcDIgPSBwb2ludHMyW2ldO1xuICAgICAgICAgICAgaWYgKHAxWzBdICE9PSBwMlswXSB8fCBwMVsxXSAhPT0gcDJbMV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U21vb3RoKHNtb290aCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIChzbW9vdGgpID09PSAnbnVtYmVyJyA/IHNtb290aCA6IChzbW9vdGggPyAwLjMgOiAwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRBeGlzRXh0ZW50V2l0aEdhcChheGlzKSB7XG4gICAgICAgIHZhciBleHRlbnQgPSBheGlzLmdldEdsb2JhbEV4dGVudCgpO1xuICAgICAgICBpZiAoYXhpcy5vbkJhbmQpIHtcbiAgICAgICAgICAgIC8vIFJlbW92ZSBleHRyYSAxcHggdG8gYXZvaWQgbGluZSBtaXRlciBpbiBjbGlwcGVkIGVkZ2VcbiAgICAgICAgICAgIHZhciBoYWxmQmFuZFdpZHRoID0gYXhpcy5nZXRCYW5kV2lkdGgoKSAvIDIgLSAxO1xuICAgICAgICAgICAgdmFyIGRpciA9IGV4dGVudFsxXSA+IGV4dGVudFswXSA/IDEgOiAtMTtcbiAgICAgICAgICAgIGV4dGVudFswXSArPSBkaXIgKiBoYWxmQmFuZFdpZHRoO1xuICAgICAgICAgICAgZXh0ZW50WzFdIC09IGRpciAqIGhhbGZCYW5kV2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV4dGVudDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzaWduKHZhbCkge1xuICAgICAgICByZXR1cm4gdmFsID49IDAgPyAxIDogLTE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvY29vcmQvY2FydGVzaWFuL0NhcnRlc2lhbjJEfG1vZHVsZTplY2hhcnRzL2Nvb3JkL3BvbGFyL1BvbGFyfSBjb29yZFN5c1xuICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvZGF0YS9MaXN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtBcnJheS48QXJyYXkuPG51bWJlcj4+fSBwb2ludHNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFN0YWNrZWRPblBvaW50cyhjb29yZFN5cywgZGF0YSkge1xuICAgICAgICB2YXIgYmFzZUF4aXMgPSBjb29yZFN5cy5nZXRCYXNlQXhpcygpO1xuICAgICAgICB2YXIgdmFsdWVBeGlzID0gY29vcmRTeXMuZ2V0T3RoZXJBeGlzKGJhc2VBeGlzKTtcbiAgICAgICAgdmFyIHZhbHVlU3RhcnQgPSBiYXNlQXhpcy5vblplcm9cbiAgICAgICAgICAgID8gMCA6IHZhbHVlQXhpcy5zY2FsZS5nZXRFeHRlbnQoKVswXTtcblxuICAgICAgICB2YXIgdmFsdWVEaW0gPSB2YWx1ZUF4aXMuZGltO1xuXG4gICAgICAgIHZhciBiYXNlRGF0YU9mZnNldCA9IHZhbHVlRGltID09PSAneCcgfHwgdmFsdWVEaW0gPT09ICdyYWRpdXMnID8gMSA6IDA7XG5cbiAgICAgICAgcmV0dXJuIGRhdGEubWFwQXJyYXkoW3ZhbHVlRGltXSwgZnVuY3Rpb24gKHZhbCwgaWR4KSB7XG4gICAgICAgICAgICB2YXIgc3RhY2tlZE9uU2FtZVNpZ247XG4gICAgICAgICAgICB2YXIgc3RhY2tlZE9uID0gZGF0YS5zdGFja2VkT247XG4gICAgICAgICAgICAvLyBGaW5kIGZpcnN0IHN0YWNrZWQgdmFsdWUgd2l0aCBzYW1lIHNpZ25cbiAgICAgICAgICAgIHdoaWxlIChzdGFja2VkT24gJiZcbiAgICAgICAgICAgICAgICBzaWduKHN0YWNrZWRPbi5nZXQodmFsdWVEaW0sIGlkeCkpID09PSBzaWduKHZhbClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHN0YWNrZWRPblNhbWVTaWduID0gc3RhY2tlZE9uO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHN0YWNrZWREYXRhID0gW107XG4gICAgICAgICAgICBzdGFja2VkRGF0YVtiYXNlRGF0YU9mZnNldF0gPSBkYXRhLmdldChiYXNlQXhpcy5kaW0sIGlkeCk7XG4gICAgICAgICAgICBzdGFja2VkRGF0YVsxIC0gYmFzZURhdGFPZmZzZXRdID0gc3RhY2tlZE9uU2FtZVNpZ25cbiAgICAgICAgICAgICAgICA/IHN0YWNrZWRPblNhbWVTaWduLmdldCh2YWx1ZURpbSwgaWR4LCB0cnVlKSA6IHZhbHVlU3RhcnQ7XG5cbiAgICAgICAgICAgIHJldHVybiBjb29yZFN5cy5kYXRhVG9Qb2ludChzdGFja2VkRGF0YSk7XG4gICAgICAgIH0sIHRydWUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUdyaWRDbGlwU2hhcGUoY2FydGVzaWFuLCBoYXNBbmltYXRpb24sIHNlcmllc01vZGVsKSB7XG4gICAgICAgIHZhciB4RXh0ZW50ID0gZ2V0QXhpc0V4dGVudFdpdGhHYXAoY2FydGVzaWFuLmdldEF4aXMoJ3gnKSk7XG4gICAgICAgIHZhciB5RXh0ZW50ID0gZ2V0QXhpc0V4dGVudFdpdGhHYXAoY2FydGVzaWFuLmdldEF4aXMoJ3knKSk7XG4gICAgICAgIHZhciBpc0hvcml6b250YWwgPSBjYXJ0ZXNpYW4uZ2V0QmFzZUF4aXMoKS5pc0hvcml6b250YWwoKTtcblxuICAgICAgICB2YXIgeCA9IE1hdGgubWluKHhFeHRlbnRbMF0sIHhFeHRlbnRbMV0pO1xuICAgICAgICB2YXIgeSA9IE1hdGgubWluKHlFeHRlbnRbMF0sIHlFeHRlbnRbMV0pO1xuICAgICAgICB2YXIgd2lkdGggPSBNYXRoLm1heCh4RXh0ZW50WzBdLCB4RXh0ZW50WzFdKSAtIHg7XG4gICAgICAgIHZhciBoZWlnaHQgPSBNYXRoLm1heCh5RXh0ZW50WzBdLCB5RXh0ZW50WzFdKSAtIHk7XG4gICAgICAgIHZhciBsaW5lV2lkdGggPSBzZXJpZXNNb2RlbC5nZXQoJ2xpbmVTdHlsZS5ub3JtYWwud2lkdGgnKSB8fCAyO1xuICAgICAgICAvLyBFeHBhbmQgY2xpcCBzaGFwZSB0byBhdm9pZCBjbGlwcGluZyB3aGVuIGxpbmUgdmFsdWUgZXhjZWVkcyBheGlzXG4gICAgICAgIHZhciBleHBhbmRTaXplID0gc2VyaWVzTW9kZWwuZ2V0KCdjbGlwT3ZlcmZsb3cnKSA/IGxpbmVXaWR0aCAvIDIgOiBNYXRoLm1heCh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgeSAtPSBleHBhbmRTaXplO1xuICAgICAgICAgICAgaGVpZ2h0ICs9IGV4cGFuZFNpemUgKiAyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgeCAtPSBleHBhbmRTaXplO1xuICAgICAgICAgICAgd2lkdGggKz0gZXhwYW5kU2l6ZSAqIDI7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2xpcFBhdGggPSBuZXcgZ3JhcGhpYy5SZWN0KHtcbiAgICAgICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgICAgICB5OiB5LFxuICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoaGFzQW5pbWF0aW9uKSB7XG4gICAgICAgICAgICBjbGlwUGF0aC5zaGFwZVtpc0hvcml6b250YWwgPyAnd2lkdGgnIDogJ2hlaWdodCddID0gMDtcbiAgICAgICAgICAgIGdyYXBoaWMuaW5pdFByb3BzKGNsaXBQYXRoLCB7XG4gICAgICAgICAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHNlcmllc01vZGVsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjbGlwUGF0aDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVQb2xhckNsaXBTaGFwZShwb2xhciwgaGFzQW5pbWF0aW9uLCBzZXJpZXNNb2RlbCkge1xuICAgICAgICB2YXIgYW5nbGVBeGlzID0gcG9sYXIuZ2V0QW5nbGVBeGlzKCk7XG4gICAgICAgIHZhciByYWRpdXNBeGlzID0gcG9sYXIuZ2V0UmFkaXVzQXhpcygpO1xuXG4gICAgICAgIHZhciByYWRpdXNFeHRlbnQgPSByYWRpdXNBeGlzLmdldEV4dGVudCgpO1xuICAgICAgICB2YXIgYW5nbGVFeHRlbnQgPSBhbmdsZUF4aXMuZ2V0RXh0ZW50KCk7XG5cbiAgICAgICAgdmFyIFJBRElBTiA9IE1hdGguUEkgLyAxODA7XG5cbiAgICAgICAgdmFyIGNsaXBQYXRoID0gbmV3IGdyYXBoaWMuU2VjdG9yKHtcbiAgICAgICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgICAgICAgY3g6IHBvbGFyLmN4LFxuICAgICAgICAgICAgICAgIGN5OiBwb2xhci5jeSxcbiAgICAgICAgICAgICAgICByMDogcmFkaXVzRXh0ZW50WzBdLFxuICAgICAgICAgICAgICAgIHI6IHJhZGl1c0V4dGVudFsxXSxcbiAgICAgICAgICAgICAgICBzdGFydEFuZ2xlOiAtYW5nbGVFeHRlbnRbMF0gKiBSQURJQU4sXG4gICAgICAgICAgICAgICAgZW5kQW5nbGU6IC1hbmdsZUV4dGVudFsxXSAqIFJBRElBTixcbiAgICAgICAgICAgICAgICBjbG9ja3dpc2U6IGFuZ2xlQXhpcy5pbnZlcnNlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChoYXNBbmltYXRpb24pIHtcbiAgICAgICAgICAgIGNsaXBQYXRoLnNoYXBlLmVuZEFuZ2xlID0gLWFuZ2xlRXh0ZW50WzBdICogUkFESUFOO1xuICAgICAgICAgICAgZ3JhcGhpYy5pbml0UHJvcHMoY2xpcFBhdGgsIHtcbiAgICAgICAgICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgICAgICAgICBlbmRBbmdsZTogLWFuZ2xlRXh0ZW50WzFdICogUkFESUFOXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgc2VyaWVzTW9kZWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNsaXBQYXRoO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUNsaXBTaGFwZShjb29yZFN5cywgaGFzQW5pbWF0aW9uLCBzZXJpZXNNb2RlbCkge1xuICAgICAgICByZXR1cm4gY29vcmRTeXMudHlwZSA9PT0gJ3BvbGFyJ1xuICAgICAgICAgICAgPyBjcmVhdGVQb2xhckNsaXBTaGFwZShjb29yZFN5cywgaGFzQW5pbWF0aW9uLCBzZXJpZXNNb2RlbClcbiAgICAgICAgICAgIDogY3JlYXRlR3JpZENsaXBTaGFwZShjb29yZFN5cywgaGFzQW5pbWF0aW9uLCBzZXJpZXNNb2RlbCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdHVyblBvaW50c0ludG9TdGVwKHBvaW50cywgY29vcmRTeXMsIHN0ZXBUdXJuQXQpIHtcbiAgICAgICAgdmFyIGJhc2VBeGlzID0gY29vcmRTeXMuZ2V0QmFzZUF4aXMoKTtcbiAgICAgICAgdmFyIGJhc2VJbmRleCA9IGJhc2VBeGlzLmRpbSA9PT0gJ3gnIHx8IGJhc2VBeGlzLmRpbSA9PT0gJ3JhZGl1cycgPyAwIDogMTtcblxuICAgICAgICB2YXIgc3RlcFBvaW50cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBuZXh0UHQgPSBwb2ludHNbaSArIDFdO1xuICAgICAgICAgICAgdmFyIHB0ID0gcG9pbnRzW2ldO1xuICAgICAgICAgICAgc3RlcFBvaW50cy5wdXNoKHB0KTtcblxuICAgICAgICAgICAgdmFyIHN0ZXBQdCA9IFtdO1xuICAgICAgICAgICAgc3dpdGNoIChzdGVwVHVybkF0KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnZW5kJzpcbiAgICAgICAgICAgICAgICAgICAgc3RlcFB0W2Jhc2VJbmRleF0gPSBuZXh0UHRbYmFzZUluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgc3RlcFB0WzEgLSBiYXNlSW5kZXhdID0gcHRbMSAtIGJhc2VJbmRleF07XG4gICAgICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQgaXMgc3RhcnRcbiAgICAgICAgICAgICAgICAgICAgc3RlcFBvaW50cy5wdXNoKHN0ZXBQdCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ21pZGRsZSc6XG4gICAgICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQgaXMgc3RhcnRcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1pZGRsZSA9IChwdFtiYXNlSW5kZXhdICsgbmV4dFB0W2Jhc2VJbmRleF0pIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0ZXBQdDIgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgc3RlcFB0W2Jhc2VJbmRleF0gPSBzdGVwUHQyW2Jhc2VJbmRleF0gPSBtaWRkbGU7XG4gICAgICAgICAgICAgICAgICAgIHN0ZXBQdFsxIC0gYmFzZUluZGV4XSA9IHB0WzEgLSBiYXNlSW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBzdGVwUHQyWzEgLSBiYXNlSW5kZXhdID0gbmV4dFB0WzEgLSBiYXNlSW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBzdGVwUG9pbnRzLnB1c2goc3RlcFB0KTtcbiAgICAgICAgICAgICAgICAgICAgc3RlcFBvaW50cy5wdXNoKHN0ZXBQdDIpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBzdGVwUHRbYmFzZUluZGV4XSA9IHB0W2Jhc2VJbmRleF07XG4gICAgICAgICAgICAgICAgICAgIHN0ZXBQdFsxIC0gYmFzZUluZGV4XSA9IG5leHRQdFsxIC0gYmFzZUluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZGVmYXVsdCBpcyBzdGFydFxuICAgICAgICAgICAgICAgICAgICBzdGVwUG9pbnRzLnB1c2goc3RlcFB0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBMYXN0IHBvaW50c1xuICAgICAgICBwb2ludHNbaV0gJiYgc3RlcFBvaW50cy5wdXNoKHBvaW50c1tpXSk7XG4gICAgICAgIHJldHVybiBzdGVwUG9pbnRzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFZpc3VhbEdyYWRpZW50KGRhdGEsIGNvb3JkU3lzKSB7XG4gICAgICAgIHZhciB2aXN1YWxNZXRhTGlzdCA9IGRhdGEuZ2V0VmlzdWFsKCd2aXN1YWxNZXRhJyk7XG4gICAgICAgIGlmICghdmlzdWFsTWV0YUxpc3QgfHwgIXZpc3VhbE1ldGFMaXN0Lmxlbmd0aCB8fCAhZGF0YS5jb3VudCgpKSB7XG4gICAgICAgICAgICAvLyBXaGVuIGRhdGEuY291bnQoKSBpcyAwLCBncmFkaWVudCByYW5nZSBjYW4gbm90IGJlIGNhbGN1bGF0ZWQuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdmlzdWFsTWV0YTtcbiAgICAgICAgZm9yICh2YXIgaSA9IHZpc3VhbE1ldGFMaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAvLyBDYW4gb25seSBiZSB4IG9yIHlcbiAgICAgICAgICAgIGlmICh2aXN1YWxNZXRhTGlzdFtpXS5kaW1lbnNpb24gPCAyKSB7XG4gICAgICAgICAgICAgICAgdmlzdWFsTWV0YSA9IHZpc3VhbE1ldGFMaXN0W2ldO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghdmlzdWFsTWV0YSB8fCBjb29yZFN5cy50eXBlICE9PSAnY2FydGVzaWFuMmQnKSB7XG4gICAgICAgICAgICBpZiAoX19ERVZfXykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignVmlzdWFsIG1hcCBvbiBsaW5lIHN0eWxlIG9ubHkgc3VwcG9ydCB4IG9yIHkgZGltZW5zaW9uLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhlIGFyZWEgdG8gYmUgcmVuZGVyZWQgaXMgYmlnZ2VyIHRoYW4gYXJlYSBkZWZpbmVkIGJ5IExpbmVhckdyYWRpZW50LFxuICAgICAgICAvLyB0aGUgY2FudmFzIHNwZWMgcHJlc2NyaWJlcyB0aGF0IHRoZSBjb2xvciBvZiB0aGUgZmlyc3Qgc3RvcCBhbmQgdGhlIGxhc3RcbiAgICAgICAgLy8gc3RvcCBzaG91bGQgYmUgdXNlZC4gQnV0IGlmIHR3byBzdG9wcyBhcmUgYWRkZWQgYXQgb2Zmc2V0IDAsIGluIGVmZmVjdFxuICAgICAgICAvLyBicm93c2VycyB1c2UgdGhlIGNvbG9yIG9mIHRoZSBzZWNvbmQgc3RvcCB0byByZW5kZXIgYXJlYSBvdXRzaWRlXG4gICAgICAgIC8vIExpbmVhckdyYWRpZW50LiBTbyB3ZSBjYW4gb25seSBpbmZpbml0ZXNpbWFsbHkgZXh0ZW5kIGFyZWEgZGVmaW5lZCBpblxuICAgICAgICAvLyBMaW5lYXJHcmFkaWVudCB0byByZW5kZXIgYG91dGVyQ29sb3JzYC5cblxuICAgICAgICB2YXIgZGltZW5zaW9uID0gdmlzdWFsTWV0YS5kaW1lbnNpb247XG4gICAgICAgIHZhciBkaW1OYW1lID0gZGF0YS5kaW1lbnNpb25zW2RpbWVuc2lvbl07XG4gICAgICAgIHZhciBheGlzID0gY29vcmRTeXMuZ2V0QXhpcyhkaW1OYW1lKTtcblxuICAgICAgICAvLyBkYXRhVG9Db29yIG1hcHBpbmcgbWF5IG5vdCBiZSBsaW5lYXIsIGJ1dCBtdXN0IGJlIG1vbm90b25pYy5cbiAgICAgICAgdmFyIGNvbG9yU3RvcHMgPSB6clV0aWwubWFwKHZpc3VhbE1ldGEuc3RvcHMsIGZ1bmN0aW9uIChzdG9wKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNvb3JkOiBheGlzLnRvR2xvYmFsQ29vcmQoYXhpcy5kYXRhVG9Db29yZChzdG9wLnZhbHVlKSksXG4gICAgICAgICAgICAgICAgY29sb3I6IHN0b3AuY29sb3JcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgc3RvcExlbiA9IGNvbG9yU3RvcHMubGVuZ3RoO1xuICAgICAgICB2YXIgb3V0ZXJDb2xvcnMgPSB2aXN1YWxNZXRhLm91dGVyQ29sb3JzLnNsaWNlKCk7XG5cbiAgICAgICAgaWYgKHN0b3BMZW4gJiYgY29sb3JTdG9wc1swXS5jb29yZCA+IGNvbG9yU3RvcHNbc3RvcExlbiAtIDFdLmNvb3JkKSB7XG4gICAgICAgICAgICBjb2xvclN0b3BzLnJldmVyc2UoKTtcbiAgICAgICAgICAgIG91dGVyQ29sb3JzLnJldmVyc2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0aW55RXh0ZW50ID0gMTA7IC8vIEFyYml0cmFyeSB2YWx1ZTogMTBweFxuICAgICAgICB2YXIgbWluQ29vcmQgPSBjb2xvclN0b3BzWzBdLmNvb3JkIC0gdGlueUV4dGVudDtcbiAgICAgICAgdmFyIG1heENvb3JkID0gY29sb3JTdG9wc1tzdG9wTGVuIC0gMV0uY29vcmQgKyB0aW55RXh0ZW50O1xuICAgICAgICB2YXIgY29vcmRTcGFuID0gbWF4Q29vcmQgLSBtaW5Db29yZDtcblxuICAgICAgICBpZiAoY29vcmRTcGFuIDwgMWUtMykge1xuICAgICAgICAgICAgcmV0dXJuICd0cmFuc3BhcmVudCc7XG4gICAgICAgIH1cblxuICAgICAgICB6clV0aWwuZWFjaChjb2xvclN0b3BzLCBmdW5jdGlvbiAoc3RvcCkge1xuICAgICAgICAgICAgc3RvcC5vZmZzZXQgPSAoc3RvcC5jb29yZCAtIG1pbkNvb3JkKSAvIGNvb3JkU3BhbjtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbG9yU3RvcHMucHVzaCh7XG4gICAgICAgICAgICBvZmZzZXQ6IHN0b3BMZW4gPyBjb2xvclN0b3BzW3N0b3BMZW4gLSAxXS5vZmZzZXQgOiAwLjUsXG4gICAgICAgICAgICBjb2xvcjogb3V0ZXJDb2xvcnNbMV0gfHwgJ3RyYW5zcGFyZW50J1xuICAgICAgICB9KTtcbiAgICAgICAgY29sb3JTdG9wcy51bnNoaWZ0KHsgLy8gbm90aWNlIGNvbG9yU3RvcHMubGVuZ3RoIGhhdmUgYmVlbiBjaGFuZ2VkLlxuICAgICAgICAgICAgb2Zmc2V0OiBzdG9wTGVuID8gY29sb3JTdG9wc1swXS5vZmZzZXQgOiAwLjUsXG4gICAgICAgICAgICBjb2xvcjogb3V0ZXJDb2xvcnNbMF0gfHwgJ3RyYW5zcGFyZW50J1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyB6clV0aWwuZWFjaChjb2xvclN0b3BzLCBmdW5jdGlvbiAoY29sb3JTdG9wKSB7XG4gICAgICAgIC8vICAgICAvLyBNYWtlIHN1cmUgZWFjaCBvZmZzZXQgaGFzIHJvdW5kZWQgcHggdG8gYXZvaWQgbm90IHNoYXJwIGVkZ2VcbiAgICAgICAgLy8gICAgIGNvbG9yU3RvcC5vZmZzZXQgPSAoTWF0aC5yb3VuZChjb2xvclN0b3Aub2Zmc2V0ICogKGVuZCAtIHN0YXJ0KSArIHN0YXJ0KSAtIHN0YXJ0KSAvIChlbmQgLSBzdGFydCk7XG4gICAgICAgIC8vIH0pO1xuXG4gICAgICAgIHZhciBncmFkaWVudCA9IG5ldyBncmFwaGljLkxpbmVhckdyYWRpZW50KDAsIDAsIDAsIDAsIGNvbG9yU3RvcHMsIHRydWUpO1xuICAgICAgICBncmFkaWVudFtkaW1OYW1lXSA9IG1pbkNvb3JkO1xuICAgICAgICBncmFkaWVudFtkaW1OYW1lICsgJzInXSA9IG1heENvb3JkO1xuXG4gICAgICAgIHJldHVybiBncmFkaWVudDtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IENoYXJ0Vmlldy5leHRlbmQoe1xuXG4gICAgICAgIHR5cGU6ICdsaW5lJyxcblxuICAgICAgICBpbml0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbGluZUdyb3VwID0gbmV3IGdyYXBoaWMuR3JvdXAoKTtcblxuICAgICAgICAgICAgdmFyIHN5bWJvbERyYXcgPSBuZXcgU3ltYm9sRHJhdygpO1xuICAgICAgICAgICAgdGhpcy5ncm91cC5hZGQoc3ltYm9sRHJhdy5ncm91cCk7XG5cbiAgICAgICAgICAgIHRoaXMuX3N5bWJvbERyYXcgPSBzeW1ib2xEcmF3O1xuICAgICAgICAgICAgdGhpcy5fbGluZUdyb3VwID0gbGluZUdyb3VwO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbmRlcjogZnVuY3Rpb24gKHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgICAgICAgICAgIHZhciBjb29yZFN5cyA9IHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG4gICAgICAgICAgICB2YXIgZ3JvdXAgPSB0aGlzLmdyb3VwO1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgICAgICAgICB2YXIgbGluZVN0eWxlTW9kZWwgPSBzZXJpZXNNb2RlbC5nZXRNb2RlbCgnbGluZVN0eWxlLm5vcm1hbCcpO1xuICAgICAgICAgICAgdmFyIGFyZWFTdHlsZU1vZGVsID0gc2VyaWVzTW9kZWwuZ2V0TW9kZWwoJ2FyZWFTdHlsZS5ub3JtYWwnKTtcblxuICAgICAgICAgICAgdmFyIHBvaW50cyA9IGRhdGEubWFwQXJyYXkoZGF0YS5nZXRJdGVtTGF5b3V0LCB0cnVlKTtcblxuICAgICAgICAgICAgdmFyIGlzQ29vcmRTeXNQb2xhciA9IGNvb3JkU3lzLnR5cGUgPT09ICdwb2xhcic7XG4gICAgICAgICAgICB2YXIgcHJldkNvb3JkU3lzID0gdGhpcy5fY29vcmRTeXM7XG5cbiAgICAgICAgICAgIHZhciBzeW1ib2xEcmF3ID0gdGhpcy5fc3ltYm9sRHJhdztcbiAgICAgICAgICAgIHZhciBwb2x5bGluZSA9IHRoaXMuX3BvbHlsaW5lO1xuICAgICAgICAgICAgdmFyIHBvbHlnb24gPSB0aGlzLl9wb2x5Z29uO1xuXG4gICAgICAgICAgICB2YXIgbGluZUdyb3VwID0gdGhpcy5fbGluZUdyb3VwO1xuXG4gICAgICAgICAgICB2YXIgaGFzQW5pbWF0aW9uID0gc2VyaWVzTW9kZWwuZ2V0KCdhbmltYXRpb24nKTtcblxuICAgICAgICAgICAgdmFyIGlzQXJlYUNoYXJ0ID0gIWFyZWFTdHlsZU1vZGVsLmlzRW1wdHkoKTtcbiAgICAgICAgICAgIHZhciBzdGFja2VkT25Qb2ludHMgPSBnZXRTdGFja2VkT25Qb2ludHMoY29vcmRTeXMsIGRhdGEpO1xuXG4gICAgICAgICAgICB2YXIgc2hvd1N5bWJvbCA9IHNlcmllc01vZGVsLmdldCgnc2hvd1N5bWJvbCcpO1xuXG4gICAgICAgICAgICB2YXIgaXNTeW1ib2xJZ25vcmUgPSBzaG93U3ltYm9sICYmICFpc0Nvb3JkU3lzUG9sYXIgJiYgIXNlcmllc01vZGVsLmdldCgnc2hvd0FsbFN5bWJvbCcpXG4gICAgICAgICAgICAgICAgJiYgdGhpcy5fZ2V0U3ltYm9sSWdub3JlRnVuYyhkYXRhLCBjb29yZFN5cyk7XG5cbiAgICAgICAgICAgIC8vIFJlbW92ZSB0ZW1wb3Jhcnkgc3ltYm9sc1xuICAgICAgICAgICAgdmFyIG9sZERhdGEgPSB0aGlzLl9kYXRhO1xuICAgICAgICAgICAgb2xkRGF0YSAmJiBvbGREYXRhLmVhY2hJdGVtR3JhcGhpY0VsKGZ1bmN0aW9uIChlbCwgaWR4KSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsLl9fdGVtcCkge1xuICAgICAgICAgICAgICAgICAgICBncm91cC5yZW1vdmUoZWwpO1xuICAgICAgICAgICAgICAgICAgICBvbGREYXRhLnNldEl0ZW1HcmFwaGljRWwoaWR4LCBudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gUmVtb3ZlIHByZXZpb3VzIGNyZWF0ZWQgc3ltYm9scyBpZiBzaG93U3ltYm9sIGNoYW5nZWQgdG8gZmFsc2VcbiAgICAgICAgICAgIGlmICghc2hvd1N5bWJvbCkge1xuICAgICAgICAgICAgICAgIHN5bWJvbERyYXcucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGdyb3VwLmFkZChsaW5lR3JvdXApO1xuXG4gICAgICAgICAgICAvLyBGSVhNRSBzdGVwIG5vdCBzdXBwb3J0IHBvbGFyXG4gICAgICAgICAgICB2YXIgc3RlcCA9ICFpc0Nvb3JkU3lzUG9sYXIgJiYgc2VyaWVzTW9kZWwuZ2V0KCdzdGVwJyk7XG4gICAgICAgICAgICAvLyBJbml0aWFsaXphdGlvbiBhbmltYXRpb24gb3IgY29vcmRpbmF0ZSBzeXN0ZW0gY2hhbmdlZFxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICEocG9seWxpbmUgJiYgcHJldkNvb3JkU3lzLnR5cGUgPT09IGNvb3JkU3lzLnR5cGUgJiYgc3RlcCA9PT0gdGhpcy5fc3RlcClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHNob3dTeW1ib2wgJiYgc3ltYm9sRHJhdy51cGRhdGVEYXRhKGRhdGEsIGlzU3ltYm9sSWdub3JlKTtcblxuICAgICAgICAgICAgICAgIGlmIChzdGVwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gSWYgc3RhY2tlZCBzZXJpZXMgaXMgbm90IHN0ZXBcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzID0gdHVyblBvaW50c0ludG9TdGVwKHBvaW50cywgY29vcmRTeXMsIHN0ZXApO1xuICAgICAgICAgICAgICAgICAgICBzdGFja2VkT25Qb2ludHMgPSB0dXJuUG9pbnRzSW50b1N0ZXAoc3RhY2tlZE9uUG9pbnRzLCBjb29yZFN5cywgc3RlcCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcG9seWxpbmUgPSB0aGlzLl9uZXdQb2x5bGluZShwb2ludHMsIGNvb3JkU3lzLCBoYXNBbmltYXRpb24pO1xuICAgICAgICAgICAgICAgIGlmIChpc0FyZWFDaGFydCkge1xuICAgICAgICAgICAgICAgICAgICBwb2x5Z29uID0gdGhpcy5fbmV3UG9seWdvbihcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cywgc3RhY2tlZE9uUG9pbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29vcmRTeXMsIGhhc0FuaW1hdGlvblxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsaW5lR3JvdXAuc2V0Q2xpcFBhdGgoY3JlYXRlQ2xpcFNoYXBlKGNvb3JkU3lzLCB0cnVlLCBzZXJpZXNNb2RlbCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzQXJlYUNoYXJ0ICYmICFwb2x5Z29uKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIGFyZWFTdHlsZSBpcyBhZGRlZFxuICAgICAgICAgICAgICAgICAgICBwb2x5Z29uID0gdGhpcy5fbmV3UG9seWdvbihcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cywgc3RhY2tlZE9uUG9pbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29vcmRTeXMsIGhhc0FuaW1hdGlvblxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwb2x5Z29uICYmICFpc0FyZWFDaGFydCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBhcmVhU3R5bGUgaXMgcmVtb3ZlZFxuICAgICAgICAgICAgICAgICAgICBsaW5lR3JvdXAucmVtb3ZlKHBvbHlnb24pO1xuICAgICAgICAgICAgICAgICAgICBwb2x5Z29uID0gdGhpcy5fcG9seWdvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIGNsaXBQYXRoXG4gICAgICAgICAgICAgICAgbGluZUdyb3VwLnNldENsaXBQYXRoKGNyZWF0ZUNsaXBTaGFwZShjb29yZFN5cywgZmFsc2UsIHNlcmllc01vZGVsKSk7XG5cbiAgICAgICAgICAgICAgICAvLyBBbHdheXMgdXBkYXRlLCBvciBpdCBpcyB3cm9uZyBpbiB0aGUgY2FzZSB0dXJuaW5nIG9uIGxlZ2VuZFxuICAgICAgICAgICAgICAgIC8vIGJlY2F1c2UgcG9pbnRzIGFyZSBub3QgY2hhbmdlZFxuICAgICAgICAgICAgICAgIHNob3dTeW1ib2wgJiYgc3ltYm9sRHJhdy51cGRhdGVEYXRhKGRhdGEsIGlzU3ltYm9sSWdub3JlKTtcblxuICAgICAgICAgICAgICAgIC8vIFN0b3Agc3ltYm9sIGFuaW1hdGlvbiBhbmQgc3luYyB3aXRoIGxpbmUgcG9pbnRzXG4gICAgICAgICAgICAgICAgLy8gRklYTUUgcGVyZm9ybWFuY2U/XG4gICAgICAgICAgICAgICAgZGF0YS5lYWNoSXRlbUdyYXBoaWNFbChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgZWwuc3RvcEFuaW1hdGlvbih0cnVlKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIEluIHRoZSBjYXNlIGRhdGEgem9vbSB0cmlnZ2VycmVkIHJlZnJlc2hpbmcgZnJlcXVlbnRseVxuICAgICAgICAgICAgICAgIC8vIERhdGEgbWF5IG5vdCBjaGFuZ2UgaWYgbGluZSBoYXMgYSBjYXRlZ29yeSBheGlzLiBTbyBpdCBzaG91bGQgYW5pbWF0ZSBub3RoaW5nXG4gICAgICAgICAgICAgICAgaWYgKCFpc1BvaW50c1NhbWUodGhpcy5fc3RhY2tlZE9uUG9pbnRzLCBzdGFja2VkT25Qb2ludHMpXG4gICAgICAgICAgICAgICAgICAgIHx8ICFpc1BvaW50c1NhbWUodGhpcy5fcG9pbnRzLCBwb2ludHMpXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYXNBbmltYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUFuaW1hdGlvbihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLCBzdGFja2VkT25Qb2ludHMsIGNvb3JkU3lzLCBhcGksIHN0ZXBcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3QgZG8gaXQgaW4gdXBkYXRlIHdpdGggYW5pbWF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RlcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gSWYgc3RhY2tlZCBzZXJpZXMgaXMgbm90IHN0ZXBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMgPSB0dXJuUG9pbnRzSW50b1N0ZXAocG9pbnRzLCBjb29yZFN5cywgc3RlcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2tlZE9uUG9pbnRzID0gdHVyblBvaW50c0ludG9TdGVwKHN0YWNrZWRPblBvaW50cywgY29vcmRTeXMsIHN0ZXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2x5bGluZS5zZXRTaGFwZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzOiBwb2ludHNcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9seWdvbiAmJiBwb2x5Z29uLnNldFNoYXBlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludHM6IHBvaW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFja2VkT25Qb2ludHM6IHN0YWNrZWRPblBvaW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB2aXN1YWxDb2xvciA9IGdldFZpc3VhbEdyYWRpZW50KGRhdGEsIGNvb3JkU3lzKSB8fCBkYXRhLmdldFZpc3VhbCgnY29sb3InKTtcblxuICAgICAgICAgICAgcG9seWxpbmUudXNlU3R5bGUoenJVdGlsLmRlZmF1bHRzKFxuICAgICAgICAgICAgICAgIC8vIFVzZSBjb2xvciBpbiBsaW5lU3R5bGUgZmlyc3RcbiAgICAgICAgICAgICAgICBsaW5lU3R5bGVNb2RlbC5nZXRMaW5lU3R5bGUoKSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGw6ICdub25lJyxcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlOiB2aXN1YWxDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgbGluZUpvaW46ICdiZXZlbCdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApKTtcblxuICAgICAgICAgICAgdmFyIHNtb290aCA9IHNlcmllc01vZGVsLmdldCgnc21vb3RoJyk7XG4gICAgICAgICAgICBzbW9vdGggPSBnZXRTbW9vdGgoc2VyaWVzTW9kZWwuZ2V0KCdzbW9vdGgnKSk7XG4gICAgICAgICAgICBwb2x5bGluZS5zZXRTaGFwZSh7XG4gICAgICAgICAgICAgICAgc21vb3RoOiBzbW9vdGgsXG4gICAgICAgICAgICAgICAgc21vb3RoTW9ub3RvbmU6IHNlcmllc01vZGVsLmdldCgnc21vb3RoTW9ub3RvbmUnKSxcbiAgICAgICAgICAgICAgICBjb25uZWN0TnVsbHM6IHNlcmllc01vZGVsLmdldCgnY29ubmVjdE51bGxzJylcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAocG9seWdvbikge1xuICAgICAgICAgICAgICAgIHZhciBzdGFja2VkT24gPSBkYXRhLnN0YWNrZWRPbjtcbiAgICAgICAgICAgICAgICB2YXIgc3RhY2tlZE9uU21vb3RoID0gMDtcblxuICAgICAgICAgICAgICAgIHBvbHlnb24udXNlU3R5bGUoenJVdGlsLmRlZmF1bHRzKFxuICAgICAgICAgICAgICAgICAgICBhcmVhU3R5bGVNb2RlbC5nZXRBcmVhU3R5bGUoKSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsbDogdmlzdWFsQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiAwLjcsXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lSm9pbjogJ2JldmVsJ1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoc3RhY2tlZE9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGFja2VkT25TZXJpZXMgPSBzdGFja2VkT24uaG9zdE1vZGVsO1xuICAgICAgICAgICAgICAgICAgICBzdGFja2VkT25TbW9vdGggPSBnZXRTbW9vdGgoc3RhY2tlZE9uU2VyaWVzLmdldCgnc21vb3RoJykpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHBvbHlnb24uc2V0U2hhcGUoe1xuICAgICAgICAgICAgICAgICAgICBzbW9vdGg6IHNtb290aCxcbiAgICAgICAgICAgICAgICAgICAgc3RhY2tlZE9uU21vb3RoOiBzdGFja2VkT25TbW9vdGgsXG4gICAgICAgICAgICAgICAgICAgIHNtb290aE1vbm90b25lOiBzZXJpZXNNb2RlbC5nZXQoJ3Ntb290aE1vbm90b25lJyksXG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3ROdWxsczogc2VyaWVzTW9kZWwuZ2V0KCdjb25uZWN0TnVsbHMnKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgICAgICAgICAgIC8vIFNhdmUgdGhlIGNvb3JkaW5hdGUgc3lzdGVtIGZvciB0cmFuc2l0aW9uIGFuaW1hdGlvbiB3aGVuIGRhdGEgY2hhbmdlZFxuICAgICAgICAgICAgdGhpcy5fY29vcmRTeXMgPSBjb29yZFN5cztcbiAgICAgICAgICAgIHRoaXMuX3N0YWNrZWRPblBvaW50cyA9IHN0YWNrZWRPblBvaW50cztcbiAgICAgICAgICAgIHRoaXMuX3BvaW50cyA9IHBvaW50cztcbiAgICAgICAgICAgIHRoaXMuX3N0ZXAgPSBzdGVwO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHt9LFxuXG4gICAgICAgIGhpZ2hsaWdodDogZnVuY3Rpb24gKHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgICAgICAgICAgdmFyIGRhdGFJbmRleCA9IG1vZGVsVXRpbC5xdWVyeURhdGFJbmRleChkYXRhLCBwYXlsb2FkKTtcblxuICAgICAgICAgICAgaWYgKCEoZGF0YUluZGV4IGluc3RhbmNlb2YgQXJyYXkpICYmIGRhdGFJbmRleCAhPSBudWxsICYmIGRhdGFJbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN5bWJvbCA9IGRhdGEuZ2V0SXRlbUdyYXBoaWNFbChkYXRhSW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmICghc3ltYm9sKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhIHRlbXBvcmFyeSBzeW1ib2wgaWYgaXQgaXMgbm90IGV4aXN0c1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHQgPSBkYXRhLmdldEl0ZW1MYXlvdXQoZGF0YUluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTnVsbCBkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gbmV3IFN5bWJvbChkYXRhLCBkYXRhSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBzeW1ib2wucG9zaXRpb24gPSBwdDtcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sLnNldFooXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXNNb2RlbC5nZXQoJ3psZXZlbCcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzTW9kZWwuZ2V0KCd6JylcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sLmlnbm9yZSA9IGlzTmFOKHB0WzBdKSB8fCBpc05hTihwdFsxXSk7XG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbC5fX3RlbXAgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBkYXRhLnNldEl0ZW1HcmFwaGljRWwoZGF0YUluZGV4LCBzeW1ib2wpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFN0b3Agc2NhbGUgYW5pbWF0aW9uXG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbC5zdG9wU3ltYm9sQW5pbWF0aW9uKHRydWUpO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXAuYWRkKHN5bWJvbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN5bWJvbC5oaWdobGlnaHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEhpZ2hsaWdodCB3aG9sZSBzZXJpZXNcbiAgICAgICAgICAgICAgICBDaGFydFZpZXcucHJvdG90eXBlLmhpZ2hsaWdodC5jYWxsKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLCBzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBkb3ducGxheTogZnVuY3Rpb24gKHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgICAgICAgICAgdmFyIGRhdGFJbmRleCA9IG1vZGVsVXRpbC5xdWVyeURhdGFJbmRleChkYXRhLCBwYXlsb2FkKTtcbiAgICAgICAgICAgIGlmIChkYXRhSW5kZXggIT0gbnVsbCAmJiBkYXRhSW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgIHZhciBzeW1ib2wgPSBkYXRhLmdldEl0ZW1HcmFwaGljRWwoZGF0YUluZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAoc3ltYm9sKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzeW1ib2wuX190ZW1wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnNldEl0ZW1HcmFwaGljRWwoZGF0YUluZGV4LCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXAucmVtb3ZlKHN5bWJvbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wuZG93bnBsYXkoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEZJWE1FXG4gICAgICAgICAgICAgICAgLy8gY2FuIG5vdCBkb3ducGxheSBjb21wbGV0ZWx5LlxuICAgICAgICAgICAgICAgIC8vIERvd25wbGF5IHdob2xlIHNlcmllc1xuICAgICAgICAgICAgICAgIENoYXJ0Vmlldy5wcm90b3R5cGUuZG93bnBsYXkuY2FsbChcbiAgICAgICAgICAgICAgICAgICAgdGhpcywgc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvY29udGFpbmVyL0dyb3VwfSBncm91cFxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5LjxBcnJheS48bnVtYmVyPj59IHBvaW50c1xuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX25ld1BvbHlsaW5lOiBmdW5jdGlvbiAocG9pbnRzKSB7XG4gICAgICAgICAgICB2YXIgcG9seWxpbmUgPSB0aGlzLl9wb2x5bGluZTtcbiAgICAgICAgICAgIC8vIFJlbW92ZSBwcmV2aW91cyBjcmVhdGVkIHBvbHlsaW5lXG4gICAgICAgICAgICBpZiAocG9seWxpbmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9saW5lR3JvdXAucmVtb3ZlKHBvbHlsaW5lKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcG9seWxpbmUgPSBuZXcgcG9seUhlbHBlci5Qb2x5bGluZSh7XG4gICAgICAgICAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzOiBwb2ludHNcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNpbGVudDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB6MjogMTBcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0aGlzLl9saW5lR3JvdXAuYWRkKHBvbHlsaW5lKTtcblxuICAgICAgICAgICAgdGhpcy5fcG9seWxpbmUgPSBwb2x5bGluZTtcblxuICAgICAgICAgICAgcmV0dXJuIHBvbHlsaW5lO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2NvbnRhaW5lci9Hcm91cH0gZ3JvdXBcbiAgICAgICAgICogQHBhcmFtIHtBcnJheS48QXJyYXkuPG51bWJlcj4+fSBzdGFja2VkT25Qb2ludHNcbiAgICAgICAgICogQHBhcmFtIHtBcnJheS48QXJyYXkuPG51bWJlcj4+fSBwb2ludHNcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF9uZXdQb2x5Z29uOiBmdW5jdGlvbiAocG9pbnRzLCBzdGFja2VkT25Qb2ludHMpIHtcbiAgICAgICAgICAgIHZhciBwb2x5Z29uID0gdGhpcy5fcG9seWdvbjtcbiAgICAgICAgICAgIC8vIFJlbW92ZSBwcmV2aW91cyBjcmVhdGVkIHBvbHlnb25cbiAgICAgICAgICAgIGlmIChwb2x5Z29uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGluZUdyb3VwLnJlbW92ZShwb2x5Z29uKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcG9seWdvbiA9IG5ldyBwb2x5SGVscGVyLlBvbHlnb24oe1xuICAgICAgICAgICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50czogcG9pbnRzLFxuICAgICAgICAgICAgICAgICAgICBzdGFja2VkT25Qb2ludHM6IHN0YWNrZWRPblBvaW50c1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2lsZW50OiB0cnVlXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy5fbGluZUdyb3VwLmFkZChwb2x5Z29uKTtcblxuICAgICAgICAgICAgdGhpcy5fcG9seWdvbiA9IHBvbHlnb247XG4gICAgICAgICAgICByZXR1cm4gcG9seWdvbjtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfZ2V0U3ltYm9sSWdub3JlRnVuYzogZnVuY3Rpb24gKGRhdGEsIGNvb3JkU3lzKSB7XG4gICAgICAgICAgICB2YXIgY2F0ZWdvcnlBeGlzID0gY29vcmRTeXMuZ2V0QXhlc0J5U2NhbGUoJ29yZGluYWwnKVswXTtcbiAgICAgICAgICAgIC8vIGBnZXRMYWJlbEludGVydmFsYCBpcyBwcm92aWRlZCBieSBlY2hhcnRzL2NvbXBvbmVudC9heGlzXG4gICAgICAgICAgICBpZiAoY2F0ZWdvcnlBeGlzICYmIGNhdGVnb3J5QXhpcy5pc0xhYmVsSWdub3JlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB6clV0aWwuYmluZChjYXRlZ29yeUF4aXMuaXNMYWJlbElnbm9yZWQsIGNhdGVnb3J5QXhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICAvLyBGSVhNRSBUd28gdmFsdWUgYXhpc1xuICAgICAgICBfdXBkYXRlQW5pbWF0aW9uOiBmdW5jdGlvbiAoZGF0YSwgc3RhY2tlZE9uUG9pbnRzLCBjb29yZFN5cywgYXBpLCBzdGVwKSB7XG4gICAgICAgICAgICB2YXIgcG9seWxpbmUgPSB0aGlzLl9wb2x5bGluZTtcbiAgICAgICAgICAgIHZhciBwb2x5Z29uID0gdGhpcy5fcG9seWdvbjtcbiAgICAgICAgICAgIHZhciBzZXJpZXNNb2RlbCA9IGRhdGEuaG9zdE1vZGVsO1xuXG4gICAgICAgICAgICB2YXIgZGlmZiA9IGxpbmVBbmltYXRpb25EaWZmKFxuICAgICAgICAgICAgICAgIHRoaXMuX2RhdGEsIGRhdGEsXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhY2tlZE9uUG9pbnRzLCBzdGFja2VkT25Qb2ludHMsXG4gICAgICAgICAgICAgICAgdGhpcy5fY29vcmRTeXMsIGNvb3JkU3lzXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICB2YXIgY3VycmVudCA9IGRpZmYuY3VycmVudDtcbiAgICAgICAgICAgIHZhciBzdGFja2VkT25DdXJyZW50ID0gZGlmZi5zdGFja2VkT25DdXJyZW50O1xuICAgICAgICAgICAgdmFyIG5leHQgPSBkaWZmLm5leHQ7XG4gICAgICAgICAgICB2YXIgc3RhY2tlZE9uTmV4dCA9IGRpZmYuc3RhY2tlZE9uTmV4dDtcbiAgICAgICAgICAgIGlmIChzdGVwKSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETyBJZiBzdGFja2VkIHNlcmllcyBpcyBub3Qgc3RlcFxuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSB0dXJuUG9pbnRzSW50b1N0ZXAoZGlmZi5jdXJyZW50LCBjb29yZFN5cywgc3RlcCk7XG4gICAgICAgICAgICAgICAgc3RhY2tlZE9uQ3VycmVudCA9IHR1cm5Qb2ludHNJbnRvU3RlcChkaWZmLnN0YWNrZWRPbkN1cnJlbnQsIGNvb3JkU3lzLCBzdGVwKTtcbiAgICAgICAgICAgICAgICBuZXh0ID0gdHVyblBvaW50c0ludG9TdGVwKGRpZmYubmV4dCwgY29vcmRTeXMsIHN0ZXApO1xuICAgICAgICAgICAgICAgIHN0YWNrZWRPbk5leHQgPSB0dXJuUG9pbnRzSW50b1N0ZXAoZGlmZi5zdGFja2VkT25OZXh0LCBjb29yZFN5cywgc3RlcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBgZGlmZi5jdXJyZW50YCBpcyBzdWJzZXQgb2YgYGN1cnJlbnRgICh3aGljaCBzaG91bGQgYmUgZW5zdXJlZCBieVxuICAgICAgICAgICAgLy8gdHVyblBvaW50c0ludG9TdGVwKSwgc28gcG9pbnRzIGluIGBfX3BvaW50c2AgY2FuIGJlIHVwZGF0ZWQgd2hlblxuICAgICAgICAgICAgLy8gcG9pbnRzIGluIGBjdXJyZW50YCBhcmUgdXBkYXRlIGR1cmluZyBhbmltYXRpb24uXG4gICAgICAgICAgICBwb2x5bGluZS5zaGFwZS5fX3BvaW50cyA9IGRpZmYuY3VycmVudDtcbiAgICAgICAgICAgIHBvbHlsaW5lLnNoYXBlLnBvaW50cyA9IGN1cnJlbnQ7XG5cbiAgICAgICAgICAgIGdyYXBoaWMudXBkYXRlUHJvcHMocG9seWxpbmUsIHtcbiAgICAgICAgICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgICAgICAgICBwb2ludHM6IG5leHRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBzZXJpZXNNb2RlbCk7XG5cbiAgICAgICAgICAgIGlmIChwb2x5Z29uKSB7XG4gICAgICAgICAgICAgICAgcG9seWdvbi5zZXRTaGFwZSh7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50czogY3VycmVudCxcbiAgICAgICAgICAgICAgICAgICAgc3RhY2tlZE9uUG9pbnRzOiBzdGFja2VkT25DdXJyZW50XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZ3JhcGhpYy51cGRhdGVQcm9wcyhwb2x5Z29uLCB7XG4gICAgICAgICAgICAgICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHM6IG5leHQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFja2VkT25Qb2ludHM6IHN0YWNrZWRPbk5leHRcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIHNlcmllc01vZGVsKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHVwZGF0ZWREYXRhSW5mbyA9IFtdO1xuICAgICAgICAgICAgdmFyIGRpZmZTdGF0dXMgPSBkaWZmLnN0YXR1cztcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaWZmU3RhdHVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNtZCA9IGRpZmZTdGF0dXNbaV0uY21kO1xuICAgICAgICAgICAgICAgIGlmIChjbWQgPT09ICc9Jykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZWwgPSBkYXRhLmdldEl0ZW1HcmFwaGljRWwoZGlmZlN0YXR1c1tpXS5pZHgxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVkRGF0YUluZm8ucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWw6IGVsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB0SWR4OiBpICAgIC8vIEluZGV4IG9mIHBvaW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwb2x5bGluZS5hbmltYXRvcnMgJiYgcG9seWxpbmUuYW5pbWF0b3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHBvbHlsaW5lLmFuaW1hdG9yc1swXS5kdXJpbmcoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHVwZGF0ZWREYXRhSW5mby5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVsID0gdXBkYXRlZERhdGFJbmZvW2ldLmVsO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwuYXR0cigncG9zaXRpb24nLCBwb2x5bGluZS5zaGFwZS5fX3BvaW50c1t1cGRhdGVkRGF0YUluZm9baV0ucHRJZHhdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gKGVjTW9kZWwpIHtcbiAgICAgICAgICAgIHZhciBncm91cCA9IHRoaXMuZ3JvdXA7XG4gICAgICAgICAgICB2YXIgb2xkRGF0YSA9IHRoaXMuX2RhdGE7XG4gICAgICAgICAgICB0aGlzLl9saW5lR3JvdXAucmVtb3ZlQWxsKCk7XG4gICAgICAgICAgICB0aGlzLl9zeW1ib2xEcmF3LnJlbW92ZSh0cnVlKTtcbiAgICAgICAgICAgIC8vIFJlbW92ZSB0ZW1wb3JhcnkgY3JlYXRlZCBlbGVtZW50cyB3aGVuIGhpZ2hsaWdodGluZ1xuICAgICAgICAgICAgb2xkRGF0YSAmJiBvbGREYXRhLmVhY2hJdGVtR3JhcGhpY0VsKGZ1bmN0aW9uIChlbCwgaWR4KSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsLl9fdGVtcCkge1xuICAgICAgICAgICAgICAgICAgICBncm91cC5yZW1vdmUoZWwpO1xuICAgICAgICAgICAgICAgICAgICBvbGREYXRhLnNldEl0ZW1HcmFwaGljRWwoaWR4LCBudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy5fcG9seWxpbmUgPVxuICAgICAgICAgICAgdGhpcy5fcG9seWdvbiA9XG4gICAgICAgICAgICB0aGlzLl9jb29yZFN5cyA9XG4gICAgICAgICAgICB0aGlzLl9wb2ludHMgPVxuICAgICAgICAgICAgdGhpcy5fc3RhY2tlZE9uUG9pbnRzID1cbiAgICAgICAgICAgIHRoaXMuX2RhdGEgPSBudWxsO1xuICAgICAgICB9XG4gICAgfSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9jaGFydC9saW5lL0xpbmVWaWV3LmpzXG4vLyBtb2R1bGUgaWQgPSAxNDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 141 */
/* unknown exports provided */
/* all exports used */
/*!*********************************************!*\
  !*** ./lib/chart/line/lineAnimationDiff.js ***!
  \*********************************************/
/***/ (function(module, exports) {

eval("\n\n    // var arrayDiff = require('zrender/lib/core/arrayDiff');\n    // 'zrender/core/arrayDiff' has been used before, but it did\n    // not do well in performance when roam with fixed dataZoom window.\n\n    function sign(val) {\n        return val >= 0 ? 1 : -1;\n    }\n\n    function getStackedOnPoint(coordSys, data, idx) {\n        var baseAxis = coordSys.getBaseAxis();\n        var valueAxis = coordSys.getOtherAxis(baseAxis);\n        var valueStart = baseAxis.onZero\n            ? 0 : valueAxis.scale.getExtent()[0];\n\n        var valueDim = valueAxis.dim;\n        var baseDataOffset = valueDim === 'x' || valueDim === 'radius' ? 1 : 0;\n\n        var stackedOnSameSign;\n        var stackedOn = data.stackedOn;\n        var val = data.get(valueDim, idx);\n        // Find first stacked value with same sign\n        while (stackedOn &&\n            sign(stackedOn.get(valueDim, idx)) === sign(val)\n        ) {\n            stackedOnSameSign = stackedOn;\n            break;\n        }\n        var stackedData = [];\n        stackedData[baseDataOffset] = data.get(baseAxis.dim, idx);\n        stackedData[1 - baseDataOffset] = stackedOnSameSign\n            ? stackedOnSameSign.get(valueDim, idx, true) : valueStart;\n\n        return coordSys.dataToPoint(stackedData);\n    }\n\n    // function convertToIntId(newIdList, oldIdList) {\n    //     // Generate int id instead of string id.\n    //     // Compare string maybe slow in score function of arrDiff\n\n    //     // Assume id in idList are all unique\n    //     var idIndicesMap = {};\n    //     var idx = 0;\n    //     for (var i = 0; i < newIdList.length; i++) {\n    //         idIndicesMap[newIdList[i]] = idx;\n    //         newIdList[i] = idx++;\n    //     }\n    //     for (var i = 0; i < oldIdList.length; i++) {\n    //         var oldId = oldIdList[i];\n    //         // Same with newIdList\n    //         if (idIndicesMap[oldId]) {\n    //             oldIdList[i] = idIndicesMap[oldId];\n    //         }\n    //         else {\n    //             oldIdList[i] = idx++;\n    //         }\n    //     }\n    // }\n\n    function diffData(oldData, newData) {\n        var diffResult = [];\n\n        newData.diff(oldData)\n            .add(function (idx) {\n                diffResult.push({cmd: '+', idx: idx});\n            })\n            .update(function (newIdx, oldIdx) {\n                diffResult.push({cmd: '=', idx: oldIdx, idx1: newIdx});\n            })\n            .remove(function (idx) {\n                diffResult.push({cmd: '-', idx: idx});\n            })\n            .execute();\n\n        return diffResult;\n    }\n\n    module.exports = function (\n        oldData, newData,\n        oldStackedOnPoints, newStackedOnPoints,\n        oldCoordSys, newCoordSys\n    ) {\n        var diff = diffData(oldData, newData);\n\n        // var newIdList = newData.mapArray(newData.getId);\n        // var oldIdList = oldData.mapArray(oldData.getId);\n\n        // convertToIntId(newIdList, oldIdList);\n\n        // // FIXME One data ?\n        // diff = arrayDiff(oldIdList, newIdList);\n\n        var currPoints = [];\n        var nextPoints = [];\n        // Points for stacking base line\n        var currStackedPoints = [];\n        var nextStackedPoints = [];\n\n        var status = [];\n        var sortedIndices = [];\n        var rawIndices = [];\n        var dims = newCoordSys.dimensions;\n        for (var i = 0; i < diff.length; i++) {\n            var diffItem = diff[i];\n            var pointAdded = true;\n\n            // FIXME, animation is not so perfect when dataZoom window moves fast\n            // Which is in case remvoing or add more than one data in the tail or head\n            switch (diffItem.cmd) {\n                case '=':\n                    var currentPt = oldData.getItemLayout(diffItem.idx);\n                    var nextPt = newData.getItemLayout(diffItem.idx1);\n                    // If previous data is NaN, use next point directly\n                    if (isNaN(currentPt[0]) || isNaN(currentPt[1])) {\n                        currentPt = nextPt.slice();\n                    }\n                    currPoints.push(currentPt);\n                    nextPoints.push(nextPt);\n\n                    currStackedPoints.push(oldStackedOnPoints[diffItem.idx]);\n                    nextStackedPoints.push(newStackedOnPoints[diffItem.idx1]);\n\n                    rawIndices.push(newData.getRawIndex(diffItem.idx1));\n                    break;\n                case '+':\n                    var idx = diffItem.idx;\n                    currPoints.push(\n                        oldCoordSys.dataToPoint([\n                            newData.get(dims[0], idx, true), newData.get(dims[1], idx, true)\n                        ])\n                    );\n\n                    nextPoints.push(newData.getItemLayout(idx).slice());\n\n                    currStackedPoints.push(\n                        getStackedOnPoint(oldCoordSys, newData, idx)\n                    );\n                    nextStackedPoints.push(newStackedOnPoints[idx]);\n\n                    rawIndices.push(newData.getRawIndex(idx));\n                    break;\n                case '-':\n                    var idx = diffItem.idx;\n                    var rawIndex = oldData.getRawIndex(idx);\n                    // Data is replaced. In the case of dynamic data queue\n                    // FIXME FIXME FIXME\n                    if (rawIndex !== idx) {\n                        currPoints.push(oldData.getItemLayout(idx));\n                        nextPoints.push(newCoordSys.dataToPoint([\n                            oldData.get(dims[0], idx, true), oldData.get(dims[1], idx, true)\n                        ]));\n\n                        currStackedPoints.push(oldStackedOnPoints[idx]);\n                        nextStackedPoints.push(\n                            getStackedOnPoint(\n                                newCoordSys, oldData, idx\n                            )\n                        );\n\n                        rawIndices.push(rawIndex);\n                    }\n                    else {\n                        pointAdded = false;\n                    }\n            }\n\n            // Original indices\n            if (pointAdded) {\n                status.push(diffItem);\n                sortedIndices.push(sortedIndices.length);\n            }\n        }\n\n        // Diff result may be crossed if all items are changed\n        // Sort by data index\n        sortedIndices.sort(function (a, b) {\n            return rawIndices[a] - rawIndices[b];\n        });\n\n        var sortedCurrPoints = [];\n        var sortedNextPoints = [];\n\n        var sortedCurrStackedPoints = [];\n        var sortedNextStackedPoints = [];\n\n        var sortedStatus = [];\n        for (var i = 0; i < sortedIndices.length; i++) {\n            var idx = sortedIndices[i];\n            sortedCurrPoints[i] = currPoints[idx];\n            sortedNextPoints[i] = nextPoints[idx];\n\n            sortedCurrStackedPoints[i] = currStackedPoints[idx];\n            sortedNextStackedPoints[i] = nextStackedPoints[idx];\n\n            sortedStatus[i] = status[idx];\n        }\n\n        return {\n            current: sortedCurrPoints,\n            next: sortedNextPoints,\n\n            stackedOnCurrent: sortedCurrStackedPoints,\n            stackedOnNext: sortedNextStackedPoints,\n\n            status: sortedStatus\n        };\n    };\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQxLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2NoYXJ0L2xpbmUvbGluZUFuaW1hdGlvbkRpZmYuanM/ZWQ0MSJdLCJzb3VyY2VzQ29udGVudCI6WyJcblxuICAgIC8vIHZhciBhcnJheURpZmYgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL2FycmF5RGlmZicpO1xuICAgIC8vICd6cmVuZGVyL2NvcmUvYXJyYXlEaWZmJyBoYXMgYmVlbiB1c2VkIGJlZm9yZSwgYnV0IGl0IGRpZFxuICAgIC8vIG5vdCBkbyB3ZWxsIGluIHBlcmZvcm1hbmNlIHdoZW4gcm9hbSB3aXRoIGZpeGVkIGRhdGFab29tIHdpbmRvdy5cblxuICAgIGZ1bmN0aW9uIHNpZ24odmFsKSB7XG4gICAgICAgIHJldHVybiB2YWwgPj0gMCA/IDEgOiAtMTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTdGFja2VkT25Qb2ludChjb29yZFN5cywgZGF0YSwgaWR4KSB7XG4gICAgICAgIHZhciBiYXNlQXhpcyA9IGNvb3JkU3lzLmdldEJhc2VBeGlzKCk7XG4gICAgICAgIHZhciB2YWx1ZUF4aXMgPSBjb29yZFN5cy5nZXRPdGhlckF4aXMoYmFzZUF4aXMpO1xuICAgICAgICB2YXIgdmFsdWVTdGFydCA9IGJhc2VBeGlzLm9uWmVyb1xuICAgICAgICAgICAgPyAwIDogdmFsdWVBeGlzLnNjYWxlLmdldEV4dGVudCgpWzBdO1xuXG4gICAgICAgIHZhciB2YWx1ZURpbSA9IHZhbHVlQXhpcy5kaW07XG4gICAgICAgIHZhciBiYXNlRGF0YU9mZnNldCA9IHZhbHVlRGltID09PSAneCcgfHwgdmFsdWVEaW0gPT09ICdyYWRpdXMnID8gMSA6IDA7XG5cbiAgICAgICAgdmFyIHN0YWNrZWRPblNhbWVTaWduO1xuICAgICAgICB2YXIgc3RhY2tlZE9uID0gZGF0YS5zdGFja2VkT247XG4gICAgICAgIHZhciB2YWwgPSBkYXRhLmdldCh2YWx1ZURpbSwgaWR4KTtcbiAgICAgICAgLy8gRmluZCBmaXJzdCBzdGFja2VkIHZhbHVlIHdpdGggc2FtZSBzaWduXG4gICAgICAgIHdoaWxlIChzdGFja2VkT24gJiZcbiAgICAgICAgICAgIHNpZ24oc3RhY2tlZE9uLmdldCh2YWx1ZURpbSwgaWR4KSkgPT09IHNpZ24odmFsKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHN0YWNrZWRPblNhbWVTaWduID0gc3RhY2tlZE9uO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0YWNrZWREYXRhID0gW107XG4gICAgICAgIHN0YWNrZWREYXRhW2Jhc2VEYXRhT2Zmc2V0XSA9IGRhdGEuZ2V0KGJhc2VBeGlzLmRpbSwgaWR4KTtcbiAgICAgICAgc3RhY2tlZERhdGFbMSAtIGJhc2VEYXRhT2Zmc2V0XSA9IHN0YWNrZWRPblNhbWVTaWduXG4gICAgICAgICAgICA/IHN0YWNrZWRPblNhbWVTaWduLmdldCh2YWx1ZURpbSwgaWR4LCB0cnVlKSA6IHZhbHVlU3RhcnQ7XG5cbiAgICAgICAgcmV0dXJuIGNvb3JkU3lzLmRhdGFUb1BvaW50KHN0YWNrZWREYXRhKTtcbiAgICB9XG5cbiAgICAvLyBmdW5jdGlvbiBjb252ZXJ0VG9JbnRJZChuZXdJZExpc3QsIG9sZElkTGlzdCkge1xuICAgIC8vICAgICAvLyBHZW5lcmF0ZSBpbnQgaWQgaW5zdGVhZCBvZiBzdHJpbmcgaWQuXG4gICAgLy8gICAgIC8vIENvbXBhcmUgc3RyaW5nIG1heWJlIHNsb3cgaW4gc2NvcmUgZnVuY3Rpb24gb2YgYXJyRGlmZlxuXG4gICAgLy8gICAgIC8vIEFzc3VtZSBpZCBpbiBpZExpc3QgYXJlIGFsbCB1bmlxdWVcbiAgICAvLyAgICAgdmFyIGlkSW5kaWNlc01hcCA9IHt9O1xuICAgIC8vICAgICB2YXIgaWR4ID0gMDtcbiAgICAvLyAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdJZExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAvLyAgICAgICAgIGlkSW5kaWNlc01hcFtuZXdJZExpc3RbaV1dID0gaWR4O1xuICAgIC8vICAgICAgICAgbmV3SWRMaXN0W2ldID0gaWR4Kys7XG4gICAgLy8gICAgIH1cbiAgICAvLyAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvbGRJZExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAvLyAgICAgICAgIHZhciBvbGRJZCA9IG9sZElkTGlzdFtpXTtcbiAgICAvLyAgICAgICAgIC8vIFNhbWUgd2l0aCBuZXdJZExpc3RcbiAgICAvLyAgICAgICAgIGlmIChpZEluZGljZXNNYXBbb2xkSWRdKSB7XG4gICAgLy8gICAgICAgICAgICAgb2xkSWRMaXN0W2ldID0gaWRJbmRpY2VzTWFwW29sZElkXTtcbiAgICAvLyAgICAgICAgIH1cbiAgICAvLyAgICAgICAgIGVsc2Uge1xuICAgIC8vICAgICAgICAgICAgIG9sZElkTGlzdFtpXSA9IGlkeCsrO1xuICAgIC8vICAgICAgICAgfVxuICAgIC8vICAgICB9XG4gICAgLy8gfVxuXG4gICAgZnVuY3Rpb24gZGlmZkRhdGEob2xkRGF0YSwgbmV3RGF0YSkge1xuICAgICAgICB2YXIgZGlmZlJlc3VsdCA9IFtdO1xuXG4gICAgICAgIG5ld0RhdGEuZGlmZihvbGREYXRhKVxuICAgICAgICAgICAgLmFkZChmdW5jdGlvbiAoaWR4KSB7XG4gICAgICAgICAgICAgICAgZGlmZlJlc3VsdC5wdXNoKHtjbWQ6ICcrJywgaWR4OiBpZHh9KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAudXBkYXRlKGZ1bmN0aW9uIChuZXdJZHgsIG9sZElkeCkge1xuICAgICAgICAgICAgICAgIGRpZmZSZXN1bHQucHVzaCh7Y21kOiAnPScsIGlkeDogb2xkSWR4LCBpZHgxOiBuZXdJZHh9KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAucmVtb3ZlKGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgICAgICAgICBkaWZmUmVzdWx0LnB1c2goe2NtZDogJy0nLCBpZHg6IGlkeH0pO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5leGVjdXRlKCk7XG5cbiAgICAgICAgcmV0dXJuIGRpZmZSZXN1bHQ7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoXG4gICAgICAgIG9sZERhdGEsIG5ld0RhdGEsXG4gICAgICAgIG9sZFN0YWNrZWRPblBvaW50cywgbmV3U3RhY2tlZE9uUG9pbnRzLFxuICAgICAgICBvbGRDb29yZFN5cywgbmV3Q29vcmRTeXNcbiAgICApIHtcbiAgICAgICAgdmFyIGRpZmYgPSBkaWZmRGF0YShvbGREYXRhLCBuZXdEYXRhKTtcblxuICAgICAgICAvLyB2YXIgbmV3SWRMaXN0ID0gbmV3RGF0YS5tYXBBcnJheShuZXdEYXRhLmdldElkKTtcbiAgICAgICAgLy8gdmFyIG9sZElkTGlzdCA9IG9sZERhdGEubWFwQXJyYXkob2xkRGF0YS5nZXRJZCk7XG5cbiAgICAgICAgLy8gY29udmVydFRvSW50SWQobmV3SWRMaXN0LCBvbGRJZExpc3QpO1xuXG4gICAgICAgIC8vIC8vIEZJWE1FIE9uZSBkYXRhID9cbiAgICAgICAgLy8gZGlmZiA9IGFycmF5RGlmZihvbGRJZExpc3QsIG5ld0lkTGlzdCk7XG5cbiAgICAgICAgdmFyIGN1cnJQb2ludHMgPSBbXTtcbiAgICAgICAgdmFyIG5leHRQb2ludHMgPSBbXTtcbiAgICAgICAgLy8gUG9pbnRzIGZvciBzdGFja2luZyBiYXNlIGxpbmVcbiAgICAgICAgdmFyIGN1cnJTdGFja2VkUG9pbnRzID0gW107XG4gICAgICAgIHZhciBuZXh0U3RhY2tlZFBvaW50cyA9IFtdO1xuXG4gICAgICAgIHZhciBzdGF0dXMgPSBbXTtcbiAgICAgICAgdmFyIHNvcnRlZEluZGljZXMgPSBbXTtcbiAgICAgICAgdmFyIHJhd0luZGljZXMgPSBbXTtcbiAgICAgICAgdmFyIGRpbXMgPSBuZXdDb29yZFN5cy5kaW1lbnNpb25zO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpZmYubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBkaWZmSXRlbSA9IGRpZmZbaV07XG4gICAgICAgICAgICB2YXIgcG9pbnRBZGRlZCA9IHRydWU7XG5cbiAgICAgICAgICAgIC8vIEZJWE1FLCBhbmltYXRpb24gaXMgbm90IHNvIHBlcmZlY3Qgd2hlbiBkYXRhWm9vbSB3aW5kb3cgbW92ZXMgZmFzdFxuICAgICAgICAgICAgLy8gV2hpY2ggaXMgaW4gY2FzZSByZW12b2luZyBvciBhZGQgbW9yZSB0aGFuIG9uZSBkYXRhIGluIHRoZSB0YWlsIG9yIGhlYWRcbiAgICAgICAgICAgIHN3aXRjaCAoZGlmZkl0ZW0uY21kKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnPSc6XG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJyZW50UHQgPSBvbGREYXRhLmdldEl0ZW1MYXlvdXQoZGlmZkl0ZW0uaWR4KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5leHRQdCA9IG5ld0RhdGEuZ2V0SXRlbUxheW91dChkaWZmSXRlbS5pZHgxKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgcHJldmlvdXMgZGF0YSBpcyBOYU4sIHVzZSBuZXh0IHBvaW50IGRpcmVjdGx5XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc05hTihjdXJyZW50UHRbMF0pIHx8IGlzTmFOKGN1cnJlbnRQdFsxXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQdCA9IG5leHRQdC5zbGljZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN1cnJQb2ludHMucHVzaChjdXJyZW50UHQpO1xuICAgICAgICAgICAgICAgICAgICBuZXh0UG9pbnRzLnB1c2gobmV4dFB0KTtcblxuICAgICAgICAgICAgICAgICAgICBjdXJyU3RhY2tlZFBvaW50cy5wdXNoKG9sZFN0YWNrZWRPblBvaW50c1tkaWZmSXRlbS5pZHhdKTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFN0YWNrZWRQb2ludHMucHVzaChuZXdTdGFja2VkT25Qb2ludHNbZGlmZkl0ZW0uaWR4MV0pO1xuXG4gICAgICAgICAgICAgICAgICAgIHJhd0luZGljZXMucHVzaChuZXdEYXRhLmdldFJhd0luZGV4KGRpZmZJdGVtLmlkeDEpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnKyc6XG4gICAgICAgICAgICAgICAgICAgIHZhciBpZHggPSBkaWZmSXRlbS5pZHg7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJQb2ludHMucHVzaChcbiAgICAgICAgICAgICAgICAgICAgICAgIG9sZENvb3JkU3lzLmRhdGFUb1BvaW50KFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdEYXRhLmdldChkaW1zWzBdLCBpZHgsIHRydWUpLCBuZXdEYXRhLmdldChkaW1zWzFdLCBpZHgsIHRydWUpXG4gICAgICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgIG5leHRQb2ludHMucHVzaChuZXdEYXRhLmdldEl0ZW1MYXlvdXQoaWR4KS5zbGljZSgpKTtcblxuICAgICAgICAgICAgICAgICAgICBjdXJyU3RhY2tlZFBvaW50cy5wdXNoKFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0U3RhY2tlZE9uUG9pbnQob2xkQ29vcmRTeXMsIG5ld0RhdGEsIGlkeClcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFN0YWNrZWRQb2ludHMucHVzaChuZXdTdGFja2VkT25Qb2ludHNbaWR4XSk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmF3SW5kaWNlcy5wdXNoKG5ld0RhdGEuZ2V0UmF3SW5kZXgoaWR4KSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgICAgICAgICAgICB2YXIgaWR4ID0gZGlmZkl0ZW0uaWR4O1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmF3SW5kZXggPSBvbGREYXRhLmdldFJhd0luZGV4KGlkeCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIERhdGEgaXMgcmVwbGFjZWQuIEluIHRoZSBjYXNlIG9mIGR5bmFtaWMgZGF0YSBxdWV1ZVxuICAgICAgICAgICAgICAgICAgICAvLyBGSVhNRSBGSVhNRSBGSVhNRVxuICAgICAgICAgICAgICAgICAgICBpZiAocmF3SW5kZXggIT09IGlkeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VyclBvaW50cy5wdXNoKG9sZERhdGEuZ2V0SXRlbUxheW91dChpZHgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRQb2ludHMucHVzaChuZXdDb29yZFN5cy5kYXRhVG9Qb2ludChbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkRGF0YS5nZXQoZGltc1swXSwgaWR4LCB0cnVlKSwgb2xkRGF0YS5nZXQoZGltc1sxXSwgaWR4LCB0cnVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgXSkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyU3RhY2tlZFBvaW50cy5wdXNoKG9sZFN0YWNrZWRPblBvaW50c1tpZHhdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRTdGFja2VkUG9pbnRzLnB1c2goXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0U3RhY2tlZE9uUG9pbnQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0Nvb3JkU3lzLCBvbGREYXRhLCBpZHhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByYXdJbmRpY2VzLnB1c2gocmF3SW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRBZGRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE9yaWdpbmFsIGluZGljZXNcbiAgICAgICAgICAgIGlmIChwb2ludEFkZGVkKSB7XG4gICAgICAgICAgICAgICAgc3RhdHVzLnB1c2goZGlmZkl0ZW0pO1xuICAgICAgICAgICAgICAgIHNvcnRlZEluZGljZXMucHVzaChzb3J0ZWRJbmRpY2VzLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEaWZmIHJlc3VsdCBtYXkgYmUgY3Jvc3NlZCBpZiBhbGwgaXRlbXMgYXJlIGNoYW5nZWRcbiAgICAgICAgLy8gU29ydCBieSBkYXRhIGluZGV4XG4gICAgICAgIHNvcnRlZEluZGljZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIHJhd0luZGljZXNbYV0gLSByYXdJbmRpY2VzW2JdO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgc29ydGVkQ3VyclBvaW50cyA9IFtdO1xuICAgICAgICB2YXIgc29ydGVkTmV4dFBvaW50cyA9IFtdO1xuXG4gICAgICAgIHZhciBzb3J0ZWRDdXJyU3RhY2tlZFBvaW50cyA9IFtdO1xuICAgICAgICB2YXIgc29ydGVkTmV4dFN0YWNrZWRQb2ludHMgPSBbXTtcblxuICAgICAgICB2YXIgc29ydGVkU3RhdHVzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc29ydGVkSW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGlkeCA9IHNvcnRlZEluZGljZXNbaV07XG4gICAgICAgICAgICBzb3J0ZWRDdXJyUG9pbnRzW2ldID0gY3VyclBvaW50c1tpZHhdO1xuICAgICAgICAgICAgc29ydGVkTmV4dFBvaW50c1tpXSA9IG5leHRQb2ludHNbaWR4XTtcblxuICAgICAgICAgICAgc29ydGVkQ3VyclN0YWNrZWRQb2ludHNbaV0gPSBjdXJyU3RhY2tlZFBvaW50c1tpZHhdO1xuICAgICAgICAgICAgc29ydGVkTmV4dFN0YWNrZWRQb2ludHNbaV0gPSBuZXh0U3RhY2tlZFBvaW50c1tpZHhdO1xuXG4gICAgICAgICAgICBzb3J0ZWRTdGF0dXNbaV0gPSBzdGF0dXNbaWR4XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjdXJyZW50OiBzb3J0ZWRDdXJyUG9pbnRzLFxuICAgICAgICAgICAgbmV4dDogc29ydGVkTmV4dFBvaW50cyxcblxuICAgICAgICAgICAgc3RhY2tlZE9uQ3VycmVudDogc29ydGVkQ3VyclN0YWNrZWRQb2ludHMsXG4gICAgICAgICAgICBzdGFja2VkT25OZXh0OiBzb3J0ZWROZXh0U3RhY2tlZFBvaW50cyxcblxuICAgICAgICAgICAgc3RhdHVzOiBzb3J0ZWRTdGF0dXNcbiAgICAgICAgfTtcbiAgICB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvY2hhcnQvbGluZS9saW5lQW5pbWF0aW9uRGlmZi5qc1xuLy8gbW9kdWxlIGlkID0gMTQxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 142 */
/* unknown exports provided */
/* all exports used */
/*!************************************!*\
  !*** ./lib/chart/pie/PieSeries.js ***!
  \************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\n    var List = __webpack_require__(/*! ../../data/List */ 13);\n    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 0);\n    var modelUtil = __webpack_require__(/*! ../../util/model */ 5);\n    var completeDimensions = __webpack_require__(/*! ../../data/helper/completeDimensions */ 24);\n\n    var dataSelectableMixin = __webpack_require__(/*! ../../component/helper/selectableMixin */ 83);\n\n    var PieSeries = __webpack_require__(/*! ../../echarts */ 1).extendSeriesModel({\n\n        type: 'series.pie',\n\n        // Overwrite\n        init: function (option) {\n            PieSeries.superApply(this, 'init', arguments);\n\n            // Enable legend selection for each data item\n            // Use a function instead of direct access because data reference may changed\n            this.legendDataProvider = function () {\n                return this.getRawData();\n            };\n\n            this.updateSelectedMap(option.data);\n\n            this._defaultLabelLine(option);\n        },\n\n        // Overwrite\n        mergeOption: function (newOption) {\n            PieSeries.superCall(this, 'mergeOption', newOption);\n            this.updateSelectedMap(this.option.data);\n        },\n\n        getInitialData: function (option, ecModel) {\n            var dimensions = completeDimensions(['value'], option.data);\n            var list = new List(dimensions, this);\n            list.initData(option.data);\n            return list;\n        },\n\n        // Overwrite\n        getDataParams: function (dataIndex) {\n            var data = this.getData();\n            var params = PieSeries.superCall(this, 'getDataParams', dataIndex);\n            var sum = data.getSum('value');\n            // FIXME toFixed?\n            //\n            // Percent is 0 if sum is 0\n            params.percent = !sum ? 0 : +(data.get('value', dataIndex) / sum * 100).toFixed(2);\n\n            params.$vars.push('percent');\n            return params;\n        },\n\n        _defaultLabelLine: function (option) {\n            // Extend labelLine emphasis\n            modelUtil.defaultEmphasis(option.labelLine, ['show']);\n\n            var labelLineNormalOpt = option.labelLine.normal;\n            var labelLineEmphasisOpt = option.labelLine.emphasis;\n            // Not show label line if `label.normal.show = false`\n            labelLineNormalOpt.show = labelLineNormalOpt.show\n                && option.label.normal.show;\n            labelLineEmphasisOpt.show = labelLineEmphasisOpt.show\n                && option.label.emphasis.show;\n        },\n\n        defaultOption: {\n            zlevel: 0,\n            z: 2,\n            legendHoverLink: true,\n\n            hoverAnimation: true,\n            // 默认全局居中\n            center: ['50%', '50%'],\n            radius: [0, '75%'],\n            // 默认顺时针\n            clockwise: true,\n            startAngle: 90,\n            // 最小角度改为0\n            minAngle: 0,\n            // 选中是扇区偏移量\n            selectedOffset: 10,\n\n            // If use strategy to avoid label overlapping\n            avoidLabelOverlap: true,\n            // 选择模式，默认关闭，可选single，multiple\n            // selectedMode: false,\n            // 南丁格尔玫瑰图模式，'radius'（半径） | 'area'（面积）\n            // roseType: null,\n\n            // If still show when all data zero.\n            stillShowZeroSum: true,\n\n            label: {\n                normal: {\n                    // If rotate around circle\n                    rotate: false,\n                    show: true,\n                    // 'outer', 'inside', 'center'\n                    position: 'outer'\n                    // formatter: 标签文本格式器，同Tooltip.formatter，不支持异步回调\n                    // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE\n                    // distance: 当position为inner时有效，为label位置到圆心的距离与圆半径(环状图为内外半径和)的比例系数\n                },\n                emphasis: {}\n            },\n            // Enabled when label.normal.position is 'outer'\n            labelLine: {\n                normal: {\n                    show: true,\n                    // 引导线两段中的第一段长度\n                    length: 15,\n                    // 引导线两段中的第二段长度\n                    length2: 15,\n                    smooth: false,\n                    lineStyle: {\n                        // color: 各异,\n                        width: 1,\n                        type: 'solid'\n                    }\n                }\n            },\n            itemStyle: {\n                normal: {\n                    borderWidth: 1\n                },\n                emphasis: {}\n            },\n\n            // Animation type canbe expansion, scale\n            animationType: 'expansion',\n\n            animationEasing: 'cubicOut',\n\n            data: []\n        }\n    });\n\n    zrUtil.mixin(PieSeries, dataSelectableMixin);\n\n    module.exports = PieSeries;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2NoYXJ0L3BpZS9QaWVTZXJpZXMuanM/MmM4NyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciBMaXN0ID0gcmVxdWlyZSgnLi4vLi4vZGF0YS9MaXN0Jyk7XG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuICAgIHZhciBtb2RlbFV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL21vZGVsJyk7XG4gICAgdmFyIGNvbXBsZXRlRGltZW5zaW9ucyA9IHJlcXVpcmUoJy4uLy4uL2RhdGEvaGVscGVyL2NvbXBsZXRlRGltZW5zaW9ucycpO1xuXG4gICAgdmFyIGRhdGFTZWxlY3RhYmxlTWl4aW4gPSByZXF1aXJlKCcuLi8uLi9jb21wb25lbnQvaGVscGVyL3NlbGVjdGFibGVNaXhpbicpO1xuXG4gICAgdmFyIFBpZVNlcmllcyA9IHJlcXVpcmUoJy4uLy4uL2VjaGFydHMnKS5leHRlbmRTZXJpZXNNb2RlbCh7XG5cbiAgICAgICAgdHlwZTogJ3Nlcmllcy5waWUnLFxuXG4gICAgICAgIC8vIE92ZXJ3cml0ZVxuICAgICAgICBpbml0OiBmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgICAgICAgICBQaWVTZXJpZXMuc3VwZXJBcHBseSh0aGlzLCAnaW5pdCcsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIC8vIEVuYWJsZSBsZWdlbmQgc2VsZWN0aW9uIGZvciBlYWNoIGRhdGEgaXRlbVxuICAgICAgICAgICAgLy8gVXNlIGEgZnVuY3Rpb24gaW5zdGVhZCBvZiBkaXJlY3QgYWNjZXNzIGJlY2F1c2UgZGF0YSByZWZlcmVuY2UgbWF5IGNoYW5nZWRcbiAgICAgICAgICAgIHRoaXMubGVnZW5kRGF0YVByb3ZpZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFJhd0RhdGEoKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMudXBkYXRlU2VsZWN0ZWRNYXAob3B0aW9uLmRhdGEpO1xuXG4gICAgICAgICAgICB0aGlzLl9kZWZhdWx0TGFiZWxMaW5lKG9wdGlvbik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gT3ZlcndyaXRlXG4gICAgICAgIG1lcmdlT3B0aW9uOiBmdW5jdGlvbiAobmV3T3B0aW9uKSB7XG4gICAgICAgICAgICBQaWVTZXJpZXMuc3VwZXJDYWxsKHRoaXMsICdtZXJnZU9wdGlvbicsIG5ld09wdGlvbik7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVNlbGVjdGVkTWFwKHRoaXMub3B0aW9uLmRhdGEpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldEluaXRpYWxEYXRhOiBmdW5jdGlvbiAob3B0aW9uLCBlY01vZGVsKSB7XG4gICAgICAgICAgICB2YXIgZGltZW5zaW9ucyA9IGNvbXBsZXRlRGltZW5zaW9ucyhbJ3ZhbHVlJ10sIG9wdGlvbi5kYXRhKTtcbiAgICAgICAgICAgIHZhciBsaXN0ID0gbmV3IExpc3QoZGltZW5zaW9ucywgdGhpcyk7XG4gICAgICAgICAgICBsaXN0LmluaXREYXRhKG9wdGlvbi5kYXRhKTtcbiAgICAgICAgICAgIHJldHVybiBsaXN0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIE92ZXJ3cml0ZVxuICAgICAgICBnZXREYXRhUGFyYW1zOiBmdW5jdGlvbiAoZGF0YUluZGV4KSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZ2V0RGF0YSgpO1xuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IFBpZVNlcmllcy5zdXBlckNhbGwodGhpcywgJ2dldERhdGFQYXJhbXMnLCBkYXRhSW5kZXgpO1xuICAgICAgICAgICAgdmFyIHN1bSA9IGRhdGEuZ2V0U3VtKCd2YWx1ZScpO1xuICAgICAgICAgICAgLy8gRklYTUUgdG9GaXhlZD9cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBQZXJjZW50IGlzIDAgaWYgc3VtIGlzIDBcbiAgICAgICAgICAgIHBhcmFtcy5wZXJjZW50ID0gIXN1bSA/IDAgOiArKGRhdGEuZ2V0KCd2YWx1ZScsIGRhdGFJbmRleCkgLyBzdW0gKiAxMDApLnRvRml4ZWQoMik7XG5cbiAgICAgICAgICAgIHBhcmFtcy4kdmFycy5wdXNoKCdwZXJjZW50Jyk7XG4gICAgICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9kZWZhdWx0TGFiZWxMaW5lOiBmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgICAgICAgICAvLyBFeHRlbmQgbGFiZWxMaW5lIGVtcGhhc2lzXG4gICAgICAgICAgICBtb2RlbFV0aWwuZGVmYXVsdEVtcGhhc2lzKG9wdGlvbi5sYWJlbExpbmUsIFsnc2hvdyddKTtcblxuICAgICAgICAgICAgdmFyIGxhYmVsTGluZU5vcm1hbE9wdCA9IG9wdGlvbi5sYWJlbExpbmUubm9ybWFsO1xuICAgICAgICAgICAgdmFyIGxhYmVsTGluZUVtcGhhc2lzT3B0ID0gb3B0aW9uLmxhYmVsTGluZS5lbXBoYXNpcztcbiAgICAgICAgICAgIC8vIE5vdCBzaG93IGxhYmVsIGxpbmUgaWYgYGxhYmVsLm5vcm1hbC5zaG93ID0gZmFsc2VgXG4gICAgICAgICAgICBsYWJlbExpbmVOb3JtYWxPcHQuc2hvdyA9IGxhYmVsTGluZU5vcm1hbE9wdC5zaG93XG4gICAgICAgICAgICAgICAgJiYgb3B0aW9uLmxhYmVsLm5vcm1hbC5zaG93O1xuICAgICAgICAgICAgbGFiZWxMaW5lRW1waGFzaXNPcHQuc2hvdyA9IGxhYmVsTGluZUVtcGhhc2lzT3B0LnNob3dcbiAgICAgICAgICAgICAgICAmJiBvcHRpb24ubGFiZWwuZW1waGFzaXMuc2hvdztcbiAgICAgICAgfSxcblxuICAgICAgICBkZWZhdWx0T3B0aW9uOiB7XG4gICAgICAgICAgICB6bGV2ZWw6IDAsXG4gICAgICAgICAgICB6OiAyLFxuICAgICAgICAgICAgbGVnZW5kSG92ZXJMaW5rOiB0cnVlLFxuXG4gICAgICAgICAgICBob3ZlckFuaW1hdGlvbjogdHJ1ZSxcbiAgICAgICAgICAgIC8vIOm7mOiupOWFqOWxgOWxheS4rVxuICAgICAgICAgICAgY2VudGVyOiBbJzUwJScsICc1MCUnXSxcbiAgICAgICAgICAgIHJhZGl1czogWzAsICc3NSUnXSxcbiAgICAgICAgICAgIC8vIOm7mOiupOmhuuaXtumSiFxuICAgICAgICAgICAgY2xvY2t3aXNlOiB0cnVlLFxuICAgICAgICAgICAgc3RhcnRBbmdsZTogOTAsXG4gICAgICAgICAgICAvLyDmnIDlsI/op5LluqbmlLnkuLowXG4gICAgICAgICAgICBtaW5BbmdsZTogMCxcbiAgICAgICAgICAgIC8vIOmAieS4reaYr+aJh+WMuuWBj+enu+mHj1xuICAgICAgICAgICAgc2VsZWN0ZWRPZmZzZXQ6IDEwLFxuXG4gICAgICAgICAgICAvLyBJZiB1c2Ugc3RyYXRlZ3kgdG8gYXZvaWQgbGFiZWwgb3ZlcmxhcHBpbmdcbiAgICAgICAgICAgIGF2b2lkTGFiZWxPdmVybGFwOiB0cnVlLFxuICAgICAgICAgICAgLy8g6YCJ5oup5qih5byP77yM6buY6K6k5YWz6Zet77yM5Y+v6YCJc2luZ2xl77yMbXVsdGlwbGVcbiAgICAgICAgICAgIC8vIHNlbGVjdGVkTW9kZTogZmFsc2UsXG4gICAgICAgICAgICAvLyDljZfkuIHmoLzlsJTnjqvnkbDlm77mqKHlvI/vvIwncmFkaXVzJ++8iOWNiuW+hO+8iSB8ICdhcmVhJ++8iOmdouenr++8iVxuICAgICAgICAgICAgLy8gcm9zZVR5cGU6IG51bGwsXG5cbiAgICAgICAgICAgIC8vIElmIHN0aWxsIHNob3cgd2hlbiBhbGwgZGF0YSB6ZXJvLlxuICAgICAgICAgICAgc3RpbGxTaG93WmVyb1N1bTogdHJ1ZSxcblxuICAgICAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICAgICAgICBub3JtYWw6IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgcm90YXRlIGFyb3VuZCBjaXJjbGVcbiAgICAgICAgICAgICAgICAgICAgcm90YXRlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgLy8gJ291dGVyJywgJ2luc2lkZScsICdjZW50ZXInXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnb3V0ZXInXG4gICAgICAgICAgICAgICAgICAgIC8vIGZvcm1hdHRlcjog5qCH562+5paH5pys5qC85byP5Zmo77yM5ZCMVG9vbHRpcC5mb3JtYXR0ZXLvvIzkuI3mlK/mjIHlvILmraXlm57osINcbiAgICAgICAgICAgICAgICAgICAgLy8gdGV4dFN0eWxlOiBudWxsICAgICAgLy8g6buY6K6k5L2/55So5YWo5bGA5paH5pys5qC35byP77yM6K+m6KeBVEVYVFNUWUxFXG4gICAgICAgICAgICAgICAgICAgIC8vIGRpc3RhbmNlOiDlvZNwb3NpdGlvbuS4umlubmVy5pe25pyJ5pWI77yM5Li6bGFiZWzkvY3nva7liLDlnIblv4PnmoTot53nprvkuI7lnIbljYrlvoQo546v54q25Zu+5Li65YaF5aSW5Y2K5b6E5ZKMKeeahOavlOS+i+ezu+aVsFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZW1waGFzaXM6IHt9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gRW5hYmxlZCB3aGVuIGxhYmVsLm5vcm1hbC5wb3NpdGlvbiBpcyAnb3V0ZXInXG4gICAgICAgICAgICBsYWJlbExpbmU6IHtcbiAgICAgICAgICAgICAgICBub3JtYWw6IHtcbiAgICAgICAgICAgICAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgLy8g5byV5a+857q/5Lik5q615Lit55qE56ys5LiA5q616ZW/5bqmXG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aDogMTUsXG4gICAgICAgICAgICAgICAgICAgIC8vIOW8leWvvOe6v+S4pOauteS4reeahOesrOS6jOautemVv+W6plxuICAgICAgICAgICAgICAgICAgICBsZW5ndGgyOiAxNSxcbiAgICAgICAgICAgICAgICAgICAgc21vb3RoOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgbGluZVN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb2xvcjog5ZCE5byCLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnc29saWQnXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXRlbVN0eWxlOiB7XG4gICAgICAgICAgICAgICAgbm9ybWFsOiB7XG4gICAgICAgICAgICAgICAgICAgIGJvcmRlcldpZHRoOiAxXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlbXBoYXNpczoge31cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIEFuaW1hdGlvbiB0eXBlIGNhbmJlIGV4cGFuc2lvbiwgc2NhbGVcbiAgICAgICAgICAgIGFuaW1hdGlvblR5cGU6ICdleHBhbnNpb24nLFxuXG4gICAgICAgICAgICBhbmltYXRpb25FYXNpbmc6ICdjdWJpY091dCcsXG5cbiAgICAgICAgICAgIGRhdGE6IFtdXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHpyVXRpbC5taXhpbihQaWVTZXJpZXMsIGRhdGFTZWxlY3RhYmxlTWl4aW4pO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBQaWVTZXJpZXM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9jaGFydC9waWUvUGllU2VyaWVzLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 143 */
/* unknown exports provided */
/* all exports used */
/*!**********************************!*\
  !*** ./lib/chart/pie/PieView.js ***!
  \**********************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var graphic = __webpack_require__(/*! ../../util/graphic */ 2);\n    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 0);\n\n    /**\n     * @param {module:echarts/model/Series} seriesModel\n     * @param {boolean} hasAnimation\n     * @inner\n     */\n    function updateDataSelected(uid, seriesModel, hasAnimation, api) {\n        var data = seriesModel.getData();\n        var dataIndex = this.dataIndex;\n        var name = data.getName(dataIndex);\n        var selectedOffset = seriesModel.get('selectedOffset');\n\n        api.dispatchAction({\n            type: 'pieToggleSelect',\n            from: uid,\n            name: name,\n            seriesId: seriesModel.id\n        });\n\n        data.each(function (idx) {\n            toggleItemSelected(\n                data.getItemGraphicEl(idx),\n                data.getItemLayout(idx),\n                seriesModel.isSelected(data.getName(idx)),\n                selectedOffset,\n                hasAnimation\n            );\n        });\n    }\n\n    /**\n     * @param {module:zrender/graphic/Sector} el\n     * @param {Object} layout\n     * @param {boolean} isSelected\n     * @param {number} selectedOffset\n     * @param {boolean} hasAnimation\n     * @inner\n     */\n    function toggleItemSelected(el, layout, isSelected, selectedOffset, hasAnimation) {\n        var midAngle = (layout.startAngle + layout.endAngle) / 2;\n\n        var dx = Math.cos(midAngle);\n        var dy = Math.sin(midAngle);\n\n        var offset = isSelected ? selectedOffset : 0;\n        var position = [dx * offset, dy * offset];\n\n        hasAnimation\n            // animateTo will stop revious animation like update transition\n            ? el.animate()\n                .when(200, {\n                    position: position\n                })\n                .start('bounceOut')\n            : el.attr('position', position);\n    }\n\n    /**\n     * Piece of pie including Sector, Label, LabelLine\n     * @constructor\n     * @extends {module:zrender/graphic/Group}\n     */\n    function PiePiece(data, idx) {\n\n        graphic.Group.call(this);\n\n        var sector = new graphic.Sector({\n            z2: 2\n        });\n        var polyline = new graphic.Polyline();\n        var text = new graphic.Text();\n        this.add(sector);\n        this.add(polyline);\n        this.add(text);\n\n        this.updateData(data, idx, true);\n\n        // Hover to change label and labelLine\n        function onEmphasis() {\n            polyline.ignore = polyline.hoverIgnore;\n            text.ignore = text.hoverIgnore;\n        }\n        function onNormal() {\n            polyline.ignore = polyline.normalIgnore;\n            text.ignore = text.normalIgnore;\n        }\n        this.on('emphasis', onEmphasis)\n            .on('normal', onNormal)\n            .on('mouseover', onEmphasis)\n            .on('mouseout', onNormal);\n    }\n\n    var piePieceProto = PiePiece.prototype;\n\n    function getLabelStyle(data, idx, state, labelModel, labelPosition) {\n        var textStyleModel = labelModel.getModel('textStyle');\n        var isLabelInside = labelPosition === 'inside' || labelPosition === 'inner';\n        return {\n            fill: textStyleModel.getTextColor()\n                || (isLabelInside ? '#fff' : data.getItemVisual(idx, 'color')),\n            opacity: data.getItemVisual(idx, 'opacity'),\n            textFont: textStyleModel.getFont(),\n            text: zrUtil.retrieve(\n                data.hostModel.getFormattedLabel(idx, state), data.getName(idx)\n            )\n        };\n    }\n\n    piePieceProto.updateData = function (data, idx, firstCreate) {\n\n        var sector = this.childAt(0);\n\n        var seriesModel = data.hostModel;\n        var itemModel = data.getItemModel(idx);\n        var layout = data.getItemLayout(idx);\n        var sectorShape = zrUtil.extend({}, layout);\n        sectorShape.label = null;\n\n        if (firstCreate) {\n            sector.setShape(sectorShape);\n\n            var animationType = seriesModel.getShallow('animationType');\n            if (animationType === 'scale') {\n                sector.shape.r = layout.r0;\n                graphic.initProps(sector, {\n                    shape: {\n                        r: layout.r\n                    }\n                }, seriesModel, idx);\n            }\n            // Expansion\n            else {\n                sector.shape.endAngle = layout.startAngle;\n                graphic.updateProps(sector, {\n                    shape: {\n                        endAngle: layout.endAngle\n                    }\n                }, seriesModel, idx);\n            }\n\n        }\n        else {\n            graphic.updateProps(sector, {\n                shape: sectorShape\n            }, seriesModel, idx);\n        }\n\n        // Update common style\n        var itemStyleModel = itemModel.getModel('itemStyle');\n        var visualColor = data.getItemVisual(idx, 'color');\n\n        sector.useStyle(\n            zrUtil.defaults(\n                {\n                    lineJoin: 'bevel',\n                    fill: visualColor\n                },\n                itemStyleModel.getModel('normal').getItemStyle()\n            )\n        );\n        sector.hoverStyle = itemStyleModel.getModel('emphasis').getItemStyle();\n\n        // Toggle selected\n        toggleItemSelected(\n            this,\n            data.getItemLayout(idx),\n            itemModel.get('selected'),\n            seriesModel.get('selectedOffset'),\n            seriesModel.get('animation')\n        );\n\n        function onEmphasis() {\n            // Sector may has animation of updating data. Force to move to the last frame\n            // Or it may stopped on the wrong shape\n            sector.stopAnimation(true);\n            sector.animateTo({\n                shape: {\n                    r: layout.r + 10\n                }\n            }, 300, 'elasticOut');\n        }\n        function onNormal() {\n            sector.stopAnimation(true);\n            sector.animateTo({\n                shape: {\n                    r: layout.r\n                }\n            }, 300, 'elasticOut');\n        }\n        sector.off('mouseover').off('mouseout').off('emphasis').off('normal');\n        if (itemModel.get('hoverAnimation') && seriesModel.isAnimationEnabled()) {\n            sector\n                .on('mouseover', onEmphasis)\n                .on('mouseout', onNormal)\n                .on('emphasis', onEmphasis)\n                .on('normal', onNormal);\n        }\n\n        this._updateLabel(data, idx);\n\n        graphic.setHoverStyle(this);\n    };\n\n    piePieceProto._updateLabel = function (data, idx) {\n\n        var labelLine = this.childAt(1);\n        var labelText = this.childAt(2);\n\n        var seriesModel = data.hostModel;\n        var itemModel = data.getItemModel(idx);\n        var layout = data.getItemLayout(idx);\n        var labelLayout = layout.label;\n        var visualColor = data.getItemVisual(idx, 'color');\n\n        graphic.updateProps(labelLine, {\n            shape: {\n                points: labelLayout.linePoints || [\n                    [labelLayout.x, labelLayout.y], [labelLayout.x, labelLayout.y], [labelLayout.x, labelLayout.y]\n                ]\n            }\n        }, seriesModel, idx);\n\n        graphic.updateProps(labelText, {\n            style: {\n                x: labelLayout.x,\n                y: labelLayout.y\n            }\n        }, seriesModel, idx);\n        labelText.attr({\n            style: {\n                textVerticalAlign: labelLayout.verticalAlign,\n                textAlign: labelLayout.textAlign,\n                textFont: labelLayout.font\n            },\n            rotation: labelLayout.rotation,\n            origin: [labelLayout.x, labelLayout.y],\n            z2: 10\n        });\n\n        var labelModel = itemModel.getModel('label.normal');\n        var labelHoverModel = itemModel.getModel('label.emphasis');\n        var labelLineModel = itemModel.getModel('labelLine.normal');\n        var labelLineHoverModel = itemModel.getModel('labelLine.emphasis');\n        var labelPosition = labelModel.get('position') || labelHoverModel.get('position');\n\n        labelText.setStyle(getLabelStyle(data, idx, 'normal', labelModel, labelPosition));\n\n        labelText.ignore = labelText.normalIgnore = !labelModel.get('show');\n        labelText.hoverIgnore = !labelHoverModel.get('show');\n\n        labelLine.ignore = labelLine.normalIgnore = !labelLineModel.get('show');\n        labelLine.hoverIgnore = !labelLineHoverModel.get('show');\n\n        // Default use item visual color\n        labelLine.setStyle({\n            stroke: visualColor,\n            opacity: data.getItemVisual(idx, 'opacity')\n        });\n        labelLine.setStyle(labelLineModel.getModel('lineStyle').getLineStyle());\n\n        labelText.hoverStyle = getLabelStyle(data, idx, 'emphasis', labelHoverModel, labelPosition);\n        labelLine.hoverStyle = labelLineHoverModel.getModel('lineStyle').getLineStyle();\n\n        var smooth = labelLineModel.get('smooth');\n        if (smooth && smooth === true) {\n            smooth = 0.4;\n        }\n        labelLine.setShape({\n            smooth: smooth\n        });\n    };\n\n    zrUtil.inherits(PiePiece, graphic.Group);\n\n\n    // Pie view\n    var Pie = __webpack_require__(/*! ../../view/Chart */ 29).extend({\n\n        type: 'pie',\n\n        init: function () {\n            var sectorGroup = new graphic.Group();\n            this._sectorGroup = sectorGroup;\n        },\n\n        render: function (seriesModel, ecModel, api, payload) {\n            if (payload && (payload.from === this.uid)) {\n                return;\n            }\n\n            var data = seriesModel.getData();\n            var oldData = this._data;\n            var group = this.group;\n\n            var hasAnimation = ecModel.get('animation');\n            var isFirstRender = !oldData;\n            var animationType = seriesModel.get('animationType');\n\n            var onSectorClick = zrUtil.curry(\n                updateDataSelected, this.uid, seriesModel, hasAnimation, api\n            );\n\n            var selectedMode = seriesModel.get('selectedMode');\n\n            data.diff(oldData)\n                .add(function (idx) {\n                    var piePiece = new PiePiece(data, idx);\n                    // Default expansion animation\n                    if (isFirstRender && animationType !== 'scale') {\n                        piePiece.eachChild(function (child) {\n                            child.stopAnimation(true);\n                        });\n                    }\n\n                    selectedMode && piePiece.on('click', onSectorClick);\n\n                    data.setItemGraphicEl(idx, piePiece);\n\n                    group.add(piePiece);\n                })\n                .update(function (newIdx, oldIdx) {\n                    var piePiece = oldData.getItemGraphicEl(oldIdx);\n\n                    piePiece.updateData(data, newIdx);\n\n                    piePiece.off('click');\n                    selectedMode && piePiece.on('click', onSectorClick);\n                    group.add(piePiece);\n                    data.setItemGraphicEl(newIdx, piePiece);\n                })\n                .remove(function (idx) {\n                    var piePiece = oldData.getItemGraphicEl(idx);\n                    group.remove(piePiece);\n                })\n                .execute();\n\n            if (\n                hasAnimation && isFirstRender && data.count() > 0\n                // Default expansion animation\n                && animationType !== 'scale'\n            ) {\n                var shape = data.getItemLayout(0);\n                var r = Math.max(api.getWidth(), api.getHeight()) / 2;\n\n                var removeClipPath = zrUtil.bind(group.removeClipPath, group);\n                group.setClipPath(this._createClipPath(\n                    shape.cx, shape.cy, r, shape.startAngle, shape.clockwise, removeClipPath, seriesModel\n                ));\n            }\n\n            this._data = data;\n        },\n\n        dispose: function () {},\n\n        _createClipPath: function (\n            cx, cy, r, startAngle, clockwise, cb, seriesModel\n        ) {\n            var clipPath = new graphic.Sector({\n                shape: {\n                    cx: cx,\n                    cy: cy,\n                    r0: 0,\n                    r: r,\n                    startAngle: startAngle,\n                    endAngle: startAngle,\n                    clockwise: clockwise\n                }\n            });\n\n            graphic.initProps(clipPath, {\n                shape: {\n                    endAngle: startAngle + (clockwise ? 1 : -1) * Math.PI * 2\n                }\n            }, seriesModel, cb);\n\n            return clipPath;\n        },\n\n        /**\n         * @implement\n         */\n        containPoint: function (point, seriesModel) {\n            var data = seriesModel.getData();\n            var itemLayout = data.getItemLayout(0);\n            if (itemLayout) {\n                var dx = point[0] - itemLayout.cx;\n                var dy = point[1] - itemLayout.cy;\n                var radius = Math.sqrt(dx * dx + dy * dy);\n                return radius <= itemLayout.r && radius >= itemLayout.r0;\n            }\n        }\n\n    });\n\n    module.exports = Pie;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2NoYXJ0L3BpZS9QaWVWaWV3LmpzPzY1MTUiXSwic291cmNlc0NvbnRlbnQiOlsiXG5cbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvZ3JhcGhpYycpO1xuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvU2VyaWVzfSBzZXJpZXNNb2RlbFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaGFzQW5pbWF0aW9uXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gdXBkYXRlRGF0YVNlbGVjdGVkKHVpZCwgc2VyaWVzTW9kZWwsIGhhc0FuaW1hdGlvbiwgYXBpKSB7XG4gICAgICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgICAgICB2YXIgZGF0YUluZGV4ID0gdGhpcy5kYXRhSW5kZXg7XG4gICAgICAgIHZhciBuYW1lID0gZGF0YS5nZXROYW1lKGRhdGFJbmRleCk7XG4gICAgICAgIHZhciBzZWxlY3RlZE9mZnNldCA9IHNlcmllc01vZGVsLmdldCgnc2VsZWN0ZWRPZmZzZXQnKTtcblxuICAgICAgICBhcGkuZGlzcGF0Y2hBY3Rpb24oe1xuICAgICAgICAgICAgdHlwZTogJ3BpZVRvZ2dsZVNlbGVjdCcsXG4gICAgICAgICAgICBmcm9tOiB1aWQsXG4gICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgc2VyaWVzSWQ6IHNlcmllc01vZGVsLmlkXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGRhdGEuZWFjaChmdW5jdGlvbiAoaWR4KSB7XG4gICAgICAgICAgICB0b2dnbGVJdGVtU2VsZWN0ZWQoXG4gICAgICAgICAgICAgICAgZGF0YS5nZXRJdGVtR3JhcGhpY0VsKGlkeCksXG4gICAgICAgICAgICAgICAgZGF0YS5nZXRJdGVtTGF5b3V0KGlkeCksXG4gICAgICAgICAgICAgICAgc2VyaWVzTW9kZWwuaXNTZWxlY3RlZChkYXRhLmdldE5hbWUoaWR4KSksXG4gICAgICAgICAgICAgICAgc2VsZWN0ZWRPZmZzZXQsXG4gICAgICAgICAgICAgICAgaGFzQW5pbWF0aW9uXG4gICAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2dyYXBoaWMvU2VjdG9yfSBlbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBsYXlvdXRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzU2VsZWN0ZWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2VsZWN0ZWRPZmZzZXRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhhc0FuaW1hdGlvblxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvZ2dsZUl0ZW1TZWxlY3RlZChlbCwgbGF5b3V0LCBpc1NlbGVjdGVkLCBzZWxlY3RlZE9mZnNldCwgaGFzQW5pbWF0aW9uKSB7XG4gICAgICAgIHZhciBtaWRBbmdsZSA9IChsYXlvdXQuc3RhcnRBbmdsZSArIGxheW91dC5lbmRBbmdsZSkgLyAyO1xuXG4gICAgICAgIHZhciBkeCA9IE1hdGguY29zKG1pZEFuZ2xlKTtcbiAgICAgICAgdmFyIGR5ID0gTWF0aC5zaW4obWlkQW5nbGUpO1xuXG4gICAgICAgIHZhciBvZmZzZXQgPSBpc1NlbGVjdGVkID8gc2VsZWN0ZWRPZmZzZXQgOiAwO1xuICAgICAgICB2YXIgcG9zaXRpb24gPSBbZHggKiBvZmZzZXQsIGR5ICogb2Zmc2V0XTtcblxuICAgICAgICBoYXNBbmltYXRpb25cbiAgICAgICAgICAgIC8vIGFuaW1hdGVUbyB3aWxsIHN0b3AgcmV2aW91cyBhbmltYXRpb24gbGlrZSB1cGRhdGUgdHJhbnNpdGlvblxuICAgICAgICAgICAgPyBlbC5hbmltYXRlKClcbiAgICAgICAgICAgICAgICAud2hlbigyMDAsIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuc3RhcnQoJ2JvdW5jZU91dCcpXG4gICAgICAgICAgICA6IGVsLmF0dHIoJ3Bvc2l0aW9uJywgcG9zaXRpb24pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBpZWNlIG9mIHBpZSBpbmNsdWRpbmcgU2VjdG9yLCBMYWJlbCwgTGFiZWxMaW5lXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGV4dGVuZHMge21vZHVsZTp6cmVuZGVyL2dyYXBoaWMvR3JvdXB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gUGllUGllY2UoZGF0YSwgaWR4KSB7XG5cbiAgICAgICAgZ3JhcGhpYy5Hcm91cC5jYWxsKHRoaXMpO1xuXG4gICAgICAgIHZhciBzZWN0b3IgPSBuZXcgZ3JhcGhpYy5TZWN0b3Ioe1xuICAgICAgICAgICAgejI6IDJcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBwb2x5bGluZSA9IG5ldyBncmFwaGljLlBvbHlsaW5lKCk7XG4gICAgICAgIHZhciB0ZXh0ID0gbmV3IGdyYXBoaWMuVGV4dCgpO1xuICAgICAgICB0aGlzLmFkZChzZWN0b3IpO1xuICAgICAgICB0aGlzLmFkZChwb2x5bGluZSk7XG4gICAgICAgIHRoaXMuYWRkKHRleHQpO1xuXG4gICAgICAgIHRoaXMudXBkYXRlRGF0YShkYXRhLCBpZHgsIHRydWUpO1xuXG4gICAgICAgIC8vIEhvdmVyIHRvIGNoYW5nZSBsYWJlbCBhbmQgbGFiZWxMaW5lXG4gICAgICAgIGZ1bmN0aW9uIG9uRW1waGFzaXMoKSB7XG4gICAgICAgICAgICBwb2x5bGluZS5pZ25vcmUgPSBwb2x5bGluZS5ob3Zlcklnbm9yZTtcbiAgICAgICAgICAgIHRleHQuaWdub3JlID0gdGV4dC5ob3Zlcklnbm9yZTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBvbk5vcm1hbCgpIHtcbiAgICAgICAgICAgIHBvbHlsaW5lLmlnbm9yZSA9IHBvbHlsaW5lLm5vcm1hbElnbm9yZTtcbiAgICAgICAgICAgIHRleHQuaWdub3JlID0gdGV4dC5ub3JtYWxJZ25vcmU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vbignZW1waGFzaXMnLCBvbkVtcGhhc2lzKVxuICAgICAgICAgICAgLm9uKCdub3JtYWwnLCBvbk5vcm1hbClcbiAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgb25FbXBoYXNpcylcbiAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBvbk5vcm1hbCk7XG4gICAgfVxuXG4gICAgdmFyIHBpZVBpZWNlUHJvdG8gPSBQaWVQaWVjZS5wcm90b3R5cGU7XG5cbiAgICBmdW5jdGlvbiBnZXRMYWJlbFN0eWxlKGRhdGEsIGlkeCwgc3RhdGUsIGxhYmVsTW9kZWwsIGxhYmVsUG9zaXRpb24pIHtcbiAgICAgICAgdmFyIHRleHRTdHlsZU1vZGVsID0gbGFiZWxNb2RlbC5nZXRNb2RlbCgndGV4dFN0eWxlJyk7XG4gICAgICAgIHZhciBpc0xhYmVsSW5zaWRlID0gbGFiZWxQb3NpdGlvbiA9PT0gJ2luc2lkZScgfHwgbGFiZWxQb3NpdGlvbiA9PT0gJ2lubmVyJztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZpbGw6IHRleHRTdHlsZU1vZGVsLmdldFRleHRDb2xvcigpXG4gICAgICAgICAgICAgICAgfHwgKGlzTGFiZWxJbnNpZGUgPyAnI2ZmZicgOiBkYXRhLmdldEl0ZW1WaXN1YWwoaWR4LCAnY29sb3InKSksXG4gICAgICAgICAgICBvcGFjaXR5OiBkYXRhLmdldEl0ZW1WaXN1YWwoaWR4LCAnb3BhY2l0eScpLFxuICAgICAgICAgICAgdGV4dEZvbnQ6IHRleHRTdHlsZU1vZGVsLmdldEZvbnQoKSxcbiAgICAgICAgICAgIHRleHQ6IHpyVXRpbC5yZXRyaWV2ZShcbiAgICAgICAgICAgICAgICBkYXRhLmhvc3RNb2RlbC5nZXRGb3JtYXR0ZWRMYWJlbChpZHgsIHN0YXRlKSwgZGF0YS5nZXROYW1lKGlkeClcbiAgICAgICAgICAgIClcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBwaWVQaWVjZVByb3RvLnVwZGF0ZURhdGEgPSBmdW5jdGlvbiAoZGF0YSwgaWR4LCBmaXJzdENyZWF0ZSkge1xuXG4gICAgICAgIHZhciBzZWN0b3IgPSB0aGlzLmNoaWxkQXQoMCk7XG5cbiAgICAgICAgdmFyIHNlcmllc01vZGVsID0gZGF0YS5ob3N0TW9kZWw7XG4gICAgICAgIHZhciBpdGVtTW9kZWwgPSBkYXRhLmdldEl0ZW1Nb2RlbChpZHgpO1xuICAgICAgICB2YXIgbGF5b3V0ID0gZGF0YS5nZXRJdGVtTGF5b3V0KGlkeCk7XG4gICAgICAgIHZhciBzZWN0b3JTaGFwZSA9IHpyVXRpbC5leHRlbmQoe30sIGxheW91dCk7XG4gICAgICAgIHNlY3RvclNoYXBlLmxhYmVsID0gbnVsbDtcblxuICAgICAgICBpZiAoZmlyc3RDcmVhdGUpIHtcbiAgICAgICAgICAgIHNlY3Rvci5zZXRTaGFwZShzZWN0b3JTaGFwZSk7XG5cbiAgICAgICAgICAgIHZhciBhbmltYXRpb25UeXBlID0gc2VyaWVzTW9kZWwuZ2V0U2hhbGxvdygnYW5pbWF0aW9uVHlwZScpO1xuICAgICAgICAgICAgaWYgKGFuaW1hdGlvblR5cGUgPT09ICdzY2FsZScpIHtcbiAgICAgICAgICAgICAgICBzZWN0b3Iuc2hhcGUuciA9IGxheW91dC5yMDtcbiAgICAgICAgICAgICAgICBncmFwaGljLmluaXRQcm9wcyhzZWN0b3IsIHtcbiAgICAgICAgICAgICAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHI6IGxheW91dC5yXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBzZXJpZXNNb2RlbCwgaWR4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEV4cGFuc2lvblxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VjdG9yLnNoYXBlLmVuZEFuZ2xlID0gbGF5b3V0LnN0YXJ0QW5nbGU7XG4gICAgICAgICAgICAgICAgZ3JhcGhpYy51cGRhdGVQcm9wcyhzZWN0b3IsIHtcbiAgICAgICAgICAgICAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZEFuZ2xlOiBsYXlvdXQuZW5kQW5nbGVcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIHNlcmllc01vZGVsLCBpZHgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBncmFwaGljLnVwZGF0ZVByb3BzKHNlY3Rvciwge1xuICAgICAgICAgICAgICAgIHNoYXBlOiBzZWN0b3JTaGFwZVxuICAgICAgICAgICAgfSwgc2VyaWVzTW9kZWwsIGlkeCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVcGRhdGUgY29tbW9uIHN0eWxlXG4gICAgICAgIHZhciBpdGVtU3R5bGVNb2RlbCA9IGl0ZW1Nb2RlbC5nZXRNb2RlbCgnaXRlbVN0eWxlJyk7XG4gICAgICAgIHZhciB2aXN1YWxDb2xvciA9IGRhdGEuZ2V0SXRlbVZpc3VhbChpZHgsICdjb2xvcicpO1xuXG4gICAgICAgIHNlY3Rvci51c2VTdHlsZShcbiAgICAgICAgICAgIHpyVXRpbC5kZWZhdWx0cyhcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVKb2luOiAnYmV2ZWwnLFxuICAgICAgICAgICAgICAgICAgICBmaWxsOiB2aXN1YWxDb2xvclxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaXRlbVN0eWxlTW9kZWwuZ2V0TW9kZWwoJ25vcm1hbCcpLmdldEl0ZW1TdHlsZSgpXG4gICAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICAgIHNlY3Rvci5ob3ZlclN0eWxlID0gaXRlbVN0eWxlTW9kZWwuZ2V0TW9kZWwoJ2VtcGhhc2lzJykuZ2V0SXRlbVN0eWxlKCk7XG5cbiAgICAgICAgLy8gVG9nZ2xlIHNlbGVjdGVkXG4gICAgICAgIHRvZ2dsZUl0ZW1TZWxlY3RlZChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICBkYXRhLmdldEl0ZW1MYXlvdXQoaWR4KSxcbiAgICAgICAgICAgIGl0ZW1Nb2RlbC5nZXQoJ3NlbGVjdGVkJyksXG4gICAgICAgICAgICBzZXJpZXNNb2RlbC5nZXQoJ3NlbGVjdGVkT2Zmc2V0JyksXG4gICAgICAgICAgICBzZXJpZXNNb2RlbC5nZXQoJ2FuaW1hdGlvbicpXG4gICAgICAgICk7XG5cbiAgICAgICAgZnVuY3Rpb24gb25FbXBoYXNpcygpIHtcbiAgICAgICAgICAgIC8vIFNlY3RvciBtYXkgaGFzIGFuaW1hdGlvbiBvZiB1cGRhdGluZyBkYXRhLiBGb3JjZSB0byBtb3ZlIHRvIHRoZSBsYXN0IGZyYW1lXG4gICAgICAgICAgICAvLyBPciBpdCBtYXkgc3RvcHBlZCBvbiB0aGUgd3Jvbmcgc2hhcGVcbiAgICAgICAgICAgIHNlY3Rvci5zdG9wQW5pbWF0aW9uKHRydWUpO1xuICAgICAgICAgICAgc2VjdG9yLmFuaW1hdGVUbyh7XG4gICAgICAgICAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgICAgICAgICAgcjogbGF5b3V0LnIgKyAxMFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIDMwMCwgJ2VsYXN0aWNPdXQnKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBvbk5vcm1hbCgpIHtcbiAgICAgICAgICAgIHNlY3Rvci5zdG9wQW5pbWF0aW9uKHRydWUpO1xuICAgICAgICAgICAgc2VjdG9yLmFuaW1hdGVUbyh7XG4gICAgICAgICAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgICAgICAgICAgcjogbGF5b3V0LnJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCAzMDAsICdlbGFzdGljT3V0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgc2VjdG9yLm9mZignbW91c2VvdmVyJykub2ZmKCdtb3VzZW91dCcpLm9mZignZW1waGFzaXMnKS5vZmYoJ25vcm1hbCcpO1xuICAgICAgICBpZiAoaXRlbU1vZGVsLmdldCgnaG92ZXJBbmltYXRpb24nKSAmJiBzZXJpZXNNb2RlbC5pc0FuaW1hdGlvbkVuYWJsZWQoKSkge1xuICAgICAgICAgICAgc2VjdG9yXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBvbkVtcGhhc2lzKVxuICAgICAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBvbk5vcm1hbClcbiAgICAgICAgICAgICAgICAub24oJ2VtcGhhc2lzJywgb25FbXBoYXNpcylcbiAgICAgICAgICAgICAgICAub24oJ25vcm1hbCcsIG9uTm9ybWFsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3VwZGF0ZUxhYmVsKGRhdGEsIGlkeCk7XG5cbiAgICAgICAgZ3JhcGhpYy5zZXRIb3ZlclN0eWxlKHRoaXMpO1xuICAgIH07XG5cbiAgICBwaWVQaWVjZVByb3RvLl91cGRhdGVMYWJlbCA9IGZ1bmN0aW9uIChkYXRhLCBpZHgpIHtcblxuICAgICAgICB2YXIgbGFiZWxMaW5lID0gdGhpcy5jaGlsZEF0KDEpO1xuICAgICAgICB2YXIgbGFiZWxUZXh0ID0gdGhpcy5jaGlsZEF0KDIpO1xuXG4gICAgICAgIHZhciBzZXJpZXNNb2RlbCA9IGRhdGEuaG9zdE1vZGVsO1xuICAgICAgICB2YXIgaXRlbU1vZGVsID0gZGF0YS5nZXRJdGVtTW9kZWwoaWR4KTtcbiAgICAgICAgdmFyIGxheW91dCA9IGRhdGEuZ2V0SXRlbUxheW91dChpZHgpO1xuICAgICAgICB2YXIgbGFiZWxMYXlvdXQgPSBsYXlvdXQubGFiZWw7XG4gICAgICAgIHZhciB2aXN1YWxDb2xvciA9IGRhdGEuZ2V0SXRlbVZpc3VhbChpZHgsICdjb2xvcicpO1xuXG4gICAgICAgIGdyYXBoaWMudXBkYXRlUHJvcHMobGFiZWxMaW5lLCB7XG4gICAgICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgICAgIHBvaW50czogbGFiZWxMYXlvdXQubGluZVBvaW50cyB8fCBbXG4gICAgICAgICAgICAgICAgICAgIFtsYWJlbExheW91dC54LCBsYWJlbExheW91dC55XSwgW2xhYmVsTGF5b3V0LngsIGxhYmVsTGF5b3V0LnldLCBbbGFiZWxMYXlvdXQueCwgbGFiZWxMYXlvdXQueV1cbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHNlcmllc01vZGVsLCBpZHgpO1xuXG4gICAgICAgIGdyYXBoaWMudXBkYXRlUHJvcHMobGFiZWxUZXh0LCB7XG4gICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgIHg6IGxhYmVsTGF5b3V0LngsXG4gICAgICAgICAgICAgICAgeTogbGFiZWxMYXlvdXQueVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBzZXJpZXNNb2RlbCwgaWR4KTtcbiAgICAgICAgbGFiZWxUZXh0LmF0dHIoe1xuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICB0ZXh0VmVydGljYWxBbGlnbjogbGFiZWxMYXlvdXQudmVydGljYWxBbGlnbixcbiAgICAgICAgICAgICAgICB0ZXh0QWxpZ246IGxhYmVsTGF5b3V0LnRleHRBbGlnbixcbiAgICAgICAgICAgICAgICB0ZXh0Rm9udDogbGFiZWxMYXlvdXQuZm9udFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJvdGF0aW9uOiBsYWJlbExheW91dC5yb3RhdGlvbixcbiAgICAgICAgICAgIG9yaWdpbjogW2xhYmVsTGF5b3V0LngsIGxhYmVsTGF5b3V0LnldLFxuICAgICAgICAgICAgejI6IDEwXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBsYWJlbE1vZGVsID0gaXRlbU1vZGVsLmdldE1vZGVsKCdsYWJlbC5ub3JtYWwnKTtcbiAgICAgICAgdmFyIGxhYmVsSG92ZXJNb2RlbCA9IGl0ZW1Nb2RlbC5nZXRNb2RlbCgnbGFiZWwuZW1waGFzaXMnKTtcbiAgICAgICAgdmFyIGxhYmVsTGluZU1vZGVsID0gaXRlbU1vZGVsLmdldE1vZGVsKCdsYWJlbExpbmUubm9ybWFsJyk7XG4gICAgICAgIHZhciBsYWJlbExpbmVIb3Zlck1vZGVsID0gaXRlbU1vZGVsLmdldE1vZGVsKCdsYWJlbExpbmUuZW1waGFzaXMnKTtcbiAgICAgICAgdmFyIGxhYmVsUG9zaXRpb24gPSBsYWJlbE1vZGVsLmdldCgncG9zaXRpb24nKSB8fCBsYWJlbEhvdmVyTW9kZWwuZ2V0KCdwb3NpdGlvbicpO1xuXG4gICAgICAgIGxhYmVsVGV4dC5zZXRTdHlsZShnZXRMYWJlbFN0eWxlKGRhdGEsIGlkeCwgJ25vcm1hbCcsIGxhYmVsTW9kZWwsIGxhYmVsUG9zaXRpb24pKTtcblxuICAgICAgICBsYWJlbFRleHQuaWdub3JlID0gbGFiZWxUZXh0Lm5vcm1hbElnbm9yZSA9ICFsYWJlbE1vZGVsLmdldCgnc2hvdycpO1xuICAgICAgICBsYWJlbFRleHQuaG92ZXJJZ25vcmUgPSAhbGFiZWxIb3Zlck1vZGVsLmdldCgnc2hvdycpO1xuXG4gICAgICAgIGxhYmVsTGluZS5pZ25vcmUgPSBsYWJlbExpbmUubm9ybWFsSWdub3JlID0gIWxhYmVsTGluZU1vZGVsLmdldCgnc2hvdycpO1xuICAgICAgICBsYWJlbExpbmUuaG92ZXJJZ25vcmUgPSAhbGFiZWxMaW5lSG92ZXJNb2RlbC5nZXQoJ3Nob3cnKTtcblxuICAgICAgICAvLyBEZWZhdWx0IHVzZSBpdGVtIHZpc3VhbCBjb2xvclxuICAgICAgICBsYWJlbExpbmUuc2V0U3R5bGUoe1xuICAgICAgICAgICAgc3Ryb2tlOiB2aXN1YWxDb2xvcixcbiAgICAgICAgICAgIG9wYWNpdHk6IGRhdGEuZ2V0SXRlbVZpc3VhbChpZHgsICdvcGFjaXR5JylcbiAgICAgICAgfSk7XG4gICAgICAgIGxhYmVsTGluZS5zZXRTdHlsZShsYWJlbExpbmVNb2RlbC5nZXRNb2RlbCgnbGluZVN0eWxlJykuZ2V0TGluZVN0eWxlKCkpO1xuXG4gICAgICAgIGxhYmVsVGV4dC5ob3ZlclN0eWxlID0gZ2V0TGFiZWxTdHlsZShkYXRhLCBpZHgsICdlbXBoYXNpcycsIGxhYmVsSG92ZXJNb2RlbCwgbGFiZWxQb3NpdGlvbik7XG4gICAgICAgIGxhYmVsTGluZS5ob3ZlclN0eWxlID0gbGFiZWxMaW5lSG92ZXJNb2RlbC5nZXRNb2RlbCgnbGluZVN0eWxlJykuZ2V0TGluZVN0eWxlKCk7XG5cbiAgICAgICAgdmFyIHNtb290aCA9IGxhYmVsTGluZU1vZGVsLmdldCgnc21vb3RoJyk7XG4gICAgICAgIGlmIChzbW9vdGggJiYgc21vb3RoID09PSB0cnVlKSB7XG4gICAgICAgICAgICBzbW9vdGggPSAwLjQ7XG4gICAgICAgIH1cbiAgICAgICAgbGFiZWxMaW5lLnNldFNoYXBlKHtcbiAgICAgICAgICAgIHNtb290aDogc21vb3RoXG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICB6clV0aWwuaW5oZXJpdHMoUGllUGllY2UsIGdyYXBoaWMuR3JvdXApO1xuXG5cbiAgICAvLyBQaWUgdmlld1xuICAgIHZhciBQaWUgPSByZXF1aXJlKCcuLi8uLi92aWV3L0NoYXJ0JykuZXh0ZW5kKHtcblxuICAgICAgICB0eXBlOiAncGllJyxcblxuICAgICAgICBpbml0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc2VjdG9yR3JvdXAgPSBuZXcgZ3JhcGhpYy5Hcm91cCgpO1xuICAgICAgICAgICAgdGhpcy5fc2VjdG9yR3JvdXAgPSBzZWN0b3JHcm91cDtcbiAgICAgICAgfSxcblxuICAgICAgICByZW5kZXI6IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKSB7XG4gICAgICAgICAgICBpZiAocGF5bG9hZCAmJiAocGF5bG9hZC5mcm9tID09PSB0aGlzLnVpZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgICAgICAgICAgdmFyIG9sZERhdGEgPSB0aGlzLl9kYXRhO1xuICAgICAgICAgICAgdmFyIGdyb3VwID0gdGhpcy5ncm91cDtcblxuICAgICAgICAgICAgdmFyIGhhc0FuaW1hdGlvbiA9IGVjTW9kZWwuZ2V0KCdhbmltYXRpb24nKTtcbiAgICAgICAgICAgIHZhciBpc0ZpcnN0UmVuZGVyID0gIW9sZERhdGE7XG4gICAgICAgICAgICB2YXIgYW5pbWF0aW9uVHlwZSA9IHNlcmllc01vZGVsLmdldCgnYW5pbWF0aW9uVHlwZScpO1xuXG4gICAgICAgICAgICB2YXIgb25TZWN0b3JDbGljayA9IHpyVXRpbC5jdXJyeShcbiAgICAgICAgICAgICAgICB1cGRhdGVEYXRhU2VsZWN0ZWQsIHRoaXMudWlkLCBzZXJpZXNNb2RlbCwgaGFzQW5pbWF0aW9uLCBhcGlcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHZhciBzZWxlY3RlZE1vZGUgPSBzZXJpZXNNb2RlbC5nZXQoJ3NlbGVjdGVkTW9kZScpO1xuXG4gICAgICAgICAgICBkYXRhLmRpZmYob2xkRGF0YSlcbiAgICAgICAgICAgICAgICAuYWRkKGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBpZVBpZWNlID0gbmV3IFBpZVBpZWNlKGRhdGEsIGlkeCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIERlZmF1bHQgZXhwYW5zaW9uIGFuaW1hdGlvblxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNGaXJzdFJlbmRlciAmJiBhbmltYXRpb25UeXBlICE9PSAnc2NhbGUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwaWVQaWVjZS5lYWNoQ2hpbGQoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQuc3RvcEFuaW1hdGlvbih0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRNb2RlICYmIHBpZVBpZWNlLm9uKCdjbGljaycsIG9uU2VjdG9yQ2xpY2spO1xuXG4gICAgICAgICAgICAgICAgICAgIGRhdGEuc2V0SXRlbUdyYXBoaWNFbChpZHgsIHBpZVBpZWNlKTtcblxuICAgICAgICAgICAgICAgICAgICBncm91cC5hZGQocGllUGllY2UpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnVwZGF0ZShmdW5jdGlvbiAobmV3SWR4LCBvbGRJZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBpZVBpZWNlID0gb2xkRGF0YS5nZXRJdGVtR3JhcGhpY0VsKG9sZElkeCk7XG5cbiAgICAgICAgICAgICAgICAgICAgcGllUGllY2UudXBkYXRlRGF0YShkYXRhLCBuZXdJZHgpO1xuXG4gICAgICAgICAgICAgICAgICAgIHBpZVBpZWNlLm9mZignY2xpY2snKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRNb2RlICYmIHBpZVBpZWNlLm9uKCdjbGljaycsIG9uU2VjdG9yQ2xpY2spO1xuICAgICAgICAgICAgICAgICAgICBncm91cC5hZGQocGllUGllY2UpO1xuICAgICAgICAgICAgICAgICAgICBkYXRhLnNldEl0ZW1HcmFwaGljRWwobmV3SWR4LCBwaWVQaWVjZSk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAucmVtb3ZlKGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBpZVBpZWNlID0gb2xkRGF0YS5nZXRJdGVtR3JhcGhpY0VsKGlkeCk7XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwLnJlbW92ZShwaWVQaWVjZSk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuZXhlY3V0ZSgpO1xuXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgaGFzQW5pbWF0aW9uICYmIGlzRmlyc3RSZW5kZXIgJiYgZGF0YS5jb3VudCgpID4gMFxuICAgICAgICAgICAgICAgIC8vIERlZmF1bHQgZXhwYW5zaW9uIGFuaW1hdGlvblxuICAgICAgICAgICAgICAgICYmIGFuaW1hdGlvblR5cGUgIT09ICdzY2FsZSdcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHZhciBzaGFwZSA9IGRhdGEuZ2V0SXRlbUxheW91dCgwKTtcbiAgICAgICAgICAgICAgICB2YXIgciA9IE1hdGgubWF4KGFwaS5nZXRXaWR0aCgpLCBhcGkuZ2V0SGVpZ2h0KCkpIC8gMjtcblxuICAgICAgICAgICAgICAgIHZhciByZW1vdmVDbGlwUGF0aCA9IHpyVXRpbC5iaW5kKGdyb3VwLnJlbW92ZUNsaXBQYXRoLCBncm91cCk7XG4gICAgICAgICAgICAgICAgZ3JvdXAuc2V0Q2xpcFBhdGgodGhpcy5fY3JlYXRlQ2xpcFBhdGgoXG4gICAgICAgICAgICAgICAgICAgIHNoYXBlLmN4LCBzaGFwZS5jeSwgciwgc2hhcGUuc3RhcnRBbmdsZSwgc2hhcGUuY2xvY2t3aXNlLCByZW1vdmVDbGlwUGF0aCwgc2VyaWVzTW9kZWxcbiAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fZGF0YSA9IGRhdGE7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGlzcG9zZTogZnVuY3Rpb24gKCkge30sXG5cbiAgICAgICAgX2NyZWF0ZUNsaXBQYXRoOiBmdW5jdGlvbiAoXG4gICAgICAgICAgICBjeCwgY3ksIHIsIHN0YXJ0QW5nbGUsIGNsb2Nrd2lzZSwgY2IsIHNlcmllc01vZGVsXG4gICAgICAgICkge1xuICAgICAgICAgICAgdmFyIGNsaXBQYXRoID0gbmV3IGdyYXBoaWMuU2VjdG9yKHtcbiAgICAgICAgICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgICAgICAgICBjeDogY3gsXG4gICAgICAgICAgICAgICAgICAgIGN5OiBjeSxcbiAgICAgICAgICAgICAgICAgICAgcjA6IDAsXG4gICAgICAgICAgICAgICAgICAgIHI6IHIsXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0QW5nbGU6IHN0YXJ0QW5nbGUsXG4gICAgICAgICAgICAgICAgICAgIGVuZEFuZ2xlOiBzdGFydEFuZ2xlLFxuICAgICAgICAgICAgICAgICAgICBjbG9ja3dpc2U6IGNsb2Nrd2lzZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBncmFwaGljLmluaXRQcm9wcyhjbGlwUGF0aCwge1xuICAgICAgICAgICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgICAgICAgICAgIGVuZEFuZ2xlOiBzdGFydEFuZ2xlICsgKGNsb2Nrd2lzZSA/IDEgOiAtMSkgKiBNYXRoLlBJICogMlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHNlcmllc01vZGVsLCBjYik7XG5cbiAgICAgICAgICAgIHJldHVybiBjbGlwUGF0aDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQGltcGxlbWVudFxuICAgICAgICAgKi9cbiAgICAgICAgY29udGFpblBvaW50OiBmdW5jdGlvbiAocG9pbnQsIHNlcmllc01vZGVsKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICAgICAgICAgIHZhciBpdGVtTGF5b3V0ID0gZGF0YS5nZXRJdGVtTGF5b3V0KDApO1xuICAgICAgICAgICAgaWYgKGl0ZW1MYXlvdXQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZHggPSBwb2ludFswXSAtIGl0ZW1MYXlvdXQuY3g7XG4gICAgICAgICAgICAgICAgdmFyIGR5ID0gcG9pbnRbMV0gLSBpdGVtTGF5b3V0LmN5O1xuICAgICAgICAgICAgICAgIHZhciByYWRpdXMgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgICAgICAgICAgICAgIHJldHVybiByYWRpdXMgPD0gaXRlbUxheW91dC5yICYmIHJhZGl1cyA+PSBpdGVtTGF5b3V0LnIwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9KTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gUGllO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvY2hhcnQvcGllL1BpZVZpZXcuanNcbi8vIG1vZHVsZSBpZCA9IDE0M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 144 */
/* unknown exports provided */
/* all exports used */
/*!**************************************!*\
  !*** ./lib/chart/pie/labelLayout.js ***!
  \**************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n// FIXME emphasis label position is not same with normal label position\n\n\n    var textContain = __webpack_require__(/*! zrender/lib/contain/text */ 15);\n\n    function adjustSingleSide(list, cx, cy, r, dir, viewWidth, viewHeight) {\n        list.sort(function (a, b) {\n            return a.y - b.y;\n        });\n\n        // 压\n        function shiftDown(start, end, delta, dir) {\n            for (var j = start; j < end; j++) {\n                list[j].y += delta;\n                if (j > start\n                    && j + 1 < end\n                    && list[j + 1].y > list[j].y + list[j].height\n                ) {\n                    shiftUp(j, delta / 2);\n                    return;\n                }\n            }\n\n            shiftUp(end - 1, delta / 2);\n        }\n\n        // 弹\n        function shiftUp(end, delta) {\n            for (var j = end; j >= 0; j--) {\n                list[j].y -= delta;\n                if (j > 0\n                    && list[j].y > list[j - 1].y + list[j - 1].height\n                ) {\n                    break;\n                }\n            }\n        }\n\n        function changeX(list, isDownList, cx, cy, r, dir) {\n            var lastDeltaX = dir > 0\n                ? isDownList                // 右侧\n                    ? Number.MAX_VALUE      // 下\n                    : 0                     // 上\n                : isDownList                // 左侧\n                    ? Number.MAX_VALUE      // 下\n                    : 0;                    // 上\n\n            for (var i = 0, l = list.length; i < l; i++) {\n                // Not change x for center label\n                if (list[i].position === 'center') {\n                    continue;\n                }\n                var deltaY = Math.abs(list[i].y - cy);\n                var length = list[i].len;\n                var length2 = list[i].len2;\n                var deltaX = (deltaY < r + length)\n                    ? Math.sqrt(\n                          (r + length + length2) * (r + length + length2)\n                          - deltaY * deltaY\n                      )\n                    : Math.abs(list[i].x - cx);\n                if (isDownList && deltaX >= lastDeltaX) {\n                    // 右下，左下\n                    deltaX = lastDeltaX - 10;\n                }\n                if (!isDownList && deltaX <= lastDeltaX) {\n                    // 右上，左上\n                    deltaX = lastDeltaX + 10;\n                }\n\n                list[i].x = cx + deltaX * dir;\n                lastDeltaX = deltaX;\n            }\n        }\n\n        var lastY = 0;\n        var delta;\n        var len = list.length;\n        var upList = [];\n        var downList = [];\n        for (var i = 0; i < len; i++) {\n            delta = list[i].y - lastY;\n            if (delta < 0) {\n                shiftDown(i, len, -delta, dir);\n            }\n            lastY = list[i].y + list[i].height;\n        }\n        if (viewHeight - lastY < 0) {\n            shiftUp(len - 1, lastY - viewHeight);\n        }\n        for (var i = 0; i < len; i++) {\n            if (list[i].y >= cy) {\n                downList.push(list[i]);\n            }\n            else {\n                upList.push(list[i]);\n            }\n        }\n        changeX(upList, false, cx, cy, r, dir);\n        changeX(downList, true, cx, cy, r, dir);\n    }\n\n    function avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight) {\n        var leftList = [];\n        var rightList = [];\n        for (var i = 0; i < labelLayoutList.length; i++) {\n            if (labelLayoutList[i].x < cx) {\n                leftList.push(labelLayoutList[i]);\n            }\n            else {\n                rightList.push(labelLayoutList[i]);\n            }\n        }\n\n        adjustSingleSide(rightList, cx, cy, r, 1, viewWidth, viewHeight);\n        adjustSingleSide(leftList, cx, cy, r, -1, viewWidth, viewHeight);\n\n        for (var i = 0; i < labelLayoutList.length; i++) {\n            var linePoints = labelLayoutList[i].linePoints;\n            if (linePoints) {\n                var dist = linePoints[1][0] - linePoints[2][0];\n                if (labelLayoutList[i].x < cx) {\n                    linePoints[2][0] = labelLayoutList[i].x + 3;\n                }\n                else {\n                    linePoints[2][0] = labelLayoutList[i].x - 3;\n                }\n                linePoints[1][1] = linePoints[2][1] = labelLayoutList[i].y;\n                linePoints[1][0] = linePoints[2][0] + dist;\n            }\n        }\n    }\n\n    module.exports = function (seriesModel, r, viewWidth, viewHeight) {\n        var data = seriesModel.getData();\n        var labelLayoutList = [];\n        var cx;\n        var cy;\n        var hasLabelRotate = false;\n\n        data.each(function (idx) {\n            var layout = data.getItemLayout(idx);\n\n            var itemModel = data.getItemModel(idx);\n            var labelModel = itemModel.getModel('label.normal');\n            // Use position in normal or emphasis\n            var labelPosition = labelModel.get('position') || itemModel.get('label.emphasis.position');\n\n            var labelLineModel = itemModel.getModel('labelLine.normal');\n            var labelLineLen = labelLineModel.get('length');\n            var labelLineLen2 = labelLineModel.get('length2');\n\n            var midAngle = (layout.startAngle + layout.endAngle) / 2;\n            var dx = Math.cos(midAngle);\n            var dy = Math.sin(midAngle);\n\n            var textX;\n            var textY;\n            var linePoints;\n            var textAlign;\n\n            cx = layout.cx;\n            cy = layout.cy;\n\n            var isLabelInside = labelPosition === 'inside' || labelPosition === 'inner';\n            if (labelPosition === 'center') {\n                textX = layout.cx;\n                textY = layout.cy;\n                textAlign = 'center';\n            }\n            else {\n                var x1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dx : layout.r * dx) + cx;\n                var y1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dy : layout.r * dy) + cy;\n\n                textX = x1 + dx * 3;\n                textY = y1 + dy * 3;\n\n                if (!isLabelInside) {\n                    // For roseType\n                    var x2 = x1 + dx * (labelLineLen + r - layout.r);\n                    var y2 = y1 + dy * (labelLineLen + r - layout.r);\n                    var x3 = x2 + ((dx < 0 ? -1 : 1) * labelLineLen2);\n                    var y3 = y2;\n\n                    textX = x3 + (dx < 0 ? -5 : 5);\n                    textY = y3;\n                    linePoints = [[x1, y1], [x2, y2], [x3, y3]];\n                }\n\n                textAlign = isLabelInside ? 'center' : (dx > 0 ? 'left' : 'right');\n            }\n            var font = labelModel.getModel('textStyle').getFont();\n\n            var labelRotate = labelModel.get('rotate')\n                ? (dx < 0 ? -midAngle + Math.PI : -midAngle) : 0;\n            var text = seriesModel.getFormattedLabel(idx, 'normal')\n                        || data.getName(idx);\n            var textRect = textContain.getBoundingRect(\n                text, font, textAlign, 'top'\n            );\n            hasLabelRotate = !!labelRotate;\n            layout.label = {\n                x: textX,\n                y: textY,\n                position: labelPosition,\n                height: textRect.height,\n                len: labelLineLen,\n                len2: labelLineLen2,\n                linePoints: linePoints,\n                textAlign: textAlign,\n                verticalAlign: 'middle',\n                font: font,\n                rotation: labelRotate\n            };\n\n            // Not layout the inside label\n            if (!isLabelInside) {\n                labelLayoutList.push(layout.label);\n            }\n        });\n        if (!hasLabelRotate && seriesModel.get('avoidLabelOverlap')) {\n            avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight);\n        }\n    };\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQ0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2NoYXJ0L3BpZS9sYWJlbExheW91dC5qcz9jMzhiIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbi8vIEZJWE1FIGVtcGhhc2lzIGxhYmVsIHBvc2l0aW9uIGlzIG5vdCBzYW1lIHdpdGggbm9ybWFsIGxhYmVsIHBvc2l0aW9uXG5cblxuICAgIHZhciB0ZXh0Q29udGFpbiA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvbnRhaW4vdGV4dCcpO1xuXG4gICAgZnVuY3Rpb24gYWRqdXN0U2luZ2xlU2lkZShsaXN0LCBjeCwgY3ksIHIsIGRpciwgdmlld1dpZHRoLCB2aWV3SGVpZ2h0KSB7XG4gICAgICAgIGxpc3Quc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGEueSAtIGIueTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8g5Y6LXG4gICAgICAgIGZ1bmN0aW9uIHNoaWZ0RG93bihzdGFydCwgZW5kLCBkZWx0YSwgZGlyKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gc3RhcnQ7IGogPCBlbmQ7IGorKykge1xuICAgICAgICAgICAgICAgIGxpc3Rbal0ueSArPSBkZWx0YTtcbiAgICAgICAgICAgICAgICBpZiAoaiA+IHN0YXJ0XG4gICAgICAgICAgICAgICAgICAgICYmIGogKyAxIDwgZW5kXG4gICAgICAgICAgICAgICAgICAgICYmIGxpc3RbaiArIDFdLnkgPiBsaXN0W2pdLnkgKyBsaXN0W2pdLmhlaWdodFxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBzaGlmdFVwKGosIGRlbHRhIC8gMik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNoaWZ0VXAoZW5kIC0gMSwgZGVsdGEgLyAyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIOW8uVxuICAgICAgICBmdW5jdGlvbiBzaGlmdFVwKGVuZCwgZGVsdGEpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSBlbmQ7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgICAgICAgbGlzdFtqXS55IC09IGRlbHRhO1xuICAgICAgICAgICAgICAgIGlmIChqID4gMFxuICAgICAgICAgICAgICAgICAgICAmJiBsaXN0W2pdLnkgPiBsaXN0W2ogLSAxXS55ICsgbGlzdFtqIC0gMV0uaGVpZ2h0XG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGNoYW5nZVgobGlzdCwgaXNEb3duTGlzdCwgY3gsIGN5LCByLCBkaXIpIHtcbiAgICAgICAgICAgIHZhciBsYXN0RGVsdGFYID0gZGlyID4gMFxuICAgICAgICAgICAgICAgID8gaXNEb3duTGlzdCAgICAgICAgICAgICAgICAvLyDlj7PkvqdcbiAgICAgICAgICAgICAgICAgICAgPyBOdW1iZXIuTUFYX1ZBTFVFICAgICAgLy8g5LiLXG4gICAgICAgICAgICAgICAgICAgIDogMCAgICAgICAgICAgICAgICAgICAgIC8vIOS4ilxuICAgICAgICAgICAgICAgIDogaXNEb3duTGlzdCAgICAgICAgICAgICAgICAvLyDlt6bkvqdcbiAgICAgICAgICAgICAgICAgICAgPyBOdW1iZXIuTUFYX1ZBTFVFICAgICAgLy8g5LiLXG4gICAgICAgICAgICAgICAgICAgIDogMDsgICAgICAgICAgICAgICAgICAgIC8vIOS4ilxuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgLy8gTm90IGNoYW5nZSB4IGZvciBjZW50ZXIgbGFiZWxcbiAgICAgICAgICAgICAgICBpZiAobGlzdFtpXS5wb3NpdGlvbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBkZWx0YVkgPSBNYXRoLmFicyhsaXN0W2ldLnkgLSBjeSk7XG4gICAgICAgICAgICAgICAgdmFyIGxlbmd0aCA9IGxpc3RbaV0ubGVuO1xuICAgICAgICAgICAgICAgIHZhciBsZW5ndGgyID0gbGlzdFtpXS5sZW4yO1xuICAgICAgICAgICAgICAgIHZhciBkZWx0YVggPSAoZGVsdGFZIDwgciArIGxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgPyBNYXRoLnNxcnQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgIChyICsgbGVuZ3RoICsgbGVuZ3RoMikgKiAociArIGxlbmd0aCArIGxlbmd0aDIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC0gZGVsdGFZICogZGVsdGFZXG4gICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICA6IE1hdGguYWJzKGxpc3RbaV0ueCAtIGN4KTtcbiAgICAgICAgICAgICAgICBpZiAoaXNEb3duTGlzdCAmJiBkZWx0YVggPj0gbGFzdERlbHRhWCkge1xuICAgICAgICAgICAgICAgICAgICAvLyDlj7PkuIvvvIzlt6bkuItcbiAgICAgICAgICAgICAgICAgICAgZGVsdGFYID0gbGFzdERlbHRhWCAtIDEwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWlzRG93bkxpc3QgJiYgZGVsdGFYIDw9IGxhc3REZWx0YVgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8g5Y+z5LiK77yM5bem5LiKXG4gICAgICAgICAgICAgICAgICAgIGRlbHRhWCA9IGxhc3REZWx0YVggKyAxMDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsaXN0W2ldLnggPSBjeCArIGRlbHRhWCAqIGRpcjtcbiAgICAgICAgICAgICAgICBsYXN0RGVsdGFYID0gZGVsdGFYO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxhc3RZID0gMDtcbiAgICAgICAgdmFyIGRlbHRhO1xuICAgICAgICB2YXIgbGVuID0gbGlzdC5sZW5ndGg7XG4gICAgICAgIHZhciB1cExpc3QgPSBbXTtcbiAgICAgICAgdmFyIGRvd25MaXN0ID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGRlbHRhID0gbGlzdFtpXS55IC0gbGFzdFk7XG4gICAgICAgICAgICBpZiAoZGVsdGEgPCAwKSB7XG4gICAgICAgICAgICAgICAgc2hpZnREb3duKGksIGxlbiwgLWRlbHRhLCBkaXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFzdFkgPSBsaXN0W2ldLnkgKyBsaXN0W2ldLmhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmlld0hlaWdodCAtIGxhc3RZIDwgMCkge1xuICAgICAgICAgICAgc2hpZnRVcChsZW4gLSAxLCBsYXN0WSAtIHZpZXdIZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChsaXN0W2ldLnkgPj0gY3kpIHtcbiAgICAgICAgICAgICAgICBkb3duTGlzdC5wdXNoKGxpc3RbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdXBMaXN0LnB1c2gobGlzdFtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2hhbmdlWCh1cExpc3QsIGZhbHNlLCBjeCwgY3ksIHIsIGRpcik7XG4gICAgICAgIGNoYW5nZVgoZG93bkxpc3QsIHRydWUsIGN4LCBjeSwgciwgZGlyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhdm9pZE92ZXJsYXAobGFiZWxMYXlvdXRMaXN0LCBjeCwgY3ksIHIsIHZpZXdXaWR0aCwgdmlld0hlaWdodCkge1xuICAgICAgICB2YXIgbGVmdExpc3QgPSBbXTtcbiAgICAgICAgdmFyIHJpZ2h0TGlzdCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhYmVsTGF5b3V0TGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGxhYmVsTGF5b3V0TGlzdFtpXS54IDwgY3gpIHtcbiAgICAgICAgICAgICAgICBsZWZ0TGlzdC5wdXNoKGxhYmVsTGF5b3V0TGlzdFtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByaWdodExpc3QucHVzaChsYWJlbExheW91dExpc3RbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYWRqdXN0U2luZ2xlU2lkZShyaWdodExpc3QsIGN4LCBjeSwgciwgMSwgdmlld1dpZHRoLCB2aWV3SGVpZ2h0KTtcbiAgICAgICAgYWRqdXN0U2luZ2xlU2lkZShsZWZ0TGlzdCwgY3gsIGN5LCByLCAtMSwgdmlld1dpZHRoLCB2aWV3SGVpZ2h0KTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhYmVsTGF5b3V0TGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGxpbmVQb2ludHMgPSBsYWJlbExheW91dExpc3RbaV0ubGluZVBvaW50cztcbiAgICAgICAgICAgIGlmIChsaW5lUG9pbnRzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRpc3QgPSBsaW5lUG9pbnRzWzFdWzBdIC0gbGluZVBvaW50c1syXVswXTtcbiAgICAgICAgICAgICAgICBpZiAobGFiZWxMYXlvdXRMaXN0W2ldLnggPCBjeCkge1xuICAgICAgICAgICAgICAgICAgICBsaW5lUG9pbnRzWzJdWzBdID0gbGFiZWxMYXlvdXRMaXN0W2ldLnggKyAzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZVBvaW50c1syXVswXSA9IGxhYmVsTGF5b3V0TGlzdFtpXS54IC0gMztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGluZVBvaW50c1sxXVsxXSA9IGxpbmVQb2ludHNbMl1bMV0gPSBsYWJlbExheW91dExpc3RbaV0ueTtcbiAgICAgICAgICAgICAgICBsaW5lUG9pbnRzWzFdWzBdID0gbGluZVBvaW50c1syXVswXSArIGRpc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgciwgdmlld1dpZHRoLCB2aWV3SGVpZ2h0KSB7XG4gICAgICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgICAgICB2YXIgbGFiZWxMYXlvdXRMaXN0ID0gW107XG4gICAgICAgIHZhciBjeDtcbiAgICAgICAgdmFyIGN5O1xuICAgICAgICB2YXIgaGFzTGFiZWxSb3RhdGUgPSBmYWxzZTtcblxuICAgICAgICBkYXRhLmVhY2goZnVuY3Rpb24gKGlkeCkge1xuICAgICAgICAgICAgdmFyIGxheW91dCA9IGRhdGEuZ2V0SXRlbUxheW91dChpZHgpO1xuXG4gICAgICAgICAgICB2YXIgaXRlbU1vZGVsID0gZGF0YS5nZXRJdGVtTW9kZWwoaWR4KTtcbiAgICAgICAgICAgIHZhciBsYWJlbE1vZGVsID0gaXRlbU1vZGVsLmdldE1vZGVsKCdsYWJlbC5ub3JtYWwnKTtcbiAgICAgICAgICAgIC8vIFVzZSBwb3NpdGlvbiBpbiBub3JtYWwgb3IgZW1waGFzaXNcbiAgICAgICAgICAgIHZhciBsYWJlbFBvc2l0aW9uID0gbGFiZWxNb2RlbC5nZXQoJ3Bvc2l0aW9uJykgfHwgaXRlbU1vZGVsLmdldCgnbGFiZWwuZW1waGFzaXMucG9zaXRpb24nKTtcblxuICAgICAgICAgICAgdmFyIGxhYmVsTGluZU1vZGVsID0gaXRlbU1vZGVsLmdldE1vZGVsKCdsYWJlbExpbmUubm9ybWFsJyk7XG4gICAgICAgICAgICB2YXIgbGFiZWxMaW5lTGVuID0gbGFiZWxMaW5lTW9kZWwuZ2V0KCdsZW5ndGgnKTtcbiAgICAgICAgICAgIHZhciBsYWJlbExpbmVMZW4yID0gbGFiZWxMaW5lTW9kZWwuZ2V0KCdsZW5ndGgyJyk7XG5cbiAgICAgICAgICAgIHZhciBtaWRBbmdsZSA9IChsYXlvdXQuc3RhcnRBbmdsZSArIGxheW91dC5lbmRBbmdsZSkgLyAyO1xuICAgICAgICAgICAgdmFyIGR4ID0gTWF0aC5jb3MobWlkQW5nbGUpO1xuICAgICAgICAgICAgdmFyIGR5ID0gTWF0aC5zaW4obWlkQW5nbGUpO1xuXG4gICAgICAgICAgICB2YXIgdGV4dFg7XG4gICAgICAgICAgICB2YXIgdGV4dFk7XG4gICAgICAgICAgICB2YXIgbGluZVBvaW50cztcbiAgICAgICAgICAgIHZhciB0ZXh0QWxpZ247XG5cbiAgICAgICAgICAgIGN4ID0gbGF5b3V0LmN4O1xuICAgICAgICAgICAgY3kgPSBsYXlvdXQuY3k7XG5cbiAgICAgICAgICAgIHZhciBpc0xhYmVsSW5zaWRlID0gbGFiZWxQb3NpdGlvbiA9PT0gJ2luc2lkZScgfHwgbGFiZWxQb3NpdGlvbiA9PT0gJ2lubmVyJztcbiAgICAgICAgICAgIGlmIChsYWJlbFBvc2l0aW9uID09PSAnY2VudGVyJykge1xuICAgICAgICAgICAgICAgIHRleHRYID0gbGF5b3V0LmN4O1xuICAgICAgICAgICAgICAgIHRleHRZID0gbGF5b3V0LmN5O1xuICAgICAgICAgICAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHgxID0gKGlzTGFiZWxJbnNpZGUgPyAobGF5b3V0LnIgKyBsYXlvdXQucjApIC8gMiAqIGR4IDogbGF5b3V0LnIgKiBkeCkgKyBjeDtcbiAgICAgICAgICAgICAgICB2YXIgeTEgPSAoaXNMYWJlbEluc2lkZSA/IChsYXlvdXQuciArIGxheW91dC5yMCkgLyAyICogZHkgOiBsYXlvdXQuciAqIGR5KSArIGN5O1xuXG4gICAgICAgICAgICAgICAgdGV4dFggPSB4MSArIGR4ICogMztcbiAgICAgICAgICAgICAgICB0ZXh0WSA9IHkxICsgZHkgKiAzO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFpc0xhYmVsSW5zaWRlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZvciByb3NlVHlwZVxuICAgICAgICAgICAgICAgICAgICB2YXIgeDIgPSB4MSArIGR4ICogKGxhYmVsTGluZUxlbiArIHIgLSBsYXlvdXQucik7XG4gICAgICAgICAgICAgICAgICAgIHZhciB5MiA9IHkxICsgZHkgKiAobGFiZWxMaW5lTGVuICsgciAtIGxheW91dC5yKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHgzID0geDIgKyAoKGR4IDwgMCA/IC0xIDogMSkgKiBsYWJlbExpbmVMZW4yKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHkzID0geTI7XG5cbiAgICAgICAgICAgICAgICAgICAgdGV4dFggPSB4MyArIChkeCA8IDAgPyAtNSA6IDUpO1xuICAgICAgICAgICAgICAgICAgICB0ZXh0WSA9IHkzO1xuICAgICAgICAgICAgICAgICAgICBsaW5lUG9pbnRzID0gW1t4MSwgeTFdLCBbeDIsIHkyXSwgW3gzLCB5M11dO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRleHRBbGlnbiA9IGlzTGFiZWxJbnNpZGUgPyAnY2VudGVyJyA6IChkeCA+IDAgPyAnbGVmdCcgOiAncmlnaHQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBmb250ID0gbGFiZWxNb2RlbC5nZXRNb2RlbCgndGV4dFN0eWxlJykuZ2V0Rm9udCgpO1xuXG4gICAgICAgICAgICB2YXIgbGFiZWxSb3RhdGUgPSBsYWJlbE1vZGVsLmdldCgncm90YXRlJylcbiAgICAgICAgICAgICAgICA/IChkeCA8IDAgPyAtbWlkQW5nbGUgKyBNYXRoLlBJIDogLW1pZEFuZ2xlKSA6IDA7XG4gICAgICAgICAgICB2YXIgdGV4dCA9IHNlcmllc01vZGVsLmdldEZvcm1hdHRlZExhYmVsKGlkeCwgJ25vcm1hbCcpXG4gICAgICAgICAgICAgICAgICAgICAgICB8fCBkYXRhLmdldE5hbWUoaWR4KTtcbiAgICAgICAgICAgIHZhciB0ZXh0UmVjdCA9IHRleHRDb250YWluLmdldEJvdW5kaW5nUmVjdChcbiAgICAgICAgICAgICAgICB0ZXh0LCBmb250LCB0ZXh0QWxpZ24sICd0b3AnXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaGFzTGFiZWxSb3RhdGUgPSAhIWxhYmVsUm90YXRlO1xuICAgICAgICAgICAgbGF5b3V0LmxhYmVsID0ge1xuICAgICAgICAgICAgICAgIHg6IHRleHRYLFxuICAgICAgICAgICAgICAgIHk6IHRleHRZLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBsYWJlbFBvc2l0aW9uLFxuICAgICAgICAgICAgICAgIGhlaWdodDogdGV4dFJlY3QuaGVpZ2h0LFxuICAgICAgICAgICAgICAgIGxlbjogbGFiZWxMaW5lTGVuLFxuICAgICAgICAgICAgICAgIGxlbjI6IGxhYmVsTGluZUxlbjIsXG4gICAgICAgICAgICAgICAgbGluZVBvaW50czogbGluZVBvaW50cyxcbiAgICAgICAgICAgICAgICB0ZXh0QWxpZ246IHRleHRBbGlnbixcbiAgICAgICAgICAgICAgICB2ZXJ0aWNhbEFsaWduOiAnbWlkZGxlJyxcbiAgICAgICAgICAgICAgICBmb250OiBmb250LFxuICAgICAgICAgICAgICAgIHJvdGF0aW9uOiBsYWJlbFJvdGF0ZVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gTm90IGxheW91dCB0aGUgaW5zaWRlIGxhYmVsXG4gICAgICAgICAgICBpZiAoIWlzTGFiZWxJbnNpZGUpIHtcbiAgICAgICAgICAgICAgICBsYWJlbExheW91dExpc3QucHVzaChsYXlvdXQubGFiZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFoYXNMYWJlbFJvdGF0ZSAmJiBzZXJpZXNNb2RlbC5nZXQoJ2F2b2lkTGFiZWxPdmVybGFwJykpIHtcbiAgICAgICAgICAgIGF2b2lkT3ZlcmxhcChsYWJlbExheW91dExpc3QsIGN4LCBjeSwgciwgdmlld1dpZHRoLCB2aWV3SGVpZ2h0KTtcbiAgICAgICAgfVxuICAgIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9jaGFydC9waWUvbGFiZWxMYXlvdXQuanNcbi8vIG1vZHVsZSBpZCA9IDE0NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 145 */
/* unknown exports provided */
/* all exports used */
/*!************************************!*\
  !*** ./lib/chart/pie/pieLayout.js ***!
  \************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("// TODO minAngle\n\n\n\n    var numberUtil = __webpack_require__(/*! ../../util/number */ 3);\n    var parsePercent = numberUtil.parsePercent;\n    var labelLayout = __webpack_require__(/*! ./labelLayout */ 144);\n    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 0);\n\n    var PI2 = Math.PI * 2;\n    var RADIAN = Math.PI / 180;\n\n    module.exports = function (seriesType, ecModel, api, payload) {\n        ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n            var center = seriesModel.get('center');\n            var radius = seriesModel.get('radius');\n\n            if (!zrUtil.isArray(radius)) {\n                radius = [0, radius];\n            }\n            if (!zrUtil.isArray(center)) {\n                center = [center, center];\n            }\n\n            var width = api.getWidth();\n            var height = api.getHeight();\n            var size = Math.min(width, height);\n            var cx = parsePercent(center[0], width);\n            var cy = parsePercent(center[1], height);\n            var r0 = parsePercent(radius[0], size / 2);\n            var r = parsePercent(radius[1], size / 2);\n\n            var data = seriesModel.getData();\n\n            var startAngle = -seriesModel.get('startAngle') * RADIAN;\n\n            var minAngle = seriesModel.get('minAngle') * RADIAN;\n\n            var sum = data.getSum('value');\n            // Sum may be 0\n            var unitRadian = Math.PI / (sum || data.count()) * 2;\n\n            var clockwise = seriesModel.get('clockwise');\n\n            var roseType = seriesModel.get('roseType');\n            var stillShowZeroSum = seriesModel.get('stillShowZeroSum');\n\n            // [0...max]\n            var extent = data.getDataExtent('value');\n            extent[0] = 0;\n\n            // In the case some sector angle is smaller than minAngle\n            var restAngle = PI2;\n            var valueSumLargerThanMinAngle = 0;\n\n            var currentAngle = startAngle;\n\n            var dir = clockwise ? 1 : -1;\n            data.each('value', function (value, idx) {\n                var angle;\n                if (isNaN(value)) {\n                    data.setItemLayout(idx, {\n                        angle: NaN,\n                        startAngle: NaN,\n                        endAngle: NaN,\n                        clockwise: clockwise,\n                        cx: cx,\n                        cy: cy,\n                        r0: r0,\n                        r: roseType\n                            ? NaN\n                            : r\n                    });\n                    return;\n                }\n\n                // FIXME 兼容 2.0 但是 roseType 是 area 的时候才是这样？\n                if (roseType !== 'area') {\n                    angle = (sum === 0 && stillShowZeroSum)\n                        ? unitRadian : (value * unitRadian);\n                }\n                else {\n                    angle = PI2 / (data.count() || 1);\n                }\n\n                if (angle < minAngle) {\n                    angle = minAngle;\n                    restAngle -= minAngle;\n                }\n                else {\n                    valueSumLargerThanMinAngle += value;\n                }\n\n                var endAngle = currentAngle + dir * angle;\n                data.setItemLayout(idx, {\n                    angle: angle,\n                    startAngle: currentAngle,\n                    endAngle: endAngle,\n                    clockwise: clockwise,\n                    cx: cx,\n                    cy: cy,\n                    r0: r0,\n                    r: roseType\n                        ? numberUtil.linearMap(value, extent, [r0, r])\n                        : r\n                });\n\n                currentAngle = endAngle;\n            }, true);\n\n            // Some sector is constrained by minAngle\n            // Rest sectors needs recalculate angle\n            if (restAngle < PI2) {\n                // Average the angle if rest angle is not enough after all angles is\n                // Constrained by minAngle\n                if (restAngle <= 1e-3) {\n                    var angle = PI2 / data.count();\n                    data.each(function (idx) {\n                        var layout = data.getItemLayout(idx);\n                        layout.startAngle = startAngle + dir * idx * angle;\n                        layout.endAngle = startAngle + dir * (idx + 1) * angle;\n                    });\n                }\n                else {\n                    unitRadian = restAngle / valueSumLargerThanMinAngle;\n                    currentAngle = startAngle;\n                    data.each('value', function (value, idx) {\n                        var layout = data.getItemLayout(idx);\n                        var angle = layout.angle === minAngle\n                            ? minAngle : value * unitRadian;\n                        layout.startAngle = currentAngle;\n                        layout.endAngle = currentAngle + dir * angle;\n                        currentAngle += dir * angle;\n                    });\n                }\n            }\n\n            labelLayout(seriesModel, r, width, height);\n        });\n    };\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQ1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2NoYXJ0L3BpZS9waWVMYXlvdXQuanM/ZWJjNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUT0RPIG1pbkFuZ2xlXG5cblxuXG4gICAgdmFyIG51bWJlclV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL251bWJlcicpO1xuICAgIHZhciBwYXJzZVBlcmNlbnQgPSBudW1iZXJVdGlsLnBhcnNlUGVyY2VudDtcbiAgICB2YXIgbGFiZWxMYXlvdXQgPSByZXF1aXJlKCcuL2xhYmVsTGF5b3V0Jyk7XG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuXG4gICAgdmFyIFBJMiA9IE1hdGguUEkgKiAyO1xuICAgIHZhciBSQURJQU4gPSBNYXRoLlBJIC8gMTgwO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc2VyaWVzVHlwZSwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKSB7XG4gICAgICAgIGVjTW9kZWwuZWFjaFNlcmllc0J5VHlwZShzZXJpZXNUeXBlLCBmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICAgICAgICAgIHZhciBjZW50ZXIgPSBzZXJpZXNNb2RlbC5nZXQoJ2NlbnRlcicpO1xuICAgICAgICAgICAgdmFyIHJhZGl1cyA9IHNlcmllc01vZGVsLmdldCgncmFkaXVzJyk7XG5cbiAgICAgICAgICAgIGlmICghenJVdGlsLmlzQXJyYXkocmFkaXVzKSkge1xuICAgICAgICAgICAgICAgIHJhZGl1cyA9IFswLCByYWRpdXNdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF6clV0aWwuaXNBcnJheShjZW50ZXIpKSB7XG4gICAgICAgICAgICAgICAgY2VudGVyID0gW2NlbnRlciwgY2VudGVyXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHdpZHRoID0gYXBpLmdldFdpZHRoKCk7XG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gYXBpLmdldEhlaWdodCgpO1xuICAgICAgICAgICAgdmFyIHNpemUgPSBNYXRoLm1pbih3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgIHZhciBjeCA9IHBhcnNlUGVyY2VudChjZW50ZXJbMF0sIHdpZHRoKTtcbiAgICAgICAgICAgIHZhciBjeSA9IHBhcnNlUGVyY2VudChjZW50ZXJbMV0sIGhlaWdodCk7XG4gICAgICAgICAgICB2YXIgcjAgPSBwYXJzZVBlcmNlbnQocmFkaXVzWzBdLCBzaXplIC8gMik7XG4gICAgICAgICAgICB2YXIgciA9IHBhcnNlUGVyY2VudChyYWRpdXNbMV0sIHNpemUgLyAyKTtcblxuICAgICAgICAgICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG5cbiAgICAgICAgICAgIHZhciBzdGFydEFuZ2xlID0gLXNlcmllc01vZGVsLmdldCgnc3RhcnRBbmdsZScpICogUkFESUFOO1xuXG4gICAgICAgICAgICB2YXIgbWluQW5nbGUgPSBzZXJpZXNNb2RlbC5nZXQoJ21pbkFuZ2xlJykgKiBSQURJQU47XG5cbiAgICAgICAgICAgIHZhciBzdW0gPSBkYXRhLmdldFN1bSgndmFsdWUnKTtcbiAgICAgICAgICAgIC8vIFN1bSBtYXkgYmUgMFxuICAgICAgICAgICAgdmFyIHVuaXRSYWRpYW4gPSBNYXRoLlBJIC8gKHN1bSB8fCBkYXRhLmNvdW50KCkpICogMjtcblxuICAgICAgICAgICAgdmFyIGNsb2Nrd2lzZSA9IHNlcmllc01vZGVsLmdldCgnY2xvY2t3aXNlJyk7XG5cbiAgICAgICAgICAgIHZhciByb3NlVHlwZSA9IHNlcmllc01vZGVsLmdldCgncm9zZVR5cGUnKTtcbiAgICAgICAgICAgIHZhciBzdGlsbFNob3daZXJvU3VtID0gc2VyaWVzTW9kZWwuZ2V0KCdzdGlsbFNob3daZXJvU3VtJyk7XG5cbiAgICAgICAgICAgIC8vIFswLi4ubWF4XVxuICAgICAgICAgICAgdmFyIGV4dGVudCA9IGRhdGEuZ2V0RGF0YUV4dGVudCgndmFsdWUnKTtcbiAgICAgICAgICAgIGV4dGVudFswXSA9IDA7XG5cbiAgICAgICAgICAgIC8vIEluIHRoZSBjYXNlIHNvbWUgc2VjdG9yIGFuZ2xlIGlzIHNtYWxsZXIgdGhhbiBtaW5BbmdsZVxuICAgICAgICAgICAgdmFyIHJlc3RBbmdsZSA9IFBJMjtcbiAgICAgICAgICAgIHZhciB2YWx1ZVN1bUxhcmdlclRoYW5NaW5BbmdsZSA9IDA7XG5cbiAgICAgICAgICAgIHZhciBjdXJyZW50QW5nbGUgPSBzdGFydEFuZ2xlO1xuXG4gICAgICAgICAgICB2YXIgZGlyID0gY2xvY2t3aXNlID8gMSA6IC0xO1xuICAgICAgICAgICAgZGF0YS5lYWNoKCd2YWx1ZScsIGZ1bmN0aW9uICh2YWx1ZSwgaWR4KSB7XG4gICAgICAgICAgICAgICAgdmFyIGFuZ2xlO1xuICAgICAgICAgICAgICAgIGlmIChpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5zZXRJdGVtTGF5b3V0KGlkeCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgYW5nbGU6IE5hTixcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0QW5nbGU6IE5hTixcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZEFuZ2xlOiBOYU4sXG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9ja3dpc2U6IGNsb2Nrd2lzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGN4OiBjeCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGN5OiBjeSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHIwOiByMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHI6IHJvc2VUeXBlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBOYU5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBGSVhNRSDlhbzlrrkgMi4wIOS9huaYryByb3NlVHlwZSDmmK8gYXJlYSDnmoTml7blgJnmiY3mmK/ov5nmoLfvvJ9cbiAgICAgICAgICAgICAgICBpZiAocm9zZVR5cGUgIT09ICdhcmVhJykge1xuICAgICAgICAgICAgICAgICAgICBhbmdsZSA9IChzdW0gPT09IDAgJiYgc3RpbGxTaG93WmVyb1N1bSlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdW5pdFJhZGlhbiA6ICh2YWx1ZSAqIHVuaXRSYWRpYW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYW5nbGUgPSBQSTIgLyAoZGF0YS5jb3VudCgpIHx8IDEpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChhbmdsZSA8IG1pbkFuZ2xlKSB7XG4gICAgICAgICAgICAgICAgICAgIGFuZ2xlID0gbWluQW5nbGU7XG4gICAgICAgICAgICAgICAgICAgIHJlc3RBbmdsZSAtPSBtaW5BbmdsZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlU3VtTGFyZ2VyVGhhbk1pbkFuZ2xlICs9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBlbmRBbmdsZSA9IGN1cnJlbnRBbmdsZSArIGRpciAqIGFuZ2xlO1xuICAgICAgICAgICAgICAgIGRhdGEuc2V0SXRlbUxheW91dChpZHgsIHtcbiAgICAgICAgICAgICAgICAgICAgYW5nbGU6IGFuZ2xlLFxuICAgICAgICAgICAgICAgICAgICBzdGFydEFuZ2xlOiBjdXJyZW50QW5nbGUsXG4gICAgICAgICAgICAgICAgICAgIGVuZEFuZ2xlOiBlbmRBbmdsZSxcbiAgICAgICAgICAgICAgICAgICAgY2xvY2t3aXNlOiBjbG9ja3dpc2UsXG4gICAgICAgICAgICAgICAgICAgIGN4OiBjeCxcbiAgICAgICAgICAgICAgICAgICAgY3k6IGN5LFxuICAgICAgICAgICAgICAgICAgICByMDogcjAsXG4gICAgICAgICAgICAgICAgICAgIHI6IHJvc2VUeXBlXG4gICAgICAgICAgICAgICAgICAgICAgICA/IG51bWJlclV0aWwubGluZWFyTWFwKHZhbHVlLCBleHRlbnQsIFtyMCwgcl0pXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHJcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGN1cnJlbnRBbmdsZSA9IGVuZEFuZ2xlO1xuICAgICAgICAgICAgfSwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIC8vIFNvbWUgc2VjdG9yIGlzIGNvbnN0cmFpbmVkIGJ5IG1pbkFuZ2xlXG4gICAgICAgICAgICAvLyBSZXN0IHNlY3RvcnMgbmVlZHMgcmVjYWxjdWxhdGUgYW5nbGVcbiAgICAgICAgICAgIGlmIChyZXN0QW5nbGUgPCBQSTIpIHtcbiAgICAgICAgICAgICAgICAvLyBBdmVyYWdlIHRoZSBhbmdsZSBpZiByZXN0IGFuZ2xlIGlzIG5vdCBlbm91Z2ggYWZ0ZXIgYWxsIGFuZ2xlcyBpc1xuICAgICAgICAgICAgICAgIC8vIENvbnN0cmFpbmVkIGJ5IG1pbkFuZ2xlXG4gICAgICAgICAgICAgICAgaWYgKHJlc3RBbmdsZSA8PSAxZS0zKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhbmdsZSA9IFBJMiAvIGRhdGEuY291bnQoKTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5lYWNoKGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsYXlvdXQgPSBkYXRhLmdldEl0ZW1MYXlvdXQoaWR4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheW91dC5zdGFydEFuZ2xlID0gc3RhcnRBbmdsZSArIGRpciAqIGlkeCAqIGFuZ2xlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGF5b3V0LmVuZEFuZ2xlID0gc3RhcnRBbmdsZSArIGRpciAqIChpZHggKyAxKSAqIGFuZ2xlO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHVuaXRSYWRpYW4gPSByZXN0QW5nbGUgLyB2YWx1ZVN1bUxhcmdlclRoYW5NaW5BbmdsZTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEFuZ2xlID0gc3RhcnRBbmdsZTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5lYWNoKCd2YWx1ZScsIGZ1bmN0aW9uICh2YWx1ZSwgaWR4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGF5b3V0ID0gZGF0YS5nZXRJdGVtTGF5b3V0KGlkeCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYW5nbGUgPSBsYXlvdXQuYW5nbGUgPT09IG1pbkFuZ2xlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBtaW5BbmdsZSA6IHZhbHVlICogdW5pdFJhZGlhbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheW91dC5zdGFydEFuZ2xlID0gY3VycmVudEFuZ2xlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGF5b3V0LmVuZEFuZ2xlID0gY3VycmVudEFuZ2xlICsgZGlyICogYW5nbGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50QW5nbGUgKz0gZGlyICogYW5nbGU7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGFiZWxMYXlvdXQoc2VyaWVzTW9kZWwsIHIsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvY2hhcnQvcGllL3BpZUxheW91dC5qc1xuLy8gbW9kdWxlIGlkID0gMTQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 146 */
/* unknown exports provided */
/* all exports used */
/*!*******************************!*\
  !*** ./lib/component/axis.js ***!
  \*******************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n// TODO boundaryGap\n\n\n    __webpack_require__(/*! ../coord/cartesian/AxisModel */ 67);\n\n    __webpack_require__(/*! ./axis/CartesianAxisView */ 147);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQ2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2NvbXBvbmVudC9heGlzLmpzPzdiNmMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuLy8gVE9ETyBib3VuZGFyeUdhcFxuXG5cbiAgICByZXF1aXJlKCcuLi9jb29yZC9jYXJ0ZXNpYW4vQXhpc01vZGVsJyk7XG5cbiAgICByZXF1aXJlKCcuL2F4aXMvQ2FydGVzaWFuQXhpc1ZpZXcnKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2NvbXBvbmVudC9heGlzLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 147 */
/* unknown exports provided */
/* all exports used */
/*!*************************************************!*\
  !*** ./lib/component/axis/CartesianAxisView.js ***!
  \*************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 0);\n    var graphic = __webpack_require__(/*! ../../util/graphic */ 2);\n    var AxisBuilder = __webpack_require__(/*! ./AxisBuilder */ 39);\n    var AxisView = __webpack_require__(/*! ./AxisView */ 40);\n    var cartesianAxisHelper = __webpack_require__(/*! ./cartesianAxisHelper */ 80);\n    var ifIgnoreOnTick = AxisBuilder.ifIgnoreOnTick;\n    var getInterval = AxisBuilder.getInterval;\n\n    var axisBuilderAttrs = [\n        'axisLine', 'axisLabel', 'axisTick', 'axisName'\n    ];\n    var selfBuilderAttrs = [\n        'splitArea', 'splitLine'\n    ];\n\n    // function getAlignWithLabel(model, axisModel) {\n    //     var alignWithLabel = model.get('alignWithLabel');\n    //     if (alignWithLabel === 'auto') {\n    //         alignWithLabel = axisModel.get('axisTick.alignWithLabel');\n    //     }\n    //     return alignWithLabel;\n    // }\n\n    var CartesianAxisView = AxisView.extend({\n\n        type: 'cartesianAxis',\n\n        axisPointerClass: 'CartesianAxisPointer',\n\n        /**\n         * @override\n         */\n        render: function (axisModel, ecModel, api, payload) {\n\n            this.group.removeAll();\n\n            var oldAxisGroup = this._axisGroup;\n            this._axisGroup = new graphic.Group();\n\n            this.group.add(this._axisGroup);\n\n            if (!axisModel.get('show')) {\n                return;\n            }\n\n            var gridModel = axisModel.getCoordSysModel();\n\n            var layout = cartesianAxisHelper.layout(gridModel, axisModel);\n\n            var axisBuilder = new AxisBuilder(axisModel, layout);\n\n            zrUtil.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);\n\n            this._axisGroup.add(axisBuilder.getGroup());\n\n            zrUtil.each(selfBuilderAttrs, function (name) {\n                if (axisModel.get(name + '.show')) {\n                    this['_' + name](axisModel, gridModel, layout.labelInterval);\n                }\n            }, this);\n\n            graphic.groupTransition(oldAxisGroup, this._axisGroup, axisModel);\n\n            CartesianAxisView.superCall(this, 'render', axisModel, ecModel, api, payload);\n        },\n\n        /**\n         * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n         * @param {module:echarts/coord/cartesian/GridModel} gridModel\n         * @param {number|Function} labelInterval\n         * @private\n         */\n        _splitLine: function (axisModel, gridModel, labelInterval) {\n            var axis = axisModel.axis;\n\n            if (axis.scale.isBlank()) {\n                return;\n            }\n\n            var splitLineModel = axisModel.getModel('splitLine');\n            var lineStyleModel = splitLineModel.getModel('lineStyle');\n            var lineColors = lineStyleModel.get('color');\n\n            var lineInterval = getInterval(splitLineModel, labelInterval);\n\n            lineColors = zrUtil.isArray(lineColors) ? lineColors : [lineColors];\n\n            var gridRect = gridModel.coordinateSystem.getRect();\n            var isHorizontal = axis.isHorizontal();\n\n            var lineCount = 0;\n\n            var ticksCoords = axis.getTicksCoords(\n                // splitLineModel.get('alignWithLabel')\n            );\n            var ticks = axis.scale.getTicks();\n\n            var p1 = [];\n            var p2 = [];\n            // Simple optimization\n            // Batching the lines if color are the same\n            var lineStyle = lineStyleModel.getLineStyle();\n            for (var i = 0; i < ticksCoords.length; i++) {\n                if (ifIgnoreOnTick(axis, i, lineInterval)) {\n                    continue;\n                }\n\n                var tickCoord = axis.toGlobalCoord(ticksCoords[i]);\n\n                if (isHorizontal) {\n                    p1[0] = tickCoord;\n                    p1[1] = gridRect.y;\n                    p2[0] = tickCoord;\n                    p2[1] = gridRect.y + gridRect.height;\n                }\n                else {\n                    p1[0] = gridRect.x;\n                    p1[1] = tickCoord;\n                    p2[0] = gridRect.x + gridRect.width;\n                    p2[1] = tickCoord;\n                }\n\n                var colorIndex = (lineCount++) % lineColors.length;\n                this._axisGroup.add(new graphic.Line(graphic.subPixelOptimizeLine({\n                    anid: 'line_' + ticks[i],\n\n                    shape: {\n                        x1: p1[0],\n                        y1: p1[1],\n                        x2: p2[0],\n                        y2: p2[1]\n                    },\n                    style: zrUtil.defaults({\n                        stroke: lineColors[colorIndex]\n                    }, lineStyle),\n                    silent: true\n                })));\n            }\n        },\n\n        /**\n         * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n         * @param {module:echarts/coord/cartesian/GridModel} gridModel\n         * @param {number|Function} labelInterval\n         * @private\n         */\n        _splitArea: function (axisModel, gridModel, labelInterval) {\n            var axis = axisModel.axis;\n\n            if (axis.scale.isBlank()) {\n                return;\n            }\n\n            var splitAreaModel = axisModel.getModel('splitArea');\n            var areaStyleModel = splitAreaModel.getModel('areaStyle');\n            var areaColors = areaStyleModel.get('color');\n\n            var gridRect = gridModel.coordinateSystem.getRect();\n\n            var ticksCoords = axis.getTicksCoords(\n                // splitAreaModel.get('alignWithLabel')\n            );\n            var ticks = axis.scale.getTicks();\n\n            var prevX = axis.toGlobalCoord(ticksCoords[0]);\n            var prevY = axis.toGlobalCoord(ticksCoords[0]);\n\n            var count = 0;\n\n            var areaInterval = getInterval(splitAreaModel, labelInterval);\n\n            var areaStyle = areaStyleModel.getAreaStyle();\n            areaColors = zrUtil.isArray(areaColors) ? areaColors : [areaColors];\n\n            for (var i = 1; i < ticksCoords.length; i++) {\n                if (ifIgnoreOnTick(axis, i, areaInterval)) {\n                    continue;\n                }\n\n                var tickCoord = axis.toGlobalCoord(ticksCoords[i]);\n\n                var x;\n                var y;\n                var width;\n                var height;\n                if (axis.isHorizontal()) {\n                    x = prevX;\n                    y = gridRect.y;\n                    width = tickCoord - x;\n                    height = gridRect.height;\n                }\n                else {\n                    x = gridRect.x;\n                    y = prevY;\n                    width = gridRect.width;\n                    height = tickCoord - y;\n                }\n\n                var colorIndex = (count++) % areaColors.length;\n                this._axisGroup.add(new graphic.Rect({\n                    anid: 'area_' + ticks[i],\n\n                    shape: {\n                        x: x,\n                        y: y,\n                        width: width,\n                        height: height\n                    },\n                    style: zrUtil.defaults({\n                        fill: areaColors[colorIndex]\n                    }, areaStyle),\n                    silent: true\n                }));\n\n                prevX = x + width;\n                prevY = y + height;\n            }\n        }\n    });\n\n    CartesianAxisView.extend({\n        type: 'xAxis'\n    });\n    CartesianAxisView.extend({\n        type: 'yAxis'\n    });\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQ3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2NvbXBvbmVudC9heGlzL0NhcnRlc2lhbkF4aXNWaWV3LmpzP2RjMzciXSwic291cmNlc0NvbnRlbnQiOlsiXG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKCcuLi8uLi91dGlsL2dyYXBoaWMnKTtcbiAgICB2YXIgQXhpc0J1aWxkZXIgPSByZXF1aXJlKCcuL0F4aXNCdWlsZGVyJyk7XG4gICAgdmFyIEF4aXNWaWV3ID0gcmVxdWlyZSgnLi9BeGlzVmlldycpO1xuICAgIHZhciBjYXJ0ZXNpYW5BeGlzSGVscGVyID0gcmVxdWlyZSgnLi9jYXJ0ZXNpYW5BeGlzSGVscGVyJyk7XG4gICAgdmFyIGlmSWdub3JlT25UaWNrID0gQXhpc0J1aWxkZXIuaWZJZ25vcmVPblRpY2s7XG4gICAgdmFyIGdldEludGVydmFsID0gQXhpc0J1aWxkZXIuZ2V0SW50ZXJ2YWw7XG5cbiAgICB2YXIgYXhpc0J1aWxkZXJBdHRycyA9IFtcbiAgICAgICAgJ2F4aXNMaW5lJywgJ2F4aXNMYWJlbCcsICdheGlzVGljaycsICdheGlzTmFtZSdcbiAgICBdO1xuICAgIHZhciBzZWxmQnVpbGRlckF0dHJzID0gW1xuICAgICAgICAnc3BsaXRBcmVhJywgJ3NwbGl0TGluZSdcbiAgICBdO1xuXG4gICAgLy8gZnVuY3Rpb24gZ2V0QWxpZ25XaXRoTGFiZWwobW9kZWwsIGF4aXNNb2RlbCkge1xuICAgIC8vICAgICB2YXIgYWxpZ25XaXRoTGFiZWwgPSBtb2RlbC5nZXQoJ2FsaWduV2l0aExhYmVsJyk7XG4gICAgLy8gICAgIGlmIChhbGlnbldpdGhMYWJlbCA9PT0gJ2F1dG8nKSB7XG4gICAgLy8gICAgICAgICBhbGlnbldpdGhMYWJlbCA9IGF4aXNNb2RlbC5nZXQoJ2F4aXNUaWNrLmFsaWduV2l0aExhYmVsJyk7XG4gICAgLy8gICAgIH1cbiAgICAvLyAgICAgcmV0dXJuIGFsaWduV2l0aExhYmVsO1xuICAgIC8vIH1cblxuICAgIHZhciBDYXJ0ZXNpYW5BeGlzVmlldyA9IEF4aXNWaWV3LmV4dGVuZCh7XG5cbiAgICAgICAgdHlwZTogJ2NhcnRlc2lhbkF4aXMnLFxuXG4gICAgICAgIGF4aXNQb2ludGVyQ2xhc3M6ICdDYXJ0ZXNpYW5BeGlzUG9pbnRlcicsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICAgKi9cbiAgICAgICAgcmVuZGVyOiBmdW5jdGlvbiAoYXhpc01vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpIHtcblxuICAgICAgICAgICAgdGhpcy5ncm91cC5yZW1vdmVBbGwoKTtcblxuICAgICAgICAgICAgdmFyIG9sZEF4aXNHcm91cCA9IHRoaXMuX2F4aXNHcm91cDtcbiAgICAgICAgICAgIHRoaXMuX2F4aXNHcm91cCA9IG5ldyBncmFwaGljLkdyb3VwKCk7XG5cbiAgICAgICAgICAgIHRoaXMuZ3JvdXAuYWRkKHRoaXMuX2F4aXNHcm91cCk7XG5cbiAgICAgICAgICAgIGlmICghYXhpc01vZGVsLmdldCgnc2hvdycpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZ3JpZE1vZGVsID0gYXhpc01vZGVsLmdldENvb3JkU3lzTW9kZWwoKTtcblxuICAgICAgICAgICAgdmFyIGxheW91dCA9IGNhcnRlc2lhbkF4aXNIZWxwZXIubGF5b3V0KGdyaWRNb2RlbCwgYXhpc01vZGVsKTtcblxuICAgICAgICAgICAgdmFyIGF4aXNCdWlsZGVyID0gbmV3IEF4aXNCdWlsZGVyKGF4aXNNb2RlbCwgbGF5b3V0KTtcblxuICAgICAgICAgICAgenJVdGlsLmVhY2goYXhpc0J1aWxkZXJBdHRycywgYXhpc0J1aWxkZXIuYWRkLCBheGlzQnVpbGRlcik7XG5cbiAgICAgICAgICAgIHRoaXMuX2F4aXNHcm91cC5hZGQoYXhpc0J1aWxkZXIuZ2V0R3JvdXAoKSk7XG5cbiAgICAgICAgICAgIHpyVXRpbC5lYWNoKHNlbGZCdWlsZGVyQXR0cnMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgaWYgKGF4aXNNb2RlbC5nZXQobmFtZSArICcuc2hvdycpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbJ18nICsgbmFtZV0oYXhpc01vZGVsLCBncmlkTW9kZWwsIGxheW91dC5sYWJlbEludGVydmFsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgZ3JhcGhpYy5ncm91cFRyYW5zaXRpb24ob2xkQXhpc0dyb3VwLCB0aGlzLl9heGlzR3JvdXAsIGF4aXNNb2RlbCk7XG5cbiAgICAgICAgICAgIENhcnRlc2lhbkF4aXNWaWV3LnN1cGVyQ2FsbCh0aGlzLCAncmVuZGVyJywgYXhpc01vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2Nvb3JkL2NhcnRlc2lhbi9BeGlzTW9kZWx9IGF4aXNNb2RlbFxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2Nvb3JkL2NhcnRlc2lhbi9HcmlkTW9kZWx9IGdyaWRNb2RlbFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcnxGdW5jdGlvbn0gbGFiZWxJbnRlcnZhbFxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX3NwbGl0TGluZTogZnVuY3Rpb24gKGF4aXNNb2RlbCwgZ3JpZE1vZGVsLCBsYWJlbEludGVydmFsKSB7XG4gICAgICAgICAgICB2YXIgYXhpcyA9IGF4aXNNb2RlbC5heGlzO1xuXG4gICAgICAgICAgICBpZiAoYXhpcy5zY2FsZS5pc0JsYW5rKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzcGxpdExpbmVNb2RlbCA9IGF4aXNNb2RlbC5nZXRNb2RlbCgnc3BsaXRMaW5lJyk7XG4gICAgICAgICAgICB2YXIgbGluZVN0eWxlTW9kZWwgPSBzcGxpdExpbmVNb2RlbC5nZXRNb2RlbCgnbGluZVN0eWxlJyk7XG4gICAgICAgICAgICB2YXIgbGluZUNvbG9ycyA9IGxpbmVTdHlsZU1vZGVsLmdldCgnY29sb3InKTtcblxuICAgICAgICAgICAgdmFyIGxpbmVJbnRlcnZhbCA9IGdldEludGVydmFsKHNwbGl0TGluZU1vZGVsLCBsYWJlbEludGVydmFsKTtcblxuICAgICAgICAgICAgbGluZUNvbG9ycyA9IHpyVXRpbC5pc0FycmF5KGxpbmVDb2xvcnMpID8gbGluZUNvbG9ycyA6IFtsaW5lQ29sb3JzXTtcblxuICAgICAgICAgICAgdmFyIGdyaWRSZWN0ID0gZ3JpZE1vZGVsLmNvb3JkaW5hdGVTeXN0ZW0uZ2V0UmVjdCgpO1xuICAgICAgICAgICAgdmFyIGlzSG9yaXpvbnRhbCA9IGF4aXMuaXNIb3Jpem9udGFsKCk7XG5cbiAgICAgICAgICAgIHZhciBsaW5lQ291bnQgPSAwO1xuXG4gICAgICAgICAgICB2YXIgdGlja3NDb29yZHMgPSBheGlzLmdldFRpY2tzQ29vcmRzKFxuICAgICAgICAgICAgICAgIC8vIHNwbGl0TGluZU1vZGVsLmdldCgnYWxpZ25XaXRoTGFiZWwnKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHZhciB0aWNrcyA9IGF4aXMuc2NhbGUuZ2V0VGlja3MoKTtcblxuICAgICAgICAgICAgdmFyIHAxID0gW107XG4gICAgICAgICAgICB2YXIgcDIgPSBbXTtcbiAgICAgICAgICAgIC8vIFNpbXBsZSBvcHRpbWl6YXRpb25cbiAgICAgICAgICAgIC8vIEJhdGNoaW5nIHRoZSBsaW5lcyBpZiBjb2xvciBhcmUgdGhlIHNhbWVcbiAgICAgICAgICAgIHZhciBsaW5lU3R5bGUgPSBsaW5lU3R5bGVNb2RlbC5nZXRMaW5lU3R5bGUoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGlja3NDb29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaWZJZ25vcmVPblRpY2soYXhpcywgaSwgbGluZUludGVydmFsKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgdGlja0Nvb3JkID0gYXhpcy50b0dsb2JhbENvb3JkKHRpY2tzQ29vcmRzW2ldKTtcblxuICAgICAgICAgICAgICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcDFbMF0gPSB0aWNrQ29vcmQ7XG4gICAgICAgICAgICAgICAgICAgIHAxWzFdID0gZ3JpZFJlY3QueTtcbiAgICAgICAgICAgICAgICAgICAgcDJbMF0gPSB0aWNrQ29vcmQ7XG4gICAgICAgICAgICAgICAgICAgIHAyWzFdID0gZ3JpZFJlY3QueSArIGdyaWRSZWN0LmhlaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHAxWzBdID0gZ3JpZFJlY3QueDtcbiAgICAgICAgICAgICAgICAgICAgcDFbMV0gPSB0aWNrQ29vcmQ7XG4gICAgICAgICAgICAgICAgICAgIHAyWzBdID0gZ3JpZFJlY3QueCArIGdyaWRSZWN0LndpZHRoO1xuICAgICAgICAgICAgICAgICAgICBwMlsxXSA9IHRpY2tDb29yZDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgY29sb3JJbmRleCA9IChsaW5lQ291bnQrKykgJSBsaW5lQ29sb3JzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB0aGlzLl9heGlzR3JvdXAuYWRkKG5ldyBncmFwaGljLkxpbmUoZ3JhcGhpYy5zdWJQaXhlbE9wdGltaXplTGluZSh7XG4gICAgICAgICAgICAgICAgICAgIGFuaWQ6ICdsaW5lXycgKyB0aWNrc1tpXSxcblxuICAgICAgICAgICAgICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgeDE6IHAxWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgeTE6IHAxWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgeDI6IHAyWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgeTI6IHAyWzFdXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiB6clV0aWwuZGVmYXVsdHMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlOiBsaW5lQ29sb3JzW2NvbG9ySW5kZXhdXG4gICAgICAgICAgICAgICAgICAgIH0sIGxpbmVTdHlsZSksXG4gICAgICAgICAgICAgICAgICAgIHNpbGVudDogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvY29vcmQvY2FydGVzaWFuL0F4aXNNb2RlbH0gYXhpc01vZGVsXG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvY29vcmQvY2FydGVzaWFuL0dyaWRNb2RlbH0gZ3JpZE1vZGVsXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfEZ1bmN0aW9ufSBsYWJlbEludGVydmFsXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfc3BsaXRBcmVhOiBmdW5jdGlvbiAoYXhpc01vZGVsLCBncmlkTW9kZWwsIGxhYmVsSW50ZXJ2YWwpIHtcbiAgICAgICAgICAgIHZhciBheGlzID0gYXhpc01vZGVsLmF4aXM7XG5cbiAgICAgICAgICAgIGlmIChheGlzLnNjYWxlLmlzQmxhbmsoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHNwbGl0QXJlYU1vZGVsID0gYXhpc01vZGVsLmdldE1vZGVsKCdzcGxpdEFyZWEnKTtcbiAgICAgICAgICAgIHZhciBhcmVhU3R5bGVNb2RlbCA9IHNwbGl0QXJlYU1vZGVsLmdldE1vZGVsKCdhcmVhU3R5bGUnKTtcbiAgICAgICAgICAgIHZhciBhcmVhQ29sb3JzID0gYXJlYVN0eWxlTW9kZWwuZ2V0KCdjb2xvcicpO1xuXG4gICAgICAgICAgICB2YXIgZ3JpZFJlY3QgPSBncmlkTW9kZWwuY29vcmRpbmF0ZVN5c3RlbS5nZXRSZWN0KCk7XG5cbiAgICAgICAgICAgIHZhciB0aWNrc0Nvb3JkcyA9IGF4aXMuZ2V0VGlja3NDb29yZHMoXG4gICAgICAgICAgICAgICAgLy8gc3BsaXRBcmVhTW9kZWwuZ2V0KCdhbGlnbldpdGhMYWJlbCcpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdmFyIHRpY2tzID0gYXhpcy5zY2FsZS5nZXRUaWNrcygpO1xuXG4gICAgICAgICAgICB2YXIgcHJldlggPSBheGlzLnRvR2xvYmFsQ29vcmQodGlja3NDb29yZHNbMF0pO1xuICAgICAgICAgICAgdmFyIHByZXZZID0gYXhpcy50b0dsb2JhbENvb3JkKHRpY2tzQ29vcmRzWzBdKTtcblxuICAgICAgICAgICAgdmFyIGNvdW50ID0gMDtcblxuICAgICAgICAgICAgdmFyIGFyZWFJbnRlcnZhbCA9IGdldEludGVydmFsKHNwbGl0QXJlYU1vZGVsLCBsYWJlbEludGVydmFsKTtcblxuICAgICAgICAgICAgdmFyIGFyZWFTdHlsZSA9IGFyZWFTdHlsZU1vZGVsLmdldEFyZWFTdHlsZSgpO1xuICAgICAgICAgICAgYXJlYUNvbG9ycyA9IHpyVXRpbC5pc0FycmF5KGFyZWFDb2xvcnMpID8gYXJlYUNvbG9ycyA6IFthcmVhQ29sb3JzXTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCB0aWNrc0Nvb3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpZklnbm9yZU9uVGljayhheGlzLCBpLCBhcmVhSW50ZXJ2YWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciB0aWNrQ29vcmQgPSBheGlzLnRvR2xvYmFsQ29vcmQodGlja3NDb29yZHNbaV0pO1xuXG4gICAgICAgICAgICAgICAgdmFyIHg7XG4gICAgICAgICAgICAgICAgdmFyIHk7XG4gICAgICAgICAgICAgICAgdmFyIHdpZHRoO1xuICAgICAgICAgICAgICAgIHZhciBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgaWYgKGF4aXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgeCA9IHByZXZYO1xuICAgICAgICAgICAgICAgICAgICB5ID0gZ3JpZFJlY3QueTtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGggPSB0aWNrQ29vcmQgLSB4O1xuICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSBncmlkUmVjdC5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB4ID0gZ3JpZFJlY3QueDtcbiAgICAgICAgICAgICAgICAgICAgeSA9IHByZXZZO1xuICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IGdyaWRSZWN0LndpZHRoO1xuICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSB0aWNrQ29vcmQgLSB5O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBjb2xvckluZGV4ID0gKGNvdW50KyspICUgYXJlYUNvbG9ycy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgdGhpcy5fYXhpc0dyb3VwLmFkZChuZXcgZ3JhcGhpYy5SZWN0KHtcbiAgICAgICAgICAgICAgICAgICAgYW5pZDogJ2FyZWFfJyArIHRpY2tzW2ldLFxuXG4gICAgICAgICAgICAgICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiB6clV0aWwuZGVmYXVsdHMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsbDogYXJlYUNvbG9yc1tjb2xvckluZGV4XVxuICAgICAgICAgICAgICAgICAgICB9LCBhcmVhU3R5bGUpLFxuICAgICAgICAgICAgICAgICAgICBzaWxlbnQ6IHRydWVcbiAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgICAgICBwcmV2WCA9IHggKyB3aWR0aDtcbiAgICAgICAgICAgICAgICBwcmV2WSA9IHkgKyBoZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIENhcnRlc2lhbkF4aXNWaWV3LmV4dGVuZCh7XG4gICAgICAgIHR5cGU6ICd4QXhpcydcbiAgICB9KTtcbiAgICBDYXJ0ZXNpYW5BeGlzVmlldy5leHRlbmQoe1xuICAgICAgICB0eXBlOiAneUF4aXMnXG4gICAgfSk7XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2NvbXBvbmVudC9heGlzL0NhcnRlc2lhbkF4aXNWaWV3LmpzXG4vLyBtb2R1bGUgaWQgPSAxNDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 148 */
/* unknown exports provided */
/* all exports used */
/*!******************************************************!*\
  !*** ./lib/component/axisPointer/BaseAxisPointer.js ***!
  \******************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\n    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 0);\n    var clazzUtil = __webpack_require__(/*! ../../util/clazz */ 14);\n    var graphic = __webpack_require__(/*! ../../util/graphic */ 2);\n    var get = __webpack_require__(/*! ../../util/model */ 5).makeGetter();\n    var axisPointerModelHelper = __webpack_require__(/*! ./modelHelper */ 45);\n    var eventTool = __webpack_require__(/*! zrender/lib/core/event */ 20);\n    var throttle = __webpack_require__(/*! ../../util/throttle */ 38);\n\n    var clone = zrUtil.clone;\n    var bind = zrUtil.bind;\n\n    /**\n     * Base axis pointer class in 2D.\n     * Implemenents {module:echarts/component/axis/IAxisPointer}.\n     */\n    function BaseAxisPointer () {\n    }\n\n    BaseAxisPointer.prototype = {\n\n        /**\n         * @private\n         */\n        _group: null,\n\n        /**\n         * @private\n         */\n        _lastGraphicKey: null,\n\n        /**\n         * @private\n         */\n        _handle: null,\n\n        /**\n         * @private\n         */\n        _dragging: false,\n\n        /**\n         * @private\n         */\n        _lastValue: null,\n\n        /**\n         * @private\n         */\n        _lastStatus: null,\n\n        /**\n         * @private\n         */\n        _payloadInfo: null,\n\n        /**\n         * In px, arbitrary value. Do not set too small,\n         * no animation is ok for most cases.\n         * @protected\n         */\n        animationThreshold: 15,\n\n        /**\n         * @implement\n         */\n        render: function (axisModel, axisPointerModel, api, forceRender) {\n            var value = axisPointerModel.get('value');\n            var status = axisPointerModel.get('status');\n\n            // Bind them to `this`, not in closure, otherwise they will not\n            // be replaced when user calling setOption in not merge mode.\n            this._axisModel = axisModel;\n            this._axisPointerModel = axisPointerModel;\n            this._api = api;\n\n            // Optimize: `render` will be called repeatly during mouse move.\n            // So it is power consuming if performing `render` each time,\n            // especially on mobile device.\n            if (!forceRender\n                && this._lastValue === value\n                && this._lastStatus === status\n            ) {\n                return;\n            }\n            this._lastValue = value;\n            this._lastStatus = status;\n\n            var group = this._group;\n            var handle = this._handle;\n\n            if (!status || status === 'hide') {\n                // Do not clear here, for animation better.\n                group && group.hide();\n                handle && handle.hide();\n                return;\n            }\n            group && group.show();\n            handle && handle.show();\n\n            // Otherwise status is 'show'\n            var elOption = {};\n            this.makeElOption(elOption, value, axisModel, axisPointerModel, api);\n\n            // Enable change axis pointer type.\n            var graphicKey = elOption.graphicKey;\n            if (graphicKey !== this._lastGraphicKey) {\n                this.clear(api);\n            }\n            this._lastGraphicKey = graphicKey;\n\n            var moveAnimation = this._moveAnimation =\n                this.determineAnimation(axisModel, axisPointerModel);\n\n            if (!group) {\n                group = this._group = new graphic.Group();\n                this.createPointerEl(group, elOption, axisModel, axisPointerModel);\n                this.createLabelEl(group, elOption, axisModel, axisPointerModel);\n                api.getZr().add(group);\n            }\n            else {\n                var doUpdateProps = zrUtil.curry(updateProps, axisPointerModel, moveAnimation);\n                this.updatePointerEl(group, elOption, doUpdateProps, axisPointerModel);\n                this.updateLabelEl(group, elOption, doUpdateProps, axisPointerModel);\n            }\n\n            updateMandatoryProps(group, axisPointerModel, true);\n\n            this._renderHandle(value);\n        },\n\n        /**\n         * @implement\n         */\n        remove: function (api) {\n            this.clear(api);\n        },\n\n        /**\n         * @implement\n         */\n        dispose: function (api) {\n            this.clear(api);\n        },\n\n        /**\n         * @protected\n         */\n        determineAnimation: function (axisModel, axisPointerModel) {\n            var animation = axisPointerModel.get('animation');\n            var axis = axisModel.axis;\n            var isCategoryAxis = axis.type === 'category';\n            var useSnap = axisPointerModel.get('snap');\n\n            // Value axis without snap always do not snap.\n            if (!useSnap && !isCategoryAxis) {\n                return false;\n            }\n\n            if (animation === 'auto' || animation == null) {\n                var animationThreshold = this.animationThreshold;\n                if (isCategoryAxis && axis.getBandWidth() > animationThreshold) {\n                    return true;\n                }\n\n                // It is important to auto animation when snap used. Consider if there is\n                // a dataZoom, animation will be disabled when too many points exist, while\n                // it will be enabled for better visual effect when little points exist.\n                if (useSnap) {\n                    var seriesDataCount = axisPointerModelHelper.getAxisInfo(axisModel).seriesDataCount;\n                    var axisExtent = axis.getExtent();\n                    // Approximate band width\n                    return Math.abs(axisExtent[0] - axisExtent[1]) / seriesDataCount > animationThreshold;\n                }\n\n                return false;\n            }\n\n            return animation === true;\n        },\n\n        /**\n         * add {pointer, label, graphicKey} to elOption\n         * @protected\n         */\n        makeElOption: function (elOption, value, axisModel, axisPointerModel, api) {\n            // Shoule be implemenented by sub-class.\n        },\n\n        /**\n         * @protected\n         */\n        createPointerEl: function (group, elOption, axisModel, axisPointerModel) {\n            var pointerOption = elOption.pointer;\n            if (pointerOption) {\n                var pointerEl = get(group).pointerEl = new graphic[pointerOption.type](\n                    clone(elOption.pointer)\n                );\n                group.add(pointerEl);\n            }\n        },\n\n        /**\n         * @protected\n         */\n        createLabelEl: function (group, elOption, axisModel, axisPointerModel) {\n            if (elOption.label) {\n                var labelEl = get(group).labelEl = new graphic.Rect(\n                    clone(elOption.label)\n                );\n\n                group.add(labelEl);\n                updateLabelShowHide(labelEl, axisPointerModel);\n            }\n        },\n\n        /**\n         * @protected\n         */\n        updatePointerEl: function (group, elOption, updateProps) {\n            var pointerEl = get(group).pointerEl;\n            if (pointerEl) {\n                pointerEl.setStyle(elOption.pointer.style);\n                updateProps(pointerEl, {shape: elOption.pointer.shape});\n            }\n        },\n\n        /**\n         * @protected\n         */\n        updateLabelEl: function (group, elOption, updateProps, axisPointerModel) {\n            var labelEl = get(group).labelEl;\n            if (labelEl) {\n                labelEl.setStyle(elOption.label.style);\n                updateProps(labelEl, {\n                    // Consider text length change in vertical axis, animation should\n                    // be used on shape, otherwise the effect will be weird.\n                    shape: elOption.label.shape,\n                    position: elOption.label.position\n                });\n\n                updateLabelShowHide(labelEl, axisPointerModel);\n            }\n        },\n\n        /**\n         * @private\n         */\n        _renderHandle: function (value) {\n            if (this._dragging || !this.updateHandleTransform) {\n                return;\n            }\n\n            var axisPointerModel = this._axisPointerModel;\n            var zr = this._api.getZr();\n            var handle = this._handle;\n            var handleModel = axisPointerModel.getModel('handle');\n\n            var status = axisPointerModel.get('status');\n            if (!handleModel.get('show') || !status || status === 'hide') {\n                handle && zr.remove(handle);\n                this._handle = null;\n                return;\n            }\n\n            var isInit;\n            if (!this._handle) {\n                isInit = true;\n                handle = this._handle = createIcon(handleModel, {\n                    onmousemove: function (e) {\n                        // Fot mobile devicem, prevent screen slider on the button.\n                        eventTool.stop(e.event);\n                    },\n                    onmousedown: bind(this._onHandleDragMove, this, 0, 0),\n                    drift: bind(this._onHandleDragMove, this),\n                    ondragend: bind(this._onHandleDragEnd, this)\n                });\n                zr.add(handle);\n            }\n\n            updateMandatoryProps(handle, axisPointerModel, false);\n\n            // update style\n            var includeStyles = [\n                'color', 'borderColor', 'borderWidth', 'opacity',\n                'shadowColor', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY'\n            ];\n            handle.setStyle(handleModel.getItemStyle(null, includeStyles));\n\n            // update position\n            var handleSize = handleModel.get('size');\n            if (!zrUtil.isArray(handleSize)) {\n                handleSize = [handleSize, handleSize];\n            }\n            handle.attr('scale', [handleSize[0] / 2, handleSize[1] / 2]);\n\n            throttle.createOrUpdate(\n                this,\n                '_doDispatchAxisPointer',\n                handleModel.get('throttle') || 0,\n                'fixRate'\n            );\n\n            this._moveHandleToValue(value, isInit);\n        },\n\n        /**\n         * @private\n         */\n        _moveHandleToValue: function (value, isInit) {\n            updateProps(\n                this._axisPointerModel,\n                !isInit && this._moveAnimation,\n                this._handle,\n                getHandleTransProps(this.getHandleTransform(\n                    value, this._axisModel, this._axisPointerModel\n                ))\n            );\n        },\n\n        /**\n         * @private\n         */\n        _onHandleDragMove: function (dx, dy) {\n            var handle = this._handle;\n            if (!handle) {\n                return;\n            }\n\n            this._dragging = true;\n\n            // Persistent for throttle.\n            var trans = this.updateHandleTransform(\n                getHandleTransProps(handle),\n                [dx, dy],\n                this._axisModel,\n                this._axisPointerModel\n            );\n            this._payloadInfo = trans;\n\n            handle.stopAnimation();\n            handle.attr(getHandleTransProps(trans));\n            get(handle).lastProp = null;\n\n            this._doDispatchAxisPointer();\n        },\n\n        /**\n         * Throttled method.\n         * @private\n         */\n        _doDispatchAxisPointer: function () {\n            var handle = this._handle;\n            if (!handle) {\n                return;\n            }\n\n            var payloadInfo = this._payloadInfo;\n            var payload = {\n                type: 'updateAxisPointer',\n                x: payloadInfo.cursorPoint[0],\n                y: payloadInfo.cursorPoint[1],\n                tooltipOption: payloadInfo.tooltipOption,\n                highDownKey: 'axisPointerHandle'\n            };\n            var axis = this._axisModel.axis;\n            payload[axis.dim + 'AxisId'] = this._axisModel.id;\n            this._api.dispatchAction(payload);\n        },\n\n        /**\n         * @private\n         */\n        _onHandleDragEnd: function (moveAnimation) {\n            this._dragging = false;\n            var handle = this._handle;\n            if (!handle) {\n                return;\n            }\n\n            var value = this._axisPointerModel.get('value');\n            // Consider snap or categroy axis, handle may be not consistent with\n            // axisPointer. So move handle to align the exact value position when\n            // drag ended.\n            this._moveHandleToValue(value);\n\n            // For the effect: tooltip will be shown when finger holding on handle\n            // button, and will be hidden after finger left handle button.\n            this._api.dispatchAction({\n                type: 'hideTip'\n            });\n        },\n\n        /**\n         * Should be implemenented by sub-class if support `handle`.\n         * @protected\n         * @param {number} value\n         * @param {module:echarts/model/Model} axisModel\n         * @param {module:echarts/model/Model} axisPointerModel\n         * @return {Object} {position: [x, y], rotation: 0}\n         */\n        getHandleTransform: null,\n\n        /**\n         * * Should be implemenented by sub-class if support `handle`.\n         * @protected\n         * @param {Object} transform {position, rotation}\n         * @param {Array.<number>} delta [dx, dy]\n         * @param {module:echarts/model/Model} axisModel\n         * @param {module:echarts/model/Model} axisPointerModel\n         * @return {Object} {position: [x, y], rotation: 0, cursorPoint: [x, y]}\n         */\n        updateHandleTransform: null,\n\n        /**\n         * @private\n         */\n        clear: function (api) {\n            this._lastValue = null;\n            this._lastStatus = null;\n\n            var zr = api.getZr();\n            var group = this._group;\n            var handle = this._handle;\n            if (zr && group) {\n                this._lastGraphicKey = null;\n                group && zr.remove(group);\n                handle && zr.remove(handle);\n                this._group = null;\n                this._handle = null;\n                this._payloadInfo = null;\n            }\n        },\n\n        /**\n         * @protected\n         */\n        doClear: function () {\n            // Implemented by sub-class if necessary.\n        },\n\n        /**\n         * @protected\n         * @param {Array.<number>} xy\n         * @param {Array.<number>} wh\n         * @param {number} [xDimIndex=0] or 1\n         */\n        buildLabel: function (xy, wh, xDimIndex) {\n            xDimIndex = xDimIndex || 0;\n            return {\n                x: xy[xDimIndex],\n                y: xy[1 - xDimIndex],\n                width: wh[xDimIndex],\n                height: wh[1 - xDimIndex]\n            };\n        }\n    };\n\n    BaseAxisPointer.prototype.constructor = BaseAxisPointer;\n\n\n    function updateProps(animationModel, moveAnimation, el, props) {\n        // Animation optimize.\n        if (!propsEqual(get(el).lastProp, props)) {\n            get(el).lastProp = props;\n            moveAnimation\n                ? graphic.updateProps(el, props, animationModel)\n                : (el.stopAnimation(), el.attr(props));\n        }\n    }\n\n    function propsEqual(lastProps, newProps) {\n        if (zrUtil.isObject(lastProps) && zrUtil.isObject(newProps)) {\n            var equals = true;\n            zrUtil.each(newProps, function (item, key) {\n                equals &= propsEqual(lastProps[key], item);\n            });\n            return !!equals;\n        }\n        else {\n            return lastProps === newProps;\n        }\n    }\n\n    function updateLabelShowHide(labelEl, axisPointerModel) {\n        labelEl[axisPointerModel.get('label.show') ? 'show' : 'hide']();\n    }\n\n    function getHandleTransProps(trans) {\n        return {\n            position: trans.position.slice(),\n            rotation: trans.rotation || 0\n        };\n    }\n\n    function createIcon(handleModel, handlers) {\n        var iconStr = handleModel.get('icon');\n        var style = {\n            x: -1, y: -1, width: 2, height: 2\n        };\n        var opt = zrUtil.extend({\n            style: {\n                strokeNoScale: true\n            },\n            rectHover: true,\n            cursor: 'move',\n            draggable: true\n        }, handlers);\n\n        return iconStr.indexOf('image://') === 0\n            ? (\n                style.image = iconStr.slice(8),\n                opt.style = style,\n                new graphic.Image(opt)\n            )\n            : graphic.makePath(\n                iconStr.replace('path://', ''),\n                opt,\n                style,\n                'center'\n            );\n    }\n\n    function updateMandatoryProps(group, axisPointerModel, silent) {\n        var z = axisPointerModel.get('z');\n        var zlevel = axisPointerModel.get('zlevel');\n\n        group && group.traverse(function (el) {\n            if (el.type !== 'group') {\n                z != null && (el.z = z);\n                zlevel != null && (el.zlevel = zlevel);\n                el.silent = silent;\n            }\n        });\n    }\n\n    clazzUtil.enableClassExtend(BaseAxisPointer);\n\n    module.exports = BaseAxisPointer;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQ4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2NvbXBvbmVudC9heGlzUG9pbnRlci9CYXNlQXhpc1BvaW50ZXIuanM/YzE0ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgY2xhenpVdGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9jbGF6eicpO1xuICAgIHZhciBncmFwaGljID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9ncmFwaGljJyk7XG4gICAgdmFyIGdldCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvbW9kZWwnKS5tYWtlR2V0dGVyKCk7XG4gICAgdmFyIGF4aXNQb2ludGVyTW9kZWxIZWxwZXIgPSByZXF1aXJlKCcuL21vZGVsSGVscGVyJyk7XG4gICAgdmFyIGV2ZW50VG9vbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvZXZlbnQnKTtcbiAgICB2YXIgdGhyb3R0bGUgPSByZXF1aXJlKCcuLi8uLi91dGlsL3Rocm90dGxlJyk7XG5cbiAgICB2YXIgY2xvbmUgPSB6clV0aWwuY2xvbmU7XG4gICAgdmFyIGJpbmQgPSB6clV0aWwuYmluZDtcblxuICAgIC8qKlxuICAgICAqIEJhc2UgYXhpcyBwb2ludGVyIGNsYXNzIGluIDJELlxuICAgICAqIEltcGxlbWVuZW50cyB7bW9kdWxlOmVjaGFydHMvY29tcG9uZW50L2F4aXMvSUF4aXNQb2ludGVyfS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBCYXNlQXhpc1BvaW50ZXIgKCkge1xuICAgIH1cblxuICAgIEJhc2VBeGlzUG9pbnRlci5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfZ3JvdXA6IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfbGFzdEdyYXBoaWNLZXk6IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfaGFuZGxlOiBudWxsLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX2RyYWdnaW5nOiBmYWxzZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF9sYXN0VmFsdWU6IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfbGFzdFN0YXR1czogbnVsbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF9wYXlsb2FkSW5mbzogbnVsbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSW4gcHgsIGFyYml0cmFyeSB2YWx1ZS4gRG8gbm90IHNldCB0b28gc21hbGwsXG4gICAgICAgICAqIG5vIGFuaW1hdGlvbiBpcyBvayBmb3IgbW9zdCBjYXNlcy5cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgYW5pbWF0aW9uVGhyZXNob2xkOiAxNSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQGltcGxlbWVudFxuICAgICAgICAgKi9cbiAgICAgICAgcmVuZGVyOiBmdW5jdGlvbiAoYXhpc01vZGVsLCBheGlzUG9pbnRlck1vZGVsLCBhcGksIGZvcmNlUmVuZGVyKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBheGlzUG9pbnRlck1vZGVsLmdldCgndmFsdWUnKTtcbiAgICAgICAgICAgIHZhciBzdGF0dXMgPSBheGlzUG9pbnRlck1vZGVsLmdldCgnc3RhdHVzJyk7XG5cbiAgICAgICAgICAgIC8vIEJpbmQgdGhlbSB0byBgdGhpc2AsIG5vdCBpbiBjbG9zdXJlLCBvdGhlcndpc2UgdGhleSB3aWxsIG5vdFxuICAgICAgICAgICAgLy8gYmUgcmVwbGFjZWQgd2hlbiB1c2VyIGNhbGxpbmcgc2V0T3B0aW9uIGluIG5vdCBtZXJnZSBtb2RlLlxuICAgICAgICAgICAgdGhpcy5fYXhpc01vZGVsID0gYXhpc01vZGVsO1xuICAgICAgICAgICAgdGhpcy5fYXhpc1BvaW50ZXJNb2RlbCA9IGF4aXNQb2ludGVyTW9kZWw7XG4gICAgICAgICAgICB0aGlzLl9hcGkgPSBhcGk7XG5cbiAgICAgICAgICAgIC8vIE9wdGltaXplOiBgcmVuZGVyYCB3aWxsIGJlIGNhbGxlZCByZXBlYXRseSBkdXJpbmcgbW91c2UgbW92ZS5cbiAgICAgICAgICAgIC8vIFNvIGl0IGlzIHBvd2VyIGNvbnN1bWluZyBpZiBwZXJmb3JtaW5nIGByZW5kZXJgIGVhY2ggdGltZSxcbiAgICAgICAgICAgIC8vIGVzcGVjaWFsbHkgb24gbW9iaWxlIGRldmljZS5cbiAgICAgICAgICAgIGlmICghZm9yY2VSZW5kZXJcbiAgICAgICAgICAgICAgICAmJiB0aGlzLl9sYXN0VmFsdWUgPT09IHZhbHVlXG4gICAgICAgICAgICAgICAgJiYgdGhpcy5fbGFzdFN0YXR1cyA9PT0gc3RhdHVzXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9sYXN0VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuX2xhc3RTdGF0dXMgPSBzdGF0dXM7XG5cbiAgICAgICAgICAgIHZhciBncm91cCA9IHRoaXMuX2dyb3VwO1xuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IHRoaXMuX2hhbmRsZTtcblxuICAgICAgICAgICAgaWYgKCFzdGF0dXMgfHwgc3RhdHVzID09PSAnaGlkZScpIHtcbiAgICAgICAgICAgICAgICAvLyBEbyBub3QgY2xlYXIgaGVyZSwgZm9yIGFuaW1hdGlvbiBiZXR0ZXIuXG4gICAgICAgICAgICAgICAgZ3JvdXAgJiYgZ3JvdXAuaGlkZSgpO1xuICAgICAgICAgICAgICAgIGhhbmRsZSAmJiBoYW5kbGUuaGlkZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdyb3VwICYmIGdyb3VwLnNob3coKTtcbiAgICAgICAgICAgIGhhbmRsZSAmJiBoYW5kbGUuc2hvdygpO1xuXG4gICAgICAgICAgICAvLyBPdGhlcndpc2Ugc3RhdHVzIGlzICdzaG93J1xuICAgICAgICAgICAgdmFyIGVsT3B0aW9uID0ge307XG4gICAgICAgICAgICB0aGlzLm1ha2VFbE9wdGlvbihlbE9wdGlvbiwgdmFsdWUsIGF4aXNNb2RlbCwgYXhpc1BvaW50ZXJNb2RlbCwgYXBpKTtcblxuICAgICAgICAgICAgLy8gRW5hYmxlIGNoYW5nZSBheGlzIHBvaW50ZXIgdHlwZS5cbiAgICAgICAgICAgIHZhciBncmFwaGljS2V5ID0gZWxPcHRpb24uZ3JhcGhpY0tleTtcbiAgICAgICAgICAgIGlmIChncmFwaGljS2V5ICE9PSB0aGlzLl9sYXN0R3JhcGhpY0tleSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXIoYXBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2xhc3RHcmFwaGljS2V5ID0gZ3JhcGhpY0tleTtcblxuICAgICAgICAgICAgdmFyIG1vdmVBbmltYXRpb24gPSB0aGlzLl9tb3ZlQW5pbWF0aW9uID1cbiAgICAgICAgICAgICAgICB0aGlzLmRldGVybWluZUFuaW1hdGlvbihheGlzTW9kZWwsIGF4aXNQb2ludGVyTW9kZWwpO1xuXG4gICAgICAgICAgICBpZiAoIWdyb3VwKSB7XG4gICAgICAgICAgICAgICAgZ3JvdXAgPSB0aGlzLl9ncm91cCA9IG5ldyBncmFwaGljLkdyb3VwKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVQb2ludGVyRWwoZ3JvdXAsIGVsT3B0aW9uLCBheGlzTW9kZWwsIGF4aXNQb2ludGVyTW9kZWwpO1xuICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlTGFiZWxFbChncm91cCwgZWxPcHRpb24sIGF4aXNNb2RlbCwgYXhpc1BvaW50ZXJNb2RlbCk7XG4gICAgICAgICAgICAgICAgYXBpLmdldFpyKCkuYWRkKGdyb3VwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBkb1VwZGF0ZVByb3BzID0genJVdGlsLmN1cnJ5KHVwZGF0ZVByb3BzLCBheGlzUG9pbnRlck1vZGVsLCBtb3ZlQW5pbWF0aW9uKTtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVBvaW50ZXJFbChncm91cCwgZWxPcHRpb24sIGRvVXBkYXRlUHJvcHMsIGF4aXNQb2ludGVyTW9kZWwpO1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlTGFiZWxFbChncm91cCwgZWxPcHRpb24sIGRvVXBkYXRlUHJvcHMsIGF4aXNQb2ludGVyTW9kZWwpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB1cGRhdGVNYW5kYXRvcnlQcm9wcyhncm91cCwgYXhpc1BvaW50ZXJNb2RlbCwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIHRoaXMuX3JlbmRlckhhbmRsZSh2YWx1ZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpbXBsZW1lbnRcbiAgICAgICAgICovXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gKGFwaSkge1xuICAgICAgICAgICAgdGhpcy5jbGVhcihhcGkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaW1wbGVtZW50XG4gICAgICAgICAqL1xuICAgICAgICBkaXNwb3NlOiBmdW5jdGlvbiAoYXBpKSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFyKGFwaSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGRldGVybWluZUFuaW1hdGlvbjogZnVuY3Rpb24gKGF4aXNNb2RlbCwgYXhpc1BvaW50ZXJNb2RlbCkge1xuICAgICAgICAgICAgdmFyIGFuaW1hdGlvbiA9IGF4aXNQb2ludGVyTW9kZWwuZ2V0KCdhbmltYXRpb24nKTtcbiAgICAgICAgICAgIHZhciBheGlzID0gYXhpc01vZGVsLmF4aXM7XG4gICAgICAgICAgICB2YXIgaXNDYXRlZ29yeUF4aXMgPSBheGlzLnR5cGUgPT09ICdjYXRlZ29yeSc7XG4gICAgICAgICAgICB2YXIgdXNlU25hcCA9IGF4aXNQb2ludGVyTW9kZWwuZ2V0KCdzbmFwJyk7XG5cbiAgICAgICAgICAgIC8vIFZhbHVlIGF4aXMgd2l0aG91dCBzbmFwIGFsd2F5cyBkbyBub3Qgc25hcC5cbiAgICAgICAgICAgIGlmICghdXNlU25hcCAmJiAhaXNDYXRlZ29yeUF4aXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChhbmltYXRpb24gPT09ICdhdXRvJyB8fCBhbmltYXRpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciBhbmltYXRpb25UaHJlc2hvbGQgPSB0aGlzLmFuaW1hdGlvblRocmVzaG9sZDtcbiAgICAgICAgICAgICAgICBpZiAoaXNDYXRlZ29yeUF4aXMgJiYgYXhpcy5nZXRCYW5kV2lkdGgoKSA+IGFuaW1hdGlvblRocmVzaG9sZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBJdCBpcyBpbXBvcnRhbnQgdG8gYXV0byBhbmltYXRpb24gd2hlbiBzbmFwIHVzZWQuIENvbnNpZGVyIGlmIHRoZXJlIGlzXG4gICAgICAgICAgICAgICAgLy8gYSBkYXRhWm9vbSwgYW5pbWF0aW9uIHdpbGwgYmUgZGlzYWJsZWQgd2hlbiB0b28gbWFueSBwb2ludHMgZXhpc3QsIHdoaWxlXG4gICAgICAgICAgICAgICAgLy8gaXQgd2lsbCBiZSBlbmFibGVkIGZvciBiZXR0ZXIgdmlzdWFsIGVmZmVjdCB3aGVuIGxpdHRsZSBwb2ludHMgZXhpc3QuXG4gICAgICAgICAgICAgICAgaWYgKHVzZVNuYXApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlcmllc0RhdGFDb3VudCA9IGF4aXNQb2ludGVyTW9kZWxIZWxwZXIuZ2V0QXhpc0luZm8oYXhpc01vZGVsKS5zZXJpZXNEYXRhQ291bnQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciBheGlzRXh0ZW50ID0gYXhpcy5nZXRFeHRlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQXBwcm94aW1hdGUgYmFuZCB3aWR0aFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5hYnMoYXhpc0V4dGVudFswXSAtIGF4aXNFeHRlbnRbMV0pIC8gc2VyaWVzRGF0YUNvdW50ID4gYW5pbWF0aW9uVGhyZXNob2xkO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGFuaW1hdGlvbiA9PT0gdHJ1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogYWRkIHtwb2ludGVyLCBsYWJlbCwgZ3JhcGhpY0tleX0gdG8gZWxPcHRpb25cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbWFrZUVsT3B0aW9uOiBmdW5jdGlvbiAoZWxPcHRpb24sIHZhbHVlLCBheGlzTW9kZWwsIGF4aXNQb2ludGVyTW9kZWwsIGFwaSkge1xuICAgICAgICAgICAgLy8gU2hvdWxlIGJlIGltcGxlbWVuZW50ZWQgYnkgc3ViLWNsYXNzLlxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjcmVhdGVQb2ludGVyRWw6IGZ1bmN0aW9uIChncm91cCwgZWxPcHRpb24sIGF4aXNNb2RlbCwgYXhpc1BvaW50ZXJNb2RlbCkge1xuICAgICAgICAgICAgdmFyIHBvaW50ZXJPcHRpb24gPSBlbE9wdGlvbi5wb2ludGVyO1xuICAgICAgICAgICAgaWYgKHBvaW50ZXJPcHRpb24pIHtcbiAgICAgICAgICAgICAgICB2YXIgcG9pbnRlckVsID0gZ2V0KGdyb3VwKS5wb2ludGVyRWwgPSBuZXcgZ3JhcGhpY1twb2ludGVyT3B0aW9uLnR5cGVdKFxuICAgICAgICAgICAgICAgICAgICBjbG9uZShlbE9wdGlvbi5wb2ludGVyKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgZ3JvdXAuYWRkKHBvaW50ZXJFbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNyZWF0ZUxhYmVsRWw6IGZ1bmN0aW9uIChncm91cCwgZWxPcHRpb24sIGF4aXNNb2RlbCwgYXhpc1BvaW50ZXJNb2RlbCkge1xuICAgICAgICAgICAgaWYgKGVsT3B0aW9uLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxhYmVsRWwgPSBnZXQoZ3JvdXApLmxhYmVsRWwgPSBuZXcgZ3JhcGhpYy5SZWN0KFxuICAgICAgICAgICAgICAgICAgICBjbG9uZShlbE9wdGlvbi5sYWJlbClcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgZ3JvdXAuYWRkKGxhYmVsRWwpO1xuICAgICAgICAgICAgICAgIHVwZGF0ZUxhYmVsU2hvd0hpZGUobGFiZWxFbCwgYXhpc1BvaW50ZXJNb2RlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHVwZGF0ZVBvaW50ZXJFbDogZnVuY3Rpb24gKGdyb3VwLCBlbE9wdGlvbiwgdXBkYXRlUHJvcHMpIHtcbiAgICAgICAgICAgIHZhciBwb2ludGVyRWwgPSBnZXQoZ3JvdXApLnBvaW50ZXJFbDtcbiAgICAgICAgICAgIGlmIChwb2ludGVyRWwpIHtcbiAgICAgICAgICAgICAgICBwb2ludGVyRWwuc2V0U3R5bGUoZWxPcHRpb24ucG9pbnRlci5zdHlsZSk7XG4gICAgICAgICAgICAgICAgdXBkYXRlUHJvcHMocG9pbnRlckVsLCB7c2hhcGU6IGVsT3B0aW9uLnBvaW50ZXIuc2hhcGV9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgdXBkYXRlTGFiZWxFbDogZnVuY3Rpb24gKGdyb3VwLCBlbE9wdGlvbiwgdXBkYXRlUHJvcHMsIGF4aXNQb2ludGVyTW9kZWwpIHtcbiAgICAgICAgICAgIHZhciBsYWJlbEVsID0gZ2V0KGdyb3VwKS5sYWJlbEVsO1xuICAgICAgICAgICAgaWYgKGxhYmVsRWwpIHtcbiAgICAgICAgICAgICAgICBsYWJlbEVsLnNldFN0eWxlKGVsT3B0aW9uLmxhYmVsLnN0eWxlKTtcbiAgICAgICAgICAgICAgICB1cGRhdGVQcm9wcyhsYWJlbEVsLCB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENvbnNpZGVyIHRleHQgbGVuZ3RoIGNoYW5nZSBpbiB2ZXJ0aWNhbCBheGlzLCBhbmltYXRpb24gc2hvdWxkXG4gICAgICAgICAgICAgICAgICAgIC8vIGJlIHVzZWQgb24gc2hhcGUsIG90aGVyd2lzZSB0aGUgZWZmZWN0IHdpbGwgYmUgd2VpcmQuXG4gICAgICAgICAgICAgICAgICAgIHNoYXBlOiBlbE9wdGlvbi5sYWJlbC5zaGFwZSxcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IGVsT3B0aW9uLmxhYmVsLnBvc2l0aW9uXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB1cGRhdGVMYWJlbFNob3dIaWRlKGxhYmVsRWwsIGF4aXNQb2ludGVyTW9kZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX3JlbmRlckhhbmRsZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fZHJhZ2dpbmcgfHwgIXRoaXMudXBkYXRlSGFuZGxlVHJhbnNmb3JtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgYXhpc1BvaW50ZXJNb2RlbCA9IHRoaXMuX2F4aXNQb2ludGVyTW9kZWw7XG4gICAgICAgICAgICB2YXIgenIgPSB0aGlzLl9hcGkuZ2V0WnIoKTtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSB0aGlzLl9oYW5kbGU7XG4gICAgICAgICAgICB2YXIgaGFuZGxlTW9kZWwgPSBheGlzUG9pbnRlck1vZGVsLmdldE1vZGVsKCdoYW5kbGUnKTtcblxuICAgICAgICAgICAgdmFyIHN0YXR1cyA9IGF4aXNQb2ludGVyTW9kZWwuZ2V0KCdzdGF0dXMnKTtcbiAgICAgICAgICAgIGlmICghaGFuZGxlTW9kZWwuZ2V0KCdzaG93JykgfHwgIXN0YXR1cyB8fCBzdGF0dXMgPT09ICdoaWRlJykge1xuICAgICAgICAgICAgICAgIGhhbmRsZSAmJiB6ci5yZW1vdmUoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGUgPSBudWxsO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGlzSW5pdDtcbiAgICAgICAgICAgIGlmICghdGhpcy5faGFuZGxlKSB7XG4gICAgICAgICAgICAgICAgaXNJbml0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBoYW5kbGUgPSB0aGlzLl9oYW5kbGUgPSBjcmVhdGVJY29uKGhhbmRsZU1vZGVsLCB7XG4gICAgICAgICAgICAgICAgICAgIG9ubW91c2Vtb3ZlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRm90IG1vYmlsZSBkZXZpY2VtLCBwcmV2ZW50IHNjcmVlbiBzbGlkZXIgb24gdGhlIGJ1dHRvbi5cbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50VG9vbC5zdG9wKGUuZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBvbm1vdXNlZG93bjogYmluZCh0aGlzLl9vbkhhbmRsZURyYWdNb3ZlLCB0aGlzLCAwLCAwKSxcbiAgICAgICAgICAgICAgICAgICAgZHJpZnQ6IGJpbmQodGhpcy5fb25IYW5kbGVEcmFnTW92ZSwgdGhpcyksXG4gICAgICAgICAgICAgICAgICAgIG9uZHJhZ2VuZDogYmluZCh0aGlzLl9vbkhhbmRsZURyYWdFbmQsIHRoaXMpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgenIuYWRkKGhhbmRsZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHVwZGF0ZU1hbmRhdG9yeVByb3BzKGhhbmRsZSwgYXhpc1BvaW50ZXJNb2RlbCwgZmFsc2UpO1xuXG4gICAgICAgICAgICAvLyB1cGRhdGUgc3R5bGVcbiAgICAgICAgICAgIHZhciBpbmNsdWRlU3R5bGVzID0gW1xuICAgICAgICAgICAgICAgICdjb2xvcicsICdib3JkZXJDb2xvcicsICdib3JkZXJXaWR0aCcsICdvcGFjaXR5JyxcbiAgICAgICAgICAgICAgICAnc2hhZG93Q29sb3InLCAnc2hhZG93Qmx1cicsICdzaGFkb3dPZmZzZXRYJywgJ3NoYWRvd09mZnNldFknXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgaGFuZGxlLnNldFN0eWxlKGhhbmRsZU1vZGVsLmdldEl0ZW1TdHlsZShudWxsLCBpbmNsdWRlU3R5bGVzKSk7XG5cbiAgICAgICAgICAgIC8vIHVwZGF0ZSBwb3NpdGlvblxuICAgICAgICAgICAgdmFyIGhhbmRsZVNpemUgPSBoYW5kbGVNb2RlbC5nZXQoJ3NpemUnKTtcbiAgICAgICAgICAgIGlmICghenJVdGlsLmlzQXJyYXkoaGFuZGxlU2l6ZSkpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVTaXplID0gW2hhbmRsZVNpemUsIGhhbmRsZVNpemVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGFuZGxlLmF0dHIoJ3NjYWxlJywgW2hhbmRsZVNpemVbMF0gLyAyLCBoYW5kbGVTaXplWzFdIC8gMl0pO1xuXG4gICAgICAgICAgICB0aHJvdHRsZS5jcmVhdGVPclVwZGF0ZShcbiAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgICdfZG9EaXNwYXRjaEF4aXNQb2ludGVyJyxcbiAgICAgICAgICAgICAgICBoYW5kbGVNb2RlbC5nZXQoJ3Rocm90dGxlJykgfHwgMCxcbiAgICAgICAgICAgICAgICAnZml4UmF0ZSdcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHRoaXMuX21vdmVIYW5kbGVUb1ZhbHVlKHZhbHVlLCBpc0luaXQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX21vdmVIYW5kbGVUb1ZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIGlzSW5pdCkge1xuICAgICAgICAgICAgdXBkYXRlUHJvcHMoXG4gICAgICAgICAgICAgICAgdGhpcy5fYXhpc1BvaW50ZXJNb2RlbCxcbiAgICAgICAgICAgICAgICAhaXNJbml0ICYmIHRoaXMuX21vdmVBbmltYXRpb24sXG4gICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlLFxuICAgICAgICAgICAgICAgIGdldEhhbmRsZVRyYW5zUHJvcHModGhpcy5nZXRIYW5kbGVUcmFuc2Zvcm0oXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLCB0aGlzLl9heGlzTW9kZWwsIHRoaXMuX2F4aXNQb2ludGVyTW9kZWxcbiAgICAgICAgICAgICAgICApKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF9vbkhhbmRsZURyYWdNb3ZlOiBmdW5jdGlvbiAoZHgsIGR5KSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gdGhpcy5faGFuZGxlO1xuICAgICAgICAgICAgaWYgKCFoYW5kbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX2RyYWdnaW5nID0gdHJ1ZTtcblxuICAgICAgICAgICAgLy8gUGVyc2lzdGVudCBmb3IgdGhyb3R0bGUuXG4gICAgICAgICAgICB2YXIgdHJhbnMgPSB0aGlzLnVwZGF0ZUhhbmRsZVRyYW5zZm9ybShcbiAgICAgICAgICAgICAgICBnZXRIYW5kbGVUcmFuc1Byb3BzKGhhbmRsZSksXG4gICAgICAgICAgICAgICAgW2R4LCBkeV0sXG4gICAgICAgICAgICAgICAgdGhpcy5fYXhpc01vZGVsLFxuICAgICAgICAgICAgICAgIHRoaXMuX2F4aXNQb2ludGVyTW9kZWxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aGlzLl9wYXlsb2FkSW5mbyA9IHRyYW5zO1xuXG4gICAgICAgICAgICBoYW5kbGUuc3RvcEFuaW1hdGlvbigpO1xuICAgICAgICAgICAgaGFuZGxlLmF0dHIoZ2V0SGFuZGxlVHJhbnNQcm9wcyh0cmFucykpO1xuICAgICAgICAgICAgZ2V0KGhhbmRsZSkubGFzdFByb3AgPSBudWxsO1xuXG4gICAgICAgICAgICB0aGlzLl9kb0Rpc3BhdGNoQXhpc1BvaW50ZXIoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhyb3R0bGVkIG1ldGhvZC5cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF9kb0Rpc3BhdGNoQXhpc1BvaW50ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSB0aGlzLl9oYW5kbGU7XG4gICAgICAgICAgICBpZiAoIWhhbmRsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHBheWxvYWRJbmZvID0gdGhpcy5fcGF5bG9hZEluZm87XG4gICAgICAgICAgICB2YXIgcGF5bG9hZCA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAndXBkYXRlQXhpc1BvaW50ZXInLFxuICAgICAgICAgICAgICAgIHg6IHBheWxvYWRJbmZvLmN1cnNvclBvaW50WzBdLFxuICAgICAgICAgICAgICAgIHk6IHBheWxvYWRJbmZvLmN1cnNvclBvaW50WzFdLFxuICAgICAgICAgICAgICAgIHRvb2x0aXBPcHRpb246IHBheWxvYWRJbmZvLnRvb2x0aXBPcHRpb24sXG4gICAgICAgICAgICAgICAgaGlnaERvd25LZXk6ICdheGlzUG9pbnRlckhhbmRsZSdcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgYXhpcyA9IHRoaXMuX2F4aXNNb2RlbC5heGlzO1xuICAgICAgICAgICAgcGF5bG9hZFtheGlzLmRpbSArICdBeGlzSWQnXSA9IHRoaXMuX2F4aXNNb2RlbC5pZDtcbiAgICAgICAgICAgIHRoaXMuX2FwaS5kaXNwYXRjaEFjdGlvbihwYXlsb2FkKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF9vbkhhbmRsZURyYWdFbmQ6IGZ1bmN0aW9uIChtb3ZlQW5pbWF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9kcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IHRoaXMuX2hhbmRsZTtcbiAgICAgICAgICAgIGlmICghaGFuZGxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl9heGlzUG9pbnRlck1vZGVsLmdldCgndmFsdWUnKTtcbiAgICAgICAgICAgIC8vIENvbnNpZGVyIHNuYXAgb3IgY2F0ZWdyb3kgYXhpcywgaGFuZGxlIG1heSBiZSBub3QgY29uc2lzdGVudCB3aXRoXG4gICAgICAgICAgICAvLyBheGlzUG9pbnRlci4gU28gbW92ZSBoYW5kbGUgdG8gYWxpZ24gdGhlIGV4YWN0IHZhbHVlIHBvc2l0aW9uIHdoZW5cbiAgICAgICAgICAgIC8vIGRyYWcgZW5kZWQuXG4gICAgICAgICAgICB0aGlzLl9tb3ZlSGFuZGxlVG9WYWx1ZSh2YWx1ZSk7XG5cbiAgICAgICAgICAgIC8vIEZvciB0aGUgZWZmZWN0OiB0b29sdGlwIHdpbGwgYmUgc2hvd24gd2hlbiBmaW5nZXIgaG9sZGluZyBvbiBoYW5kbGVcbiAgICAgICAgICAgIC8vIGJ1dHRvbiwgYW5kIHdpbGwgYmUgaGlkZGVuIGFmdGVyIGZpbmdlciBsZWZ0IGhhbmRsZSBidXR0b24uXG4gICAgICAgICAgICB0aGlzLl9hcGkuZGlzcGF0Y2hBY3Rpb24oe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdoaWRlVGlwJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNob3VsZCBiZSBpbXBsZW1lbmVudGVkIGJ5IHN1Yi1jbGFzcyBpZiBzdXBwb3J0IGBoYW5kbGVgLlxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBheGlzTW9kZWxcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH0gYXhpc1BvaW50ZXJNb2RlbFxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHtwb3NpdGlvbjogW3gsIHldLCByb3RhdGlvbjogMH1cbiAgICAgICAgICovXG4gICAgICAgIGdldEhhbmRsZVRyYW5zZm9ybTogbnVsbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogKiBTaG91bGQgYmUgaW1wbGVtZW5lbnRlZCBieSBzdWItY2xhc3MgaWYgc3VwcG9ydCBgaGFuZGxlYC5cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gdHJhbnNmb3JtIHtwb3NpdGlvbiwgcm90YXRpb259XG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGRlbHRhIFtkeCwgZHldXG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWx9IGF4aXNNb2RlbFxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBheGlzUG9pbnRlck1vZGVsXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH0ge3Bvc2l0aW9uOiBbeCwgeV0sIHJvdGF0aW9uOiAwLCBjdXJzb3JQb2ludDogW3gsIHldfVxuICAgICAgICAgKi9cbiAgICAgICAgdXBkYXRlSGFuZGxlVHJhbnNmb3JtOiBudWxsLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgY2xlYXI6IGZ1bmN0aW9uIChhcGkpIHtcbiAgICAgICAgICAgIHRoaXMuX2xhc3RWYWx1ZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9sYXN0U3RhdHVzID0gbnVsbDtcblxuICAgICAgICAgICAgdmFyIHpyID0gYXBpLmdldFpyKCk7XG4gICAgICAgICAgICB2YXIgZ3JvdXAgPSB0aGlzLl9ncm91cDtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSB0aGlzLl9oYW5kbGU7XG4gICAgICAgICAgICBpZiAoenIgJiYgZ3JvdXApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sYXN0R3JhcGhpY0tleSA9IG51bGw7XG4gICAgICAgICAgICAgICAgZ3JvdXAgJiYgenIucmVtb3ZlKGdyb3VwKTtcbiAgICAgICAgICAgICAgICBoYW5kbGUgJiYgenIucmVtb3ZlKGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZ3JvdXAgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGF5bG9hZEluZm8gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBkb0NsZWFyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBJbXBsZW1lbnRlZCBieSBzdWItY2xhc3MgaWYgbmVjZXNzYXJ5LlxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHh5XG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHdoXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbeERpbUluZGV4PTBdIG9yIDFcbiAgICAgICAgICovXG4gICAgICAgIGJ1aWxkTGFiZWw6IGZ1bmN0aW9uICh4eSwgd2gsIHhEaW1JbmRleCkge1xuICAgICAgICAgICAgeERpbUluZGV4ID0geERpbUluZGV4IHx8IDA7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHg6IHh5W3hEaW1JbmRleF0sXG4gICAgICAgICAgICAgICAgeTogeHlbMSAtIHhEaW1JbmRleF0sXG4gICAgICAgICAgICAgICAgd2lkdGg6IHdoW3hEaW1JbmRleF0sXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiB3aFsxIC0geERpbUluZGV4XVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBCYXNlQXhpc1BvaW50ZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQmFzZUF4aXNQb2ludGVyO1xuXG5cbiAgICBmdW5jdGlvbiB1cGRhdGVQcm9wcyhhbmltYXRpb25Nb2RlbCwgbW92ZUFuaW1hdGlvbiwgZWwsIHByb3BzKSB7XG4gICAgICAgIC8vIEFuaW1hdGlvbiBvcHRpbWl6ZS5cbiAgICAgICAgaWYgKCFwcm9wc0VxdWFsKGdldChlbCkubGFzdFByb3AsIHByb3BzKSkge1xuICAgICAgICAgICAgZ2V0KGVsKS5sYXN0UHJvcCA9IHByb3BzO1xuICAgICAgICAgICAgbW92ZUFuaW1hdGlvblxuICAgICAgICAgICAgICAgID8gZ3JhcGhpYy51cGRhdGVQcm9wcyhlbCwgcHJvcHMsIGFuaW1hdGlvbk1vZGVsKVxuICAgICAgICAgICAgICAgIDogKGVsLnN0b3BBbmltYXRpb24oKSwgZWwuYXR0cihwcm9wcykpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJvcHNFcXVhbChsYXN0UHJvcHMsIG5ld1Byb3BzKSB7XG4gICAgICAgIGlmICh6clV0aWwuaXNPYmplY3QobGFzdFByb3BzKSAmJiB6clV0aWwuaXNPYmplY3QobmV3UHJvcHMpKSB7XG4gICAgICAgICAgICB2YXIgZXF1YWxzID0gdHJ1ZTtcbiAgICAgICAgICAgIHpyVXRpbC5lYWNoKG5ld1Byb3BzLCBmdW5jdGlvbiAoaXRlbSwga2V5KSB7XG4gICAgICAgICAgICAgICAgZXF1YWxzICY9IHByb3BzRXF1YWwobGFzdFByb3BzW2tleV0sIGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gISFlcXVhbHM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbGFzdFByb3BzID09PSBuZXdQcm9wcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVwZGF0ZUxhYmVsU2hvd0hpZGUobGFiZWxFbCwgYXhpc1BvaW50ZXJNb2RlbCkge1xuICAgICAgICBsYWJlbEVsW2F4aXNQb2ludGVyTW9kZWwuZ2V0KCdsYWJlbC5zaG93JykgPyAnc2hvdycgOiAnaGlkZSddKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0SGFuZGxlVHJhbnNQcm9wcyh0cmFucykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcG9zaXRpb246IHRyYW5zLnBvc2l0aW9uLnNsaWNlKCksXG4gICAgICAgICAgICByb3RhdGlvbjogdHJhbnMucm90YXRpb24gfHwgMFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUljb24oaGFuZGxlTW9kZWwsIGhhbmRsZXJzKSB7XG4gICAgICAgIHZhciBpY29uU3RyID0gaGFuZGxlTW9kZWwuZ2V0KCdpY29uJyk7XG4gICAgICAgIHZhciBzdHlsZSA9IHtcbiAgICAgICAgICAgIHg6IC0xLCB5OiAtMSwgd2lkdGg6IDIsIGhlaWdodDogMlxuICAgICAgICB9O1xuICAgICAgICB2YXIgb3B0ID0genJVdGlsLmV4dGVuZCh7XG4gICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgIHN0cm9rZU5vU2NhbGU6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZWN0SG92ZXI6IHRydWUsXG4gICAgICAgICAgICBjdXJzb3I6ICdtb3ZlJyxcbiAgICAgICAgICAgIGRyYWdnYWJsZTogdHJ1ZVxuICAgICAgICB9LCBoYW5kbGVycyk7XG5cbiAgICAgICAgcmV0dXJuIGljb25TdHIuaW5kZXhPZignaW1hZ2U6Ly8nKSA9PT0gMFxuICAgICAgICAgICAgPyAoXG4gICAgICAgICAgICAgICAgc3R5bGUuaW1hZ2UgPSBpY29uU3RyLnNsaWNlKDgpLFxuICAgICAgICAgICAgICAgIG9wdC5zdHlsZSA9IHN0eWxlLFxuICAgICAgICAgICAgICAgIG5ldyBncmFwaGljLkltYWdlKG9wdClcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIDogZ3JhcGhpYy5tYWtlUGF0aChcbiAgICAgICAgICAgICAgICBpY29uU3RyLnJlcGxhY2UoJ3BhdGg6Ly8nLCAnJyksXG4gICAgICAgICAgICAgICAgb3B0LFxuICAgICAgICAgICAgICAgIHN0eWxlLFxuICAgICAgICAgICAgICAgICdjZW50ZXInXG4gICAgICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVwZGF0ZU1hbmRhdG9yeVByb3BzKGdyb3VwLCBheGlzUG9pbnRlck1vZGVsLCBzaWxlbnQpIHtcbiAgICAgICAgdmFyIHogPSBheGlzUG9pbnRlck1vZGVsLmdldCgneicpO1xuICAgICAgICB2YXIgemxldmVsID0gYXhpc1BvaW50ZXJNb2RlbC5nZXQoJ3psZXZlbCcpO1xuXG4gICAgICAgIGdyb3VwICYmIGdyb3VwLnRyYXZlcnNlKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgaWYgKGVsLnR5cGUgIT09ICdncm91cCcpIHtcbiAgICAgICAgICAgICAgICB6ICE9IG51bGwgJiYgKGVsLnogPSB6KTtcbiAgICAgICAgICAgICAgICB6bGV2ZWwgIT0gbnVsbCAmJiAoZWwuemxldmVsID0gemxldmVsKTtcbiAgICAgICAgICAgICAgICBlbC5zaWxlbnQgPSBzaWxlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGNsYXp6VXRpbC5lbmFibGVDbGFzc0V4dGVuZChCYXNlQXhpc1BvaW50ZXIpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBCYXNlQXhpc1BvaW50ZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9jb21wb25lbnQvYXhpc1BvaW50ZXIvQmFzZUF4aXNQb2ludGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 149 */
/* unknown exports provided */
/* all exports used */
/*!***********************************************************!*\
  !*** ./lib/component/axisPointer/CartesianAxisPointer.js ***!
  \***********************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\n    var graphic = __webpack_require__(/*! ../../util/graphic */ 2);\n    var BaseAxisPointer = __webpack_require__(/*! ./BaseAxisPointer */ 148);\n    var viewHelper = __webpack_require__(/*! ./viewHelper */ 81);\n    var cartesianAxisHelper = __webpack_require__(/*! ../axis/cartesianAxisHelper */ 80);\n    var AxisView = __webpack_require__(/*! ../axis/AxisView */ 40);\n\n    var CartesianAxisPointer = BaseAxisPointer.extend({\n\n        /**\n         * @override\n         */\n        makeElOption: function (elOption, value, axisModel, axisPointerModel, api) {\n            var axis = axisModel.axis;\n            var grid = axis.grid;\n            var axisPointerType = axisPointerModel.get('type');\n            var otherExtent = getCartesian(grid, axis).getOtherAxis(axis).getGlobalExtent();\n            var pixelValue = axis.toGlobalCoord(axis.dataToCoord(value, true));\n\n            if (axisPointerType && axisPointerType !== 'none') {\n                var elStyle = viewHelper.buildElStyle(axisPointerModel);\n                var pointerOption = pointerShapeBuilder[axisPointerType](\n                    axis, pixelValue, otherExtent, elStyle\n                );\n                pointerOption.style = elStyle;\n                elOption.graphicKey = pointerOption.type;\n                elOption.pointer = pointerOption;\n            }\n\n            var layoutInfo = cartesianAxisHelper.layout(grid.model, axisModel);\n            viewHelper.buildCartesianSingleLabelElOption(\n                value, elOption, layoutInfo, axisModel, axisPointerModel, api\n            );\n        },\n\n        /**\n         * @override\n         */\n        getHandleTransform: function (value, axisModel, axisPointerModel) {\n            var layoutInfo = cartesianAxisHelper.layout(axisModel.axis.grid.model, axisModel, {\n                labelInside: false\n            });\n            layoutInfo.labelMargin = axisPointerModel.get('handle.margin');\n            return {\n                position: viewHelper.getTransformedPosition(axisModel.axis, value, layoutInfo),\n                rotation: layoutInfo.rotation + (layoutInfo.labelDirection < 0 ? Math.PI : 0)\n            };\n        },\n\n        /**\n         * @override\n         */\n        updateHandleTransform: function (transform, delta, axisModel, axisPointerModel) {\n            var axis = axisModel.axis;\n            var grid = axis.grid;\n            var axisExtent = axis.getGlobalExtent(true);\n            var otherExtent = getCartesian(grid, axis).getOtherAxis(axis).getGlobalExtent();\n            var dimIndex = axis.dim === 'x' ? 0 : 1;\n\n            var currPosition = transform.position;\n            currPosition[dimIndex] += delta[dimIndex];\n            currPosition[dimIndex] = Math.min(axisExtent[1], currPosition[dimIndex]);\n            currPosition[dimIndex] = Math.max(axisExtent[0], currPosition[dimIndex]);\n\n            var cursorOtherValue = (otherExtent[1] + otherExtent[0]) / 2;\n            var cursorPoint = [cursorOtherValue, cursorOtherValue];\n            cursorPoint[dimIndex] = currPosition[dimIndex];\n\n            // Make tooltip do not overlap axisPointer and in the middle of the grid.\n            var tooltipOptions = [{verticalAlign: 'middle'}, {align: 'center'}];\n\n            return {\n                position: currPosition,\n                rotation: transform.rotation,\n                cursorPoint: cursorPoint,\n                tooltipOption: tooltipOptions[dimIndex]\n            };\n        }\n\n    });\n\n    function getCartesian(grid, axis) {\n        var opt = {};\n        opt[axis.dim + 'AxisIndex'] = axis.index;\n        return grid.getCartesian(opt);\n    }\n\n    var pointerShapeBuilder = {\n\n        line: function (axis, pixelValue, otherExtent, elStyle) {\n            var targetShape = viewHelper.makeLineShape(\n                [pixelValue, otherExtent[0]],\n                [pixelValue, otherExtent[1]],\n                getAxisDimIndex(axis)\n            );\n            graphic.subPixelOptimizeLine({\n                shape: targetShape,\n                style: elStyle\n            });\n            return {\n                type: 'Line',\n                shape: targetShape\n            };\n        },\n\n        shadow: function (axis, pixelValue, otherExtent, elStyle) {\n            var bandWidth = axis.getBandWidth();\n            var span = otherExtent[1] - otherExtent[0];\n            return {\n                type: 'Rect',\n                shape: viewHelper.makeRectShape(\n                    [pixelValue - bandWidth / 2, otherExtent[0]],\n                    [bandWidth, span],\n                    getAxisDimIndex(axis)\n                )\n            };\n        }\n    };\n\n    function getAxisDimIndex(axis) {\n        return axis.dim === 'x' ? 0 : 1;\n    }\n\n    AxisView.registerAxisPointerClass('CartesianAxisPointer', CartesianAxisPointer);\n\n    module.exports = CartesianAxisPointer;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQ5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2NvbXBvbmVudC9heGlzUG9pbnRlci9DYXJ0ZXNpYW5BeGlzUG9pbnRlci5qcz8xMzczIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuXG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKCcuLi8uLi91dGlsL2dyYXBoaWMnKTtcbiAgICB2YXIgQmFzZUF4aXNQb2ludGVyID0gcmVxdWlyZSgnLi9CYXNlQXhpc1BvaW50ZXInKTtcbiAgICB2YXIgdmlld0hlbHBlciA9IHJlcXVpcmUoJy4vdmlld0hlbHBlcicpO1xuICAgIHZhciBjYXJ0ZXNpYW5BeGlzSGVscGVyID0gcmVxdWlyZSgnLi4vYXhpcy9jYXJ0ZXNpYW5BeGlzSGVscGVyJyk7XG4gICAgdmFyIEF4aXNWaWV3ID0gcmVxdWlyZSgnLi4vYXhpcy9BeGlzVmlldycpO1xuXG4gICAgdmFyIENhcnRlc2lhbkF4aXNQb2ludGVyID0gQmFzZUF4aXNQb2ludGVyLmV4dGVuZCh7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICAgKi9cbiAgICAgICAgbWFrZUVsT3B0aW9uOiBmdW5jdGlvbiAoZWxPcHRpb24sIHZhbHVlLCBheGlzTW9kZWwsIGF4aXNQb2ludGVyTW9kZWwsIGFwaSkge1xuICAgICAgICAgICAgdmFyIGF4aXMgPSBheGlzTW9kZWwuYXhpcztcbiAgICAgICAgICAgIHZhciBncmlkID0gYXhpcy5ncmlkO1xuICAgICAgICAgICAgdmFyIGF4aXNQb2ludGVyVHlwZSA9IGF4aXNQb2ludGVyTW9kZWwuZ2V0KCd0eXBlJyk7XG4gICAgICAgICAgICB2YXIgb3RoZXJFeHRlbnQgPSBnZXRDYXJ0ZXNpYW4oZ3JpZCwgYXhpcykuZ2V0T3RoZXJBeGlzKGF4aXMpLmdldEdsb2JhbEV4dGVudCgpO1xuICAgICAgICAgICAgdmFyIHBpeGVsVmFsdWUgPSBheGlzLnRvR2xvYmFsQ29vcmQoYXhpcy5kYXRhVG9Db29yZCh2YWx1ZSwgdHJ1ZSkpO1xuXG4gICAgICAgICAgICBpZiAoYXhpc1BvaW50ZXJUeXBlICYmIGF4aXNQb2ludGVyVHlwZSAhPT0gJ25vbmUnKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsU3R5bGUgPSB2aWV3SGVscGVyLmJ1aWxkRWxTdHlsZShheGlzUG9pbnRlck1vZGVsKTtcbiAgICAgICAgICAgICAgICB2YXIgcG9pbnRlck9wdGlvbiA9IHBvaW50ZXJTaGFwZUJ1aWxkZXJbYXhpc1BvaW50ZXJUeXBlXShcbiAgICAgICAgICAgICAgICAgICAgYXhpcywgcGl4ZWxWYWx1ZSwgb3RoZXJFeHRlbnQsIGVsU3R5bGVcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHBvaW50ZXJPcHRpb24uc3R5bGUgPSBlbFN0eWxlO1xuICAgICAgICAgICAgICAgIGVsT3B0aW9uLmdyYXBoaWNLZXkgPSBwb2ludGVyT3B0aW9uLnR5cGU7XG4gICAgICAgICAgICAgICAgZWxPcHRpb24ucG9pbnRlciA9IHBvaW50ZXJPcHRpb247XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBsYXlvdXRJbmZvID0gY2FydGVzaWFuQXhpc0hlbHBlci5sYXlvdXQoZ3JpZC5tb2RlbCwgYXhpc01vZGVsKTtcbiAgICAgICAgICAgIHZpZXdIZWxwZXIuYnVpbGRDYXJ0ZXNpYW5TaW5nbGVMYWJlbEVsT3B0aW9uKFxuICAgICAgICAgICAgICAgIHZhbHVlLCBlbE9wdGlvbiwgbGF5b3V0SW5mbywgYXhpc01vZGVsLCBheGlzUG9pbnRlck1vZGVsLCBhcGlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0SGFuZGxlVHJhbnNmb3JtOiBmdW5jdGlvbiAodmFsdWUsIGF4aXNNb2RlbCwgYXhpc1BvaW50ZXJNb2RlbCkge1xuICAgICAgICAgICAgdmFyIGxheW91dEluZm8gPSBjYXJ0ZXNpYW5BeGlzSGVscGVyLmxheW91dChheGlzTW9kZWwuYXhpcy5ncmlkLm1vZGVsLCBheGlzTW9kZWwsIHtcbiAgICAgICAgICAgICAgICBsYWJlbEluc2lkZTogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGF5b3V0SW5mby5sYWJlbE1hcmdpbiA9IGF4aXNQb2ludGVyTW9kZWwuZ2V0KCdoYW5kbGUubWFyZ2luJyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiB2aWV3SGVscGVyLmdldFRyYW5zZm9ybWVkUG9zaXRpb24oYXhpc01vZGVsLmF4aXMsIHZhbHVlLCBsYXlvdXRJbmZvKSxcbiAgICAgICAgICAgICAgICByb3RhdGlvbjogbGF5b3V0SW5mby5yb3RhdGlvbiArIChsYXlvdXRJbmZvLmxhYmVsRGlyZWN0aW9uIDwgMCA/IE1hdGguUEkgOiAwKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgICAqL1xuICAgICAgICB1cGRhdGVIYW5kbGVUcmFuc2Zvcm06IGZ1bmN0aW9uICh0cmFuc2Zvcm0sIGRlbHRhLCBheGlzTW9kZWwsIGF4aXNQb2ludGVyTW9kZWwpIHtcbiAgICAgICAgICAgIHZhciBheGlzID0gYXhpc01vZGVsLmF4aXM7XG4gICAgICAgICAgICB2YXIgZ3JpZCA9IGF4aXMuZ3JpZDtcbiAgICAgICAgICAgIHZhciBheGlzRXh0ZW50ID0gYXhpcy5nZXRHbG9iYWxFeHRlbnQodHJ1ZSk7XG4gICAgICAgICAgICB2YXIgb3RoZXJFeHRlbnQgPSBnZXRDYXJ0ZXNpYW4oZ3JpZCwgYXhpcykuZ2V0T3RoZXJBeGlzKGF4aXMpLmdldEdsb2JhbEV4dGVudCgpO1xuICAgICAgICAgICAgdmFyIGRpbUluZGV4ID0gYXhpcy5kaW0gPT09ICd4JyA/IDAgOiAxO1xuXG4gICAgICAgICAgICB2YXIgY3VyclBvc2l0aW9uID0gdHJhbnNmb3JtLnBvc2l0aW9uO1xuICAgICAgICAgICAgY3VyclBvc2l0aW9uW2RpbUluZGV4XSArPSBkZWx0YVtkaW1JbmRleF07XG4gICAgICAgICAgICBjdXJyUG9zaXRpb25bZGltSW5kZXhdID0gTWF0aC5taW4oYXhpc0V4dGVudFsxXSwgY3VyclBvc2l0aW9uW2RpbUluZGV4XSk7XG4gICAgICAgICAgICBjdXJyUG9zaXRpb25bZGltSW5kZXhdID0gTWF0aC5tYXgoYXhpc0V4dGVudFswXSwgY3VyclBvc2l0aW9uW2RpbUluZGV4XSk7XG5cbiAgICAgICAgICAgIHZhciBjdXJzb3JPdGhlclZhbHVlID0gKG90aGVyRXh0ZW50WzFdICsgb3RoZXJFeHRlbnRbMF0pIC8gMjtcbiAgICAgICAgICAgIHZhciBjdXJzb3JQb2ludCA9IFtjdXJzb3JPdGhlclZhbHVlLCBjdXJzb3JPdGhlclZhbHVlXTtcbiAgICAgICAgICAgIGN1cnNvclBvaW50W2RpbUluZGV4XSA9IGN1cnJQb3NpdGlvbltkaW1JbmRleF07XG5cbiAgICAgICAgICAgIC8vIE1ha2UgdG9vbHRpcCBkbyBub3Qgb3ZlcmxhcCBheGlzUG9pbnRlciBhbmQgaW4gdGhlIG1pZGRsZSBvZiB0aGUgZ3JpZC5cbiAgICAgICAgICAgIHZhciB0b29sdGlwT3B0aW9ucyA9IFt7dmVydGljYWxBbGlnbjogJ21pZGRsZSd9LCB7YWxpZ246ICdjZW50ZXInfV07XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb246IGN1cnJQb3NpdGlvbixcbiAgICAgICAgICAgICAgICByb3RhdGlvbjogdHJhbnNmb3JtLnJvdGF0aW9uLFxuICAgICAgICAgICAgICAgIGN1cnNvclBvaW50OiBjdXJzb3JQb2ludCxcbiAgICAgICAgICAgICAgICB0b29sdGlwT3B0aW9uOiB0b29sdGlwT3B0aW9uc1tkaW1JbmRleF1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gZ2V0Q2FydGVzaWFuKGdyaWQsIGF4aXMpIHtcbiAgICAgICAgdmFyIG9wdCA9IHt9O1xuICAgICAgICBvcHRbYXhpcy5kaW0gKyAnQXhpc0luZGV4J10gPSBheGlzLmluZGV4O1xuICAgICAgICByZXR1cm4gZ3JpZC5nZXRDYXJ0ZXNpYW4ob3B0KTtcbiAgICB9XG5cbiAgICB2YXIgcG9pbnRlclNoYXBlQnVpbGRlciA9IHtcblxuICAgICAgICBsaW5lOiBmdW5jdGlvbiAoYXhpcywgcGl4ZWxWYWx1ZSwgb3RoZXJFeHRlbnQsIGVsU3R5bGUpIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXRTaGFwZSA9IHZpZXdIZWxwZXIubWFrZUxpbmVTaGFwZShcbiAgICAgICAgICAgICAgICBbcGl4ZWxWYWx1ZSwgb3RoZXJFeHRlbnRbMF1dLFxuICAgICAgICAgICAgICAgIFtwaXhlbFZhbHVlLCBvdGhlckV4dGVudFsxXV0sXG4gICAgICAgICAgICAgICAgZ2V0QXhpc0RpbUluZGV4KGF4aXMpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZ3JhcGhpYy5zdWJQaXhlbE9wdGltaXplTGluZSh7XG4gICAgICAgICAgICAgICAgc2hhcGU6IHRhcmdldFNoYXBlLFxuICAgICAgICAgICAgICAgIHN0eWxlOiBlbFN0eWxlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ0xpbmUnLFxuICAgICAgICAgICAgICAgIHNoYXBlOiB0YXJnZXRTaGFwZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICBzaGFkb3c6IGZ1bmN0aW9uIChheGlzLCBwaXhlbFZhbHVlLCBvdGhlckV4dGVudCwgZWxTdHlsZSkge1xuICAgICAgICAgICAgdmFyIGJhbmRXaWR0aCA9IGF4aXMuZ2V0QmFuZFdpZHRoKCk7XG4gICAgICAgICAgICB2YXIgc3BhbiA9IG90aGVyRXh0ZW50WzFdIC0gb3RoZXJFeHRlbnRbMF07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdSZWN0JyxcbiAgICAgICAgICAgICAgICBzaGFwZTogdmlld0hlbHBlci5tYWtlUmVjdFNoYXBlKFxuICAgICAgICAgICAgICAgICAgICBbcGl4ZWxWYWx1ZSAtIGJhbmRXaWR0aCAvIDIsIG90aGVyRXh0ZW50WzBdXSxcbiAgICAgICAgICAgICAgICAgICAgW2JhbmRXaWR0aCwgc3Bhbl0sXG4gICAgICAgICAgICAgICAgICAgIGdldEF4aXNEaW1JbmRleChheGlzKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZ2V0QXhpc0RpbUluZGV4KGF4aXMpIHtcbiAgICAgICAgcmV0dXJuIGF4aXMuZGltID09PSAneCcgPyAwIDogMTtcbiAgICB9XG5cbiAgICBBeGlzVmlldy5yZWdpc3RlckF4aXNQb2ludGVyQ2xhc3MoJ0NhcnRlc2lhbkF4aXNQb2ludGVyJywgQ2FydGVzaWFuQXhpc1BvaW50ZXIpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBDYXJ0ZXNpYW5BeGlzUG9pbnRlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2NvbXBvbmVudC9heGlzUG9pbnRlci9DYXJ0ZXNpYW5BeGlzUG9pbnRlci5qc1xuLy8gbW9kdWxlIGlkID0gMTQ5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 150 */
/* unknown exports provided */
/* all exports used */
/*!**********************************************************!*\
  !*** ./lib/component/axisPointer/findPointFromSeries.js ***!
  \**********************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 0);\n    var modelUtil = __webpack_require__(/*! ../../util/model */ 5);\n\n    /**\n     * @param {Object} finder contains {seriesIndex, dataIndex, dataIndexInside}\n     * @param {module:echarts/model/Global} ecModel\n     * @return {Object} {point: [x, y], el: ...} point Will not be null.\n     */\n    module.exports = function (finder, ecModel) {\n        var point = [];\n        var seriesIndex = finder.seriesIndex;\n        var seriesModel;\n        if (seriesIndex == null || !(\n            seriesModel = ecModel.getSeriesByIndex(seriesIndex)\n        )) {\n            return {point: []};\n        }\n\n        var data = seriesModel.getData();\n        var dataIndex = modelUtil.queryDataIndex(data, finder);\n        if (dataIndex == null || zrUtil.isArray(dataIndex)) {\n            return {point: []};\n        }\n\n        var el = data.getItemGraphicEl(dataIndex);\n        var coordSys = seriesModel.coordinateSystem;\n\n        if (seriesModel.getTooltipPosition) {\n            point = seriesModel.getTooltipPosition(dataIndex) || [];\n        }\n        else if (coordSys && coordSys.dataToPoint) {\n            point = coordSys.dataToPoint(\n                data.getValues(\n                    zrUtil.map(coordSys.dimensions, function (dim) {\n                        return seriesModel.coordDimToDataDim(dim)[0];\n                    }), dataIndex, true\n                )\n            ) || [];\n        }\n        else if (el) {\n            // Use graphic bounding rect\n            var rect = el.getBoundingRect().clone();\n            rect.applyTransform(el.transform);\n            point = [\n                rect.x + rect.width / 2,\n                rect.y + rect.height / 2\n            ];\n        }\n\n        return {point: point, el: el};\n    };\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTUwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2NvbXBvbmVudC9heGlzUG9pbnRlci9maW5kUG9pbnRGcm9tU2VyaWVzLmpzPzQ4MWYiXSwic291cmNlc0NvbnRlbnQiOlsiXG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG4gICAgdmFyIG1vZGVsVXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvbW9kZWwnKTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBmaW5kZXIgY29udGFpbnMge3Nlcmllc0luZGV4LCBkYXRhSW5kZXgsIGRhdGFJbmRleEluc2lkZX1cbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL0dsb2JhbH0gZWNNb2RlbFxuICAgICAqIEByZXR1cm4ge09iamVjdH0ge3BvaW50OiBbeCwgeV0sIGVsOiAuLi59IHBvaW50IFdpbGwgbm90IGJlIG51bGwuXG4gICAgICovXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZmluZGVyLCBlY01vZGVsKSB7XG4gICAgICAgIHZhciBwb2ludCA9IFtdO1xuICAgICAgICB2YXIgc2VyaWVzSW5kZXggPSBmaW5kZXIuc2VyaWVzSW5kZXg7XG4gICAgICAgIHZhciBzZXJpZXNNb2RlbDtcbiAgICAgICAgaWYgKHNlcmllc0luZGV4ID09IG51bGwgfHwgIShcbiAgICAgICAgICAgIHNlcmllc01vZGVsID0gZWNNb2RlbC5nZXRTZXJpZXNCeUluZGV4KHNlcmllc0luZGV4KVxuICAgICAgICApKSB7XG4gICAgICAgICAgICByZXR1cm4ge3BvaW50OiBbXX07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICAgICAgdmFyIGRhdGFJbmRleCA9IG1vZGVsVXRpbC5xdWVyeURhdGFJbmRleChkYXRhLCBmaW5kZXIpO1xuICAgICAgICBpZiAoZGF0YUluZGV4ID09IG51bGwgfHwgenJVdGlsLmlzQXJyYXkoZGF0YUluZGV4KSkge1xuICAgICAgICAgICAgcmV0dXJuIHtwb2ludDogW119O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVsID0gZGF0YS5nZXRJdGVtR3JhcGhpY0VsKGRhdGFJbmRleCk7XG4gICAgICAgIHZhciBjb29yZFN5cyA9IHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG5cbiAgICAgICAgaWYgKHNlcmllc01vZGVsLmdldFRvb2x0aXBQb3NpdGlvbikge1xuICAgICAgICAgICAgcG9pbnQgPSBzZXJpZXNNb2RlbC5nZXRUb29sdGlwUG9zaXRpb24oZGF0YUluZGV4KSB8fCBbXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb29yZFN5cyAmJiBjb29yZFN5cy5kYXRhVG9Qb2ludCkge1xuICAgICAgICAgICAgcG9pbnQgPSBjb29yZFN5cy5kYXRhVG9Qb2ludChcbiAgICAgICAgICAgICAgICBkYXRhLmdldFZhbHVlcyhcbiAgICAgICAgICAgICAgICAgICAgenJVdGlsLm1hcChjb29yZFN5cy5kaW1lbnNpb25zLCBmdW5jdGlvbiAoZGltKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VyaWVzTW9kZWwuY29vcmREaW1Ub0RhdGFEaW0oZGltKVswXTtcbiAgICAgICAgICAgICAgICAgICAgfSksIGRhdGFJbmRleCwgdHJ1ZVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICkgfHwgW107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZWwpIHtcbiAgICAgICAgICAgIC8vIFVzZSBncmFwaGljIGJvdW5kaW5nIHJlY3RcbiAgICAgICAgICAgIHZhciByZWN0ID0gZWwuZ2V0Qm91bmRpbmdSZWN0KCkuY2xvbmUoKTtcbiAgICAgICAgICAgIHJlY3QuYXBwbHlUcmFuc2Zvcm0oZWwudHJhbnNmb3JtKTtcbiAgICAgICAgICAgIHBvaW50ID0gW1xuICAgICAgICAgICAgICAgIHJlY3QueCArIHJlY3Qud2lkdGggLyAyLFxuICAgICAgICAgICAgICAgIHJlY3QueSArIHJlY3QuaGVpZ2h0IC8gMlxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7cG9pbnQ6IHBvaW50LCBlbDogZWx9O1xuICAgIH07XG5cblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvY29tcG9uZW50L2F4aXNQb2ludGVyL2ZpbmRQb2ludEZyb21TZXJpZXMuanNcbi8vIG1vZHVsZSBpZCA9IDE1MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 151 */
/* unknown exports provided */
/* all exports used */
/*!*****************************************************!*\
  !*** ./lib/component/axisPointer/globalListener.js ***!
  \*****************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var env = __webpack_require__(/*! zrender/lib/core/env */ 8);\n    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 0);\n    var get = __webpack_require__(/*! ../../util/model */ 5).makeGetter();\n\n    var each = zrUtil.each;\n\n    var globalListener = {};\n\n    /**\n     * @param {string} key\n     * @param {module:echarts/ExtensionAPI} api\n     * @param {Function} handler\n     *      param: {string} currTrigger\n     *      param: {Array.<number>} point\n     */\n    globalListener.register = function (key, api, handler) {\n        if (env.node) {\n            return;\n        }\n\n        var zr = api.getZr();\n        get(zr).records || (get(zr).records = {});\n\n        initGlobalListeners(zr, api);\n\n        var record = get(zr).records[key] || (get(zr).records[key] = {});\n        record.handler = handler;\n    };\n\n    function initGlobalListeners(zr, api) {\n        if (get(zr).initialized) {\n            return;\n        }\n\n        get(zr).initialized = true;\n\n        useHandler('click', zrUtil.curry(doEnter, 'click'));\n        useHandler('mousemove', zrUtil.curry(doEnter, 'mousemove'));\n        // useHandler('mouseout', onLeave);\n        useHandler('globalout', onLeave);\n\n        function useHandler(eventType, cb) {\n            zr.on(eventType, function (e) {\n                var dis = makeDispatchAction(api);\n\n                each(get(zr).records, function (record) {\n                    record && cb(record, e, dis.dispatchAction);\n                });\n\n                dispatchTooltipFinally(dis.pendings, api);\n            });\n        }\n    }\n\n    function dispatchTooltipFinally(pendings, api) {\n        var showLen = pendings.showTip.length;\n        var hideLen = pendings.hideTip.length;\n\n        var actuallyPayload;\n        if (showLen) {\n            actuallyPayload = pendings.showTip[showLen - 1];\n        }\n        else if (hideLen) {\n            actuallyPayload = pendings.hideTip[hideLen - 1];\n        }\n        if (actuallyPayload) {\n            actuallyPayload.dispatchAction = null;\n            api.dispatchAction(actuallyPayload);\n        }\n    }\n\n    function onLeave(record, e, dispatchAction) {\n        record.handler('leave', null, dispatchAction);\n    }\n\n    function doEnter(currTrigger, record, e, dispatchAction) {\n        record.handler(currTrigger, e, dispatchAction);\n    }\n\n    function makeDispatchAction(api) {\n        var pendings = {\n            showTip: [],\n            hideTip: []\n        };\n        // FIXME\n        // better approach?\n        // 'showTip' and 'hideTip' can be triggered by axisPointer and tooltip,\n        // which may be conflict, (axisPointer call showTip but tooltip call hideTip);\n        // So we have to add \"final stage\" to merge those dispatched actions.\n        var dispatchAction = function (payload) {\n            var pendingList = pendings[payload.type];\n            if (pendingList) {\n                pendingList.push(payload);\n            }\n            else {\n                payload.dispatchAction = dispatchAction;\n                api.dispatchAction(payload);\n            }\n        };\n\n        return {\n            dispatchAction: dispatchAction,\n            pendings: pendings\n        };\n    }\n\n    /**\n     * @param {string} key\n     * @param {module:echarts/ExtensionAPI} api\n     */\n    globalListener.unregister = function (key, api) {\n        if (env.node) {\n            return;\n        }\n        var zr = api.getZr();\n        var record = (get(zr).records || {})[key];\n        if (record) {\n            get(zr).records[key] = null;\n        }\n    };\n\n    module.exports = globalListener;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTUxLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2NvbXBvbmVudC9heGlzUG9pbnRlci9nbG9iYWxMaXN0ZW5lci5qcz80YWRlIl0sInNvdXJjZXNDb250ZW50IjpbIlxuXG4gICAgdmFyIGVudiA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvZW52Jyk7XG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuICAgIHZhciBnZXQgPSByZXF1aXJlKCcuLi8uLi91dGlsL21vZGVsJykubWFrZUdldHRlcigpO1xuXG4gICAgdmFyIGVhY2ggPSB6clV0aWwuZWFjaDtcblxuICAgIHZhciBnbG9iYWxMaXN0ZW5lciA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvRXh0ZW5zaW9uQVBJfSBhcGlcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAgICogICAgICBwYXJhbToge3N0cmluZ30gY3VyclRyaWdnZXJcbiAgICAgKiAgICAgIHBhcmFtOiB7QXJyYXkuPG51bWJlcj59IHBvaW50XG4gICAgICovXG4gICAgZ2xvYmFsTGlzdGVuZXIucmVnaXN0ZXIgPSBmdW5jdGlvbiAoa2V5LCBhcGksIGhhbmRsZXIpIHtcbiAgICAgICAgaWYgKGVudi5ub2RlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgenIgPSBhcGkuZ2V0WnIoKTtcbiAgICAgICAgZ2V0KHpyKS5yZWNvcmRzIHx8IChnZXQoenIpLnJlY29yZHMgPSB7fSk7XG5cbiAgICAgICAgaW5pdEdsb2JhbExpc3RlbmVycyh6ciwgYXBpKTtcblxuICAgICAgICB2YXIgcmVjb3JkID0gZ2V0KHpyKS5yZWNvcmRzW2tleV0gfHwgKGdldCh6cikucmVjb3Jkc1trZXldID0ge30pO1xuICAgICAgICByZWNvcmQuaGFuZGxlciA9IGhhbmRsZXI7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGluaXRHbG9iYWxMaXN0ZW5lcnMoenIsIGFwaSkge1xuICAgICAgICBpZiAoZ2V0KHpyKS5pbml0aWFsaXplZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2V0KHpyKS5pbml0aWFsaXplZCA9IHRydWU7XG5cbiAgICAgICAgdXNlSGFuZGxlcignY2xpY2snLCB6clV0aWwuY3VycnkoZG9FbnRlciwgJ2NsaWNrJykpO1xuICAgICAgICB1c2VIYW5kbGVyKCdtb3VzZW1vdmUnLCB6clV0aWwuY3VycnkoZG9FbnRlciwgJ21vdXNlbW92ZScpKTtcbiAgICAgICAgLy8gdXNlSGFuZGxlcignbW91c2VvdXQnLCBvbkxlYXZlKTtcbiAgICAgICAgdXNlSGFuZGxlcignZ2xvYmFsb3V0Jywgb25MZWF2ZSk7XG5cbiAgICAgICAgZnVuY3Rpb24gdXNlSGFuZGxlcihldmVudFR5cGUsIGNiKSB7XG4gICAgICAgICAgICB6ci5vbihldmVudFR5cGUsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRpcyA9IG1ha2VEaXNwYXRjaEFjdGlvbihhcGkpO1xuXG4gICAgICAgICAgICAgICAgZWFjaChnZXQoenIpLnJlY29yZHMsIGZ1bmN0aW9uIChyZWNvcmQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjb3JkICYmIGNiKHJlY29yZCwgZSwgZGlzLmRpc3BhdGNoQWN0aW9uKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGRpc3BhdGNoVG9vbHRpcEZpbmFsbHkoZGlzLnBlbmRpbmdzLCBhcGkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkaXNwYXRjaFRvb2x0aXBGaW5hbGx5KHBlbmRpbmdzLCBhcGkpIHtcbiAgICAgICAgdmFyIHNob3dMZW4gPSBwZW5kaW5ncy5zaG93VGlwLmxlbmd0aDtcbiAgICAgICAgdmFyIGhpZGVMZW4gPSBwZW5kaW5ncy5oaWRlVGlwLmxlbmd0aDtcblxuICAgICAgICB2YXIgYWN0dWFsbHlQYXlsb2FkO1xuICAgICAgICBpZiAoc2hvd0xlbikge1xuICAgICAgICAgICAgYWN0dWFsbHlQYXlsb2FkID0gcGVuZGluZ3Muc2hvd1RpcFtzaG93TGVuIC0gMV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaGlkZUxlbikge1xuICAgICAgICAgICAgYWN0dWFsbHlQYXlsb2FkID0gcGVuZGluZ3MuaGlkZVRpcFtoaWRlTGVuIC0gMV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFjdHVhbGx5UGF5bG9hZCkge1xuICAgICAgICAgICAgYWN0dWFsbHlQYXlsb2FkLmRpc3BhdGNoQWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIGFwaS5kaXNwYXRjaEFjdGlvbihhY3R1YWxseVBheWxvYWQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25MZWF2ZShyZWNvcmQsIGUsIGRpc3BhdGNoQWN0aW9uKSB7XG4gICAgICAgIHJlY29yZC5oYW5kbGVyKCdsZWF2ZScsIG51bGwsIGRpc3BhdGNoQWN0aW9uKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkb0VudGVyKGN1cnJUcmlnZ2VyLCByZWNvcmQsIGUsIGRpc3BhdGNoQWN0aW9uKSB7XG4gICAgICAgIHJlY29yZC5oYW5kbGVyKGN1cnJUcmlnZ2VyLCBlLCBkaXNwYXRjaEFjdGlvbik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZURpc3BhdGNoQWN0aW9uKGFwaSkge1xuICAgICAgICB2YXIgcGVuZGluZ3MgPSB7XG4gICAgICAgICAgICBzaG93VGlwOiBbXSxcbiAgICAgICAgICAgIGhpZGVUaXA6IFtdXG4gICAgICAgIH07XG4gICAgICAgIC8vIEZJWE1FXG4gICAgICAgIC8vIGJldHRlciBhcHByb2FjaD9cbiAgICAgICAgLy8gJ3Nob3dUaXAnIGFuZCAnaGlkZVRpcCcgY2FuIGJlIHRyaWdnZXJlZCBieSBheGlzUG9pbnRlciBhbmQgdG9vbHRpcCxcbiAgICAgICAgLy8gd2hpY2ggbWF5IGJlIGNvbmZsaWN0LCAoYXhpc1BvaW50ZXIgY2FsbCBzaG93VGlwIGJ1dCB0b29sdGlwIGNhbGwgaGlkZVRpcCk7XG4gICAgICAgIC8vIFNvIHdlIGhhdmUgdG8gYWRkIFwiZmluYWwgc3RhZ2VcIiB0byBtZXJnZSB0aG9zZSBkaXNwYXRjaGVkIGFjdGlvbnMuXG4gICAgICAgIHZhciBkaXNwYXRjaEFjdGlvbiA9IGZ1bmN0aW9uIChwYXlsb2FkKSB7XG4gICAgICAgICAgICB2YXIgcGVuZGluZ0xpc3QgPSBwZW5kaW5nc1twYXlsb2FkLnR5cGVdO1xuICAgICAgICAgICAgaWYgKHBlbmRpbmdMaXN0KSB7XG4gICAgICAgICAgICAgICAgcGVuZGluZ0xpc3QucHVzaChwYXlsb2FkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBheWxvYWQuZGlzcGF0Y2hBY3Rpb24gPSBkaXNwYXRjaEFjdGlvbjtcbiAgICAgICAgICAgICAgICBhcGkuZGlzcGF0Y2hBY3Rpb24ocGF5bG9hZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRpc3BhdGNoQWN0aW9uOiBkaXNwYXRjaEFjdGlvbixcbiAgICAgICAgICAgIHBlbmRpbmdzOiBwZW5kaW5nc1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL0V4dGVuc2lvbkFQSX0gYXBpXG4gICAgICovXG4gICAgZ2xvYmFsTGlzdGVuZXIudW5yZWdpc3RlciA9IGZ1bmN0aW9uIChrZXksIGFwaSkge1xuICAgICAgICBpZiAoZW52Lm5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgenIgPSBhcGkuZ2V0WnIoKTtcbiAgICAgICAgdmFyIHJlY29yZCA9IChnZXQoenIpLnJlY29yZHMgfHwge30pW2tleV07XG4gICAgICAgIGlmIChyZWNvcmQpIHtcbiAgICAgICAgICAgIGdldCh6cikucmVjb3Jkc1trZXldID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGdsb2JhbExpc3RlbmVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvY29tcG9uZW50L2F4aXNQb2ludGVyL2dsb2JhbExpc3RlbmVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 152 */
/* unknown exports provided */
/* all exports used */
/*!**************************************************!*\
  !*** ./lib/component/dataZoom/dataZoomAction.js ***!
  \**************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * @file Data zoom action\n */\n\n\n    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 0);\n    var helper = __webpack_require__(/*! ./helper */ 82);\n    var echarts = __webpack_require__(/*! ../../echarts */ 1);\n\n\n    echarts.registerAction('dataZoom', function (payload, ecModel) {\n\n        var linkedNodesFinder = helper.createLinkedNodesFinder(\n            zrUtil.bind(ecModel.eachComponent, ecModel, 'dataZoom'),\n            helper.eachAxisDim,\n            function (model, dimNames) {\n                return model.get(dimNames.axisIndex);\n            }\n        );\n\n        var effectedModels = [];\n\n        ecModel.eachComponent(\n            {mainType: 'dataZoom', query: payload},\n            function (model, index) {\n                effectedModels.push.apply(\n                    effectedModels, linkedNodesFinder(model).nodes\n                );\n            }\n        );\n\n        zrUtil.each(effectedModels, function (dataZoomModel, index) {\n            dataZoomModel.setRawRange({\n                start: payload.start,\n                end: payload.end,\n                startValue: payload.startValue,\n                endValue: payload.endValue\n            });\n        });\n\n    });\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTUyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2NvbXBvbmVudC9kYXRhWm9vbS9kYXRhWm9vbUFjdGlvbi5qcz83YTFjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGZpbGUgRGF0YSB6b29tIGFjdGlvblxuICovXG5cblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgaGVscGVyID0gcmVxdWlyZSgnLi9oZWxwZXInKTtcbiAgICB2YXIgZWNoYXJ0cyA9IHJlcXVpcmUoJy4uLy4uL2VjaGFydHMnKTtcblxuXG4gICAgZWNoYXJ0cy5yZWdpc3RlckFjdGlvbignZGF0YVpvb20nLCBmdW5jdGlvbiAocGF5bG9hZCwgZWNNb2RlbCkge1xuXG4gICAgICAgIHZhciBsaW5rZWROb2Rlc0ZpbmRlciA9IGhlbHBlci5jcmVhdGVMaW5rZWROb2Rlc0ZpbmRlcihcbiAgICAgICAgICAgIHpyVXRpbC5iaW5kKGVjTW9kZWwuZWFjaENvbXBvbmVudCwgZWNNb2RlbCwgJ2RhdGFab29tJyksXG4gICAgICAgICAgICBoZWxwZXIuZWFjaEF4aXNEaW0sXG4gICAgICAgICAgICBmdW5jdGlvbiAobW9kZWwsIGRpbU5hbWVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vZGVsLmdldChkaW1OYW1lcy5heGlzSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuXG4gICAgICAgIHZhciBlZmZlY3RlZE1vZGVscyA9IFtdO1xuXG4gICAgICAgIGVjTW9kZWwuZWFjaENvbXBvbmVudChcbiAgICAgICAgICAgIHttYWluVHlwZTogJ2RhdGFab29tJywgcXVlcnk6IHBheWxvYWR9LFxuICAgICAgICAgICAgZnVuY3Rpb24gKG1vZGVsLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIGVmZmVjdGVkTW9kZWxzLnB1c2guYXBwbHkoXG4gICAgICAgICAgICAgICAgICAgIGVmZmVjdGVkTW9kZWxzLCBsaW5rZWROb2Rlc0ZpbmRlcihtb2RlbCkubm9kZXNcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuXG4gICAgICAgIHpyVXRpbC5lYWNoKGVmZmVjdGVkTW9kZWxzLCBmdW5jdGlvbiAoZGF0YVpvb21Nb2RlbCwgaW5kZXgpIHtcbiAgICAgICAgICAgIGRhdGFab29tTW9kZWwuc2V0UmF3UmFuZ2Uoe1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBwYXlsb2FkLnN0YXJ0LFxuICAgICAgICAgICAgICAgIGVuZDogcGF5bG9hZC5lbmQsXG4gICAgICAgICAgICAgICAgc3RhcnRWYWx1ZTogcGF5bG9hZC5zdGFydFZhbHVlLFxuICAgICAgICAgICAgICAgIGVuZFZhbHVlOiBwYXlsb2FkLmVuZFZhbHVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICB9KTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvY29tcG9uZW50L2RhdGFab29tL2RhdGFab29tQWN0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 153 */
/* unknown exports provided */
/* all exports used */
/*!*****************************************************!*\
  !*** ./lib/component/dataZoom/dataZoomProcessor.js ***!
  \*****************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * @file Data zoom processor\n */\n\n\n    var echarts = __webpack_require__(/*! ../../echarts */ 1);\n\n    echarts.registerProcessor(function (ecModel, api) {\n\n        ecModel.eachComponent('dataZoom', function (dataZoomModel) {\n            // We calculate window and reset axis here but not in model\n            // init stage and not after action dispatch handler, because\n            // reset should be called after seriesData.restoreData.\n            dataZoomModel.eachTargetAxis(resetSingleAxis);\n\n            // Caution: data zoom filtering is order sensitive when using\n            // percent range and no min/max/scale set on axis.\n            // For example, we have dataZoom definition:\n            // [\n            //      {xAxisIndex: 0, start: 30, end: 70},\n            //      {yAxisIndex: 0, start: 20, end: 80}\n            // ]\n            // In this case, [20, 80] of y-dataZoom should be based on data\n            // that have filtered by x-dataZoom using range of [30, 70],\n            // but should not be based on full raw data. Thus sliding\n            // x-dataZoom will change both ranges of xAxis and yAxis,\n            // while sliding y-dataZoom will only change the range of yAxis.\n            // So we should filter x-axis after reset x-axis immediately,\n            // and then reset y-axis and filter y-axis.\n            dataZoomModel.eachTargetAxis(filterSingleAxis);\n        });\n\n        ecModel.eachComponent('dataZoom', function (dataZoomModel) {\n            // Fullfill all of the range props so that user\n            // is able to get them from chart.getOption().\n            var axisProxy = dataZoomModel.findRepresentativeAxisProxy();\n            var percentRange = axisProxy.getDataPercentWindow();\n            var valueRange = axisProxy.getDataValueWindow();\n\n            dataZoomModel.setRawRange({\n                start: percentRange[0],\n                end: percentRange[1],\n                startValue: valueRange[0],\n                endValue: valueRange[1]\n            }, true);\n        });\n    });\n\n    function resetSingleAxis(dimNames, axisIndex, dataZoomModel) {\n        dataZoomModel.getAxisProxy(dimNames.name, axisIndex).reset(dataZoomModel);\n    }\n\n    function filterSingleAxis(dimNames, axisIndex, dataZoomModel) {\n        dataZoomModel.getAxisProxy(dimNames.name, axisIndex).filterData(dataZoomModel);\n    }\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTUzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2NvbXBvbmVudC9kYXRhWm9vbS9kYXRhWm9vbVByb2Nlc3Nvci5qcz80ZThlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGZpbGUgRGF0YSB6b29tIHByb2Nlc3NvclxuICovXG5cblxuICAgIHZhciBlY2hhcnRzID0gcmVxdWlyZSgnLi4vLi4vZWNoYXJ0cycpO1xuXG4gICAgZWNoYXJ0cy5yZWdpc3RlclByb2Nlc3NvcihmdW5jdGlvbiAoZWNNb2RlbCwgYXBpKSB7XG5cbiAgICAgICAgZWNNb2RlbC5lYWNoQ29tcG9uZW50KCdkYXRhWm9vbScsIGZ1bmN0aW9uIChkYXRhWm9vbU1vZGVsKSB7XG4gICAgICAgICAgICAvLyBXZSBjYWxjdWxhdGUgd2luZG93IGFuZCByZXNldCBheGlzIGhlcmUgYnV0IG5vdCBpbiBtb2RlbFxuICAgICAgICAgICAgLy8gaW5pdCBzdGFnZSBhbmQgbm90IGFmdGVyIGFjdGlvbiBkaXNwYXRjaCBoYW5kbGVyLCBiZWNhdXNlXG4gICAgICAgICAgICAvLyByZXNldCBzaG91bGQgYmUgY2FsbGVkIGFmdGVyIHNlcmllc0RhdGEucmVzdG9yZURhdGEuXG4gICAgICAgICAgICBkYXRhWm9vbU1vZGVsLmVhY2hUYXJnZXRBeGlzKHJlc2V0U2luZ2xlQXhpcyk7XG5cbiAgICAgICAgICAgIC8vIENhdXRpb246IGRhdGEgem9vbSBmaWx0ZXJpbmcgaXMgb3JkZXIgc2Vuc2l0aXZlIHdoZW4gdXNpbmdcbiAgICAgICAgICAgIC8vIHBlcmNlbnQgcmFuZ2UgYW5kIG5vIG1pbi9tYXgvc2NhbGUgc2V0IG9uIGF4aXMuXG4gICAgICAgICAgICAvLyBGb3IgZXhhbXBsZSwgd2UgaGF2ZSBkYXRhWm9vbSBkZWZpbml0aW9uOlxuICAgICAgICAgICAgLy8gW1xuICAgICAgICAgICAgLy8gICAgICB7eEF4aXNJbmRleDogMCwgc3RhcnQ6IDMwLCBlbmQ6IDcwfSxcbiAgICAgICAgICAgIC8vICAgICAge3lBeGlzSW5kZXg6IDAsIHN0YXJ0OiAyMCwgZW5kOiA4MH1cbiAgICAgICAgICAgIC8vIF1cbiAgICAgICAgICAgIC8vIEluIHRoaXMgY2FzZSwgWzIwLCA4MF0gb2YgeS1kYXRhWm9vbSBzaG91bGQgYmUgYmFzZWQgb24gZGF0YVxuICAgICAgICAgICAgLy8gdGhhdCBoYXZlIGZpbHRlcmVkIGJ5IHgtZGF0YVpvb20gdXNpbmcgcmFuZ2Ugb2YgWzMwLCA3MF0sXG4gICAgICAgICAgICAvLyBidXQgc2hvdWxkIG5vdCBiZSBiYXNlZCBvbiBmdWxsIHJhdyBkYXRhLiBUaHVzIHNsaWRpbmdcbiAgICAgICAgICAgIC8vIHgtZGF0YVpvb20gd2lsbCBjaGFuZ2UgYm90aCByYW5nZXMgb2YgeEF4aXMgYW5kIHlBeGlzLFxuICAgICAgICAgICAgLy8gd2hpbGUgc2xpZGluZyB5LWRhdGFab29tIHdpbGwgb25seSBjaGFuZ2UgdGhlIHJhbmdlIG9mIHlBeGlzLlxuICAgICAgICAgICAgLy8gU28gd2Ugc2hvdWxkIGZpbHRlciB4LWF4aXMgYWZ0ZXIgcmVzZXQgeC1heGlzIGltbWVkaWF0ZWx5LFxuICAgICAgICAgICAgLy8gYW5kIHRoZW4gcmVzZXQgeS1heGlzIGFuZCBmaWx0ZXIgeS1heGlzLlxuICAgICAgICAgICAgZGF0YVpvb21Nb2RlbC5lYWNoVGFyZ2V0QXhpcyhmaWx0ZXJTaW5nbGVBeGlzKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZWNNb2RlbC5lYWNoQ29tcG9uZW50KCdkYXRhWm9vbScsIGZ1bmN0aW9uIChkYXRhWm9vbU1vZGVsKSB7XG4gICAgICAgICAgICAvLyBGdWxsZmlsbCBhbGwgb2YgdGhlIHJhbmdlIHByb3BzIHNvIHRoYXQgdXNlclxuICAgICAgICAgICAgLy8gaXMgYWJsZSB0byBnZXQgdGhlbSBmcm9tIGNoYXJ0LmdldE9wdGlvbigpLlxuICAgICAgICAgICAgdmFyIGF4aXNQcm94eSA9IGRhdGFab29tTW9kZWwuZmluZFJlcHJlc2VudGF0aXZlQXhpc1Byb3h5KCk7XG4gICAgICAgICAgICB2YXIgcGVyY2VudFJhbmdlID0gYXhpc1Byb3h5LmdldERhdGFQZXJjZW50V2luZG93KCk7XG4gICAgICAgICAgICB2YXIgdmFsdWVSYW5nZSA9IGF4aXNQcm94eS5nZXREYXRhVmFsdWVXaW5kb3coKTtcblxuICAgICAgICAgICAgZGF0YVpvb21Nb2RlbC5zZXRSYXdSYW5nZSh7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IHBlcmNlbnRSYW5nZVswXSxcbiAgICAgICAgICAgICAgICBlbmQ6IHBlcmNlbnRSYW5nZVsxXSxcbiAgICAgICAgICAgICAgICBzdGFydFZhbHVlOiB2YWx1ZVJhbmdlWzBdLFxuICAgICAgICAgICAgICAgIGVuZFZhbHVlOiB2YWx1ZVJhbmdlWzFdXG4gICAgICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiByZXNldFNpbmdsZUF4aXMoZGltTmFtZXMsIGF4aXNJbmRleCwgZGF0YVpvb21Nb2RlbCkge1xuICAgICAgICBkYXRhWm9vbU1vZGVsLmdldEF4aXNQcm94eShkaW1OYW1lcy5uYW1lLCBheGlzSW5kZXgpLnJlc2V0KGRhdGFab29tTW9kZWwpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpbHRlclNpbmdsZUF4aXMoZGltTmFtZXMsIGF4aXNJbmRleCwgZGF0YVpvb21Nb2RlbCkge1xuICAgICAgICBkYXRhWm9vbU1vZGVsLmdldEF4aXNQcm94eShkaW1OYW1lcy5uYW1lLCBheGlzSW5kZXgpLmZpbHRlckRhdGEoZGF0YVpvb21Nb2RlbCk7XG4gICAgfVxuXG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2NvbXBvbmVudC9kYXRhWm9vbS9kYXRhWm9vbVByb2Nlc3Nvci5qc1xuLy8gbW9kdWxlIGlkID0gMTUzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 154 */
/* unknown exports provided */
/* all exports used */
/*!*******************************************!*\
  !*** ./lib/component/dataZoom/history.js ***!
  \*******************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * @file History manager.\n */\n\n\n    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 0);\n    var each = zrUtil.each;\n\n    var ATTR = '\\0_ec_hist_store';\n\n    var history = {\n\n        /**\n         * @public\n         * @param {module:echarts/model/Global} ecModel\n         * @param {Object} newSnapshot {dataZoomId, batch: [payloadInfo, ...]}\n         */\n        push: function (ecModel, newSnapshot) {\n            var store = giveStore(ecModel);\n\n            // If previous dataZoom can not be found,\n            // complete an range with current range.\n            each(newSnapshot, function (batchItem, dataZoomId) {\n                var i = store.length - 1;\n                for (; i >= 0; i--) {\n                    var snapshot = store[i];\n                    if (snapshot[dataZoomId]) {\n                        break;\n                    }\n                }\n                if (i < 0) {\n                    // No origin range set, create one by current range.\n                    var dataZoomModel = ecModel.queryComponents(\n                        {mainType: 'dataZoom', subType: 'select', id: dataZoomId}\n                    )[0];\n                    if (dataZoomModel) {\n                        var percentRange = dataZoomModel.getPercentRange();\n                        store[0][dataZoomId] = {\n                            dataZoomId: dataZoomId,\n                            start: percentRange[0],\n                            end: percentRange[1]\n                        };\n                    }\n                }\n            });\n\n            store.push(newSnapshot);\n        },\n\n        /**\n         * @public\n         * @param {module:echarts/model/Global} ecModel\n         * @return {Object} snapshot\n         */\n        pop: function (ecModel) {\n            var store = giveStore(ecModel);\n            var head = store[store.length - 1];\n            store.length > 1 && store.pop();\n\n            // Find top for all dataZoom.\n            var snapshot = {};\n            each(head, function (batchItem, dataZoomId) {\n                for (var i = store.length - 1; i >= 0; i--) {\n                    var batchItem = store[i][dataZoomId];\n                    if (batchItem) {\n                        snapshot[dataZoomId] = batchItem;\n                        break;\n                    }\n                }\n            });\n\n            return snapshot;\n        },\n\n        /**\n         * @public\n         */\n        clear: function (ecModel) {\n            ecModel[ATTR] = null;\n        },\n\n        /**\n         * @public\n         * @param {module:echarts/model/Global} ecModel\n         * @return {number} records. always >= 1.\n         */\n        count: function (ecModel) {\n            return giveStore(ecModel).length;\n        }\n\n    };\n\n    /**\n     * [{key: dataZoomId, value: {dataZoomId, range}}, ...]\n     * History length of each dataZoom may be different.\n     * this._history[0] is used to store origin range.\n     * @type {Array.<Object>}\n     */\n    function giveStore(ecModel) {\n        var store = ecModel[ATTR];\n        if (!store) {\n            store = ecModel[ATTR] = [{}];\n        }\n        return store;\n    }\n\n    module.exports = history;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTU0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2NvbXBvbmVudC9kYXRhWm9vbS9oaXN0b3J5LmpzPzc5MGYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZmlsZSBIaXN0b3J5IG1hbmFnZXIuXG4gKi9cblxuXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuICAgIHZhciBlYWNoID0genJVdGlsLmVhY2g7XG5cbiAgICB2YXIgQVRUUiA9ICdcXDBfZWNfaGlzdF9zdG9yZSc7XG5cbiAgICB2YXIgaGlzdG9yeSA9IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHB1YmxpY1xuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL0dsb2JhbH0gZWNNb2RlbFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gbmV3U25hcHNob3Qge2RhdGFab29tSWQsIGJhdGNoOiBbcGF5bG9hZEluZm8sIC4uLl19XG4gICAgICAgICAqL1xuICAgICAgICBwdXNoOiBmdW5jdGlvbiAoZWNNb2RlbCwgbmV3U25hcHNob3QpIHtcbiAgICAgICAgICAgIHZhciBzdG9yZSA9IGdpdmVTdG9yZShlY01vZGVsKTtcblxuICAgICAgICAgICAgLy8gSWYgcHJldmlvdXMgZGF0YVpvb20gY2FuIG5vdCBiZSBmb3VuZCxcbiAgICAgICAgICAgIC8vIGNvbXBsZXRlIGFuIHJhbmdlIHdpdGggY3VycmVudCByYW5nZS5cbiAgICAgICAgICAgIGVhY2gobmV3U25hcHNob3QsIGZ1bmN0aW9uIChiYXRjaEl0ZW0sIGRhdGFab29tSWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgaSA9IHN0b3JlLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgZm9yICg7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzbmFwc2hvdCA9IHN0b3JlW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc25hcHNob3RbZGF0YVpvb21JZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBObyBvcmlnaW4gcmFuZ2Ugc2V0LCBjcmVhdGUgb25lIGJ5IGN1cnJlbnQgcmFuZ2UuXG4gICAgICAgICAgICAgICAgICAgIHZhciBkYXRhWm9vbU1vZGVsID0gZWNNb2RlbC5xdWVyeUNvbXBvbmVudHMoXG4gICAgICAgICAgICAgICAgICAgICAgICB7bWFpblR5cGU6ICdkYXRhWm9vbScsIHN1YlR5cGU6ICdzZWxlY3QnLCBpZDogZGF0YVpvb21JZH1cbiAgICAgICAgICAgICAgICAgICAgKVswXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFab29tTW9kZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwZXJjZW50UmFuZ2UgPSBkYXRhWm9vbU1vZGVsLmdldFBlcmNlbnRSYW5nZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmVbMF1bZGF0YVpvb21JZF0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVpvb21JZDogZGF0YVpvb21JZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogcGVyY2VudFJhbmdlWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogcGVyY2VudFJhbmdlWzFdXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHN0b3JlLnB1c2gobmV3U25hcHNob3QpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHVibGljXG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvR2xvYmFsfSBlY01vZGVsXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gc25hcHNob3RcbiAgICAgICAgICovXG4gICAgICAgIHBvcDogZnVuY3Rpb24gKGVjTW9kZWwpIHtcbiAgICAgICAgICAgIHZhciBzdG9yZSA9IGdpdmVTdG9yZShlY01vZGVsKTtcbiAgICAgICAgICAgIHZhciBoZWFkID0gc3RvcmVbc3RvcmUubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBzdG9yZS5sZW5ndGggPiAxICYmIHN0b3JlLnBvcCgpO1xuXG4gICAgICAgICAgICAvLyBGaW5kIHRvcCBmb3IgYWxsIGRhdGFab29tLlxuICAgICAgICAgICAgdmFyIHNuYXBzaG90ID0ge307XG4gICAgICAgICAgICBlYWNoKGhlYWQsIGZ1bmN0aW9uIChiYXRjaEl0ZW0sIGRhdGFab29tSWQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gc3RvcmUubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJhdGNoSXRlbSA9IHN0b3JlW2ldW2RhdGFab29tSWRdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmF0Y2hJdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzbmFwc2hvdFtkYXRhWm9vbUlkXSA9IGJhdGNoSXRlbTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiBzbmFwc2hvdDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHB1YmxpY1xuICAgICAgICAgKi9cbiAgICAgICAgY2xlYXI6IGZ1bmN0aW9uIChlY01vZGVsKSB7XG4gICAgICAgICAgICBlY01vZGVsW0FUVFJdID0gbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHB1YmxpY1xuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL0dsb2JhbH0gZWNNb2RlbFxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IHJlY29yZHMuIGFsd2F5cyA+PSAxLlxuICAgICAgICAgKi9cbiAgICAgICAgY291bnQ6IGZ1bmN0aW9uIChlY01vZGVsKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2l2ZVN0b3JlKGVjTW9kZWwpLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFt7a2V5OiBkYXRhWm9vbUlkLCB2YWx1ZToge2RhdGFab29tSWQsIHJhbmdlfX0sIC4uLl1cbiAgICAgKiBIaXN0b3J5IGxlbmd0aCBvZiBlYWNoIGRhdGFab29tIG1heSBiZSBkaWZmZXJlbnQuXG4gICAgICogdGhpcy5faGlzdG9yeVswXSBpcyB1c2VkIHRvIHN0b3JlIG9yaWdpbiByYW5nZS5cbiAgICAgKiBAdHlwZSB7QXJyYXkuPE9iamVjdD59XG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2l2ZVN0b3JlKGVjTW9kZWwpIHtcbiAgICAgICAgdmFyIHN0b3JlID0gZWNNb2RlbFtBVFRSXTtcbiAgICAgICAgaWYgKCFzdG9yZSkge1xuICAgICAgICAgICAgc3RvcmUgPSBlY01vZGVsW0FUVFJdID0gW3t9XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RvcmU7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBoaXN0b3J5O1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9jb21wb25lbnQvZGF0YVpvb20vaGlzdG9yeS5qc1xuLy8gbW9kdWxlIGlkID0gMTU0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 155 */
/* unknown exports provided */
/* all exports used */
/*!*************************************************!*\
  !*** ./lib/component/dataZoom/typeDefaulter.js ***!
  \*************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    __webpack_require__(/*! ../../model/Component */ 12).registerSubTypeDefaulter('dataZoom', function (option) {\n        // Default 'slider' when no type specified.\n        return 'slider';\n    });\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTU1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2NvbXBvbmVudC9kYXRhWm9vbS90eXBlRGVmYXVsdGVyLmpzPzk5ZjkiXSwic291cmNlc0NvbnRlbnQiOlsiXG5cbiAgICByZXF1aXJlKCcuLi8uLi9tb2RlbC9Db21wb25lbnQnKS5yZWdpc3RlclN1YlR5cGVEZWZhdWx0ZXIoJ2RhdGFab29tJywgZnVuY3Rpb24gKG9wdGlvbikge1xuICAgICAgICAvLyBEZWZhdWx0ICdzbGlkZXInIHdoZW4gbm8gdHlwZSBzcGVjaWZpZWQuXG4gICAgICAgIHJldHVybiAnc2xpZGVyJztcbiAgICB9KTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvY29tcG9uZW50L2RhdGFab29tL3R5cGVEZWZhdWx0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDE1NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 156 */
/* unknown exports provided */
/* all exports used */
/*!*************************************************!*\
  !*** ./lib/component/helper/BrushController.js ***!
  \*************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Box selection tool.\n *\n * @module echarts/component/helper/BrushController\n */\n\n\n\n    var Eventful = __webpack_require__(/*! zrender/lib/mixin/Eventful */ 22);\n    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 0);\n    var graphic = __webpack_require__(/*! ../../util/graphic */ 2);\n    var interactionMutex = __webpack_require__(/*! ./interactionMutex */ 158);\n    var DataDiffer = __webpack_require__(/*! ../../data/DataDiffer */ 48);\n\n    var curry = zrUtil.curry;\n    var each = zrUtil.each;\n    var map = zrUtil.map;\n    var mathMin = Math.min;\n    var mathMax = Math.max;\n    var mathPow = Math.pow;\n\n    var COVER_Z = 10000;\n    var UNSELECT_THRESHOLD = 6;\n    var MIN_RESIZE_LINE_WIDTH = 6;\n    var MUTEX_RESOURCE_KEY = 'globalPan';\n\n    var DIRECTION_MAP = {\n        w: [0, 0],\n        e: [0, 1],\n        n: [1, 0],\n        s: [1, 1]\n    };\n    var CURSOR_MAP = {\n        w: 'ew',\n        e: 'ew',\n        n: 'ns',\n        s: 'ns',\n        ne: 'nesw',\n        sw: 'nesw',\n        nw: 'nwse',\n        se: 'nwse'\n    };\n    var DEFAULT_BRUSH_OPT = {\n        brushStyle: {\n            lineWidth: 2,\n            stroke: 'rgba(0,0,0,0.3)',\n            fill: 'rgba(0,0,0,0.1)'\n        },\n        transformable: true,\n        brushMode: 'single',\n        removeOnClick: false\n    };\n\n    var baseUID = 0;\n\n    /**\n     * @alias module:echarts/component/helper/BrushController\n     * @constructor\n     * @mixin {module:zrender/mixin/Eventful}\n     * @event module:echarts/component/helper/BrushController#brush\n     *        params:\n     *            areas: Array.<Array>, coord relates to container group,\n     *                                    If no container specified, to global.\n     *            opt {\n     *                isEnd: boolean,\n     *                removeOnClick: boolean\n     *            }\n     *\n     * @param {module:zrender/zrender~ZRender} zr\n     */\n    function BrushController(zr) {\n\n        if (true) {\n            zrUtil.assert(zr);\n        }\n\n        Eventful.call(this);\n\n        /**\n         * @type {module:zrender/zrender~ZRender}\n         * @private\n         */\n        this._zr = zr;\n\n        /**\n         * @type {module:zrender/container/Group}\n         * @readOnly\n         */\n        this.group = new graphic.Group();\n\n        /**\n         * Only for drawing (after enabledBrush).\n         *     'line', 'rect', 'polygon' or false\n         *     If passing false/null/undefined, disable brush.\n         *     If passing 'auto', determined by panel.defaultBrushType\n         * @private\n         * @type {string}\n         */\n        this._brushType;\n\n        /**\n         * Only for drawing (after enabledBrush).\n         *\n         * @private\n         * @type {Object}\n         */\n        this._brushOption;\n\n        /**\n         * @private\n         * @type {Object}\n         */\n        this._panels;\n\n        /**\n         * @private\n         * @type {Array.<nubmer>}\n         */\n        this._track = [];\n\n        /**\n         * @private\n         * @type {boolean}\n         */\n        this._dragging;\n\n        /**\n         * @private\n         * @type {Array}\n         */\n        this._covers = [];\n\n        /**\n         * @private\n         * @type {moudule:zrender/container/Group}\n         */\n        this._creatingCover;\n\n        /**\n         * `true` means global panel\n         * @private\n         * @type {module:zrender/container/Group|boolean}\n         */\n        this._creatingPanel;\n\n        /**\n         * @private\n         * @type {boolean}\n         */\n        this._enableGlobalPan;\n\n        /**\n         * @private\n         * @type {boolean}\n         */\n        if (true) {\n            this._mounted;\n        }\n\n        /**\n         * @private\n         * @type {string}\n         */\n        this._uid = 'brushController_' + baseUID++;\n\n        /**\n         * @private\n         * @type {Object}\n         */\n        this._handlers = {};\n        each(mouseHandlers, function (handler, eventName) {\n            this._handlers[eventName] = zrUtil.bind(handler, this);\n        }, this);\n    }\n\n    BrushController.prototype = {\n\n        constructor: BrushController,\n\n        /**\n         * If set to null/undefined/false, select disabled.\n         * @param {Object} brushOption\n         * @param {string|boolean} brushOption.brushType 'line', 'rect', 'polygon' or false\n         *                          If passing false/null/undefined, disable brush.\n         *                          If passing 'auto', determined by panel.defaultBrushType.\n         *                              ('auto' can not be used in global panel)\n         * @param {number} [brushOption.brushMode='single'] 'single' or 'multiple'\n         * @param {boolean} [brushOption.transformable=true]\n         * @param {boolean} [brushOption.removeOnClick=false]\n         * @param {Object} [brushOption.brushStyle]\n         * @param {number} [brushOption.brushStyle.width]\n         * @param {number} [brushOption.brushStyle.lineWidth]\n         * @param {string} [brushOption.brushStyle.stroke]\n         * @param {string} [brushOption.brushStyle.fill]\n         * @param {number} [brushOption.z]\n         */\n        enableBrush: function (brushOption) {\n            if (true) {\n                zrUtil.assert(this._mounted);\n            }\n\n            this._brushType && doDisableBrush(this);\n            brushOption.brushType && doEnableBrush(this, brushOption);\n\n            return this;\n        },\n\n        /**\n         * @param {Array.<Object>} panelOpts If not pass, it is global brush.\n         *        Each items: {\n         *            panelId, // mandatory.\n         *            clipPath, // mandatory. function.\n         *            isTargetByCursor, // mandatory. function.\n         *            defaultBrushType, // optional, only used when brushType is 'auto'.\n         *            getLinearBrushOtherExtent, // optional. function.\n         *        }\n         */\n        setPanels: function (panelOpts) {\n            if (panelOpts && panelOpts.length) {\n                var panels = this._panels = {};\n                zrUtil.each(panelOpts, function (panelOpts) {\n                    panels[panelOpts.panelId] = zrUtil.clone(panelOpts);\n                });\n            }\n            else {\n                this._panels = null;\n            }\n            return this;\n        },\n\n        /**\n         * @param {Object} [opt]\n         * @return {boolean} [opt.enableGlobalPan=false]\n         */\n        mount: function (opt) {\n            opt = opt || {};\n\n            if (true) {\n                this._mounted = true; // should be at first.\n            }\n\n            this._enableGlobalPan = opt.enableGlobalPan;\n\n            var thisGroup = this.group;\n            this._zr.add(thisGroup);\n\n            thisGroup.attr({\n                position: opt.position || [0, 0],\n                rotation: opt.rotation || 0,\n                scale: opt.scale || [1, 1]\n            });\n            this._transform = thisGroup.getLocalTransform();\n\n            return this;\n        },\n\n        eachCover: function (cb, context) {\n            each(this._covers, cb, context);\n        },\n\n        /**\n         * Update covers.\n         * @param {Array.<Object>} brushOptionList Like:\n         *        [\n         *            {id: 'xx', brushType: 'line', range: [23, 44], brushStyle, transformable},\n         *            {id: 'yy', brushType: 'rect', range: [[23, 44], [23, 54]]},\n         *            ...\n         *        ]\n         *        `brushType` is required in each cover info. (can not be 'auto')\n         *        `id` is not mandatory.\n         *        `brushStyle`, `transformable` is not mandatory, use DEFAULT_BRUSH_OPT by default.\n         *        If brushOptionList is null/undefined, all covers removed.\n         */\n        updateCovers: function (brushOptionList) {\n            if (true) {\n                zrUtil.assert(this._mounted);\n            }\n\n            brushOptionList = zrUtil.map(brushOptionList, function (brushOption) {\n                return zrUtil.merge(zrUtil.clone(DEFAULT_BRUSH_OPT), brushOption, true);\n            });\n\n            var tmpIdPrefix = '\\0-brush-index-';\n            var oldCovers = this._covers;\n            var newCovers = this._covers = [];\n            var controller = this;\n            var creatingCover = this._creatingCover;\n\n            (new DataDiffer(oldCovers, brushOptionList, oldGetKey, getKey))\n                .add(addOrUpdate)\n                .update(addOrUpdate)\n                .remove(remove)\n                .execute();\n\n            return this;\n\n            function getKey(brushOption, index) {\n                return (brushOption.id != null ? brushOption.id : tmpIdPrefix + index)\n                    + '-' + brushOption.brushType;\n            }\n\n            function oldGetKey(cover, index) {\n                return getKey(cover.__brushOption, index);\n            }\n\n            function addOrUpdate(newIndex, oldIndex) {\n                var newBrushOption = brushOptionList[newIndex];\n                // Consider setOption in event listener of brushSelect,\n                // where updating cover when creating should be forbiden.\n                if (oldIndex != null && oldCovers[oldIndex] === creatingCover) {\n                    newCovers[newIndex] = oldCovers[oldIndex];\n                }\n                else {\n                    var cover = newCovers[newIndex] = oldIndex != null\n                        ? (\n                            oldCovers[oldIndex].__brushOption = newBrushOption,\n                            oldCovers[oldIndex]\n                        )\n                        : endCreating(controller, createCover(controller, newBrushOption));\n                    updateCoverAfterCreation(controller, cover);\n                }\n            }\n\n            function remove(oldIndex) {\n                if (oldCovers[oldIndex] !== creatingCover) {\n                    controller.group.remove(oldCovers[oldIndex]);\n                }\n            }\n        },\n\n        unmount: function () {\n            if (true) {\n                if (!this._mounted) {\n                    return;\n                }\n            }\n\n            this.enableBrush(false);\n\n            // container may 'removeAll' outside.\n            clearCovers(this);\n            this._zr.remove(this.group);\n\n            if (true) {\n                this._mounted = false; // should be at last.\n            }\n\n            return this;\n        },\n\n        dispose: function () {\n            this.unmount();\n            this.off();\n        }\n    };\n\n    zrUtil.mixin(BrushController, Eventful);\n\n    function doEnableBrush(controller, brushOption) {\n        var zr = controller._zr;\n\n        // Consider roam, which takes globalPan too.\n        if (!controller._enableGlobalPan) {\n            interactionMutex.take(zr, MUTEX_RESOURCE_KEY, controller._uid);\n        }\n\n        each(controller._handlers, function (handler, eventName) {\n            zr.on(eventName, handler);\n        });\n\n        controller._brushType = brushOption.brushType;\n        controller._brushOption = zrUtil.merge(zrUtil.clone(DEFAULT_BRUSH_OPT), brushOption, true);\n    }\n\n    function doDisableBrush(controller) {\n        var zr = controller._zr;\n\n        interactionMutex.release(zr, MUTEX_RESOURCE_KEY, controller._uid);\n\n        each(controller._handlers, function (handler, eventName) {\n            zr.off(eventName, handler);\n        });\n\n        controller._brushType = controller._brushOption = null;\n    }\n\n    function createCover(controller, brushOption) {\n        var cover = coverRenderers[brushOption.brushType].createCover(controller, brushOption);\n        cover.__brushOption = brushOption;\n        updateZ(cover, brushOption);\n        controller.group.add(cover);\n        return cover;\n    }\n\n    function endCreating(controller, creatingCover) {\n        var coverRenderer = getCoverRenderer(creatingCover);\n        if (coverRenderer.endCreating) {\n            coverRenderer.endCreating(controller, creatingCover);\n            updateZ(creatingCover, creatingCover.__brushOption);\n        }\n        return creatingCover;\n    }\n\n    function updateCoverShape(controller, cover) {\n        var brushOption = cover.__brushOption;\n        getCoverRenderer(cover).updateCoverShape(\n            controller, cover, brushOption.range, brushOption\n        );\n    }\n\n    function updateZ(cover, brushOption) {\n        var z = brushOption.z;\n        z == null && (z = COVER_Z);\n        cover.traverse(function (el) {\n            el.z = z;\n            el.z2 = z; // Consider in given container.\n        });\n    }\n\n    function updateCoverAfterCreation(controller, cover) {\n        getCoverRenderer(cover).updateCommon(controller, cover);\n        updateCoverShape(controller, cover);\n    }\n\n    function getCoverRenderer(cover) {\n        return coverRenderers[cover.__brushOption.brushType];\n    }\n\n    // return target panel or `true` (means global panel)\n    function getPanelByPoint(controller, e, localCursorPoint) {\n        var panels = controller._panels;\n        if (!panels) {\n            return true; // Global panel\n        }\n        var panel;\n        var transform = controller._transform;\n        each(panels, function (pn) {\n            pn.isTargetByCursor(e, localCursorPoint, transform) && (panel = pn);\n        });\n        return panel;\n    }\n\n    // Return a panel or true\n    function getPanelByCover(controller, cover) {\n        var panels = controller._panels;\n        if (!panels) {\n            return true; // Global panel\n        }\n        var panelId = cover.__brushOption.panelId;\n        // User may give cover without coord sys info,\n        // which is then treated as global panel.\n        return panelId != null ? panels[panelId] : true;\n    }\n\n    function clearCovers(controller) {\n        var covers = controller._covers;\n        var originalLength = covers.length;\n        each(covers, function (cover) {\n            controller.group.remove(cover);\n        }, controller);\n        covers.length = 0;\n\n        return !!originalLength;\n    }\n\n    function trigger(controller, opt) {\n        var areas = map(controller._covers, function (cover) {\n            var brushOption = cover.__brushOption;\n            var range = zrUtil.clone(brushOption.range);\n            return {\n                brushType: brushOption.brushType,\n                panelId: brushOption.panelId,\n                range: range\n            };\n        });\n\n        controller.trigger('brush', areas, {\n            isEnd: !!opt.isEnd,\n            removeOnClick: !!opt.removeOnClick\n        });\n    }\n\n    function shouldShowCover(controller) {\n        var track = controller._track;\n\n        if (!track.length) {\n            return false;\n        }\n\n        var p2 = track[track.length - 1];\n        var p1 = track[0];\n        var dx = p2[0] - p1[0];\n        var dy = p2[1] - p1[1];\n        var dist = mathPow(dx * dx + dy * dy, 0.5);\n\n        return dist > UNSELECT_THRESHOLD;\n    }\n\n    function getTrackEnds(track) {\n        var tail = track.length - 1;\n        tail < 0 && (tail = 0);\n        return [track[0], track[tail]];\n    }\n\n    function createBaseRectCover(doDrift, controller, brushOption, edgeNames) {\n        var cover = new graphic.Group();\n\n        cover.add(new graphic.Rect({\n            name: 'main',\n            style: makeStyle(brushOption),\n            silent: true,\n            draggable: true,\n            cursor: 'move',\n            drift: curry(doDrift, controller, cover, 'nswe'),\n            ondragend: curry(trigger, controller, {isEnd: true})\n        }));\n\n        each(\n            edgeNames,\n            function (name) {\n                cover.add(new graphic.Rect({\n                    name: name,\n                    style: {opacity: 0},\n                    draggable: true,\n                    silent: true,\n                    invisible: true,\n                    drift: curry(doDrift, controller, cover, name),\n                    ondragend: curry(trigger, controller, {isEnd: true})\n                }));\n            }\n        );\n\n        return cover;\n    }\n\n    function updateBaseRect(controller, cover, localRange, brushOption) {\n        var lineWidth = brushOption.brushStyle.lineWidth || 0;\n        var handleSize = mathMax(lineWidth, MIN_RESIZE_LINE_WIDTH);\n        var x = localRange[0][0];\n        var y = localRange[1][0];\n        var xa = x - lineWidth / 2;\n        var ya = y - lineWidth / 2;\n        var x2 = localRange[0][1];\n        var y2 = localRange[1][1];\n        var x2a = x2 - handleSize + lineWidth / 2;\n        var y2a = y2 - handleSize + lineWidth / 2;\n        var width = x2 - x;\n        var height = y2 - y;\n        var widtha = width + lineWidth;\n        var heighta = height + lineWidth;\n\n        updateRectShape(controller, cover, 'main', x, y, width, height);\n\n        if (brushOption.transformable) {\n            updateRectShape(controller, cover, 'w', xa, ya, handleSize, heighta);\n            updateRectShape(controller, cover, 'e', x2a, ya, handleSize, heighta);\n            updateRectShape(controller, cover, 'n', xa, ya, widtha, handleSize);\n            updateRectShape(controller, cover, 's', xa, y2a, widtha, handleSize);\n\n            updateRectShape(controller, cover, 'nw', xa, ya, handleSize, handleSize);\n            updateRectShape(controller, cover, 'ne', x2a, ya, handleSize, handleSize);\n            updateRectShape(controller, cover, 'sw', xa, y2a, handleSize, handleSize);\n            updateRectShape(controller, cover, 'se', x2a, y2a, handleSize, handleSize);\n        }\n    }\n\n    function updateCommon(controller, cover) {\n        var brushOption = cover.__brushOption;\n        var transformable = brushOption.transformable;\n\n        var mainEl = cover.childAt(0);\n        mainEl.useStyle(makeStyle(brushOption));\n        mainEl.attr({\n            silent: !transformable,\n            cursor: transformable ? 'move' : 'default'\n        });\n\n        each(\n            ['w', 'e', 'n', 's', 'se', 'sw', 'ne', 'nw'],\n            function (name) {\n                var el = cover.childOfName(name);\n                var globalDir = getGlobalDirection(controller, name);\n\n                el && el.attr({\n                    silent: !transformable,\n                    invisible: !transformable,\n                    cursor: transformable ? CURSOR_MAP[globalDir] + '-resize' : null\n                });\n            }\n        );\n    }\n\n    function updateRectShape(controller, cover, name, x, y, w, h) {\n        var el = cover.childOfName(name);\n        el && el.setShape(pointsToRect(\n            clipByPanel(controller, cover, [[x, y], [x + w, y + h]])\n        ));\n    }\n\n    function makeStyle(brushOption) {\n        return zrUtil.defaults({strokeNoScale: true}, brushOption.brushStyle);\n    }\n\n    function formatRectRange(x, y, x2, y2) {\n        var min = [mathMin(x, x2), mathMin(y, y2)];\n        var max = [mathMax(x, x2), mathMax(y, y2)];\n\n        return [\n            [min[0], max[0]], // x range\n            [min[1], max[1]] // y range\n        ];\n    }\n\n    function getTransform(controller) {\n        return graphic.getTransform(controller.group);\n    }\n\n    function getGlobalDirection(controller, localDirection) {\n        if (localDirection.length > 1) {\n            localDirection = localDirection.split('');\n            var globalDir = [\n                getGlobalDirection(controller, localDirection[0]),\n                getGlobalDirection(controller, localDirection[1])\n            ];\n            (globalDir[0] === 'e' || globalDir[0] === 'w') && globalDir.reverse();\n            return globalDir.join('');\n        }\n        else {\n            var map = {w: 'left', e: 'right', n: 'top', s: 'bottom'};\n            var inverseMap = {left: 'w', right: 'e', top: 'n', bottom: 's'};\n            var globalDir = graphic.transformDirection(\n                map[localDirection], getTransform(controller)\n            );\n            return inverseMap[globalDir];\n        }\n    }\n\n    function driftRect(toRectRange, fromRectRange, controller, cover, name, dx, dy, e) {\n        var brushOption = cover.__brushOption;\n        var rectRange = toRectRange(brushOption.range);\n        var localDelta = toLocalDelta(controller, dx, dy);\n\n        each(name.split(''), function (namePart) {\n            var ind = DIRECTION_MAP[namePart];\n            rectRange[ind[0]][ind[1]] += localDelta[ind[0]];\n        });\n\n        brushOption.range = fromRectRange(formatRectRange(\n            rectRange[0][0], rectRange[1][0], rectRange[0][1], rectRange[1][1]\n        ));\n\n        updateCoverAfterCreation(controller, cover);\n        trigger(controller, {isEnd: false});\n    }\n\n    function driftPolygon(controller, cover, dx, dy, e) {\n        var range = cover.__brushOption.range;\n        var localDelta = toLocalDelta(controller, dx, dy);\n\n        each(range, function (point) {\n            point[0] += localDelta[0];\n            point[1] += localDelta[1];\n        });\n\n        updateCoverAfterCreation(controller, cover);\n        trigger(controller, {isEnd: false});\n    }\n\n    function toLocalDelta(controller, dx, dy) {\n        var thisGroup = controller.group;\n        var localD = thisGroup.transformCoordToLocal(dx, dy);\n        var localZero = thisGroup.transformCoordToLocal(0, 0);\n\n        return [localD[0] - localZero[0], localD[1] - localZero[1]];\n    }\n\n    function clipByPanel(controller, cover, data) {\n        var panel = getPanelByCover(controller, cover);\n\n        return (panel && panel !== true)\n            ? panel.clipPath(data, controller._transform)\n            : zrUtil.clone(data);\n    }\n\n    function pointsToRect(points) {\n        var xmin = mathMin(points[0][0], points[1][0]);\n        var ymin = mathMin(points[0][1], points[1][1]);\n        var xmax = mathMax(points[0][0], points[1][0]);\n        var ymax = mathMax(points[0][1], points[1][1]);\n\n        return {\n            x: xmin,\n            y: ymin,\n            width: xmax - xmin,\n            height: ymax - ymin\n        };\n    }\n\n    function resetCursor(controller, e, localCursorPoint) {\n        // Check active\n        if (!controller._brushType) {\n            return;\n        }\n\n        var zr = controller._zr;\n        var covers = controller._covers;\n        var currPanel = getPanelByPoint(controller, e, localCursorPoint);\n\n        // Check whether in covers.\n        if (!controller._dragging) {\n            for (var i = 0; i < covers.length; i++) {\n                var brushOption = covers[i].__brushOption;\n                if (currPanel\n                    && (currPanel === true || brushOption.panelId === currPanel.panelId)\n                    && coverRenderers[brushOption.brushType].contain(\n                        covers[i], localCursorPoint[0], localCursorPoint[1]\n                    )\n                ) {\n                    // Use cursor style set on cover.\n                    return;\n                }\n            }\n        }\n\n        currPanel && zr.setCursorStyle('crosshair');\n    }\n\n    function preventDefault(e) {\n        var rawE = e.event;\n        rawE.preventDefault && rawE.preventDefault();\n    }\n\n    function mainShapeContain(cover, x, y) {\n        return cover.childOfName('main').contain(x, y);\n    }\n\n    function updateCoverByMouse(controller, e, localCursorPoint, isEnd) {\n        var creatingCover = controller._creatingCover;\n        var panel = controller._creatingPanel;\n        var thisBrushOption = controller._brushOption;\n        var eventParams;\n\n        controller._track.push(localCursorPoint.slice());\n\n        if (shouldShowCover(controller) || creatingCover) {\n\n            if (panel && !creatingCover) {\n                thisBrushOption.brushMode === 'single' && clearCovers(controller);\n                var brushOption = zrUtil.clone(thisBrushOption);\n                brushOption.brushType = determineBrushType(brushOption.brushType, panel);\n                brushOption.panelId = panel === true ? null : panel.panelId;\n                creatingCover = controller._creatingCover = createCover(controller, brushOption);\n                controller._covers.push(creatingCover);\n            }\n\n            if (creatingCover) {\n                var coverRenderer = coverRenderers[determineBrushType(controller._brushType, panel)];\n                var coverBrushOption = creatingCover.__brushOption;\n\n                coverBrushOption.range = coverRenderer.getCreatingRange(\n                    clipByPanel(controller, creatingCover, controller._track)\n                );\n\n                if (isEnd) {\n                    endCreating(controller, creatingCover);\n                    coverRenderer.updateCommon(controller, creatingCover);\n                }\n\n                updateCoverShape(controller, creatingCover);\n\n                eventParams = {isEnd: isEnd};\n            }\n        }\n        else if (\n            isEnd\n            && thisBrushOption.brushMode === 'single'\n            && thisBrushOption.removeOnClick\n        ) {\n            // Help user to remove covers easily, only by a tiny drag, in 'single' mode.\n            // But a single click do not clear covers, because user may have casual\n            // clicks (for example, click on other component and do not expect covers\n            // disappear).\n            // Only some cover removed, trigger action, but not every click trigger action.\n            if (getPanelByPoint(controller, e, localCursorPoint) && clearCovers(controller)) {\n                eventParams = {isEnd: isEnd, removeOnClick: true};\n            }\n        }\n\n        return eventParams;\n    }\n\n    function determineBrushType(brushType, panel) {\n        if (brushType === 'auto') {\n            if (true) {\n                zrUtil.assert(\n                    panel && panel.defaultBrushType,\n                    'MUST have defaultBrushType when brushType is \"atuo\"'\n                );\n            }\n            return panel.defaultBrushType;\n        }\n        return brushType;\n    }\n\n    var mouseHandlers = {\n\n        mousedown: function (e) {\n            if (this._dragging) {\n                // In case some browser do not support globalOut,\n                // and release mose out side the browser.\n                handleDragEnd.call(this, e);\n            }\n            else if (!e.target || !e.target.draggable) {\n\n                preventDefault(e);\n\n                var localCursorPoint = this.group.transformCoordToLocal(e.offsetX, e.offsetY);\n\n                this._creatingCover = null;\n                var panel = this._creatingPanel = getPanelByPoint(this, e, localCursorPoint);\n\n                if (panel) {\n                    this._dragging = true;\n                    this._track = [localCursorPoint.slice()];\n                }\n            }\n        },\n\n        mousemove: function (e) {\n            var localCursorPoint = this.group.transformCoordToLocal(e.offsetX, e.offsetY);\n\n            resetCursor(this, e, localCursorPoint);\n\n            if (this._dragging) {\n\n                preventDefault(e);\n\n                var eventParams = updateCoverByMouse(this, e, localCursorPoint, false);\n\n                eventParams && trigger(this, eventParams);\n            }\n        },\n\n        mouseup: handleDragEnd //,\n\n        // FIXME\n        // in tooltip, globalout should not be triggered.\n        // globalout: handleDragEnd\n    };\n\n    function handleDragEnd(e) {\n        if (this._dragging) {\n\n            preventDefault(e);\n\n            var localCursorPoint = this.group.transformCoordToLocal(e.offsetX, e.offsetY);\n            var eventParams = updateCoverByMouse(this, e, localCursorPoint, true);\n\n            this._dragging = false;\n            this._track = [];\n            this._creatingCover = null;\n\n            // trigger event shoule be at final, after procedure will be nested.\n            eventParams && trigger(this, eventParams);\n        }\n    }\n\n    /**\n     * key: brushType\n     * @type {Object}\n     */\n    var coverRenderers = {\n\n        lineX: getLineRenderer(0),\n\n        lineY: getLineRenderer(1),\n\n        rect: {\n            createCover: function (controller, brushOption) {\n                return createBaseRectCover(\n                    curry(\n                        driftRect,\n                        function (range) {\n                            return range;\n                        },\n                        function (range) {\n                            return range;\n                        }\n                    ),\n                    controller,\n                    brushOption,\n                    ['w', 'e', 'n', 's', 'se', 'sw', 'ne', 'nw']\n                );\n            },\n            getCreatingRange: function (localTrack) {\n                var ends = getTrackEnds(localTrack);\n                return formatRectRange(ends[1][0], ends[1][1], ends[0][0], ends[0][1]);\n            },\n            updateCoverShape: function (controller, cover, localRange, brushOption) {\n                updateBaseRect(controller, cover, localRange, brushOption);\n            },\n            updateCommon: updateCommon,\n            contain: mainShapeContain\n        },\n\n        polygon: {\n            createCover: function (controller, brushOption) {\n                var cover = new graphic.Group();\n\n                // Do not use graphic.Polygon because graphic.Polyline do not close the\n                // border of the shape when drawing, which is a better experience for user.\n                cover.add(new graphic.Polyline({\n                    name: 'main',\n                    style: makeStyle(brushOption),\n                    silent: true\n                }));\n\n                return cover;\n            },\n            getCreatingRange: function (localTrack) {\n                return localTrack;\n            },\n            endCreating: function (controller, cover) {\n                cover.remove(cover.childAt(0));\n                // Use graphic.Polygon close the shape.\n                cover.add(new graphic.Polygon({\n                    name: 'main',\n                    draggable: true,\n                    drift: curry(driftPolygon, controller, cover),\n                    ondragend: curry(trigger, controller, {isEnd: true})\n                }));\n            },\n            updateCoverShape: function (controller, cover, localRange, brushOption) {\n                cover.childAt(0).setShape({\n                    points: clipByPanel(controller, cover, localRange)\n                });\n            },\n            updateCommon: updateCommon,\n            contain: mainShapeContain\n        }\n    };\n\n    function getLineRenderer(xyIndex) {\n        return {\n            createCover: function (controller, brushOption) {\n                return createBaseRectCover(\n                    curry(\n                        driftRect,\n                        function (range) {\n                            var rectRange = [range, [0, 100]];\n                            xyIndex && rectRange.reverse();\n                            return rectRange;\n                        },\n                        function (rectRange) {\n                            return rectRange[xyIndex];\n                        }\n                    ),\n                    controller,\n                    brushOption,\n                    [['w', 'e'], ['n', 's']][xyIndex]\n                );\n            },\n            getCreatingRange: function (localTrack) {\n                var ends = getTrackEnds(localTrack);\n                var min = mathMin(ends[0][xyIndex], ends[1][xyIndex]);\n                var max = mathMax(ends[0][xyIndex], ends[1][xyIndex]);\n\n                return [min, max];\n            },\n            updateCoverShape: function (controller, cover, localRange, brushOption) {\n                var otherExtent;\n                // If brushWidth not specified, fit the panel.\n                var panel = getPanelByCover(controller, cover);\n                if (panel !== true && panel.getLinearBrushOtherExtent) {\n                    otherExtent = panel.getLinearBrushOtherExtent(\n                        xyIndex, controller._transform\n                    );\n                }\n                else {\n                    var zr = controller._zr;\n                    otherExtent = [0, [zr.getWidth(), zr.getHeight()][1 - xyIndex]];\n                }\n                var rectRange = [localRange, otherExtent];\n                xyIndex && rectRange.reverse();\n\n                updateBaseRect(controller, cover, rectRange, brushOption);\n            },\n            updateCommon: updateCommon,\n            contain: mainShapeContain\n        };\n    }\n\n    module.exports = BrushController;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTU2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2NvbXBvbmVudC9oZWxwZXIvQnJ1c2hDb250cm9sbGVyLmpzP2QzNGYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBCb3ggc2VsZWN0aW9uIHRvb2wuXG4gKlxuICogQG1vZHVsZSBlY2hhcnRzL2NvbXBvbmVudC9oZWxwZXIvQnJ1c2hDb250cm9sbGVyXG4gKi9cblxuXG5cbiAgICB2YXIgRXZlbnRmdWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9taXhpbi9FdmVudGZ1bCcpO1xuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvZ3JhcGhpYycpO1xuICAgIHZhciBpbnRlcmFjdGlvbk11dGV4ID0gcmVxdWlyZSgnLi9pbnRlcmFjdGlvbk11dGV4Jyk7XG4gICAgdmFyIERhdGFEaWZmZXIgPSByZXF1aXJlKCcuLi8uLi9kYXRhL0RhdGFEaWZmZXInKTtcblxuICAgIHZhciBjdXJyeSA9IHpyVXRpbC5jdXJyeTtcbiAgICB2YXIgZWFjaCA9IHpyVXRpbC5lYWNoO1xuICAgIHZhciBtYXAgPSB6clV0aWwubWFwO1xuICAgIHZhciBtYXRoTWluID0gTWF0aC5taW47XG4gICAgdmFyIG1hdGhNYXggPSBNYXRoLm1heDtcbiAgICB2YXIgbWF0aFBvdyA9IE1hdGgucG93O1xuXG4gICAgdmFyIENPVkVSX1ogPSAxMDAwMDtcbiAgICB2YXIgVU5TRUxFQ1RfVEhSRVNIT0xEID0gNjtcbiAgICB2YXIgTUlOX1JFU0laRV9MSU5FX1dJRFRIID0gNjtcbiAgICB2YXIgTVVURVhfUkVTT1VSQ0VfS0VZID0gJ2dsb2JhbFBhbic7XG5cbiAgICB2YXIgRElSRUNUSU9OX01BUCA9IHtcbiAgICAgICAgdzogWzAsIDBdLFxuICAgICAgICBlOiBbMCwgMV0sXG4gICAgICAgIG46IFsxLCAwXSxcbiAgICAgICAgczogWzEsIDFdXG4gICAgfTtcbiAgICB2YXIgQ1VSU09SX01BUCA9IHtcbiAgICAgICAgdzogJ2V3JyxcbiAgICAgICAgZTogJ2V3JyxcbiAgICAgICAgbjogJ25zJyxcbiAgICAgICAgczogJ25zJyxcbiAgICAgICAgbmU6ICduZXN3JyxcbiAgICAgICAgc3c6ICduZXN3JyxcbiAgICAgICAgbnc6ICdud3NlJyxcbiAgICAgICAgc2U6ICdud3NlJ1xuICAgIH07XG4gICAgdmFyIERFRkFVTFRfQlJVU0hfT1BUID0ge1xuICAgICAgICBicnVzaFN0eWxlOiB7XG4gICAgICAgICAgICBsaW5lV2lkdGg6IDIsXG4gICAgICAgICAgICBzdHJva2U6ICdyZ2JhKDAsMCwwLDAuMyknLFxuICAgICAgICAgICAgZmlsbDogJ3JnYmEoMCwwLDAsMC4xKSdcbiAgICAgICAgfSxcbiAgICAgICAgdHJhbnNmb3JtYWJsZTogdHJ1ZSxcbiAgICAgICAgYnJ1c2hNb2RlOiAnc2luZ2xlJyxcbiAgICAgICAgcmVtb3ZlT25DbGljazogZmFsc2VcbiAgICB9O1xuXG4gICAgdmFyIGJhc2VVSUQgPSAwO1xuXG4gICAgLyoqXG4gICAgICogQGFsaWFzIG1vZHVsZTplY2hhcnRzL2NvbXBvbmVudC9oZWxwZXIvQnJ1c2hDb250cm9sbGVyXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1peGluIHttb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bH1cbiAgICAgKiBAZXZlbnQgbW9kdWxlOmVjaGFydHMvY29tcG9uZW50L2hlbHBlci9CcnVzaENvbnRyb2xsZXIjYnJ1c2hcbiAgICAgKiAgICAgICAgcGFyYW1zOlxuICAgICAqICAgICAgICAgICAgYXJlYXM6IEFycmF5LjxBcnJheT4sIGNvb3JkIHJlbGF0ZXMgdG8gY29udGFpbmVyIGdyb3VwLFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgbm8gY29udGFpbmVyIHNwZWNpZmllZCwgdG8gZ2xvYmFsLlxuICAgICAqICAgICAgICAgICAgb3B0IHtcbiAgICAgKiAgICAgICAgICAgICAgICBpc0VuZDogYm9vbGVhbixcbiAgICAgKiAgICAgICAgICAgICAgICByZW1vdmVPbkNsaWNrOiBib29sZWFuXG4gICAgICogICAgICAgICAgICB9XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL3pyZW5kZXJ+WlJlbmRlcn0genJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBCcnVzaENvbnRyb2xsZXIoenIpIHtcblxuICAgICAgICBpZiAoX19ERVZfXykge1xuICAgICAgICAgICAgenJVdGlsLmFzc2VydCh6cik7XG4gICAgICAgIH1cblxuICAgICAgICBFdmVudGZ1bC5jYWxsKHRoaXMpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvenJlbmRlcn5aUmVuZGVyfVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fenIgPSB6cjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2NvbnRhaW5lci9Hcm91cH1cbiAgICAgICAgICogQHJlYWRPbmx5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdyb3VwID0gbmV3IGdyYXBoaWMuR3JvdXAoKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogT25seSBmb3IgZHJhd2luZyAoYWZ0ZXIgZW5hYmxlZEJydXNoKS5cbiAgICAgICAgICogICAgICdsaW5lJywgJ3JlY3QnLCAncG9seWdvbicgb3IgZmFsc2VcbiAgICAgICAgICogICAgIElmIHBhc3NpbmcgZmFsc2UvbnVsbC91bmRlZmluZWQsIGRpc2FibGUgYnJ1c2guXG4gICAgICAgICAqICAgICBJZiBwYXNzaW5nICdhdXRvJywgZGV0ZXJtaW5lZCBieSBwYW5lbC5kZWZhdWx0QnJ1c2hUeXBlXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9icnVzaFR5cGU7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9ubHkgZm9yIGRyYXdpbmcgKGFmdGVyIGVuYWJsZWRCcnVzaCkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9icnVzaE9wdGlvbjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3BhbmVscztcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHR5cGUge0FycmF5LjxudWJtZXI+fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fdHJhY2sgPSBbXTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9kcmFnZ2luZztcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHR5cGUge0FycmF5fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fY292ZXJzID0gW107XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEB0eXBlIHttb3VkdWxlOnpyZW5kZXIvY29udGFpbmVyL0dyb3VwfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fY3JlYXRpbmdDb3ZlcjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogYHRydWVgIG1lYW5zIGdsb2JhbCBwYW5lbFxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvY29udGFpbmVyL0dyb3VwfGJvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9jcmVhdGluZ1BhbmVsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2VuYWJsZUdsb2JhbFBhbjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBpZiAoX19ERVZfXykge1xuICAgICAgICAgICAgdGhpcy5fbW91bnRlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fdWlkID0gJ2JydXNoQ29udHJvbGxlcl8nICsgYmFzZVVJRCsrO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5faGFuZGxlcnMgPSB7fTtcbiAgICAgICAgZWFjaChtb3VzZUhhbmRsZXJzLCBmdW5jdGlvbiAoaGFuZGxlciwgZXZlbnROYW1lKSB7XG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVyc1tldmVudE5hbWVdID0genJVdGlsLmJpbmQoaGFuZGxlciwgdGhpcyk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH1cblxuICAgIEJydXNoQ29udHJvbGxlci5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IEJydXNoQ29udHJvbGxlcixcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgc2V0IHRvIG51bGwvdW5kZWZpbmVkL2ZhbHNlLCBzZWxlY3QgZGlzYWJsZWQuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBicnVzaE9wdGlvblxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ3xib29sZWFufSBicnVzaE9wdGlvbi5icnVzaFR5cGUgJ2xpbmUnLCAncmVjdCcsICdwb2x5Z29uJyBvciBmYWxzZVxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgcGFzc2luZyBmYWxzZS9udWxsL3VuZGVmaW5lZCwgZGlzYWJsZSBicnVzaC5cbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgIElmIHBhc3NpbmcgJ2F1dG8nLCBkZXRlcm1pbmVkIGJ5IHBhbmVsLmRlZmF1bHRCcnVzaFR5cGUuXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCdhdXRvJyBjYW4gbm90IGJlIHVzZWQgaW4gZ2xvYmFsIHBhbmVsKVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2JydXNoT3B0aW9uLmJydXNoTW9kZT0nc2luZ2xlJ10gJ3NpbmdsZScgb3IgJ211bHRpcGxlJ1xuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFticnVzaE9wdGlvbi50cmFuc2Zvcm1hYmxlPXRydWVdXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2JydXNoT3B0aW9uLnJlbW92ZU9uQ2xpY2s9ZmFsc2VdXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbYnJ1c2hPcHRpb24uYnJ1c2hTdHlsZV1cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFticnVzaE9wdGlvbi5icnVzaFN0eWxlLndpZHRoXVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2JydXNoT3B0aW9uLmJydXNoU3R5bGUubGluZVdpZHRoXVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2JydXNoT3B0aW9uLmJydXNoU3R5bGUuc3Ryb2tlXVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2JydXNoT3B0aW9uLmJydXNoU3R5bGUuZmlsbF1cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFticnVzaE9wdGlvbi56XVxuICAgICAgICAgKi9cbiAgICAgICAgZW5hYmxlQnJ1c2g6IGZ1bmN0aW9uIChicnVzaE9wdGlvbikge1xuICAgICAgICAgICAgaWYgKF9fREVWX18pIHtcbiAgICAgICAgICAgICAgICB6clV0aWwuYXNzZXJ0KHRoaXMuX21vdW50ZWQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9icnVzaFR5cGUgJiYgZG9EaXNhYmxlQnJ1c2godGhpcyk7XG4gICAgICAgICAgICBicnVzaE9wdGlvbi5icnVzaFR5cGUgJiYgZG9FbmFibGVCcnVzaCh0aGlzLCBicnVzaE9wdGlvbik7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5LjxPYmplY3Q+fSBwYW5lbE9wdHMgSWYgbm90IHBhc3MsIGl0IGlzIGdsb2JhbCBicnVzaC5cbiAgICAgICAgICogICAgICAgIEVhY2ggaXRlbXM6IHtcbiAgICAgICAgICogICAgICAgICAgICBwYW5lbElkLCAvLyBtYW5kYXRvcnkuXG4gICAgICAgICAqICAgICAgICAgICAgY2xpcFBhdGgsIC8vIG1hbmRhdG9yeS4gZnVuY3Rpb24uXG4gICAgICAgICAqICAgICAgICAgICAgaXNUYXJnZXRCeUN1cnNvciwgLy8gbWFuZGF0b3J5LiBmdW5jdGlvbi5cbiAgICAgICAgICogICAgICAgICAgICBkZWZhdWx0QnJ1c2hUeXBlLCAvLyBvcHRpb25hbCwgb25seSB1c2VkIHdoZW4gYnJ1c2hUeXBlIGlzICdhdXRvJy5cbiAgICAgICAgICogICAgICAgICAgICBnZXRMaW5lYXJCcnVzaE90aGVyRXh0ZW50LCAvLyBvcHRpb25hbC4gZnVuY3Rpb24uXG4gICAgICAgICAqICAgICAgICB9XG4gICAgICAgICAqL1xuICAgICAgICBzZXRQYW5lbHM6IGZ1bmN0aW9uIChwYW5lbE9wdHMpIHtcbiAgICAgICAgICAgIGlmIChwYW5lbE9wdHMgJiYgcGFuZWxPcHRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBwYW5lbHMgPSB0aGlzLl9wYW5lbHMgPSB7fTtcbiAgICAgICAgICAgICAgICB6clV0aWwuZWFjaChwYW5lbE9wdHMsIGZ1bmN0aW9uIChwYW5lbE9wdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFuZWxzW3BhbmVsT3B0cy5wYW5lbElkXSA9IHpyVXRpbC5jbG9uZShwYW5lbE9wdHMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFuZWxzID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdF1cbiAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gW29wdC5lbmFibGVHbG9iYWxQYW49ZmFsc2VdXG4gICAgICAgICAqL1xuICAgICAgICBtb3VudDogZnVuY3Rpb24gKG9wdCkge1xuICAgICAgICAgICAgb3B0ID0gb3B0IHx8IHt9O1xuXG4gICAgICAgICAgICBpZiAoX19ERVZfXykge1xuICAgICAgICAgICAgICAgIHRoaXMuX21vdW50ZWQgPSB0cnVlOyAvLyBzaG91bGQgYmUgYXQgZmlyc3QuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX2VuYWJsZUdsb2JhbFBhbiA9IG9wdC5lbmFibGVHbG9iYWxQYW47XG5cbiAgICAgICAgICAgIHZhciB0aGlzR3JvdXAgPSB0aGlzLmdyb3VwO1xuICAgICAgICAgICAgdGhpcy5fenIuYWRkKHRoaXNHcm91cCk7XG5cbiAgICAgICAgICAgIHRoaXNHcm91cC5hdHRyKHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogb3B0LnBvc2l0aW9uIHx8IFswLCAwXSxcbiAgICAgICAgICAgICAgICByb3RhdGlvbjogb3B0LnJvdGF0aW9uIHx8IDAsXG4gICAgICAgICAgICAgICAgc2NhbGU6IG9wdC5zY2FsZSB8fCBbMSwgMV1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5fdHJhbnNmb3JtID0gdGhpc0dyb3VwLmdldExvY2FsVHJhbnNmb3JtKCk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGVhY2hDb3ZlcjogZnVuY3Rpb24gKGNiLCBjb250ZXh0KSB7XG4gICAgICAgICAgICBlYWNoKHRoaXMuX2NvdmVycywgY2IsIGNvbnRleHQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGUgY292ZXJzLlxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5LjxPYmplY3Q+fSBicnVzaE9wdGlvbkxpc3QgTGlrZTpcbiAgICAgICAgICogICAgICAgIFtcbiAgICAgICAgICogICAgICAgICAgICB7aWQ6ICd4eCcsIGJydXNoVHlwZTogJ2xpbmUnLCByYW5nZTogWzIzLCA0NF0sIGJydXNoU3R5bGUsIHRyYW5zZm9ybWFibGV9LFxuICAgICAgICAgKiAgICAgICAgICAgIHtpZDogJ3l5JywgYnJ1c2hUeXBlOiAncmVjdCcsIHJhbmdlOiBbWzIzLCA0NF0sIFsyMywgNTRdXX0sXG4gICAgICAgICAqICAgICAgICAgICAgLi4uXG4gICAgICAgICAqICAgICAgICBdXG4gICAgICAgICAqICAgICAgICBgYnJ1c2hUeXBlYCBpcyByZXF1aXJlZCBpbiBlYWNoIGNvdmVyIGluZm8uIChjYW4gbm90IGJlICdhdXRvJylcbiAgICAgICAgICogICAgICAgIGBpZGAgaXMgbm90IG1hbmRhdG9yeS5cbiAgICAgICAgICogICAgICAgIGBicnVzaFN0eWxlYCwgYHRyYW5zZm9ybWFibGVgIGlzIG5vdCBtYW5kYXRvcnksIHVzZSBERUZBVUxUX0JSVVNIX09QVCBieSBkZWZhdWx0LlxuICAgICAgICAgKiAgICAgICAgSWYgYnJ1c2hPcHRpb25MaXN0IGlzIG51bGwvdW5kZWZpbmVkLCBhbGwgY292ZXJzIHJlbW92ZWQuXG4gICAgICAgICAqL1xuICAgICAgICB1cGRhdGVDb3ZlcnM6IGZ1bmN0aW9uIChicnVzaE9wdGlvbkxpc3QpIHtcbiAgICAgICAgICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgICAgICAgICAgenJVdGlsLmFzc2VydCh0aGlzLl9tb3VudGVkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJ1c2hPcHRpb25MaXN0ID0genJVdGlsLm1hcChicnVzaE9wdGlvbkxpc3QsIGZ1bmN0aW9uIChicnVzaE9wdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiB6clV0aWwubWVyZ2UoenJVdGlsLmNsb25lKERFRkFVTFRfQlJVU0hfT1BUKSwgYnJ1c2hPcHRpb24sIHRydWUpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHZhciB0bXBJZFByZWZpeCA9ICdcXDAtYnJ1c2gtaW5kZXgtJztcbiAgICAgICAgICAgIHZhciBvbGRDb3ZlcnMgPSB0aGlzLl9jb3ZlcnM7XG4gICAgICAgICAgICB2YXIgbmV3Q292ZXJzID0gdGhpcy5fY292ZXJzID0gW107XG4gICAgICAgICAgICB2YXIgY29udHJvbGxlciA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgY3JlYXRpbmdDb3ZlciA9IHRoaXMuX2NyZWF0aW5nQ292ZXI7XG5cbiAgICAgICAgICAgIChuZXcgRGF0YURpZmZlcihvbGRDb3ZlcnMsIGJydXNoT3B0aW9uTGlzdCwgb2xkR2V0S2V5LCBnZXRLZXkpKVxuICAgICAgICAgICAgICAgIC5hZGQoYWRkT3JVcGRhdGUpXG4gICAgICAgICAgICAgICAgLnVwZGF0ZShhZGRPclVwZGF0ZSlcbiAgICAgICAgICAgICAgICAucmVtb3ZlKHJlbW92ZSlcbiAgICAgICAgICAgICAgICAuZXhlY3V0ZSgpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0S2V5KGJydXNoT3B0aW9uLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoYnJ1c2hPcHRpb24uaWQgIT0gbnVsbCA/IGJydXNoT3B0aW9uLmlkIDogdG1wSWRQcmVmaXggKyBpbmRleClcbiAgICAgICAgICAgICAgICAgICAgKyAnLScgKyBicnVzaE9wdGlvbi5icnVzaFR5cGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIG9sZEdldEtleShjb3ZlciwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0S2V5KGNvdmVyLl9fYnJ1c2hPcHRpb24sIGluZGV4KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gYWRkT3JVcGRhdGUobmV3SW5kZXgsIG9sZEluZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIG5ld0JydXNoT3B0aW9uID0gYnJ1c2hPcHRpb25MaXN0W25ld0luZGV4XTtcbiAgICAgICAgICAgICAgICAvLyBDb25zaWRlciBzZXRPcHRpb24gaW4gZXZlbnQgbGlzdGVuZXIgb2YgYnJ1c2hTZWxlY3QsXG4gICAgICAgICAgICAgICAgLy8gd2hlcmUgdXBkYXRpbmcgY292ZXIgd2hlbiBjcmVhdGluZyBzaG91bGQgYmUgZm9yYmlkZW4uXG4gICAgICAgICAgICAgICAgaWYgKG9sZEluZGV4ICE9IG51bGwgJiYgb2xkQ292ZXJzW29sZEluZGV4XSA9PT0gY3JlYXRpbmdDb3Zlcikge1xuICAgICAgICAgICAgICAgICAgICBuZXdDb3ZlcnNbbmV3SW5kZXhdID0gb2xkQ292ZXJzW29sZEluZGV4XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb3ZlciA9IG5ld0NvdmVyc1tuZXdJbmRleF0gPSBvbGRJbmRleCAhPSBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICA/IChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbGRDb3ZlcnNbb2xkSW5kZXhdLl9fYnJ1c2hPcHRpb24gPSBuZXdCcnVzaE9wdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbGRDb3ZlcnNbb2xkSW5kZXhdXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGVuZENyZWF0aW5nKGNvbnRyb2xsZXIsIGNyZWF0ZUNvdmVyKGNvbnRyb2xsZXIsIG5ld0JydXNoT3B0aW9uKSk7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUNvdmVyQWZ0ZXJDcmVhdGlvbihjb250cm9sbGVyLCBjb3Zlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiByZW1vdmUob2xkSW5kZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAob2xkQ292ZXJzW29sZEluZGV4XSAhPT0gY3JlYXRpbmdDb3Zlcikge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmdyb3VwLnJlbW92ZShvbGRDb3ZlcnNbb2xkSW5kZXhdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgdW5tb3VudDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF9fREVWX18pIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX21vdW50ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5lbmFibGVCcnVzaChmYWxzZSk7XG5cbiAgICAgICAgICAgIC8vIGNvbnRhaW5lciBtYXkgJ3JlbW92ZUFsbCcgb3V0c2lkZS5cbiAgICAgICAgICAgIGNsZWFyQ292ZXJzKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fenIucmVtb3ZlKHRoaXMuZ3JvdXApO1xuXG4gICAgICAgICAgICBpZiAoX19ERVZfXykge1xuICAgICAgICAgICAgICAgIHRoaXMuX21vdW50ZWQgPSBmYWxzZTsgLy8gc2hvdWxkIGJlIGF0IGxhc3QuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMudW5tb3VudCgpO1xuICAgICAgICAgICAgdGhpcy5vZmYoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB6clV0aWwubWl4aW4oQnJ1c2hDb250cm9sbGVyLCBFdmVudGZ1bCk7XG5cbiAgICBmdW5jdGlvbiBkb0VuYWJsZUJydXNoKGNvbnRyb2xsZXIsIGJydXNoT3B0aW9uKSB7XG4gICAgICAgIHZhciB6ciA9IGNvbnRyb2xsZXIuX3pyO1xuXG4gICAgICAgIC8vIENvbnNpZGVyIHJvYW0sIHdoaWNoIHRha2VzIGdsb2JhbFBhbiB0b28uXG4gICAgICAgIGlmICghY29udHJvbGxlci5fZW5hYmxlR2xvYmFsUGFuKSB7XG4gICAgICAgICAgICBpbnRlcmFjdGlvbk11dGV4LnRha2UoenIsIE1VVEVYX1JFU09VUkNFX0tFWSwgY29udHJvbGxlci5fdWlkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVhY2goY29udHJvbGxlci5faGFuZGxlcnMsIGZ1bmN0aW9uIChoYW5kbGVyLCBldmVudE5hbWUpIHtcbiAgICAgICAgICAgIHpyLm9uKGV2ZW50TmFtZSwgaGFuZGxlcik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnRyb2xsZXIuX2JydXNoVHlwZSA9IGJydXNoT3B0aW9uLmJydXNoVHlwZTtcbiAgICAgICAgY29udHJvbGxlci5fYnJ1c2hPcHRpb24gPSB6clV0aWwubWVyZ2UoenJVdGlsLmNsb25lKERFRkFVTFRfQlJVU0hfT1BUKSwgYnJ1c2hPcHRpb24sIHRydWUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRvRGlzYWJsZUJydXNoKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgdmFyIHpyID0gY29udHJvbGxlci5fenI7XG5cbiAgICAgICAgaW50ZXJhY3Rpb25NdXRleC5yZWxlYXNlKHpyLCBNVVRFWF9SRVNPVVJDRV9LRVksIGNvbnRyb2xsZXIuX3VpZCk7XG5cbiAgICAgICAgZWFjaChjb250cm9sbGVyLl9oYW5kbGVycywgZnVuY3Rpb24gKGhhbmRsZXIsIGV2ZW50TmFtZSkge1xuICAgICAgICAgICAgenIub2ZmKGV2ZW50TmFtZSwgaGFuZGxlcik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnRyb2xsZXIuX2JydXNoVHlwZSA9IGNvbnRyb2xsZXIuX2JydXNoT3B0aW9uID0gbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVDb3Zlcihjb250cm9sbGVyLCBicnVzaE9wdGlvbikge1xuICAgICAgICB2YXIgY292ZXIgPSBjb3ZlclJlbmRlcmVyc1ticnVzaE9wdGlvbi5icnVzaFR5cGVdLmNyZWF0ZUNvdmVyKGNvbnRyb2xsZXIsIGJydXNoT3B0aW9uKTtcbiAgICAgICAgY292ZXIuX19icnVzaE9wdGlvbiA9IGJydXNoT3B0aW9uO1xuICAgICAgICB1cGRhdGVaKGNvdmVyLCBicnVzaE9wdGlvbik7XG4gICAgICAgIGNvbnRyb2xsZXIuZ3JvdXAuYWRkKGNvdmVyKTtcbiAgICAgICAgcmV0dXJuIGNvdmVyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVuZENyZWF0aW5nKGNvbnRyb2xsZXIsIGNyZWF0aW5nQ292ZXIpIHtcbiAgICAgICAgdmFyIGNvdmVyUmVuZGVyZXIgPSBnZXRDb3ZlclJlbmRlcmVyKGNyZWF0aW5nQ292ZXIpO1xuICAgICAgICBpZiAoY292ZXJSZW5kZXJlci5lbmRDcmVhdGluZykge1xuICAgICAgICAgICAgY292ZXJSZW5kZXJlci5lbmRDcmVhdGluZyhjb250cm9sbGVyLCBjcmVhdGluZ0NvdmVyKTtcbiAgICAgICAgICAgIHVwZGF0ZVooY3JlYXRpbmdDb3ZlciwgY3JlYXRpbmdDb3Zlci5fX2JydXNoT3B0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3JlYXRpbmdDb3ZlcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVDb3ZlclNoYXBlKGNvbnRyb2xsZXIsIGNvdmVyKSB7XG4gICAgICAgIHZhciBicnVzaE9wdGlvbiA9IGNvdmVyLl9fYnJ1c2hPcHRpb247XG4gICAgICAgIGdldENvdmVyUmVuZGVyZXIoY292ZXIpLnVwZGF0ZUNvdmVyU2hhcGUoXG4gICAgICAgICAgICBjb250cm9sbGVyLCBjb3ZlciwgYnJ1c2hPcHRpb24ucmFuZ2UsIGJydXNoT3B0aW9uXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXBkYXRlWihjb3ZlciwgYnJ1c2hPcHRpb24pIHtcbiAgICAgICAgdmFyIHogPSBicnVzaE9wdGlvbi56O1xuICAgICAgICB6ID09IG51bGwgJiYgKHogPSBDT1ZFUl9aKTtcbiAgICAgICAgY292ZXIudHJhdmVyc2UoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICBlbC56ID0gejtcbiAgICAgICAgICAgIGVsLnoyID0gejsgLy8gQ29uc2lkZXIgaW4gZ2l2ZW4gY29udGFpbmVyLlxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVDb3ZlckFmdGVyQ3JlYXRpb24oY29udHJvbGxlciwgY292ZXIpIHtcbiAgICAgICAgZ2V0Q292ZXJSZW5kZXJlcihjb3ZlcikudXBkYXRlQ29tbW9uKGNvbnRyb2xsZXIsIGNvdmVyKTtcbiAgICAgICAgdXBkYXRlQ292ZXJTaGFwZShjb250cm9sbGVyLCBjb3Zlcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Q292ZXJSZW5kZXJlcihjb3Zlcikge1xuICAgICAgICByZXR1cm4gY292ZXJSZW5kZXJlcnNbY292ZXIuX19icnVzaE9wdGlvbi5icnVzaFR5cGVdO1xuICAgIH1cblxuICAgIC8vIHJldHVybiB0YXJnZXQgcGFuZWwgb3IgYHRydWVgIChtZWFucyBnbG9iYWwgcGFuZWwpXG4gICAgZnVuY3Rpb24gZ2V0UGFuZWxCeVBvaW50KGNvbnRyb2xsZXIsIGUsIGxvY2FsQ3Vyc29yUG9pbnQpIHtcbiAgICAgICAgdmFyIHBhbmVscyA9IGNvbnRyb2xsZXIuX3BhbmVscztcbiAgICAgICAgaWYgKCFwYW5lbHMpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBHbG9iYWwgcGFuZWxcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGFuZWw7XG4gICAgICAgIHZhciB0cmFuc2Zvcm0gPSBjb250cm9sbGVyLl90cmFuc2Zvcm07XG4gICAgICAgIGVhY2gocGFuZWxzLCBmdW5jdGlvbiAocG4pIHtcbiAgICAgICAgICAgIHBuLmlzVGFyZ2V0QnlDdXJzb3IoZSwgbG9jYWxDdXJzb3JQb2ludCwgdHJhbnNmb3JtKSAmJiAocGFuZWwgPSBwbik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcGFuZWw7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGEgcGFuZWwgb3IgdHJ1ZVxuICAgIGZ1bmN0aW9uIGdldFBhbmVsQnlDb3Zlcihjb250cm9sbGVyLCBjb3Zlcikge1xuICAgICAgICB2YXIgcGFuZWxzID0gY29udHJvbGxlci5fcGFuZWxzO1xuICAgICAgICBpZiAoIXBhbmVscykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7IC8vIEdsb2JhbCBwYW5lbFxuICAgICAgICB9XG4gICAgICAgIHZhciBwYW5lbElkID0gY292ZXIuX19icnVzaE9wdGlvbi5wYW5lbElkO1xuICAgICAgICAvLyBVc2VyIG1heSBnaXZlIGNvdmVyIHdpdGhvdXQgY29vcmQgc3lzIGluZm8sXG4gICAgICAgIC8vIHdoaWNoIGlzIHRoZW4gdHJlYXRlZCBhcyBnbG9iYWwgcGFuZWwuXG4gICAgICAgIHJldHVybiBwYW5lbElkICE9IG51bGwgPyBwYW5lbHNbcGFuZWxJZF0gOiB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFyQ292ZXJzKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgdmFyIGNvdmVycyA9IGNvbnRyb2xsZXIuX2NvdmVycztcbiAgICAgICAgdmFyIG9yaWdpbmFsTGVuZ3RoID0gY292ZXJzLmxlbmd0aDtcbiAgICAgICAgZWFjaChjb3ZlcnMsIGZ1bmN0aW9uIChjb3Zlcikge1xuICAgICAgICAgICAgY29udHJvbGxlci5ncm91cC5yZW1vdmUoY292ZXIpO1xuICAgICAgICB9LCBjb250cm9sbGVyKTtcbiAgICAgICAgY292ZXJzLmxlbmd0aCA9IDA7XG5cbiAgICAgICAgcmV0dXJuICEhb3JpZ2luYWxMZW5ndGg7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdHJpZ2dlcihjb250cm9sbGVyLCBvcHQpIHtcbiAgICAgICAgdmFyIGFyZWFzID0gbWFwKGNvbnRyb2xsZXIuX2NvdmVycywgZnVuY3Rpb24gKGNvdmVyKSB7XG4gICAgICAgICAgICB2YXIgYnJ1c2hPcHRpb24gPSBjb3Zlci5fX2JydXNoT3B0aW9uO1xuICAgICAgICAgICAgdmFyIHJhbmdlID0genJVdGlsLmNsb25lKGJydXNoT3B0aW9uLnJhbmdlKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYnJ1c2hUeXBlOiBicnVzaE9wdGlvbi5icnVzaFR5cGUsXG4gICAgICAgICAgICAgICAgcGFuZWxJZDogYnJ1c2hPcHRpb24ucGFuZWxJZCxcbiAgICAgICAgICAgICAgICByYW5nZTogcmFuZ2VcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnRyb2xsZXIudHJpZ2dlcignYnJ1c2gnLCBhcmVhcywge1xuICAgICAgICAgICAgaXNFbmQ6ICEhb3B0LmlzRW5kLFxuICAgICAgICAgICAgcmVtb3ZlT25DbGljazogISFvcHQucmVtb3ZlT25DbGlja1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzaG91bGRTaG93Q292ZXIoY29udHJvbGxlcikge1xuICAgICAgICB2YXIgdHJhY2sgPSBjb250cm9sbGVyLl90cmFjaztcblxuICAgICAgICBpZiAoIXRyYWNrLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHAyID0gdHJhY2tbdHJhY2subGVuZ3RoIC0gMV07XG4gICAgICAgIHZhciBwMSA9IHRyYWNrWzBdO1xuICAgICAgICB2YXIgZHggPSBwMlswXSAtIHAxWzBdO1xuICAgICAgICB2YXIgZHkgPSBwMlsxXSAtIHAxWzFdO1xuICAgICAgICB2YXIgZGlzdCA9IG1hdGhQb3coZHggKiBkeCArIGR5ICogZHksIDAuNSk7XG5cbiAgICAgICAgcmV0dXJuIGRpc3QgPiBVTlNFTEVDVF9USFJFU0hPTEQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0VHJhY2tFbmRzKHRyYWNrKSB7XG4gICAgICAgIHZhciB0YWlsID0gdHJhY2subGVuZ3RoIC0gMTtcbiAgICAgICAgdGFpbCA8IDAgJiYgKHRhaWwgPSAwKTtcbiAgICAgICAgcmV0dXJuIFt0cmFja1swXSwgdHJhY2tbdGFpbF1dO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUJhc2VSZWN0Q292ZXIoZG9EcmlmdCwgY29udHJvbGxlciwgYnJ1c2hPcHRpb24sIGVkZ2VOYW1lcykge1xuICAgICAgICB2YXIgY292ZXIgPSBuZXcgZ3JhcGhpYy5Hcm91cCgpO1xuXG4gICAgICAgIGNvdmVyLmFkZChuZXcgZ3JhcGhpYy5SZWN0KHtcbiAgICAgICAgICAgIG5hbWU6ICdtYWluJyxcbiAgICAgICAgICAgIHN0eWxlOiBtYWtlU3R5bGUoYnJ1c2hPcHRpb24pLFxuICAgICAgICAgICAgc2lsZW50OiB0cnVlLFxuICAgICAgICAgICAgZHJhZ2dhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY3Vyc29yOiAnbW92ZScsXG4gICAgICAgICAgICBkcmlmdDogY3VycnkoZG9EcmlmdCwgY29udHJvbGxlciwgY292ZXIsICduc3dlJyksXG4gICAgICAgICAgICBvbmRyYWdlbmQ6IGN1cnJ5KHRyaWdnZXIsIGNvbnRyb2xsZXIsIHtpc0VuZDogdHJ1ZX0pXG4gICAgICAgIH0pKTtcblxuICAgICAgICBlYWNoKFxuICAgICAgICAgICAgZWRnZU5hbWVzLFxuICAgICAgICAgICAgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgICAgICBjb3Zlci5hZGQobmV3IGdyYXBoaWMuUmVjdCh7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7b3BhY2l0eTogMH0sXG4gICAgICAgICAgICAgICAgICAgIGRyYWdnYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgc2lsZW50OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBpbnZpc2libGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGRyaWZ0OiBjdXJyeShkb0RyaWZ0LCBjb250cm9sbGVyLCBjb3ZlciwgbmFtZSksXG4gICAgICAgICAgICAgICAgICAgIG9uZHJhZ2VuZDogY3VycnkodHJpZ2dlciwgY29udHJvbGxlciwge2lzRW5kOiB0cnVlfSlcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuIGNvdmVyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVwZGF0ZUJhc2VSZWN0KGNvbnRyb2xsZXIsIGNvdmVyLCBsb2NhbFJhbmdlLCBicnVzaE9wdGlvbikge1xuICAgICAgICB2YXIgbGluZVdpZHRoID0gYnJ1c2hPcHRpb24uYnJ1c2hTdHlsZS5saW5lV2lkdGggfHwgMDtcbiAgICAgICAgdmFyIGhhbmRsZVNpemUgPSBtYXRoTWF4KGxpbmVXaWR0aCwgTUlOX1JFU0laRV9MSU5FX1dJRFRIKTtcbiAgICAgICAgdmFyIHggPSBsb2NhbFJhbmdlWzBdWzBdO1xuICAgICAgICB2YXIgeSA9IGxvY2FsUmFuZ2VbMV1bMF07XG4gICAgICAgIHZhciB4YSA9IHggLSBsaW5lV2lkdGggLyAyO1xuICAgICAgICB2YXIgeWEgPSB5IC0gbGluZVdpZHRoIC8gMjtcbiAgICAgICAgdmFyIHgyID0gbG9jYWxSYW5nZVswXVsxXTtcbiAgICAgICAgdmFyIHkyID0gbG9jYWxSYW5nZVsxXVsxXTtcbiAgICAgICAgdmFyIHgyYSA9IHgyIC0gaGFuZGxlU2l6ZSArIGxpbmVXaWR0aCAvIDI7XG4gICAgICAgIHZhciB5MmEgPSB5MiAtIGhhbmRsZVNpemUgKyBsaW5lV2lkdGggLyAyO1xuICAgICAgICB2YXIgd2lkdGggPSB4MiAtIHg7XG4gICAgICAgIHZhciBoZWlnaHQgPSB5MiAtIHk7XG4gICAgICAgIHZhciB3aWR0aGEgPSB3aWR0aCArIGxpbmVXaWR0aDtcbiAgICAgICAgdmFyIGhlaWdodGEgPSBoZWlnaHQgKyBsaW5lV2lkdGg7XG5cbiAgICAgICAgdXBkYXRlUmVjdFNoYXBlKGNvbnRyb2xsZXIsIGNvdmVyLCAnbWFpbicsIHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgICAgIGlmIChicnVzaE9wdGlvbi50cmFuc2Zvcm1hYmxlKSB7XG4gICAgICAgICAgICB1cGRhdGVSZWN0U2hhcGUoY29udHJvbGxlciwgY292ZXIsICd3JywgeGEsIHlhLCBoYW5kbGVTaXplLCBoZWlnaHRhKTtcbiAgICAgICAgICAgIHVwZGF0ZVJlY3RTaGFwZShjb250cm9sbGVyLCBjb3ZlciwgJ2UnLCB4MmEsIHlhLCBoYW5kbGVTaXplLCBoZWlnaHRhKTtcbiAgICAgICAgICAgIHVwZGF0ZVJlY3RTaGFwZShjb250cm9sbGVyLCBjb3ZlciwgJ24nLCB4YSwgeWEsIHdpZHRoYSwgaGFuZGxlU2l6ZSk7XG4gICAgICAgICAgICB1cGRhdGVSZWN0U2hhcGUoY29udHJvbGxlciwgY292ZXIsICdzJywgeGEsIHkyYSwgd2lkdGhhLCBoYW5kbGVTaXplKTtcblxuICAgICAgICAgICAgdXBkYXRlUmVjdFNoYXBlKGNvbnRyb2xsZXIsIGNvdmVyLCAnbncnLCB4YSwgeWEsIGhhbmRsZVNpemUsIGhhbmRsZVNpemUpO1xuICAgICAgICAgICAgdXBkYXRlUmVjdFNoYXBlKGNvbnRyb2xsZXIsIGNvdmVyLCAnbmUnLCB4MmEsIHlhLCBoYW5kbGVTaXplLCBoYW5kbGVTaXplKTtcbiAgICAgICAgICAgIHVwZGF0ZVJlY3RTaGFwZShjb250cm9sbGVyLCBjb3ZlciwgJ3N3JywgeGEsIHkyYSwgaGFuZGxlU2l6ZSwgaGFuZGxlU2l6ZSk7XG4gICAgICAgICAgICB1cGRhdGVSZWN0U2hhcGUoY29udHJvbGxlciwgY292ZXIsICdzZScsIHgyYSwgeTJhLCBoYW5kbGVTaXplLCBoYW5kbGVTaXplKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVwZGF0ZUNvbW1vbihjb250cm9sbGVyLCBjb3Zlcikge1xuICAgICAgICB2YXIgYnJ1c2hPcHRpb24gPSBjb3Zlci5fX2JydXNoT3B0aW9uO1xuICAgICAgICB2YXIgdHJhbnNmb3JtYWJsZSA9IGJydXNoT3B0aW9uLnRyYW5zZm9ybWFibGU7XG5cbiAgICAgICAgdmFyIG1haW5FbCA9IGNvdmVyLmNoaWxkQXQoMCk7XG4gICAgICAgIG1haW5FbC51c2VTdHlsZShtYWtlU3R5bGUoYnJ1c2hPcHRpb24pKTtcbiAgICAgICAgbWFpbkVsLmF0dHIoe1xuICAgICAgICAgICAgc2lsZW50OiAhdHJhbnNmb3JtYWJsZSxcbiAgICAgICAgICAgIGN1cnNvcjogdHJhbnNmb3JtYWJsZSA/ICdtb3ZlJyA6ICdkZWZhdWx0J1xuICAgICAgICB9KTtcblxuICAgICAgICBlYWNoKFxuICAgICAgICAgICAgWyd3JywgJ2UnLCAnbicsICdzJywgJ3NlJywgJ3N3JywgJ25lJywgJ253J10sXG4gICAgICAgICAgICBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBlbCA9IGNvdmVyLmNoaWxkT2ZOYW1lKG5hbWUpO1xuICAgICAgICAgICAgICAgIHZhciBnbG9iYWxEaXIgPSBnZXRHbG9iYWxEaXJlY3Rpb24oY29udHJvbGxlciwgbmFtZSk7XG5cbiAgICAgICAgICAgICAgICBlbCAmJiBlbC5hdHRyKHtcbiAgICAgICAgICAgICAgICAgICAgc2lsZW50OiAhdHJhbnNmb3JtYWJsZSxcbiAgICAgICAgICAgICAgICAgICAgaW52aXNpYmxlOiAhdHJhbnNmb3JtYWJsZSxcbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yOiB0cmFuc2Zvcm1hYmxlID8gQ1VSU09SX01BUFtnbG9iYWxEaXJdICsgJy1yZXNpemUnIDogbnVsbFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVwZGF0ZVJlY3RTaGFwZShjb250cm9sbGVyLCBjb3ZlciwgbmFtZSwgeCwgeSwgdywgaCkge1xuICAgICAgICB2YXIgZWwgPSBjb3Zlci5jaGlsZE9mTmFtZShuYW1lKTtcbiAgICAgICAgZWwgJiYgZWwuc2V0U2hhcGUocG9pbnRzVG9SZWN0KFxuICAgICAgICAgICAgY2xpcEJ5UGFuZWwoY29udHJvbGxlciwgY292ZXIsIFtbeCwgeV0sIFt4ICsgdywgeSArIGhdXSlcbiAgICAgICAgKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZVN0eWxlKGJydXNoT3B0aW9uKSB7XG4gICAgICAgIHJldHVybiB6clV0aWwuZGVmYXVsdHMoe3N0cm9rZU5vU2NhbGU6IHRydWV9LCBicnVzaE9wdGlvbi5icnVzaFN0eWxlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JtYXRSZWN0UmFuZ2UoeCwgeSwgeDIsIHkyKSB7XG4gICAgICAgIHZhciBtaW4gPSBbbWF0aE1pbih4LCB4MiksIG1hdGhNaW4oeSwgeTIpXTtcbiAgICAgICAgdmFyIG1heCA9IFttYXRoTWF4KHgsIHgyKSwgbWF0aE1heCh5LCB5MildO1xuXG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBbbWluWzBdLCBtYXhbMF1dLCAvLyB4IHJhbmdlXG4gICAgICAgICAgICBbbWluWzFdLCBtYXhbMV1dIC8vIHkgcmFuZ2VcbiAgICAgICAgXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRUcmFuc2Zvcm0oY29udHJvbGxlcikge1xuICAgICAgICByZXR1cm4gZ3JhcGhpYy5nZXRUcmFuc2Zvcm0oY29udHJvbGxlci5ncm91cCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0R2xvYmFsRGlyZWN0aW9uKGNvbnRyb2xsZXIsIGxvY2FsRGlyZWN0aW9uKSB7XG4gICAgICAgIGlmIChsb2NhbERpcmVjdGlvbi5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBsb2NhbERpcmVjdGlvbiA9IGxvY2FsRGlyZWN0aW9uLnNwbGl0KCcnKTtcbiAgICAgICAgICAgIHZhciBnbG9iYWxEaXIgPSBbXG4gICAgICAgICAgICAgICAgZ2V0R2xvYmFsRGlyZWN0aW9uKGNvbnRyb2xsZXIsIGxvY2FsRGlyZWN0aW9uWzBdKSxcbiAgICAgICAgICAgICAgICBnZXRHbG9iYWxEaXJlY3Rpb24oY29udHJvbGxlciwgbG9jYWxEaXJlY3Rpb25bMV0pXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgKGdsb2JhbERpclswXSA9PT0gJ2UnIHx8IGdsb2JhbERpclswXSA9PT0gJ3cnKSAmJiBnbG9iYWxEaXIucmV2ZXJzZSgpO1xuICAgICAgICAgICAgcmV0dXJuIGdsb2JhbERpci5qb2luKCcnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBtYXAgPSB7dzogJ2xlZnQnLCBlOiAncmlnaHQnLCBuOiAndG9wJywgczogJ2JvdHRvbSd9O1xuICAgICAgICAgICAgdmFyIGludmVyc2VNYXAgPSB7bGVmdDogJ3cnLCByaWdodDogJ2UnLCB0b3A6ICduJywgYm90dG9tOiAncyd9O1xuICAgICAgICAgICAgdmFyIGdsb2JhbERpciA9IGdyYXBoaWMudHJhbnNmb3JtRGlyZWN0aW9uKFxuICAgICAgICAgICAgICAgIG1hcFtsb2NhbERpcmVjdGlvbl0sIGdldFRyYW5zZm9ybShjb250cm9sbGVyKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybiBpbnZlcnNlTWFwW2dsb2JhbERpcl07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkcmlmdFJlY3QodG9SZWN0UmFuZ2UsIGZyb21SZWN0UmFuZ2UsIGNvbnRyb2xsZXIsIGNvdmVyLCBuYW1lLCBkeCwgZHksIGUpIHtcbiAgICAgICAgdmFyIGJydXNoT3B0aW9uID0gY292ZXIuX19icnVzaE9wdGlvbjtcbiAgICAgICAgdmFyIHJlY3RSYW5nZSA9IHRvUmVjdFJhbmdlKGJydXNoT3B0aW9uLnJhbmdlKTtcbiAgICAgICAgdmFyIGxvY2FsRGVsdGEgPSB0b0xvY2FsRGVsdGEoY29udHJvbGxlciwgZHgsIGR5KTtcblxuICAgICAgICBlYWNoKG5hbWUuc3BsaXQoJycpLCBmdW5jdGlvbiAobmFtZVBhcnQpIHtcbiAgICAgICAgICAgIHZhciBpbmQgPSBESVJFQ1RJT05fTUFQW25hbWVQYXJ0XTtcbiAgICAgICAgICAgIHJlY3RSYW5nZVtpbmRbMF1dW2luZFsxXV0gKz0gbG9jYWxEZWx0YVtpbmRbMF1dO1xuICAgICAgICB9KTtcblxuICAgICAgICBicnVzaE9wdGlvbi5yYW5nZSA9IGZyb21SZWN0UmFuZ2UoZm9ybWF0UmVjdFJhbmdlKFxuICAgICAgICAgICAgcmVjdFJhbmdlWzBdWzBdLCByZWN0UmFuZ2VbMV1bMF0sIHJlY3RSYW5nZVswXVsxXSwgcmVjdFJhbmdlWzFdWzFdXG4gICAgICAgICkpO1xuXG4gICAgICAgIHVwZGF0ZUNvdmVyQWZ0ZXJDcmVhdGlvbihjb250cm9sbGVyLCBjb3Zlcik7XG4gICAgICAgIHRyaWdnZXIoY29udHJvbGxlciwge2lzRW5kOiBmYWxzZX0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRyaWZ0UG9seWdvbihjb250cm9sbGVyLCBjb3ZlciwgZHgsIGR5LCBlKSB7XG4gICAgICAgIHZhciByYW5nZSA9IGNvdmVyLl9fYnJ1c2hPcHRpb24ucmFuZ2U7XG4gICAgICAgIHZhciBsb2NhbERlbHRhID0gdG9Mb2NhbERlbHRhKGNvbnRyb2xsZXIsIGR4LCBkeSk7XG5cbiAgICAgICAgZWFjaChyYW5nZSwgZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICAgICAgICBwb2ludFswXSArPSBsb2NhbERlbHRhWzBdO1xuICAgICAgICAgICAgcG9pbnRbMV0gKz0gbG9jYWxEZWx0YVsxXTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdXBkYXRlQ292ZXJBZnRlckNyZWF0aW9uKGNvbnRyb2xsZXIsIGNvdmVyKTtcbiAgICAgICAgdHJpZ2dlcihjb250cm9sbGVyLCB7aXNFbmQ6IGZhbHNlfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9Mb2NhbERlbHRhKGNvbnRyb2xsZXIsIGR4LCBkeSkge1xuICAgICAgICB2YXIgdGhpc0dyb3VwID0gY29udHJvbGxlci5ncm91cDtcbiAgICAgICAgdmFyIGxvY2FsRCA9IHRoaXNHcm91cC50cmFuc2Zvcm1Db29yZFRvTG9jYWwoZHgsIGR5KTtcbiAgICAgICAgdmFyIGxvY2FsWmVybyA9IHRoaXNHcm91cC50cmFuc2Zvcm1Db29yZFRvTG9jYWwoMCwgMCk7XG5cbiAgICAgICAgcmV0dXJuIFtsb2NhbERbMF0gLSBsb2NhbFplcm9bMF0sIGxvY2FsRFsxXSAtIGxvY2FsWmVyb1sxXV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xpcEJ5UGFuZWwoY29udHJvbGxlciwgY292ZXIsIGRhdGEpIHtcbiAgICAgICAgdmFyIHBhbmVsID0gZ2V0UGFuZWxCeUNvdmVyKGNvbnRyb2xsZXIsIGNvdmVyKTtcblxuICAgICAgICByZXR1cm4gKHBhbmVsICYmIHBhbmVsICE9PSB0cnVlKVxuICAgICAgICAgICAgPyBwYW5lbC5jbGlwUGF0aChkYXRhLCBjb250cm9sbGVyLl90cmFuc2Zvcm0pXG4gICAgICAgICAgICA6IHpyVXRpbC5jbG9uZShkYXRhKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwb2ludHNUb1JlY3QocG9pbnRzKSB7XG4gICAgICAgIHZhciB4bWluID0gbWF0aE1pbihwb2ludHNbMF1bMF0sIHBvaW50c1sxXVswXSk7XG4gICAgICAgIHZhciB5bWluID0gbWF0aE1pbihwb2ludHNbMF1bMV0sIHBvaW50c1sxXVsxXSk7XG4gICAgICAgIHZhciB4bWF4ID0gbWF0aE1heChwb2ludHNbMF1bMF0sIHBvaW50c1sxXVswXSk7XG4gICAgICAgIHZhciB5bWF4ID0gbWF0aE1heChwb2ludHNbMF1bMV0sIHBvaW50c1sxXVsxXSk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IHhtaW4sXG4gICAgICAgICAgICB5OiB5bWluLFxuICAgICAgICAgICAgd2lkdGg6IHhtYXggLSB4bWluLFxuICAgICAgICAgICAgaGVpZ2h0OiB5bWF4IC0geW1pblxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlc2V0Q3Vyc29yKGNvbnRyb2xsZXIsIGUsIGxvY2FsQ3Vyc29yUG9pbnQpIHtcbiAgICAgICAgLy8gQ2hlY2sgYWN0aXZlXG4gICAgICAgIGlmICghY29udHJvbGxlci5fYnJ1c2hUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgenIgPSBjb250cm9sbGVyLl96cjtcbiAgICAgICAgdmFyIGNvdmVycyA9IGNvbnRyb2xsZXIuX2NvdmVycztcbiAgICAgICAgdmFyIGN1cnJQYW5lbCA9IGdldFBhbmVsQnlQb2ludChjb250cm9sbGVyLCBlLCBsb2NhbEN1cnNvclBvaW50KTtcblxuICAgICAgICAvLyBDaGVjayB3aGV0aGVyIGluIGNvdmVycy5cbiAgICAgICAgaWYgKCFjb250cm9sbGVyLl9kcmFnZ2luZykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3ZlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgYnJ1c2hPcHRpb24gPSBjb3ZlcnNbaV0uX19icnVzaE9wdGlvbjtcbiAgICAgICAgICAgICAgICBpZiAoY3VyclBhbmVsXG4gICAgICAgICAgICAgICAgICAgICYmIChjdXJyUGFuZWwgPT09IHRydWUgfHwgYnJ1c2hPcHRpb24ucGFuZWxJZCA9PT0gY3VyclBhbmVsLnBhbmVsSWQpXG4gICAgICAgICAgICAgICAgICAgICYmIGNvdmVyUmVuZGVyZXJzW2JydXNoT3B0aW9uLmJydXNoVHlwZV0uY29udGFpbihcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdmVyc1tpXSwgbG9jYWxDdXJzb3JQb2ludFswXSwgbG9jYWxDdXJzb3JQb2ludFsxXVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVzZSBjdXJzb3Igc3R5bGUgc2V0IG9uIGNvdmVyLlxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY3VyclBhbmVsICYmIHpyLnNldEN1cnNvclN0eWxlKCdjcm9zc2hhaXInKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmV2ZW50RGVmYXVsdChlKSB7XG4gICAgICAgIHZhciByYXdFID0gZS5ldmVudDtcbiAgICAgICAgcmF3RS5wcmV2ZW50RGVmYXVsdCAmJiByYXdFLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFpblNoYXBlQ29udGFpbihjb3ZlciwgeCwgeSkge1xuICAgICAgICByZXR1cm4gY292ZXIuY2hpbGRPZk5hbWUoJ21haW4nKS5jb250YWluKHgsIHkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVwZGF0ZUNvdmVyQnlNb3VzZShjb250cm9sbGVyLCBlLCBsb2NhbEN1cnNvclBvaW50LCBpc0VuZCkge1xuICAgICAgICB2YXIgY3JlYXRpbmdDb3ZlciA9IGNvbnRyb2xsZXIuX2NyZWF0aW5nQ292ZXI7XG4gICAgICAgIHZhciBwYW5lbCA9IGNvbnRyb2xsZXIuX2NyZWF0aW5nUGFuZWw7XG4gICAgICAgIHZhciB0aGlzQnJ1c2hPcHRpb24gPSBjb250cm9sbGVyLl9icnVzaE9wdGlvbjtcbiAgICAgICAgdmFyIGV2ZW50UGFyYW1zO1xuXG4gICAgICAgIGNvbnRyb2xsZXIuX3RyYWNrLnB1c2gobG9jYWxDdXJzb3JQb2ludC5zbGljZSgpKTtcblxuICAgICAgICBpZiAoc2hvdWxkU2hvd0NvdmVyKGNvbnRyb2xsZXIpIHx8IGNyZWF0aW5nQ292ZXIpIHtcblxuICAgICAgICAgICAgaWYgKHBhbmVsICYmICFjcmVhdGluZ0NvdmVyKSB7XG4gICAgICAgICAgICAgICAgdGhpc0JydXNoT3B0aW9uLmJydXNoTW9kZSA9PT0gJ3NpbmdsZScgJiYgY2xlYXJDb3ZlcnMoY29udHJvbGxlcik7XG4gICAgICAgICAgICAgICAgdmFyIGJydXNoT3B0aW9uID0genJVdGlsLmNsb25lKHRoaXNCcnVzaE9wdGlvbik7XG4gICAgICAgICAgICAgICAgYnJ1c2hPcHRpb24uYnJ1c2hUeXBlID0gZGV0ZXJtaW5lQnJ1c2hUeXBlKGJydXNoT3B0aW9uLmJydXNoVHlwZSwgcGFuZWwpO1xuICAgICAgICAgICAgICAgIGJydXNoT3B0aW9uLnBhbmVsSWQgPSBwYW5lbCA9PT0gdHJ1ZSA/IG51bGwgOiBwYW5lbC5wYW5lbElkO1xuICAgICAgICAgICAgICAgIGNyZWF0aW5nQ292ZXIgPSBjb250cm9sbGVyLl9jcmVhdGluZ0NvdmVyID0gY3JlYXRlQ292ZXIoY29udHJvbGxlciwgYnJ1c2hPcHRpb24pO1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuX2NvdmVycy5wdXNoKGNyZWF0aW5nQ292ZXIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY3JlYXRpbmdDb3Zlcikge1xuICAgICAgICAgICAgICAgIHZhciBjb3ZlclJlbmRlcmVyID0gY292ZXJSZW5kZXJlcnNbZGV0ZXJtaW5lQnJ1c2hUeXBlKGNvbnRyb2xsZXIuX2JydXNoVHlwZSwgcGFuZWwpXTtcbiAgICAgICAgICAgICAgICB2YXIgY292ZXJCcnVzaE9wdGlvbiA9IGNyZWF0aW5nQ292ZXIuX19icnVzaE9wdGlvbjtcblxuICAgICAgICAgICAgICAgIGNvdmVyQnJ1c2hPcHRpb24ucmFuZ2UgPSBjb3ZlclJlbmRlcmVyLmdldENyZWF0aW5nUmFuZ2UoXG4gICAgICAgICAgICAgICAgICAgIGNsaXBCeVBhbmVsKGNvbnRyb2xsZXIsIGNyZWF0aW5nQ292ZXIsIGNvbnRyb2xsZXIuX3RyYWNrKVxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNFbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgZW5kQ3JlYXRpbmcoY29udHJvbGxlciwgY3JlYXRpbmdDb3Zlcik7XG4gICAgICAgICAgICAgICAgICAgIGNvdmVyUmVuZGVyZXIudXBkYXRlQ29tbW9uKGNvbnRyb2xsZXIsIGNyZWF0aW5nQ292ZXIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHVwZGF0ZUNvdmVyU2hhcGUoY29udHJvbGxlciwgY3JlYXRpbmdDb3Zlcik7XG5cbiAgICAgICAgICAgICAgICBldmVudFBhcmFtcyA9IHtpc0VuZDogaXNFbmR9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFxuICAgICAgICAgICAgaXNFbmRcbiAgICAgICAgICAgICYmIHRoaXNCcnVzaE9wdGlvbi5icnVzaE1vZGUgPT09ICdzaW5nbGUnXG4gICAgICAgICAgICAmJiB0aGlzQnJ1c2hPcHRpb24ucmVtb3ZlT25DbGlja1xuICAgICAgICApIHtcbiAgICAgICAgICAgIC8vIEhlbHAgdXNlciB0byByZW1vdmUgY292ZXJzIGVhc2lseSwgb25seSBieSBhIHRpbnkgZHJhZywgaW4gJ3NpbmdsZScgbW9kZS5cbiAgICAgICAgICAgIC8vIEJ1dCBhIHNpbmdsZSBjbGljayBkbyBub3QgY2xlYXIgY292ZXJzLCBiZWNhdXNlIHVzZXIgbWF5IGhhdmUgY2FzdWFsXG4gICAgICAgICAgICAvLyBjbGlja3MgKGZvciBleGFtcGxlLCBjbGljayBvbiBvdGhlciBjb21wb25lbnQgYW5kIGRvIG5vdCBleHBlY3QgY292ZXJzXG4gICAgICAgICAgICAvLyBkaXNhcHBlYXIpLlxuICAgICAgICAgICAgLy8gT25seSBzb21lIGNvdmVyIHJlbW92ZWQsIHRyaWdnZXIgYWN0aW9uLCBidXQgbm90IGV2ZXJ5IGNsaWNrIHRyaWdnZXIgYWN0aW9uLlxuICAgICAgICAgICAgaWYgKGdldFBhbmVsQnlQb2ludChjb250cm9sbGVyLCBlLCBsb2NhbEN1cnNvclBvaW50KSAmJiBjbGVhckNvdmVycyhjb250cm9sbGVyKSkge1xuICAgICAgICAgICAgICAgIGV2ZW50UGFyYW1zID0ge2lzRW5kOiBpc0VuZCwgcmVtb3ZlT25DbGljazogdHJ1ZX07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXZlbnRQYXJhbXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGV0ZXJtaW5lQnJ1c2hUeXBlKGJydXNoVHlwZSwgcGFuZWwpIHtcbiAgICAgICAgaWYgKGJydXNoVHlwZSA9PT0gJ2F1dG8nKSB7XG4gICAgICAgICAgICBpZiAoX19ERVZfXykge1xuICAgICAgICAgICAgICAgIHpyVXRpbC5hc3NlcnQoXG4gICAgICAgICAgICAgICAgICAgIHBhbmVsICYmIHBhbmVsLmRlZmF1bHRCcnVzaFR5cGUsXG4gICAgICAgICAgICAgICAgICAgICdNVVNUIGhhdmUgZGVmYXVsdEJydXNoVHlwZSB3aGVuIGJydXNoVHlwZSBpcyBcImF0dW9cIidcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBhbmVsLmRlZmF1bHRCcnVzaFR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJydXNoVHlwZTtcbiAgICB9XG5cbiAgICB2YXIgbW91c2VIYW5kbGVycyA9IHtcblxuICAgICAgICBtb3VzZWRvd246IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fZHJhZ2dpbmcpIHtcbiAgICAgICAgICAgICAgICAvLyBJbiBjYXNlIHNvbWUgYnJvd3NlciBkbyBub3Qgc3VwcG9ydCBnbG9iYWxPdXQsXG4gICAgICAgICAgICAgICAgLy8gYW5kIHJlbGVhc2UgbW9zZSBvdXQgc2lkZSB0aGUgYnJvd3Nlci5cbiAgICAgICAgICAgICAgICBoYW5kbGVEcmFnRW5kLmNhbGwodGhpcywgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghZS50YXJnZXQgfHwgIWUudGFyZ2V0LmRyYWdnYWJsZSkge1xuXG4gICAgICAgICAgICAgICAgcHJldmVudERlZmF1bHQoZSk7XG5cbiAgICAgICAgICAgICAgICB2YXIgbG9jYWxDdXJzb3JQb2ludCA9IHRoaXMuZ3JvdXAudHJhbnNmb3JtQ29vcmRUb0xvY2FsKGUub2Zmc2V0WCwgZS5vZmZzZXRZKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuX2NyZWF0aW5nQ292ZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgIHZhciBwYW5lbCA9IHRoaXMuX2NyZWF0aW5nUGFuZWwgPSBnZXRQYW5lbEJ5UG9pbnQodGhpcywgZSwgbG9jYWxDdXJzb3JQb2ludCk7XG5cbiAgICAgICAgICAgICAgICBpZiAocGFuZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90cmFjayA9IFtsb2NhbEN1cnNvclBvaW50LnNsaWNlKCldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBtb3VzZW1vdmU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB2YXIgbG9jYWxDdXJzb3JQb2ludCA9IHRoaXMuZ3JvdXAudHJhbnNmb3JtQ29vcmRUb0xvY2FsKGUub2Zmc2V0WCwgZS5vZmZzZXRZKTtcblxuICAgICAgICAgICAgcmVzZXRDdXJzb3IodGhpcywgZSwgbG9jYWxDdXJzb3JQb2ludCk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9kcmFnZ2luZykge1xuXG4gICAgICAgICAgICAgICAgcHJldmVudERlZmF1bHQoZSk7XG5cbiAgICAgICAgICAgICAgICB2YXIgZXZlbnRQYXJhbXMgPSB1cGRhdGVDb3ZlckJ5TW91c2UodGhpcywgZSwgbG9jYWxDdXJzb3JQb2ludCwgZmFsc2UpO1xuXG4gICAgICAgICAgICAgICAgZXZlbnRQYXJhbXMgJiYgdHJpZ2dlcih0aGlzLCBldmVudFBhcmFtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgbW91c2V1cDogaGFuZGxlRHJhZ0VuZCAvLyxcblxuICAgICAgICAvLyBGSVhNRVxuICAgICAgICAvLyBpbiB0b29sdGlwLCBnbG9iYWxvdXQgc2hvdWxkIG5vdCBiZSB0cmlnZ2VyZWQuXG4gICAgICAgIC8vIGdsb2JhbG91dDogaGFuZGxlRHJhZ0VuZFxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVEcmFnRW5kKGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RyYWdnaW5nKSB7XG5cbiAgICAgICAgICAgIHByZXZlbnREZWZhdWx0KGUpO1xuXG4gICAgICAgICAgICB2YXIgbG9jYWxDdXJzb3JQb2ludCA9IHRoaXMuZ3JvdXAudHJhbnNmb3JtQ29vcmRUb0xvY2FsKGUub2Zmc2V0WCwgZS5vZmZzZXRZKTtcbiAgICAgICAgICAgIHZhciBldmVudFBhcmFtcyA9IHVwZGF0ZUNvdmVyQnlNb3VzZSh0aGlzLCBlLCBsb2NhbEN1cnNvclBvaW50LCB0cnVlKTtcblxuICAgICAgICAgICAgdGhpcy5fZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX3RyYWNrID0gW107XG4gICAgICAgICAgICB0aGlzLl9jcmVhdGluZ0NvdmVyID0gbnVsbDtcblxuICAgICAgICAgICAgLy8gdHJpZ2dlciBldmVudCBzaG91bGUgYmUgYXQgZmluYWwsIGFmdGVyIHByb2NlZHVyZSB3aWxsIGJlIG5lc3RlZC5cbiAgICAgICAgICAgIGV2ZW50UGFyYW1zICYmIHRyaWdnZXIodGhpcywgZXZlbnRQYXJhbXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICoga2V5OiBicnVzaFR5cGVcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIHZhciBjb3ZlclJlbmRlcmVycyA9IHtcblxuICAgICAgICBsaW5lWDogZ2V0TGluZVJlbmRlcmVyKDApLFxuXG4gICAgICAgIGxpbmVZOiBnZXRMaW5lUmVuZGVyZXIoMSksXG5cbiAgICAgICAgcmVjdDoge1xuICAgICAgICAgICAgY3JlYXRlQ292ZXI6IGZ1bmN0aW9uIChjb250cm9sbGVyLCBicnVzaE9wdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVCYXNlUmVjdENvdmVyKFxuICAgICAgICAgICAgICAgICAgICBjdXJyeShcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyaWZ0UmVjdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChyYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByYW5nZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIsXG4gICAgICAgICAgICAgICAgICAgIGJydXNoT3B0aW9uLFxuICAgICAgICAgICAgICAgICAgICBbJ3cnLCAnZScsICduJywgJ3MnLCAnc2UnLCAnc3cnLCAnbmUnLCAnbncnXVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0Q3JlYXRpbmdSYW5nZTogZnVuY3Rpb24gKGxvY2FsVHJhY2spIHtcbiAgICAgICAgICAgICAgICB2YXIgZW5kcyA9IGdldFRyYWNrRW5kcyhsb2NhbFRyYWNrKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm9ybWF0UmVjdFJhbmdlKGVuZHNbMV1bMF0sIGVuZHNbMV1bMV0sIGVuZHNbMF1bMF0sIGVuZHNbMF1bMV0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVwZGF0ZUNvdmVyU2hhcGU6IGZ1bmN0aW9uIChjb250cm9sbGVyLCBjb3ZlciwgbG9jYWxSYW5nZSwgYnJ1c2hPcHRpb24pIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVCYXNlUmVjdChjb250cm9sbGVyLCBjb3ZlciwgbG9jYWxSYW5nZSwgYnJ1c2hPcHRpb24pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVwZGF0ZUNvbW1vbjogdXBkYXRlQ29tbW9uLFxuICAgICAgICAgICAgY29udGFpbjogbWFpblNoYXBlQ29udGFpblxuICAgICAgICB9LFxuXG4gICAgICAgIHBvbHlnb246IHtcbiAgICAgICAgICAgIGNyZWF0ZUNvdmVyOiBmdW5jdGlvbiAoY29udHJvbGxlciwgYnJ1c2hPcHRpb24pIHtcbiAgICAgICAgICAgICAgICB2YXIgY292ZXIgPSBuZXcgZ3JhcGhpYy5Hcm91cCgpO1xuXG4gICAgICAgICAgICAgICAgLy8gRG8gbm90IHVzZSBncmFwaGljLlBvbHlnb24gYmVjYXVzZSBncmFwaGljLlBvbHlsaW5lIGRvIG5vdCBjbG9zZSB0aGVcbiAgICAgICAgICAgICAgICAvLyBib3JkZXIgb2YgdGhlIHNoYXBlIHdoZW4gZHJhd2luZywgd2hpY2ggaXMgYSBiZXR0ZXIgZXhwZXJpZW5jZSBmb3IgdXNlci5cbiAgICAgICAgICAgICAgICBjb3Zlci5hZGQobmV3IGdyYXBoaWMuUG9seWxpbmUoe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnbWFpbicsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiBtYWtlU3R5bGUoYnJ1c2hPcHRpb24pLFxuICAgICAgICAgICAgICAgICAgICBzaWxlbnQ6IHRydWVcbiAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gY292ZXI7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0Q3JlYXRpbmdSYW5nZTogZnVuY3Rpb24gKGxvY2FsVHJhY2spIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxUcmFjaztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbmRDcmVhdGluZzogZnVuY3Rpb24gKGNvbnRyb2xsZXIsIGNvdmVyKSB7XG4gICAgICAgICAgICAgICAgY292ZXIucmVtb3ZlKGNvdmVyLmNoaWxkQXQoMCkpO1xuICAgICAgICAgICAgICAgIC8vIFVzZSBncmFwaGljLlBvbHlnb24gY2xvc2UgdGhlIHNoYXBlLlxuICAgICAgICAgICAgICAgIGNvdmVyLmFkZChuZXcgZ3JhcGhpYy5Qb2x5Z29uKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ21haW4nLFxuICAgICAgICAgICAgICAgICAgICBkcmFnZ2FibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGRyaWZ0OiBjdXJyeShkcmlmdFBvbHlnb24sIGNvbnRyb2xsZXIsIGNvdmVyKSxcbiAgICAgICAgICAgICAgICAgICAgb25kcmFnZW5kOiBjdXJyeSh0cmlnZ2VyLCBjb250cm9sbGVyLCB7aXNFbmQ6IHRydWV9KVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1cGRhdGVDb3ZlclNoYXBlOiBmdW5jdGlvbiAoY29udHJvbGxlciwgY292ZXIsIGxvY2FsUmFuZ2UsIGJydXNoT3B0aW9uKSB7XG4gICAgICAgICAgICAgICAgY292ZXIuY2hpbGRBdCgwKS5zZXRTaGFwZSh7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50czogY2xpcEJ5UGFuZWwoY29udHJvbGxlciwgY292ZXIsIGxvY2FsUmFuZ2UpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdXBkYXRlQ29tbW9uOiB1cGRhdGVDb21tb24sXG4gICAgICAgICAgICBjb250YWluOiBtYWluU2hhcGVDb250YWluXG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZ2V0TGluZVJlbmRlcmVyKHh5SW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNyZWF0ZUNvdmVyOiBmdW5jdGlvbiAoY29udHJvbGxlciwgYnJ1c2hPcHRpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQmFzZVJlY3RDb3ZlcihcbiAgICAgICAgICAgICAgICAgICAgY3VycnkoXG4gICAgICAgICAgICAgICAgICAgICAgICBkcmlmdFJlY3QsXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVjdFJhbmdlID0gW3JhbmdlLCBbMCwgMTAwXV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeHlJbmRleCAmJiByZWN0UmFuZ2UucmV2ZXJzZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWN0UmFuZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKHJlY3RSYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWN0UmFuZ2VbeHlJbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIsXG4gICAgICAgICAgICAgICAgICAgIGJydXNoT3B0aW9uLFxuICAgICAgICAgICAgICAgICAgICBbWyd3JywgJ2UnXSwgWyduJywgJ3MnXV1beHlJbmRleF1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldENyZWF0aW5nUmFuZ2U6IGZ1bmN0aW9uIChsb2NhbFRyYWNrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVuZHMgPSBnZXRUcmFja0VuZHMobG9jYWxUcmFjayk7XG4gICAgICAgICAgICAgICAgdmFyIG1pbiA9IG1hdGhNaW4oZW5kc1swXVt4eUluZGV4XSwgZW5kc1sxXVt4eUluZGV4XSk7XG4gICAgICAgICAgICAgICAgdmFyIG1heCA9IG1hdGhNYXgoZW5kc1swXVt4eUluZGV4XSwgZW5kc1sxXVt4eUluZGV4XSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gW21pbiwgbWF4XTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1cGRhdGVDb3ZlclNoYXBlOiBmdW5jdGlvbiAoY29udHJvbGxlciwgY292ZXIsIGxvY2FsUmFuZ2UsIGJydXNoT3B0aW9uKSB7XG4gICAgICAgICAgICAgICAgdmFyIG90aGVyRXh0ZW50O1xuICAgICAgICAgICAgICAgIC8vIElmIGJydXNoV2lkdGggbm90IHNwZWNpZmllZCwgZml0IHRoZSBwYW5lbC5cbiAgICAgICAgICAgICAgICB2YXIgcGFuZWwgPSBnZXRQYW5lbEJ5Q292ZXIoY29udHJvbGxlciwgY292ZXIpO1xuICAgICAgICAgICAgICAgIGlmIChwYW5lbCAhPT0gdHJ1ZSAmJiBwYW5lbC5nZXRMaW5lYXJCcnVzaE90aGVyRXh0ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIG90aGVyRXh0ZW50ID0gcGFuZWwuZ2V0TGluZWFyQnJ1c2hPdGhlckV4dGVudChcbiAgICAgICAgICAgICAgICAgICAgICAgIHh5SW5kZXgsIGNvbnRyb2xsZXIuX3RyYW5zZm9ybVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHpyID0gY29udHJvbGxlci5fenI7XG4gICAgICAgICAgICAgICAgICAgIG90aGVyRXh0ZW50ID0gWzAsIFt6ci5nZXRXaWR0aCgpLCB6ci5nZXRIZWlnaHQoKV1bMSAtIHh5SW5kZXhdXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHJlY3RSYW5nZSA9IFtsb2NhbFJhbmdlLCBvdGhlckV4dGVudF07XG4gICAgICAgICAgICAgICAgeHlJbmRleCAmJiByZWN0UmFuZ2UucmV2ZXJzZSgpO1xuXG4gICAgICAgICAgICAgICAgdXBkYXRlQmFzZVJlY3QoY29udHJvbGxlciwgY292ZXIsIHJlY3RSYW5nZSwgYnJ1c2hPcHRpb24pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVwZGF0ZUNvbW1vbjogdXBkYXRlQ29tbW9uLFxuICAgICAgICAgICAgY29udGFpbjogbWFpblNoYXBlQ29udGFpblxuICAgICAgICB9O1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gQnJ1c2hDb250cm9sbGVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvY29tcG9uZW50L2hlbHBlci9CcnVzaENvbnRyb2xsZXIuanNcbi8vIG1vZHVsZSBpZCA9IDE1NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 157 */
/* unknown exports provided */
/* all exports used */
/*!**********************************************!*\
  !*** ./lib/component/helper/cursorHelper.js ***!
  \**********************************************/
/***/ (function(module, exports) {

eval("\n\n    var helper = {};\n\n    var IRRELEVANT_EXCLUDES = {'axisPointer': 1, 'tooltip': 1, 'brush': 1};\n\n    /**\n     * Avoid that: mouse click on a elements that is over geo or graph,\n     * but roam is triggered.\n     */\n    helper.onIrrelevantElement = function (e, api, targetCoordSysModel) {\n        var model = api.getComponentByElement(e.topTarget);\n        // If model is axisModel, it works only if it is injected with coordinateSystem.\n        var coordSys = model && model.coordinateSystem;\n        return model\n            && model !== targetCoordSysModel\n            && !IRRELEVANT_EXCLUDES[model.mainType]\n            && (coordSys && coordSys.model !== targetCoordSysModel);\n    };\n\n    module.exports = helper;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTU3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2NvbXBvbmVudC9oZWxwZXIvY3Vyc29ySGVscGVyLmpzPzdkOWIiXSwic291cmNlc0NvbnRlbnQiOlsiXG5cbiAgICB2YXIgaGVscGVyID0ge307XG5cbiAgICB2YXIgSVJSRUxFVkFOVF9FWENMVURFUyA9IHsnYXhpc1BvaW50ZXInOiAxLCAndG9vbHRpcCc6IDEsICdicnVzaCc6IDF9O1xuXG4gICAgLyoqXG4gICAgICogQXZvaWQgdGhhdDogbW91c2UgY2xpY2sgb24gYSBlbGVtZW50cyB0aGF0IGlzIG92ZXIgZ2VvIG9yIGdyYXBoLFxuICAgICAqIGJ1dCByb2FtIGlzIHRyaWdnZXJlZC5cbiAgICAgKi9cbiAgICBoZWxwZXIub25JcnJlbGV2YW50RWxlbWVudCA9IGZ1bmN0aW9uIChlLCBhcGksIHRhcmdldENvb3JkU3lzTW9kZWwpIHtcbiAgICAgICAgdmFyIG1vZGVsID0gYXBpLmdldENvbXBvbmVudEJ5RWxlbWVudChlLnRvcFRhcmdldCk7XG4gICAgICAgIC8vIElmIG1vZGVsIGlzIGF4aXNNb2RlbCwgaXQgd29ya3Mgb25seSBpZiBpdCBpcyBpbmplY3RlZCB3aXRoIGNvb3JkaW5hdGVTeXN0ZW0uXG4gICAgICAgIHZhciBjb29yZFN5cyA9IG1vZGVsICYmIG1vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG4gICAgICAgIHJldHVybiBtb2RlbFxuICAgICAgICAgICAgJiYgbW9kZWwgIT09IHRhcmdldENvb3JkU3lzTW9kZWxcbiAgICAgICAgICAgICYmICFJUlJFTEVWQU5UX0VYQ0xVREVTW21vZGVsLm1haW5UeXBlXVxuICAgICAgICAgICAgJiYgKGNvb3JkU3lzICYmIGNvb3JkU3lzLm1vZGVsICE9PSB0YXJnZXRDb29yZFN5c01vZGVsKTtcbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBoZWxwZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9jb21wb25lbnQvaGVscGVyL2N1cnNvckhlbHBlci5qc1xuLy8gbW9kdWxlIGlkID0gMTU3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 158 */
/* unknown exports provided */
/* all exports used */
/*!**************************************************!*\
  !*** ./lib/component/helper/interactionMutex.js ***!
  \**************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var ATTR = '\\0_ec_interaction_mutex';\n\n    var interactionMutex = {\n\n        take: function (zr, resourceKey, userKey) {\n            var store = getStore(zr);\n            store[resourceKey] = userKey;\n        },\n\n        release: function (zr, resourceKey, userKey) {\n            var store = getStore(zr);\n            var uKey = store[resourceKey];\n\n            if (uKey === userKey) {\n                store[resourceKey] = null;\n            }\n        },\n\n        isTaken: function (zr, resourceKey) {\n            return !!getStore(zr)[resourceKey];\n        }\n    };\n\n    function getStore(zr) {\n        return zr[ATTR] || (zr[ATTR] = {});\n    }\n\n    /**\n     * payload: {\n     *     type: 'takeGlobalCursor',\n     *     key: 'dataZoomSelect', or 'brush', or ...,\n     *         If no userKey, release global cursor.\n     * }\n     */\n    __webpack_require__(/*! ../../echarts */ 1).registerAction(\n        {type: 'takeGlobalCursor', event: 'globalCursorTaken', update: 'update'},\n        function () {}\n    );\n\n    module.exports = interactionMutex;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTU4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2NvbXBvbmVudC9oZWxwZXIvaW50ZXJhY3Rpb25NdXRleC5qcz9mMWE1Il0sInNvdXJjZXNDb250ZW50IjpbIlxuXG4gICAgdmFyIEFUVFIgPSAnXFwwX2VjX2ludGVyYWN0aW9uX211dGV4JztcblxuICAgIHZhciBpbnRlcmFjdGlvbk11dGV4ID0ge1xuXG4gICAgICAgIHRha2U6IGZ1bmN0aW9uICh6ciwgcmVzb3VyY2VLZXksIHVzZXJLZXkpIHtcbiAgICAgICAgICAgIHZhciBzdG9yZSA9IGdldFN0b3JlKHpyKTtcbiAgICAgICAgICAgIHN0b3JlW3Jlc291cmNlS2V5XSA9IHVzZXJLZXk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVsZWFzZTogZnVuY3Rpb24gKHpyLCByZXNvdXJjZUtleSwgdXNlcktleSkge1xuICAgICAgICAgICAgdmFyIHN0b3JlID0gZ2V0U3RvcmUoenIpO1xuICAgICAgICAgICAgdmFyIHVLZXkgPSBzdG9yZVtyZXNvdXJjZUtleV07XG5cbiAgICAgICAgICAgIGlmICh1S2V5ID09PSB1c2VyS2V5KSB7XG4gICAgICAgICAgICAgICAgc3RvcmVbcmVzb3VyY2VLZXldID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBpc1Rha2VuOiBmdW5jdGlvbiAoenIsIHJlc291cmNlS2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gISFnZXRTdG9yZSh6cilbcmVzb3VyY2VLZXldO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGdldFN0b3JlKHpyKSB7XG4gICAgICAgIHJldHVybiB6cltBVFRSXSB8fCAoenJbQVRUUl0gPSB7fSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcGF5bG9hZDoge1xuICAgICAqICAgICB0eXBlOiAndGFrZUdsb2JhbEN1cnNvcicsXG4gICAgICogICAgIGtleTogJ2RhdGFab29tU2VsZWN0Jywgb3IgJ2JydXNoJywgb3IgLi4uLFxuICAgICAqICAgICAgICAgSWYgbm8gdXNlcktleSwgcmVsZWFzZSBnbG9iYWwgY3Vyc29yLlxuICAgICAqIH1cbiAgICAgKi9cbiAgICByZXF1aXJlKCcuLi8uLi9lY2hhcnRzJykucmVnaXN0ZXJBY3Rpb24oXG4gICAgICAgIHt0eXBlOiAndGFrZUdsb2JhbEN1cnNvcicsIGV2ZW50OiAnZ2xvYmFsQ3Vyc29yVGFrZW4nLCB1cGRhdGU6ICd1cGRhdGUnfSxcbiAgICAgICAgZnVuY3Rpb24gKCkge31cbiAgICApO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBpbnRlcmFjdGlvbk11dGV4O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvY29tcG9uZW50L2hlbHBlci9pbnRlcmFjdGlvbk11dGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxNThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 159 */
/* unknown exports provided */
/* all exports used */
/*!***********************************************!*\
  !*** ./lib/component/helper/listComponent.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\n    // List layout\n    var layout = __webpack_require__(/*! ../../util/layout */ 11);\n    var formatUtil = __webpack_require__(/*! ../../util/format */ 6);\n    var graphic = __webpack_require__(/*! ../../util/graphic */ 2);\n\n    function positionGroup(group, model, api) {\n        layout.positionElement(\n            group, model.getBoxLayoutParams(),\n            {\n                width: api.getWidth(),\n                height: api.getHeight()\n            },\n            model.get('padding')\n        );\n    }\n\n    module.exports = {\n        /**\n         * Layout list like component.\n         * It will box layout each items in group of component and then position the whole group in the viewport\n         * @param {module:zrender/group/Group} group\n         * @param {module:echarts/model/Component} componentModel\n         * @param {module:echarts/ExtensionAPI}\n         */\n        layout: function (group, componentModel, api) {\n            var rect = layout.getLayoutRect(componentModel.getBoxLayoutParams(), {\n                width: api.getWidth(),\n                height: api.getHeight()\n            }, componentModel.get('padding'));\n            layout.box(\n                componentModel.get('orient'),\n                group,\n                componentModel.get('itemGap'),\n                rect.width,\n                rect.height\n            );\n\n            positionGroup(group, componentModel, api);\n        },\n\n        addBackground: function (group, componentModel) {\n            var padding = formatUtil.normalizeCssArray(\n                componentModel.get('padding')\n            );\n            var boundingRect = group.getBoundingRect();\n            var style = componentModel.getItemStyle(['color', 'opacity']);\n            style.fill = componentModel.get('backgroundColor');\n            var rect = new graphic.Rect({\n                shape: {\n                    x: boundingRect.x - padding[3],\n                    y: boundingRect.y - padding[0],\n                    width: boundingRect.width + padding[1] + padding[3],\n                    height: boundingRect.height + padding[0] + padding[2]\n                },\n                style: style,\n                silent: true,\n                z2: -1\n            });\n            graphic.subPixelOptimizeRect(rect);\n\n            group.add(rect);\n        }\n    };\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTU5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2NvbXBvbmVudC9oZWxwZXIvbGlzdENvbXBvbmVudC5qcz85YWJjIl0sInNvdXJjZXNDb250ZW50IjpbIlxuICAgIC8vIExpc3QgbGF5b3V0XG4gICAgdmFyIGxheW91dCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvbGF5b3V0Jyk7XG4gICAgdmFyIGZvcm1hdFV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL2Zvcm1hdCcpO1xuICAgIHZhciBncmFwaGljID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9ncmFwaGljJyk7XG5cbiAgICBmdW5jdGlvbiBwb3NpdGlvbkdyb3VwKGdyb3VwLCBtb2RlbCwgYXBpKSB7XG4gICAgICAgIGxheW91dC5wb3NpdGlvbkVsZW1lbnQoXG4gICAgICAgICAgICBncm91cCwgbW9kZWwuZ2V0Qm94TGF5b3V0UGFyYW1zKCksXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IGFwaS5nZXRXaWR0aCgpLFxuICAgICAgICAgICAgICAgIGhlaWdodDogYXBpLmdldEhlaWdodCgpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbW9kZWwuZ2V0KCdwYWRkaW5nJylcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExheW91dCBsaXN0IGxpa2UgY29tcG9uZW50LlxuICAgICAgICAgKiBJdCB3aWxsIGJveCBsYXlvdXQgZWFjaCBpdGVtcyBpbiBncm91cCBvZiBjb21wb25lbnQgYW5kIHRoZW4gcG9zaXRpb24gdGhlIHdob2xlIGdyb3VwIGluIHRoZSB2aWV3cG9ydFxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2dyb3VwL0dyb3VwfSBncm91cFxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL0NvbXBvbmVudH0gY29tcG9uZW50TW9kZWxcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9FeHRlbnNpb25BUEl9XG4gICAgICAgICAqL1xuICAgICAgICBsYXlvdXQ6IGZ1bmN0aW9uIChncm91cCwgY29tcG9uZW50TW9kZWwsIGFwaSkge1xuICAgICAgICAgICAgdmFyIHJlY3QgPSBsYXlvdXQuZ2V0TGF5b3V0UmVjdChjb21wb25lbnRNb2RlbC5nZXRCb3hMYXlvdXRQYXJhbXMoKSwge1xuICAgICAgICAgICAgICAgIHdpZHRoOiBhcGkuZ2V0V2lkdGgoKSxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGFwaS5nZXRIZWlnaHQoKVxuICAgICAgICAgICAgfSwgY29tcG9uZW50TW9kZWwuZ2V0KCdwYWRkaW5nJykpO1xuICAgICAgICAgICAgbGF5b3V0LmJveChcbiAgICAgICAgICAgICAgICBjb21wb25lbnRNb2RlbC5nZXQoJ29yaWVudCcpLFxuICAgICAgICAgICAgICAgIGdyb3VwLFxuICAgICAgICAgICAgICAgIGNvbXBvbmVudE1vZGVsLmdldCgnaXRlbUdhcCcpLFxuICAgICAgICAgICAgICAgIHJlY3Qud2lkdGgsXG4gICAgICAgICAgICAgICAgcmVjdC5oZWlnaHRcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHBvc2l0aW9uR3JvdXAoZ3JvdXAsIGNvbXBvbmVudE1vZGVsLCBhcGkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFkZEJhY2tncm91bmQ6IGZ1bmN0aW9uIChncm91cCwgY29tcG9uZW50TW9kZWwpIHtcbiAgICAgICAgICAgIHZhciBwYWRkaW5nID0gZm9ybWF0VXRpbC5ub3JtYWxpemVDc3NBcnJheShcbiAgICAgICAgICAgICAgICBjb21wb25lbnRNb2RlbC5nZXQoJ3BhZGRpbmcnKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHZhciBib3VuZGluZ1JlY3QgPSBncm91cC5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IGNvbXBvbmVudE1vZGVsLmdldEl0ZW1TdHlsZShbJ2NvbG9yJywgJ29wYWNpdHknXSk7XG4gICAgICAgICAgICBzdHlsZS5maWxsID0gY29tcG9uZW50TW9kZWwuZ2V0KCdiYWNrZ3JvdW5kQ29sb3InKTtcbiAgICAgICAgICAgIHZhciByZWN0ID0gbmV3IGdyYXBoaWMuUmVjdCh7XG4gICAgICAgICAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgICAgICAgICAgeDogYm91bmRpbmdSZWN0LnggLSBwYWRkaW5nWzNdLFxuICAgICAgICAgICAgICAgICAgICB5OiBib3VuZGluZ1JlY3QueSAtIHBhZGRpbmdbMF0sXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBib3VuZGluZ1JlY3Qud2lkdGggKyBwYWRkaW5nWzFdICsgcGFkZGluZ1szXSxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBib3VuZGluZ1JlY3QuaGVpZ2h0ICsgcGFkZGluZ1swXSArIHBhZGRpbmdbMl1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHN0eWxlOiBzdHlsZSxcbiAgICAgICAgICAgICAgICBzaWxlbnQ6IHRydWUsXG4gICAgICAgICAgICAgICAgejI6IC0xXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGdyYXBoaWMuc3ViUGl4ZWxPcHRpbWl6ZVJlY3QocmVjdCk7XG5cbiAgICAgICAgICAgIGdyb3VwLmFkZChyZWN0KTtcbiAgICAgICAgfVxuICAgIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9jb21wb25lbnQvaGVscGVyL2xpc3RDb21wb25lbnQuanNcbi8vIG1vZHVsZSBpZCA9IDE1OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 160 */
/* unknown exports provided */
/* all exports used */
/*!***************************************!*\
  !*** ./lib/coord/cartesian/Axis2D.js ***!
  \***************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 0);\n    var Axis = __webpack_require__(/*! ../Axis */ 34);\n    var axisLabelInterval = __webpack_require__(/*! ./axisLabelInterval */ 164);\n\n    /**\n     * Extend axis 2d\n     * @constructor module:echarts/coord/cartesian/Axis2D\n     * @extends {module:echarts/coord/cartesian/Axis}\n     * @param {string} dim\n     * @param {*} scale\n     * @param {Array.<number>} coordExtent\n     * @param {string} axisType\n     * @param {string} position\n     */\n    var Axis2D = function (dim, scale, coordExtent, axisType, position) {\n        Axis.call(this, dim, scale, coordExtent);\n        /**\n         * Axis type\n         *  - 'category'\n         *  - 'value'\n         *  - 'time'\n         *  - 'log'\n         * @type {string}\n         */\n        this.type = axisType || 'value';\n\n        /**\n         * Axis position\n         *  - 'top'\n         *  - 'bottom'\n         *  - 'left'\n         *  - 'right'\n         */\n        this.position = position || 'bottom';\n    };\n\n    Axis2D.prototype = {\n\n        constructor: Axis2D,\n\n        /**\n         * Index of axis, can be used as key\n         */\n        index: 0,\n        /**\n         * If axis is on the zero position of the other axis\n         * @type {boolean}\n         */\n        onZero: false,\n\n        /**\n         * Axis model\n         * @param {module:echarts/coord/cartesian/AxisModel}\n         */\n        model: null,\n\n        isHorizontal: function () {\n            var position = this.position;\n            return position === 'top' || position === 'bottom';\n        },\n\n        /**\n         * Each item cooresponds to this.getExtent(), which\n         * means globalExtent[0] may greater than globalExtent[1],\n         * unless `asc` is input.\n         *\n         * @param {boolean} [asc]\n         * @return {Array.<number>}\n         */\n        getGlobalExtent: function (asc) {\n            var ret = this.getExtent();\n            ret[0] = this.toGlobalCoord(ret[0]);\n            ret[1] = this.toGlobalCoord(ret[1]);\n            asc && ret[0] > ret[1] && ret.reverse();\n            return ret;\n        },\n\n        getOtherAxis: function () {\n            this.grid.getOtherAxis();\n        },\n\n        /**\n         * @return {number}\n         */\n        getLabelInterval: function () {\n            var labelInterval = this._labelInterval;\n            if (!labelInterval) {\n                labelInterval = this._labelInterval = axisLabelInterval(this);\n            }\n            return labelInterval;\n        },\n\n        /**\n         * If label is ignored.\n         * Automatically used when axis is category and label can not be all shown\n         * @param  {number}  idx\n         * @return {boolean}\n         */\n        isLabelIgnored: function (idx) {\n            if (this.type === 'category') {\n                var labelInterval = this.getLabelInterval();\n                return ((typeof labelInterval === 'function')\n                    && !labelInterval(idx, this.scale.getLabel(idx)))\n                    || idx % (labelInterval + 1);\n            }\n        },\n\n        /**\n         * @override\n         */\n        pointToData: function (point, clamp) {\n            return this.coordToData(this.toLocalCoord(point[this.dim === 'x' ? 0 : 1]), clamp);\n        },\n\n        /**\n         * Transform global coord to local coord,\n         * i.e. var localCoord = axis.toLocalCoord(80);\n         * designate by module:echarts/coord/cartesian/Grid.\n         * @type {Function}\n         */\n        toLocalCoord: null,\n\n        /**\n         * Transform global coord to local coord,\n         * i.e. var globalCoord = axis.toLocalCoord(40);\n         * designate by module:echarts/coord/cartesian/Grid.\n         * @type {Function}\n         */\n        toGlobalCoord: null\n\n    };\n    zrUtil.inherits(Axis2D, Axis);\n\n    module.exports = Axis2D;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTYwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2Nvb3JkL2NhcnRlc2lhbi9BeGlzMkQuanM/NTEwNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgQXhpcyA9IHJlcXVpcmUoJy4uL0F4aXMnKTtcbiAgICB2YXIgYXhpc0xhYmVsSW50ZXJ2YWwgPSByZXF1aXJlKCcuL2F4aXNMYWJlbEludGVydmFsJyk7XG5cbiAgICAvKipcbiAgICAgKiBFeHRlbmQgYXhpcyAyZFxuICAgICAqIEBjb25zdHJ1Y3RvciBtb2R1bGU6ZWNoYXJ0cy9jb29yZC9jYXJ0ZXNpYW4vQXhpczJEXG4gICAgICogQGV4dGVuZHMge21vZHVsZTplY2hhcnRzL2Nvb3JkL2NhcnRlc2lhbi9BeGlzfVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkaW1cbiAgICAgKiBAcGFyYW0geyp9IHNjYWxlXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gY29vcmRFeHRlbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXhpc1R5cGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcG9zaXRpb25cbiAgICAgKi9cbiAgICB2YXIgQXhpczJEID0gZnVuY3Rpb24gKGRpbSwgc2NhbGUsIGNvb3JkRXh0ZW50LCBheGlzVHlwZSwgcG9zaXRpb24pIHtcbiAgICAgICAgQXhpcy5jYWxsKHRoaXMsIGRpbSwgc2NhbGUsIGNvb3JkRXh0ZW50KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEF4aXMgdHlwZVxuICAgICAgICAgKiAgLSAnY2F0ZWdvcnknXG4gICAgICAgICAqICAtICd2YWx1ZSdcbiAgICAgICAgICogIC0gJ3RpbWUnXG4gICAgICAgICAqICAtICdsb2cnXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnR5cGUgPSBheGlzVHlwZSB8fCAndmFsdWUnO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBeGlzIHBvc2l0aW9uXG4gICAgICAgICAqICAtICd0b3AnXG4gICAgICAgICAqICAtICdib3R0b20nXG4gICAgICAgICAqICAtICdsZWZ0J1xuICAgICAgICAgKiAgLSAncmlnaHQnXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb24gfHwgJ2JvdHRvbSc7XG4gICAgfTtcblxuICAgIEF4aXMyRC5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IEF4aXMyRCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSW5kZXggb2YgYXhpcywgY2FuIGJlIHVzZWQgYXMga2V5XG4gICAgICAgICAqL1xuICAgICAgICBpbmRleDogMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGF4aXMgaXMgb24gdGhlIHplcm8gcG9zaXRpb24gb2YgdGhlIG90aGVyIGF4aXNcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBvblplcm86IGZhbHNlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBeGlzIG1vZGVsXG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvY29vcmQvY2FydGVzaWFuL0F4aXNNb2RlbH1cbiAgICAgICAgICovXG4gICAgICAgIG1vZGVsOiBudWxsLFxuXG4gICAgICAgIGlzSG9yaXpvbnRhbDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbjtcbiAgICAgICAgICAgIHJldHVybiBwb3NpdGlvbiA9PT0gJ3RvcCcgfHwgcG9zaXRpb24gPT09ICdib3R0b20nO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFYWNoIGl0ZW0gY29vcmVzcG9uZHMgdG8gdGhpcy5nZXRFeHRlbnQoKSwgd2hpY2hcbiAgICAgICAgICogbWVhbnMgZ2xvYmFsRXh0ZW50WzBdIG1heSBncmVhdGVyIHRoYW4gZ2xvYmFsRXh0ZW50WzFdLFxuICAgICAgICAgKiB1bmxlc3MgYGFzY2AgaXMgaW5wdXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FzY11cbiAgICAgICAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gICAgICAgICAqL1xuICAgICAgICBnZXRHbG9iYWxFeHRlbnQ6IGZ1bmN0aW9uIChhc2MpIHtcbiAgICAgICAgICAgIHZhciByZXQgPSB0aGlzLmdldEV4dGVudCgpO1xuICAgICAgICAgICAgcmV0WzBdID0gdGhpcy50b0dsb2JhbENvb3JkKHJldFswXSk7XG4gICAgICAgICAgICByZXRbMV0gPSB0aGlzLnRvR2xvYmFsQ29vcmQocmV0WzFdKTtcbiAgICAgICAgICAgIGFzYyAmJiByZXRbMF0gPiByZXRbMV0gJiYgcmV0LnJldmVyc2UoKTtcbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0T3RoZXJBeGlzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmdyaWQuZ2V0T3RoZXJBeGlzKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIGdldExhYmVsSW50ZXJ2YWw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBsYWJlbEludGVydmFsID0gdGhpcy5fbGFiZWxJbnRlcnZhbDtcbiAgICAgICAgICAgIGlmICghbGFiZWxJbnRlcnZhbCkge1xuICAgICAgICAgICAgICAgIGxhYmVsSW50ZXJ2YWwgPSB0aGlzLl9sYWJlbEludGVydmFsID0gYXhpc0xhYmVsSW50ZXJ2YWwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbGFiZWxJbnRlcnZhbDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgbGFiZWwgaXMgaWdub3JlZC5cbiAgICAgICAgICogQXV0b21hdGljYWxseSB1c2VkIHdoZW4gYXhpcyBpcyBjYXRlZ29yeSBhbmQgbGFiZWwgY2FuIG5vdCBiZSBhbGwgc2hvd25cbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgaWR4XG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBpc0xhYmVsSWdub3JlZDogZnVuY3Rpb24gKGlkeCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ2NhdGVnb3J5Jykge1xuICAgICAgICAgICAgICAgIHZhciBsYWJlbEludGVydmFsID0gdGhpcy5nZXRMYWJlbEludGVydmFsKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgodHlwZW9mIGxhYmVsSW50ZXJ2YWwgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICAgICAgICAgICYmICFsYWJlbEludGVydmFsKGlkeCwgdGhpcy5zY2FsZS5nZXRMYWJlbChpZHgpKSlcbiAgICAgICAgICAgICAgICAgICAgfHwgaWR4ICUgKGxhYmVsSW50ZXJ2YWwgKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgICAqL1xuICAgICAgICBwb2ludFRvRGF0YTogZnVuY3Rpb24gKHBvaW50LCBjbGFtcCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29vcmRUb0RhdGEodGhpcy50b0xvY2FsQ29vcmQocG9pbnRbdGhpcy5kaW0gPT09ICd4JyA/IDAgOiAxXSksIGNsYW1wKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVHJhbnNmb3JtIGdsb2JhbCBjb29yZCB0byBsb2NhbCBjb29yZCxcbiAgICAgICAgICogaS5lLiB2YXIgbG9jYWxDb29yZCA9IGF4aXMudG9Mb2NhbENvb3JkKDgwKTtcbiAgICAgICAgICogZGVzaWduYXRlIGJ5IG1vZHVsZTplY2hhcnRzL2Nvb3JkL2NhcnRlc2lhbi9HcmlkLlxuICAgICAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICAgICAqL1xuICAgICAgICB0b0xvY2FsQ29vcmQ6IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRyYW5zZm9ybSBnbG9iYWwgY29vcmQgdG8gbG9jYWwgY29vcmQsXG4gICAgICAgICAqIGkuZS4gdmFyIGdsb2JhbENvb3JkID0gYXhpcy50b0xvY2FsQ29vcmQoNDApO1xuICAgICAgICAgKiBkZXNpZ25hdGUgYnkgbW9kdWxlOmVjaGFydHMvY29vcmQvY2FydGVzaWFuL0dyaWQuXG4gICAgICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgICAgICovXG4gICAgICAgIHRvR2xvYmFsQ29vcmQ6IG51bGxcblxuICAgIH07XG4gICAgenJVdGlsLmluaGVyaXRzKEF4aXMyRCwgQXhpcyk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IEF4aXMyRDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Nvb3JkL2NhcnRlc2lhbi9BeGlzMkQuanNcbi8vIG1vZHVsZSBpZCA9IDE2MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 161 */
/* unknown exports provided */
/* all exports used */
/*!******************************************!*\
  !*** ./lib/coord/cartesian/Cartesian.js ***!
  \******************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Cartesian coordinate system\n * @module  echarts/coord/Cartesian\n *\n */\n\n\n    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 0);\n\n    function dimAxisMapper(dim) {\n        return this._axes[dim];\n    }\n\n    /**\n     * @alias module:echarts/coord/Cartesian\n     * @constructor\n     */\n    var Cartesian = function (name) {\n        this._axes = {};\n\n        this._dimList = [];\n\n        /**\n         * @type {string}\n         */\n        this.name = name || '';\n    };\n\n    Cartesian.prototype = {\n\n        constructor: Cartesian,\n\n        type: 'cartesian',\n\n        /**\n         * Get axis\n         * @param  {number|string} dim\n         * @return {module:echarts/coord/Cartesian~Axis}\n         */\n        getAxis: function (dim) {\n            return this._axes[dim];\n        },\n\n        /**\n         * Get axes list\n         * @return {Array.<module:echarts/coord/Cartesian~Axis>}\n         */\n        getAxes: function () {\n            return zrUtil.map(this._dimList, dimAxisMapper, this);\n        },\n\n        /**\n         * Get axes list by given scale type\n         */\n        getAxesByScale: function (scaleType) {\n            scaleType = scaleType.toLowerCase();\n            return zrUtil.filter(\n                this.getAxes(),\n                function (axis) {\n                    return axis.scale.type === scaleType;\n                }\n            );\n        },\n\n        /**\n         * Add axis\n         * @param {module:echarts/coord/Cartesian.Axis}\n         */\n        addAxis: function (axis) {\n            var dim = axis.dim;\n\n            this._axes[dim] = axis;\n\n            this._dimList.push(dim);\n        },\n\n        /**\n         * Convert data to coord in nd space\n         * @param {Array.<number>|Object.<string, number>} val\n         * @return {Array.<number>|Object.<string, number>}\n         */\n        dataToCoord: function (val) {\n            return this._dataCoordConvert(val, 'dataToCoord');\n        },\n\n        /**\n         * Convert coord in nd space to data\n         * @param  {Array.<number>|Object.<string, number>} val\n         * @return {Array.<number>|Object.<string, number>}\n         */\n        coordToData: function (val) {\n            return this._dataCoordConvert(val, 'coordToData');\n        },\n\n        _dataCoordConvert: function (input, method) {\n            var dimList = this._dimList;\n\n            var output = input instanceof Array ? [] : {};\n\n            for (var i = 0; i < dimList.length; i++) {\n                var dim = dimList[i];\n                var axis = this._axes[dim];\n\n                output[dim] = axis[method](input[dim]);\n            }\n\n            return output;\n        }\n    };\n\n    module.exports = Cartesian;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTYxLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2Nvb3JkL2NhcnRlc2lhbi9DYXJ0ZXNpYW4uanM/YjkwNyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG4vKipcbiAqIENhcnRlc2lhbiBjb29yZGluYXRlIHN5c3RlbVxuICogQG1vZHVsZSAgZWNoYXJ0cy9jb29yZC9DYXJ0ZXNpYW5cbiAqXG4gKi9cblxuXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuXG4gICAgZnVuY3Rpb24gZGltQXhpc01hcHBlcihkaW0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2F4ZXNbZGltXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAYWxpYXMgbW9kdWxlOmVjaGFydHMvY29vcmQvQ2FydGVzaWFuXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgdmFyIENhcnRlc2lhbiA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHRoaXMuX2F4ZXMgPSB7fTtcblxuICAgICAgICB0aGlzLl9kaW1MaXN0ID0gW107XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lIHx8ICcnO1xuICAgIH07XG5cbiAgICBDYXJ0ZXNpYW4ucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBDYXJ0ZXNpYW4sXG5cbiAgICAgICAgdHlwZTogJ2NhcnRlc2lhbicsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBheGlzXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcnxzdHJpbmd9IGRpbVxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6ZWNoYXJ0cy9jb29yZC9DYXJ0ZXNpYW5+QXhpc31cbiAgICAgICAgICovXG4gICAgICAgIGdldEF4aXM6IGZ1bmN0aW9uIChkaW0pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9heGVzW2RpbV07XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBheGVzIGxpc3RcbiAgICAgICAgICogQHJldHVybiB7QXJyYXkuPG1vZHVsZTplY2hhcnRzL2Nvb3JkL0NhcnRlc2lhbn5BeGlzPn1cbiAgICAgICAgICovXG4gICAgICAgIGdldEF4ZXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB6clV0aWwubWFwKHRoaXMuX2RpbUxpc3QsIGRpbUF4aXNNYXBwZXIsIHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgYXhlcyBsaXN0IGJ5IGdpdmVuIHNjYWxlIHR5cGVcbiAgICAgICAgICovXG4gICAgICAgIGdldEF4ZXNCeVNjYWxlOiBmdW5jdGlvbiAoc2NhbGVUeXBlKSB7XG4gICAgICAgICAgICBzY2FsZVR5cGUgPSBzY2FsZVR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHJldHVybiB6clV0aWwuZmlsdGVyKFxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0QXhlcygpLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChheGlzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBheGlzLnNjYWxlLnR5cGUgPT09IHNjYWxlVHlwZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGQgYXhpc1xuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2Nvb3JkL0NhcnRlc2lhbi5BeGlzfVxuICAgICAgICAgKi9cbiAgICAgICAgYWRkQXhpczogZnVuY3Rpb24gKGF4aXMpIHtcbiAgICAgICAgICAgIHZhciBkaW0gPSBheGlzLmRpbTtcblxuICAgICAgICAgICAgdGhpcy5fYXhlc1tkaW1dID0gYXhpcztcblxuICAgICAgICAgICAgdGhpcy5fZGltTGlzdC5wdXNoKGRpbSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnQgZGF0YSB0byBjb29yZCBpbiBuZCBzcGFjZVxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fE9iamVjdC48c3RyaW5nLCBudW1iZXI+fSB2YWxcbiAgICAgICAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj58T2JqZWN0LjxzdHJpbmcsIG51bWJlcj59XG4gICAgICAgICAqL1xuICAgICAgICBkYXRhVG9Db29yZDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGFDb29yZENvbnZlcnQodmFsLCAnZGF0YVRvQ29vcmQnKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydCBjb29yZCBpbiBuZCBzcGFjZSB0byBkYXRhXG4gICAgICAgICAqIEBwYXJhbSAge0FycmF5LjxudW1iZXI+fE9iamVjdC48c3RyaW5nLCBudW1iZXI+fSB2YWxcbiAgICAgICAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj58T2JqZWN0LjxzdHJpbmcsIG51bWJlcj59XG4gICAgICAgICAqL1xuICAgICAgICBjb29yZFRvRGF0YTogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGFDb29yZENvbnZlcnQodmFsLCAnY29vcmRUb0RhdGEnKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfZGF0YUNvb3JkQ29udmVydDogZnVuY3Rpb24gKGlucHV0LCBtZXRob2QpIHtcbiAgICAgICAgICAgIHZhciBkaW1MaXN0ID0gdGhpcy5fZGltTGlzdDtcblxuICAgICAgICAgICAgdmFyIG91dHB1dCA9IGlucHV0IGluc3RhbmNlb2YgQXJyYXkgPyBbXSA6IHt9O1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpbUxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZGltID0gZGltTGlzdFtpXTtcbiAgICAgICAgICAgICAgICB2YXIgYXhpcyA9IHRoaXMuX2F4ZXNbZGltXTtcblxuICAgICAgICAgICAgICAgIG91dHB1dFtkaW1dID0gYXhpc1ttZXRob2RdKGlucHV0W2RpbV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gQ2FydGVzaWFuO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvY29vcmQvY2FydGVzaWFuL0NhcnRlc2lhbi5qc1xuLy8gbW9kdWxlIGlkID0gMTYxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 162 */
/* unknown exports provided */
/* all exports used */
/*!********************************************!*\
  !*** ./lib/coord/cartesian/Cartesian2D.js ***!
  \********************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\n    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 0);\n    var Cartesian = __webpack_require__(/*! ./Cartesian */ 161);\n\n    function Cartesian2D(name) {\n\n        Cartesian.call(this, name);\n    }\n\n    Cartesian2D.prototype = {\n\n        constructor: Cartesian2D,\n\n        type: 'cartesian2d',\n\n        /**\n         * @type {Array.<string>}\n         * @readOnly\n         */\n        dimensions: ['x', 'y'],\n\n        /**\n         * Base axis will be used on stacking.\n         *\n         * @return {module:echarts/coord/cartesian/Axis2D}\n         */\n        getBaseAxis: function () {\n            return this.getAxesByScale('ordinal')[0]\n                || this.getAxesByScale('time')[0]\n                || this.getAxis('x');\n        },\n\n        /**\n         * If contain point\n         * @param {Array.<number>} point\n         * @return {boolean}\n         */\n        containPoint: function (point) {\n            var axisX = this.getAxis('x');\n            var axisY = this.getAxis('y');\n            return axisX.contain(axisX.toLocalCoord(point[0]))\n                && axisY.contain(axisY.toLocalCoord(point[1]));\n        },\n\n        /**\n         * If contain data\n         * @param {Array.<number>} data\n         * @return {boolean}\n         */\n        containData: function (data) {\n            return this.getAxis('x').containData(data[0])\n                && this.getAxis('y').containData(data[1]);\n        },\n\n        /**\n         * Convert series data to an array of points\n         * @param {module:echarts/data/List} data\n         * @param {boolean} stack\n         * @return {Array}\n         *  Return array of points. For example:\n         *  `[[10, 10], [20, 20], [30, 30]]`\n         */\n        dataToPoints: function (data, stack) {\n            return data.mapArray(['x', 'y'], function (x, y) {\n                return this.dataToPoint([x, y]);\n            }, stack, this);\n        },\n\n        /**\n         * @param {Array.<number>} data\n         * @param {boolean} [clamp=false]\n         * @return {Array.<number>}\n         */\n        dataToPoint: function (data, clamp) {\n            var xAxis = this.getAxis('x');\n            var yAxis = this.getAxis('y');\n            return [\n                xAxis.toGlobalCoord(xAxis.dataToCoord(data[0], clamp)),\n                yAxis.toGlobalCoord(yAxis.dataToCoord(data[1], clamp))\n            ];\n        },\n\n        /**\n         * @param {Array.<number>} point\n         * @param {boolean} [clamp=false]\n         * @return {Array.<number>}\n         */\n        pointToData: function (point, clamp) {\n            var xAxis = this.getAxis('x');\n            var yAxis = this.getAxis('y');\n            return [\n                xAxis.coordToData(xAxis.toLocalCoord(point[0]), clamp),\n                yAxis.coordToData(yAxis.toLocalCoord(point[1]), clamp)\n            ];\n        },\n\n        /**\n         * Get other axis\n         * @param {module:echarts/coord/cartesian/Axis2D} axis\n         */\n        getOtherAxis: function (axis) {\n            return this.getAxis(axis.dim === 'x' ? 'y' : 'x');\n        }\n    };\n\n    zrUtil.inherits(Cartesian2D, Cartesian);\n\n    module.exports = Cartesian2D;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTYyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2Nvb3JkL2NhcnRlc2lhbi9DYXJ0ZXNpYW4yRC5qcz9jNWE1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuICAgIHZhciBDYXJ0ZXNpYW4gPSByZXF1aXJlKCcuL0NhcnRlc2lhbicpO1xuXG4gICAgZnVuY3Rpb24gQ2FydGVzaWFuMkQobmFtZSkge1xuXG4gICAgICAgIENhcnRlc2lhbi5jYWxsKHRoaXMsIG5hbWUpO1xuICAgIH1cblxuICAgIENhcnRlc2lhbjJELnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogQ2FydGVzaWFuMkQsXG5cbiAgICAgICAgdHlwZTogJ2NhcnRlc2lhbjJkJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge0FycmF5LjxzdHJpbmc+fVxuICAgICAgICAgKiBAcmVhZE9ubHlcbiAgICAgICAgICovXG4gICAgICAgIGRpbWVuc2lvbnM6IFsneCcsICd5J10sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJhc2UgYXhpcyB3aWxsIGJlIHVzZWQgb24gc3RhY2tpbmcuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTplY2hhcnRzL2Nvb3JkL2NhcnRlc2lhbi9BeGlzMkR9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRCYXNlQXhpczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QXhlc0J5U2NhbGUoJ29yZGluYWwnKVswXVxuICAgICAgICAgICAgICAgIHx8IHRoaXMuZ2V0QXhlc0J5U2NhbGUoJ3RpbWUnKVswXVxuICAgICAgICAgICAgICAgIHx8IHRoaXMuZ2V0QXhpcygneCcpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBjb250YWluIHBvaW50XG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHBvaW50XG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBjb250YWluUG9pbnQ6IGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgICAgICAgdmFyIGF4aXNYID0gdGhpcy5nZXRBeGlzKCd4Jyk7XG4gICAgICAgICAgICB2YXIgYXhpc1kgPSB0aGlzLmdldEF4aXMoJ3knKTtcbiAgICAgICAgICAgIHJldHVybiBheGlzWC5jb250YWluKGF4aXNYLnRvTG9jYWxDb29yZChwb2ludFswXSkpXG4gICAgICAgICAgICAgICAgJiYgYXhpc1kuY29udGFpbihheGlzWS50b0xvY2FsQ29vcmQocG9pbnRbMV0pKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgY29udGFpbiBkYXRhXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGRhdGFcbiAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGNvbnRhaW5EYXRhOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QXhpcygneCcpLmNvbnRhaW5EYXRhKGRhdGFbMF0pXG4gICAgICAgICAgICAgICAgJiYgdGhpcy5nZXRBeGlzKCd5JykuY29udGFpbkRhdGEoZGF0YVsxXSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnQgc2VyaWVzIGRhdGEgdG8gYW4gYXJyYXkgb2YgcG9pbnRzXG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvZGF0YS9MaXN0fSBkYXRhXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc3RhY2tcbiAgICAgICAgICogQHJldHVybiB7QXJyYXl9XG4gICAgICAgICAqICBSZXR1cm4gYXJyYXkgb2YgcG9pbnRzLiBGb3IgZXhhbXBsZTpcbiAgICAgICAgICogIGBbWzEwLCAxMF0sIFsyMCwgMjBdLCBbMzAsIDMwXV1gXG4gICAgICAgICAqL1xuICAgICAgICBkYXRhVG9Qb2ludHM6IGZ1bmN0aW9uIChkYXRhLCBzdGFjaykge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGEubWFwQXJyYXkoWyd4JywgJ3knXSwgZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhVG9Qb2ludChbeCwgeV0pO1xuICAgICAgICAgICAgfSwgc3RhY2ssIHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBkYXRhXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2NsYW1wPWZhbHNlXVxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAgICAgICAgICovXG4gICAgICAgIGRhdGFUb1BvaW50OiBmdW5jdGlvbiAoZGF0YSwgY2xhbXApIHtcbiAgICAgICAgICAgIHZhciB4QXhpcyA9IHRoaXMuZ2V0QXhpcygneCcpO1xuICAgICAgICAgICAgdmFyIHlBeGlzID0gdGhpcy5nZXRBeGlzKCd5Jyk7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHhBeGlzLnRvR2xvYmFsQ29vcmQoeEF4aXMuZGF0YVRvQ29vcmQoZGF0YVswXSwgY2xhbXApKSxcbiAgICAgICAgICAgICAgICB5QXhpcy50b0dsb2JhbENvb3JkKHlBeGlzLmRhdGFUb0Nvb3JkKGRhdGFbMV0sIGNsYW1wKSlcbiAgICAgICAgICAgIF07XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHBvaW50XG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2NsYW1wPWZhbHNlXVxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAgICAgICAgICovXG4gICAgICAgIHBvaW50VG9EYXRhOiBmdW5jdGlvbiAocG9pbnQsIGNsYW1wKSB7XG4gICAgICAgICAgICB2YXIgeEF4aXMgPSB0aGlzLmdldEF4aXMoJ3gnKTtcbiAgICAgICAgICAgIHZhciB5QXhpcyA9IHRoaXMuZ2V0QXhpcygneScpO1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB4QXhpcy5jb29yZFRvRGF0YSh4QXhpcy50b0xvY2FsQ29vcmQocG9pbnRbMF0pLCBjbGFtcCksXG4gICAgICAgICAgICAgICAgeUF4aXMuY29vcmRUb0RhdGEoeUF4aXMudG9Mb2NhbENvb3JkKHBvaW50WzFdKSwgY2xhbXApXG4gICAgICAgICAgICBdO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgb3RoZXIgYXhpc1xuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2Nvb3JkL2NhcnRlc2lhbi9BeGlzMkR9IGF4aXNcbiAgICAgICAgICovXG4gICAgICAgIGdldE90aGVyQXhpczogZnVuY3Rpb24gKGF4aXMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEF4aXMoYXhpcy5kaW0gPT09ICd4JyA/ICd5JyA6ICd4Jyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgenJVdGlsLmluaGVyaXRzKENhcnRlc2lhbjJELCBDYXJ0ZXNpYW4pO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBDYXJ0ZXNpYW4yRDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Nvb3JkL2NhcnRlc2lhbi9DYXJ0ZXNpYW4yRC5qc1xuLy8gbW9kdWxlIGlkID0gMTYyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 163 */
/* unknown exports provided */
/* all exports used */
/*!******************************************!*\
  !*** ./lib/coord/cartesian/GridModel.js ***!
  \******************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n// Grid 是在有直角坐标系的时候必须要存在的\n// 所以这里也要被 Cartesian2D 依赖\n\n\n    __webpack_require__(/*! ./AxisModel */ 67);\n\n    var ComponentModel = __webpack_require__(/*! ../../model/Component */ 12);\n\n    module.exports = ComponentModel.extend({\n\n        type: 'grid',\n\n        dependencies: ['xAxis', 'yAxis'],\n\n        layoutMode: 'box',\n\n        /**\n         * @type {module:echarts/coord/cartesian/Grid}\n         */\n        coordinateSystem: null,\n\n        defaultOption: {\n            show: false,\n            zlevel: 0,\n            z: 0,\n            left: '10%',\n            top: 60,\n            right: '10%',\n            bottom: 60,\n            // If grid size contain label\n            containLabel: false,\n            // width: {totalWidth} - left - right,\n            // height: {totalHeight} - top - bottom,\n            backgroundColor: 'rgba(0,0,0,0)',\n            borderWidth: 1,\n            borderColor: '#ccc'\n        }\n    });\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTYzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2Nvb3JkL2NhcnRlc2lhbi9HcmlkTW9kZWwuanM/OTExMCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG4vLyBHcmlkIOaYr+WcqOacieebtOinkuWdkOagh+ezu+eahOaXtuWAmeW/hemhu+imgeWtmOWcqOeahFxuLy8g5omA5Lul6L+Z6YeM5Lmf6KaB6KKrIENhcnRlc2lhbjJEIOS+nei1llxuXG5cbiAgICByZXF1aXJlKCcuL0F4aXNNb2RlbCcpO1xuXG4gICAgdmFyIENvbXBvbmVudE1vZGVsID0gcmVxdWlyZSgnLi4vLi4vbW9kZWwvQ29tcG9uZW50Jyk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IENvbXBvbmVudE1vZGVsLmV4dGVuZCh7XG5cbiAgICAgICAgdHlwZTogJ2dyaWQnLFxuXG4gICAgICAgIGRlcGVuZGVuY2llczogWyd4QXhpcycsICd5QXhpcyddLFxuXG4gICAgICAgIGxheW91dE1vZGU6ICdib3gnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bW9kdWxlOmVjaGFydHMvY29vcmQvY2FydGVzaWFuL0dyaWR9XG4gICAgICAgICAqL1xuICAgICAgICBjb29yZGluYXRlU3lzdGVtOiBudWxsLFxuXG4gICAgICAgIGRlZmF1bHRPcHRpb246IHtcbiAgICAgICAgICAgIHNob3c6IGZhbHNlLFxuICAgICAgICAgICAgemxldmVsOiAwLFxuICAgICAgICAgICAgejogMCxcbiAgICAgICAgICAgIGxlZnQ6ICcxMCUnLFxuICAgICAgICAgICAgdG9wOiA2MCxcbiAgICAgICAgICAgIHJpZ2h0OiAnMTAlJyxcbiAgICAgICAgICAgIGJvdHRvbTogNjAsXG4gICAgICAgICAgICAvLyBJZiBncmlkIHNpemUgY29udGFpbiBsYWJlbFxuICAgICAgICAgICAgY29udGFpbkxhYmVsOiBmYWxzZSxcbiAgICAgICAgICAgIC8vIHdpZHRoOiB7dG90YWxXaWR0aH0gLSBsZWZ0IC0gcmlnaHQsXG4gICAgICAgICAgICAvLyBoZWlnaHQ6IHt0b3RhbEhlaWdodH0gLSB0b3AgLSBib3R0b20sXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDAsMCwwLDApJyxcbiAgICAgICAgICAgIGJvcmRlcldpZHRoOiAxLFxuICAgICAgICAgICAgYm9yZGVyQ29sb3I6ICcjY2NjJ1xuICAgICAgICB9XG4gICAgfSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9jb29yZC9jYXJ0ZXNpYW4vR3JpZE1vZGVsLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 164 */
/* unknown exports provided */
/* all exports used */
/*!**************************************************!*\
  !*** ./lib/coord/cartesian/axisLabelInterval.js ***!
  \**************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Helper function for axisLabelInterval calculation\n */\n\n\n\n    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 0);\n    var axisHelper = __webpack_require__(/*! ../axisHelper */ 16);\n\n    module.exports = function (axis) {\n        var axisModel = axis.model;\n        var labelModel = axisModel.getModel('axisLabel');\n        var labelInterval = labelModel.get('interval');\n        if (!(axis.type === 'category' && labelInterval === 'auto')) {\n            return labelInterval === 'auto' ? 0 : labelInterval;\n        }\n\n        return axisHelper.getAxisLabelInterval(\n            zrUtil.map(axis.scale.getTicks(), axis.dataToCoord, axis),\n            axisModel.getFormattedLabels(),\n            labelModel.getModel('textStyle').getFont(),\n            axis.isHorizontal()\n        );\n    };\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTY0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2Nvb3JkL2NhcnRlc2lhbi9heGlzTGFiZWxJbnRlcnZhbC5qcz9jYjZmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIGZvciBheGlzTGFiZWxJbnRlcnZhbCBjYWxjdWxhdGlvblxuICovXG5cblxuXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuICAgIHZhciBheGlzSGVscGVyID0gcmVxdWlyZSgnLi4vYXhpc0hlbHBlcicpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXhpcykge1xuICAgICAgICB2YXIgYXhpc01vZGVsID0gYXhpcy5tb2RlbDtcbiAgICAgICAgdmFyIGxhYmVsTW9kZWwgPSBheGlzTW9kZWwuZ2V0TW9kZWwoJ2F4aXNMYWJlbCcpO1xuICAgICAgICB2YXIgbGFiZWxJbnRlcnZhbCA9IGxhYmVsTW9kZWwuZ2V0KCdpbnRlcnZhbCcpO1xuICAgICAgICBpZiAoIShheGlzLnR5cGUgPT09ICdjYXRlZ29yeScgJiYgbGFiZWxJbnRlcnZhbCA9PT0gJ2F1dG8nKSkge1xuICAgICAgICAgICAgcmV0dXJuIGxhYmVsSW50ZXJ2YWwgPT09ICdhdXRvJyA/IDAgOiBsYWJlbEludGVydmFsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF4aXNIZWxwZXIuZ2V0QXhpc0xhYmVsSW50ZXJ2YWwoXG4gICAgICAgICAgICB6clV0aWwubWFwKGF4aXMuc2NhbGUuZ2V0VGlja3MoKSwgYXhpcy5kYXRhVG9Db29yZCwgYXhpcyksXG4gICAgICAgICAgICBheGlzTW9kZWwuZ2V0Rm9ybWF0dGVkTGFiZWxzKCksXG4gICAgICAgICAgICBsYWJlbE1vZGVsLmdldE1vZGVsKCd0ZXh0U3R5bGUnKS5nZXRGb250KCksXG4gICAgICAgICAgICBheGlzLmlzSG9yaXpvbnRhbCgpXG4gICAgICAgICk7XG4gICAgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Nvb3JkL2NhcnRlc2lhbi9heGlzTGFiZWxJbnRlcnZhbC5qc1xuLy8gbW9kdWxlIGlkID0gMTY0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 165 */
/* unknown exports provided */
/* all exports used */
/*!***********************!*\
  !*** ./lib/helper.js ***!
  \***********************/
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var createListFromArray = __webpack_require__(/*! ./chart/helper/createListFromArray */ 27);\n    var symbolUtil = __webpack_require__(/*! ./util/symbol */ 23);\n    var axisHelper = __webpack_require__(/*! ./coord/axisHelper */ 16);\n    var axisModelCommonMixin = __webpack_require__(/*! ./coord/axisModelCommonMixin */ 41);\n    var Model = __webpack_require__(/*! ./model/Model */ 9);\n    var util = __webpack_require__(/*! zrender/lib/core/util */ 0);\n\n    module.exports = {\n        /**\n         * Create a muti dimension List structure from seriesModel.\n         * @param  {module:echarts/model/Model} seriesModel\n         * @return {module:echarts/data/List} list\n         */\n        createList: function (seriesModel) {\n            var data = seriesModel.get('data');\n            return createListFromArray(data, seriesModel, seriesModel.ecModel);\n        },\n\n        /**\n         * Complete the dimensions array guessed from the data structure.\n         * @param  {Array.<string>} dimensions Necessary dimensions, like ['x', 'y']\n         * @param  {Array} data Data list. [[1, 2, 3], [2, 3, 4]]\n         * @param  {Object} [opt]\n         * @param  {Array.<string>} [opt.defaultNames] Default names to fill not necessary dimensions, like ['value']\n         * @param  {string} [opt.extraPrefix] Prefix of name when filling the left dimensions.\n         * @param  {number} [opt.dimCount] If not specified, guess by the first data item.\n         * @return {Array.<string>}\n         */\n        completeDimensions: __webpack_require__(/*! ./data/helper/completeDimensions */ 24),\n\n        /**\n         * Create a symbol element with given symbol configuration: shape, x, y, width, height, color\n         * @see http://echarts.baidu.com/option.html#series-scatter.symbol\n         * @param {string} symbolDesc\n         * @param {number} x\n         * @param {number} y\n         * @param {number} w\n         * @param {number} h\n         * @param {string} color\n         */\n        createSymbol: symbolUtil.createSymbol,\n\n        /**\n         * Create scale\n         * @param {Array.<number>} dataExtent\n         * @param {Object|module:echarts/Model} option\n         */\n        createScale: function (dataExtent, option) {\n            var axisModel = option;\n            if (!(option instanceof Model)) {\n                axisModel = new Model(option);\n                util.mixin(axisModel, axisModelCommonMixin);\n            }\n\n            var scale = axisHelper.createScaleByModel(axisModel);\n            scale.setExtent(dataExtent[0], dataExtent[1]);\n\n            axisHelper.niceScaleExtent(scale, axisModel);\n            return scale;\n        },\n\n        /**\n         * Mixin common methods to axis model,\n         *\n         * Inlcude methods\n         * `getFormattedLabels() => Array.<string>`\n         * `getCategories() => Array.<string>`\n         * `getMin(origin: boolean) => number`\n         * `getMax(origin: boolean) => number`\n         * `getNeedCrossZero() => boolean`\n         * `setRange(start: number, end: number)`\n         * `resetRange()`\n         */\n        mixinAxisModelCommonMethods: function (Model) {\n            util.mixin(Model, axisModelCommonMixin);\n        }\n    };\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTY1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2hlbHBlci5qcz9mZTc0Il0sInNvdXJjZXNDb250ZW50IjpbIlxuXG4gICAgdmFyIGNyZWF0ZUxpc3RGcm9tQXJyYXkgPSByZXF1aXJlKCcuL2NoYXJ0L2hlbHBlci9jcmVhdGVMaXN0RnJvbUFycmF5Jyk7XG4gICAgdmFyIHN5bWJvbFV0aWwgPSByZXF1aXJlKCcuL3V0aWwvc3ltYm9sJyk7XG4gICAgdmFyIGF4aXNIZWxwZXIgPSByZXF1aXJlKCcuL2Nvb3JkL2F4aXNIZWxwZXInKTtcbiAgICB2YXIgYXhpc01vZGVsQ29tbW9uTWl4aW4gPSByZXF1aXJlKCcuL2Nvb3JkL2F4aXNNb2RlbENvbW1vbk1peGluJyk7XG4gICAgdmFyIE1vZGVsID0gcmVxdWlyZSgnLi9tb2RlbC9Nb2RlbCcpO1xuICAgIHZhciB1dGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIG11dGkgZGltZW5zaW9uIExpc3Qgc3RydWN0dXJlIGZyb20gc2VyaWVzTW9kZWwuXG4gICAgICAgICAqIEBwYXJhbSAge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBzZXJpZXNNb2RlbFxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6ZWNoYXJ0cy9kYXRhL0xpc3R9IGxpc3RcbiAgICAgICAgICovXG4gICAgICAgIGNyZWF0ZUxpc3Q6IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXQoJ2RhdGEnKTtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVMaXN0RnJvbUFycmF5KGRhdGEsIHNlcmllc01vZGVsLCBzZXJpZXNNb2RlbC5lY01vZGVsKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29tcGxldGUgdGhlIGRpbWVuc2lvbnMgYXJyYXkgZ3Vlc3NlZCBmcm9tIHRoZSBkYXRhIHN0cnVjdHVyZS5cbiAgICAgICAgICogQHBhcmFtICB7QXJyYXkuPHN0cmluZz59IGRpbWVuc2lvbnMgTmVjZXNzYXJ5IGRpbWVuc2lvbnMsIGxpa2UgWyd4JywgJ3knXVxuICAgICAgICAgKiBAcGFyYW0gIHtBcnJheX0gZGF0YSBEYXRhIGxpc3QuIFtbMSwgMiwgM10sIFsyLCAzLCA0XV1cbiAgICAgICAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0XVxuICAgICAgICAgKiBAcGFyYW0gIHtBcnJheS48c3RyaW5nPn0gW29wdC5kZWZhdWx0TmFtZXNdIERlZmF1bHQgbmFtZXMgdG8gZmlsbCBub3QgbmVjZXNzYXJ5IGRpbWVuc2lvbnMsIGxpa2UgWyd2YWx1ZSddXG4gICAgICAgICAqIEBwYXJhbSAge3N0cmluZ30gW29wdC5leHRyYVByZWZpeF0gUHJlZml4IG9mIG5hbWUgd2hlbiBmaWxsaW5nIHRoZSBsZWZ0IGRpbWVuc2lvbnMuXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gW29wdC5kaW1Db3VudF0gSWYgbm90IHNwZWNpZmllZCwgZ3Vlc3MgYnkgdGhlIGZpcnN0IGRhdGEgaXRlbS5cbiAgICAgICAgICogQHJldHVybiB7QXJyYXkuPHN0cmluZz59XG4gICAgICAgICAqL1xuICAgICAgICBjb21wbGV0ZURpbWVuc2lvbnM6IHJlcXVpcmUoJy4vZGF0YS9oZWxwZXIvY29tcGxldGVEaW1lbnNpb25zJyksXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIHN5bWJvbCBlbGVtZW50IHdpdGggZ2l2ZW4gc3ltYm9sIGNvbmZpZ3VyYXRpb246IHNoYXBlLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBjb2xvclxuICAgICAgICAgKiBAc2VlIGh0dHA6Ly9lY2hhcnRzLmJhaWR1LmNvbS9vcHRpb24uaHRtbCNzZXJpZXMtc2NhdHRlci5zeW1ib2xcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHN5bWJvbERlc2NcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHdcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGhcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yXG4gICAgICAgICAqL1xuICAgICAgICBjcmVhdGVTeW1ib2w6IHN5bWJvbFV0aWwuY3JlYXRlU3ltYm9sLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgc2NhbGVcbiAgICAgICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gZGF0YUV4dGVudFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdHxtb2R1bGU6ZWNoYXJ0cy9Nb2RlbH0gb3B0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBjcmVhdGVTY2FsZTogZnVuY3Rpb24gKGRhdGFFeHRlbnQsIG9wdGlvbikge1xuICAgICAgICAgICAgdmFyIGF4aXNNb2RlbCA9IG9wdGlvbjtcbiAgICAgICAgICAgIGlmICghKG9wdGlvbiBpbnN0YW5jZW9mIE1vZGVsKSkge1xuICAgICAgICAgICAgICAgIGF4aXNNb2RlbCA9IG5ldyBNb2RlbChvcHRpb24pO1xuICAgICAgICAgICAgICAgIHV0aWwubWl4aW4oYXhpc01vZGVsLCBheGlzTW9kZWxDb21tb25NaXhpbik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzY2FsZSA9IGF4aXNIZWxwZXIuY3JlYXRlU2NhbGVCeU1vZGVsKGF4aXNNb2RlbCk7XG4gICAgICAgICAgICBzY2FsZS5zZXRFeHRlbnQoZGF0YUV4dGVudFswXSwgZGF0YUV4dGVudFsxXSk7XG5cbiAgICAgICAgICAgIGF4aXNIZWxwZXIubmljZVNjYWxlRXh0ZW50KHNjYWxlLCBheGlzTW9kZWwpO1xuICAgICAgICAgICAgcmV0dXJuIHNjYWxlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNaXhpbiBjb21tb24gbWV0aG9kcyB0byBheGlzIG1vZGVsLFxuICAgICAgICAgKlxuICAgICAgICAgKiBJbmxjdWRlIG1ldGhvZHNcbiAgICAgICAgICogYGdldEZvcm1hdHRlZExhYmVscygpID0+IEFycmF5LjxzdHJpbmc+YFxuICAgICAgICAgKiBgZ2V0Q2F0ZWdvcmllcygpID0+IEFycmF5LjxzdHJpbmc+YFxuICAgICAgICAgKiBgZ2V0TWluKG9yaWdpbjogYm9vbGVhbikgPT4gbnVtYmVyYFxuICAgICAgICAgKiBgZ2V0TWF4KG9yaWdpbjogYm9vbGVhbikgPT4gbnVtYmVyYFxuICAgICAgICAgKiBgZ2V0TmVlZENyb3NzWmVybygpID0+IGJvb2xlYW5gXG4gICAgICAgICAqIGBzZXRSYW5nZShzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlcilgXG4gICAgICAgICAqIGByZXNldFJhbmdlKClgXG4gICAgICAgICAqL1xuICAgICAgICBtaXhpbkF4aXNNb2RlbENvbW1vbk1ldGhvZHM6IGZ1bmN0aW9uIChNb2RlbCkge1xuICAgICAgICAgICAgdXRpbC5taXhpbihNb2RlbCwgYXhpc01vZGVsQ29tbW9uTWl4aW4pO1xuICAgICAgICB9XG4gICAgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2hlbHBlci5qc1xuLy8gbW9kdWxlIGlkID0gMTY1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 166 */
/* unknown exports provided */
/* all exports used */
/*!********************************!*\
  !*** ./lib/loading/default.js ***!
  \********************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var graphic = __webpack_require__(/*! ../util/graphic */ 2);\n    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 0);\n    var PI = Math.PI;\n    /**\n     * @param {module:echarts/ExtensionAPI} api\n     * @param {Object} [opts]\n     * @param {string} [opts.text]\n     * @param {string} [opts.color]\n     * @param {string} [opts.textColor]\n     * @return {module:zrender/Element}\n     */\n    module.exports = function (api, opts) {\n        opts = opts || {};\n        zrUtil.defaults(opts, {\n            text: 'loading',\n            color: '#c23531',\n            textColor: '#000',\n            maskColor: 'rgba(255, 255, 255, 0.8)',\n            zlevel: 0\n        });\n        var mask = new graphic.Rect({\n            style: {\n                fill: opts.maskColor\n            },\n            zlevel: opts.zlevel,\n            z: 10000\n        });\n        var arc = new graphic.Arc({\n            shape: {\n                startAngle: -PI / 2,\n                endAngle: -PI / 2 + 0.1,\n                r: 10\n            },\n            style: {\n                stroke: opts.color,\n                lineCap: 'round',\n                lineWidth: 5\n            },\n            zlevel: opts.zlevel,\n            z: 10001\n        });\n        var labelRect = new graphic.Rect({\n            style: {\n                fill: 'none',\n                text: opts.text,\n                textPosition: 'right',\n                textDistance: 10,\n                textFill: opts.textColor\n            },\n            zlevel: opts.zlevel,\n            z: 10001\n        });\n\n        arc.animateShape(true)\n            .when(1000, {\n                endAngle: PI * 3 / 2\n            })\n            .start('circularInOut');\n        arc.animateShape(true)\n            .when(1000, {\n                startAngle: PI * 3 / 2\n            })\n            .delay(300)\n            .start('circularInOut');\n\n        var group = new graphic.Group();\n        group.add(arc);\n        group.add(labelRect);\n        group.add(mask);\n        // Inject resize\n        group.resize = function () {\n            var cx = api.getWidth() / 2;\n            var cy = api.getHeight() / 2;\n            arc.setShape({\n                cx: cx,\n                cy: cy\n            });\n            var r = arc.shape.r;\n            labelRect.setShape({\n                x: cx - r,\n                y: cy - r,\n                width: r * 2,\n                height: r * 2\n            });\n\n            mask.setShape({\n                x: 0,\n                y: 0,\n                width: api.getWidth(),\n                height: api.getHeight()\n            });\n        };\n        group.resize();\n        return group;\n    };\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTY2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2xvYWRpbmcvZGVmYXVsdC5qcz83YzNhIl0sInNvdXJjZXNDb250ZW50IjpbIlxuXG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKCcuLi91dGlsL2dyYXBoaWMnKTtcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG4gICAgdmFyIFBJID0gTWF0aC5QSTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL0V4dGVuc2lvbkFQSX0gYXBpXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRzXVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy50ZXh0XVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5jb2xvcl1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMudGV4dENvbG9yXVxuICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9XG4gICAgICovXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXBpLCBvcHRzKSB7XG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgICAgICB6clV0aWwuZGVmYXVsdHMob3B0cywge1xuICAgICAgICAgICAgdGV4dDogJ2xvYWRpbmcnLFxuICAgICAgICAgICAgY29sb3I6ICcjYzIzNTMxJyxcbiAgICAgICAgICAgIHRleHRDb2xvcjogJyMwMDAnLFxuICAgICAgICAgICAgbWFza0NvbG9yOiAncmdiYSgyNTUsIDI1NSwgMjU1LCAwLjgpJyxcbiAgICAgICAgICAgIHpsZXZlbDogMFxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIG1hc2sgPSBuZXcgZ3JhcGhpYy5SZWN0KHtcbiAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgZmlsbDogb3B0cy5tYXNrQ29sb3JcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB6bGV2ZWw6IG9wdHMuemxldmVsLFxuICAgICAgICAgICAgejogMTAwMDBcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBhcmMgPSBuZXcgZ3JhcGhpYy5BcmMoe1xuICAgICAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgICAgICBzdGFydEFuZ2xlOiAtUEkgLyAyLFxuICAgICAgICAgICAgICAgIGVuZEFuZ2xlOiAtUEkgLyAyICsgMC4xLFxuICAgICAgICAgICAgICAgIHI6IDEwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICBzdHJva2U6IG9wdHMuY29sb3IsXG4gICAgICAgICAgICAgICAgbGluZUNhcDogJ3JvdW5kJyxcbiAgICAgICAgICAgICAgICBsaW5lV2lkdGg6IDVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB6bGV2ZWw6IG9wdHMuemxldmVsLFxuICAgICAgICAgICAgejogMTAwMDFcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBsYWJlbFJlY3QgPSBuZXcgZ3JhcGhpYy5SZWN0KHtcbiAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgZmlsbDogJ25vbmUnLFxuICAgICAgICAgICAgICAgIHRleHQ6IG9wdHMudGV4dCxcbiAgICAgICAgICAgICAgICB0ZXh0UG9zaXRpb246ICdyaWdodCcsXG4gICAgICAgICAgICAgICAgdGV4dERpc3RhbmNlOiAxMCxcbiAgICAgICAgICAgICAgICB0ZXh0RmlsbDogb3B0cy50ZXh0Q29sb3JcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB6bGV2ZWw6IG9wdHMuemxldmVsLFxuICAgICAgICAgICAgejogMTAwMDFcbiAgICAgICAgfSk7XG5cbiAgICAgICAgYXJjLmFuaW1hdGVTaGFwZSh0cnVlKVxuICAgICAgICAgICAgLndoZW4oMTAwMCwge1xuICAgICAgICAgICAgICAgIGVuZEFuZ2xlOiBQSSAqIDMgLyAyXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnN0YXJ0KCdjaXJjdWxhckluT3V0Jyk7XG4gICAgICAgIGFyYy5hbmltYXRlU2hhcGUodHJ1ZSlcbiAgICAgICAgICAgIC53aGVuKDEwMDAsIHtcbiAgICAgICAgICAgICAgICBzdGFydEFuZ2xlOiBQSSAqIDMgLyAyXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmRlbGF5KDMwMClcbiAgICAgICAgICAgIC5zdGFydCgnY2lyY3VsYXJJbk91dCcpO1xuXG4gICAgICAgIHZhciBncm91cCA9IG5ldyBncmFwaGljLkdyb3VwKCk7XG4gICAgICAgIGdyb3VwLmFkZChhcmMpO1xuICAgICAgICBncm91cC5hZGQobGFiZWxSZWN0KTtcbiAgICAgICAgZ3JvdXAuYWRkKG1hc2spO1xuICAgICAgICAvLyBJbmplY3QgcmVzaXplXG4gICAgICAgIGdyb3VwLnJlc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjeCA9IGFwaS5nZXRXaWR0aCgpIC8gMjtcbiAgICAgICAgICAgIHZhciBjeSA9IGFwaS5nZXRIZWlnaHQoKSAvIDI7XG4gICAgICAgICAgICBhcmMuc2V0U2hhcGUoe1xuICAgICAgICAgICAgICAgIGN4OiBjeCxcbiAgICAgICAgICAgICAgICBjeTogY3lcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIHIgPSBhcmMuc2hhcGUucjtcbiAgICAgICAgICAgIGxhYmVsUmVjdC5zZXRTaGFwZSh7XG4gICAgICAgICAgICAgICAgeDogY3ggLSByLFxuICAgICAgICAgICAgICAgIHk6IGN5IC0gcixcbiAgICAgICAgICAgICAgICB3aWR0aDogciAqIDIsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiByICogMlxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIG1hc2suc2V0U2hhcGUoe1xuICAgICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgICAgeTogMCxcbiAgICAgICAgICAgICAgICB3aWR0aDogYXBpLmdldFdpZHRoKCksXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBhcGkuZ2V0SGVpZ2h0KClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBncm91cC5yZXNpemUoKTtcbiAgICAgICAgcmV0dXJuIGdyb3VwO1xuICAgIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9sb2FkaW5nL2RlZmF1bHQuanNcbi8vIG1vZHVsZSBpZCA9IDE2NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 167 */
/* unknown exports provided */
/* all exports used */
/*!*****************************!*\
  !*** ./lib/model/Global.js ***!
  \*****************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * ECharts global model\n *\n * @module {echarts/model/Global}\n */\n\n\n\n    /**\n     * Caution: If the mechanism should be changed some day, these cases\n     * should be considered:\n     *\n     * (1) In `merge option` mode, if using the same option to call `setOption`\n     * many times, the result should be the same (try our best to ensure that).\n     * (2) In `merge option` mode, if a component has no id/name specified, it\n     * will be merged by index, and the result sequence of the components is\n     * consistent to the original sequence.\n     * (3) `reset` feature (in toolbox). Find detailed info in comments about\n     * `mergeOption` in module:echarts/model/OptionManager.\n     */\n\n    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 0);\n    var modelUtil = __webpack_require__(/*! ../util/model */ 5);\n    var Model = __webpack_require__(/*! ./Model */ 9);\n    var each = zrUtil.each;\n    var filter = zrUtil.filter;\n    var map = zrUtil.map;\n    var isArray = zrUtil.isArray;\n    var indexOf = zrUtil.indexOf;\n    var isObject = zrUtil.isObject;\n\n    var ComponentModel = __webpack_require__(/*! ./Component */ 12);\n\n    var globalDefault = __webpack_require__(/*! ./globalDefault */ 169);\n\n    var OPTION_INNER_KEY = '\\0_ec_inner';\n\n    /**\n     * @alias module:echarts/model/Global\n     *\n     * @param {Object} option\n     * @param {module:echarts/model/Model} parentModel\n     * @param {Object} theme\n     */\n    var GlobalModel = Model.extend({\n\n        constructor: GlobalModel,\n\n        init: function (option, parentModel, theme, optionManager) {\n            theme = theme || {};\n\n            this.option = null; // Mark as not initialized.\n\n            /**\n             * @type {module:echarts/model/Model}\n             * @private\n             */\n            this._theme = new Model(theme);\n\n            /**\n             * @type {module:echarts/model/OptionManager}\n             */\n            this._optionManager = optionManager;\n        },\n\n        setOption: function (option, optionPreprocessorFuncs, onlyGraphic) {\n            zrUtil.assert(\n                !(OPTION_INNER_KEY in option),\n                'please use chart.getOption()'\n            );\n\n            this._optionManager.setOption(option, optionPreprocessorFuncs);\n\n            this.resetOption(null, onlyGraphic);\n        },\n\n        /**\n         * @param {string} type null/undefined: reset all.\n         *                      'recreate': force recreate all.\n         *                      'timeline': only reset timeline option\n         *                      'media': only reset media query option\n         * @return {boolean} Whether option changed.\n         */\n        resetOption: function (type, onlyGraphic) {\n            var optionChanged = false;\n            var optionManager = this._optionManager;\n\n            if (!type || type === 'recreate') {\n                var baseOption = optionManager.mountOption(type === 'recreate');\n\n                if (!this.option || type === 'recreate') {\n                    initBase.call(this, baseOption);\n                }\n                else {\n                    // If only graphic, other series and component will not\n                    // go through update process, data should not be restored.\n                    // Otherwise grphic els mounted on data will be eliminated\n                    // and downplay will not work.\n                    !onlyGraphic && this.restoreData();\n                    this.mergeOption(baseOption);\n                }\n                optionChanged = true;\n            }\n\n            if (type === 'timeline' || type === 'media') {\n                this.restoreData();\n            }\n\n            if (!type || type === 'recreate' || type === 'timeline') {\n                var timelineOption = optionManager.getTimelineOption(this);\n                timelineOption && (this.mergeOption(timelineOption), optionChanged = true);\n            }\n\n            if (!type || type === 'recreate' || type === 'media') {\n                var mediaOptions = optionManager.getMediaOption(this, this._api);\n                if (mediaOptions.length) {\n                    each(mediaOptions, function (mediaOption) {\n                        this.mergeOption(mediaOption, optionChanged = true);\n                    }, this);\n                }\n            }\n\n            return optionChanged;\n        },\n\n        /**\n         * @protected\n         */\n        mergeOption: function (newOption) {\n            var option = this.option;\n            var componentsMap = this._componentsMap;\n            var newCptTypes = [];\n\n            // 如果不存在对应的 component model 则直接 merge\n            each(newOption, function (componentOption, mainType) {\n                if (componentOption == null) {\n                    return;\n                }\n\n                if (!ComponentModel.hasClass(mainType)) {\n                    option[mainType] = option[mainType] == null\n                        ? zrUtil.clone(componentOption)\n                        : zrUtil.merge(option[mainType], componentOption, true);\n                }\n                else {\n                    newCptTypes.push(mainType);\n                }\n            });\n\n            // FIXME OPTION 同步是否要改回原来的\n            ComponentModel.topologicalTravel(\n                newCptTypes, ComponentModel.getAllClassMainTypes(), visitComponent, this\n            );\n\n            this._seriesIndices = this._seriesIndices || [];\n\n            function visitComponent(mainType, dependencies) {\n                var newCptOptionList = modelUtil.normalizeToArray(newOption[mainType]);\n\n                var mapResult = modelUtil.mappingToExists(\n                    componentsMap[mainType], newCptOptionList\n                );\n\n                modelUtil.makeIdAndName(mapResult);\n\n                // Set mainType and complete subType.\n                each(mapResult, function (item, index) {\n                    var opt = item.option;\n                    if (isObject(opt)) {\n                        item.keyInfo.mainType = mainType;\n                        item.keyInfo.subType = determineSubType(mainType, opt, item.exist);\n                    }\n                });\n\n                var dependentModels = getComponentsByTypes(\n                    componentsMap, dependencies\n                );\n\n                option[mainType] = [];\n                componentsMap[mainType] = [];\n\n                each(mapResult, function (resultItem, index) {\n                    var componentModel = resultItem.exist;\n                    var newCptOption = resultItem.option;\n\n                    zrUtil.assert(\n                        isObject(newCptOption) || componentModel,\n                        'Empty component definition'\n                    );\n\n                    // Consider where is no new option and should be merged using {},\n                    // see removeEdgeAndAdd in topologicalTravel and\n                    // ComponentModel.getAllClassMainTypes.\n                    if (!newCptOption) {\n                        componentModel.mergeOption({}, this);\n                        componentModel.optionUpdated({}, false);\n                    }\n                    else {\n                        var ComponentModelClass = ComponentModel.getClass(\n                            mainType, resultItem.keyInfo.subType, true\n                        );\n\n                        if (componentModel && componentModel instanceof ComponentModelClass) {\n                            componentModel.name = resultItem.keyInfo.name;\n                            componentModel.mergeOption(newCptOption, this);\n                            componentModel.optionUpdated(newCptOption, false);\n                        }\n                        else {\n                            // PENDING Global as parent ?\n                            var extraOpt = zrUtil.extend(\n                                {\n                                    dependentModels: dependentModels,\n                                    componentIndex: index\n                                },\n                                resultItem.keyInfo\n                            );\n                            componentModel = new ComponentModelClass(\n                                newCptOption, this, this, extraOpt\n                            );\n                            zrUtil.extend(componentModel, extraOpt);\n                            componentModel.init(newCptOption, this, this, extraOpt);\n                            // Call optionUpdated after init.\n                            // newCptOption has been used as componentModel.option\n                            // and may be merged with theme and default, so pass null\n                            // to avoid confusion.\n                            componentModel.optionUpdated(null, true);\n                        }\n                    }\n\n                    componentsMap[mainType][index] = componentModel;\n                    option[mainType][index] = componentModel.option;\n                }, this);\n\n                // Backup series for filtering.\n                if (mainType === 'series') {\n                    this._seriesIndices = createSeriesIndices(componentsMap.series);\n                }\n            }\n        },\n\n        /**\n         * Get option for output (cloned option and inner info removed)\n         * @public\n         * @return {Object}\n         */\n        getOption: function () {\n            var option = zrUtil.clone(this.option);\n\n            each(option, function (opts, mainType) {\n                if (ComponentModel.hasClass(mainType)) {\n                    var opts = modelUtil.normalizeToArray(opts);\n                    for (var i = opts.length - 1; i >= 0; i--) {\n                        // Remove options with inner id.\n                        if (modelUtil.isIdInner(opts[i])) {\n                            opts.splice(i, 1);\n                        }\n                    }\n                    option[mainType] = opts;\n                }\n            });\n\n            delete option[OPTION_INNER_KEY];\n\n            return option;\n        },\n\n        /**\n         * @return {module:echarts/model/Model}\n         */\n        getTheme: function () {\n            return this._theme;\n        },\n\n        /**\n         * @param {string} mainType\n         * @param {number} [idx=0]\n         * @return {module:echarts/model/Component}\n         */\n        getComponent: function (mainType, idx) {\n            var list = this._componentsMap[mainType];\n            if (list) {\n                return list[idx || 0];\n            }\n        },\n\n        /**\n         * If none of index and id and name used, return all components with mainType.\n         * @param {Object} condition\n         * @param {string} condition.mainType\n         * @param {string} [condition.subType] If ignore, only query by mainType\n         * @param {number|Array.<number>} [condition.index] Either input index or id or name.\n         * @param {string|Array.<string>} [condition.id] Either input index or id or name.\n         * @param {string|Array.<string>} [condition.name] Either input index or id or name.\n         * @return {Array.<module:echarts/model/Component>}\n         */\n        queryComponents: function (condition) {\n            var mainType = condition.mainType;\n            if (!mainType) {\n                return [];\n            }\n\n            var index = condition.index;\n            var id = condition.id;\n            var name = condition.name;\n\n            var cpts = this._componentsMap[mainType];\n\n            if (!cpts || !cpts.length) {\n                return [];\n            }\n\n            var result;\n\n            if (index != null) {\n                if (!isArray(index)) {\n                    index = [index];\n                }\n                result = filter(map(index, function (idx) {\n                    return cpts[idx];\n                }), function (val) {\n                    return !!val;\n                });\n            }\n            else if (id != null) {\n                var isIdArray = isArray(id);\n                result = filter(cpts, function (cpt) {\n                    return (isIdArray && indexOf(id, cpt.id) >= 0)\n                        || (!isIdArray && cpt.id === id);\n                });\n            }\n            else if (name != null) {\n                var isNameArray = isArray(name);\n                result = filter(cpts, function (cpt) {\n                    return (isNameArray && indexOf(name, cpt.name) >= 0)\n                        || (!isNameArray && cpt.name === name);\n                });\n            }\n            else {\n                // Return all components with mainType\n                result = cpts.slice();\n            }\n\n            return filterBySubType(result, condition);\n        },\n\n        /**\n         * The interface is different from queryComponents,\n         * which is convenient for inner usage.\n         *\n         * @usage\n         * var result = findComponents(\n         *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}}\n         * );\n         * var result = findComponents(\n         *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}}\n         * );\n         * var result = findComponents(\n         *     {mainType: 'series'},\n         *     function (model, index) {...}\n         * );\n         * // result like [component0, componnet1, ...]\n         *\n         * @param {Object} condition\n         * @param {string} condition.mainType Mandatory.\n         * @param {string} [condition.subType] Optional.\n         * @param {Object} [condition.query] like {xxxIndex, xxxId, xxxName},\n         *        where xxx is mainType.\n         *        If query attribute is null/undefined or has no index/id/name,\n         *        do not filtering by query conditions, which is convenient for\n         *        no-payload situations or when target of action is global.\n         * @param {Function} [condition.filter] parameter: component, return boolean.\n         * @return {Array.<module:echarts/model/Component>}\n         */\n        findComponents: function (condition) {\n            var query = condition.query;\n            var mainType = condition.mainType;\n\n            var queryCond = getQueryCond(query);\n            var result = queryCond\n                ? this.queryComponents(queryCond)\n                : this._componentsMap[mainType];\n\n            return doFilter(filterBySubType(result, condition));\n\n            function getQueryCond(q) {\n                var indexAttr = mainType + 'Index';\n                var idAttr = mainType + 'Id';\n                var nameAttr = mainType + 'Name';\n                return q && (\n                        q[indexAttr] != null\n                        || q[idAttr] != null\n                        || q[nameAttr] != null\n                    )\n                    ? {\n                        mainType: mainType,\n                        // subType will be filtered finally.\n                        index: q[indexAttr],\n                        id: q[idAttr],\n                        name: q[nameAttr]\n                    }\n                    : null;\n            }\n\n            function doFilter(res) {\n                return condition.filter\n                     ? filter(res, condition.filter)\n                     : res;\n            }\n        },\n\n        /**\n         * @usage\n         * eachComponent('legend', function (legendModel, index) {\n         *     ...\n         * });\n         * eachComponent(function (componentType, model, index) {\n         *     // componentType does not include subType\n         *     // (componentType is 'xxx' but not 'xxx.aa')\n         * });\n         * eachComponent(\n         *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}},\n         *     function (model, index) {...}\n         * );\n         * eachComponent(\n         *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}},\n         *     function (model, index) {...}\n         * );\n         *\n         * @param {string|Object=} mainType When mainType is object, the definition\n         *                                  is the same as the method 'findComponents'.\n         * @param {Function} cb\n         * @param {*} context\n         */\n        eachComponent: function (mainType, cb, context) {\n            var componentsMap = this._componentsMap;\n\n            if (typeof mainType === 'function') {\n                context = cb;\n                cb = mainType;\n                each(componentsMap, function (components, componentType) {\n                    each(components, function (component, index) {\n                        cb.call(context, componentType, component, index);\n                    });\n                });\n            }\n            else if (zrUtil.isString(mainType)) {\n                each(componentsMap[mainType], cb, context);\n            }\n            else if (isObject(mainType)) {\n                var queryResult = this.findComponents(mainType);\n                each(queryResult, cb, context);\n            }\n        },\n\n        /**\n         * @param {string} name\n         * @return {Array.<module:echarts/model/Series>}\n         */\n        getSeriesByName: function (name) {\n            var series = this._componentsMap.series;\n            return filter(series, function (oneSeries) {\n                return oneSeries.name === name;\n            });\n        },\n\n        /**\n         * @param {number} seriesIndex\n         * @return {module:echarts/model/Series}\n         */\n        getSeriesByIndex: function (seriesIndex) {\n            return this._componentsMap.series[seriesIndex];\n        },\n\n        /**\n         * @param {string} subType\n         * @return {Array.<module:echarts/model/Series>}\n         */\n        getSeriesByType: function (subType) {\n            var series = this._componentsMap.series;\n            return filter(series, function (oneSeries) {\n                return oneSeries.subType === subType;\n            });\n        },\n\n        /**\n         * @return {Array.<module:echarts/model/Series>}\n         */\n        getSeries: function () {\n            return this._componentsMap.series.slice();\n        },\n\n        /**\n         * After filtering, series may be different\n         * frome raw series.\n         *\n         * @param {Function} cb\n         * @param {*} context\n         */\n        eachSeries: function (cb, context) {\n            assertSeriesInitialized(this);\n            each(this._seriesIndices, function (rawSeriesIndex) {\n                var series = this._componentsMap.series[rawSeriesIndex];\n                cb.call(context, series, rawSeriesIndex);\n            }, this);\n        },\n\n        /**\n         * Iterate raw series before filtered.\n         *\n         * @param {Function} cb\n         * @param {*} context\n         */\n        eachRawSeries: function (cb, context) {\n            each(this._componentsMap.series, cb, context);\n        },\n\n        /**\n         * After filtering, series may be different.\n         * frome raw series.\n         *\n         * @parma {string} subType\n         * @param {Function} cb\n         * @param {*} context\n         */\n        eachSeriesByType: function (subType, cb, context) {\n            assertSeriesInitialized(this);\n            each(this._seriesIndices, function (rawSeriesIndex) {\n                var series = this._componentsMap.series[rawSeriesIndex];\n                if (series.subType === subType) {\n                    cb.call(context, series, rawSeriesIndex);\n                }\n            }, this);\n        },\n\n        /**\n         * Iterate raw series before filtered of given type.\n         *\n         * @parma {string} subType\n         * @param {Function} cb\n         * @param {*} context\n         */\n        eachRawSeriesByType: function (subType, cb, context) {\n            return each(this.getSeriesByType(subType), cb, context);\n        },\n\n        /**\n         * @param {module:echarts/model/Series} seriesModel\n         */\n        isSeriesFiltered: function (seriesModel) {\n            assertSeriesInitialized(this);\n            return zrUtil.indexOf(this._seriesIndices, seriesModel.componentIndex) < 0;\n        },\n\n        /**\n         * @param {Function} cb\n         * @param {*} context\n         */\n        filterSeries: function (cb, context) {\n            assertSeriesInitialized(this);\n            var filteredSeries = filter(\n                this._componentsMap.series, cb, context\n            );\n            this._seriesIndices = createSeriesIndices(filteredSeries);\n        },\n\n        restoreData: function () {\n            var componentsMap = this._componentsMap;\n\n            this._seriesIndices = createSeriesIndices(componentsMap.series);\n\n            var componentTypes = [];\n            each(componentsMap, function (components, componentType) {\n                componentTypes.push(componentType);\n            });\n\n            ComponentModel.topologicalTravel(\n                componentTypes,\n                ComponentModel.getAllClassMainTypes(),\n                function (componentType, dependencies) {\n                    each(componentsMap[componentType], function (component) {\n                        component.restoreData();\n                    });\n                }\n            );\n        }\n\n    });\n\n    /**\n     * @inner\n     */\n    function mergeTheme(option, theme) {\n        zrUtil.each(theme, function (themeItem, name) {\n            // 如果有 component model 则把具体的 merge 逻辑交给该 model 处理\n            if (!ComponentModel.hasClass(name)) {\n                if (typeof themeItem === 'object') {\n                    option[name] = !option[name]\n                        ? zrUtil.clone(themeItem)\n                        : zrUtil.merge(option[name], themeItem, false);\n                }\n                else {\n                    if (option[name] == null) {\n                        option[name] = themeItem;\n                    }\n                }\n            }\n        });\n    }\n\n    function initBase(baseOption) {\n        baseOption = baseOption;\n\n        // Using OPTION_INNER_KEY to mark that this option can not be used outside,\n        // i.e. `chart.setOption(chart.getModel().option);` is forbiden.\n        this.option = {};\n        this.option[OPTION_INNER_KEY] = 1;\n\n        /**\n         * Init with series: [], in case of calling findSeries method\n         * before series initialized.\n         * @type {Object.<string, Array.<module:echarts/model/Model>>}\n         * @private\n         */\n        this._componentsMap = {series: []};\n\n        /**\n         * Mapping between filtered series list and raw series list.\n         * key: filtered series indices, value: raw series indices.\n         * @type {Array.<nubmer>}\n         * @private\n         */\n        this._seriesIndices = null;\n\n        mergeTheme(baseOption, this._theme.option);\n\n        // TODO Needs clone when merging to the unexisted property\n        zrUtil.merge(baseOption, globalDefault, false);\n\n        this.mergeOption(baseOption);\n    }\n\n    /**\n     * @inner\n     * @param {Array.<string>|string} types model types\n     * @return {Object} key: {string} type, value: {Array.<Object>} models\n     */\n    function getComponentsByTypes(componentsMap, types) {\n        if (!zrUtil.isArray(types)) {\n            types = types ? [types] : [];\n        }\n\n        var ret = {};\n        each(types, function (type) {\n            ret[type] = (componentsMap[type] || []).slice();\n        });\n\n        return ret;\n    }\n\n    /**\n     * @inner\n     */\n    function determineSubType(mainType, newCptOption, existComponent) {\n        var subType = newCptOption.type\n            ? newCptOption.type\n            : existComponent\n            ? existComponent.subType\n            // Use determineSubType only when there is no existComponent.\n            : ComponentModel.determineSubType(mainType, newCptOption);\n\n        // tooltip, markline, markpoint may always has no subType\n        return subType;\n    }\n\n    /**\n     * @inner\n     */\n    function createSeriesIndices(seriesModels) {\n        return map(seriesModels, function (series) {\n            return series.componentIndex;\n        }) || [];\n    }\n\n    /**\n     * @inner\n     */\n    function filterBySubType(components, condition) {\n        // Using hasOwnProperty for restrict. Consider\n        // subType is undefined in user payload.\n        return condition.hasOwnProperty('subType')\n            ? filter(components, function (cpt) {\n                return cpt.subType === condition.subType;\n            })\n            : components;\n    }\n\n    /**\n     * @inner\n     */\n    function assertSeriesInitialized(ecModel) {\n        // Components that use _seriesIndices should depends on series component,\n        // which make sure that their initialization is after series.\n        if (true) {\n            if (!ecModel._seriesIndices) {\n                throw new Error('Series has not been initialized yet.');\n            }\n        }\n    }\n\n    zrUtil.mixin(GlobalModel, __webpack_require__(/*! ./mixin/colorPalette */ 69));\n\n    module.exports = GlobalModel;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTY3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL21vZGVsL0dsb2JhbC5qcz8xYzZmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRUNoYXJ0cyBnbG9iYWwgbW9kZWxcbiAqXG4gKiBAbW9kdWxlIHtlY2hhcnRzL21vZGVsL0dsb2JhbH1cbiAqL1xuXG5cblxuICAgIC8qKlxuICAgICAqIENhdXRpb246IElmIHRoZSBtZWNoYW5pc20gc2hvdWxkIGJlIGNoYW5nZWQgc29tZSBkYXksIHRoZXNlIGNhc2VzXG4gICAgICogc2hvdWxkIGJlIGNvbnNpZGVyZWQ6XG4gICAgICpcbiAgICAgKiAoMSkgSW4gYG1lcmdlIG9wdGlvbmAgbW9kZSwgaWYgdXNpbmcgdGhlIHNhbWUgb3B0aW9uIHRvIGNhbGwgYHNldE9wdGlvbmBcbiAgICAgKiBtYW55IHRpbWVzLCB0aGUgcmVzdWx0IHNob3VsZCBiZSB0aGUgc2FtZSAodHJ5IG91ciBiZXN0IHRvIGVuc3VyZSB0aGF0KS5cbiAgICAgKiAoMikgSW4gYG1lcmdlIG9wdGlvbmAgbW9kZSwgaWYgYSBjb21wb25lbnQgaGFzIG5vIGlkL25hbWUgc3BlY2lmaWVkLCBpdFxuICAgICAqIHdpbGwgYmUgbWVyZ2VkIGJ5IGluZGV4LCBhbmQgdGhlIHJlc3VsdCBzZXF1ZW5jZSBvZiB0aGUgY29tcG9uZW50cyBpc1xuICAgICAqIGNvbnNpc3RlbnQgdG8gdGhlIG9yaWdpbmFsIHNlcXVlbmNlLlxuICAgICAqICgzKSBgcmVzZXRgIGZlYXR1cmUgKGluIHRvb2xib3gpLiBGaW5kIGRldGFpbGVkIGluZm8gaW4gY29tbWVudHMgYWJvdXRcbiAgICAgKiBgbWVyZ2VPcHRpb25gIGluIG1vZHVsZTplY2hhcnRzL21vZGVsL09wdGlvbk1hbmFnZXIuXG4gICAgICovXG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG4gICAgdmFyIG1vZGVsVXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvbW9kZWwnKTtcbiAgICB2YXIgTW9kZWwgPSByZXF1aXJlKCcuL01vZGVsJyk7XG4gICAgdmFyIGVhY2ggPSB6clV0aWwuZWFjaDtcbiAgICB2YXIgZmlsdGVyID0genJVdGlsLmZpbHRlcjtcbiAgICB2YXIgbWFwID0genJVdGlsLm1hcDtcbiAgICB2YXIgaXNBcnJheSA9IHpyVXRpbC5pc0FycmF5O1xuICAgIHZhciBpbmRleE9mID0genJVdGlsLmluZGV4T2Y7XG4gICAgdmFyIGlzT2JqZWN0ID0genJVdGlsLmlzT2JqZWN0O1xuXG4gICAgdmFyIENvbXBvbmVudE1vZGVsID0gcmVxdWlyZSgnLi9Db21wb25lbnQnKTtcblxuICAgIHZhciBnbG9iYWxEZWZhdWx0ID0gcmVxdWlyZSgnLi9nbG9iYWxEZWZhdWx0Jyk7XG5cbiAgICB2YXIgT1BUSU9OX0lOTkVSX0tFWSA9ICdcXDBfZWNfaW5uZXInO1xuXG4gICAgLyoqXG4gICAgICogQGFsaWFzIG1vZHVsZTplY2hhcnRzL21vZGVsL0dsb2JhbFxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvblxuICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWx9IHBhcmVudE1vZGVsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRoZW1lXG4gICAgICovXG4gICAgdmFyIEdsb2JhbE1vZGVsID0gTW9kZWwuZXh0ZW5kKHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogR2xvYmFsTW9kZWwsXG5cbiAgICAgICAgaW5pdDogZnVuY3Rpb24gKG9wdGlvbiwgcGFyZW50TW9kZWwsIHRoZW1lLCBvcHRpb25NYW5hZ2VyKSB7XG4gICAgICAgICAgICB0aGVtZSA9IHRoZW1lIHx8IHt9O1xuXG4gICAgICAgICAgICB0aGlzLm9wdGlvbiA9IG51bGw7IC8vIE1hcmsgYXMgbm90IGluaXRpYWxpemVkLlxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEB0eXBlIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH1cbiAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuX3RoZW1lID0gbmV3IE1vZGVsKHRoZW1lKTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAdHlwZSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvT3B0aW9uTWFuYWdlcn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5fb3B0aW9uTWFuYWdlciA9IG9wdGlvbk1hbmFnZXI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0T3B0aW9uOiBmdW5jdGlvbiAob3B0aW9uLCBvcHRpb25QcmVwcm9jZXNzb3JGdW5jcywgb25seUdyYXBoaWMpIHtcbiAgICAgICAgICAgIHpyVXRpbC5hc3NlcnQoXG4gICAgICAgICAgICAgICAgIShPUFRJT05fSU5ORVJfS0VZIGluIG9wdGlvbiksXG4gICAgICAgICAgICAgICAgJ3BsZWFzZSB1c2UgY2hhcnQuZ2V0T3B0aW9uKCknXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICB0aGlzLl9vcHRpb25NYW5hZ2VyLnNldE9wdGlvbihvcHRpb24sIG9wdGlvblByZXByb2Nlc3NvckZ1bmNzKTtcblxuICAgICAgICAgICAgdGhpcy5yZXNldE9wdGlvbihudWxsLCBvbmx5R3JhcGhpYyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIG51bGwvdW5kZWZpbmVkOiByZXNldCBhbGwuXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICdyZWNyZWF0ZSc6IGZvcmNlIHJlY3JlYXRlIGFsbC5cbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgICAgJ3RpbWVsaW5lJzogb25seSByZXNldCB0aW1lbGluZSBvcHRpb25cbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgICAgJ21lZGlhJzogb25seSByZXNldCBtZWRpYSBxdWVyeSBvcHRpb25cbiAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciBvcHRpb24gY2hhbmdlZC5cbiAgICAgICAgICovXG4gICAgICAgIHJlc2V0T3B0aW9uOiBmdW5jdGlvbiAodHlwZSwgb25seUdyYXBoaWMpIHtcbiAgICAgICAgICAgIHZhciBvcHRpb25DaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgb3B0aW9uTWFuYWdlciA9IHRoaXMuX29wdGlvbk1hbmFnZXI7XG5cbiAgICAgICAgICAgIGlmICghdHlwZSB8fCB0eXBlID09PSAncmVjcmVhdGUnKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJhc2VPcHRpb24gPSBvcHRpb25NYW5hZ2VyLm1vdW50T3B0aW9uKHR5cGUgPT09ICdyZWNyZWF0ZScpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLm9wdGlvbiB8fCB0eXBlID09PSAncmVjcmVhdGUnKSB7XG4gICAgICAgICAgICAgICAgICAgIGluaXRCYXNlLmNhbGwodGhpcywgYmFzZU9wdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBvbmx5IGdyYXBoaWMsIG90aGVyIHNlcmllcyBhbmQgY29tcG9uZW50IHdpbGwgbm90XG4gICAgICAgICAgICAgICAgICAgIC8vIGdvIHRocm91Z2ggdXBkYXRlIHByb2Nlc3MsIGRhdGEgc2hvdWxkIG5vdCBiZSByZXN0b3JlZC5cbiAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIGdycGhpYyBlbHMgbW91bnRlZCBvbiBkYXRhIHdpbGwgYmUgZWxpbWluYXRlZFxuICAgICAgICAgICAgICAgICAgICAvLyBhbmQgZG93bnBsYXkgd2lsbCBub3Qgd29yay5cbiAgICAgICAgICAgICAgICAgICAgIW9ubHlHcmFwaGljICYmIHRoaXMucmVzdG9yZURhdGEoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tZXJnZU9wdGlvbihiYXNlT3B0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3B0aW9uQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlID09PSAndGltZWxpbmUnIHx8IHR5cGUgPT09ICdtZWRpYScpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3RvcmVEYXRhKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghdHlwZSB8fCB0eXBlID09PSAncmVjcmVhdGUnIHx8IHR5cGUgPT09ICd0aW1lbGluZScpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGltZWxpbmVPcHRpb24gPSBvcHRpb25NYW5hZ2VyLmdldFRpbWVsaW5lT3B0aW9uKHRoaXMpO1xuICAgICAgICAgICAgICAgIHRpbWVsaW5lT3B0aW9uICYmICh0aGlzLm1lcmdlT3B0aW9uKHRpbWVsaW5lT3B0aW9uKSwgb3B0aW9uQ2hhbmdlZCA9IHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXR5cGUgfHwgdHlwZSA9PT0gJ3JlY3JlYXRlJyB8fCB0eXBlID09PSAnbWVkaWEnKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1lZGlhT3B0aW9ucyA9IG9wdGlvbk1hbmFnZXIuZ2V0TWVkaWFPcHRpb24odGhpcywgdGhpcy5fYXBpKTtcbiAgICAgICAgICAgICAgICBpZiAobWVkaWFPcHRpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBlYWNoKG1lZGlhT3B0aW9ucywgZnVuY3Rpb24gKG1lZGlhT3B0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1lcmdlT3B0aW9uKG1lZGlhT3B0aW9uLCBvcHRpb25DaGFuZ2VkID0gdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbkNoYW5nZWQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG1lcmdlT3B0aW9uOiBmdW5jdGlvbiAobmV3T3B0aW9uKSB7XG4gICAgICAgICAgICB2YXIgb3B0aW9uID0gdGhpcy5vcHRpb247XG4gICAgICAgICAgICB2YXIgY29tcG9uZW50c01hcCA9IHRoaXMuX2NvbXBvbmVudHNNYXA7XG4gICAgICAgICAgICB2YXIgbmV3Q3B0VHlwZXMgPSBbXTtcblxuICAgICAgICAgICAgLy8g5aaC5p6c5LiN5a2Y5Zyo5a+55bqU55qEIGNvbXBvbmVudCBtb2RlbCDliJnnm7TmjqUgbWVyZ2VcbiAgICAgICAgICAgIGVhY2gobmV3T3B0aW9uLCBmdW5jdGlvbiAoY29tcG9uZW50T3B0aW9uLCBtYWluVHlwZSkge1xuICAgICAgICAgICAgICAgIGlmIChjb21wb25lbnRPcHRpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFDb21wb25lbnRNb2RlbC5oYXNDbGFzcyhtYWluVHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uW21haW5UeXBlXSA9IG9wdGlvblttYWluVHlwZV0gPT0gbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgPyB6clV0aWwuY2xvbmUoY29tcG9uZW50T3B0aW9uKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB6clV0aWwubWVyZ2Uob3B0aW9uW21haW5UeXBlXSwgY29tcG9uZW50T3B0aW9uLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0NwdFR5cGVzLnB1c2gobWFpblR5cGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBGSVhNRSBPUFRJT04g5ZCM5q2l5piv5ZCm6KaB5pS55Zue5Y6f5p2l55qEXG4gICAgICAgICAgICBDb21wb25lbnRNb2RlbC50b3BvbG9naWNhbFRyYXZlbChcbiAgICAgICAgICAgICAgICBuZXdDcHRUeXBlcywgQ29tcG9uZW50TW9kZWwuZ2V0QWxsQ2xhc3NNYWluVHlwZXMoKSwgdmlzaXRDb21wb25lbnQsIHRoaXNcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHRoaXMuX3Nlcmllc0luZGljZXMgPSB0aGlzLl9zZXJpZXNJbmRpY2VzIHx8IFtdO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiB2aXNpdENvbXBvbmVudChtYWluVHlwZSwgZGVwZW5kZW5jaWVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5ld0NwdE9wdGlvbkxpc3QgPSBtb2RlbFV0aWwubm9ybWFsaXplVG9BcnJheShuZXdPcHRpb25bbWFpblR5cGVdKTtcblxuICAgICAgICAgICAgICAgIHZhciBtYXBSZXN1bHQgPSBtb2RlbFV0aWwubWFwcGluZ1RvRXhpc3RzKFxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRzTWFwW21haW5UeXBlXSwgbmV3Q3B0T3B0aW9uTGlzdFxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICBtb2RlbFV0aWwubWFrZUlkQW5kTmFtZShtYXBSZXN1bHQpO1xuXG4gICAgICAgICAgICAgICAgLy8gU2V0IG1haW5UeXBlIGFuZCBjb21wbGV0ZSBzdWJUeXBlLlxuICAgICAgICAgICAgICAgIGVhY2gobWFwUmVzdWx0LCBmdW5jdGlvbiAoaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wdCA9IGl0ZW0ub3B0aW9uO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNPYmplY3Qob3B0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5rZXlJbmZvLm1haW5UeXBlID0gbWFpblR5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLmtleUluZm8uc3ViVHlwZSA9IGRldGVybWluZVN1YlR5cGUobWFpblR5cGUsIG9wdCwgaXRlbS5leGlzdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHZhciBkZXBlbmRlbnRNb2RlbHMgPSBnZXRDb21wb25lbnRzQnlUeXBlcyhcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50c01hcCwgZGVwZW5kZW5jaWVzXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIG9wdGlvblttYWluVHlwZV0gPSBbXTtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzTWFwW21haW5UeXBlXSA9IFtdO1xuXG4gICAgICAgICAgICAgICAgZWFjaChtYXBSZXN1bHQsIGZ1bmN0aW9uIChyZXN1bHRJdGVtLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29tcG9uZW50TW9kZWwgPSByZXN1bHRJdGVtLmV4aXN0O1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3Q3B0T3B0aW9uID0gcmVzdWx0SXRlbS5vcHRpb247XG5cbiAgICAgICAgICAgICAgICAgICAgenJVdGlsLmFzc2VydChcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzT2JqZWN0KG5ld0NwdE9wdGlvbikgfHwgY29tcG9uZW50TW9kZWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRW1wdHkgY29tcG9uZW50IGRlZmluaXRpb24nXG4gICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ29uc2lkZXIgd2hlcmUgaXMgbm8gbmV3IG9wdGlvbiBhbmQgc2hvdWxkIGJlIG1lcmdlZCB1c2luZyB7fSxcbiAgICAgICAgICAgICAgICAgICAgLy8gc2VlIHJlbW92ZUVkZ2VBbmRBZGQgaW4gdG9wb2xvZ2ljYWxUcmF2ZWwgYW5kXG4gICAgICAgICAgICAgICAgICAgIC8vIENvbXBvbmVudE1vZGVsLmdldEFsbENsYXNzTWFpblR5cGVzLlxuICAgICAgICAgICAgICAgICAgICBpZiAoIW5ld0NwdE9wdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50TW9kZWwubWVyZ2VPcHRpb24oe30sIHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50TW9kZWwub3B0aW9uVXBkYXRlZCh7fSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIENvbXBvbmVudE1vZGVsQ2xhc3MgPSBDb21wb25lbnRNb2RlbC5nZXRDbGFzcyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYWluVHlwZSwgcmVzdWx0SXRlbS5rZXlJbmZvLnN1YlR5cGUsIHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb21wb25lbnRNb2RlbCAmJiBjb21wb25lbnRNb2RlbCBpbnN0YW5jZW9mIENvbXBvbmVudE1vZGVsQ2xhc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRNb2RlbC5uYW1lID0gcmVzdWx0SXRlbS5rZXlJbmZvLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50TW9kZWwubWVyZ2VPcHRpb24obmV3Q3B0T3B0aW9uLCB0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRNb2RlbC5vcHRpb25VcGRhdGVkKG5ld0NwdE9wdGlvbiwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUEVORElORyBHbG9iYWwgYXMgcGFyZW50ID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXh0cmFPcHQgPSB6clV0aWwuZXh0ZW5kKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXBlbmRlbnRNb2RlbHM6IGRlcGVuZGVudE1vZGVscyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudEluZGV4OiBpbmRleFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRJdGVtLmtleUluZm9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudE1vZGVsID0gbmV3IENvbXBvbmVudE1vZGVsQ2xhc3MoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NwdE9wdGlvbiwgdGhpcywgdGhpcywgZXh0cmFPcHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHpyVXRpbC5leHRlbmQoY29tcG9uZW50TW9kZWwsIGV4dHJhT3B0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRNb2RlbC5pbml0KG5ld0NwdE9wdGlvbiwgdGhpcywgdGhpcywgZXh0cmFPcHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhbGwgb3B0aW9uVXBkYXRlZCBhZnRlciBpbml0LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5ld0NwdE9wdGlvbiBoYXMgYmVlbiB1c2VkIGFzIGNvbXBvbmVudE1vZGVsLm9wdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCBtYXkgYmUgbWVyZ2VkIHdpdGggdGhlbWUgYW5kIGRlZmF1bHQsIHNvIHBhc3MgbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRvIGF2b2lkIGNvbmZ1c2lvbi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRNb2RlbC5vcHRpb25VcGRhdGVkKG51bGwsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50c01hcFttYWluVHlwZV1baW5kZXhdID0gY29tcG9uZW50TW9kZWw7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvblttYWluVHlwZV1baW5kZXhdID0gY29tcG9uZW50TW9kZWwub3B0aW9uO1xuICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgICAgICAgLy8gQmFja3VwIHNlcmllcyBmb3IgZmlsdGVyaW5nLlxuICAgICAgICAgICAgICAgIGlmIChtYWluVHlwZSA9PT0gJ3NlcmllcycpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2VyaWVzSW5kaWNlcyA9IGNyZWF0ZVNlcmllc0luZGljZXMoY29tcG9uZW50c01hcC5zZXJpZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IG9wdGlvbiBmb3Igb3V0cHV0IChjbG9uZWQgb3B0aW9uIGFuZCBpbm5lciBpbmZvIHJlbW92ZWQpXG4gICAgICAgICAqIEBwdWJsaWNcbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0T3B0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb3B0aW9uID0genJVdGlsLmNsb25lKHRoaXMub3B0aW9uKTtcblxuICAgICAgICAgICAgZWFjaChvcHRpb24sIGZ1bmN0aW9uIChvcHRzLCBtYWluVHlwZSkge1xuICAgICAgICAgICAgICAgIGlmIChDb21wb25lbnRNb2RlbC5oYXNDbGFzcyhtYWluVHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wdHMgPSBtb2RlbFV0aWwubm9ybWFsaXplVG9BcnJheShvcHRzKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IG9wdHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBvcHRpb25zIHdpdGggaW5uZXIgaWQuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobW9kZWxVdGlsLmlzSWRJbm5lcihvcHRzW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvblttYWluVHlwZV0gPSBvcHRzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBkZWxldGUgb3B0aW9uW09QVElPTl9JTk5FUl9LRVldO1xuXG4gICAgICAgICAgICByZXR1cm4gb3B0aW9uO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH1cbiAgICAgICAgICovXG4gICAgICAgIGdldFRoZW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGhlbWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtYWluVHlwZVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2lkeD0wXVxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Db21wb25lbnR9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRDb21wb25lbnQ6IGZ1bmN0aW9uIChtYWluVHlwZSwgaWR4KSB7XG4gICAgICAgICAgICB2YXIgbGlzdCA9IHRoaXMuX2NvbXBvbmVudHNNYXBbbWFpblR5cGVdO1xuICAgICAgICAgICAgaWYgKGxpc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGlzdFtpZHggfHwgMF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIG5vbmUgb2YgaW5kZXggYW5kIGlkIGFuZCBuYW1lIHVzZWQsIHJldHVybiBhbGwgY29tcG9uZW50cyB3aXRoIG1haW5UeXBlLlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZGl0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb25kaXRpb24ubWFpblR5cGVcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtjb25kaXRpb24uc3ViVHlwZV0gSWYgaWdub3JlLCBvbmx5IHF1ZXJ5IGJ5IG1haW5UeXBlXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfEFycmF5LjxudW1iZXI+fSBbY29uZGl0aW9uLmluZGV4XSBFaXRoZXIgaW5wdXQgaW5kZXggb3IgaWQgb3IgbmFtZS5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd8QXJyYXkuPHN0cmluZz59IFtjb25kaXRpb24uaWRdIEVpdGhlciBpbnB1dCBpbmRleCBvciBpZCBvciBuYW1lLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ3xBcnJheS48c3RyaW5nPn0gW2NvbmRpdGlvbi5uYW1lXSBFaXRoZXIgaW5wdXQgaW5kZXggb3IgaWQgb3IgbmFtZS5cbiAgICAgICAgICogQHJldHVybiB7QXJyYXkuPG1vZHVsZTplY2hhcnRzL21vZGVsL0NvbXBvbmVudD59XG4gICAgICAgICAqL1xuICAgICAgICBxdWVyeUNvbXBvbmVudHM6IGZ1bmN0aW9uIChjb25kaXRpb24pIHtcbiAgICAgICAgICAgIHZhciBtYWluVHlwZSA9IGNvbmRpdGlvbi5tYWluVHlwZTtcbiAgICAgICAgICAgIGlmICghbWFpblR5cGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBpbmRleCA9IGNvbmRpdGlvbi5pbmRleDtcbiAgICAgICAgICAgIHZhciBpZCA9IGNvbmRpdGlvbi5pZDtcbiAgICAgICAgICAgIHZhciBuYW1lID0gY29uZGl0aW9uLm5hbWU7XG5cbiAgICAgICAgICAgIHZhciBjcHRzID0gdGhpcy5fY29tcG9uZW50c01hcFttYWluVHlwZV07XG5cbiAgICAgICAgICAgIGlmICghY3B0cyB8fCAhY3B0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgICAgICAgIGlmIChpbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc0FycmF5KGluZGV4KSkge1xuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IFtpbmRleF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZpbHRlcihtYXAoaW5kZXgsIGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNwdHNbaWR4XTtcbiAgICAgICAgICAgICAgICB9KSwgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gISF2YWw7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlzSWRBcnJheSA9IGlzQXJyYXkoaWQpO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZpbHRlcihjcHRzLCBmdW5jdGlvbiAoY3B0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoaXNJZEFycmF5ICYmIGluZGV4T2YoaWQsIGNwdC5pZCkgPj0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgIHx8ICghaXNJZEFycmF5ICYmIGNwdC5pZCA9PT0gaWQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobmFtZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlzTmFtZUFycmF5ID0gaXNBcnJheShuYW1lKTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmaWx0ZXIoY3B0cywgZnVuY3Rpb24gKGNwdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGlzTmFtZUFycmF5ICYmIGluZGV4T2YobmFtZSwgY3B0Lm5hbWUpID49IDApXG4gICAgICAgICAgICAgICAgICAgICAgICB8fCAoIWlzTmFtZUFycmF5ICYmIGNwdC5uYW1lID09PSBuYW1lKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFJldHVybiBhbGwgY29tcG9uZW50cyB3aXRoIG1haW5UeXBlXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gY3B0cy5zbGljZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmlsdGVyQnlTdWJUeXBlKHJlc3VsdCwgY29uZGl0aW9uKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGludGVyZmFjZSBpcyBkaWZmZXJlbnQgZnJvbSBxdWVyeUNvbXBvbmVudHMsXG4gICAgICAgICAqIHdoaWNoIGlzIGNvbnZlbmllbnQgZm9yIGlubmVyIHVzYWdlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdXNhZ2VcbiAgICAgICAgICogdmFyIHJlc3VsdCA9IGZpbmRDb21wb25lbnRzKFxuICAgICAgICAgKiAgICAge21haW5UeXBlOiAnZGF0YVpvb20nLCBxdWVyeToge2RhdGFab29tSWQ6ICdhYmMnfX1cbiAgICAgICAgICogKTtcbiAgICAgICAgICogdmFyIHJlc3VsdCA9IGZpbmRDb21wb25lbnRzKFxuICAgICAgICAgKiAgICAge21haW5UeXBlOiAnc2VyaWVzJywgc3ViVHlwZTogJ3BpZScsIHF1ZXJ5OiB7c2VyaWVzTmFtZTogJ3Vpbyd9fVxuICAgICAgICAgKiApO1xuICAgICAgICAgKiB2YXIgcmVzdWx0ID0gZmluZENvbXBvbmVudHMoXG4gICAgICAgICAqICAgICB7bWFpblR5cGU6ICdzZXJpZXMnfSxcbiAgICAgICAgICogICAgIGZ1bmN0aW9uIChtb2RlbCwgaW5kZXgpIHsuLi59XG4gICAgICAgICAqICk7XG4gICAgICAgICAqIC8vIHJlc3VsdCBsaWtlIFtjb21wb25lbnQwLCBjb21wb25uZXQxLCAuLi5dXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25kaXRpb25cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbmRpdGlvbi5tYWluVHlwZSBNYW5kYXRvcnkuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY29uZGl0aW9uLnN1YlR5cGVdIE9wdGlvbmFsLlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmRpdGlvbi5xdWVyeV0gbGlrZSB7eHh4SW5kZXgsIHh4eElkLCB4eHhOYW1lfSxcbiAgICAgICAgICogICAgICAgIHdoZXJlIHh4eCBpcyBtYWluVHlwZS5cbiAgICAgICAgICogICAgICAgIElmIHF1ZXJ5IGF0dHJpYnV0ZSBpcyBudWxsL3VuZGVmaW5lZCBvciBoYXMgbm8gaW5kZXgvaWQvbmFtZSxcbiAgICAgICAgICogICAgICAgIGRvIG5vdCBmaWx0ZXJpbmcgYnkgcXVlcnkgY29uZGl0aW9ucywgd2hpY2ggaXMgY29udmVuaWVudCBmb3JcbiAgICAgICAgICogICAgICAgIG5vLXBheWxvYWQgc2l0dWF0aW9ucyBvciB3aGVuIHRhcmdldCBvZiBhY3Rpb24gaXMgZ2xvYmFsLlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29uZGl0aW9uLmZpbHRlcl0gcGFyYW1ldGVyOiBjb21wb25lbnQsIHJldHVybiBib29sZWFuLlxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48bW9kdWxlOmVjaGFydHMvbW9kZWwvQ29tcG9uZW50Pn1cbiAgICAgICAgICovXG4gICAgICAgIGZpbmRDb21wb25lbnRzOiBmdW5jdGlvbiAoY29uZGl0aW9uKSB7XG4gICAgICAgICAgICB2YXIgcXVlcnkgPSBjb25kaXRpb24ucXVlcnk7XG4gICAgICAgICAgICB2YXIgbWFpblR5cGUgPSBjb25kaXRpb24ubWFpblR5cGU7XG5cbiAgICAgICAgICAgIHZhciBxdWVyeUNvbmQgPSBnZXRRdWVyeUNvbmQocXVlcnkpO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHF1ZXJ5Q29uZFxuICAgICAgICAgICAgICAgID8gdGhpcy5xdWVyeUNvbXBvbmVudHMocXVlcnlDb25kKVxuICAgICAgICAgICAgICAgIDogdGhpcy5fY29tcG9uZW50c01hcFttYWluVHlwZV07XG5cbiAgICAgICAgICAgIHJldHVybiBkb0ZpbHRlcihmaWx0ZXJCeVN1YlR5cGUocmVzdWx0LCBjb25kaXRpb24pKTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0UXVlcnlDb25kKHEpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXhBdHRyID0gbWFpblR5cGUgKyAnSW5kZXgnO1xuICAgICAgICAgICAgICAgIHZhciBpZEF0dHIgPSBtYWluVHlwZSArICdJZCc7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWVBdHRyID0gbWFpblR5cGUgKyAnTmFtZSc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHEgJiYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgcVtpbmRleEF0dHJdICE9IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgIHx8IHFbaWRBdHRyXSAhPSBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICB8fCBxW25hbWVBdHRyXSAhPSBudWxsXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYWluVHlwZTogbWFpblR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzdWJUeXBlIHdpbGwgYmUgZmlsdGVyZWQgZmluYWxseS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBxW2luZGV4QXR0cl0sXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogcVtpZEF0dHJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogcVtuYW1lQXR0cl1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGRvRmlsdGVyKHJlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb25kaXRpb24uZmlsdGVyXG4gICAgICAgICAgICAgICAgICAgICA/IGZpbHRlcihyZXMsIGNvbmRpdGlvbi5maWx0ZXIpXG4gICAgICAgICAgICAgICAgICAgICA6IHJlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHVzYWdlXG4gICAgICAgICAqIGVhY2hDb21wb25lbnQoJ2xlZ2VuZCcsIGZ1bmN0aW9uIChsZWdlbmRNb2RlbCwgaW5kZXgpIHtcbiAgICAgICAgICogICAgIC4uLlxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICogZWFjaENvbXBvbmVudChmdW5jdGlvbiAoY29tcG9uZW50VHlwZSwgbW9kZWwsIGluZGV4KSB7XG4gICAgICAgICAqICAgICAvLyBjb21wb25lbnRUeXBlIGRvZXMgbm90IGluY2x1ZGUgc3ViVHlwZVxuICAgICAgICAgKiAgICAgLy8gKGNvbXBvbmVudFR5cGUgaXMgJ3h4eCcgYnV0IG5vdCAneHh4LmFhJylcbiAgICAgICAgICogfSk7XG4gICAgICAgICAqIGVhY2hDb21wb25lbnQoXG4gICAgICAgICAqICAgICB7bWFpblR5cGU6ICdkYXRhWm9vbScsIHF1ZXJ5OiB7ZGF0YVpvb21JZDogJ2FiYyd9fSxcbiAgICAgICAgICogICAgIGZ1bmN0aW9uIChtb2RlbCwgaW5kZXgpIHsuLi59XG4gICAgICAgICAqICk7XG4gICAgICAgICAqIGVhY2hDb21wb25lbnQoXG4gICAgICAgICAqICAgICB7bWFpblR5cGU6ICdzZXJpZXMnLCBzdWJUeXBlOiAncGllJywgcXVlcnk6IHtzZXJpZXNOYW1lOiAndWlvJ319LFxuICAgICAgICAgKiAgICAgZnVuY3Rpb24gKG1vZGVsLCBpbmRleCkgey4uLn1cbiAgICAgICAgICogKTtcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0PX0gbWFpblR5cGUgV2hlbiBtYWluVHlwZSBpcyBvYmplY3QsIHRoZSBkZWZpbml0aW9uXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzIHRoZSBzYW1lIGFzIHRoZSBtZXRob2QgJ2ZpbmRDb21wb25lbnRzJy5cbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAgICAgICAgICogQHBhcmFtIHsqfSBjb250ZXh0XG4gICAgICAgICAqL1xuICAgICAgICBlYWNoQ29tcG9uZW50OiBmdW5jdGlvbiAobWFpblR5cGUsIGNiLCBjb250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgY29tcG9uZW50c01hcCA9IHRoaXMuX2NvbXBvbmVudHNNYXA7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWFpblR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0ID0gY2I7XG4gICAgICAgICAgICAgICAgY2IgPSBtYWluVHlwZTtcbiAgICAgICAgICAgICAgICBlYWNoKGNvbXBvbmVudHNNYXAsIGZ1bmN0aW9uIChjb21wb25lbnRzLCBjb21wb25lbnRUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGVhY2goY29tcG9uZW50cywgZnVuY3Rpb24gKGNvbXBvbmVudCwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNiLmNhbGwoY29udGV4dCwgY29tcG9uZW50VHlwZSwgY29tcG9uZW50LCBpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoenJVdGlsLmlzU3RyaW5nKG1haW5UeXBlKSkge1xuICAgICAgICAgICAgICAgIGVhY2goY29tcG9uZW50c01hcFttYWluVHlwZV0sIGNiLCBjb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzT2JqZWN0KG1haW5UeXBlKSkge1xuICAgICAgICAgICAgICAgIHZhciBxdWVyeVJlc3VsdCA9IHRoaXMuZmluZENvbXBvbmVudHMobWFpblR5cGUpO1xuICAgICAgICAgICAgICAgIGVhY2gocXVlcnlSZXN1bHQsIGNiLCBjb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgICAgICogQHJldHVybiB7QXJyYXkuPG1vZHVsZTplY2hhcnRzL21vZGVsL1Nlcmllcz59XG4gICAgICAgICAqL1xuICAgICAgICBnZXRTZXJpZXNCeU5hbWU6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICB2YXIgc2VyaWVzID0gdGhpcy5fY29tcG9uZW50c01hcC5zZXJpZXM7XG4gICAgICAgICAgICByZXR1cm4gZmlsdGVyKHNlcmllcywgZnVuY3Rpb24gKG9uZVNlcmllcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBvbmVTZXJpZXMubmFtZSA9PT0gbmFtZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gc2VyaWVzSW5kZXhcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOmVjaGFydHMvbW9kZWwvU2VyaWVzfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0U2VyaWVzQnlJbmRleDogZnVuY3Rpb24gKHNlcmllc0luZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29tcG9uZW50c01hcC5zZXJpZXNbc2VyaWVzSW5kZXhdO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3ViVHlwZVxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48bW9kdWxlOmVjaGFydHMvbW9kZWwvU2VyaWVzPn1cbiAgICAgICAgICovXG4gICAgICAgIGdldFNlcmllc0J5VHlwZTogZnVuY3Rpb24gKHN1YlR5cGUpIHtcbiAgICAgICAgICAgIHZhciBzZXJpZXMgPSB0aGlzLl9jb21wb25lbnRzTWFwLnNlcmllcztcbiAgICAgICAgICAgIHJldHVybiBmaWx0ZXIoc2VyaWVzLCBmdW5jdGlvbiAob25lU2VyaWVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9uZVNlcmllcy5zdWJUeXBlID09PSBzdWJUeXBlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5Ljxtb2R1bGU6ZWNoYXJ0cy9tb2RlbC9TZXJpZXM+fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0U2VyaWVzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29tcG9uZW50c01hcC5zZXJpZXMuc2xpY2UoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQWZ0ZXIgZmlsdGVyaW5nLCBzZXJpZXMgbWF5IGJlIGRpZmZlcmVudFxuICAgICAgICAgKiBmcm9tZSByYXcgc2VyaWVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICAgICAgICAgKiBAcGFyYW0geyp9IGNvbnRleHRcbiAgICAgICAgICovXG4gICAgICAgIGVhY2hTZXJpZXM6IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge1xuICAgICAgICAgICAgYXNzZXJ0U2VyaWVzSW5pdGlhbGl6ZWQodGhpcyk7XG4gICAgICAgICAgICBlYWNoKHRoaXMuX3Nlcmllc0luZGljZXMsIGZ1bmN0aW9uIChyYXdTZXJpZXNJbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciBzZXJpZXMgPSB0aGlzLl9jb21wb25lbnRzTWFwLnNlcmllc1tyYXdTZXJpZXNJbmRleF07XG4gICAgICAgICAgICAgICAgY2IuY2FsbChjb250ZXh0LCBzZXJpZXMsIHJhd1Nlcmllc0luZGV4KTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJdGVyYXRlIHJhdyBzZXJpZXMgYmVmb3JlIGZpbHRlcmVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICAgICAgICAgKiBAcGFyYW0geyp9IGNvbnRleHRcbiAgICAgICAgICovXG4gICAgICAgIGVhY2hSYXdTZXJpZXM6IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge1xuICAgICAgICAgICAgZWFjaCh0aGlzLl9jb21wb25lbnRzTWFwLnNlcmllcywgY2IsIGNvbnRleHQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZnRlciBmaWx0ZXJpbmcsIHNlcmllcyBtYXkgYmUgZGlmZmVyZW50LlxuICAgICAgICAgKiBmcm9tZSByYXcgc2VyaWVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFybWEge3N0cmluZ30gc3ViVHlwZVxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICAgICAgICAgKiBAcGFyYW0geyp9IGNvbnRleHRcbiAgICAgICAgICovXG4gICAgICAgIGVhY2hTZXJpZXNCeVR5cGU6IGZ1bmN0aW9uIChzdWJUeXBlLCBjYiwgY29udGV4dCkge1xuICAgICAgICAgICAgYXNzZXJ0U2VyaWVzSW5pdGlhbGl6ZWQodGhpcyk7XG4gICAgICAgICAgICBlYWNoKHRoaXMuX3Nlcmllc0luZGljZXMsIGZ1bmN0aW9uIChyYXdTZXJpZXNJbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciBzZXJpZXMgPSB0aGlzLl9jb21wb25lbnRzTWFwLnNlcmllc1tyYXdTZXJpZXNJbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKHNlcmllcy5zdWJUeXBlID09PSBzdWJUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNiLmNhbGwoY29udGV4dCwgc2VyaWVzLCByYXdTZXJpZXNJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEl0ZXJhdGUgcmF3IHNlcmllcyBiZWZvcmUgZmlsdGVyZWQgb2YgZ2l2ZW4gdHlwZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcm1hIHtzdHJpbmd9IHN1YlR5cGVcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAgICAgICAgICogQHBhcmFtIHsqfSBjb250ZXh0XG4gICAgICAgICAqL1xuICAgICAgICBlYWNoUmF3U2VyaWVzQnlUeXBlOiBmdW5jdGlvbiAoc3ViVHlwZSwgY2IsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHJldHVybiBlYWNoKHRoaXMuZ2V0U2VyaWVzQnlUeXBlKHN1YlR5cGUpLCBjYiwgY29udGV4dCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvU2VyaWVzfSBzZXJpZXNNb2RlbFxuICAgICAgICAgKi9cbiAgICAgICAgaXNTZXJpZXNGaWx0ZXJlZDogZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICAgICAgICBhc3NlcnRTZXJpZXNJbml0aWFsaXplZCh0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiB6clV0aWwuaW5kZXhPZih0aGlzLl9zZXJpZXNJbmRpY2VzLCBzZXJpZXNNb2RlbC5jb21wb25lbnRJbmRleCkgPCAwO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICAgICAgICAgKiBAcGFyYW0geyp9IGNvbnRleHRcbiAgICAgICAgICovXG4gICAgICAgIGZpbHRlclNlcmllczogZnVuY3Rpb24gKGNiLCBjb250ZXh0KSB7XG4gICAgICAgICAgICBhc3NlcnRTZXJpZXNJbml0aWFsaXplZCh0aGlzKTtcbiAgICAgICAgICAgIHZhciBmaWx0ZXJlZFNlcmllcyA9IGZpbHRlcihcbiAgICAgICAgICAgICAgICB0aGlzLl9jb21wb25lbnRzTWFwLnNlcmllcywgY2IsIGNvbnRleHRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aGlzLl9zZXJpZXNJbmRpY2VzID0gY3JlYXRlU2VyaWVzSW5kaWNlcyhmaWx0ZXJlZFNlcmllcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVzdG9yZURhdGE6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjb21wb25lbnRzTWFwID0gdGhpcy5fY29tcG9uZW50c01hcDtcblxuICAgICAgICAgICAgdGhpcy5fc2VyaWVzSW5kaWNlcyA9IGNyZWF0ZVNlcmllc0luZGljZXMoY29tcG9uZW50c01hcC5zZXJpZXMpO1xuXG4gICAgICAgICAgICB2YXIgY29tcG9uZW50VHlwZXMgPSBbXTtcbiAgICAgICAgICAgIGVhY2goY29tcG9uZW50c01hcCwgZnVuY3Rpb24gKGNvbXBvbmVudHMsIGNvbXBvbmVudFR5cGUpIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRUeXBlcy5wdXNoKGNvbXBvbmVudFR5cGUpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIENvbXBvbmVudE1vZGVsLnRvcG9sb2dpY2FsVHJhdmVsKFxuICAgICAgICAgICAgICAgIGNvbXBvbmVudFR5cGVzLFxuICAgICAgICAgICAgICAgIENvbXBvbmVudE1vZGVsLmdldEFsbENsYXNzTWFpblR5cGVzKCksXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKGNvbXBvbmVudFR5cGUsIGRlcGVuZGVuY2llcykge1xuICAgICAgICAgICAgICAgICAgICBlYWNoKGNvbXBvbmVudHNNYXBbY29tcG9uZW50VHlwZV0sIGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5yZXN0b3JlRGF0YSgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1lcmdlVGhlbWUob3B0aW9uLCB0aGVtZSkge1xuICAgICAgICB6clV0aWwuZWFjaCh0aGVtZSwgZnVuY3Rpb24gKHRoZW1lSXRlbSwgbmFtZSkge1xuICAgICAgICAgICAgLy8g5aaC5p6c5pyJIGNvbXBvbmVudCBtb2RlbCDliJnmiorlhbfkvZPnmoQgbWVyZ2Ug6YC76L6R5Lqk57uZ6K+lIG1vZGVsIOWkhOeQhlxuICAgICAgICAgICAgaWYgKCFDb21wb25lbnRNb2RlbC5oYXNDbGFzcyhuYW1lKSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhlbWVJdGVtID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25bbmFtZV0gPSAhb3B0aW9uW25hbWVdXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHpyVXRpbC5jbG9uZSh0aGVtZUl0ZW0pXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHpyVXRpbC5tZXJnZShvcHRpb25bbmFtZV0sIHRoZW1lSXRlbSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbltuYW1lXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25bbmFtZV0gPSB0aGVtZUl0ZW07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluaXRCYXNlKGJhc2VPcHRpb24pIHtcbiAgICAgICAgYmFzZU9wdGlvbiA9IGJhc2VPcHRpb247XG5cbiAgICAgICAgLy8gVXNpbmcgT1BUSU9OX0lOTkVSX0tFWSB0byBtYXJrIHRoYXQgdGhpcyBvcHRpb24gY2FuIG5vdCBiZSB1c2VkIG91dHNpZGUsXG4gICAgICAgIC8vIGkuZS4gYGNoYXJ0LnNldE9wdGlvbihjaGFydC5nZXRNb2RlbCgpLm9wdGlvbik7YCBpcyBmb3JiaWRlbi5cbiAgICAgICAgdGhpcy5vcHRpb24gPSB7fTtcbiAgICAgICAgdGhpcy5vcHRpb25bT1BUSU9OX0lOTkVSX0tFWV0gPSAxO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbml0IHdpdGggc2VyaWVzOiBbXSwgaW4gY2FzZSBvZiBjYWxsaW5nIGZpbmRTZXJpZXMgbWV0aG9kXG4gICAgICAgICAqIGJlZm9yZSBzZXJpZXMgaW5pdGlhbGl6ZWQuXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywgQXJyYXkuPG1vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsPj59XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9jb21wb25lbnRzTWFwID0ge3NlcmllczogW119O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYXBwaW5nIGJldHdlZW4gZmlsdGVyZWQgc2VyaWVzIGxpc3QgYW5kIHJhdyBzZXJpZXMgbGlzdC5cbiAgICAgICAgICoga2V5OiBmaWx0ZXJlZCBzZXJpZXMgaW5kaWNlcywgdmFsdWU6IHJhdyBzZXJpZXMgaW5kaWNlcy5cbiAgICAgICAgICogQHR5cGUge0FycmF5LjxudWJtZXI+fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fc2VyaWVzSW5kaWNlcyA9IG51bGw7XG5cbiAgICAgICAgbWVyZ2VUaGVtZShiYXNlT3B0aW9uLCB0aGlzLl90aGVtZS5vcHRpb24pO1xuXG4gICAgICAgIC8vIFRPRE8gTmVlZHMgY2xvbmUgd2hlbiBtZXJnaW5nIHRvIHRoZSB1bmV4aXN0ZWQgcHJvcGVydHlcbiAgICAgICAgenJVdGlsLm1lcmdlKGJhc2VPcHRpb24sIGdsb2JhbERlZmF1bHQsIGZhbHNlKTtcblxuICAgICAgICB0aGlzLm1lcmdlT3B0aW9uKGJhc2VPcHRpb24pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBpbm5lclxuICAgICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz58c3RyaW5nfSB0eXBlcyBtb2RlbCB0eXBlc1xuICAgICAqIEByZXR1cm4ge09iamVjdH0ga2V5OiB7c3RyaW5nfSB0eXBlLCB2YWx1ZToge0FycmF5LjxPYmplY3Q+fSBtb2RlbHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRDb21wb25lbnRzQnlUeXBlcyhjb21wb25lbnRzTWFwLCB0eXBlcykge1xuICAgICAgICBpZiAoIXpyVXRpbC5pc0FycmF5KHR5cGVzKSkge1xuICAgICAgICAgICAgdHlwZXMgPSB0eXBlcyA/IFt0eXBlc10gOiBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXQgPSB7fTtcbiAgICAgICAgZWFjaCh0eXBlcywgZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgICAgIHJldFt0eXBlXSA9IChjb21wb25lbnRzTWFwW3R5cGVdIHx8IFtdKS5zbGljZSgpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRldGVybWluZVN1YlR5cGUobWFpblR5cGUsIG5ld0NwdE9wdGlvbiwgZXhpc3RDb21wb25lbnQpIHtcbiAgICAgICAgdmFyIHN1YlR5cGUgPSBuZXdDcHRPcHRpb24udHlwZVxuICAgICAgICAgICAgPyBuZXdDcHRPcHRpb24udHlwZVxuICAgICAgICAgICAgOiBleGlzdENvbXBvbmVudFxuICAgICAgICAgICAgPyBleGlzdENvbXBvbmVudC5zdWJUeXBlXG4gICAgICAgICAgICAvLyBVc2UgZGV0ZXJtaW5lU3ViVHlwZSBvbmx5IHdoZW4gdGhlcmUgaXMgbm8gZXhpc3RDb21wb25lbnQuXG4gICAgICAgICAgICA6IENvbXBvbmVudE1vZGVsLmRldGVybWluZVN1YlR5cGUobWFpblR5cGUsIG5ld0NwdE9wdGlvbik7XG5cbiAgICAgICAgLy8gdG9vbHRpcCwgbWFya2xpbmUsIG1hcmtwb2ludCBtYXkgYWx3YXlzIGhhcyBubyBzdWJUeXBlXG4gICAgICAgIHJldHVybiBzdWJUeXBlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVNlcmllc0luZGljZXMoc2VyaWVzTW9kZWxzKSB7XG4gICAgICAgIHJldHVybiBtYXAoc2VyaWVzTW9kZWxzLCBmdW5jdGlvbiAoc2VyaWVzKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VyaWVzLmNvbXBvbmVudEluZGV4O1xuICAgICAgICB9KSB8fCBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaWx0ZXJCeVN1YlR5cGUoY29tcG9uZW50cywgY29uZGl0aW9uKSB7XG4gICAgICAgIC8vIFVzaW5nIGhhc093blByb3BlcnR5IGZvciByZXN0cmljdC4gQ29uc2lkZXJcbiAgICAgICAgLy8gc3ViVHlwZSBpcyB1bmRlZmluZWQgaW4gdXNlciBwYXlsb2FkLlxuICAgICAgICByZXR1cm4gY29uZGl0aW9uLmhhc093blByb3BlcnR5KCdzdWJUeXBlJylcbiAgICAgICAgICAgID8gZmlsdGVyKGNvbXBvbmVudHMsIGZ1bmN0aW9uIChjcHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3B0LnN1YlR5cGUgPT09IGNvbmRpdGlvbi5zdWJUeXBlO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIDogY29tcG9uZW50cztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhc3NlcnRTZXJpZXNJbml0aWFsaXplZChlY01vZGVsKSB7XG4gICAgICAgIC8vIENvbXBvbmVudHMgdGhhdCB1c2UgX3Nlcmllc0luZGljZXMgc2hvdWxkIGRlcGVuZHMgb24gc2VyaWVzIGNvbXBvbmVudCxcbiAgICAgICAgLy8gd2hpY2ggbWFrZSBzdXJlIHRoYXQgdGhlaXIgaW5pdGlhbGl6YXRpb24gaXMgYWZ0ZXIgc2VyaWVzLlxuICAgICAgICBpZiAoX19ERVZfXykge1xuICAgICAgICAgICAgaWYgKCFlY01vZGVsLl9zZXJpZXNJbmRpY2VzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZXJpZXMgaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHpyVXRpbC5taXhpbihHbG9iYWxNb2RlbCwgcmVxdWlyZSgnLi9taXhpbi9jb2xvclBhbGV0dGUnKSk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IEdsb2JhbE1vZGVsO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvbW9kZWwvR2xvYmFsLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 168 */
/* unknown exports provided */
/* all exports used */
/*!************************************!*\
  !*** ./lib/model/OptionManager.js ***!
  \************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * ECharts option manager\n *\n * @module {echarts/model/OptionManager}\n */\n\n\n\n    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 0);\n    var modelUtil = __webpack_require__(/*! ../util/model */ 5);\n    var ComponentModel = __webpack_require__(/*! ./Component */ 12);\n    var each = zrUtil.each;\n    var clone = zrUtil.clone;\n    var map = zrUtil.map;\n    var merge = zrUtil.merge;\n\n    var QUERY_REG = /^(min|max)?(.+)$/;\n\n    /**\n     * TERM EXPLANATIONS:\n     *\n     * [option]:\n     *\n     *     An object that contains definitions of components. For example:\n     *     var option = {\n     *         title: {...},\n     *         legend: {...},\n     *         visualMap: {...},\n     *         series: [\n     *             {data: [...]},\n     *             {data: [...]},\n     *             ...\n     *         ]\n     *     };\n     *\n     * [rawOption]:\n     *\n     *     An object input to echarts.setOption. 'rawOption' may be an\n     *     'option', or may be an object contains multi-options. For example:\n     *     var option = {\n     *         baseOption: {\n     *             title: {...},\n     *             legend: {...},\n     *             series: [\n     *                 {data: [...]},\n     *                 {data: [...]},\n     *                 ...\n     *             ]\n     *         },\n     *         timeline: {...},\n     *         options: [\n     *             {title: {...}, series: {data: [...]}},\n     *             {title: {...}, series: {data: [...]}},\n     *             ...\n     *         ],\n     *         media: [\n     *             {\n     *                 query: {maxWidth: 320},\n     *                 option: {series: {x: 20}, visualMap: {show: false}}\n     *             },\n     *             {\n     *                 query: {minWidth: 320, maxWidth: 720},\n     *                 option: {series: {x: 500}, visualMap: {show: true}}\n     *             },\n     *             {\n     *                 option: {series: {x: 1200}, visualMap: {show: true}}\n     *             }\n     *         ]\n     *     };\n     *\n     * @alias module:echarts/model/OptionManager\n     * @param {module:echarts/ExtensionAPI} api\n     */\n    function OptionManager(api) {\n\n        /**\n         * @private\n         * @type {module:echarts/ExtensionAPI}\n         */\n        this._api = api;\n\n        /**\n         * @private\n         * @type {Array.<number>}\n         */\n        this._timelineOptions = [];\n\n        /**\n         * @private\n         * @type {Array.<Object>}\n         */\n        this._mediaList = [];\n\n        /**\n         * @private\n         * @type {Object}\n         */\n        this._mediaDefault;\n\n        /**\n         * -1, means default.\n         * empty means no media.\n         * @private\n         * @type {Array.<number>}\n         */\n        this._currentMediaIndices = [];\n\n        /**\n         * @private\n         * @type {Object}\n         */\n        this._optionBackup;\n\n        /**\n         * @private\n         * @type {Object}\n         */\n        this._newBaseOption;\n    }\n\n    // timeline.notMerge is not supported in ec3. Firstly there is rearly\n    // case that notMerge is needed. Secondly supporting 'notMerge' requires\n    // rawOption cloned and backuped when timeline changed, which does no\n    // good to performance. What's more, that both timeline and setOption\n    // method supply 'notMerge' brings complex and some problems.\n    // Consider this case:\n    // (step1) chart.setOption({timeline: {notMerge: false}, ...}, false);\n    // (step2) chart.setOption({timeline: {notMerge: true}, ...}, false);\n\n    OptionManager.prototype = {\n\n        constructor: OptionManager,\n\n        /**\n         * @public\n         * @param {Object} rawOption Raw option.\n         * @param {module:echarts/model/Global} ecModel\n         * @param {Array.<Function>} optionPreprocessorFuncs\n         * @return {Object} Init option\n         */\n        setOption: function (rawOption, optionPreprocessorFuncs) {\n            rawOption = clone(rawOption, true);\n\n            // FIXME\n            // 如果 timeline options 或者 media 中设置了某个属性，而baseOption中没有设置，则进行警告。\n\n            var oldOptionBackup = this._optionBackup;\n            var newParsedOption = parseRawOption.call(\n                this, rawOption, optionPreprocessorFuncs, !oldOptionBackup\n            );\n            this._newBaseOption = newParsedOption.baseOption;\n\n            // For setOption at second time (using merge mode);\n            if (oldOptionBackup) {\n                // Only baseOption can be merged.\n                mergeOption(oldOptionBackup.baseOption, newParsedOption.baseOption);\n\n                // For simplicity, timeline options and media options do not support merge,\n                // that is, if you `setOption` twice and both has timeline options, the latter\n                // timeline opitons will not be merged to the formers, but just substitude them.\n                if (newParsedOption.timelineOptions.length) {\n                    oldOptionBackup.timelineOptions = newParsedOption.timelineOptions;\n                }\n                if (newParsedOption.mediaList.length) {\n                    oldOptionBackup.mediaList = newParsedOption.mediaList;\n                }\n                if (newParsedOption.mediaDefault) {\n                    oldOptionBackup.mediaDefault = newParsedOption.mediaDefault;\n                }\n            }\n            else {\n                this._optionBackup = newParsedOption;\n            }\n        },\n\n        /**\n         * @param {boolean} isRecreate\n         * @return {Object}\n         */\n        mountOption: function (isRecreate) {\n            var optionBackup = this._optionBackup;\n\n            // TODO\n            // 如果没有reset功能则不clone。\n\n            this._timelineOptions = map(optionBackup.timelineOptions, clone);\n            this._mediaList = map(optionBackup.mediaList, clone);\n            this._mediaDefault = clone(optionBackup.mediaDefault);\n            this._currentMediaIndices = [];\n\n            return clone(isRecreate\n                // this._optionBackup.baseOption, which is created at the first `setOption`\n                // called, and is merged into every new option by inner method `mergeOption`\n                // each time `setOption` called, can be only used in `isRecreate`, because\n                // its reliability is under suspicion. In other cases option merge is\n                // performed by `model.mergeOption`.\n                ? optionBackup.baseOption : this._newBaseOption\n            );\n        },\n\n        /**\n         * @param {module:echarts/model/Global} ecModel\n         * @return {Object}\n         */\n        getTimelineOption: function (ecModel) {\n            var option;\n            var timelineOptions = this._timelineOptions;\n\n            if (timelineOptions.length) {\n                // getTimelineOption can only be called after ecModel inited,\n                // so we can get currentIndex from timelineModel.\n                var timelineModel = ecModel.getComponent('timeline');\n                if (timelineModel) {\n                    option = clone(\n                        timelineOptions[timelineModel.getCurrentIndex()],\n                        true\n                    );\n                }\n            }\n\n            return option;\n        },\n\n        /**\n         * @param {module:echarts/model/Global} ecModel\n         * @return {Array.<Object>}\n         */\n        getMediaOption: function (ecModel) {\n            var ecWidth = this._api.getWidth();\n            var ecHeight = this._api.getHeight();\n            var mediaList = this._mediaList;\n            var mediaDefault = this._mediaDefault;\n            var indices = [];\n            var result = [];\n\n            // No media defined.\n            if (!mediaList.length && !mediaDefault) {\n                return result;\n            }\n\n            // Multi media may be applied, the latter defined media has higher priority.\n            for (var i = 0, len = mediaList.length; i < len; i++) {\n                if (applyMediaQuery(mediaList[i].query, ecWidth, ecHeight)) {\n                    indices.push(i);\n                }\n            }\n\n            // FIXME\n            // 是否mediaDefault应该强制用户设置，否则可能修改不能回归。\n            if (!indices.length && mediaDefault) {\n                indices = [-1];\n            }\n\n            if (indices.length && !indicesEquals(indices, this._currentMediaIndices)) {\n                result = map(indices, function (index) {\n                    return clone(\n                        index === -1 ? mediaDefault.option : mediaList[index].option\n                    );\n                });\n            }\n            // Otherwise return nothing.\n\n            this._currentMediaIndices = indices;\n\n            return result;\n        }\n    };\n\n    function parseRawOption(rawOption, optionPreprocessorFuncs, isNew) {\n        var timelineOptions = [];\n        var mediaList = [];\n        var mediaDefault;\n        var baseOption;\n\n        // Compatible with ec2.\n        var timelineOpt = rawOption.timeline;\n\n        if (rawOption.baseOption) {\n            baseOption = rawOption.baseOption;\n        }\n\n        // For timeline\n        if (timelineOpt || rawOption.options) {\n            baseOption = baseOption || {};\n            timelineOptions = (rawOption.options || []).slice();\n        }\n\n        // For media query\n        if (rawOption.media) {\n            baseOption = baseOption || {};\n            var media = rawOption.media;\n            each(media, function (singleMedia) {\n                if (singleMedia && singleMedia.option) {\n                    if (singleMedia.query) {\n                        mediaList.push(singleMedia);\n                    }\n                    else if (!mediaDefault) {\n                        // Use the first media default.\n                        mediaDefault = singleMedia;\n                    }\n                }\n            });\n        }\n\n        // For normal option\n        if (!baseOption) {\n            baseOption = rawOption;\n        }\n\n        // Set timelineOpt to baseOption in ec3,\n        // which is convenient for merge option.\n        if (!baseOption.timeline) {\n            baseOption.timeline = timelineOpt;\n        }\n\n        // Preprocess.\n        each([baseOption].concat(timelineOptions)\n            .concat(zrUtil.map(mediaList, function (media) {\n                return media.option;\n            })),\n            function (option) {\n                each(optionPreprocessorFuncs, function (preProcess) {\n                    preProcess(option, isNew);\n                });\n            }\n        );\n\n        return {\n            baseOption: baseOption,\n            timelineOptions: timelineOptions,\n            mediaDefault: mediaDefault,\n            mediaList: mediaList\n        };\n    }\n\n    /**\n     * @see <http://www.w3.org/TR/css3-mediaqueries/#media1>\n     * Support: width, height, aspectRatio\n     * Can use max or min as prefix.\n     */\n    function applyMediaQuery(query, ecWidth, ecHeight) {\n        var realMap = {\n            width: ecWidth,\n            height: ecHeight,\n            aspectratio: ecWidth / ecHeight // lowser case for convenientce.\n        };\n\n        var applicatable = true;\n\n        zrUtil.each(query, function (value, attr) {\n            var matched = attr.match(QUERY_REG);\n\n            if (!matched || !matched[1] || !matched[2]) {\n                return;\n            }\n\n            var operator = matched[1];\n            var realAttr = matched[2].toLowerCase();\n\n            if (!compare(realMap[realAttr], value, operator)) {\n                applicatable = false;\n            }\n        });\n\n        return applicatable;\n    }\n\n    function compare(real, expect, operator) {\n        if (operator === 'min') {\n            return real >= expect;\n        }\n        else if (operator === 'max') {\n            return real <= expect;\n        }\n        else { // Equals\n            return real === expect;\n        }\n    }\n\n    function indicesEquals(indices1, indices2) {\n        // indices is always order by asc and has only finite number.\n        return indices1.join(',') === indices2.join(',');\n    }\n\n    /**\n     * Consider case:\n     * `chart.setOption(opt1);`\n     * Then user do some interaction like dataZoom, dataView changing.\n     * `chart.setOption(opt2);`\n     * Then user press 'reset button' in toolbox.\n     *\n     * After doing that all of the interaction effects should be reset, the\n     * chart should be the same as the result of invoke\n     * `chart.setOption(opt1); chart.setOption(opt2);`.\n     *\n     * Although it is not able ensure that\n     * `chart.setOption(opt1); chart.setOption(opt2);` is equivalents to\n     * `chart.setOption(merge(opt1, opt2));` exactly,\n     * this might be the only simple way to implement that feature.\n     *\n     * MEMO: We've considered some other approaches:\n     * 1. Each model handle its self restoration but not uniform treatment.\n     *     (Too complex in logic and error-prone)\n     * 2. Use a shadow ecModel. (Performace expensive)\n     */\n    function mergeOption(oldOption, newOption) {\n        newOption = newOption || {};\n\n        each(newOption, function (newCptOpt, mainType) {\n            if (newCptOpt == null) {\n                return;\n            }\n\n            var oldCptOpt = oldOption[mainType];\n\n            if (!ComponentModel.hasClass(mainType)) {\n                oldOption[mainType] = merge(oldCptOpt, newCptOpt, true);\n            }\n            else {\n                newCptOpt = modelUtil.normalizeToArray(newCptOpt);\n                oldCptOpt = modelUtil.normalizeToArray(oldCptOpt);\n\n                var mapResult = modelUtil.mappingToExists(oldCptOpt, newCptOpt);\n\n                oldOption[mainType] = map(mapResult, function (item) {\n                    return (item.option && item.exist)\n                        ? merge(item.exist, item.option, true)\n                        : (item.exist || item.option);\n                });\n            }\n        });\n    }\n\n    module.exports = OptionManager;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTY4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL21vZGVsL09wdGlvbk1hbmFnZXIuanM/Y2U0YiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEVDaGFydHMgb3B0aW9uIG1hbmFnZXJcbiAqXG4gKiBAbW9kdWxlIHtlY2hhcnRzL21vZGVsL09wdGlvbk1hbmFnZXJ9XG4gKi9cblxuXG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG4gICAgdmFyIG1vZGVsVXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvbW9kZWwnKTtcbiAgICB2YXIgQ29tcG9uZW50TW9kZWwgPSByZXF1aXJlKCcuL0NvbXBvbmVudCcpO1xuICAgIHZhciBlYWNoID0genJVdGlsLmVhY2g7XG4gICAgdmFyIGNsb25lID0genJVdGlsLmNsb25lO1xuICAgIHZhciBtYXAgPSB6clV0aWwubWFwO1xuICAgIHZhciBtZXJnZSA9IHpyVXRpbC5tZXJnZTtcblxuICAgIHZhciBRVUVSWV9SRUcgPSAvXihtaW58bWF4KT8oLispJC87XG5cbiAgICAvKipcbiAgICAgKiBURVJNIEVYUExBTkFUSU9OUzpcbiAgICAgKlxuICAgICAqIFtvcHRpb25dOlxuICAgICAqXG4gICAgICogICAgIEFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIGRlZmluaXRpb25zIG9mIGNvbXBvbmVudHMuIEZvciBleGFtcGxlOlxuICAgICAqICAgICB2YXIgb3B0aW9uID0ge1xuICAgICAqICAgICAgICAgdGl0bGU6IHsuLi59LFxuICAgICAqICAgICAgICAgbGVnZW5kOiB7Li4ufSxcbiAgICAgKiAgICAgICAgIHZpc3VhbE1hcDogey4uLn0sXG4gICAgICogICAgICAgICBzZXJpZXM6IFtcbiAgICAgKiAgICAgICAgICAgICB7ZGF0YTogWy4uLl19LFxuICAgICAqICAgICAgICAgICAgIHtkYXRhOiBbLi4uXX0sXG4gICAgICogICAgICAgICAgICAgLi4uXG4gICAgICogICAgICAgICBdXG4gICAgICogICAgIH07XG4gICAgICpcbiAgICAgKiBbcmF3T3B0aW9uXTpcbiAgICAgKlxuICAgICAqICAgICBBbiBvYmplY3QgaW5wdXQgdG8gZWNoYXJ0cy5zZXRPcHRpb24uICdyYXdPcHRpb24nIG1heSBiZSBhblxuICAgICAqICAgICAnb3B0aW9uJywgb3IgbWF5IGJlIGFuIG9iamVjdCBjb250YWlucyBtdWx0aS1vcHRpb25zLiBGb3IgZXhhbXBsZTpcbiAgICAgKiAgICAgdmFyIG9wdGlvbiA9IHtcbiAgICAgKiAgICAgICAgIGJhc2VPcHRpb246IHtcbiAgICAgKiAgICAgICAgICAgICB0aXRsZTogey4uLn0sXG4gICAgICogICAgICAgICAgICAgbGVnZW5kOiB7Li4ufSxcbiAgICAgKiAgICAgICAgICAgICBzZXJpZXM6IFtcbiAgICAgKiAgICAgICAgICAgICAgICAge2RhdGE6IFsuLi5dfSxcbiAgICAgKiAgICAgICAgICAgICAgICAge2RhdGE6IFsuLi5dfSxcbiAgICAgKiAgICAgICAgICAgICAgICAgLi4uXG4gICAgICogICAgICAgICAgICAgXVxuICAgICAqICAgICAgICAgfSxcbiAgICAgKiAgICAgICAgIHRpbWVsaW5lOiB7Li4ufSxcbiAgICAgKiAgICAgICAgIG9wdGlvbnM6IFtcbiAgICAgKiAgICAgICAgICAgICB7dGl0bGU6IHsuLi59LCBzZXJpZXM6IHtkYXRhOiBbLi4uXX19LFxuICAgICAqICAgICAgICAgICAgIHt0aXRsZTogey4uLn0sIHNlcmllczoge2RhdGE6IFsuLi5dfX0sXG4gICAgICogICAgICAgICAgICAgLi4uXG4gICAgICogICAgICAgICBdLFxuICAgICAqICAgICAgICAgbWVkaWE6IFtcbiAgICAgKiAgICAgICAgICAgICB7XG4gICAgICogICAgICAgICAgICAgICAgIHF1ZXJ5OiB7bWF4V2lkdGg6IDMyMH0sXG4gICAgICogICAgICAgICAgICAgICAgIG9wdGlvbjoge3Nlcmllczoge3g6IDIwfSwgdmlzdWFsTWFwOiB7c2hvdzogZmFsc2V9fVxuICAgICAqICAgICAgICAgICAgIH0sXG4gICAgICogICAgICAgICAgICAge1xuICAgICAqICAgICAgICAgICAgICAgICBxdWVyeToge21pbldpZHRoOiAzMjAsIG1heFdpZHRoOiA3MjB9LFxuICAgICAqICAgICAgICAgICAgICAgICBvcHRpb246IHtzZXJpZXM6IHt4OiA1MDB9LCB2aXN1YWxNYXA6IHtzaG93OiB0cnVlfX1cbiAgICAgKiAgICAgICAgICAgICB9LFxuICAgICAqICAgICAgICAgICAgIHtcbiAgICAgKiAgICAgICAgICAgICAgICAgb3B0aW9uOiB7c2VyaWVzOiB7eDogMTIwMH0sIHZpc3VhbE1hcDoge3Nob3c6IHRydWV9fVxuICAgICAqICAgICAgICAgICAgIH1cbiAgICAgKiAgICAgICAgIF1cbiAgICAgKiAgICAgfTtcbiAgICAgKlxuICAgICAqIEBhbGlhcyBtb2R1bGU6ZWNoYXJ0cy9tb2RlbC9PcHRpb25NYW5hZ2VyXG4gICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9FeHRlbnNpb25BUEl9IGFwaVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE9wdGlvbk1hbmFnZXIoYXBpKSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEB0eXBlIHttb2R1bGU6ZWNoYXJ0cy9FeHRlbnNpb25BUEl9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9hcGkgPSBhcGk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3RpbWVsaW5lT3B0aW9ucyA9IFtdO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPE9iamVjdD59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9tZWRpYUxpc3QgPSBbXTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX21lZGlhRGVmYXVsdDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogLTEsIG1lYW5zIGRlZmF1bHQuXG4gICAgICAgICAqIGVtcHR5IG1lYW5zIG5vIG1lZGlhLlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9jdXJyZW50TWVkaWFJbmRpY2VzID0gW107XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9vcHRpb25CYWNrdXA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9uZXdCYXNlT3B0aW9uO1xuICAgIH1cblxuICAgIC8vIHRpbWVsaW5lLm5vdE1lcmdlIGlzIG5vdCBzdXBwb3J0ZWQgaW4gZWMzLiBGaXJzdGx5IHRoZXJlIGlzIHJlYXJseVxuICAgIC8vIGNhc2UgdGhhdCBub3RNZXJnZSBpcyBuZWVkZWQuIFNlY29uZGx5IHN1cHBvcnRpbmcgJ25vdE1lcmdlJyByZXF1aXJlc1xuICAgIC8vIHJhd09wdGlvbiBjbG9uZWQgYW5kIGJhY2t1cGVkIHdoZW4gdGltZWxpbmUgY2hhbmdlZCwgd2hpY2ggZG9lcyBub1xuICAgIC8vIGdvb2QgdG8gcGVyZm9ybWFuY2UuIFdoYXQncyBtb3JlLCB0aGF0IGJvdGggdGltZWxpbmUgYW5kIHNldE9wdGlvblxuICAgIC8vIG1ldGhvZCBzdXBwbHkgJ25vdE1lcmdlJyBicmluZ3MgY29tcGxleCBhbmQgc29tZSBwcm9ibGVtcy5cbiAgICAvLyBDb25zaWRlciB0aGlzIGNhc2U6XG4gICAgLy8gKHN0ZXAxKSBjaGFydC5zZXRPcHRpb24oe3RpbWVsaW5lOiB7bm90TWVyZ2U6IGZhbHNlfSwgLi4ufSwgZmFsc2UpO1xuICAgIC8vIChzdGVwMikgY2hhcnQuc2V0T3B0aW9uKHt0aW1lbGluZToge25vdE1lcmdlOiB0cnVlfSwgLi4ufSwgZmFsc2UpO1xuXG4gICAgT3B0aW9uTWFuYWdlci5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IE9wdGlvbk1hbmFnZXIsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwdWJsaWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHJhd09wdGlvbiBSYXcgb3B0aW9uLlxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL0dsb2JhbH0gZWNNb2RlbFxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5LjxGdW5jdGlvbj59IG9wdGlvblByZXByb2Nlc3NvckZ1bmNzXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gSW5pdCBvcHRpb25cbiAgICAgICAgICovXG4gICAgICAgIHNldE9wdGlvbjogZnVuY3Rpb24gKHJhd09wdGlvbiwgb3B0aW9uUHJlcHJvY2Vzc29yRnVuY3MpIHtcbiAgICAgICAgICAgIHJhd09wdGlvbiA9IGNsb25lKHJhd09wdGlvbiwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIC8vIEZJWE1FXG4gICAgICAgICAgICAvLyDlpoLmnpwgdGltZWxpbmUgb3B0aW9ucyDmiJbogIUgbWVkaWEg5Lit6K6+572u5LqG5p+Q5Liq5bGe5oCn77yM6ICMYmFzZU9wdGlvbuS4reayoeacieiuvue9ru+8jOWImei/m+ihjOitpuWRiuOAglxuXG4gICAgICAgICAgICB2YXIgb2xkT3B0aW9uQmFja3VwID0gdGhpcy5fb3B0aW9uQmFja3VwO1xuICAgICAgICAgICAgdmFyIG5ld1BhcnNlZE9wdGlvbiA9IHBhcnNlUmF3T3B0aW9uLmNhbGwoXG4gICAgICAgICAgICAgICAgdGhpcywgcmF3T3B0aW9uLCBvcHRpb25QcmVwcm9jZXNzb3JGdW5jcywgIW9sZE9wdGlvbkJhY2t1cFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRoaXMuX25ld0Jhc2VPcHRpb24gPSBuZXdQYXJzZWRPcHRpb24uYmFzZU9wdGlvbjtcblxuICAgICAgICAgICAgLy8gRm9yIHNldE9wdGlvbiBhdCBzZWNvbmQgdGltZSAodXNpbmcgbWVyZ2UgbW9kZSk7XG4gICAgICAgICAgICBpZiAob2xkT3B0aW9uQmFja3VwKSB7XG4gICAgICAgICAgICAgICAgLy8gT25seSBiYXNlT3B0aW9uIGNhbiBiZSBtZXJnZWQuXG4gICAgICAgICAgICAgICAgbWVyZ2VPcHRpb24ob2xkT3B0aW9uQmFja3VwLmJhc2VPcHRpb24sIG5ld1BhcnNlZE9wdGlvbi5iYXNlT3B0aW9uKTtcblxuICAgICAgICAgICAgICAgIC8vIEZvciBzaW1wbGljaXR5LCB0aW1lbGluZSBvcHRpb25zIGFuZCBtZWRpYSBvcHRpb25zIGRvIG5vdCBzdXBwb3J0IG1lcmdlLFxuICAgICAgICAgICAgICAgIC8vIHRoYXQgaXMsIGlmIHlvdSBgc2V0T3B0aW9uYCB0d2ljZSBhbmQgYm90aCBoYXMgdGltZWxpbmUgb3B0aW9ucywgdGhlIGxhdHRlclxuICAgICAgICAgICAgICAgIC8vIHRpbWVsaW5lIG9waXRvbnMgd2lsbCBub3QgYmUgbWVyZ2VkIHRvIHRoZSBmb3JtZXJzLCBidXQganVzdCBzdWJzdGl0dWRlIHRoZW0uXG4gICAgICAgICAgICAgICAgaWYgKG5ld1BhcnNlZE9wdGlvbi50aW1lbGluZU9wdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIG9sZE9wdGlvbkJhY2t1cC50aW1lbGluZU9wdGlvbnMgPSBuZXdQYXJzZWRPcHRpb24udGltZWxpbmVPcHRpb25zO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobmV3UGFyc2VkT3B0aW9uLm1lZGlhTGlzdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgb2xkT3B0aW9uQmFja3VwLm1lZGlhTGlzdCA9IG5ld1BhcnNlZE9wdGlvbi5tZWRpYUxpc3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChuZXdQYXJzZWRPcHRpb24ubWVkaWFEZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIG9sZE9wdGlvbkJhY2t1cC5tZWRpYURlZmF1bHQgPSBuZXdQYXJzZWRPcHRpb24ubWVkaWFEZWZhdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX29wdGlvbkJhY2t1cCA9IG5ld1BhcnNlZE9wdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBpc1JlY3JlYXRlXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIG1vdW50T3B0aW9uOiBmdW5jdGlvbiAoaXNSZWNyZWF0ZSkge1xuICAgICAgICAgICAgdmFyIG9wdGlvbkJhY2t1cCA9IHRoaXMuX29wdGlvbkJhY2t1cDtcblxuICAgICAgICAgICAgLy8gVE9ET1xuICAgICAgICAgICAgLy8g5aaC5p6c5rKh5pyJcmVzZXTlip/og73liJnkuI1jbG9uZeOAglxuXG4gICAgICAgICAgICB0aGlzLl90aW1lbGluZU9wdGlvbnMgPSBtYXAob3B0aW9uQmFja3VwLnRpbWVsaW5lT3B0aW9ucywgY2xvbmUpO1xuICAgICAgICAgICAgdGhpcy5fbWVkaWFMaXN0ID0gbWFwKG9wdGlvbkJhY2t1cC5tZWRpYUxpc3QsIGNsb25lKTtcbiAgICAgICAgICAgIHRoaXMuX21lZGlhRGVmYXVsdCA9IGNsb25lKG9wdGlvbkJhY2t1cC5tZWRpYURlZmF1bHQpO1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudE1lZGlhSW5kaWNlcyA9IFtdO1xuXG4gICAgICAgICAgICByZXR1cm4gY2xvbmUoaXNSZWNyZWF0ZVxuICAgICAgICAgICAgICAgIC8vIHRoaXMuX29wdGlvbkJhY2t1cC5iYXNlT3B0aW9uLCB3aGljaCBpcyBjcmVhdGVkIGF0IHRoZSBmaXJzdCBgc2V0T3B0aW9uYFxuICAgICAgICAgICAgICAgIC8vIGNhbGxlZCwgYW5kIGlzIG1lcmdlZCBpbnRvIGV2ZXJ5IG5ldyBvcHRpb24gYnkgaW5uZXIgbWV0aG9kIGBtZXJnZU9wdGlvbmBcbiAgICAgICAgICAgICAgICAvLyBlYWNoIHRpbWUgYHNldE9wdGlvbmAgY2FsbGVkLCBjYW4gYmUgb25seSB1c2VkIGluIGBpc1JlY3JlYXRlYCwgYmVjYXVzZVxuICAgICAgICAgICAgICAgIC8vIGl0cyByZWxpYWJpbGl0eSBpcyB1bmRlciBzdXNwaWNpb24uIEluIG90aGVyIGNhc2VzIG9wdGlvbiBtZXJnZSBpc1xuICAgICAgICAgICAgICAgIC8vIHBlcmZvcm1lZCBieSBgbW9kZWwubWVyZ2VPcHRpb25gLlxuICAgICAgICAgICAgICAgID8gb3B0aW9uQmFja3VwLmJhc2VPcHRpb24gOiB0aGlzLl9uZXdCYXNlT3B0aW9uXG4gICAgICAgICAgICApO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL0dsb2JhbH0gZWNNb2RlbFxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRUaW1lbGluZU9wdGlvbjogZnVuY3Rpb24gKGVjTW9kZWwpIHtcbiAgICAgICAgICAgIHZhciBvcHRpb247XG4gICAgICAgICAgICB2YXIgdGltZWxpbmVPcHRpb25zID0gdGhpcy5fdGltZWxpbmVPcHRpb25zO1xuXG4gICAgICAgICAgICBpZiAodGltZWxpbmVPcHRpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vIGdldFRpbWVsaW5lT3B0aW9uIGNhbiBvbmx5IGJlIGNhbGxlZCBhZnRlciBlY01vZGVsIGluaXRlZCxcbiAgICAgICAgICAgICAgICAvLyBzbyB3ZSBjYW4gZ2V0IGN1cnJlbnRJbmRleCBmcm9tIHRpbWVsaW5lTW9kZWwuXG4gICAgICAgICAgICAgICAgdmFyIHRpbWVsaW5lTW9kZWwgPSBlY01vZGVsLmdldENvbXBvbmVudCgndGltZWxpbmUnKTtcbiAgICAgICAgICAgICAgICBpZiAodGltZWxpbmVNb2RlbCkge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb24gPSBjbG9uZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lT3B0aW9uc1t0aW1lbGluZU1vZGVsLmdldEN1cnJlbnRJbmRleCgpXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBvcHRpb247XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvR2xvYmFsfSBlY01vZGVsXG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5LjxPYmplY3Q+fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0TWVkaWFPcHRpb246IGZ1bmN0aW9uIChlY01vZGVsKSB7XG4gICAgICAgICAgICB2YXIgZWNXaWR0aCA9IHRoaXMuX2FwaS5nZXRXaWR0aCgpO1xuICAgICAgICAgICAgdmFyIGVjSGVpZ2h0ID0gdGhpcy5fYXBpLmdldEhlaWdodCgpO1xuICAgICAgICAgICAgdmFyIG1lZGlhTGlzdCA9IHRoaXMuX21lZGlhTGlzdDtcbiAgICAgICAgICAgIHZhciBtZWRpYURlZmF1bHQgPSB0aGlzLl9tZWRpYURlZmF1bHQ7XG4gICAgICAgICAgICB2YXIgaW5kaWNlcyA9IFtdO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICAgICAgICAvLyBObyBtZWRpYSBkZWZpbmVkLlxuICAgICAgICAgICAgaWYgKCFtZWRpYUxpc3QubGVuZ3RoICYmICFtZWRpYURlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBNdWx0aSBtZWRpYSBtYXkgYmUgYXBwbGllZCwgdGhlIGxhdHRlciBkZWZpbmVkIG1lZGlhIGhhcyBoaWdoZXIgcHJpb3JpdHkuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbWVkaWFMaXN0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFwcGx5TWVkaWFRdWVyeShtZWRpYUxpc3RbaV0ucXVlcnksIGVjV2lkdGgsIGVjSGVpZ2h0KSkge1xuICAgICAgICAgICAgICAgICAgICBpbmRpY2VzLnB1c2goaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGSVhNRVxuICAgICAgICAgICAgLy8g5piv5ZCmbWVkaWFEZWZhdWx05bqU6K+l5by65Yi255So5oi36K6+572u77yM5ZCm5YiZ5Y+v6IO95L+u5pS55LiN6IO95Zue5b2S44CCXG4gICAgICAgICAgICBpZiAoIWluZGljZXMubGVuZ3RoICYmIG1lZGlhRGVmYXVsdCkge1xuICAgICAgICAgICAgICAgIGluZGljZXMgPSBbLTFdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaW5kaWNlcy5sZW5ndGggJiYgIWluZGljZXNFcXVhbHMoaW5kaWNlcywgdGhpcy5fY3VycmVudE1lZGlhSW5kaWNlcykpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBtYXAoaW5kaWNlcywgZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjbG9uZShcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID09PSAtMSA/IG1lZGlhRGVmYXVsdC5vcHRpb24gOiBtZWRpYUxpc3RbaW5kZXhdLm9wdGlvblxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIHJldHVybiBub3RoaW5nLlxuXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50TWVkaWFJbmRpY2VzID0gaW5kaWNlcztcblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBwYXJzZVJhd09wdGlvbihyYXdPcHRpb24sIG9wdGlvblByZXByb2Nlc3NvckZ1bmNzLCBpc05ldykge1xuICAgICAgICB2YXIgdGltZWxpbmVPcHRpb25zID0gW107XG4gICAgICAgIHZhciBtZWRpYUxpc3QgPSBbXTtcbiAgICAgICAgdmFyIG1lZGlhRGVmYXVsdDtcbiAgICAgICAgdmFyIGJhc2VPcHRpb247XG5cbiAgICAgICAgLy8gQ29tcGF0aWJsZSB3aXRoIGVjMi5cbiAgICAgICAgdmFyIHRpbWVsaW5lT3B0ID0gcmF3T3B0aW9uLnRpbWVsaW5lO1xuXG4gICAgICAgIGlmIChyYXdPcHRpb24uYmFzZU9wdGlvbikge1xuICAgICAgICAgICAgYmFzZU9wdGlvbiA9IHJhd09wdGlvbi5iYXNlT3B0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRm9yIHRpbWVsaW5lXG4gICAgICAgIGlmICh0aW1lbGluZU9wdCB8fCByYXdPcHRpb24ub3B0aW9ucykge1xuICAgICAgICAgICAgYmFzZU9wdGlvbiA9IGJhc2VPcHRpb24gfHwge307XG4gICAgICAgICAgICB0aW1lbGluZU9wdGlvbnMgPSAocmF3T3B0aW9uLm9wdGlvbnMgfHwgW10pLnNsaWNlKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGb3IgbWVkaWEgcXVlcnlcbiAgICAgICAgaWYgKHJhd09wdGlvbi5tZWRpYSkge1xuICAgICAgICAgICAgYmFzZU9wdGlvbiA9IGJhc2VPcHRpb24gfHwge307XG4gICAgICAgICAgICB2YXIgbWVkaWEgPSByYXdPcHRpb24ubWVkaWE7XG4gICAgICAgICAgICBlYWNoKG1lZGlhLCBmdW5jdGlvbiAoc2luZ2xlTWVkaWEpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2luZ2xlTWVkaWEgJiYgc2luZ2xlTWVkaWEub3B0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaW5nbGVNZWRpYS5xdWVyeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVkaWFMaXN0LnB1c2goc2luZ2xlTWVkaWEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFtZWRpYURlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZSB0aGUgZmlyc3QgbWVkaWEgZGVmYXVsdC5cbiAgICAgICAgICAgICAgICAgICAgICAgIG1lZGlhRGVmYXVsdCA9IHNpbmdsZU1lZGlhO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGb3Igbm9ybWFsIG9wdGlvblxuICAgICAgICBpZiAoIWJhc2VPcHRpb24pIHtcbiAgICAgICAgICAgIGJhc2VPcHRpb24gPSByYXdPcHRpb247XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZXQgdGltZWxpbmVPcHQgdG8gYmFzZU9wdGlvbiBpbiBlYzMsXG4gICAgICAgIC8vIHdoaWNoIGlzIGNvbnZlbmllbnQgZm9yIG1lcmdlIG9wdGlvbi5cbiAgICAgICAgaWYgKCFiYXNlT3B0aW9uLnRpbWVsaW5lKSB7XG4gICAgICAgICAgICBiYXNlT3B0aW9uLnRpbWVsaW5lID0gdGltZWxpbmVPcHQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQcmVwcm9jZXNzLlxuICAgICAgICBlYWNoKFtiYXNlT3B0aW9uXS5jb25jYXQodGltZWxpbmVPcHRpb25zKVxuICAgICAgICAgICAgLmNvbmNhdCh6clV0aWwubWFwKG1lZGlhTGlzdCwgZnVuY3Rpb24gKG1lZGlhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lZGlhLm9wdGlvbjtcbiAgICAgICAgICAgIH0pKSxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICAgICAgICAgICAgICBlYWNoKG9wdGlvblByZXByb2Nlc3NvckZ1bmNzLCBmdW5jdGlvbiAocHJlUHJvY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICBwcmVQcm9jZXNzKG9wdGlvbiwgaXNOZXcpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBiYXNlT3B0aW9uOiBiYXNlT3B0aW9uLFxuICAgICAgICAgICAgdGltZWxpbmVPcHRpb25zOiB0aW1lbGluZU9wdGlvbnMsXG4gICAgICAgICAgICBtZWRpYURlZmF1bHQ6IG1lZGlhRGVmYXVsdCxcbiAgICAgICAgICAgIG1lZGlhTGlzdDogbWVkaWFMaXN0XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHNlZSA8aHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1tZWRpYXF1ZXJpZXMvI21lZGlhMT5cbiAgICAgKiBTdXBwb3J0OiB3aWR0aCwgaGVpZ2h0LCBhc3BlY3RSYXRpb1xuICAgICAqIENhbiB1c2UgbWF4IG9yIG1pbiBhcyBwcmVmaXguXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXBwbHlNZWRpYVF1ZXJ5KHF1ZXJ5LCBlY1dpZHRoLCBlY0hlaWdodCkge1xuICAgICAgICB2YXIgcmVhbE1hcCA9IHtcbiAgICAgICAgICAgIHdpZHRoOiBlY1dpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBlY0hlaWdodCxcbiAgICAgICAgICAgIGFzcGVjdHJhdGlvOiBlY1dpZHRoIC8gZWNIZWlnaHQgLy8gbG93c2VyIGNhc2UgZm9yIGNvbnZlbmllbnRjZS5cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgYXBwbGljYXRhYmxlID0gdHJ1ZTtcblxuICAgICAgICB6clV0aWwuZWFjaChxdWVyeSwgZnVuY3Rpb24gKHZhbHVlLCBhdHRyKSB7XG4gICAgICAgICAgICB2YXIgbWF0Y2hlZCA9IGF0dHIubWF0Y2goUVVFUllfUkVHKTtcblxuICAgICAgICAgICAgaWYgKCFtYXRjaGVkIHx8ICFtYXRjaGVkWzFdIHx8ICFtYXRjaGVkWzJdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgb3BlcmF0b3IgPSBtYXRjaGVkWzFdO1xuICAgICAgICAgICAgdmFyIHJlYWxBdHRyID0gbWF0Y2hlZFsyXS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgICAgICBpZiAoIWNvbXBhcmUocmVhbE1hcFtyZWFsQXR0cl0sIHZhbHVlLCBvcGVyYXRvcikpIHtcbiAgICAgICAgICAgICAgICBhcHBsaWNhdGFibGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGFwcGxpY2F0YWJsZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21wYXJlKHJlYWwsIGV4cGVjdCwgb3BlcmF0b3IpIHtcbiAgICAgICAgaWYgKG9wZXJhdG9yID09PSAnbWluJykge1xuICAgICAgICAgICAgcmV0dXJuIHJlYWwgPj0gZXhwZWN0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wZXJhdG9yID09PSAnbWF4Jykge1xuICAgICAgICAgICAgcmV0dXJuIHJlYWwgPD0gZXhwZWN0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAvLyBFcXVhbHNcbiAgICAgICAgICAgIHJldHVybiByZWFsID09PSBleHBlY3Q7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbmRpY2VzRXF1YWxzKGluZGljZXMxLCBpbmRpY2VzMikge1xuICAgICAgICAvLyBpbmRpY2VzIGlzIGFsd2F5cyBvcmRlciBieSBhc2MgYW5kIGhhcyBvbmx5IGZpbml0ZSBudW1iZXIuXG4gICAgICAgIHJldHVybiBpbmRpY2VzMS5qb2luKCcsJykgPT09IGluZGljZXMyLmpvaW4oJywnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb25zaWRlciBjYXNlOlxuICAgICAqIGBjaGFydC5zZXRPcHRpb24ob3B0MSk7YFxuICAgICAqIFRoZW4gdXNlciBkbyBzb21lIGludGVyYWN0aW9uIGxpa2UgZGF0YVpvb20sIGRhdGFWaWV3IGNoYW5naW5nLlxuICAgICAqIGBjaGFydC5zZXRPcHRpb24ob3B0Mik7YFxuICAgICAqIFRoZW4gdXNlciBwcmVzcyAncmVzZXQgYnV0dG9uJyBpbiB0b29sYm94LlxuICAgICAqXG4gICAgICogQWZ0ZXIgZG9pbmcgdGhhdCBhbGwgb2YgdGhlIGludGVyYWN0aW9uIGVmZmVjdHMgc2hvdWxkIGJlIHJlc2V0LCB0aGVcbiAgICAgKiBjaGFydCBzaG91bGQgYmUgdGhlIHNhbWUgYXMgdGhlIHJlc3VsdCBvZiBpbnZva2VcbiAgICAgKiBgY2hhcnQuc2V0T3B0aW9uKG9wdDEpOyBjaGFydC5zZXRPcHRpb24ob3B0Mik7YC5cbiAgICAgKlxuICAgICAqIEFsdGhvdWdoIGl0IGlzIG5vdCBhYmxlIGVuc3VyZSB0aGF0XG4gICAgICogYGNoYXJ0LnNldE9wdGlvbihvcHQxKTsgY2hhcnQuc2V0T3B0aW9uKG9wdDIpO2AgaXMgZXF1aXZhbGVudHMgdG9cbiAgICAgKiBgY2hhcnQuc2V0T3B0aW9uKG1lcmdlKG9wdDEsIG9wdDIpKTtgIGV4YWN0bHksXG4gICAgICogdGhpcyBtaWdodCBiZSB0aGUgb25seSBzaW1wbGUgd2F5IHRvIGltcGxlbWVudCB0aGF0IGZlYXR1cmUuXG4gICAgICpcbiAgICAgKiBNRU1POiBXZSd2ZSBjb25zaWRlcmVkIHNvbWUgb3RoZXIgYXBwcm9hY2hlczpcbiAgICAgKiAxLiBFYWNoIG1vZGVsIGhhbmRsZSBpdHMgc2VsZiByZXN0b3JhdGlvbiBidXQgbm90IHVuaWZvcm0gdHJlYXRtZW50LlxuICAgICAqICAgICAoVG9vIGNvbXBsZXggaW4gbG9naWMgYW5kIGVycm9yLXByb25lKVxuICAgICAqIDIuIFVzZSBhIHNoYWRvdyBlY01vZGVsLiAoUGVyZm9ybWFjZSBleHBlbnNpdmUpXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWVyZ2VPcHRpb24ob2xkT3B0aW9uLCBuZXdPcHRpb24pIHtcbiAgICAgICAgbmV3T3B0aW9uID0gbmV3T3B0aW9uIHx8IHt9O1xuXG4gICAgICAgIGVhY2gobmV3T3B0aW9uLCBmdW5jdGlvbiAobmV3Q3B0T3B0LCBtYWluVHlwZSkge1xuICAgICAgICAgICAgaWYgKG5ld0NwdE9wdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgb2xkQ3B0T3B0ID0gb2xkT3B0aW9uW21haW5UeXBlXTtcblxuICAgICAgICAgICAgaWYgKCFDb21wb25lbnRNb2RlbC5oYXNDbGFzcyhtYWluVHlwZSkpIHtcbiAgICAgICAgICAgICAgICBvbGRPcHRpb25bbWFpblR5cGVdID0gbWVyZ2Uob2xkQ3B0T3B0LCBuZXdDcHRPcHQsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3Q3B0T3B0ID0gbW9kZWxVdGlsLm5vcm1hbGl6ZVRvQXJyYXkobmV3Q3B0T3B0KTtcbiAgICAgICAgICAgICAgICBvbGRDcHRPcHQgPSBtb2RlbFV0aWwubm9ybWFsaXplVG9BcnJheShvbGRDcHRPcHQpO1xuXG4gICAgICAgICAgICAgICAgdmFyIG1hcFJlc3VsdCA9IG1vZGVsVXRpbC5tYXBwaW5nVG9FeGlzdHMob2xkQ3B0T3B0LCBuZXdDcHRPcHQpO1xuXG4gICAgICAgICAgICAgICAgb2xkT3B0aW9uW21haW5UeXBlXSA9IG1hcChtYXBSZXN1bHQsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoaXRlbS5vcHRpb24gJiYgaXRlbS5leGlzdClcbiAgICAgICAgICAgICAgICAgICAgICAgID8gbWVyZ2UoaXRlbS5leGlzdCwgaXRlbS5vcHRpb24sIHRydWUpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IChpdGVtLmV4aXN0IHx8IGl0ZW0ub3B0aW9uKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBPcHRpb25NYW5hZ2VyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvbW9kZWwvT3B0aW9uTWFuYWdlci5qc1xuLy8gbW9kdWxlIGlkID0gMTY4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 169 */
/* unknown exports provided */
/* all exports used */
/*!************************************!*\
  !*** ./lib/model/globalDefault.js ***!
  \************************************/
/***/ (function(module, exports) {

eval("\n    var platform = '';\n    // Navigator not exists in node\n    if (typeof navigator !== 'undefined') {\n        platform = navigator.platform || '';\n    }\n    module.exports = {\n        // 全图默认背景\n        // backgroundColor: 'rgba(0,0,0,0)',\n\n        // https://dribbble.com/shots/1065960-Infographic-Pie-chart-visualization\n        // color: ['#5793f3', '#d14a61', '#fd9c35', '#675bba', '#fec42c', '#dd4444', '#d4df5a', '#cd4870'],\n        // 浅色\n        // color: ['#bcd3bb', '#e88f70', '#edc1a5', '#9dc5c8', '#e1e8c8', '#7b7c68', '#e5b5b5', '#f0b489', '#928ea8', '#bda29a'],\n        // color: ['#cc5664', '#9bd6ec', '#ea946e', '#8acaaa', '#f1ec64', '#ee8686', '#a48dc1', '#5da6bc', '#b9dcae'],\n        // 深色\n        color: ['#c23531','#2f4554', '#61a0a8', '#d48265', '#91c7ae','#749f83',  '#ca8622', '#bda29a','#6e7074', '#546570', '#c4ccd3'],\n\n        // 默认需要 Grid 配置项\n        // grid: {},\n        // 主题，主题\n        textStyle: {\n            // color: '#000',\n            // decoration: 'none',\n            // PENDING\n            fontFamily: platform.match(/^Win/) ? 'Microsoft YaHei' : 'sans-serif',\n            // fontFamily: 'Arial, Verdana, sans-serif',\n            fontSize: 12,\n            fontStyle: 'normal',\n            fontWeight: 'normal'\n        },\n\n        // http://blogs.adobe.com/webplatform/2014/02/24/using-blend-modes-in-html-canvas/\n        // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation\n        // Default is source-over\n        blendMode: null,\n\n        animation: 'auto',\n        animationDuration: 1000,\n        animationDurationUpdate: 300,\n        animationEasing: 'exponentialOut',\n        animationEasingUpdate: 'cubicOut',\n\n        animationThreshold: 2000,\n        // Configuration for progressive/incremental rendering\n        progressiveThreshold: 3000,\n        progressive: 400,\n\n        // Threshold of if use single hover layer to optimize.\n        // It is recommended that `hoverLayerThreshold` is equivalent to or less than\n        // `progressiveThreshold`, otherwise hover will cause restart of progressive,\n        // which is unexpected.\n        // see example <echarts/test/heatmap-large.html>.\n        hoverLayerThreshold: 3000,\n\n        // See: module:echarts/scale/Time\n        useUTC: false\n    };\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTY5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL21vZGVsL2dsb2JhbERlZmF1bHQuanM/NTA3ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcbiAgICB2YXIgcGxhdGZvcm0gPSAnJztcbiAgICAvLyBOYXZpZ2F0b3Igbm90IGV4aXN0cyBpbiBub2RlXG4gICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHBsYXRmb3JtID0gbmF2aWdhdG9yLnBsYXRmb3JtIHx8ICcnO1xuICAgIH1cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgLy8g5YWo5Zu+6buY6K6k6IOM5pmvXG4gICAgICAgIC8vIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMCwwLDAsMCknLFxuXG4gICAgICAgIC8vIGh0dHBzOi8vZHJpYmJibGUuY29tL3Nob3RzLzEwNjU5NjAtSW5mb2dyYXBoaWMtUGllLWNoYXJ0LXZpc3VhbGl6YXRpb25cbiAgICAgICAgLy8gY29sb3I6IFsnIzU3OTNmMycsICcjZDE0YTYxJywgJyNmZDljMzUnLCAnIzY3NWJiYScsICcjZmVjNDJjJywgJyNkZDQ0NDQnLCAnI2Q0ZGY1YScsICcjY2Q0ODcwJ10sXG4gICAgICAgIC8vIOa1heiJslxuICAgICAgICAvLyBjb2xvcjogWycjYmNkM2JiJywgJyNlODhmNzAnLCAnI2VkYzFhNScsICcjOWRjNWM4JywgJyNlMWU4YzgnLCAnIzdiN2M2OCcsICcjZTViNWI1JywgJyNmMGI0ODknLCAnIzkyOGVhOCcsICcjYmRhMjlhJ10sXG4gICAgICAgIC8vIGNvbG9yOiBbJyNjYzU2NjQnLCAnIzliZDZlYycsICcjZWE5NDZlJywgJyM4YWNhYWEnLCAnI2YxZWM2NCcsICcjZWU4Njg2JywgJyNhNDhkYzEnLCAnIzVkYTZiYycsICcjYjlkY2FlJ10sXG4gICAgICAgIC8vIOa3seiJslxuICAgICAgICBjb2xvcjogWycjYzIzNTMxJywnIzJmNDU1NCcsICcjNjFhMGE4JywgJyNkNDgyNjUnLCAnIzkxYzdhZScsJyM3NDlmODMnLCAgJyNjYTg2MjInLCAnI2JkYTI5YScsJyM2ZTcwNzQnLCAnIzU0NjU3MCcsICcjYzRjY2QzJ10sXG5cbiAgICAgICAgLy8g6buY6K6k6ZyA6KaBIEdyaWQg6YWN572u6aG5XG4gICAgICAgIC8vIGdyaWQ6IHt9LFxuICAgICAgICAvLyDkuLvpopjvvIzkuLvpophcbiAgICAgICAgdGV4dFN0eWxlOiB7XG4gICAgICAgICAgICAvLyBjb2xvcjogJyMwMDAnLFxuICAgICAgICAgICAgLy8gZGVjb3JhdGlvbjogJ25vbmUnLFxuICAgICAgICAgICAgLy8gUEVORElOR1xuICAgICAgICAgICAgZm9udEZhbWlseTogcGxhdGZvcm0ubWF0Y2goL15XaW4vKSA/ICdNaWNyb3NvZnQgWWFIZWknIDogJ3NhbnMtc2VyaWYnLFxuICAgICAgICAgICAgLy8gZm9udEZhbWlseTogJ0FyaWFsLCBWZXJkYW5hLCBzYW5zLXNlcmlmJyxcbiAgICAgICAgICAgIGZvbnRTaXplOiAxMixcbiAgICAgICAgICAgIGZvbnRTdHlsZTogJ25vcm1hbCcsXG4gICAgICAgICAgICBmb250V2VpZ2h0OiAnbm9ybWFsJ1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIGh0dHA6Ly9ibG9ncy5hZG9iZS5jb20vd2VicGxhdGZvcm0vMjAxNC8wMi8yNC91c2luZy1ibGVuZC1tb2Rlcy1pbi1odG1sLWNhbnZhcy9cbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC9nbG9iYWxDb21wb3NpdGVPcGVyYXRpb25cbiAgICAgICAgLy8gRGVmYXVsdCBpcyBzb3VyY2Utb3ZlclxuICAgICAgICBibGVuZE1vZGU6IG51bGwsXG5cbiAgICAgICAgYW5pbWF0aW9uOiAnYXV0bycsXG4gICAgICAgIGFuaW1hdGlvbkR1cmF0aW9uOiAxMDAwLFxuICAgICAgICBhbmltYXRpb25EdXJhdGlvblVwZGF0ZTogMzAwLFxuICAgICAgICBhbmltYXRpb25FYXNpbmc6ICdleHBvbmVudGlhbE91dCcsXG4gICAgICAgIGFuaW1hdGlvbkVhc2luZ1VwZGF0ZTogJ2N1YmljT3V0JyxcblxuICAgICAgICBhbmltYXRpb25UaHJlc2hvbGQ6IDIwMDAsXG4gICAgICAgIC8vIENvbmZpZ3VyYXRpb24gZm9yIHByb2dyZXNzaXZlL2luY3JlbWVudGFsIHJlbmRlcmluZ1xuICAgICAgICBwcm9ncmVzc2l2ZVRocmVzaG9sZDogMzAwMCxcbiAgICAgICAgcHJvZ3Jlc3NpdmU6IDQwMCxcblxuICAgICAgICAvLyBUaHJlc2hvbGQgb2YgaWYgdXNlIHNpbmdsZSBob3ZlciBsYXllciB0byBvcHRpbWl6ZS5cbiAgICAgICAgLy8gSXQgaXMgcmVjb21tZW5kZWQgdGhhdCBgaG92ZXJMYXllclRocmVzaG9sZGAgaXMgZXF1aXZhbGVudCB0byBvciBsZXNzIHRoYW5cbiAgICAgICAgLy8gYHByb2dyZXNzaXZlVGhyZXNob2xkYCwgb3RoZXJ3aXNlIGhvdmVyIHdpbGwgY2F1c2UgcmVzdGFydCBvZiBwcm9ncmVzc2l2ZSxcbiAgICAgICAgLy8gd2hpY2ggaXMgdW5leHBlY3RlZC5cbiAgICAgICAgLy8gc2VlIGV4YW1wbGUgPGVjaGFydHMvdGVzdC9oZWF0bWFwLWxhcmdlLmh0bWw+LlxuICAgICAgICBob3ZlckxheWVyVGhyZXNob2xkOiAzMDAwLFxuXG4gICAgICAgIC8vIFNlZTogbW9kdWxlOmVjaGFydHMvc2NhbGUvVGltZVxuICAgICAgICB1c2VVVEM6IGZhbHNlXG4gICAgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL21vZGVsL2dsb2JhbERlZmF1bHQuanNcbi8vIG1vZHVsZSBpZCA9IDE2OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 170 */
/* unknown exports provided */
/* all exports used */
/*!**************************************!*\
  !*** ./lib/model/mixin/areaStyle.js ***!
  \**************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\n    module.exports = {\n        getAreaStyle: __webpack_require__(/*! ./makeStyleMapper */ 30)(\n            [\n                ['fill', 'color'],\n                ['shadowBlur'],\n                ['shadowOffsetX'],\n                ['shadowOffsetY'],\n                ['opacity'],\n                ['shadowColor']\n            ]\n        )\n    };\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTcwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL21vZGVsL21peGluL2FyZWFTdHlsZS5qcz8yZTZkIl0sInNvdXJjZXNDb250ZW50IjpbIlxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBnZXRBcmVhU3R5bGU6IHJlcXVpcmUoJy4vbWFrZVN0eWxlTWFwcGVyJykoXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgWydmaWxsJywgJ2NvbG9yJ10sXG4gICAgICAgICAgICAgICAgWydzaGFkb3dCbHVyJ10sXG4gICAgICAgICAgICAgICAgWydzaGFkb3dPZmZzZXRYJ10sXG4gICAgICAgICAgICAgICAgWydzaGFkb3dPZmZzZXRZJ10sXG4gICAgICAgICAgICAgICAgWydvcGFjaXR5J10sXG4gICAgICAgICAgICAgICAgWydzaGFkb3dDb2xvciddXG4gICAgICAgICAgICBdXG4gICAgICAgIClcbiAgICB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvbW9kZWwvbWl4aW4vYXJlYVN0eWxlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 171 */
/* unknown exports provided */
/* all exports used */
/*!**************************************!*\
  !*** ./lib/model/mixin/boxLayout.js ***!
  \**************************************/
/***/ (function(module, exports) {

eval("\n\n    module.exports = {\n        getBoxLayoutParams: function () {\n            return {\n                left: this.get('left'),\n                top: this.get('top'),\n                right: this.get('right'),\n                bottom: this.get('bottom'),\n                width: this.get('width'),\n                height: this.get('height')\n            };\n        }\n    };\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTcxLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL21vZGVsL21peGluL2JveExheW91dC5qcz8zNDc4Il0sInNvdXJjZXNDb250ZW50IjpbIlxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIGdldEJveExheW91dFBhcmFtczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBsZWZ0OiB0aGlzLmdldCgnbGVmdCcpLFxuICAgICAgICAgICAgICAgIHRvcDogdGhpcy5nZXQoJ3RvcCcpLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiB0aGlzLmdldCgncmlnaHQnKSxcbiAgICAgICAgICAgICAgICBib3R0b206IHRoaXMuZ2V0KCdib3R0b20nKSxcbiAgICAgICAgICAgICAgICB3aWR0aDogdGhpcy5nZXQoJ3dpZHRoJyksXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmdldCgnaGVpZ2h0JylcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvbW9kZWwvbWl4aW4vYm94TGF5b3V0LmpzXG4vLyBtb2R1bGUgaWQgPSAxNzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 172 */
/* unknown exports provided */
/* all exports used */
/*!**************************************!*\
  !*** ./lib/model/mixin/itemStyle.js ***!
  \**************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\n    var getItemStyle = __webpack_require__(/*! ./makeStyleMapper */ 30)(\n        [\n            ['fill', 'color'],\n            ['stroke', 'borderColor'],\n            ['lineWidth', 'borderWidth'],\n            ['opacity'],\n            ['shadowBlur'],\n            ['shadowOffsetX'],\n            ['shadowOffsetY'],\n            ['shadowColor'],\n            ['textPosition'],\n            ['textAlign']\n        ]\n    );\n    module.exports = {\n        getItemStyle: function (excludes, includes) {\n            var style = getItemStyle.call(this, excludes, includes);\n            var lineDash = this.getBorderLineDash();\n            lineDash && (style.lineDash = lineDash);\n            return style;\n        },\n\n        getBorderLineDash: function () {\n            var lineType = this.get('borderType');\n            return (lineType === 'solid' || lineType == null) ? null\n                : (lineType === 'dashed' ? [5, 5] : [1, 1]);\n        }\n    };\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTcyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL21vZGVsL21peGluL2l0ZW1TdHlsZS5qcz8zZjcxIl0sInNvdXJjZXNDb250ZW50IjpbIlxuICAgIHZhciBnZXRJdGVtU3R5bGUgPSByZXF1aXJlKCcuL21ha2VTdHlsZU1hcHBlcicpKFxuICAgICAgICBbXG4gICAgICAgICAgICBbJ2ZpbGwnLCAnY29sb3InXSxcbiAgICAgICAgICAgIFsnc3Ryb2tlJywgJ2JvcmRlckNvbG9yJ10sXG4gICAgICAgICAgICBbJ2xpbmVXaWR0aCcsICdib3JkZXJXaWR0aCddLFxuICAgICAgICAgICAgWydvcGFjaXR5J10sXG4gICAgICAgICAgICBbJ3NoYWRvd0JsdXInXSxcbiAgICAgICAgICAgIFsnc2hhZG93T2Zmc2V0WCddLFxuICAgICAgICAgICAgWydzaGFkb3dPZmZzZXRZJ10sXG4gICAgICAgICAgICBbJ3NoYWRvd0NvbG9yJ10sXG4gICAgICAgICAgICBbJ3RleHRQb3NpdGlvbiddLFxuICAgICAgICAgICAgWyd0ZXh0QWxpZ24nXVxuICAgICAgICBdXG4gICAgKTtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgZ2V0SXRlbVN0eWxlOiBmdW5jdGlvbiAoZXhjbHVkZXMsIGluY2x1ZGVzKSB7XG4gICAgICAgICAgICB2YXIgc3R5bGUgPSBnZXRJdGVtU3R5bGUuY2FsbCh0aGlzLCBleGNsdWRlcywgaW5jbHVkZXMpO1xuICAgICAgICAgICAgdmFyIGxpbmVEYXNoID0gdGhpcy5nZXRCb3JkZXJMaW5lRGFzaCgpO1xuICAgICAgICAgICAgbGluZURhc2ggJiYgKHN0eWxlLmxpbmVEYXNoID0gbGluZURhc2gpO1xuICAgICAgICAgICAgcmV0dXJuIHN0eWxlO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldEJvcmRlckxpbmVEYXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbGluZVR5cGUgPSB0aGlzLmdldCgnYm9yZGVyVHlwZScpO1xuICAgICAgICAgICAgcmV0dXJuIChsaW5lVHlwZSA9PT0gJ3NvbGlkJyB8fCBsaW5lVHlwZSA9PSBudWxsKSA/IG51bGxcbiAgICAgICAgICAgICAgICA6IChsaW5lVHlwZSA9PT0gJ2Rhc2hlZCcgPyBbNSwgNV0gOiBbMSwgMV0pO1xuICAgICAgICB9XG4gICAgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL21vZGVsL21peGluL2l0ZW1TdHlsZS5qc1xuLy8gbW9kdWxlIGlkID0gMTcyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 173 */
/* unknown exports provided */
/* all exports used */
/*!**************************************!*\
  !*** ./lib/model/mixin/lineStyle.js ***!
  \**************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\n    var getLineStyle = __webpack_require__(/*! ./makeStyleMapper */ 30)(\n        [\n            ['lineWidth', 'width'],\n            ['stroke', 'color'],\n            ['opacity'],\n            ['shadowBlur'],\n            ['shadowOffsetX'],\n            ['shadowOffsetY'],\n            ['shadowColor']\n        ]\n    );\n    module.exports = {\n        getLineStyle: function (excludes) {\n            var style = getLineStyle.call(this, excludes);\n            var lineDash = this.getLineDash(style.lineWidth);\n            lineDash && (style.lineDash = lineDash);\n            return style;\n        },\n\n        getLineDash: function (lineWidth) {\n            if (lineWidth == null) {\n                lineWidth = 1;\n            }\n            var lineType = this.get('type');\n            var dotSize = Math.max(lineWidth, 2);\n            var dashSize = lineWidth * 4;\n            return (lineType === 'solid' || lineType == null) ? null\n                : (lineType === 'dashed' ? [dashSize, dashSize] : [dotSize, dotSize]);\n        }\n    };\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTczLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL21vZGVsL21peGluL2xpbmVTdHlsZS5qcz8wZmEyIl0sInNvdXJjZXNDb250ZW50IjpbIlxuICAgIHZhciBnZXRMaW5lU3R5bGUgPSByZXF1aXJlKCcuL21ha2VTdHlsZU1hcHBlcicpKFxuICAgICAgICBbXG4gICAgICAgICAgICBbJ2xpbmVXaWR0aCcsICd3aWR0aCddLFxuICAgICAgICAgICAgWydzdHJva2UnLCAnY29sb3InXSxcbiAgICAgICAgICAgIFsnb3BhY2l0eSddLFxuICAgICAgICAgICAgWydzaGFkb3dCbHVyJ10sXG4gICAgICAgICAgICBbJ3NoYWRvd09mZnNldFgnXSxcbiAgICAgICAgICAgIFsnc2hhZG93T2Zmc2V0WSddLFxuICAgICAgICAgICAgWydzaGFkb3dDb2xvciddXG4gICAgICAgIF1cbiAgICApO1xuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBnZXRMaW5lU3R5bGU6IGZ1bmN0aW9uIChleGNsdWRlcykge1xuICAgICAgICAgICAgdmFyIHN0eWxlID0gZ2V0TGluZVN0eWxlLmNhbGwodGhpcywgZXhjbHVkZXMpO1xuICAgICAgICAgICAgdmFyIGxpbmVEYXNoID0gdGhpcy5nZXRMaW5lRGFzaChzdHlsZS5saW5lV2lkdGgpO1xuICAgICAgICAgICAgbGluZURhc2ggJiYgKHN0eWxlLmxpbmVEYXNoID0gbGluZURhc2gpO1xuICAgICAgICAgICAgcmV0dXJuIHN0eWxlO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldExpbmVEYXNoOiBmdW5jdGlvbiAobGluZVdpZHRoKSB7XG4gICAgICAgICAgICBpZiAobGluZVdpZHRoID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBsaW5lV2lkdGggPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGxpbmVUeXBlID0gdGhpcy5nZXQoJ3R5cGUnKTtcbiAgICAgICAgICAgIHZhciBkb3RTaXplID0gTWF0aC5tYXgobGluZVdpZHRoLCAyKTtcbiAgICAgICAgICAgIHZhciBkYXNoU2l6ZSA9IGxpbmVXaWR0aCAqIDQ7XG4gICAgICAgICAgICByZXR1cm4gKGxpbmVUeXBlID09PSAnc29saWQnIHx8IGxpbmVUeXBlID09IG51bGwpID8gbnVsbFxuICAgICAgICAgICAgICAgIDogKGxpbmVUeXBlID09PSAnZGFzaGVkJyA/IFtkYXNoU2l6ZSwgZGFzaFNpemVdIDogW2RvdFNpemUsIGRvdFNpemVdKTtcbiAgICAgICAgfVxuICAgIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9tb2RlbC9taXhpbi9saW5lU3R5bGUuanNcbi8vIG1vZHVsZSBpZCA9IDE3M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 174 */
/* unknown exports provided */
/* all exports used */
/*!**************************************!*\
  !*** ./lib/model/mixin/textStyle.js ***!
  \**************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var textContain = __webpack_require__(/*! zrender/lib/contain/text */ 15);\n\n    function getShallow(model, path) {\n        return model && model.getShallow(path);\n    }\n\n    module.exports = {\n        /**\n         * Get color property or get color from option.textStyle.color\n         * @return {string}\n         */\n        getTextColor: function () {\n            var ecModel = this.ecModel;\n            return this.getShallow('color')\n                || (ecModel && ecModel.get('textStyle.color'));\n        },\n\n        /**\n         * Create font string from fontStyle, fontWeight, fontSize, fontFamily\n         * @return {string}\n         */\n        getFont: function () {\n            var ecModel = this.ecModel;\n            var gTextStyleModel = ecModel && ecModel.getModel('textStyle');\n            return [\n                // FIXME in node-canvas fontWeight is before fontStyle\n                this.getShallow('fontStyle') || getShallow(gTextStyleModel, 'fontStyle'),\n                this.getShallow('fontWeight') || getShallow(gTextStyleModel, 'fontWeight'),\n                (this.getShallow('fontSize') || getShallow(gTextStyleModel, 'fontSize') || 12) + 'px',\n                this.getShallow('fontFamily') || getShallow(gTextStyleModel, 'fontFamily') || 'sans-serif'\n            ].join(' ');\n        },\n\n        getTextRect: function (text) {\n            return textContain.getBoundingRect(\n                text,\n                this.getFont(),\n                this.getShallow('align'),\n                this.getShallow('baseline')\n            );\n        },\n\n        truncateText: function (text, containerWidth, ellipsis, options) {\n            return textContain.truncateText(\n                text, containerWidth, this.getFont(), ellipsis, options\n            );\n        }\n    };\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTc0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL21vZGVsL21peGluL3RleHRTdHlsZS5qcz8xNDBlIl0sInNvdXJjZXNDb250ZW50IjpbIlxuXG4gICAgdmFyIHRleHRDb250YWluID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29udGFpbi90ZXh0Jyk7XG5cbiAgICBmdW5jdGlvbiBnZXRTaGFsbG93KG1vZGVsLCBwYXRoKSB7XG4gICAgICAgIHJldHVybiBtb2RlbCAmJiBtb2RlbC5nZXRTaGFsbG93KHBhdGgpO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGNvbG9yIHByb3BlcnR5IG9yIGdldCBjb2xvciBmcm9tIG9wdGlvbi50ZXh0U3R5bGUuY29sb3JcbiAgICAgICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0VGV4dENvbG9yOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZWNNb2RlbCA9IHRoaXMuZWNNb2RlbDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFNoYWxsb3coJ2NvbG9yJylcbiAgICAgICAgICAgICAgICB8fCAoZWNNb2RlbCAmJiBlY01vZGVsLmdldCgndGV4dFN0eWxlLmNvbG9yJykpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgZm9udCBzdHJpbmcgZnJvbSBmb250U3R5bGUsIGZvbnRXZWlnaHQsIGZvbnRTaXplLCBmb250RmFtaWx5XG4gICAgICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIGdldEZvbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBlY01vZGVsID0gdGhpcy5lY01vZGVsO1xuICAgICAgICAgICAgdmFyIGdUZXh0U3R5bGVNb2RlbCA9IGVjTW9kZWwgJiYgZWNNb2RlbC5nZXRNb2RlbCgndGV4dFN0eWxlJyk7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIC8vIEZJWE1FIGluIG5vZGUtY2FudmFzIGZvbnRXZWlnaHQgaXMgYmVmb3JlIGZvbnRTdHlsZVxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0U2hhbGxvdygnZm9udFN0eWxlJykgfHwgZ2V0U2hhbGxvdyhnVGV4dFN0eWxlTW9kZWwsICdmb250U3R5bGUnKSxcbiAgICAgICAgICAgICAgICB0aGlzLmdldFNoYWxsb3coJ2ZvbnRXZWlnaHQnKSB8fCBnZXRTaGFsbG93KGdUZXh0U3R5bGVNb2RlbCwgJ2ZvbnRXZWlnaHQnKSxcbiAgICAgICAgICAgICAgICAodGhpcy5nZXRTaGFsbG93KCdmb250U2l6ZScpIHx8IGdldFNoYWxsb3coZ1RleHRTdHlsZU1vZGVsLCAnZm9udFNpemUnKSB8fCAxMikgKyAncHgnLFxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0U2hhbGxvdygnZm9udEZhbWlseScpIHx8IGdldFNoYWxsb3coZ1RleHRTdHlsZU1vZGVsLCAnZm9udEZhbWlseScpIHx8ICdzYW5zLXNlcmlmJ1xuICAgICAgICAgICAgXS5qb2luKCcgJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0VGV4dFJlY3Q6IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGV4dENvbnRhaW4uZ2V0Qm91bmRpbmdSZWN0KFxuICAgICAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRGb250KCksXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRTaGFsbG93KCdhbGlnbicpLFxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0U2hhbGxvdygnYmFzZWxpbmUnKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSxcblxuICAgICAgICB0cnVuY2F0ZVRleHQ6IGZ1bmN0aW9uICh0ZXh0LCBjb250YWluZXJXaWR0aCwgZWxsaXBzaXMsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiB0ZXh0Q29udGFpbi50cnVuY2F0ZVRleHQoXG4gICAgICAgICAgICAgICAgdGV4dCwgY29udGFpbmVyV2lkdGgsIHRoaXMuZ2V0Rm9udCgpLCBlbGxpcHNpcywgb3B0aW9uc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9tb2RlbC9taXhpbi90ZXh0U3R5bGUuanNcbi8vIG1vZHVsZSBpZCA9IDE3NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 175 */
/* unknown exports provided */
/* all exports used */
/*!********************************************!*\
  !*** ./lib/preprocessor/backwardCompat.js ***!
  \********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("// Compatitable with 2.0\n\n\n    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 0);\n    var compatStyle = __webpack_require__(/*! ./helper/compatStyle */ 176);\n\n    function get(opt, path) {\n        path = path.split(',');\n        var obj = opt;\n        for (var i = 0; i < path.length; i++) {\n            obj = obj && obj[path[i]];\n            if (obj == null) {\n                break;\n            }\n        }\n        return obj;\n    }\n\n    function set(opt, path, val, overwrite) {\n        path = path.split(',');\n        var obj = opt;\n        var key;\n        for (var i = 0; i < path.length - 1; i++) {\n            key = path[i];\n            if (obj[key] == null) {\n                obj[key] = {};\n            }\n            obj = obj[key];\n        }\n        if (overwrite || obj[path[i]] == null) {\n            obj[path[i]] = val;\n        }\n    }\n\n    function compatLayoutProperties(option) {\n        each(LAYOUT_PROPERTIES, function (prop) {\n            if (prop[0] in option && !(prop[1] in option)) {\n                option[prop[1]] = option[prop[0]];\n            }\n        });\n    }\n\n    var LAYOUT_PROPERTIES = [\n        ['x', 'left'], ['y', 'top'], ['x2', 'right'], ['y2', 'bottom']\n    ];\n\n    var COMPATITABLE_COMPONENTS = [\n        'grid', 'geo', 'parallel', 'legend', 'toolbox', 'title', 'visualMap', 'dataZoom', 'timeline'\n    ];\n\n    var COMPATITABLE_SERIES = [\n        'bar', 'boxplot', 'candlestick', 'chord', 'effectScatter',\n        'funnel', 'gauge', 'lines', 'graph', 'heatmap', 'line', 'map', 'parallel',\n        'pie', 'radar', 'sankey', 'scatter', 'treemap'\n    ];\n\n    var each = zrUtil.each;\n\n    module.exports = function (option) {\n        each(option.series, function (seriesOpt) {\n            if (!zrUtil.isObject(seriesOpt)) {\n                return;\n            }\n\n            var seriesType = seriesOpt.type;\n\n            compatStyle(seriesOpt);\n\n            if (seriesType === 'pie' || seriesType === 'gauge') {\n                if (seriesOpt.clockWise != null) {\n                    seriesOpt.clockwise = seriesOpt.clockWise;\n                }\n            }\n            if (seriesType === 'gauge') {\n                var pointerColor = get(seriesOpt, 'pointer.color');\n                pointerColor != null\n                    && set(seriesOpt, 'itemStyle.normal.color', pointerColor);\n            }\n\n            for (var i = 0; i < COMPATITABLE_SERIES.length; i++) {\n                if (COMPATITABLE_SERIES[i] === seriesOpt.type) {\n                    compatLayoutProperties(seriesOpt);\n                    break;\n                }\n            }\n        });\n\n        // dataRange has changed to visualMap\n        if (option.dataRange) {\n            option.visualMap = option.dataRange;\n        }\n\n        each(COMPATITABLE_COMPONENTS, function (componentName) {\n            var options = option[componentName];\n            if (options) {\n                if (!zrUtil.isArray(options)) {\n                    options = [options];\n                }\n                each(options, function (option) {\n                    compatLayoutProperties(option);\n                });\n            }\n        });\n    };\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTc1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL3ByZXByb2Nlc3Nvci9iYWNrd2FyZENvbXBhdC5qcz8wOTM3Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvbXBhdGl0YWJsZSB3aXRoIDIuMFxuXG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG4gICAgdmFyIGNvbXBhdFN0eWxlID0gcmVxdWlyZSgnLi9oZWxwZXIvY29tcGF0U3R5bGUnKTtcblxuICAgIGZ1bmN0aW9uIGdldChvcHQsIHBhdGgpIHtcbiAgICAgICAgcGF0aCA9IHBhdGguc3BsaXQoJywnKTtcbiAgICAgICAgdmFyIG9iaiA9IG9wdDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBvYmogPSBvYmogJiYgb2JqW3BhdGhbaV1dO1xuICAgICAgICAgICAgaWYgKG9iaiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXQob3B0LCBwYXRoLCB2YWwsIG92ZXJ3cml0ZSkge1xuICAgICAgICBwYXRoID0gcGF0aC5zcGxpdCgnLCcpO1xuICAgICAgICB2YXIgb2JqID0gb3B0O1xuICAgICAgICB2YXIga2V5O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICBrZXkgPSBwYXRoW2ldO1xuICAgICAgICAgICAgaWYgKG9ialtrZXldID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBvYmpba2V5XSA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2JqID0gb2JqW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG92ZXJ3cml0ZSB8fCBvYmpbcGF0aFtpXV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgb2JqW3BhdGhbaV1dID0gdmFsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29tcGF0TGF5b3V0UHJvcGVydGllcyhvcHRpb24pIHtcbiAgICAgICAgZWFjaChMQVlPVVRfUFJPUEVSVElFUywgZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgIGlmIChwcm9wWzBdIGluIG9wdGlvbiAmJiAhKHByb3BbMV0gaW4gb3B0aW9uKSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbltwcm9wWzFdXSA9IG9wdGlvbltwcm9wWzBdXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIExBWU9VVF9QUk9QRVJUSUVTID0gW1xuICAgICAgICBbJ3gnLCAnbGVmdCddLCBbJ3knLCAndG9wJ10sIFsneDInLCAncmlnaHQnXSwgWyd5MicsICdib3R0b20nXVxuICAgIF07XG5cbiAgICB2YXIgQ09NUEFUSVRBQkxFX0NPTVBPTkVOVFMgPSBbXG4gICAgICAgICdncmlkJywgJ2dlbycsICdwYXJhbGxlbCcsICdsZWdlbmQnLCAndG9vbGJveCcsICd0aXRsZScsICd2aXN1YWxNYXAnLCAnZGF0YVpvb20nLCAndGltZWxpbmUnXG4gICAgXTtcblxuICAgIHZhciBDT01QQVRJVEFCTEVfU0VSSUVTID0gW1xuICAgICAgICAnYmFyJywgJ2JveHBsb3QnLCAnY2FuZGxlc3RpY2snLCAnY2hvcmQnLCAnZWZmZWN0U2NhdHRlcicsXG4gICAgICAgICdmdW5uZWwnLCAnZ2F1Z2UnLCAnbGluZXMnLCAnZ3JhcGgnLCAnaGVhdG1hcCcsICdsaW5lJywgJ21hcCcsICdwYXJhbGxlbCcsXG4gICAgICAgICdwaWUnLCAncmFkYXInLCAnc2Fua2V5JywgJ3NjYXR0ZXInLCAndHJlZW1hcCdcbiAgICBdO1xuXG4gICAgdmFyIGVhY2ggPSB6clV0aWwuZWFjaDtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9wdGlvbikge1xuICAgICAgICBlYWNoKG9wdGlvbi5zZXJpZXMsIGZ1bmN0aW9uIChzZXJpZXNPcHQpIHtcbiAgICAgICAgICAgIGlmICghenJVdGlsLmlzT2JqZWN0KHNlcmllc09wdCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzZXJpZXNUeXBlID0gc2VyaWVzT3B0LnR5cGU7XG5cbiAgICAgICAgICAgIGNvbXBhdFN0eWxlKHNlcmllc09wdCk7XG5cbiAgICAgICAgICAgIGlmIChzZXJpZXNUeXBlID09PSAncGllJyB8fCBzZXJpZXNUeXBlID09PSAnZ2F1Z2UnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlcmllc09wdC5jbG9ja1dpc2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBzZXJpZXNPcHQuY2xvY2t3aXNlID0gc2VyaWVzT3B0LmNsb2NrV2lzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VyaWVzVHlwZSA9PT0gJ2dhdWdlJykge1xuICAgICAgICAgICAgICAgIHZhciBwb2ludGVyQ29sb3IgPSBnZXQoc2VyaWVzT3B0LCAncG9pbnRlci5jb2xvcicpO1xuICAgICAgICAgICAgICAgIHBvaW50ZXJDb2xvciAhPSBudWxsXG4gICAgICAgICAgICAgICAgICAgICYmIHNldChzZXJpZXNPcHQsICdpdGVtU3R5bGUubm9ybWFsLmNvbG9yJywgcG9pbnRlckNvbG9yKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBDT01QQVRJVEFCTEVfU0VSSUVTLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKENPTVBBVElUQUJMRV9TRVJJRVNbaV0gPT09IHNlcmllc09wdC50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBhdExheW91dFByb3BlcnRpZXMoc2VyaWVzT3B0KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBkYXRhUmFuZ2UgaGFzIGNoYW5nZWQgdG8gdmlzdWFsTWFwXG4gICAgICAgIGlmIChvcHRpb24uZGF0YVJhbmdlKSB7XG4gICAgICAgICAgICBvcHRpb24udmlzdWFsTWFwID0gb3B0aW9uLmRhdGFSYW5nZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVhY2goQ09NUEFUSVRBQkxFX0NPTVBPTkVOVFMsIGZ1bmN0aW9uIChjb21wb25lbnROYW1lKSB7XG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IG9wdGlvbltjb21wb25lbnROYW1lXTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF6clV0aWwuaXNBcnJheShvcHRpb25zKSkge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0gW29wdGlvbnNdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlYWNoKG9wdGlvbnMsIGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcGF0TGF5b3V0UHJvcGVydGllcyhvcHRpb24pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvcHJlcHJvY2Vzc29yL2JhY2t3YXJkQ29tcGF0LmpzXG4vLyBtb2R1bGUgaWQgPSAxNzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 176 */
/* unknown exports provided */
/* all exports used */
/*!************************************************!*\
  !*** ./lib/preprocessor/helper/compatStyle.js ***!
  \************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 0);\n\n    var POSSIBLE_STYLES = [\n        'areaStyle', 'lineStyle', 'nodeStyle', 'linkStyle',\n        'chordStyle', 'label', 'labelLine'\n    ];\n\n    function compatItemStyle(opt) {\n        var itemStyleOpt = opt && opt.itemStyle;\n        if (itemStyleOpt) {\n            zrUtil.each(POSSIBLE_STYLES, function (styleName) {\n                var normalItemStyleOpt = itemStyleOpt.normal;\n                var emphasisItemStyleOpt = itemStyleOpt.emphasis;\n                if (normalItemStyleOpt && normalItemStyleOpt[styleName]) {\n                    opt[styleName] = opt[styleName] || {};\n                    if (!opt[styleName].normal) {\n                        opt[styleName].normal = normalItemStyleOpt[styleName];\n                    }\n                    else {\n                        zrUtil.merge(opt[styleName].normal, normalItemStyleOpt[styleName]);\n                    }\n                    normalItemStyleOpt[styleName] = null;\n                }\n                if (emphasisItemStyleOpt && emphasisItemStyleOpt[styleName]) {\n                    opt[styleName] = opt[styleName] || {};\n                    if (!opt[styleName].emphasis) {\n                        opt[styleName].emphasis = emphasisItemStyleOpt[styleName];\n                    }\n                    else {\n                        zrUtil.merge(opt[styleName].emphasis, emphasisItemStyleOpt[styleName]);\n                    }\n                    emphasisItemStyleOpt[styleName] = null;\n                }\n            });\n        }\n    }\n\n    module.exports = function (seriesOpt) {\n        if (!seriesOpt) {\n            return;\n        }\n        compatItemStyle(seriesOpt);\n        compatItemStyle(seriesOpt.markPoint);\n        compatItemStyle(seriesOpt.markLine);\n        var data = seriesOpt.data;\n        if (data) {\n            for (var i = 0; i < data.length; i++) {\n                compatItemStyle(data[i]);\n            }\n            // mark point data\n            var markPoint = seriesOpt.markPoint;\n            if (markPoint && markPoint.data) {\n                var mpData = markPoint.data;\n                for (var i = 0; i < mpData.length; i++) {\n                    compatItemStyle(mpData[i]);\n                }\n            }\n            // mark line data\n            var markLine = seriesOpt.markLine;\n            if (markLine && markLine.data) {\n                var mlData = markLine.data;\n                for (var i = 0; i < mlData.length; i++) {\n                    if (zrUtil.isArray(mlData[i])) {\n                        compatItemStyle(mlData[i][0]);\n                        compatItemStyle(mlData[i][1]);\n                    }\n                    else {\n                        compatItemStyle(mlData[i]);\n                    }\n                }\n            }\n        }\n    };\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTc2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL3ByZXByb2Nlc3Nvci9oZWxwZXIvY29tcGF0U3R5bGUuanM/ZTcyOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcblxuICAgIHZhciBQT1NTSUJMRV9TVFlMRVMgPSBbXG4gICAgICAgICdhcmVhU3R5bGUnLCAnbGluZVN0eWxlJywgJ25vZGVTdHlsZScsICdsaW5rU3R5bGUnLFxuICAgICAgICAnY2hvcmRTdHlsZScsICdsYWJlbCcsICdsYWJlbExpbmUnXG4gICAgXTtcblxuICAgIGZ1bmN0aW9uIGNvbXBhdEl0ZW1TdHlsZShvcHQpIHtcbiAgICAgICAgdmFyIGl0ZW1TdHlsZU9wdCA9IG9wdCAmJiBvcHQuaXRlbVN0eWxlO1xuICAgICAgICBpZiAoaXRlbVN0eWxlT3B0KSB7XG4gICAgICAgICAgICB6clV0aWwuZWFjaChQT1NTSUJMRV9TVFlMRVMsIGZ1bmN0aW9uIChzdHlsZU5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9ybWFsSXRlbVN0eWxlT3B0ID0gaXRlbVN0eWxlT3B0Lm5vcm1hbDtcbiAgICAgICAgICAgICAgICB2YXIgZW1waGFzaXNJdGVtU3R5bGVPcHQgPSBpdGVtU3R5bGVPcHQuZW1waGFzaXM7XG4gICAgICAgICAgICAgICAgaWYgKG5vcm1hbEl0ZW1TdHlsZU9wdCAmJiBub3JtYWxJdGVtU3R5bGVPcHRbc3R5bGVOYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICBvcHRbc3R5bGVOYW1lXSA9IG9wdFtzdHlsZU5hbWVdIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW9wdFtzdHlsZU5hbWVdLm5vcm1hbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0W3N0eWxlTmFtZV0ubm9ybWFsID0gbm9ybWFsSXRlbVN0eWxlT3B0W3N0eWxlTmFtZV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB6clV0aWwubWVyZ2Uob3B0W3N0eWxlTmFtZV0ubm9ybWFsLCBub3JtYWxJdGVtU3R5bGVPcHRbc3R5bGVOYW1lXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsSXRlbVN0eWxlT3B0W3N0eWxlTmFtZV0gPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZW1waGFzaXNJdGVtU3R5bGVPcHQgJiYgZW1waGFzaXNJdGVtU3R5bGVPcHRbc3R5bGVOYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICBvcHRbc3R5bGVOYW1lXSA9IG9wdFtzdHlsZU5hbWVdIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW9wdFtzdHlsZU5hbWVdLmVtcGhhc2lzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRbc3R5bGVOYW1lXS5lbXBoYXNpcyA9IGVtcGhhc2lzSXRlbVN0eWxlT3B0W3N0eWxlTmFtZV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB6clV0aWwubWVyZ2Uob3B0W3N0eWxlTmFtZV0uZW1waGFzaXMsIGVtcGhhc2lzSXRlbVN0eWxlT3B0W3N0eWxlTmFtZV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVtcGhhc2lzSXRlbVN0eWxlT3B0W3N0eWxlTmFtZV0gPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc2VyaWVzT3B0KSB7XG4gICAgICAgIGlmICghc2VyaWVzT3B0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29tcGF0SXRlbVN0eWxlKHNlcmllc09wdCk7XG4gICAgICAgIGNvbXBhdEl0ZW1TdHlsZShzZXJpZXNPcHQubWFya1BvaW50KTtcbiAgICAgICAgY29tcGF0SXRlbVN0eWxlKHNlcmllc09wdC5tYXJrTGluZSk7XG4gICAgICAgIHZhciBkYXRhID0gc2VyaWVzT3B0LmRhdGE7XG4gICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb21wYXRJdGVtU3R5bGUoZGF0YVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBtYXJrIHBvaW50IGRhdGFcbiAgICAgICAgICAgIHZhciBtYXJrUG9pbnQgPSBzZXJpZXNPcHQubWFya1BvaW50O1xuICAgICAgICAgICAgaWYgKG1hcmtQb2ludCAmJiBtYXJrUG9pbnQuZGF0YSkge1xuICAgICAgICAgICAgICAgIHZhciBtcERhdGEgPSBtYXJrUG9pbnQuZGF0YTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1wRGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb21wYXRJdGVtU3R5bGUobXBEYXRhW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBtYXJrIGxpbmUgZGF0YVxuICAgICAgICAgICAgdmFyIG1hcmtMaW5lID0gc2VyaWVzT3B0Lm1hcmtMaW5lO1xuICAgICAgICAgICAgaWYgKG1hcmtMaW5lICYmIG1hcmtMaW5lLmRhdGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWxEYXRhID0gbWFya0xpbmUuZGF0YTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1sRGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoenJVdGlsLmlzQXJyYXkobWxEYXRhW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcGF0SXRlbVN0eWxlKG1sRGF0YVtpXVswXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wYXRJdGVtU3R5bGUobWxEYXRhW2ldWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBhdEl0ZW1TdHlsZShtbERhdGFbaV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL3ByZXByb2Nlc3Nvci9oZWxwZXIvY29tcGF0U3R5bGUuanNcbi8vIG1vZHVsZSBpZCA9IDE3NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 177 */
/* unknown exports provided */
/* all exports used */
/*!*************************************!*\
  !*** ./lib/processor/dataSample.js ***!
  \*************************************/
/***/ (function(module, exports) {

eval("\n    var samplers = {\n        average: function (frame) {\n            var sum = 0;\n            var count = 0;\n            for (var i = 0; i < frame.length; i++) {\n                if (!isNaN(frame[i])) {\n                    sum += frame[i];\n                    count++;\n                }\n            }\n            // Return NaN if count is 0\n            return count === 0 ? NaN : sum / count;\n        },\n        sum: function (frame) {\n            var sum = 0;\n            for (var i = 0; i < frame.length; i++) {\n                // Ignore NaN\n                sum += frame[i] || 0;\n            }\n            return sum;\n        },\n        max: function (frame) {\n            var max = -Infinity;\n            for (var i = 0; i < frame.length; i++) {\n                frame[i] > max && (max = frame[i]);\n            }\n            return max;\n        },\n        min: function (frame) {\n            var min = Infinity;\n            for (var i = 0; i < frame.length; i++) {\n                frame[i] < min && (min = frame[i]);\n            }\n            return min;\n        },\n        // TODO\n        // Median\n        nearest: function (frame) {\n            return frame[0];\n        }\n    };\n\n    var indexSampler = function (frame, value) {\n        return Math.round(frame.length / 2);\n    };\n    module.exports = function (seriesType, ecModel, api) {\n        ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n            var data = seriesModel.getData();\n            var sampling = seriesModel.get('sampling');\n            var coordSys = seriesModel.coordinateSystem;\n            // Only cartesian2d support down sampling\n            if (coordSys.type === 'cartesian2d' && sampling) {\n                var baseAxis = coordSys.getBaseAxis();\n                var valueAxis = coordSys.getOtherAxis(baseAxis);\n                var extent = baseAxis.getExtent();\n                // Coordinste system has been resized\n                var size = extent[1] - extent[0];\n                var rate = Math.round(data.count() / size);\n                if (rate > 1) {\n                    var sampler;\n                    if (typeof sampling === 'string') {\n                        sampler = samplers[sampling];\n                    }\n                    else if (typeof sampling === 'function') {\n                        sampler = sampling;\n                    }\n                    if (sampler) {\n                        data = data.downSample(\n                            valueAxis.dim, 1 / rate, sampler, indexSampler\n                        );\n                        seriesModel.setData(data);\n                    }\n                }\n            }\n        }, this);\n    };\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTc3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL3Byb2Nlc3Nvci9kYXRhU2FtcGxlLmpzP2QyMzAiXSwic291cmNlc0NvbnRlbnQiOlsiXG4gICAgdmFyIHNhbXBsZXJzID0ge1xuICAgICAgICBhdmVyYWdlOiBmdW5jdGlvbiAoZnJhbWUpIHtcbiAgICAgICAgICAgIHZhciBzdW0gPSAwO1xuICAgICAgICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZnJhbWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKGZyYW1lW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICBzdW0gKz0gZnJhbWVbaV07XG4gICAgICAgICAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmV0dXJuIE5hTiBpZiBjb3VudCBpcyAwXG4gICAgICAgICAgICByZXR1cm4gY291bnQgPT09IDAgPyBOYU4gOiBzdW0gLyBjb3VudDtcbiAgICAgICAgfSxcbiAgICAgICAgc3VtOiBmdW5jdGlvbiAoZnJhbWUpIHtcbiAgICAgICAgICAgIHZhciBzdW0gPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmcmFtZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIC8vIElnbm9yZSBOYU5cbiAgICAgICAgICAgICAgICBzdW0gKz0gZnJhbWVbaV0gfHwgMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdW07XG4gICAgICAgIH0sXG4gICAgICAgIG1heDogZnVuY3Rpb24gKGZyYW1lKSB7XG4gICAgICAgICAgICB2YXIgbWF4ID0gLUluZmluaXR5O1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmcmFtZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGZyYW1lW2ldID4gbWF4ICYmIChtYXggPSBmcmFtZVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWF4O1xuICAgICAgICB9LFxuICAgICAgICBtaW46IGZ1bmN0aW9uIChmcmFtZSkge1xuICAgICAgICAgICAgdmFyIG1pbiA9IEluZmluaXR5O1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmcmFtZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGZyYW1lW2ldIDwgbWluICYmIChtaW4gPSBmcmFtZVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWluO1xuICAgICAgICB9LFxuICAgICAgICAvLyBUT0RPXG4gICAgICAgIC8vIE1lZGlhblxuICAgICAgICBuZWFyZXN0OiBmdW5jdGlvbiAoZnJhbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBmcmFtZVswXTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgaW5kZXhTYW1wbGVyID0gZnVuY3Rpb24gKGZyYW1lLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChmcmFtZS5sZW5ndGggLyAyKTtcbiAgICB9O1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHNlcmllc1R5cGUsIGVjTW9kZWwsIGFwaSkge1xuICAgICAgICBlY01vZGVsLmVhY2hTZXJpZXNCeVR5cGUoc2VyaWVzVHlwZSwgZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICAgICAgICAgIHZhciBzYW1wbGluZyA9IHNlcmllc01vZGVsLmdldCgnc2FtcGxpbmcnKTtcbiAgICAgICAgICAgIHZhciBjb29yZFN5cyA9IHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG4gICAgICAgICAgICAvLyBPbmx5IGNhcnRlc2lhbjJkIHN1cHBvcnQgZG93biBzYW1wbGluZ1xuICAgICAgICAgICAgaWYgKGNvb3JkU3lzLnR5cGUgPT09ICdjYXJ0ZXNpYW4yZCcgJiYgc2FtcGxpbmcpIHtcbiAgICAgICAgICAgICAgICB2YXIgYmFzZUF4aXMgPSBjb29yZFN5cy5nZXRCYXNlQXhpcygpO1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZUF4aXMgPSBjb29yZFN5cy5nZXRPdGhlckF4aXMoYmFzZUF4aXMpO1xuICAgICAgICAgICAgICAgIHZhciBleHRlbnQgPSBiYXNlQXhpcy5nZXRFeHRlbnQoKTtcbiAgICAgICAgICAgICAgICAvLyBDb29yZGluc3RlIHN5c3RlbSBoYXMgYmVlbiByZXNpemVkXG4gICAgICAgICAgICAgICAgdmFyIHNpemUgPSBleHRlbnRbMV0gLSBleHRlbnRbMF07XG4gICAgICAgICAgICAgICAgdmFyIHJhdGUgPSBNYXRoLnJvdW5kKGRhdGEuY291bnQoKSAvIHNpemUpO1xuICAgICAgICAgICAgICAgIGlmIChyYXRlID4gMSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2FtcGxlcjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzYW1wbGluZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNhbXBsZXIgPSBzYW1wbGVyc1tzYW1wbGluZ107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHNhbXBsaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzYW1wbGVyID0gc2FtcGxpbmc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNhbXBsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhLmRvd25TYW1wbGUoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVBeGlzLmRpbSwgMSAvIHJhdGUsIHNhbXBsZXIsIGluZGV4U2FtcGxlclxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllc01vZGVsLnNldERhdGEoZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9wcm9jZXNzb3IvZGF0YVNhbXBsZS5qc1xuLy8gbW9kdWxlIGlkID0gMTc3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 178 */
/* unknown exports provided */
/* all exports used */
/*!**************************!*\
  !*** ./lib/scale/Log.js ***!
  \**************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Log scale\n * @module echarts/scale/Log\n */\n\n\n    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 0);\n    var Scale = __webpack_require__(/*! ./Scale */ 35);\n    var numberUtil = __webpack_require__(/*! ../util/number */ 3);\n\n    // Use some method of IntervalScale\n    var IntervalScale = __webpack_require__(/*! ./Interval */ 42);\n\n    var scaleProto = Scale.prototype;\n    var intervalScaleProto = IntervalScale.prototype;\n\n    var getPrecisionSafe = numberUtil.getPrecisionSafe;\n    var roundingErrorFix = numberUtil.round;\n\n    var mathFloor = Math.floor;\n    var mathCeil = Math.ceil;\n    var mathPow = Math.pow;\n\n    var mathLog = Math.log;\n\n    var LogScale = Scale.extend({\n\n        type: 'log',\n\n        base: 10,\n\n        $constructor: function () {\n            Scale.apply(this, arguments);\n            this._originalScale = new IntervalScale();\n        },\n\n        /**\n         * @return {Array.<number>}\n         */\n        getTicks: function () {\n            var originalScale = this._originalScale;\n            var extent = this._extent;\n            var originalExtent = originalScale.getExtent();\n\n            return zrUtil.map(intervalScaleProto.getTicks.call(this), function (val) {\n                var powVal = numberUtil.round(mathPow(this.base, val));\n\n                // Fix #4158\n                powVal = (val === extent[0] && originalScale.__fixMin)\n                    ? fixRoundingError(powVal, originalExtent[0])\n                    : powVal;\n                powVal = (val === extent[1] && originalScale.__fixMax)\n                    ? fixRoundingError(powVal, originalExtent[1])\n                    : powVal;\n\n                return powVal;\n            }, this);\n        },\n\n        /**\n         * @param {number} val\n         * @return {string}\n         */\n        getLabel: intervalScaleProto.getLabel,\n\n        /**\n         * @param  {number} val\n         * @return {number}\n         */\n        scale: function (val) {\n            val = scaleProto.scale.call(this, val);\n            return mathPow(this.base, val);\n        },\n\n        /**\n         * @param {number} start\n         * @param {number} end\n         */\n        setExtent: function (start, end) {\n            var base = this.base;\n            start = mathLog(start) / mathLog(base);\n            end = mathLog(end) / mathLog(base);\n            intervalScaleProto.setExtent.call(this, start, end);\n        },\n\n        /**\n         * @return {number} end\n         */\n        getExtent: function () {\n            var base = this.base;\n            var extent = scaleProto.getExtent.call(this);\n            extent[0] = mathPow(base, extent[0]);\n            extent[1] = mathPow(base, extent[1]);\n\n            // Fix #4158\n            var originalScale = this._originalScale;\n            var originalExtent = originalScale.getExtent();\n            originalScale.__fixMin && (extent[0] = fixRoundingError(extent[0], originalExtent[0]));\n            originalScale.__fixMax && (extent[1] = fixRoundingError(extent[1], originalExtent[1]));\n\n            return extent;\n        },\n\n        /**\n         * @param  {Array.<number>} extent\n         */\n        unionExtent: function (extent) {\n            this._originalScale.unionExtent(extent);\n\n            var base = this.base;\n            extent[0] = mathLog(extent[0]) / mathLog(base);\n            extent[1] = mathLog(extent[1]) / mathLog(base);\n            scaleProto.unionExtent.call(this, extent);\n        },\n\n        /**\n         * @override\n         */\n        unionExtentFromData: function (data, dim) {\n            this.unionExtent(data.getDataExtent(dim, true, function (val) {\n                return val > 0;\n            }));\n        },\n\n        /**\n         * Update interval and extent of intervals for nice ticks\n         * @param  {number} [approxTickNum = 10] Given approx tick number\n         */\n        niceTicks: function (approxTickNum) {\n            approxTickNum = approxTickNum || 10;\n            var extent = this._extent;\n            var span = extent[1] - extent[0];\n            if (span === Infinity || span <= 0) {\n                return;\n            }\n\n            var interval = numberUtil.quantity(span);\n            var err = approxTickNum / span * interval;\n\n            // Filter ticks to get closer to the desired count.\n            if (err <= 0.5) {\n                interval *= 10;\n            }\n\n            // Interval should be integer\n            while (!isNaN(interval) && Math.abs(interval) < 1 && Math.abs(interval) > 0) {\n                interval *= 10;\n            }\n\n            var niceExtent = [\n                numberUtil.round(mathCeil(extent[0] / interval) * interval),\n                numberUtil.round(mathFloor(extent[1] / interval) * interval)\n            ];\n\n            this._interval = interval;\n            this._niceExtent = niceExtent;\n        },\n\n        /**\n         * Nice extent.\n         * @param {number} [approxTickNum = 10] Given approx tick number\n         * @param {boolean} [fixMin=false]\n         * @param {boolean} [fixMax=false]\n         */\n        niceExtent: function (splitNumber, fixMin, fixMax) {\n            intervalScaleProto.niceExtent.call(this, splitNumber, fixMin, fixMax);\n\n            var originalScale = this._originalScale;\n            originalScale.__fixMin = fixMin;\n            originalScale.__fixMax = fixMax;\n        }\n\n    });\n\n    zrUtil.each(['contain', 'normalize'], function (methodName) {\n        LogScale.prototype[methodName] = function (val) {\n            val = mathLog(val) / mathLog(this.base);\n            return scaleProto[methodName].call(this, val);\n        };\n    });\n\n    LogScale.create = function () {\n        return new LogScale();\n    };\n\n    function fixRoundingError(val, originalVal) {\n        return roundingErrorFix(val, getPrecisionSafe(originalVal));\n    }\n\n    module.exports = LogScale;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTc4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL3NjYWxlL0xvZy5qcz8yNmE5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogTG9nIHNjYWxlXG4gKiBAbW9kdWxlIGVjaGFydHMvc2NhbGUvTG9nXG4gKi9cblxuXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuICAgIHZhciBTY2FsZSA9IHJlcXVpcmUoJy4vU2NhbGUnKTtcbiAgICB2YXIgbnVtYmVyVXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvbnVtYmVyJyk7XG5cbiAgICAvLyBVc2Ugc29tZSBtZXRob2Qgb2YgSW50ZXJ2YWxTY2FsZVxuICAgIHZhciBJbnRlcnZhbFNjYWxlID0gcmVxdWlyZSgnLi9JbnRlcnZhbCcpO1xuXG4gICAgdmFyIHNjYWxlUHJvdG8gPSBTY2FsZS5wcm90b3R5cGU7XG4gICAgdmFyIGludGVydmFsU2NhbGVQcm90byA9IEludGVydmFsU2NhbGUucHJvdG90eXBlO1xuXG4gICAgdmFyIGdldFByZWNpc2lvblNhZmUgPSBudW1iZXJVdGlsLmdldFByZWNpc2lvblNhZmU7XG4gICAgdmFyIHJvdW5kaW5nRXJyb3JGaXggPSBudW1iZXJVdGlsLnJvdW5kO1xuXG4gICAgdmFyIG1hdGhGbG9vciA9IE1hdGguZmxvb3I7XG4gICAgdmFyIG1hdGhDZWlsID0gTWF0aC5jZWlsO1xuICAgIHZhciBtYXRoUG93ID0gTWF0aC5wb3c7XG5cbiAgICB2YXIgbWF0aExvZyA9IE1hdGgubG9nO1xuXG4gICAgdmFyIExvZ1NjYWxlID0gU2NhbGUuZXh0ZW5kKHtcblxuICAgICAgICB0eXBlOiAnbG9nJyxcblxuICAgICAgICBiYXNlOiAxMCxcblxuICAgICAgICAkY29uc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIFNjYWxlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB0aGlzLl9vcmlnaW5hbFNjYWxlID0gbmV3IEludGVydmFsU2NhbGUoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gICAgICAgICAqL1xuICAgICAgICBnZXRUaWNrczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG9yaWdpbmFsU2NhbGUgPSB0aGlzLl9vcmlnaW5hbFNjYWxlO1xuICAgICAgICAgICAgdmFyIGV4dGVudCA9IHRoaXMuX2V4dGVudDtcbiAgICAgICAgICAgIHZhciBvcmlnaW5hbEV4dGVudCA9IG9yaWdpbmFsU2NhbGUuZ2V0RXh0ZW50KCk7XG5cbiAgICAgICAgICAgIHJldHVybiB6clV0aWwubWFwKGludGVydmFsU2NhbGVQcm90by5nZXRUaWNrcy5jYWxsKHRoaXMpLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBvd1ZhbCA9IG51bWJlclV0aWwucm91bmQobWF0aFBvdyh0aGlzLmJhc2UsIHZhbCkpO1xuXG4gICAgICAgICAgICAgICAgLy8gRml4ICM0MTU4XG4gICAgICAgICAgICAgICAgcG93VmFsID0gKHZhbCA9PT0gZXh0ZW50WzBdICYmIG9yaWdpbmFsU2NhbGUuX19maXhNaW4pXG4gICAgICAgICAgICAgICAgICAgID8gZml4Um91bmRpbmdFcnJvcihwb3dWYWwsIG9yaWdpbmFsRXh0ZW50WzBdKVxuICAgICAgICAgICAgICAgICAgICA6IHBvd1ZhbDtcbiAgICAgICAgICAgICAgICBwb3dWYWwgPSAodmFsID09PSBleHRlbnRbMV0gJiYgb3JpZ2luYWxTY2FsZS5fX2ZpeE1heClcbiAgICAgICAgICAgICAgICAgICAgPyBmaXhSb3VuZGluZ0Vycm9yKHBvd1ZhbCwgb3JpZ2luYWxFeHRlbnRbMV0pXG4gICAgICAgICAgICAgICAgICAgIDogcG93VmFsO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvd1ZhbDtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsXG4gICAgICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIGdldExhYmVsOiBpbnRlcnZhbFNjYWxlUHJvdG8uZ2V0TGFiZWwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gdmFsXG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHNjYWxlOiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICB2YWwgPSBzY2FsZVByb3RvLnNjYWxlLmNhbGwodGhpcywgdmFsKTtcbiAgICAgICAgICAgIHJldHVybiBtYXRoUG93KHRoaXMuYmFzZSwgdmFsKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0XG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmRcbiAgICAgICAgICovXG4gICAgICAgIHNldEV4dGVudDogZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgICAgIHZhciBiYXNlID0gdGhpcy5iYXNlO1xuICAgICAgICAgICAgc3RhcnQgPSBtYXRoTG9nKHN0YXJ0KSAvIG1hdGhMb2coYmFzZSk7XG4gICAgICAgICAgICBlbmQgPSBtYXRoTG9nKGVuZCkgLyBtYXRoTG9nKGJhc2UpO1xuICAgICAgICAgICAgaW50ZXJ2YWxTY2FsZVByb3RvLnNldEV4dGVudC5jYWxsKHRoaXMsIHN0YXJ0LCBlbmQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IGVuZFxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0RXh0ZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYmFzZSA9IHRoaXMuYmFzZTtcbiAgICAgICAgICAgIHZhciBleHRlbnQgPSBzY2FsZVByb3RvLmdldEV4dGVudC5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgZXh0ZW50WzBdID0gbWF0aFBvdyhiYXNlLCBleHRlbnRbMF0pO1xuICAgICAgICAgICAgZXh0ZW50WzFdID0gbWF0aFBvdyhiYXNlLCBleHRlbnRbMV0pO1xuXG4gICAgICAgICAgICAvLyBGaXggIzQxNThcbiAgICAgICAgICAgIHZhciBvcmlnaW5hbFNjYWxlID0gdGhpcy5fb3JpZ2luYWxTY2FsZTtcbiAgICAgICAgICAgIHZhciBvcmlnaW5hbEV4dGVudCA9IG9yaWdpbmFsU2NhbGUuZ2V0RXh0ZW50KCk7XG4gICAgICAgICAgICBvcmlnaW5hbFNjYWxlLl9fZml4TWluICYmIChleHRlbnRbMF0gPSBmaXhSb3VuZGluZ0Vycm9yKGV4dGVudFswXSwgb3JpZ2luYWxFeHRlbnRbMF0pKTtcbiAgICAgICAgICAgIG9yaWdpbmFsU2NhbGUuX19maXhNYXggJiYgKGV4dGVudFsxXSA9IGZpeFJvdW5kaW5nRXJyb3IoZXh0ZW50WzFdLCBvcmlnaW5hbEV4dGVudFsxXSkpO1xuXG4gICAgICAgICAgICByZXR1cm4gZXh0ZW50O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gIHtBcnJheS48bnVtYmVyPn0gZXh0ZW50XG4gICAgICAgICAqL1xuICAgICAgICB1bmlvbkV4dGVudDogZnVuY3Rpb24gKGV4dGVudCkge1xuICAgICAgICAgICAgdGhpcy5fb3JpZ2luYWxTY2FsZS51bmlvbkV4dGVudChleHRlbnQpO1xuXG4gICAgICAgICAgICB2YXIgYmFzZSA9IHRoaXMuYmFzZTtcbiAgICAgICAgICAgIGV4dGVudFswXSA9IG1hdGhMb2coZXh0ZW50WzBdKSAvIG1hdGhMb2coYmFzZSk7XG4gICAgICAgICAgICBleHRlbnRbMV0gPSBtYXRoTG9nKGV4dGVudFsxXSkgLyBtYXRoTG9nKGJhc2UpO1xuICAgICAgICAgICAgc2NhbGVQcm90by51bmlvbkV4dGVudC5jYWxsKHRoaXMsIGV4dGVudCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICAgKi9cbiAgICAgICAgdW5pb25FeHRlbnRGcm9tRGF0YTogZnVuY3Rpb24gKGRhdGEsIGRpbSkge1xuICAgICAgICAgICAgdGhpcy51bmlvbkV4dGVudChkYXRhLmdldERhdGFFeHRlbnQoZGltLCB0cnVlLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbCA+IDA7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZSBpbnRlcnZhbCBhbmQgZXh0ZW50IG9mIGludGVydmFscyBmb3IgbmljZSB0aWNrc1xuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IFthcHByb3hUaWNrTnVtID0gMTBdIEdpdmVuIGFwcHJveCB0aWNrIG51bWJlclxuICAgICAgICAgKi9cbiAgICAgICAgbmljZVRpY2tzOiBmdW5jdGlvbiAoYXBwcm94VGlja051bSkge1xuICAgICAgICAgICAgYXBwcm94VGlja051bSA9IGFwcHJveFRpY2tOdW0gfHwgMTA7XG4gICAgICAgICAgICB2YXIgZXh0ZW50ID0gdGhpcy5fZXh0ZW50O1xuICAgICAgICAgICAgdmFyIHNwYW4gPSBleHRlbnRbMV0gLSBleHRlbnRbMF07XG4gICAgICAgICAgICBpZiAoc3BhbiA9PT0gSW5maW5pdHkgfHwgc3BhbiA8PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgaW50ZXJ2YWwgPSBudW1iZXJVdGlsLnF1YW50aXR5KHNwYW4pO1xuICAgICAgICAgICAgdmFyIGVyciA9IGFwcHJveFRpY2tOdW0gLyBzcGFuICogaW50ZXJ2YWw7XG5cbiAgICAgICAgICAgIC8vIEZpbHRlciB0aWNrcyB0byBnZXQgY2xvc2VyIHRvIHRoZSBkZXNpcmVkIGNvdW50LlxuICAgICAgICAgICAgaWYgKGVyciA8PSAwLjUpIHtcbiAgICAgICAgICAgICAgICBpbnRlcnZhbCAqPSAxMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSW50ZXJ2YWwgc2hvdWxkIGJlIGludGVnZXJcbiAgICAgICAgICAgIHdoaWxlICghaXNOYU4oaW50ZXJ2YWwpICYmIE1hdGguYWJzKGludGVydmFsKSA8IDEgJiYgTWF0aC5hYnMoaW50ZXJ2YWwpID4gMCkge1xuICAgICAgICAgICAgICAgIGludGVydmFsICo9IDEwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbmljZUV4dGVudCA9IFtcbiAgICAgICAgICAgICAgICBudW1iZXJVdGlsLnJvdW5kKG1hdGhDZWlsKGV4dGVudFswXSAvIGludGVydmFsKSAqIGludGVydmFsKSxcbiAgICAgICAgICAgICAgICBudW1iZXJVdGlsLnJvdW5kKG1hdGhGbG9vcihleHRlbnRbMV0gLyBpbnRlcnZhbCkgKiBpbnRlcnZhbClcbiAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgIHRoaXMuX2ludGVydmFsID0gaW50ZXJ2YWw7XG4gICAgICAgICAgICB0aGlzLl9uaWNlRXh0ZW50ID0gbmljZUV4dGVudDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogTmljZSBleHRlbnQuXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXBwcm94VGlja051bSA9IDEwXSBHaXZlbiBhcHByb3ggdGljayBudW1iZXJcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbZml4TWluPWZhbHNlXVxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmaXhNYXg9ZmFsc2VdXG4gICAgICAgICAqL1xuICAgICAgICBuaWNlRXh0ZW50OiBmdW5jdGlvbiAoc3BsaXROdW1iZXIsIGZpeE1pbiwgZml4TWF4KSB7XG4gICAgICAgICAgICBpbnRlcnZhbFNjYWxlUHJvdG8ubmljZUV4dGVudC5jYWxsKHRoaXMsIHNwbGl0TnVtYmVyLCBmaXhNaW4sIGZpeE1heCk7XG5cbiAgICAgICAgICAgIHZhciBvcmlnaW5hbFNjYWxlID0gdGhpcy5fb3JpZ2luYWxTY2FsZTtcbiAgICAgICAgICAgIG9yaWdpbmFsU2NhbGUuX19maXhNaW4gPSBmaXhNaW47XG4gICAgICAgICAgICBvcmlnaW5hbFNjYWxlLl9fZml4TWF4ID0gZml4TWF4O1xuICAgICAgICB9XG5cbiAgICB9KTtcblxuICAgIHpyVXRpbC5lYWNoKFsnY29udGFpbicsICdub3JtYWxpemUnXSwgZnVuY3Rpb24gKG1ldGhvZE5hbWUpIHtcbiAgICAgICAgTG9nU2NhbGUucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgdmFsID0gbWF0aExvZyh2YWwpIC8gbWF0aExvZyh0aGlzLmJhc2UpO1xuICAgICAgICAgICAgcmV0dXJuIHNjYWxlUHJvdG9bbWV0aG9kTmFtZV0uY2FsbCh0aGlzLCB2YWwpO1xuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgTG9nU2NhbGUuY3JlYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IExvZ1NjYWxlKCk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGZpeFJvdW5kaW5nRXJyb3IodmFsLCBvcmlnaW5hbFZhbCkge1xuICAgICAgICByZXR1cm4gcm91bmRpbmdFcnJvckZpeCh2YWwsIGdldFByZWNpc2lvblNhZmUob3JpZ2luYWxWYWwpKTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IExvZ1NjYWxlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvc2NhbGUvTG9nLmpzXG4vLyBtb2R1bGUgaWQgPSAxNzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 179 */
/* unknown exports provided */
/* all exports used */
/*!******************************!*\
  !*** ./lib/scale/Ordinal.js ***!
  \******************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Linear continuous scale\n * @module echarts/coord/scale/Ordinal\n *\n * http://en.wikipedia.org/wiki/Level_of_measurement\n */\n\n// FIXME only one data\n\n\n    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 0);\n    var Scale = __webpack_require__(/*! ./Scale */ 35);\n\n    var scaleProto = Scale.prototype;\n\n    var OrdinalScale = Scale.extend({\n\n        type: 'ordinal',\n\n        init: function (data, extent) {\n            this._data = data;\n            this._extent = extent || [0, data.length - 1];\n        },\n\n        parse: function (val) {\n            return typeof val === 'string'\n                ? zrUtil.indexOf(this._data, val)\n                // val might be float.\n                : Math.round(val);\n        },\n\n        contain: function (rank) {\n            rank = this.parse(rank);\n            return scaleProto.contain.call(this, rank)\n                && this._data[rank] != null;\n        },\n\n        /**\n         * Normalize given rank or name to linear [0, 1]\n         * @param {number|string} [val]\n         * @return {number}\n         */\n        normalize: function (val) {\n            return scaleProto.normalize.call(this, this.parse(val));\n        },\n\n        scale: function (val) {\n            return Math.round(scaleProto.scale.call(this, val));\n        },\n\n        /**\n         * @return {Array}\n         */\n        getTicks: function () {\n            var ticks = [];\n            var extent = this._extent;\n            var rank = extent[0];\n\n            while (rank <= extent[1]) {\n                ticks.push(rank);\n                rank++;\n            }\n\n            return ticks;\n        },\n\n        /**\n         * Get item on rank n\n         * @param {number} n\n         * @return {string}\n         */\n        getLabel: function (n) {\n            return this._data[n];\n        },\n\n        /**\n         * @return {number}\n         */\n        count: function () {\n            return this._extent[1] - this._extent[0] + 1;\n        },\n\n        /**\n         * @override\n         */\n        unionExtentFromData: function (data, dim) {\n            this.unionExtent(data.getDataExtent(dim, false));\n        },\n\n        niceTicks: zrUtil.noop,\n        niceExtent: zrUtil.noop\n    });\n\n    /**\n     * @return {module:echarts/scale/Time}\n     */\n    OrdinalScale.create = function () {\n        return new OrdinalScale();\n    };\n\n    module.exports = OrdinalScale;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTc5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL3NjYWxlL09yZGluYWwuanM/NGM0YiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIExpbmVhciBjb250aW51b3VzIHNjYWxlXG4gKiBAbW9kdWxlIGVjaGFydHMvY29vcmQvc2NhbGUvT3JkaW5hbFxuICpcbiAqIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGV2ZWxfb2ZfbWVhc3VyZW1lbnRcbiAqL1xuXG4vLyBGSVhNRSBvbmx5IG9uZSBkYXRhXG5cblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgU2NhbGUgPSByZXF1aXJlKCcuL1NjYWxlJyk7XG5cbiAgICB2YXIgc2NhbGVQcm90byA9IFNjYWxlLnByb3RvdHlwZTtcblxuICAgIHZhciBPcmRpbmFsU2NhbGUgPSBTY2FsZS5leHRlbmQoe1xuXG4gICAgICAgIHR5cGU6ICdvcmRpbmFsJyxcblxuICAgICAgICBpbml0OiBmdW5jdGlvbiAoZGF0YSwgZXh0ZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgICAgICAgICAgIHRoaXMuX2V4dGVudCA9IGV4dGVudCB8fCBbMCwgZGF0YS5sZW5ndGggLSAxXTtcbiAgICAgICAgfSxcblxuICAgICAgICBwYXJzZTogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgPyB6clV0aWwuaW5kZXhPZih0aGlzLl9kYXRhLCB2YWwpXG4gICAgICAgICAgICAgICAgLy8gdmFsIG1pZ2h0IGJlIGZsb2F0LlxuICAgICAgICAgICAgICAgIDogTWF0aC5yb3VuZCh2YWwpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNvbnRhaW46IGZ1bmN0aW9uIChyYW5rKSB7XG4gICAgICAgICAgICByYW5rID0gdGhpcy5wYXJzZShyYW5rKTtcbiAgICAgICAgICAgIHJldHVybiBzY2FsZVByb3RvLmNvbnRhaW4uY2FsbCh0aGlzLCByYW5rKVxuICAgICAgICAgICAgICAgICYmIHRoaXMuX2RhdGFbcmFua10gIT0gbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogTm9ybWFsaXplIGdpdmVuIHJhbmsgb3IgbmFtZSB0byBsaW5lYXIgWzAsIDFdXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW3ZhbF1cbiAgICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgbm9ybWFsaXplOiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NhbGVQcm90by5ub3JtYWxpemUuY2FsbCh0aGlzLCB0aGlzLnBhcnNlKHZhbCkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNjYWxlOiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChzY2FsZVByb3RvLnNjYWxlLmNhbGwodGhpcywgdmFsKSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0VGlja3M6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB0aWNrcyA9IFtdO1xuICAgICAgICAgICAgdmFyIGV4dGVudCA9IHRoaXMuX2V4dGVudDtcbiAgICAgICAgICAgIHZhciByYW5rID0gZXh0ZW50WzBdO1xuXG4gICAgICAgICAgICB3aGlsZSAocmFuayA8PSBleHRlbnRbMV0pIHtcbiAgICAgICAgICAgICAgICB0aWNrcy5wdXNoKHJhbmspO1xuICAgICAgICAgICAgICAgIHJhbmsrKztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRpY2tzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgaXRlbSBvbiByYW5rIG5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IG5cbiAgICAgICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0TGFiZWw6IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YVtuXTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgY291bnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9leHRlbnRbMV0gLSB0aGlzLl9leHRlbnRbMF0gKyAxO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAb3ZlcnJpZGVcbiAgICAgICAgICovXG4gICAgICAgIHVuaW9uRXh0ZW50RnJvbURhdGE6IGZ1bmN0aW9uIChkYXRhLCBkaW0pIHtcbiAgICAgICAgICAgIHRoaXMudW5pb25FeHRlbnQoZGF0YS5nZXREYXRhRXh0ZW50KGRpbSwgZmFsc2UpKTtcbiAgICAgICAgfSxcblxuICAgICAgICBuaWNlVGlja3M6IHpyVXRpbC5ub29wLFxuICAgICAgICBuaWNlRXh0ZW50OiB6clV0aWwubm9vcFxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7bW9kdWxlOmVjaGFydHMvc2NhbGUvVGltZX1cbiAgICAgKi9cbiAgICBPcmRpbmFsU2NhbGUuY3JlYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IE9yZGluYWxTY2FsZSgpO1xuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IE9yZGluYWxTY2FsZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL3NjYWxlL09yZGluYWwuanNcbi8vIG1vZHVsZSBpZCA9IDE3OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 180 */
/* unknown exports provided */
/* all exports used */
/*!***************************!*\
  !*** ./lib/scale/Time.js ***!
  \***************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Interval scale\n * @module echarts/coord/scale/Time\n */\n\n\n\n    // [About UTC and local time zone]:\n    // In most cases, `number.parseDate` will treat input data string as local time\n    // (except time zone is specified in time string). And `format.formateTime` returns\n    // local time by default. option.useUTC is false by default. This design have\n    // concidered these common case:\n    // (1) Time that is persistent in server is in UTC, but it is needed to be diplayed\n    // in local time by default.\n    // (2) By default, the input data string (e.g., '2011-01-02') should be displayed\n    // as its original time, without any time difference.\n\n    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 0);\n    var numberUtil = __webpack_require__(/*! ../util/number */ 3);\n    var formatUtil = __webpack_require__(/*! ../util/format */ 6);\n    var scaleHelper = __webpack_require__(/*! ./helper */ 71);\n\n    var IntervalScale = __webpack_require__(/*! ./Interval */ 42);\n\n    var intervalScaleProto = IntervalScale.prototype;\n\n    var mathCeil = Math.ceil;\n    var mathFloor = Math.floor;\n    var ONE_SECOND = 1000;\n    var ONE_MINUTE = ONE_SECOND * 60;\n    var ONE_HOUR = ONE_MINUTE * 60;\n    var ONE_DAY = ONE_HOUR * 24;\n\n    // FIXME 公用？\n    var bisect = function (a, x, lo, hi) {\n        while (lo < hi) {\n            var mid = lo + hi >>> 1;\n            if (a[mid][2] < x) {\n                lo = mid + 1;\n            }\n            else {\n                hi  = mid;\n            }\n        }\n        return lo;\n    };\n\n    /**\n     * @alias module:echarts/coord/scale/Time\n     * @constructor\n     */\n    var TimeScale = IntervalScale.extend({\n        type: 'time',\n\n        // Overwrite\n        getLabel: function (val) {\n            var stepLvl = this._stepLvl;\n\n            var date = new Date(val);\n\n            return formatUtil.formatTime(stepLvl[0], date, this.getSetting('useUTC'));\n        },\n\n        // Overwrite\n        niceExtent: function (approxTickNum, fixMin, fixMax) {\n            var extent = this._extent;\n            // If extent start and end are same, expand them\n            if (extent[0] === extent[1]) {\n                // Expand extent\n                extent[0] -= ONE_DAY;\n                extent[1] += ONE_DAY;\n            }\n            // If there are no data and extent are [Infinity, -Infinity]\n            if (extent[1] === -Infinity && extent[0] === Infinity) {\n                var d = new Date();\n                extent[1] = new Date(d.getFullYear(), d.getMonth(), d.getDate());\n                extent[0] = extent[1] - ONE_DAY;\n            }\n\n            this.niceTicks(approxTickNum);\n\n            // var extent = this._extent;\n            var interval = this._interval;\n\n            if (!fixMin) {\n                extent[0] = numberUtil.round(mathFloor(extent[0] / interval) * interval);\n            }\n            if (!fixMax) {\n                extent[1] = numberUtil.round(mathCeil(extent[1] / interval) * interval);\n            }\n        },\n\n        // Overwrite\n        niceTicks: function (approxTickNum) {\n            var timezoneOffset = this.getSetting('useUTC')\n                ? 0 : numberUtil.getTimezoneOffset() * 60 * 1000;\n            approxTickNum = approxTickNum || 10;\n\n            var extent = this._extent;\n            var span = extent[1] - extent[0];\n            var approxInterval = span / approxTickNum;\n            var scaleLevelsLen = scaleLevels.length;\n            var idx = bisect(scaleLevels, approxInterval, 0, scaleLevelsLen);\n\n            var level = scaleLevels[Math.min(idx, scaleLevelsLen - 1)];\n            var interval = level[2];\n            // Same with interval scale if span is much larger than 1 year\n            if (level[0] === 'year') {\n                var yearSpan = span / interval;\n\n                // From \"Nice Numbers for Graph Labels\" of Graphic Gems\n                // var niceYearSpan = numberUtil.nice(yearSpan, false);\n                var yearStep = numberUtil.nice(yearSpan / approxTickNum, true);\n\n                interval *= yearStep;\n            }\n\n            var niceExtent = [\n                Math.round(mathCeil((extent[0] - timezoneOffset) / interval) * interval + timezoneOffset),\n                Math.round(mathFloor((extent[1] - timezoneOffset)/ interval) * interval + timezoneOffset)\n            ];\n\n            scaleHelper.fixExtent(niceExtent, extent);\n\n            this._stepLvl = level;\n            // Interval will be used in getTicks\n            this._interval = interval;\n            this._niceExtent = niceExtent;\n        },\n\n        parse: function (val) {\n            // val might be float.\n            return +numberUtil.parseDate(val);\n        }\n    });\n\n    zrUtil.each(['contain', 'normalize'], function (methodName) {\n        TimeScale.prototype[methodName] = function (val) {\n            return intervalScaleProto[methodName].call(this, this.parse(val));\n        };\n    });\n\n    // Steps from d3\n    var scaleLevels = [\n        // Format       step    interval\n        ['hh:mm:ss',    1,      ONE_SECOND],           // 1s\n        ['hh:mm:ss',    5,      ONE_SECOND * 5],       // 5s\n        ['hh:mm:ss',    10,     ONE_SECOND * 10],      // 10s\n        ['hh:mm:ss',    15,     ONE_SECOND * 15],      // 15s\n        ['hh:mm:ss',    30,     ONE_SECOND * 30],      // 30s\n        ['hh:mm\\nMM-dd',1,      ONE_MINUTE],          // 1m\n        ['hh:mm\\nMM-dd',5,      ONE_MINUTE * 5],      // 5m\n        ['hh:mm\\nMM-dd',10,     ONE_MINUTE * 10],     // 10m\n        ['hh:mm\\nMM-dd',15,     ONE_MINUTE * 15],     // 15m\n        ['hh:mm\\nMM-dd',30,     ONE_MINUTE * 30],     // 30m\n        ['hh:mm\\nMM-dd',1,      ONE_HOUR],        // 1h\n        ['hh:mm\\nMM-dd',2,      ONE_HOUR * 2],    // 2h\n        ['hh:mm\\nMM-dd',6,      ONE_HOUR * 6],    // 6h\n        ['hh:mm\\nMM-dd',12,     ONE_HOUR * 12],   // 12h\n        ['MM-dd\\nyyyy', 1,      ONE_DAY],   // 1d\n        ['week',        7,      ONE_DAY * 7],        // 7d\n        ['month',       1,      ONE_DAY * 31],       // 1M\n        ['quarter',     3,      ONE_DAY * 380 / 4],  // 3M\n        ['half-year',   6,      ONE_DAY * 380 / 2],  // 6M\n        ['year',        1,      ONE_DAY * 380]       // 1Y\n    ];\n\n    /**\n     * @param {module:echarts/model/Model}\n     * @return {module:echarts/scale/Time}\n     */\n    TimeScale.create = function (model) {\n        return new TimeScale({useUTC: model.ecModel.get('useUTC')});\n    };\n\n    module.exports = TimeScale;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTgwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL3NjYWxlL1RpbWUuanM/NDk1ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEludGVydmFsIHNjYWxlXG4gKiBAbW9kdWxlIGVjaGFydHMvY29vcmQvc2NhbGUvVGltZVxuICovXG5cblxuXG4gICAgLy8gW0Fib3V0IFVUQyBhbmQgbG9jYWwgdGltZSB6b25lXTpcbiAgICAvLyBJbiBtb3N0IGNhc2VzLCBgbnVtYmVyLnBhcnNlRGF0ZWAgd2lsbCB0cmVhdCBpbnB1dCBkYXRhIHN0cmluZyBhcyBsb2NhbCB0aW1lXG4gICAgLy8gKGV4Y2VwdCB0aW1lIHpvbmUgaXMgc3BlY2lmaWVkIGluIHRpbWUgc3RyaW5nKS4gQW5kIGBmb3JtYXQuZm9ybWF0ZVRpbWVgIHJldHVybnNcbiAgICAvLyBsb2NhbCB0aW1lIGJ5IGRlZmF1bHQuIG9wdGlvbi51c2VVVEMgaXMgZmFsc2UgYnkgZGVmYXVsdC4gVGhpcyBkZXNpZ24gaGF2ZVxuICAgIC8vIGNvbmNpZGVyZWQgdGhlc2UgY29tbW9uIGNhc2U6XG4gICAgLy8gKDEpIFRpbWUgdGhhdCBpcyBwZXJzaXN0ZW50IGluIHNlcnZlciBpcyBpbiBVVEMsIGJ1dCBpdCBpcyBuZWVkZWQgdG8gYmUgZGlwbGF5ZWRcbiAgICAvLyBpbiBsb2NhbCB0aW1lIGJ5IGRlZmF1bHQuXG4gICAgLy8gKDIpIEJ5IGRlZmF1bHQsIHRoZSBpbnB1dCBkYXRhIHN0cmluZyAoZS5nLiwgJzIwMTEtMDEtMDInKSBzaG91bGQgYmUgZGlzcGxheWVkXG4gICAgLy8gYXMgaXRzIG9yaWdpbmFsIHRpbWUsIHdpdGhvdXQgYW55IHRpbWUgZGlmZmVyZW5jZS5cblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgbnVtYmVyVXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvbnVtYmVyJyk7XG4gICAgdmFyIGZvcm1hdFV0aWwgPSByZXF1aXJlKCcuLi91dGlsL2Zvcm1hdCcpO1xuICAgIHZhciBzY2FsZUhlbHBlciA9IHJlcXVpcmUoJy4vaGVscGVyJyk7XG5cbiAgICB2YXIgSW50ZXJ2YWxTY2FsZSA9IHJlcXVpcmUoJy4vSW50ZXJ2YWwnKTtcblxuICAgIHZhciBpbnRlcnZhbFNjYWxlUHJvdG8gPSBJbnRlcnZhbFNjYWxlLnByb3RvdHlwZTtcblxuICAgIHZhciBtYXRoQ2VpbCA9IE1hdGguY2VpbDtcbiAgICB2YXIgbWF0aEZsb29yID0gTWF0aC5mbG9vcjtcbiAgICB2YXIgT05FX1NFQ09ORCA9IDEwMDA7XG4gICAgdmFyIE9ORV9NSU5VVEUgPSBPTkVfU0VDT05EICogNjA7XG4gICAgdmFyIE9ORV9IT1VSID0gT05FX01JTlVURSAqIDYwO1xuICAgIHZhciBPTkVfREFZID0gT05FX0hPVVIgKiAyNDtcblxuICAgIC8vIEZJWE1FIOWFrOeUqO+8n1xuICAgIHZhciBiaXNlY3QgPSBmdW5jdGlvbiAoYSwgeCwgbG8sIGhpKSB7XG4gICAgICAgIHdoaWxlIChsbyA8IGhpKSB7XG4gICAgICAgICAgICB2YXIgbWlkID0gbG8gKyBoaSA+Pj4gMTtcbiAgICAgICAgICAgIGlmIChhW21pZF1bMl0gPCB4KSB7XG4gICAgICAgICAgICAgICAgbG8gPSBtaWQgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaGkgID0gbWlkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsbztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGFsaWFzIG1vZHVsZTplY2hhcnRzL2Nvb3JkL3NjYWxlL1RpbWVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICB2YXIgVGltZVNjYWxlID0gSW50ZXJ2YWxTY2FsZS5leHRlbmQoe1xuICAgICAgICB0eXBlOiAndGltZScsXG5cbiAgICAgICAgLy8gT3ZlcndyaXRlXG4gICAgICAgIGdldExhYmVsOiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICB2YXIgc3RlcEx2bCA9IHRoaXMuX3N0ZXBMdmw7XG5cbiAgICAgICAgICAgIHZhciBkYXRlID0gbmV3IERhdGUodmFsKTtcblxuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdFV0aWwuZm9ybWF0VGltZShzdGVwTHZsWzBdLCBkYXRlLCB0aGlzLmdldFNldHRpbmcoJ3VzZVVUQycpKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBPdmVyd3JpdGVcbiAgICAgICAgbmljZUV4dGVudDogZnVuY3Rpb24gKGFwcHJveFRpY2tOdW0sIGZpeE1pbiwgZml4TWF4KSB7XG4gICAgICAgICAgICB2YXIgZXh0ZW50ID0gdGhpcy5fZXh0ZW50O1xuICAgICAgICAgICAgLy8gSWYgZXh0ZW50IHN0YXJ0IGFuZCBlbmQgYXJlIHNhbWUsIGV4cGFuZCB0aGVtXG4gICAgICAgICAgICBpZiAoZXh0ZW50WzBdID09PSBleHRlbnRbMV0pIHtcbiAgICAgICAgICAgICAgICAvLyBFeHBhbmQgZXh0ZW50XG4gICAgICAgICAgICAgICAgZXh0ZW50WzBdIC09IE9ORV9EQVk7XG4gICAgICAgICAgICAgICAgZXh0ZW50WzFdICs9IE9ORV9EQVk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gZGF0YSBhbmQgZXh0ZW50IGFyZSBbSW5maW5pdHksIC1JbmZpbml0eV1cbiAgICAgICAgICAgIGlmIChleHRlbnRbMV0gPT09IC1JbmZpbml0eSAmJiBleHRlbnRbMF0gPT09IEluZmluaXR5KSB7XG4gICAgICAgICAgICAgICAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgICAgIGV4dGVudFsxXSA9IG5ldyBEYXRlKGQuZ2V0RnVsbFllYXIoKSwgZC5nZXRNb250aCgpLCBkLmdldERhdGUoKSk7XG4gICAgICAgICAgICAgICAgZXh0ZW50WzBdID0gZXh0ZW50WzFdIC0gT05FX0RBWTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5uaWNlVGlja3MoYXBwcm94VGlja051bSk7XG5cbiAgICAgICAgICAgIC8vIHZhciBleHRlbnQgPSB0aGlzLl9leHRlbnQ7XG4gICAgICAgICAgICB2YXIgaW50ZXJ2YWwgPSB0aGlzLl9pbnRlcnZhbDtcblxuICAgICAgICAgICAgaWYgKCFmaXhNaW4pIHtcbiAgICAgICAgICAgICAgICBleHRlbnRbMF0gPSBudW1iZXJVdGlsLnJvdW5kKG1hdGhGbG9vcihleHRlbnRbMF0gLyBpbnRlcnZhbCkgKiBpbnRlcnZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWZpeE1heCkge1xuICAgICAgICAgICAgICAgIGV4dGVudFsxXSA9IG51bWJlclV0aWwucm91bmQobWF0aENlaWwoZXh0ZW50WzFdIC8gaW50ZXJ2YWwpICogaW50ZXJ2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIE92ZXJ3cml0ZVxuICAgICAgICBuaWNlVGlja3M6IGZ1bmN0aW9uIChhcHByb3hUaWNrTnVtKSB7XG4gICAgICAgICAgICB2YXIgdGltZXpvbmVPZmZzZXQgPSB0aGlzLmdldFNldHRpbmcoJ3VzZVVUQycpXG4gICAgICAgICAgICAgICAgPyAwIDogbnVtYmVyVXRpbC5nZXRUaW1lem9uZU9mZnNldCgpICogNjAgKiAxMDAwO1xuICAgICAgICAgICAgYXBwcm94VGlja051bSA9IGFwcHJveFRpY2tOdW0gfHwgMTA7XG5cbiAgICAgICAgICAgIHZhciBleHRlbnQgPSB0aGlzLl9leHRlbnQ7XG4gICAgICAgICAgICB2YXIgc3BhbiA9IGV4dGVudFsxXSAtIGV4dGVudFswXTtcbiAgICAgICAgICAgIHZhciBhcHByb3hJbnRlcnZhbCA9IHNwYW4gLyBhcHByb3hUaWNrTnVtO1xuICAgICAgICAgICAgdmFyIHNjYWxlTGV2ZWxzTGVuID0gc2NhbGVMZXZlbHMubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGlkeCA9IGJpc2VjdChzY2FsZUxldmVscywgYXBwcm94SW50ZXJ2YWwsIDAsIHNjYWxlTGV2ZWxzTGVuKTtcblxuICAgICAgICAgICAgdmFyIGxldmVsID0gc2NhbGVMZXZlbHNbTWF0aC5taW4oaWR4LCBzY2FsZUxldmVsc0xlbiAtIDEpXTtcbiAgICAgICAgICAgIHZhciBpbnRlcnZhbCA9IGxldmVsWzJdO1xuICAgICAgICAgICAgLy8gU2FtZSB3aXRoIGludGVydmFsIHNjYWxlIGlmIHNwYW4gaXMgbXVjaCBsYXJnZXIgdGhhbiAxIHllYXJcbiAgICAgICAgICAgIGlmIChsZXZlbFswXSA9PT0gJ3llYXInKSB7XG4gICAgICAgICAgICAgICAgdmFyIHllYXJTcGFuID0gc3BhbiAvIGludGVydmFsO1xuXG4gICAgICAgICAgICAgICAgLy8gRnJvbSBcIk5pY2UgTnVtYmVycyBmb3IgR3JhcGggTGFiZWxzXCIgb2YgR3JhcGhpYyBHZW1zXG4gICAgICAgICAgICAgICAgLy8gdmFyIG5pY2VZZWFyU3BhbiA9IG51bWJlclV0aWwubmljZSh5ZWFyU3BhbiwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIHZhciB5ZWFyU3RlcCA9IG51bWJlclV0aWwubmljZSh5ZWFyU3BhbiAvIGFwcHJveFRpY2tOdW0sIHRydWUpO1xuXG4gICAgICAgICAgICAgICAgaW50ZXJ2YWwgKj0geWVhclN0ZXA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBuaWNlRXh0ZW50ID0gW1xuICAgICAgICAgICAgICAgIE1hdGgucm91bmQobWF0aENlaWwoKGV4dGVudFswXSAtIHRpbWV6b25lT2Zmc2V0KSAvIGludGVydmFsKSAqIGludGVydmFsICsgdGltZXpvbmVPZmZzZXQpLFxuICAgICAgICAgICAgICAgIE1hdGgucm91bmQobWF0aEZsb29yKChleHRlbnRbMV0gLSB0aW1lem9uZU9mZnNldCkvIGludGVydmFsKSAqIGludGVydmFsICsgdGltZXpvbmVPZmZzZXQpXG4gICAgICAgICAgICBdO1xuXG4gICAgICAgICAgICBzY2FsZUhlbHBlci5maXhFeHRlbnQobmljZUV4dGVudCwgZXh0ZW50KTtcblxuICAgICAgICAgICAgdGhpcy5fc3RlcEx2bCA9IGxldmVsO1xuICAgICAgICAgICAgLy8gSW50ZXJ2YWwgd2lsbCBiZSB1c2VkIGluIGdldFRpY2tzXG4gICAgICAgICAgICB0aGlzLl9pbnRlcnZhbCA9IGludGVydmFsO1xuICAgICAgICAgICAgdGhpcy5fbmljZUV4dGVudCA9IG5pY2VFeHRlbnQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcGFyc2U6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIC8vIHZhbCBtaWdodCBiZSBmbG9hdC5cbiAgICAgICAgICAgIHJldHVybiArbnVtYmVyVXRpbC5wYXJzZURhdGUodmFsKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgenJVdGlsLmVhY2goWydjb250YWluJywgJ25vcm1hbGl6ZSddLCBmdW5jdGlvbiAobWV0aG9kTmFtZSkge1xuICAgICAgICBUaW1lU2NhbGUucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIGludGVydmFsU2NhbGVQcm90b1ttZXRob2ROYW1lXS5jYWxsKHRoaXMsIHRoaXMucGFyc2UodmFsKSk7XG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvLyBTdGVwcyBmcm9tIGQzXG4gICAgdmFyIHNjYWxlTGV2ZWxzID0gW1xuICAgICAgICAvLyBGb3JtYXQgICAgICAgc3RlcCAgICBpbnRlcnZhbFxuICAgICAgICBbJ2hoOm1tOnNzJywgICAgMSwgICAgICBPTkVfU0VDT05EXSwgICAgICAgICAgIC8vIDFzXG4gICAgICAgIFsnaGg6bW06c3MnLCAgICA1LCAgICAgIE9ORV9TRUNPTkQgKiA1XSwgICAgICAgLy8gNXNcbiAgICAgICAgWydoaDptbTpzcycsICAgIDEwLCAgICAgT05FX1NFQ09ORCAqIDEwXSwgICAgICAvLyAxMHNcbiAgICAgICAgWydoaDptbTpzcycsICAgIDE1LCAgICAgT05FX1NFQ09ORCAqIDE1XSwgICAgICAvLyAxNXNcbiAgICAgICAgWydoaDptbTpzcycsICAgIDMwLCAgICAgT05FX1NFQ09ORCAqIDMwXSwgICAgICAvLyAzMHNcbiAgICAgICAgWydoaDptbVxcbk1NLWRkJywxLCAgICAgIE9ORV9NSU5VVEVdLCAgICAgICAgICAvLyAxbVxuICAgICAgICBbJ2hoOm1tXFxuTU0tZGQnLDUsICAgICAgT05FX01JTlVURSAqIDVdLCAgICAgIC8vIDVtXG4gICAgICAgIFsnaGg6bW1cXG5NTS1kZCcsMTAsICAgICBPTkVfTUlOVVRFICogMTBdLCAgICAgLy8gMTBtXG4gICAgICAgIFsnaGg6bW1cXG5NTS1kZCcsMTUsICAgICBPTkVfTUlOVVRFICogMTVdLCAgICAgLy8gMTVtXG4gICAgICAgIFsnaGg6bW1cXG5NTS1kZCcsMzAsICAgICBPTkVfTUlOVVRFICogMzBdLCAgICAgLy8gMzBtXG4gICAgICAgIFsnaGg6bW1cXG5NTS1kZCcsMSwgICAgICBPTkVfSE9VUl0sICAgICAgICAvLyAxaFxuICAgICAgICBbJ2hoOm1tXFxuTU0tZGQnLDIsICAgICAgT05FX0hPVVIgKiAyXSwgICAgLy8gMmhcbiAgICAgICAgWydoaDptbVxcbk1NLWRkJyw2LCAgICAgIE9ORV9IT1VSICogNl0sICAgIC8vIDZoXG4gICAgICAgIFsnaGg6bW1cXG5NTS1kZCcsMTIsICAgICBPTkVfSE9VUiAqIDEyXSwgICAvLyAxMmhcbiAgICAgICAgWydNTS1kZFxcbnl5eXknLCAxLCAgICAgIE9ORV9EQVldLCAgIC8vIDFkXG4gICAgICAgIFsnd2VlaycsICAgICAgICA3LCAgICAgIE9ORV9EQVkgKiA3XSwgICAgICAgIC8vIDdkXG4gICAgICAgIFsnbW9udGgnLCAgICAgICAxLCAgICAgIE9ORV9EQVkgKiAzMV0sICAgICAgIC8vIDFNXG4gICAgICAgIFsncXVhcnRlcicsICAgICAzLCAgICAgIE9ORV9EQVkgKiAzODAgLyA0XSwgIC8vIDNNXG4gICAgICAgIFsnaGFsZi15ZWFyJywgICA2LCAgICAgIE9ORV9EQVkgKiAzODAgLyAyXSwgIC8vIDZNXG4gICAgICAgIFsneWVhcicsICAgICAgICAxLCAgICAgIE9ORV9EQVkgKiAzODBdICAgICAgIC8vIDFZXG4gICAgXTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWx9XG4gICAgICogQHJldHVybiB7bW9kdWxlOmVjaGFydHMvc2NhbGUvVGltZX1cbiAgICAgKi9cbiAgICBUaW1lU2NhbGUuY3JlYXRlID0gZnVuY3Rpb24gKG1vZGVsKSB7XG4gICAgICAgIHJldHVybiBuZXcgVGltZVNjYWxlKHt1c2VVVEM6IG1vZGVsLmVjTW9kZWwuZ2V0KCd1c2VVVEMnKX0pO1xuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFRpbWVTY2FsZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL3NjYWxlL1RpbWUuanNcbi8vIG1vZHVsZSBpZCA9IDE4MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 181 */
/* unknown exports provided */
/* all exports used */
/*!***********************************!*\
  !*** ./lib/visual/seriesColor.js ***!
  \***********************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\n    var Gradient = __webpack_require__(/*! zrender/lib/graphic/Gradient */ 37);\n    module.exports = function (ecModel) {\n        function encodeColor(seriesModel) {\n            var colorAccessPath = (seriesModel.visualColorAccessPath || 'itemStyle.normal.color').split('.');\n            var data = seriesModel.getData();\n            var color = seriesModel.get(colorAccessPath) // Set in itemStyle\n                || seriesModel.getColorFromPalette(seriesModel.get('name'));  // Default color\n\n            // FIXME Set color function or use the platte color\n            data.setVisual('color', color);\n\n            // Only visible series has each data be visual encoded\n            if (!ecModel.isSeriesFiltered(seriesModel)) {\n                if (typeof color === 'function' && !(color instanceof Gradient)) {\n                    data.each(function (idx) {\n                        data.setItemVisual(\n                            idx, 'color', color(seriesModel.getDataParams(idx))\n                        );\n                    });\n                }\n\n                // itemStyle in each data item\n                data.each(function (idx) {\n                    var itemModel = data.getItemModel(idx);\n                    var color = itemModel.get(colorAccessPath, true);\n                    if (color != null) {\n                        data.setItemVisual(idx, 'color', color);\n                    }\n                });\n            }\n        }\n        ecModel.eachRawSeries(encodeColor);\n    };\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTgxLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL3Zpc3VhbC9zZXJpZXNDb2xvci5qcz8xY2Q2Il0sInNvdXJjZXNDb250ZW50IjpbIlxuICAgIHZhciBHcmFkaWVudCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2dyYXBoaWMvR3JhZGllbnQnKTtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChlY01vZGVsKSB7XG4gICAgICAgIGZ1bmN0aW9uIGVuY29kZUNvbG9yKHNlcmllc01vZGVsKSB7XG4gICAgICAgICAgICB2YXIgY29sb3JBY2Nlc3NQYXRoID0gKHNlcmllc01vZGVsLnZpc3VhbENvbG9yQWNjZXNzUGF0aCB8fCAnaXRlbVN0eWxlLm5vcm1hbC5jb2xvcicpLnNwbGl0KCcuJyk7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICAgICAgICAgIHZhciBjb2xvciA9IHNlcmllc01vZGVsLmdldChjb2xvckFjY2Vzc1BhdGgpIC8vIFNldCBpbiBpdGVtU3R5bGVcbiAgICAgICAgICAgICAgICB8fCBzZXJpZXNNb2RlbC5nZXRDb2xvckZyb21QYWxldHRlKHNlcmllc01vZGVsLmdldCgnbmFtZScpKTsgIC8vIERlZmF1bHQgY29sb3JcblxuICAgICAgICAgICAgLy8gRklYTUUgU2V0IGNvbG9yIGZ1bmN0aW9uIG9yIHVzZSB0aGUgcGxhdHRlIGNvbG9yXG4gICAgICAgICAgICBkYXRhLnNldFZpc3VhbCgnY29sb3InLCBjb2xvcik7XG5cbiAgICAgICAgICAgIC8vIE9ubHkgdmlzaWJsZSBzZXJpZXMgaGFzIGVhY2ggZGF0YSBiZSB2aXN1YWwgZW5jb2RlZFxuICAgICAgICAgICAgaWYgKCFlY01vZGVsLmlzU2VyaWVzRmlsdGVyZWQoc2VyaWVzTW9kZWwpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb2xvciA9PT0gJ2Z1bmN0aW9uJyAmJiAhKGNvbG9yIGluc3RhbmNlb2YgR3JhZGllbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEuZWFjaChmdW5jdGlvbiAoaWR4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnNldEl0ZW1WaXN1YWwoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWR4LCAnY29sb3InLCBjb2xvcihzZXJpZXNNb2RlbC5nZXREYXRhUGFyYW1zKGlkeCkpXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBpdGVtU3R5bGUgaW4gZWFjaCBkYXRhIGl0ZW1cbiAgICAgICAgICAgICAgICBkYXRhLmVhY2goZnVuY3Rpb24gKGlkeCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbU1vZGVsID0gZGF0YS5nZXRJdGVtTW9kZWwoaWR4KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbG9yID0gaXRlbU1vZGVsLmdldChjb2xvckFjY2Vzc1BhdGgsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29sb3IgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5zZXRJdGVtVmlzdWFsKGlkeCwgJ2NvbG9yJywgY29sb3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWNNb2RlbC5lYWNoUmF3U2VyaWVzKGVuY29kZUNvbG9yKTtcbiAgICB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvdmlzdWFsL3Nlcmllc0NvbG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAxODFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 182 */
/* unknown exports provided */
/* all exports used */
/*!*************************************************************!*\
  !*** /usr/local/nvm/v6.1.0/lib/~/webpack/buildin/global.js ***!
  \*************************************************************/
/***/ (function(module, exports) {

eval("var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTgyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy91c3IvbG9jYWwvbnZtL3Y2LjEuMC9saWIvfi93ZWJwYWNrL2J1aWxkaW4vZ2xvYmFsLmpzPzUyZjkiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGc7XHJcblxyXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxyXG5nID0gKGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzO1xyXG59KSgpO1xyXG5cclxudHJ5IHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcclxuXHRnID0gZyB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCkgfHwgKDEsZXZhbCkoXCJ0aGlzXCIpO1xyXG59IGNhdGNoKGUpIHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxyXG5cdGlmKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpXHJcblx0XHRnID0gd2luZG93O1xyXG59XHJcblxyXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXHJcbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXHJcbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL3Vzci9sb2NhbC9udm0vdjYuMS4wL2xpYi9+L3dlYnBhY2svYnVpbGRpbi9nbG9iYWwuanNcbi8vIG1vZHVsZSBpZCA9IDE4MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 183 */
/* unknown exports provided */
/* all exports used */
/*!*****************************************!*\
  !*** /home/yx/~/zrender/lib/vml/vml.js ***!
  \*****************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\n    __webpack_require__(/*! ./graphic */ 201);\n    __webpack_require__(/*! ../zrender */ 79).registerPainter('vml', __webpack_require__(/*! ./Painter */ 200));\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTgzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy9ob21lL3l4L34venJlbmRlci9saWIvdm1sL3ZtbC5qcz83MzJlIl0sInNvdXJjZXNDb250ZW50IjpbIlxuICAgIHJlcXVpcmUoJy4vZ3JhcGhpYycpO1xuICAgIHJlcXVpcmUoJy4uL3pyZW5kZXInKS5yZWdpc3RlclBhaW50ZXIoJ3ZtbCcsIHJlcXVpcmUoJy4vUGFpbnRlcicpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9ob21lL3l4L34venJlbmRlci9saWIvdm1sL3ZtbC5qc1xuLy8gbW9kdWxlIGlkID0gMTgzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 184 */
/* unknown exports provided */
/* all exports used */
/*!******************************!*\
  !*** ./lib/chart/scatter.js ***!
  \******************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 0);\n    var echarts = __webpack_require__(/*! ../echarts */ 1);\n\n    __webpack_require__(/*! ./scatter/ScatterSeries */ 204);\n    __webpack_require__(/*! ./scatter/ScatterView */ 205);\n\n    echarts.registerVisual(zrUtil.curry(\n        __webpack_require__(/*! ../visual/symbol */ 50), 'scatter', 'circle', null\n    ));\n    echarts.registerLayout(zrUtil.curry(\n        __webpack_require__(/*! ../layout/points */ 68), 'scatter'\n    ));\n\n    // In case developer forget to include grid component\n    __webpack_require__(/*! ../component/gridSimple */ 31);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTg0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2NoYXJ0L3NjYXR0ZXIuanM/MTZiYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgZWNoYXJ0cyA9IHJlcXVpcmUoJy4uL2VjaGFydHMnKTtcblxuICAgIHJlcXVpcmUoJy4vc2NhdHRlci9TY2F0dGVyU2VyaWVzJyk7XG4gICAgcmVxdWlyZSgnLi9zY2F0dGVyL1NjYXR0ZXJWaWV3Jyk7XG5cbiAgICBlY2hhcnRzLnJlZ2lzdGVyVmlzdWFsKHpyVXRpbC5jdXJyeShcbiAgICAgICAgcmVxdWlyZSgnLi4vdmlzdWFsL3N5bWJvbCcpLCAnc2NhdHRlcicsICdjaXJjbGUnLCBudWxsXG4gICAgKSk7XG4gICAgZWNoYXJ0cy5yZWdpc3RlckxheW91dCh6clV0aWwuY3VycnkoXG4gICAgICAgIHJlcXVpcmUoJy4uL2xheW91dC9wb2ludHMnKSwgJ3NjYXR0ZXInXG4gICAgKSk7XG5cbiAgICAvLyBJbiBjYXNlIGRldmVsb3BlciBmb3JnZXQgdG8gaW5jbHVkZSBncmlkIGNvbXBvbmVudFxuICAgIHJlcXVpcmUoJy4uL2NvbXBvbmVudC9ncmlkU2ltcGxlJyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9jaGFydC9zY2F0dGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxODRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 185 */
/* unknown exports provided */
/* all exports used */
/*!***********************************!*\
  !*** ./lib/component/dataZoom.js ***!
  \***********************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * DataZoom component entry\n */\n\n\n    __webpack_require__(/*! ./dataZoom/typeDefaulter */ 155);\n\n    __webpack_require__(/*! ./dataZoom/DataZoomModel */ 46);\n    __webpack_require__(/*! ./dataZoom/DataZoomView */ 47);\n\n    __webpack_require__(/*! ./dataZoom/SliderZoomModel */ 214);\n    __webpack_require__(/*! ./dataZoom/SliderZoomView */ 215);\n\n    __webpack_require__(/*! ./dataZoom/InsideZoomModel */ 210);\n    __webpack_require__(/*! ./dataZoom/InsideZoomView */ 211);\n\n    __webpack_require__(/*! ./dataZoom/dataZoomProcessor */ 153);\n    __webpack_require__(/*! ./dataZoom/dataZoomAction */ 152);\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTg1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2NvbXBvbmVudC9kYXRhWm9vbS5qcz8zNjAyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRGF0YVpvb20gY29tcG9uZW50IGVudHJ5XG4gKi9cblxuXG4gICAgcmVxdWlyZSgnLi9kYXRhWm9vbS90eXBlRGVmYXVsdGVyJyk7XG5cbiAgICByZXF1aXJlKCcuL2RhdGFab29tL0RhdGFab29tTW9kZWwnKTtcbiAgICByZXF1aXJlKCcuL2RhdGFab29tL0RhdGFab29tVmlldycpO1xuXG4gICAgcmVxdWlyZSgnLi9kYXRhWm9vbS9TbGlkZXJab29tTW9kZWwnKTtcbiAgICByZXF1aXJlKCcuL2RhdGFab29tL1NsaWRlclpvb21WaWV3Jyk7XG5cbiAgICByZXF1aXJlKCcuL2RhdGFab29tL0luc2lkZVpvb21Nb2RlbCcpO1xuICAgIHJlcXVpcmUoJy4vZGF0YVpvb20vSW5zaWRlWm9vbVZpZXcnKTtcblxuICAgIHJlcXVpcmUoJy4vZGF0YVpvb20vZGF0YVpvb21Qcm9jZXNzb3InKTtcbiAgICByZXF1aXJlKCcuL2RhdGFab29tL2RhdGFab29tQWN0aW9uJyk7XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2NvbXBvbmVudC9kYXRhWm9vbS5qc1xuLy8gbW9kdWxlIGlkID0gMTg1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 186 */
/* unknown exports provided */
/* all exports used */
/*!**********************************!*\
  !*** ./lib/component/graphic.js ***!
  \**********************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var echarts = __webpack_require__(/*! ../echarts */ 1);\n    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 0);\n    var modelUtil = __webpack_require__(/*! ../util/model */ 5);\n    var graphicUtil = __webpack_require__(/*! ../util/graphic */ 2);\n    var layoutUtil = __webpack_require__(/*! ../util/layout */ 11);\n\n    // -------------\n    // Preprocessor\n    // -------------\n\n    echarts.registerPreprocessor(function (option) {\n        var graphicOption = option.graphic;\n\n        // Convert\n        // {graphic: [{left: 10, type: 'circle'}, ...]}\n        // or\n        // {graphic: {left: 10, type: 'circle'}}\n        // to\n        // {graphic: [{elements: [{left: 10, type: 'circle'}, ...]}]}\n        if (zrUtil.isArray(graphicOption)) {\n            if (!graphicOption[0] || !graphicOption[0].elements) {\n                option.graphic = [{elements: graphicOption}];\n            }\n            else {\n                // Only one graphic instance can be instantiated. (We dont\n                // want that too many views are created in echarts._viewMap)\n                option.graphic = [option.graphic[0]];\n            }\n        }\n        else if (graphicOption && !graphicOption.elements) {\n            option.graphic = [{elements: [graphicOption]}];\n        }\n    });\n\n    // ------\n    // Model\n    // ------\n\n    var GraphicModel = echarts.extendComponentModel({\n\n        type: 'graphic',\n\n        defaultOption: {\n\n            // Extra properties for each elements:\n            //\n            // left/right/top/bottom: (like 12, '22%', 'center', default undefined)\n            //      If left/rigth is set, shape.x/shape.cx/position will not be used.\n            //      If top/bottom is set, shape.y/shape.cy/position will not be used.\n            //      This mechanism is useful when you want to position a group/element\n            //      against the right side or the center of this container.\n            //\n            // width/height: (can only be pixel value, default 0)\n            //      Only be used to specify contianer(group) size, if needed. And\n            //      can not be percentage value (like '33%'). See the reason in the\n            //      layout algorithm below.\n            //\n            // bounding: (enum: 'all' (default) | 'raw')\n            //      Specify how to calculate boundingRect when locating.\n            //      'all': Get uioned and transformed boundingRect\n            //          from both itself and its descendants.\n            //          This mode simplies confining a group of elements in the bounding\n            //          of their ancester container (e.g., using 'right: 0').\n            //      'raw': Only use the boundingRect of itself and before transformed.\n            //          This mode is similar to css behavior, which is useful when you\n            //          want an element to be able to overflow its container. (Consider\n            //          a rotated circle needs to be located in a corner.)\n\n            // Note: elements is always behind its ancestors in this elements array.\n            elements: [],\n            parentId: null\n        },\n\n        /**\n         * Save el options for the sake of the performance (only update modified graphics).\n         * The order is the same as those in option. (ancesters -> descendants)\n         *\n         * @private\n         * @type {Array.<Object>}\n         */\n        _elOptionsToUpdate: null,\n\n        /**\n         * @override\n         */\n        mergeOption: function (option) {\n            // Prevent default merge to elements\n            var elements = this.option.elements;\n            this.option.elements = null;\n\n            GraphicModel.superApply(this, 'mergeOption', arguments);\n\n            this.option.elements = elements;\n        },\n\n        /**\n         * @override\n         */\n        optionUpdated: function (newOption, isInit) {\n            var thisOption = this.option;\n            var newList = (isInit ? thisOption : newOption).elements;\n            var existList = thisOption.elements = isInit ? [] : thisOption.elements;\n\n            var flattenedList = [];\n            this._flatten(newList, flattenedList);\n\n            var mappingResult = modelUtil.mappingToExists(existList, flattenedList);\n            modelUtil.makeIdAndName(mappingResult);\n\n            // Clear elOptionsToUpdate\n            var elOptionsToUpdate = this._elOptionsToUpdate = [];\n\n            zrUtil.each(mappingResult, function (resultItem, index) {\n                var newElOption = resultItem.option;\n\n                if (true) {\n                    zrUtil.assert(\n                        zrUtil.isObject(newElOption) || resultItem.exist,\n                        'Empty graphic option definition'\n                    );\n                }\n\n                if (!newElOption) {\n                    return;\n                }\n\n                elOptionsToUpdate.push(newElOption);\n\n                setKeyInfoToNewElOption(resultItem, newElOption);\n\n                mergeNewElOptionToExist(existList, index, newElOption);\n\n                setLayoutInfoToExist(existList[index], newElOption);\n\n            }, this);\n\n            // Clean\n            for (var i = existList.length - 1; i >= 0; i--) {\n                if (existList[i] == null) {\n                    existList.splice(i, 1);\n                }\n                else {\n                    // $action should be volatile, otherwise option gotten from\n                    // `getOption` will contain unexpected $action.\n                    delete existList[i].$action;\n                }\n            }\n        },\n\n        /**\n         * Convert\n         * [{\n         *  type: 'group',\n         *  id: 'xx',\n         *  children: [{type: 'circle'}, {type: 'polygon'}]\n         * }]\n         * to\n         * [\n         *  {type: 'group', id: 'xx'},\n         *  {type: 'circle', parentId: 'xx'},\n         *  {type: 'polygon', parentId: 'xx'}\n         * ]\n         *\n         * @private\n         * @param {Array.<Object>} optionList option list\n         * @param {Array.<Object>} result result of flatten\n         * @param {Object} parentOption parent option\n         */\n        _flatten: function (optionList, result, parentOption) {\n            zrUtil.each(optionList, function (option) {\n                if (!option) {\n                    return;\n                }\n\n                if (parentOption) {\n                    option.parentOption = parentOption;\n                }\n\n                result.push(option);\n\n                var children = option.children;\n                if (option.type === 'group' && children) {\n                    this._flatten(children, result, option);\n                }\n                // Deleting for JSON output, and for not affecting group creation.\n                delete option.children;\n            }, this);\n        },\n\n        // FIXME\n        // Pass to view using payload? setOption has a payload?\n        useElOptionsToUpdate: function () {\n            var els = this._elOptionsToUpdate;\n            // Clear to avoid render duplicately when zooming.\n            this._elOptionsToUpdate = null;\n            return els;\n        }\n    });\n\n    // -----\n    // View\n    // -----\n\n    echarts.extendComponentView({\n\n        type: 'graphic',\n\n        /**\n         * @override\n         */\n        init: function (ecModel, api) {\n\n            /**\n             * @private\n             * @type {Object}\n             */\n            this._elMap = {};\n\n            /**\n             * @private\n             * @type {module:echarts/graphic/GraphicModel}\n             */\n            this._lastGraphicModel;\n        },\n\n        /**\n         * @override\n         */\n        render: function (graphicModel, ecModel, api) {\n\n            // Having leveraged between use cases and algorithm complexity, a very\n            // simple layout mechanism is used:\n            // The size(width/height) can be determined by itself or its parent (not\n            // implemented yet), but can not by its children. (Top-down travel)\n            // The location(x/y) can be determined by the bounding rect of itself\n            // (can including its descendants or not) and the size of its parent.\n            // (Bottom-up travel)\n\n            // When `chart.clear()` or `chart.setOption({...}, true)` with the same id,\n            // view will be reused.\n            if (graphicModel !== this._lastGraphicModel) {\n                this._clear();\n            }\n            this._lastGraphicModel = graphicModel;\n\n            this._updateElements(graphicModel, api);\n            this._relocate(graphicModel, api);\n        },\n\n        /**\n         * Update graphic elements.\n         *\n         * @private\n         * @param {Object} graphicModel graphic model\n         * @param {module:echarts/ExtensionAPI} api extension API\n         */\n        _updateElements: function (graphicModel, api) {\n            var elOptionsToUpdate = graphicModel.useElOptionsToUpdate();\n\n            if (!elOptionsToUpdate) {\n                return;\n            }\n\n            var elMap = this._elMap;\n            var rootGroup = this.group;\n\n            // Top-down tranverse to assign graphic settings to each elements.\n            zrUtil.each(elOptionsToUpdate, function (elOption) {\n                var $action = elOption.$action;\n                var id = elOption.id;\n                var existEl = elMap[id];\n                var parentId = elOption.parentId;\n                var targetElParent = parentId != null ? elMap[parentId] : rootGroup;\n\n                // In top/bottom mode, textVertical should not be used. And textBaseline\n                // should not be 'alphabetic', which cause inaccurately locating.\n                if (elOption.hv && elOption.hv[1] && elOption.type === 'text') {\n                    elOption.style = zrUtil.defaults({textBaseline: 'middle'}, elOption.style);\n                    elOption.style.textVerticalAlign = null;\n                }\n\n                // Remove unnecessary props to avoid potential problems.\n                var elOptionCleaned = getCleanedElOption(elOption);\n\n                // For simple, do not support parent change, otherwise reorder is needed.\n                if (true) {\n                    existEl && zrUtil.assert(\n                        targetElParent === existEl.parent,\n                        'Changing parent is not supported.'\n                    );\n                }\n\n                if (!$action || $action === 'merge') {\n                    existEl\n                        ? existEl.attr(elOptionCleaned)\n                        : createEl(id, targetElParent, elOptionCleaned, elMap);\n                }\n                else if ($action === 'replace') {\n                    removeEl(existEl, elMap);\n                    createEl(id, targetElParent, elOptionCleaned, elMap);\n                }\n                else if ($action === 'remove') {\n                    removeEl(existEl, elMap);\n                }\n\n                if (elMap[id]) {\n                    elMap[id].__ecGraphicWidth = elOption.width;\n                    elMap[id].__ecGraphicHeight = elOption.height;\n                }\n            });\n        },\n\n        /**\n         * Locate graphic elements.\n         *\n         * @private\n         * @param {Object} graphicModel graphic model\n         * @param {module:echarts/ExtensionAPI} api extension API\n         */\n        _relocate: function (graphicModel, api) {\n            var elOptions = graphicModel.option.elements;\n            var rootGroup = this.group;\n            var elMap = this._elMap;\n\n            // Bottom-up tranvese all elements (consider ec resize) to locate elements.\n            for (var i = elOptions.length - 1; i >= 0; i--) {\n                var elOption = elOptions[i];\n                var el = elMap[elOption.id];\n\n                if (!el) {\n                    continue;\n                }\n\n                var parentEl = el.parent;\n                var containerInfo = parentEl === rootGroup\n                    ? {\n                        width: api.getWidth(),\n                        height: api.getHeight()\n                    }\n                    : { // Like 'position:absolut' in css, default 0.\n                        width: parentEl.__ecGraphicWidth || 0,\n                        height: parentEl.__ecGraphicHeight || 0\n                    };\n\n                layoutUtil.positionElement(\n                    el, elOption, containerInfo, null,\n                    {hv: elOption.hv, boundingMode: elOption.bounding}\n                );\n            }\n        },\n\n        /**\n         * Clear all elements.\n         *\n         * @private\n         */\n        _clear: function () {\n            var elMap = this._elMap;\n            zrUtil.each(elMap, function (el) {\n                removeEl(el, elMap);\n            });\n            this._elMap = {};\n        },\n\n        /**\n         * @override\n         */\n        dispose: function () {\n            this._clear();\n        }\n    });\n\n    function createEl(id, targetElParent, elOption, elMap) {\n        var graphicType = elOption.type;\n\n        if (true) {\n            zrUtil.assert(graphicType, 'graphic type MUST be set');\n        }\n\n        var Clz = graphicUtil[graphicType.charAt(0).toUpperCase() + graphicType.slice(1)];\n\n        if (true) {\n            zrUtil.assert(Clz, 'graphic type can not be found');\n        }\n\n        var el = new Clz(elOption);\n        targetElParent.add(el);\n        elMap[id] = el;\n        el.__ecGraphicId = id;\n    }\n\n    function removeEl(existEl, elMap) {\n        var existElParent = existEl && existEl.parent;\n        if (existElParent) {\n            existEl.type === 'group' && existEl.traverse(function (el) {\n                removeEl(el, elMap);\n            });\n            delete elMap[existEl.__ecGraphicId];\n            existElParent.remove(existEl);\n        }\n    }\n\n    // Remove unnecessary props to avoid potential problems.\n    function getCleanedElOption(elOption) {\n        elOption = zrUtil.extend({}, elOption);\n        zrUtil.each(\n            ['id', 'parentId', '$action', 'hv', 'bounding'].concat(layoutUtil.LOCATION_PARAMS),\n            function (name) {\n                delete elOption[name];\n            }\n        );\n        return elOption;\n    }\n\n    function isSetLoc(obj, props) {\n        var isSet;\n        zrUtil.each(props, function (prop) {\n            obj[prop] != null && obj[prop] !== 'auto' && (isSet = true);\n        });\n        return isSet;\n    }\n\n    function setKeyInfoToNewElOption(resultItem, newElOption) {\n        var existElOption = resultItem.exist;\n\n        // Set id and type after id assigned.\n        newElOption.id = resultItem.keyInfo.id;\n        !newElOption.type && existElOption && (newElOption.type = existElOption.type);\n\n        // Set parent id if not specified\n        if (newElOption.parentId == null) {\n            var newElParentOption = newElOption.parentOption;\n            if (newElParentOption) {\n                newElOption.parentId = newElParentOption.id;\n            }\n            else if (existElOption) {\n                newElOption.parentId = existElOption.parentId;\n            }\n        }\n\n        // Clear\n        newElOption.parentOption = null;\n    }\n\n    function mergeNewElOptionToExist(existList, index, newElOption) {\n        // Update existing options, for `getOption` feature.\n        var newElOptCopy = zrUtil.extend({}, newElOption);\n        var existElOption = existList[index];\n\n        var $action = newElOption.$action || 'merge';\n        if ($action === 'merge') {\n            if (existElOption) {\n\n                if (true) {\n                    var newType = newElOption.type;\n                    zrUtil.assert(\n                        !newType || existElOption.type === newType,\n                        'Please set $action: \"replace\" to change `type`'\n                    );\n                }\n\n                // We can ensure that newElOptCopy and existElOption are not\n                // the same object, so `merge` will not change newElOptCopy.\n                zrUtil.merge(existElOption, newElOptCopy, true);\n                // Rigid body, use ignoreSize.\n                layoutUtil.mergeLayoutParam(existElOption, newElOptCopy, {ignoreSize: true});\n                // Will be used in render.\n                layoutUtil.copyLayoutParams(newElOption, existElOption);\n            }\n            else {\n                existList[index] = newElOptCopy;\n            }\n        }\n        else if ($action === 'replace') {\n            existList[index] = newElOptCopy;\n        }\n        else if ($action === 'remove') {\n            // null will be cleaned later.\n            existElOption && (existList[index] = null);\n        }\n    }\n\n    function setLayoutInfoToExist(existItem, newElOption) {\n        if (!existItem) {\n            return;\n        }\n        existItem.hv = newElOption.hv = [\n            // Rigid body, dont care `width`.\n            isSetLoc(newElOption, ['left', 'right']),\n            // Rigid body, dont care `height`.\n            isSetLoc(newElOption, ['top', 'bottom'])\n        ];\n        // Give default group size. Otherwise layout error may occur.\n        if (existItem.type === 'group') {\n            existItem.width == null && (existItem.width = newElOption.width = 0);\n            existItem.height == null && (existItem.height = newElOption.height = 0);\n        }\n    }\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTg2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2NvbXBvbmVudC9ncmFwaGljLmpzP2Q0ZjQiXSwic291cmNlc0NvbnRlbnQiOlsiXG5cbiAgICB2YXIgZWNoYXJ0cyA9IHJlcXVpcmUoJy4uL2VjaGFydHMnKTtcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG4gICAgdmFyIG1vZGVsVXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvbW9kZWwnKTtcbiAgICB2YXIgZ3JhcGhpY1V0aWwgPSByZXF1aXJlKCcuLi91dGlsL2dyYXBoaWMnKTtcbiAgICB2YXIgbGF5b3V0VXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvbGF5b3V0Jyk7XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tXG4gICAgLy8gUHJlcHJvY2Vzc29yXG4gICAgLy8gLS0tLS0tLS0tLS0tLVxuXG4gICAgZWNoYXJ0cy5yZWdpc3RlclByZXByb2Nlc3NvcihmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgICAgIHZhciBncmFwaGljT3B0aW9uID0gb3B0aW9uLmdyYXBoaWM7XG5cbiAgICAgICAgLy8gQ29udmVydFxuICAgICAgICAvLyB7Z3JhcGhpYzogW3tsZWZ0OiAxMCwgdHlwZTogJ2NpcmNsZSd9LCAuLi5dfVxuICAgICAgICAvLyBvclxuICAgICAgICAvLyB7Z3JhcGhpYzoge2xlZnQ6IDEwLCB0eXBlOiAnY2lyY2xlJ319XG4gICAgICAgIC8vIHRvXG4gICAgICAgIC8vIHtncmFwaGljOiBbe2VsZW1lbnRzOiBbe2xlZnQ6IDEwLCB0eXBlOiAnY2lyY2xlJ30sIC4uLl19XX1cbiAgICAgICAgaWYgKHpyVXRpbC5pc0FycmF5KGdyYXBoaWNPcHRpb24pKSB7XG4gICAgICAgICAgICBpZiAoIWdyYXBoaWNPcHRpb25bMF0gfHwgIWdyYXBoaWNPcHRpb25bMF0uZWxlbWVudHMpIHtcbiAgICAgICAgICAgICAgICBvcHRpb24uZ3JhcGhpYyA9IFt7ZWxlbWVudHM6IGdyYXBoaWNPcHRpb259XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE9ubHkgb25lIGdyYXBoaWMgaW5zdGFuY2UgY2FuIGJlIGluc3RhbnRpYXRlZC4gKFdlIGRvbnRcbiAgICAgICAgICAgICAgICAvLyB3YW50IHRoYXQgdG9vIG1hbnkgdmlld3MgYXJlIGNyZWF0ZWQgaW4gZWNoYXJ0cy5fdmlld01hcClcbiAgICAgICAgICAgICAgICBvcHRpb24uZ3JhcGhpYyA9IFtvcHRpb24uZ3JhcGhpY1swXV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZ3JhcGhpY09wdGlvbiAmJiAhZ3JhcGhpY09wdGlvbi5lbGVtZW50cykge1xuICAgICAgICAgICAgb3B0aW9uLmdyYXBoaWMgPSBbe2VsZW1lbnRzOiBbZ3JhcGhpY09wdGlvbl19XTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gLS0tLS0tXG4gICAgLy8gTW9kZWxcbiAgICAvLyAtLS0tLS1cblxuICAgIHZhciBHcmFwaGljTW9kZWwgPSBlY2hhcnRzLmV4dGVuZENvbXBvbmVudE1vZGVsKHtcblxuICAgICAgICB0eXBlOiAnZ3JhcGhpYycsXG5cbiAgICAgICAgZGVmYXVsdE9wdGlvbjoge1xuXG4gICAgICAgICAgICAvLyBFeHRyYSBwcm9wZXJ0aWVzIGZvciBlYWNoIGVsZW1lbnRzOlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIGxlZnQvcmlnaHQvdG9wL2JvdHRvbTogKGxpa2UgMTIsICcyMiUnLCAnY2VudGVyJywgZGVmYXVsdCB1bmRlZmluZWQpXG4gICAgICAgICAgICAvLyAgICAgIElmIGxlZnQvcmlndGggaXMgc2V0LCBzaGFwZS54L3NoYXBlLmN4L3Bvc2l0aW9uIHdpbGwgbm90IGJlIHVzZWQuXG4gICAgICAgICAgICAvLyAgICAgIElmIHRvcC9ib3R0b20gaXMgc2V0LCBzaGFwZS55L3NoYXBlLmN5L3Bvc2l0aW9uIHdpbGwgbm90IGJlIHVzZWQuXG4gICAgICAgICAgICAvLyAgICAgIFRoaXMgbWVjaGFuaXNtIGlzIHVzZWZ1bCB3aGVuIHlvdSB3YW50IHRvIHBvc2l0aW9uIGEgZ3JvdXAvZWxlbWVudFxuICAgICAgICAgICAgLy8gICAgICBhZ2FpbnN0IHRoZSByaWdodCBzaWRlIG9yIHRoZSBjZW50ZXIgb2YgdGhpcyBjb250YWluZXIuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gd2lkdGgvaGVpZ2h0OiAoY2FuIG9ubHkgYmUgcGl4ZWwgdmFsdWUsIGRlZmF1bHQgMClcbiAgICAgICAgICAgIC8vICAgICAgT25seSBiZSB1c2VkIHRvIHNwZWNpZnkgY29udGlhbmVyKGdyb3VwKSBzaXplLCBpZiBuZWVkZWQuIEFuZFxuICAgICAgICAgICAgLy8gICAgICBjYW4gbm90IGJlIHBlcmNlbnRhZ2UgdmFsdWUgKGxpa2UgJzMzJScpLiBTZWUgdGhlIHJlYXNvbiBpbiB0aGVcbiAgICAgICAgICAgIC8vICAgICAgbGF5b3V0IGFsZ29yaXRobSBiZWxvdy5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBib3VuZGluZzogKGVudW06ICdhbGwnIChkZWZhdWx0KSB8ICdyYXcnKVxuICAgICAgICAgICAgLy8gICAgICBTcGVjaWZ5IGhvdyB0byBjYWxjdWxhdGUgYm91bmRpbmdSZWN0IHdoZW4gbG9jYXRpbmcuXG4gICAgICAgICAgICAvLyAgICAgICdhbGwnOiBHZXQgdWlvbmVkIGFuZCB0cmFuc2Zvcm1lZCBib3VuZGluZ1JlY3RcbiAgICAgICAgICAgIC8vICAgICAgICAgIGZyb20gYm90aCBpdHNlbGYgYW5kIGl0cyBkZXNjZW5kYW50cy5cbiAgICAgICAgICAgIC8vICAgICAgICAgIFRoaXMgbW9kZSBzaW1wbGllcyBjb25maW5pbmcgYSBncm91cCBvZiBlbGVtZW50cyBpbiB0aGUgYm91bmRpbmdcbiAgICAgICAgICAgIC8vICAgICAgICAgIG9mIHRoZWlyIGFuY2VzdGVyIGNvbnRhaW5lciAoZS5nLiwgdXNpbmcgJ3JpZ2h0OiAwJykuXG4gICAgICAgICAgICAvLyAgICAgICdyYXcnOiBPbmx5IHVzZSB0aGUgYm91bmRpbmdSZWN0IG9mIGl0c2VsZiBhbmQgYmVmb3JlIHRyYW5zZm9ybWVkLlxuICAgICAgICAgICAgLy8gICAgICAgICAgVGhpcyBtb2RlIGlzIHNpbWlsYXIgdG8gY3NzIGJlaGF2aW9yLCB3aGljaCBpcyB1c2VmdWwgd2hlbiB5b3VcbiAgICAgICAgICAgIC8vICAgICAgICAgIHdhbnQgYW4gZWxlbWVudCB0byBiZSBhYmxlIHRvIG92ZXJmbG93IGl0cyBjb250YWluZXIuIChDb25zaWRlclxuICAgICAgICAgICAgLy8gICAgICAgICAgYSByb3RhdGVkIGNpcmNsZSBuZWVkcyB0byBiZSBsb2NhdGVkIGluIGEgY29ybmVyLilcblxuICAgICAgICAgICAgLy8gTm90ZTogZWxlbWVudHMgaXMgYWx3YXlzIGJlaGluZCBpdHMgYW5jZXN0b3JzIGluIHRoaXMgZWxlbWVudHMgYXJyYXkuXG4gICAgICAgICAgICBlbGVtZW50czogW10sXG4gICAgICAgICAgICBwYXJlbnRJZDogbnVsbFxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTYXZlIGVsIG9wdGlvbnMgZm9yIHRoZSBzYWtlIG9mIHRoZSBwZXJmb3JtYW5jZSAob25seSB1cGRhdGUgbW9kaWZpZWQgZ3JhcGhpY3MpLlxuICAgICAgICAgKiBUaGUgb3JkZXIgaXMgdGhlIHNhbWUgYXMgdGhvc2UgaW4gb3B0aW9uLiAoYW5jZXN0ZXJzIC0+IGRlc2NlbmRhbnRzKVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPE9iamVjdD59XG4gICAgICAgICAqL1xuICAgICAgICBfZWxPcHRpb25zVG9VcGRhdGU6IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICAgKi9cbiAgICAgICAgbWVyZ2VPcHRpb246IGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICAgICAgICAgIC8vIFByZXZlbnQgZGVmYXVsdCBtZXJnZSB0byBlbGVtZW50c1xuICAgICAgICAgICAgdmFyIGVsZW1lbnRzID0gdGhpcy5vcHRpb24uZWxlbWVudHM7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbi5lbGVtZW50cyA9IG51bGw7XG5cbiAgICAgICAgICAgIEdyYXBoaWNNb2RlbC5zdXBlckFwcGx5KHRoaXMsICdtZXJnZU9wdGlvbicsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIHRoaXMub3B0aW9uLmVsZW1lbnRzID0gZWxlbWVudHM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICAgKi9cbiAgICAgICAgb3B0aW9uVXBkYXRlZDogZnVuY3Rpb24gKG5ld09wdGlvbiwgaXNJbml0KSB7XG4gICAgICAgICAgICB2YXIgdGhpc09wdGlvbiA9IHRoaXMub3B0aW9uO1xuICAgICAgICAgICAgdmFyIG5ld0xpc3QgPSAoaXNJbml0ID8gdGhpc09wdGlvbiA6IG5ld09wdGlvbikuZWxlbWVudHM7XG4gICAgICAgICAgICB2YXIgZXhpc3RMaXN0ID0gdGhpc09wdGlvbi5lbGVtZW50cyA9IGlzSW5pdCA/IFtdIDogdGhpc09wdGlvbi5lbGVtZW50cztcblxuICAgICAgICAgICAgdmFyIGZsYXR0ZW5lZExpc3QgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2ZsYXR0ZW4obmV3TGlzdCwgZmxhdHRlbmVkTGlzdCk7XG5cbiAgICAgICAgICAgIHZhciBtYXBwaW5nUmVzdWx0ID0gbW9kZWxVdGlsLm1hcHBpbmdUb0V4aXN0cyhleGlzdExpc3QsIGZsYXR0ZW5lZExpc3QpO1xuICAgICAgICAgICAgbW9kZWxVdGlsLm1ha2VJZEFuZE5hbWUobWFwcGluZ1Jlc3VsdCk7XG5cbiAgICAgICAgICAgIC8vIENsZWFyIGVsT3B0aW9uc1RvVXBkYXRlXG4gICAgICAgICAgICB2YXIgZWxPcHRpb25zVG9VcGRhdGUgPSB0aGlzLl9lbE9wdGlvbnNUb1VwZGF0ZSA9IFtdO1xuXG4gICAgICAgICAgICB6clV0aWwuZWFjaChtYXBwaW5nUmVzdWx0LCBmdW5jdGlvbiAocmVzdWx0SXRlbSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV3RWxPcHRpb24gPSByZXN1bHRJdGVtLm9wdGlvbjtcblxuICAgICAgICAgICAgICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgICAgICAgICAgICAgIHpyVXRpbC5hc3NlcnQoXG4gICAgICAgICAgICAgICAgICAgICAgICB6clV0aWwuaXNPYmplY3QobmV3RWxPcHRpb24pIHx8IHJlc3VsdEl0ZW0uZXhpc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRW1wdHkgZ3JhcGhpYyBvcHRpb24gZGVmaW5pdGlvbidcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIW5ld0VsT3B0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBlbE9wdGlvbnNUb1VwZGF0ZS5wdXNoKG5ld0VsT3B0aW9uKTtcblxuICAgICAgICAgICAgICAgIHNldEtleUluZm9Ub05ld0VsT3B0aW9uKHJlc3VsdEl0ZW0sIG5ld0VsT3B0aW9uKTtcblxuICAgICAgICAgICAgICAgIG1lcmdlTmV3RWxPcHRpb25Ub0V4aXN0KGV4aXN0TGlzdCwgaW5kZXgsIG5ld0VsT3B0aW9uKTtcblxuICAgICAgICAgICAgICAgIHNldExheW91dEluZm9Ub0V4aXN0KGV4aXN0TGlzdFtpbmRleF0sIG5ld0VsT3B0aW9uKTtcblxuICAgICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgICAgIC8vIENsZWFuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gZXhpc3RMaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV4aXN0TGlzdFtpXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4aXN0TGlzdC5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyAkYWN0aW9uIHNob3VsZCBiZSB2b2xhdGlsZSwgb3RoZXJ3aXNlIG9wdGlvbiBnb3R0ZW4gZnJvbVxuICAgICAgICAgICAgICAgICAgICAvLyBgZ2V0T3B0aW9uYCB3aWxsIGNvbnRhaW4gdW5leHBlY3RlZCAkYWN0aW9uLlxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgZXhpc3RMaXN0W2ldLiRhY3Rpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0XG4gICAgICAgICAqIFt7XG4gICAgICAgICAqICB0eXBlOiAnZ3JvdXAnLFxuICAgICAgICAgKiAgaWQ6ICd4eCcsXG4gICAgICAgICAqICBjaGlsZHJlbjogW3t0eXBlOiAnY2lyY2xlJ30sIHt0eXBlOiAncG9seWdvbid9XVxuICAgICAgICAgKiB9XVxuICAgICAgICAgKiB0b1xuICAgICAgICAgKiBbXG4gICAgICAgICAqICB7dHlwZTogJ2dyb3VwJywgaWQ6ICd4eCd9LFxuICAgICAgICAgKiAge3R5cGU6ICdjaXJjbGUnLCBwYXJlbnRJZDogJ3h4J30sXG4gICAgICAgICAqICB7dHlwZTogJ3BvbHlnb24nLCBwYXJlbnRJZDogJ3h4J31cbiAgICAgICAgICogXVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5LjxPYmplY3Q+fSBvcHRpb25MaXN0IG9wdGlvbiBsaXN0XG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD59IHJlc3VsdCByZXN1bHQgb2YgZmxhdHRlblxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyZW50T3B0aW9uIHBhcmVudCBvcHRpb25cbiAgICAgICAgICovXG4gICAgICAgIF9mbGF0dGVuOiBmdW5jdGlvbiAob3B0aW9uTGlzdCwgcmVzdWx0LCBwYXJlbnRPcHRpb24pIHtcbiAgICAgICAgICAgIHpyVXRpbC5lYWNoKG9wdGlvbkxpc3QsIGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudE9wdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb24ucGFyZW50T3B0aW9uID0gcGFyZW50T3B0aW9uO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG9wdGlvbik7XG5cbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBvcHRpb24uY2hpbGRyZW47XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbi50eXBlID09PSAnZ3JvdXAnICYmIGNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZsYXR0ZW4oY2hpbGRyZW4sIHJlc3VsdCwgb3B0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gRGVsZXRpbmcgZm9yIEpTT04gb3V0cHV0LCBhbmQgZm9yIG5vdCBhZmZlY3RpbmcgZ3JvdXAgY3JlYXRpb24uXG4gICAgICAgICAgICAgICAgZGVsZXRlIG9wdGlvbi5jaGlsZHJlbjtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIEZJWE1FXG4gICAgICAgIC8vIFBhc3MgdG8gdmlldyB1c2luZyBwYXlsb2FkPyBzZXRPcHRpb24gaGFzIGEgcGF5bG9hZD9cbiAgICAgICAgdXNlRWxPcHRpb25zVG9VcGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBlbHMgPSB0aGlzLl9lbE9wdGlvbnNUb1VwZGF0ZTtcbiAgICAgICAgICAgIC8vIENsZWFyIHRvIGF2b2lkIHJlbmRlciBkdXBsaWNhdGVseSB3aGVuIHpvb21pbmcuXG4gICAgICAgICAgICB0aGlzLl9lbE9wdGlvbnNUb1VwZGF0ZSA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gZWxzO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyAtLS0tLVxuICAgIC8vIFZpZXdcbiAgICAvLyAtLS0tLVxuXG4gICAgZWNoYXJ0cy5leHRlbmRDb21wb25lbnRWaWV3KHtcblxuICAgICAgICB0eXBlOiAnZ3JhcGhpYycsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICAgKi9cbiAgICAgICAgaW5pdDogZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLl9lbE1hcCA9IHt9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgKiBAdHlwZSB7bW9kdWxlOmVjaGFydHMvZ3JhcGhpYy9HcmFwaGljTW9kZWx9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuX2xhc3RHcmFwaGljTW9kZWw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICAgKi9cbiAgICAgICAgcmVuZGVyOiBmdW5jdGlvbiAoZ3JhcGhpY01vZGVsLCBlY01vZGVsLCBhcGkpIHtcblxuICAgICAgICAgICAgLy8gSGF2aW5nIGxldmVyYWdlZCBiZXR3ZWVuIHVzZSBjYXNlcyBhbmQgYWxnb3JpdGhtIGNvbXBsZXhpdHksIGEgdmVyeVxuICAgICAgICAgICAgLy8gc2ltcGxlIGxheW91dCBtZWNoYW5pc20gaXMgdXNlZDpcbiAgICAgICAgICAgIC8vIFRoZSBzaXplKHdpZHRoL2hlaWdodCkgY2FuIGJlIGRldGVybWluZWQgYnkgaXRzZWxmIG9yIGl0cyBwYXJlbnQgKG5vdFxuICAgICAgICAgICAgLy8gaW1wbGVtZW50ZWQgeWV0KSwgYnV0IGNhbiBub3QgYnkgaXRzIGNoaWxkcmVuLiAoVG9wLWRvd24gdHJhdmVsKVxuICAgICAgICAgICAgLy8gVGhlIGxvY2F0aW9uKHgveSkgY2FuIGJlIGRldGVybWluZWQgYnkgdGhlIGJvdW5kaW5nIHJlY3Qgb2YgaXRzZWxmXG4gICAgICAgICAgICAvLyAoY2FuIGluY2x1ZGluZyBpdHMgZGVzY2VuZGFudHMgb3Igbm90KSBhbmQgdGhlIHNpemUgb2YgaXRzIHBhcmVudC5cbiAgICAgICAgICAgIC8vIChCb3R0b20tdXAgdHJhdmVsKVxuXG4gICAgICAgICAgICAvLyBXaGVuIGBjaGFydC5jbGVhcigpYCBvciBgY2hhcnQuc2V0T3B0aW9uKHsuLi59LCB0cnVlKWAgd2l0aCB0aGUgc2FtZSBpZCxcbiAgICAgICAgICAgIC8vIHZpZXcgd2lsbCBiZSByZXVzZWQuXG4gICAgICAgICAgICBpZiAoZ3JhcGhpY01vZGVsICE9PSB0aGlzLl9sYXN0R3JhcGhpY01vZGVsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2xlYXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2xhc3RHcmFwaGljTW9kZWwgPSBncmFwaGljTW9kZWw7XG5cbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUVsZW1lbnRzKGdyYXBoaWNNb2RlbCwgYXBpKTtcbiAgICAgICAgICAgIHRoaXMuX3JlbG9jYXRlKGdyYXBoaWNNb2RlbCwgYXBpKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlIGdyYXBoaWMgZWxlbWVudHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBncmFwaGljTW9kZWwgZ3JhcGhpYyBtb2RlbFxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL0V4dGVuc2lvbkFQSX0gYXBpIGV4dGVuc2lvbiBBUElcbiAgICAgICAgICovXG4gICAgICAgIF91cGRhdGVFbGVtZW50czogZnVuY3Rpb24gKGdyYXBoaWNNb2RlbCwgYXBpKSB7XG4gICAgICAgICAgICB2YXIgZWxPcHRpb25zVG9VcGRhdGUgPSBncmFwaGljTW9kZWwudXNlRWxPcHRpb25zVG9VcGRhdGUoKTtcblxuICAgICAgICAgICAgaWYgKCFlbE9wdGlvbnNUb1VwZGF0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGVsTWFwID0gdGhpcy5fZWxNYXA7XG4gICAgICAgICAgICB2YXIgcm9vdEdyb3VwID0gdGhpcy5ncm91cDtcblxuICAgICAgICAgICAgLy8gVG9wLWRvd24gdHJhbnZlcnNlIHRvIGFzc2lnbiBncmFwaGljIHNldHRpbmdzIHRvIGVhY2ggZWxlbWVudHMuXG4gICAgICAgICAgICB6clV0aWwuZWFjaChlbE9wdGlvbnNUb1VwZGF0ZSwgZnVuY3Rpb24gKGVsT3B0aW9uKSB7XG4gICAgICAgICAgICAgICAgdmFyICRhY3Rpb24gPSBlbE9wdGlvbi4kYWN0aW9uO1xuICAgICAgICAgICAgICAgIHZhciBpZCA9IGVsT3B0aW9uLmlkO1xuICAgICAgICAgICAgICAgIHZhciBleGlzdEVsID0gZWxNYXBbaWRdO1xuICAgICAgICAgICAgICAgIHZhciBwYXJlbnRJZCA9IGVsT3B0aW9uLnBhcmVudElkO1xuICAgICAgICAgICAgICAgIHZhciB0YXJnZXRFbFBhcmVudCA9IHBhcmVudElkICE9IG51bGwgPyBlbE1hcFtwYXJlbnRJZF0gOiByb290R3JvdXA7XG5cbiAgICAgICAgICAgICAgICAvLyBJbiB0b3AvYm90dG9tIG1vZGUsIHRleHRWZXJ0aWNhbCBzaG91bGQgbm90IGJlIHVzZWQuIEFuZCB0ZXh0QmFzZWxpbmVcbiAgICAgICAgICAgICAgICAvLyBzaG91bGQgbm90IGJlICdhbHBoYWJldGljJywgd2hpY2ggY2F1c2UgaW5hY2N1cmF0ZWx5IGxvY2F0aW5nLlxuICAgICAgICAgICAgICAgIGlmIChlbE9wdGlvbi5odiAmJiBlbE9wdGlvbi5odlsxXSAmJiBlbE9wdGlvbi50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxPcHRpb24uc3R5bGUgPSB6clV0aWwuZGVmYXVsdHMoe3RleHRCYXNlbGluZTogJ21pZGRsZSd9LCBlbE9wdGlvbi5zdHlsZSk7XG4gICAgICAgICAgICAgICAgICAgIGVsT3B0aW9uLnN0eWxlLnRleHRWZXJ0aWNhbEFsaWduID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdW5uZWNlc3NhcnkgcHJvcHMgdG8gYXZvaWQgcG90ZW50aWFsIHByb2JsZW1zLlxuICAgICAgICAgICAgICAgIHZhciBlbE9wdGlvbkNsZWFuZWQgPSBnZXRDbGVhbmVkRWxPcHRpb24oZWxPcHRpb24pO1xuXG4gICAgICAgICAgICAgICAgLy8gRm9yIHNpbXBsZSwgZG8gbm90IHN1cHBvcnQgcGFyZW50IGNoYW5nZSwgb3RoZXJ3aXNlIHJlb3JkZXIgaXMgbmVlZGVkLlxuICAgICAgICAgICAgICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4aXN0RWwgJiYgenJVdGlsLmFzc2VydChcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldEVsUGFyZW50ID09PSBleGlzdEVsLnBhcmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdDaGFuZ2luZyBwYXJlbnQgaXMgbm90IHN1cHBvcnRlZC4nXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCEkYWN0aW9uIHx8ICRhY3Rpb24gPT09ICdtZXJnZScpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhpc3RFbFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBleGlzdEVsLmF0dHIoZWxPcHRpb25DbGVhbmVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBjcmVhdGVFbChpZCwgdGFyZ2V0RWxQYXJlbnQsIGVsT3B0aW9uQ2xlYW5lZCwgZWxNYXApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICgkYWN0aW9uID09PSAncmVwbGFjZScpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlRWwoZXhpc3RFbCwgZWxNYXApO1xuICAgICAgICAgICAgICAgICAgICBjcmVhdGVFbChpZCwgdGFyZ2V0RWxQYXJlbnQsIGVsT3B0aW9uQ2xlYW5lZCwgZWxNYXApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICgkYWN0aW9uID09PSAncmVtb3ZlJykge1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVFbChleGlzdEVsLCBlbE1hcCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGVsTWFwW2lkXSkge1xuICAgICAgICAgICAgICAgICAgICBlbE1hcFtpZF0uX19lY0dyYXBoaWNXaWR0aCA9IGVsT3B0aW9uLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICBlbE1hcFtpZF0uX19lY0dyYXBoaWNIZWlnaHQgPSBlbE9wdGlvbi5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIExvY2F0ZSBncmFwaGljIGVsZW1lbnRzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZ3JhcGhpY01vZGVsIGdyYXBoaWMgbW9kZWxcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9FeHRlbnNpb25BUEl9IGFwaSBleHRlbnNpb24gQVBJXG4gICAgICAgICAqL1xuICAgICAgICBfcmVsb2NhdGU6IGZ1bmN0aW9uIChncmFwaGljTW9kZWwsIGFwaSkge1xuICAgICAgICAgICAgdmFyIGVsT3B0aW9ucyA9IGdyYXBoaWNNb2RlbC5vcHRpb24uZWxlbWVudHM7XG4gICAgICAgICAgICB2YXIgcm9vdEdyb3VwID0gdGhpcy5ncm91cDtcbiAgICAgICAgICAgIHZhciBlbE1hcCA9IHRoaXMuX2VsTWFwO1xuXG4gICAgICAgICAgICAvLyBCb3R0b20tdXAgdHJhbnZlc2UgYWxsIGVsZW1lbnRzIChjb25zaWRlciBlYyByZXNpemUpIHRvIGxvY2F0ZSBlbGVtZW50cy5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBlbE9wdGlvbnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICB2YXIgZWxPcHRpb24gPSBlbE9wdGlvbnNbaV07XG4gICAgICAgICAgICAgICAgdmFyIGVsID0gZWxNYXBbZWxPcHRpb24uaWRdO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFlbCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50RWwgPSBlbC5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRhaW5lckluZm8gPSBwYXJlbnRFbCA9PT0gcm9vdEdyb3VwXG4gICAgICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGFwaS5nZXRXaWR0aCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBhcGkuZ2V0SGVpZ2h0KClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICA6IHsgLy8gTGlrZSAncG9zaXRpb246YWJzb2x1dCcgaW4gY3NzLCBkZWZhdWx0IDAuXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogcGFyZW50RWwuX19lY0dyYXBoaWNXaWR0aCB8fCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBwYXJlbnRFbC5fX2VjR3JhcGhpY0hlaWdodCB8fCAwXG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBsYXlvdXRVdGlsLnBvc2l0aW9uRWxlbWVudChcbiAgICAgICAgICAgICAgICAgICAgZWwsIGVsT3B0aW9uLCBjb250YWluZXJJbmZvLCBudWxsLFxuICAgICAgICAgICAgICAgICAgICB7aHY6IGVsT3B0aW9uLmh2LCBib3VuZGluZ01vZGU6IGVsT3B0aW9uLmJvdW5kaW5nfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENsZWFyIGFsbCBlbGVtZW50cy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF9jbGVhcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGVsTWFwID0gdGhpcy5fZWxNYXA7XG4gICAgICAgICAgICB6clV0aWwuZWFjaChlbE1hcCwgZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlRWwoZWwsIGVsTWFwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5fZWxNYXAgPSB7fTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgICAqL1xuICAgICAgICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9jbGVhcigpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVFbChpZCwgdGFyZ2V0RWxQYXJlbnQsIGVsT3B0aW9uLCBlbE1hcCkge1xuICAgICAgICB2YXIgZ3JhcGhpY1R5cGUgPSBlbE9wdGlvbi50eXBlO1xuXG4gICAgICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgICAgICB6clV0aWwuYXNzZXJ0KGdyYXBoaWNUeXBlLCAnZ3JhcGhpYyB0eXBlIE1VU1QgYmUgc2V0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgQ2x6ID0gZ3JhcGhpY1V0aWxbZ3JhcGhpY1R5cGUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBncmFwaGljVHlwZS5zbGljZSgxKV07XG5cbiAgICAgICAgaWYgKF9fREVWX18pIHtcbiAgICAgICAgICAgIHpyVXRpbC5hc3NlcnQoQ2x6LCAnZ3JhcGhpYyB0eXBlIGNhbiBub3QgYmUgZm91bmQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlbCA9IG5ldyBDbHooZWxPcHRpb24pO1xuICAgICAgICB0YXJnZXRFbFBhcmVudC5hZGQoZWwpO1xuICAgICAgICBlbE1hcFtpZF0gPSBlbDtcbiAgICAgICAgZWwuX19lY0dyYXBoaWNJZCA9IGlkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZUVsKGV4aXN0RWwsIGVsTWFwKSB7XG4gICAgICAgIHZhciBleGlzdEVsUGFyZW50ID0gZXhpc3RFbCAmJiBleGlzdEVsLnBhcmVudDtcbiAgICAgICAgaWYgKGV4aXN0RWxQYXJlbnQpIHtcbiAgICAgICAgICAgIGV4aXN0RWwudHlwZSA9PT0gJ2dyb3VwJyAmJiBleGlzdEVsLnRyYXZlcnNlKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgICAgIHJlbW92ZUVsKGVsLCBlbE1hcCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRlbGV0ZSBlbE1hcFtleGlzdEVsLl9fZWNHcmFwaGljSWRdO1xuICAgICAgICAgICAgZXhpc3RFbFBhcmVudC5yZW1vdmUoZXhpc3RFbCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZW1vdmUgdW5uZWNlc3NhcnkgcHJvcHMgdG8gYXZvaWQgcG90ZW50aWFsIHByb2JsZW1zLlxuICAgIGZ1bmN0aW9uIGdldENsZWFuZWRFbE9wdGlvbihlbE9wdGlvbikge1xuICAgICAgICBlbE9wdGlvbiA9IHpyVXRpbC5leHRlbmQoe30sIGVsT3B0aW9uKTtcbiAgICAgICAgenJVdGlsLmVhY2goXG4gICAgICAgICAgICBbJ2lkJywgJ3BhcmVudElkJywgJyRhY3Rpb24nLCAnaHYnLCAnYm91bmRpbmcnXS5jb25jYXQobGF5b3V0VXRpbC5MT0NBVElPTl9QQVJBTVMpLFxuICAgICAgICAgICAgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgZWxPcHRpb25bbmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBlbE9wdGlvbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1NldExvYyhvYmosIHByb3BzKSB7XG4gICAgICAgIHZhciBpc1NldDtcbiAgICAgICAgenJVdGlsLmVhY2gocHJvcHMsIGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICBvYmpbcHJvcF0gIT0gbnVsbCAmJiBvYmpbcHJvcF0gIT09ICdhdXRvJyAmJiAoaXNTZXQgPSB0cnVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBpc1NldDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRLZXlJbmZvVG9OZXdFbE9wdGlvbihyZXN1bHRJdGVtLCBuZXdFbE9wdGlvbikge1xuICAgICAgICB2YXIgZXhpc3RFbE9wdGlvbiA9IHJlc3VsdEl0ZW0uZXhpc3Q7XG5cbiAgICAgICAgLy8gU2V0IGlkIGFuZCB0eXBlIGFmdGVyIGlkIGFzc2lnbmVkLlxuICAgICAgICBuZXdFbE9wdGlvbi5pZCA9IHJlc3VsdEl0ZW0ua2V5SW5mby5pZDtcbiAgICAgICAgIW5ld0VsT3B0aW9uLnR5cGUgJiYgZXhpc3RFbE9wdGlvbiAmJiAobmV3RWxPcHRpb24udHlwZSA9IGV4aXN0RWxPcHRpb24udHlwZSk7XG5cbiAgICAgICAgLy8gU2V0IHBhcmVudCBpZCBpZiBub3Qgc3BlY2lmaWVkXG4gICAgICAgIGlmIChuZXdFbE9wdGlvbi5wYXJlbnRJZCA9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgbmV3RWxQYXJlbnRPcHRpb24gPSBuZXdFbE9wdGlvbi5wYXJlbnRPcHRpb247XG4gICAgICAgICAgICBpZiAobmV3RWxQYXJlbnRPcHRpb24pIHtcbiAgICAgICAgICAgICAgICBuZXdFbE9wdGlvbi5wYXJlbnRJZCA9IG5ld0VsUGFyZW50T3B0aW9uLmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXhpc3RFbE9wdGlvbikge1xuICAgICAgICAgICAgICAgIG5ld0VsT3B0aW9uLnBhcmVudElkID0gZXhpc3RFbE9wdGlvbi5wYXJlbnRJZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENsZWFyXG4gICAgICAgIG5ld0VsT3B0aW9uLnBhcmVudE9wdGlvbiA9IG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWVyZ2VOZXdFbE9wdGlvblRvRXhpc3QoZXhpc3RMaXN0LCBpbmRleCwgbmV3RWxPcHRpb24pIHtcbiAgICAgICAgLy8gVXBkYXRlIGV4aXN0aW5nIG9wdGlvbnMsIGZvciBgZ2V0T3B0aW9uYCBmZWF0dXJlLlxuICAgICAgICB2YXIgbmV3RWxPcHRDb3B5ID0genJVdGlsLmV4dGVuZCh7fSwgbmV3RWxPcHRpb24pO1xuICAgICAgICB2YXIgZXhpc3RFbE9wdGlvbiA9IGV4aXN0TGlzdFtpbmRleF07XG5cbiAgICAgICAgdmFyICRhY3Rpb24gPSBuZXdFbE9wdGlvbi4kYWN0aW9uIHx8ICdtZXJnZSc7XG4gICAgICAgIGlmICgkYWN0aW9uID09PSAnbWVyZ2UnKSB7XG4gICAgICAgICAgICBpZiAoZXhpc3RFbE9wdGlvbikge1xuXG4gICAgICAgICAgICAgICAgaWYgKF9fREVWX18pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1R5cGUgPSBuZXdFbE9wdGlvbi50eXBlO1xuICAgICAgICAgICAgICAgICAgICB6clV0aWwuYXNzZXJ0KFxuICAgICAgICAgICAgICAgICAgICAgICAgIW5ld1R5cGUgfHwgZXhpc3RFbE9wdGlvbi50eXBlID09PSBuZXdUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1BsZWFzZSBzZXQgJGFjdGlvbjogXCJyZXBsYWNlXCIgdG8gY2hhbmdlIGB0eXBlYCdcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBXZSBjYW4gZW5zdXJlIHRoYXQgbmV3RWxPcHRDb3B5IGFuZCBleGlzdEVsT3B0aW9uIGFyZSBub3RcbiAgICAgICAgICAgICAgICAvLyB0aGUgc2FtZSBvYmplY3QsIHNvIGBtZXJnZWAgd2lsbCBub3QgY2hhbmdlIG5ld0VsT3B0Q29weS5cbiAgICAgICAgICAgICAgICB6clV0aWwubWVyZ2UoZXhpc3RFbE9wdGlvbiwgbmV3RWxPcHRDb3B5LCB0cnVlKTtcbiAgICAgICAgICAgICAgICAvLyBSaWdpZCBib2R5LCB1c2UgaWdub3JlU2l6ZS5cbiAgICAgICAgICAgICAgICBsYXlvdXRVdGlsLm1lcmdlTGF5b3V0UGFyYW0oZXhpc3RFbE9wdGlvbiwgbmV3RWxPcHRDb3B5LCB7aWdub3JlU2l6ZTogdHJ1ZX0pO1xuICAgICAgICAgICAgICAgIC8vIFdpbGwgYmUgdXNlZCBpbiByZW5kZXIuXG4gICAgICAgICAgICAgICAgbGF5b3V0VXRpbC5jb3B5TGF5b3V0UGFyYW1zKG5ld0VsT3B0aW9uLCBleGlzdEVsT3B0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGV4aXN0TGlzdFtpbmRleF0gPSBuZXdFbE9wdENvcHk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoJGFjdGlvbiA9PT0gJ3JlcGxhY2UnKSB7XG4gICAgICAgICAgICBleGlzdExpc3RbaW5kZXhdID0gbmV3RWxPcHRDb3B5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCRhY3Rpb24gPT09ICdyZW1vdmUnKSB7XG4gICAgICAgICAgICAvLyBudWxsIHdpbGwgYmUgY2xlYW5lZCBsYXRlci5cbiAgICAgICAgICAgIGV4aXN0RWxPcHRpb24gJiYgKGV4aXN0TGlzdFtpbmRleF0gPSBudWxsKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldExheW91dEluZm9Ub0V4aXN0KGV4aXN0SXRlbSwgbmV3RWxPcHRpb24pIHtcbiAgICAgICAgaWYgKCFleGlzdEl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBleGlzdEl0ZW0uaHYgPSBuZXdFbE9wdGlvbi5odiA9IFtcbiAgICAgICAgICAgIC8vIFJpZ2lkIGJvZHksIGRvbnQgY2FyZSBgd2lkdGhgLlxuICAgICAgICAgICAgaXNTZXRMb2MobmV3RWxPcHRpb24sIFsnbGVmdCcsICdyaWdodCddKSxcbiAgICAgICAgICAgIC8vIFJpZ2lkIGJvZHksIGRvbnQgY2FyZSBgaGVpZ2h0YC5cbiAgICAgICAgICAgIGlzU2V0TG9jKG5ld0VsT3B0aW9uLCBbJ3RvcCcsICdib3R0b20nXSlcbiAgICAgICAgXTtcbiAgICAgICAgLy8gR2l2ZSBkZWZhdWx0IGdyb3VwIHNpemUuIE90aGVyd2lzZSBsYXlvdXQgZXJyb3IgbWF5IG9jY3VyLlxuICAgICAgICBpZiAoZXhpc3RJdGVtLnR5cGUgPT09ICdncm91cCcpIHtcbiAgICAgICAgICAgIGV4aXN0SXRlbS53aWR0aCA9PSBudWxsICYmIChleGlzdEl0ZW0ud2lkdGggPSBuZXdFbE9wdGlvbi53aWR0aCA9IDApO1xuICAgICAgICAgICAgZXhpc3RJdGVtLmhlaWdodCA9PSBudWxsICYmIChleGlzdEl0ZW0uaGVpZ2h0ID0gbmV3RWxPcHRpb24uaGVpZ2h0ID0gMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2NvbXBvbmVudC9ncmFwaGljLmpzXG4vLyBtb2R1bGUgaWQgPSAxODZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 187 */
/* unknown exports provided */
/* all exports used */
/*!*******************************!*\
  !*** ./lib/component/grid.js ***!
  \*******************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    __webpack_require__(/*! ./gridSimple */ 31);\n\n    __webpack_require__(/*! ./axisPointer/CartesianAxisPointer */ 149);\n\n    __webpack_require__(/*! ./axisPointer */ 51);\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTg3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2NvbXBvbmVudC9ncmlkLmpzPzY4MTAiXSwic291cmNlc0NvbnRlbnQiOlsiXG5cbiAgICByZXF1aXJlKCcuL2dyaWRTaW1wbGUnKTtcblxuICAgIHJlcXVpcmUoJy4vYXhpc1BvaW50ZXIvQ2FydGVzaWFuQXhpc1BvaW50ZXInKTtcblxuICAgIHJlcXVpcmUoJy4vYXhpc1BvaW50ZXInKTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvY29tcG9uZW50L2dyaWQuanNcbi8vIG1vZHVsZSBpZCA9IDE4N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 188 */
/* unknown exports provided */
/* all exports used */
/*!*********************************!*\
  !*** ./lib/component/legend.js ***!
  \*********************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Legend component entry file8\n */\n\n\n    __webpack_require__(/*! ./legend/LegendModel */ 218);\n    __webpack_require__(/*! ./legend/legendAction */ 220);\n    __webpack_require__(/*! ./legend/LegendView */ 219);\n\n    var echarts = __webpack_require__(/*! ../echarts */ 1);\n    // Series Filter\n    echarts.registerProcessor(__webpack_require__(/*! ./legend/legendFilter */ 221));\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTg4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2NvbXBvbmVudC9sZWdlbmQuanM/MTBkYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIExlZ2VuZCBjb21wb25lbnQgZW50cnkgZmlsZThcbiAqL1xuXG5cbiAgICByZXF1aXJlKCcuL2xlZ2VuZC9MZWdlbmRNb2RlbCcpO1xuICAgIHJlcXVpcmUoJy4vbGVnZW5kL2xlZ2VuZEFjdGlvbicpO1xuICAgIHJlcXVpcmUoJy4vbGVnZW5kL0xlZ2VuZFZpZXcnKTtcblxuICAgIHZhciBlY2hhcnRzID0gcmVxdWlyZSgnLi4vZWNoYXJ0cycpO1xuICAgIC8vIFNlcmllcyBGaWx0ZXJcbiAgICBlY2hhcnRzLnJlZ2lzdGVyUHJvY2Vzc29yKHJlcXVpcmUoJy4vbGVnZW5kL2xlZ2VuZEZpbHRlcicpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2NvbXBvbmVudC9sZWdlbmQuanNcbi8vIG1vZHVsZSBpZCA9IDE4OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 189 */
/* unknown exports provided */
/* all exports used */
/*!***********************************!*\
  !*** ./lib/component/markArea.js ***!
  \***********************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    __webpack_require__(/*! ./marker/MarkAreaModel */ 222);\n    __webpack_require__(/*! ./marker/MarkAreaView */ 223);\n\n    __webpack_require__(/*! ../echarts */ 1).registerPreprocessor(function (opt) {\n        // Make sure markArea component is enabled\n        opt.markArea = opt.markArea || {};\n    });\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTg5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2NvbXBvbmVudC9tYXJrQXJlYS5qcz9hMmQwIl0sInNvdXJjZXNDb250ZW50IjpbIlxuXG4gICAgcmVxdWlyZSgnLi9tYXJrZXIvTWFya0FyZWFNb2RlbCcpO1xuICAgIHJlcXVpcmUoJy4vbWFya2VyL01hcmtBcmVhVmlldycpO1xuXG4gICAgcmVxdWlyZSgnLi4vZWNoYXJ0cycpLnJlZ2lzdGVyUHJlcHJvY2Vzc29yKGZ1bmN0aW9uIChvcHQpIHtcbiAgICAgICAgLy8gTWFrZSBzdXJlIG1hcmtBcmVhIGNvbXBvbmVudCBpcyBlbmFibGVkXG4gICAgICAgIG9wdC5tYXJrQXJlYSA9IG9wdC5tYXJrQXJlYSB8fCB7fTtcbiAgICB9KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2NvbXBvbmVudC9tYXJrQXJlYS5qc1xuLy8gbW9kdWxlIGlkID0gMTg5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 190 */
/* unknown exports provided */
/* all exports used */
/*!***********************************!*\
  !*** ./lib/component/markLine.js ***!
  \***********************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    __webpack_require__(/*! ./marker/MarkLineModel */ 224);\n    __webpack_require__(/*! ./marker/MarkLineView */ 225);\n\n    __webpack_require__(/*! ../echarts */ 1).registerPreprocessor(function (opt) {\n        // Make sure markLine component is enabled\n        opt.markLine = opt.markLine || {};\n    });\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTkwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2NvbXBvbmVudC9tYXJrTGluZS5qcz9iYjZhIl0sInNvdXJjZXNDb250ZW50IjpbIlxuXG4gICAgcmVxdWlyZSgnLi9tYXJrZXIvTWFya0xpbmVNb2RlbCcpO1xuICAgIHJlcXVpcmUoJy4vbWFya2VyL01hcmtMaW5lVmlldycpO1xuXG4gICAgcmVxdWlyZSgnLi4vZWNoYXJ0cycpLnJlZ2lzdGVyUHJlcHJvY2Vzc29yKGZ1bmN0aW9uIChvcHQpIHtcbiAgICAgICAgLy8gTWFrZSBzdXJlIG1hcmtMaW5lIGNvbXBvbmVudCBpcyBlbmFibGVkXG4gICAgICAgIG9wdC5tYXJrTGluZSA9IG9wdC5tYXJrTGluZSB8fCB7fTtcbiAgICB9KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2NvbXBvbmVudC9tYXJrTGluZS5qc1xuLy8gbW9kdWxlIGlkID0gMTkwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 191 */
/* unknown exports provided */
/* all exports used */
/*!************************************!*\
  !*** ./lib/component/markPoint.js ***!
  \************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("// HINT Markpoint can't be used too much\n\n\n    __webpack_require__(/*! ./marker/MarkPointModel */ 226);\n    __webpack_require__(/*! ./marker/MarkPointView */ 227);\n\n    __webpack_require__(/*! ../echarts */ 1).registerPreprocessor(function (opt) {\n        // Make sure markPoint component is enabled\n        opt.markPoint = opt.markPoint || {};\n    });\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTkxLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2NvbXBvbmVudC9tYXJrUG9pbnQuanM/ZTA0ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBISU5UIE1hcmtwb2ludCBjYW4ndCBiZSB1c2VkIHRvbyBtdWNoXG5cblxuICAgIHJlcXVpcmUoJy4vbWFya2VyL01hcmtQb2ludE1vZGVsJyk7XG4gICAgcmVxdWlyZSgnLi9tYXJrZXIvTWFya1BvaW50VmlldycpO1xuXG4gICAgcmVxdWlyZSgnLi4vZWNoYXJ0cycpLnJlZ2lzdGVyUHJlcHJvY2Vzc29yKGZ1bmN0aW9uIChvcHQpIHtcbiAgICAgICAgLy8gTWFrZSBzdXJlIG1hcmtQb2ludCBjb21wb25lbnQgaXMgZW5hYmxlZFxuICAgICAgICBvcHQubWFya1BvaW50ID0gb3B0Lm1hcmtQb2ludCB8fCB7fTtcbiAgICB9KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2NvbXBvbmVudC9tYXJrUG9pbnQuanNcbi8vIG1vZHVsZSBpZCA9IDE5MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 192 */
/* unknown exports provided */
/* all exports used */
/*!********************************!*\
  !*** ./lib/component/title.js ***!
  \********************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\n    var echarts = __webpack_require__(/*! ../echarts */ 1);\n    var graphic = __webpack_require__(/*! ../util/graphic */ 2);\n    var layout = __webpack_require__(/*! ../util/layout */ 11);\n\n    // Model\n    echarts.extendComponentModel({\n\n        type: 'title',\n\n        layoutMode: {type: 'box', ignoreSize: true},\n\n        defaultOption: {\n            // 一级层叠\n            zlevel: 0,\n            // 二级层叠\n            z: 6,\n            show: true,\n\n            text: '',\n            // 超链接跳转\n            // link: null,\n            // 仅支持self | blank\n            target: 'blank',\n            subtext: '',\n\n            // 超链接跳转\n            // sublink: null,\n            // 仅支持self | blank\n            subtarget: 'blank',\n\n            // 'center' ¦ 'left' ¦ 'right'\n            // ¦ {number}（x坐标，单位px）\n            left: 0,\n            // 'top' ¦ 'bottom' ¦ 'center'\n            // ¦ {number}（y坐标，单位px）\n            top: 0,\n\n            // 水平对齐\n            // 'auto' | 'left' | 'right' | 'center'\n            // 默认根据 left 的位置判断是左对齐还是右对齐\n            // textAlign: null\n            //\n            // 垂直对齐\n            // 'auto' | 'top' | 'bottom' | 'middle'\n            // 默认根据 top 位置判断是上对齐还是下对齐\n            // textBaseline: null\n\n            backgroundColor: 'rgba(0,0,0,0)',\n\n            // 标题边框颜色\n            borderColor: '#ccc',\n\n            // 标题边框线宽，单位px，默认为0（无边框）\n            borderWidth: 0,\n\n            // 标题内边距，单位px，默认各方向内边距为5，\n            // 接受数组分别设定上右下左边距，同css\n            padding: 5,\n\n            // 主副标题纵向间隔，单位px，默认为10，\n            itemGap: 10,\n            textStyle: {\n                fontSize: 18,\n                fontWeight: 'bolder',\n                color: '#333'\n            },\n            subtextStyle: {\n                color: '#aaa'\n            }\n        }\n    });\n\n    // View\n    echarts.extendComponentView({\n\n        type: 'title',\n\n        render: function (titleModel, ecModel, api) {\n            this.group.removeAll();\n\n            if (!titleModel.get('show')) {\n                return;\n            }\n\n            var group = this.group;\n\n            var textStyleModel = titleModel.getModel('textStyle');\n            var subtextStyleModel = titleModel.getModel('subtextStyle');\n\n            var textAlign = titleModel.get('textAlign');\n            var textBaseline = titleModel.get('textBaseline');\n\n            var textEl = new graphic.Text({\n                style: {\n                    text: titleModel.get('text'),\n                    textFont: textStyleModel.getFont(),\n                    fill: textStyleModel.getTextColor()\n                },\n                z2: 10\n            });\n\n            var textRect = textEl.getBoundingRect();\n\n            var subText = titleModel.get('subtext');\n            var subTextEl = new graphic.Text({\n                style: {\n                    text: subText,\n                    textFont: subtextStyleModel.getFont(),\n                    fill: subtextStyleModel.getTextColor(),\n                    y: textRect.height + titleModel.get('itemGap'),\n                    textBaseline: 'top'\n                },\n                z2: 10\n            });\n\n            var link = titleModel.get('link');\n            var sublink = titleModel.get('sublink');\n\n            textEl.silent = !link;\n            subTextEl.silent = !sublink;\n\n            if (link) {\n                textEl.on('click', function () {\n                    window.open(link, '_' + titleModel.get('target'));\n                });\n            }\n            if (sublink) {\n                subTextEl.on('click', function () {\n                    window.open(sublink, '_' + titleModel.get('subtarget'));\n                });\n            }\n\n            group.add(textEl);\n            subText && group.add(subTextEl);\n            // If no subText, but add subTextEl, there will be an empty line.\n\n            var groupRect = group.getBoundingRect();\n            var layoutOption = titleModel.getBoxLayoutParams();\n            layoutOption.width = groupRect.width;\n            layoutOption.height = groupRect.height;\n            var layoutRect = layout.getLayoutRect(\n                layoutOption, {\n                    width: api.getWidth(),\n                    height: api.getHeight()\n                }, titleModel.get('padding')\n            );\n            // Adjust text align based on position\n            if (!textAlign) {\n                // Align left if title is on the left. center and right is same\n                textAlign = titleModel.get('left') || titleModel.get('right');\n                if (textAlign === 'middle') {\n                    textAlign = 'center';\n                }\n                // Adjust layout by text align\n                if (textAlign === 'right') {\n                    layoutRect.x += layoutRect.width;\n                }\n                else if (textAlign === 'center') {\n                    layoutRect.x += layoutRect.width / 2;\n                }\n            }\n            if (!textBaseline) {\n                textBaseline = titleModel.get('top') || titleModel.get('bottom');\n                if (textBaseline === 'center') {\n                    textBaseline = 'middle';\n                }\n                if (textBaseline === 'bottom') {\n                    layoutRect.y += layoutRect.height;\n                }\n                else if (textBaseline === 'middle') {\n                    layoutRect.y += layoutRect.height / 2;\n                }\n\n                textBaseline = textBaseline || 'top';\n            }\n\n            group.attr('position', [layoutRect.x, layoutRect.y]);\n            var alignStyle = {\n                textAlign: textAlign,\n                textVerticalAlign: textBaseline\n            };\n            textEl.setStyle(alignStyle);\n            subTextEl.setStyle(alignStyle);\n\n            // Render background\n            // Get groupRect again because textAlign has been changed\n            groupRect = group.getBoundingRect();\n            var padding = layoutRect.margin;\n            var style = titleModel.getItemStyle(['color', 'opacity']);\n            style.fill = titleModel.get('backgroundColor');\n            var rect = new graphic.Rect({\n                shape: {\n                    x: groupRect.x - padding[3],\n                    y: groupRect.y - padding[0],\n                    width: groupRect.width + padding[1] + padding[3],\n                    height: groupRect.height + padding[0] + padding[2]\n                },\n                style: style,\n                silent: true\n            });\n            graphic.subPixelOptimizeRect(rect);\n\n            group.add(rect);\n        }\n    });\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTkyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2NvbXBvbmVudC90aXRsZS5qcz9kOGM1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuXG4gICAgdmFyIGVjaGFydHMgPSByZXF1aXJlKCcuLi9lY2hhcnRzJyk7XG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKCcuLi91dGlsL2dyYXBoaWMnKTtcbiAgICB2YXIgbGF5b3V0ID0gcmVxdWlyZSgnLi4vdXRpbC9sYXlvdXQnKTtcblxuICAgIC8vIE1vZGVsXG4gICAgZWNoYXJ0cy5leHRlbmRDb21wb25lbnRNb2RlbCh7XG5cbiAgICAgICAgdHlwZTogJ3RpdGxlJyxcblxuICAgICAgICBsYXlvdXRNb2RlOiB7dHlwZTogJ2JveCcsIGlnbm9yZVNpemU6IHRydWV9LFxuXG4gICAgICAgIGRlZmF1bHRPcHRpb246IHtcbiAgICAgICAgICAgIC8vIOS4gOe6p+WxguWPoFxuICAgICAgICAgICAgemxldmVsOiAwLFxuICAgICAgICAgICAgLy8g5LqM57qn5bGC5Y+gXG4gICAgICAgICAgICB6OiA2LFxuICAgICAgICAgICAgc2hvdzogdHJ1ZSxcblxuICAgICAgICAgICAgdGV4dDogJycsXG4gICAgICAgICAgICAvLyDotoXpk77mjqXot7PovaxcbiAgICAgICAgICAgIC8vIGxpbms6IG51bGwsXG4gICAgICAgICAgICAvLyDku4XmlK/mjIFzZWxmIHwgYmxhbmtcbiAgICAgICAgICAgIHRhcmdldDogJ2JsYW5rJyxcbiAgICAgICAgICAgIHN1YnRleHQ6ICcnLFxuXG4gICAgICAgICAgICAvLyDotoXpk77mjqXot7PovaxcbiAgICAgICAgICAgIC8vIHN1Ymxpbms6IG51bGwsXG4gICAgICAgICAgICAvLyDku4XmlK/mjIFzZWxmIHwgYmxhbmtcbiAgICAgICAgICAgIHN1YnRhcmdldDogJ2JsYW5rJyxcblxuICAgICAgICAgICAgLy8gJ2NlbnRlcicgwqYgJ2xlZnQnIMKmICdyaWdodCdcbiAgICAgICAgICAgIC8vIMKmIHtudW1iZXJ977yIeOWdkOagh++8jOWNleS9jXB477yJXG4gICAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgICAgLy8gJ3RvcCcgwqYgJ2JvdHRvbScgwqYgJ2NlbnRlcidcbiAgICAgICAgICAgIC8vIMKmIHtudW1iZXJ977yIeeWdkOagh++8jOWNleS9jXB477yJXG4gICAgICAgICAgICB0b3A6IDAsXG5cbiAgICAgICAgICAgIC8vIOawtOW5s+Wvuem9kFxuICAgICAgICAgICAgLy8gJ2F1dG8nIHwgJ2xlZnQnIHwgJ3JpZ2h0JyB8ICdjZW50ZXInXG4gICAgICAgICAgICAvLyDpu5jorqTmoLnmja4gbGVmdCDnmoTkvY3nva7liKTmlq3mmK/lt6blr7npvZDov5jmmK/lj7Plr7npvZBcbiAgICAgICAgICAgIC8vIHRleHRBbGlnbjogbnVsbFxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIOWeguebtOWvuem9kFxuICAgICAgICAgICAgLy8gJ2F1dG8nIHwgJ3RvcCcgfCAnYm90dG9tJyB8ICdtaWRkbGUnXG4gICAgICAgICAgICAvLyDpu5jorqTmoLnmja4gdG9wIOS9jee9ruWIpOaWreaYr+S4iuWvuem9kOi/mOaYr+S4i+Wvuem9kFxuICAgICAgICAgICAgLy8gdGV4dEJhc2VsaW5lOiBudWxsXG5cbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMCwwLDAsMCknLFxuXG4gICAgICAgICAgICAvLyDmoIfpopjovrnmoYbpopzoibJcbiAgICAgICAgICAgIGJvcmRlckNvbG9yOiAnI2NjYycsXG5cbiAgICAgICAgICAgIC8vIOagh+mimOi+ueahhue6v+Wuve+8jOWNleS9jXB477yM6buY6K6k5Li6MO+8iOaXoOi+ueahhu+8iVxuICAgICAgICAgICAgYm9yZGVyV2lkdGg6IDAsXG5cbiAgICAgICAgICAgIC8vIOagh+mimOWGhei+uei3ne+8jOWNleS9jXB477yM6buY6K6k5ZCE5pa55ZCR5YaF6L656Led5Li6Ne+8jFxuICAgICAgICAgICAgLy8g5o6l5Y+X5pWw57uE5YiG5Yir6K6+5a6a5LiK5Y+z5LiL5bem6L656Led77yM5ZCMY3NzXG4gICAgICAgICAgICBwYWRkaW5nOiA1LFxuXG4gICAgICAgICAgICAvLyDkuLvlia/moIfpopjnurXlkJHpl7TpmpTvvIzljZXkvY1weO+8jOm7mOiupOS4ujEw77yMXG4gICAgICAgICAgICBpdGVtR2FwOiAxMCxcbiAgICAgICAgICAgIHRleHRTdHlsZToge1xuICAgICAgICAgICAgICAgIGZvbnRTaXplOiAxOCxcbiAgICAgICAgICAgICAgICBmb250V2VpZ2h0OiAnYm9sZGVyJyxcbiAgICAgICAgICAgICAgICBjb2xvcjogJyMzMzMnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3VidGV4dFN0eWxlOiB7XG4gICAgICAgICAgICAgICAgY29sb3I6ICcjYWFhJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBWaWV3XG4gICAgZWNoYXJ0cy5leHRlbmRDb21wb25lbnRWaWV3KHtcblxuICAgICAgICB0eXBlOiAndGl0bGUnLFxuXG4gICAgICAgIHJlbmRlcjogZnVuY3Rpb24gKHRpdGxlTW9kZWwsIGVjTW9kZWwsIGFwaSkge1xuICAgICAgICAgICAgdGhpcy5ncm91cC5yZW1vdmVBbGwoKTtcblxuICAgICAgICAgICAgaWYgKCF0aXRsZU1vZGVsLmdldCgnc2hvdycpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZ3JvdXAgPSB0aGlzLmdyb3VwO1xuXG4gICAgICAgICAgICB2YXIgdGV4dFN0eWxlTW9kZWwgPSB0aXRsZU1vZGVsLmdldE1vZGVsKCd0ZXh0U3R5bGUnKTtcbiAgICAgICAgICAgIHZhciBzdWJ0ZXh0U3R5bGVNb2RlbCA9IHRpdGxlTW9kZWwuZ2V0TW9kZWwoJ3N1YnRleHRTdHlsZScpO1xuXG4gICAgICAgICAgICB2YXIgdGV4dEFsaWduID0gdGl0bGVNb2RlbC5nZXQoJ3RleHRBbGlnbicpO1xuICAgICAgICAgICAgdmFyIHRleHRCYXNlbGluZSA9IHRpdGxlTW9kZWwuZ2V0KCd0ZXh0QmFzZWxpbmUnKTtcblxuICAgICAgICAgICAgdmFyIHRleHRFbCA9IG5ldyBncmFwaGljLlRleHQoe1xuICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IHRpdGxlTW9kZWwuZ2V0KCd0ZXh0JyksXG4gICAgICAgICAgICAgICAgICAgIHRleHRGb250OiB0ZXh0U3R5bGVNb2RlbC5nZXRGb250KCksXG4gICAgICAgICAgICAgICAgICAgIGZpbGw6IHRleHRTdHlsZU1vZGVsLmdldFRleHRDb2xvcigpXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB6MjogMTBcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB2YXIgdGV4dFJlY3QgPSB0ZXh0RWwuZ2V0Qm91bmRpbmdSZWN0KCk7XG5cbiAgICAgICAgICAgIHZhciBzdWJUZXh0ID0gdGl0bGVNb2RlbC5nZXQoJ3N1YnRleHQnKTtcbiAgICAgICAgICAgIHZhciBzdWJUZXh0RWwgPSBuZXcgZ3JhcGhpYy5UZXh0KHtcbiAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBzdWJUZXh0LFxuICAgICAgICAgICAgICAgICAgICB0ZXh0Rm9udDogc3VidGV4dFN0eWxlTW9kZWwuZ2V0Rm9udCgpLFxuICAgICAgICAgICAgICAgICAgICBmaWxsOiBzdWJ0ZXh0U3R5bGVNb2RlbC5nZXRUZXh0Q29sb3IoKSxcbiAgICAgICAgICAgICAgICAgICAgeTogdGV4dFJlY3QuaGVpZ2h0ICsgdGl0bGVNb2RlbC5nZXQoJ2l0ZW1HYXAnKSxcbiAgICAgICAgICAgICAgICAgICAgdGV4dEJhc2VsaW5lOiAndG9wJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgejI6IDEwXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdmFyIGxpbmsgPSB0aXRsZU1vZGVsLmdldCgnbGluaycpO1xuICAgICAgICAgICAgdmFyIHN1YmxpbmsgPSB0aXRsZU1vZGVsLmdldCgnc3VibGluaycpO1xuXG4gICAgICAgICAgICB0ZXh0RWwuc2lsZW50ID0gIWxpbms7XG4gICAgICAgICAgICBzdWJUZXh0RWwuc2lsZW50ID0gIXN1Ymxpbms7XG5cbiAgICAgICAgICAgIGlmIChsaW5rKSB7XG4gICAgICAgICAgICAgICAgdGV4dEVsLm9uKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93Lm9wZW4obGluaywgJ18nICsgdGl0bGVNb2RlbC5nZXQoJ3RhcmdldCcpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdWJsaW5rKSB7XG4gICAgICAgICAgICAgICAgc3ViVGV4dEVsLm9uKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93Lm9wZW4oc3VibGluaywgJ18nICsgdGl0bGVNb2RlbC5nZXQoJ3N1YnRhcmdldCcpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ3JvdXAuYWRkKHRleHRFbCk7XG4gICAgICAgICAgICBzdWJUZXh0ICYmIGdyb3VwLmFkZChzdWJUZXh0RWwpO1xuICAgICAgICAgICAgLy8gSWYgbm8gc3ViVGV4dCwgYnV0IGFkZCBzdWJUZXh0RWwsIHRoZXJlIHdpbGwgYmUgYW4gZW1wdHkgbGluZS5cblxuICAgICAgICAgICAgdmFyIGdyb3VwUmVjdCA9IGdyb3VwLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgICAgICAgICAgdmFyIGxheW91dE9wdGlvbiA9IHRpdGxlTW9kZWwuZ2V0Qm94TGF5b3V0UGFyYW1zKCk7XG4gICAgICAgICAgICBsYXlvdXRPcHRpb24ud2lkdGggPSBncm91cFJlY3Qud2lkdGg7XG4gICAgICAgICAgICBsYXlvdXRPcHRpb24uaGVpZ2h0ID0gZ3JvdXBSZWN0LmhlaWdodDtcbiAgICAgICAgICAgIHZhciBsYXlvdXRSZWN0ID0gbGF5b3V0LmdldExheW91dFJlY3QoXG4gICAgICAgICAgICAgICAgbGF5b3V0T3B0aW9uLCB7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBhcGkuZ2V0V2lkdGgoKSxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBhcGkuZ2V0SGVpZ2h0KClcbiAgICAgICAgICAgICAgICB9LCB0aXRsZU1vZGVsLmdldCgncGFkZGluZycpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgLy8gQWRqdXN0IHRleHQgYWxpZ24gYmFzZWQgb24gcG9zaXRpb25cbiAgICAgICAgICAgIGlmICghdGV4dEFsaWduKSB7XG4gICAgICAgICAgICAgICAgLy8gQWxpZ24gbGVmdCBpZiB0aXRsZSBpcyBvbiB0aGUgbGVmdC4gY2VudGVyIGFuZCByaWdodCBpcyBzYW1lXG4gICAgICAgICAgICAgICAgdGV4dEFsaWduID0gdGl0bGVNb2RlbC5nZXQoJ2xlZnQnKSB8fCB0aXRsZU1vZGVsLmdldCgncmlnaHQnKTtcbiAgICAgICAgICAgICAgICBpZiAodGV4dEFsaWduID09PSAnbWlkZGxlJykge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQWRqdXN0IGxheW91dCBieSB0ZXh0IGFsaWduXG4gICAgICAgICAgICAgICAgaWYgKHRleHRBbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgICAgICAgICAgICBsYXlvdXRSZWN0LnggKz0gbGF5b3V0UmVjdC53aWR0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGV4dEFsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICAgICAgICAgICAgICBsYXlvdXRSZWN0LnggKz0gbGF5b3V0UmVjdC53aWR0aCAvIDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0ZXh0QmFzZWxpbmUpIHtcbiAgICAgICAgICAgICAgICB0ZXh0QmFzZWxpbmUgPSB0aXRsZU1vZGVsLmdldCgndG9wJykgfHwgdGl0bGVNb2RlbC5nZXQoJ2JvdHRvbScpO1xuICAgICAgICAgICAgICAgIGlmICh0ZXh0QmFzZWxpbmUgPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGV4dEJhc2VsaW5lID09PSAnYm90dG9tJykge1xuICAgICAgICAgICAgICAgICAgICBsYXlvdXRSZWN0LnkgKz0gbGF5b3V0UmVjdC5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRleHRCYXNlbGluZSA9PT0gJ21pZGRsZScpIHtcbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0UmVjdC55ICs9IGxheW91dFJlY3QuaGVpZ2h0IC8gMjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0ZXh0QmFzZWxpbmUgPSB0ZXh0QmFzZWxpbmUgfHwgJ3RvcCc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGdyb3VwLmF0dHIoJ3Bvc2l0aW9uJywgW2xheW91dFJlY3QueCwgbGF5b3V0UmVjdC55XSk7XG4gICAgICAgICAgICB2YXIgYWxpZ25TdHlsZSA9IHtcbiAgICAgICAgICAgICAgICB0ZXh0QWxpZ246IHRleHRBbGlnbixcbiAgICAgICAgICAgICAgICB0ZXh0VmVydGljYWxBbGlnbjogdGV4dEJhc2VsaW5lXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGV4dEVsLnNldFN0eWxlKGFsaWduU3R5bGUpO1xuICAgICAgICAgICAgc3ViVGV4dEVsLnNldFN0eWxlKGFsaWduU3R5bGUpO1xuXG4gICAgICAgICAgICAvLyBSZW5kZXIgYmFja2dyb3VuZFxuICAgICAgICAgICAgLy8gR2V0IGdyb3VwUmVjdCBhZ2FpbiBiZWNhdXNlIHRleHRBbGlnbiBoYXMgYmVlbiBjaGFuZ2VkXG4gICAgICAgICAgICBncm91cFJlY3QgPSBncm91cC5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICAgICAgICAgIHZhciBwYWRkaW5nID0gbGF5b3V0UmVjdC5tYXJnaW47XG4gICAgICAgICAgICB2YXIgc3R5bGUgPSB0aXRsZU1vZGVsLmdldEl0ZW1TdHlsZShbJ2NvbG9yJywgJ29wYWNpdHknXSk7XG4gICAgICAgICAgICBzdHlsZS5maWxsID0gdGl0bGVNb2RlbC5nZXQoJ2JhY2tncm91bmRDb2xvcicpO1xuICAgICAgICAgICAgdmFyIHJlY3QgPSBuZXcgZ3JhcGhpYy5SZWN0KHtcbiAgICAgICAgICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgICAgICAgICB4OiBncm91cFJlY3QueCAtIHBhZGRpbmdbM10sXG4gICAgICAgICAgICAgICAgICAgIHk6IGdyb3VwUmVjdC55IC0gcGFkZGluZ1swXSxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGdyb3VwUmVjdC53aWR0aCArIHBhZGRpbmdbMV0gKyBwYWRkaW5nWzNdLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGdyb3VwUmVjdC5oZWlnaHQgKyBwYWRkaW5nWzBdICsgcGFkZGluZ1syXVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc3R5bGU6IHN0eWxlLFxuICAgICAgICAgICAgICAgIHNpbGVudDogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBncmFwaGljLnN1YlBpeGVsT3B0aW1pemVSZWN0KHJlY3QpO1xuXG4gICAgICAgICAgICBncm91cC5hZGQocmVjdCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2NvbXBvbmVudC90aXRsZS5qc1xuLy8gbW9kdWxlIGlkID0gMTkyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 193 */
/* unknown exports provided */
/* all exports used */
/*!**********************************!*\
  !*** ./lib/component/toolbox.js ***!
  \**********************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    __webpack_require__(/*! ./toolbox/ToolboxModel */ 228);\n    __webpack_require__(/*! ./toolbox/ToolboxView */ 229);\n\n    __webpack_require__(/*! ./toolbox/feature/SaveAsImage */ 234);\n    __webpack_require__(/*! ./toolbox/feature/MagicType */ 232);\n    __webpack_require__(/*! ./toolbox/feature/DataView */ 230);\n    __webpack_require__(/*! ./toolbox/feature/DataZoom */ 231);\n    __webpack_require__(/*! ./toolbox/feature/Restore */ 233);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTkzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2NvbXBvbmVudC90b29sYm94LmpzP2M1NjQiXSwic291cmNlc0NvbnRlbnQiOlsiXG5cbiAgICByZXF1aXJlKCcuL3Rvb2xib3gvVG9vbGJveE1vZGVsJyk7XG4gICAgcmVxdWlyZSgnLi90b29sYm94L1Rvb2xib3hWaWV3Jyk7XG5cbiAgICByZXF1aXJlKCcuL3Rvb2xib3gvZmVhdHVyZS9TYXZlQXNJbWFnZScpO1xuICAgIHJlcXVpcmUoJy4vdG9vbGJveC9mZWF0dXJlL01hZ2ljVHlwZScpO1xuICAgIHJlcXVpcmUoJy4vdG9vbGJveC9mZWF0dXJlL0RhdGFWaWV3Jyk7XG4gICAgcmVxdWlyZSgnLi90b29sYm94L2ZlYXR1cmUvRGF0YVpvb20nKTtcbiAgICByZXF1aXJlKCcuL3Rvb2xib3gvZmVhdHVyZS9SZXN0b3JlJyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9jb21wb25lbnQvdG9vbGJveC5qc1xuLy8gbW9kdWxlIGlkID0gMTkzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 194 */
/* unknown exports provided */
/* all exports used */
/*!**********************************!*\
  !*** ./lib/component/tooltip.js ***!
  \**********************************/
/***/ (function(module, exports, __webpack_require__) {

eval("// FIXME Better way to pack data in graphic element\n\n\n    __webpack_require__(/*! ./axisPointer */ 51);\n\n    __webpack_require__(/*! ./tooltip/TooltipModel */ 236);\n\n    __webpack_require__(/*! ./tooltip/TooltipView */ 237);\n\n\n    // Show tip action\n    /**\n     * @action\n     * @property {string} type\n     * @property {number} seriesIndex\n     * @property {number} dataIndex\n     * @property {number} [x]\n     * @property {number} [y]\n     */\n    __webpack_require__(/*! ../echarts */ 1).registerAction(\n        {\n            type: 'showTip',\n            event: 'showTip',\n            update: 'tooltip:manuallyShowTip'\n        },\n        // noop\n        function () {}\n    );\n    // Hide tip action\n    __webpack_require__(/*! ../echarts */ 1).registerAction(\n        {\n            type: 'hideTip',\n            event: 'hideTip',\n            update: 'tooltip:manuallyHideTip'\n        },\n        // noop\n        function () {}\n    );\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTk0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2NvbXBvbmVudC90b29sdGlwLmpzPzU1Y2MiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gRklYTUUgQmV0dGVyIHdheSB0byBwYWNrIGRhdGEgaW4gZ3JhcGhpYyBlbGVtZW50XG5cblxuICAgIHJlcXVpcmUoJy4vYXhpc1BvaW50ZXInKTtcblxuICAgIHJlcXVpcmUoJy4vdG9vbHRpcC9Ub29sdGlwTW9kZWwnKTtcblxuICAgIHJlcXVpcmUoJy4vdG9vbHRpcC9Ub29sdGlwVmlldycpO1xuXG5cbiAgICAvLyBTaG93IHRpcCBhY3Rpb25cbiAgICAvKipcbiAgICAgKiBAYWN0aW9uXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IHR5cGVcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gc2VyaWVzSW5kZXhcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gZGF0YUluZGV4XG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IFt4XVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbeV1cbiAgICAgKi9cbiAgICByZXF1aXJlKCcuLi9lY2hhcnRzJykucmVnaXN0ZXJBY3Rpb24oXG4gICAgICAgIHtcbiAgICAgICAgICAgIHR5cGU6ICdzaG93VGlwJyxcbiAgICAgICAgICAgIGV2ZW50OiAnc2hvd1RpcCcsXG4gICAgICAgICAgICB1cGRhdGU6ICd0b29sdGlwOm1hbnVhbGx5U2hvd1RpcCdcbiAgICAgICAgfSxcbiAgICAgICAgLy8gbm9vcFxuICAgICAgICBmdW5jdGlvbiAoKSB7fVxuICAgICk7XG4gICAgLy8gSGlkZSB0aXAgYWN0aW9uXG4gICAgcmVxdWlyZSgnLi4vZWNoYXJ0cycpLnJlZ2lzdGVyQWN0aW9uKFxuICAgICAgICB7XG4gICAgICAgICAgICB0eXBlOiAnaGlkZVRpcCcsXG4gICAgICAgICAgICBldmVudDogJ2hpZGVUaXAnLFxuICAgICAgICAgICAgdXBkYXRlOiAndG9vbHRpcDptYW51YWxseUhpZGVUaXAnXG4gICAgICAgIH0sXG4gICAgICAgIC8vIG5vb3BcbiAgICAgICAgZnVuY3Rpb24gKCkge31cbiAgICApO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvY29tcG9uZW50L3Rvb2x0aXAuanNcbi8vIG1vZHVsZSBpZCA9IDE5NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 195 */,
/* 196 */
/* unknown exports provided */
/* all exports used */
/*!****************************************************!*\
  !*** ./lib/component/helper/BrushTargetManager.js ***!
  \****************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 0);\n    var graphic = __webpack_require__(/*! ../../util/graphic */ 2);\n    var modelUtil = __webpack_require__(/*! ../../util/model */ 5);\n    var brushHelper = __webpack_require__(/*! ./brushHelper */ 197);\n\n    var each = zrUtil.each;\n    var indexOf = zrUtil.indexOf;\n    var curry = zrUtil.curry;\n\n    var COORD_CONVERTS = ['dataToPoint', 'pointToData'];\n\n    // FIXME\n    // how to genarialize to more coordinate systems.\n    var INCLUDE_FINDER_MAIN_TYPES = [\n        'grid', 'xAxis', 'yAxis', 'geo', 'graph',\n        'polar', 'radiusAxis', 'angleAxis', 'bmap'\n    ];\n\n    /**\n     * [option in constructor]:\n     * {\n     *     Index/Id/Name of geo, xAxis, yAxis, grid: See util/model#parseFinder.\n     * }\n     *\n     *\n     * [targetInfo]:\n     *\n     * There can be multiple axes in a single targetInfo. Consider the case\n     * of `grid` component, a targetInfo represents a grid which contains one or more\n     * cartesian and one or more axes. And consider the case of parallel system,\n     * which has multiple axes in a coordinate system.\n     * Can be {\n     *     panelId: ...,\n     *     coordSys: <a representitive cartesian in grid (first cartesian by default)>,\n     *     coordSyses: all cartesians.\n     *     gridModel: <grid component>\n     *     xAxes: correspond to coordSyses on index\n     *     yAxes: correspond to coordSyses on index\n     * }\n     * or {\n     *     panelId: ...,\n     *     coordSys: <geo coord sys>\n     *     coordSyses: [<geo coord sys>]\n     *     geoModel: <geo component>\n     * }\n     *\n     *\n     * [panelOpt]:\n     *\n     * Make from targetInfo. Input to BrushController.\n     * {\n     *     panelId: ...,\n     *     rect: ...\n     * }\n     *\n     *\n     * [area]:\n     *\n     * Generated by BrushController or user input.\n     * {\n     *     panelId: Used to locate coordInfo directly. If user inpput, no panelId.\n     *     brushType: determine how to convert to/from coord('rect' or 'polygon' or 'lineX/Y').\n     *     Index/Id/Name of geo, xAxis, yAxis, grid: See util/model#parseFinder.\n     *     range: pixel range.\n     *     coordRange: representitive coord range (the first one of coordRanges).\n     *     coordRanges: <Array> coord ranges, used in multiple cartesian in one grid.\n     * }\n     */\n\n    /**\n     * @param {Object} option contains Index/Id/Name of xAxis/yAxis/geo/grid\n     *        Each can be {number|Array.<number>}. like: {xAxisIndex: [3, 4]}\n     * @param {module:echarts/model/Global} ecModel\n     * @param {Object} [opt]\n     * @param {Array.<string>} [opt.include] include coordinate system types.\n     */\n    function BrushTargetManager(option, ecModel, opt) {\n        /**\n         * @private\n         * @type {Array.<Object>}\n         */\n        var targetInfoList = this._targetInfoList = [];\n        var info = {};\n        var foundCpts = parseFinder(ecModel, option);\n\n        each(targetInfoBuilders, function (builder, type) {\n            if (!opt || !opt.include || indexOf(opt.include, type) >= 0) {\n                builder(foundCpts, targetInfoList, info);\n            }\n        });\n    }\n\n    var proto = BrushTargetManager.prototype;\n\n    proto.setOutputRanges = function (areas, ecModel) {\n        this.matchOutputRanges(areas, ecModel, function (area, coordRange, coordSys) {\n            (area.coordRanges || (area.coordRanges = [])).push(coordRange);\n            // area.coordRange is the first of area.coordRanges\n            if (!area.coordRange) {\n                area.coordRange = coordRange;\n                // In 'category' axis, coord to pixel is not reversible, so we can not\n                // rebuild range by coordRange accrately, which may bring trouble when\n                // brushing only one item. So we use __rangeOffset to rebuilding range\n                // by coordRange. And this it only used in brush component so it is no\n                // need to be adapted to coordRanges.\n                var result = coordConvert[area.brushType](0, coordSys, coordRange);\n                area.__rangeOffset = {\n                    offset: diffProcessor[area.brushType](result.values, area.range, [1, 1]),\n                    xyMinMax: result.xyMinMax\n                };\n            }\n        });\n    };\n\n    proto.matchOutputRanges = function (areas, ecModel, cb) {\n        each(areas, function (area) {\n            var targetInfo = this.findTargetInfo(area, ecModel);\n\n            if (targetInfo && targetInfo !== true) {\n                zrUtil.each(\n                    targetInfo.coordSyses,\n                    function (coordSys) {\n                        var result = coordConvert[area.brushType](1, coordSys, area.range);\n                        cb(area, result.values, coordSys, ecModel);\n                    }\n                );\n            }\n        }, this);\n    };\n\n    proto.setInputRanges = function (areas, ecModel) {\n        each(areas, function (area) {\n            var targetInfo = this.findTargetInfo(area, ecModel);\n\n            if (true) {\n                zrUtil.assert(\n                    !targetInfo || targetInfo === true || area.coordRange,\n                    'coordRange must be specified when coord index specified.'\n                );\n                zrUtil.assert(\n                    !targetInfo || targetInfo !== true || area.range,\n                    'range must be specified in global brush.'\n                );\n            }\n\n            area.range = area.range || [];\n\n            // convert coordRange to global range and set panelId.\n            if (targetInfo && targetInfo !== true) {\n                area.panelId = targetInfo.panelId;\n                // (1) area.range shoule always be calculate from coordRange but does\n                // not keep its original value, for the sake of the dataZoom scenario,\n                // where area.coordRange remains unchanged but area.range may be changed.\n                // (2) Only support converting one coordRange to pixel range in brush\n                // component. So do not consider `coordRanges`.\n                // (3) About __rangeOffset, see comment above.\n                var result = coordConvert[area.brushType](0, targetInfo.coordSys, area.coordRange);\n                var rangeOffset = area.__rangeOffset;\n                area.range = rangeOffset\n                    ? diffProcessor[area.brushType](\n                        result.values,\n                        rangeOffset.offset,\n                        getScales(result.xyMinMax, rangeOffset.xyMinMax)\n                    )\n                    : result.values;\n            }\n        }, this);\n    };\n\n    proto.makePanelOpts = function (api, getDefaultBrushType) {\n        return zrUtil.map(this._targetInfoList, function (targetInfo) {\n            var rect = targetInfo.getPanelRect();\n            return {\n                panelId: targetInfo.panelId,\n                defaultBrushType: getDefaultBrushType && getDefaultBrushType(targetInfo),\n                clipPath: brushHelper.makeRectPanelClipPath(rect),\n                isTargetByCursor: brushHelper.makeRectIsTargetByCursor(\n                    rect, api, targetInfo.coordSysModel\n                ),\n                getLinearBrushOtherExtent: brushHelper.makeLinearBrushOtherExtent(rect)\n            };\n        });\n    };\n\n    proto.controlSeries = function (area, seriesModel, ecModel) {\n        // Check whether area is bound in coord, and series do not belong to that coord.\n        // If do not do this check, some brush (like lineX) will controll all axes.\n        var targetInfo = this.findTargetInfo(area, ecModel);\n        return targetInfo === true || (\n            targetInfo && indexOf(targetInfo.coordSyses, seriesModel.coordinateSystem) >= 0\n        );\n    };\n\n    /**\n     * If return Object, a coord found.\n     * If reutrn true, global found.\n     * Otherwise nothing found.\n     *\n     * @param {Object} area\n     * @param {Array} targetInfoList\n     * @return {Obejct|boolean}\n     */\n    proto.findTargetInfo = function (area, ecModel) {\n        var targetInfoList = this._targetInfoList;\n        var foundCpts = parseFinder(ecModel, area);\n\n        for (var i = 0; i < targetInfoList.length; i++) {\n            var targetInfo = targetInfoList[i];\n            var areaPanelId = area.panelId;\n            if (areaPanelId) {\n                if (targetInfo.panelId === areaPanelId) {\n                    return targetInfo;\n                }\n            }\n            else {\n                for (var i = 0; i < targetInfoMatchers.length; i++) {\n                    if (targetInfoMatchers[i](foundCpts, targetInfo)) {\n                        return targetInfo;\n                    }\n                }\n            }\n        }\n\n        return true;\n    };\n\n    function formatMinMax(minMax) {\n        minMax[0] > minMax[1] && minMax.reverse();\n        return minMax;\n    }\n\n    function parseFinder(ecModel, option) {\n        return modelUtil.parseFinder(\n            ecModel, option, {includeMainTypes: INCLUDE_FINDER_MAIN_TYPES}\n        );\n    }\n\n    var targetInfoBuilders = {\n\n        grid: function (foundCpts, targetInfoList) {\n            var xAxisModels = foundCpts.xAxisModels;\n            var yAxisModels = foundCpts.yAxisModels;\n            var gridModels = foundCpts.gridModels;\n            // Remove duplicated.\n            var gridModelMap = {};\n            var xAxesHas = {};\n            var yAxesHas = {};\n\n            if (!xAxisModels && !yAxisModels && !gridModels) {\n                return;\n            }\n\n            each(xAxisModels, function (axisModel) {\n                var gridModel = axisModel.axis.grid.model;\n                gridModelMap[gridModel.id] = gridModel;\n                xAxesHas[gridModel.id] = true;\n            });\n            each(yAxisModels, function (axisModel) {\n                var gridModel = axisModel.axis.grid.model;\n                gridModelMap[gridModel.id] = gridModel;\n                yAxesHas[gridModel.id] = true;\n            });\n            each(gridModels, function (gridModel) {\n                gridModelMap[gridModel.id] = gridModel;\n                xAxesHas[gridModel.id] = true;\n                yAxesHas[gridModel.id] = true;\n            });\n\n            each(gridModelMap, function (gridModel) {\n                var grid = gridModel.coordinateSystem;\n                var cartesians = [];\n\n                each(grid.getCartesians(), function (cartesian, index) {\n                    if (indexOf(xAxisModels, cartesian.getAxis('x').model) >= 0\n                        || indexOf(yAxisModels, cartesian.getAxis('y').model) >= 0\n                    ) {\n                        cartesians.push(cartesian);\n                    }\n                });\n                targetInfoList.push({\n                    panelId: 'grid--' + gridModel.id,\n                    gridModel: gridModel,\n                    coordSysModel: gridModel,\n                    // Use the first one as the representitive coordSys.\n                    coordSys: cartesians[0],\n                    coordSyses: cartesians,\n                    getPanelRect: panelRectBuilder.grid,\n                    xAxisDeclared: xAxesHas[gridModel.id],\n                    yAxisDeclared: yAxesHas[gridModel.id]\n                });\n            });\n        },\n\n        geo: function (foundCpts, targetInfoList) {\n            each(foundCpts.geoModels, function (geoModel) {\n                var coordSys = geoModel.coordinateSystem;\n                targetInfoList.push({\n                    panelId: 'geo--' + geoModel.id,\n                    geoModel: geoModel,\n                    coordSysModel: geoModel,\n                    coordSys: coordSys,\n                    coordSyses: [coordSys],\n                    getPanelRect: panelRectBuilder.geo\n                });\n            });\n        }\n    };\n\n    var targetInfoMatchers = [\n\n        // grid\n        function (foundCpts, targetInfo) {\n            var xAxisModel = foundCpts.xAxisModel;\n            var yAxisModel = foundCpts.yAxisModel;\n            var gridModel = foundCpts.gridModel;\n\n            !gridModel && xAxisModel && (gridModel = xAxisModel.axis.grid.model);\n            !gridModel && yAxisModel && (gridModel = yAxisModel.axis.grid.model);\n\n            return gridModel && gridModel === targetInfo.gridModel;\n        },\n\n        // geo\n        function (foundCpts, targetInfo) {\n            var geoModel = foundCpts.geoModel;\n            return geoModel && geoModel === targetInfo.geoModel;\n        }\n    ];\n\n    var panelRectBuilder = {\n\n        grid: function () {\n            // grid is not Transformable.\n            return this.coordSys.grid.getRect().clone();\n        },\n\n        geo: function () {\n            var coordSys = this.coordSys;\n            var rect = coordSys.getBoundingRect().clone();\n            // geo roam and zoom transform\n            rect.applyTransform(graphic.getTransform(coordSys));\n            return rect;\n        }\n    };\n\n    var coordConvert = {\n\n        lineX: curry(axisConvert, 0),\n\n        lineY: curry(axisConvert, 1),\n\n        rect: function (to, coordSys, rangeOrCoordRange) {\n            var xminymin = coordSys[COORD_CONVERTS[to]]([rangeOrCoordRange[0][0], rangeOrCoordRange[1][0]]);\n            var xmaxymax = coordSys[COORD_CONVERTS[to]]([rangeOrCoordRange[0][1], rangeOrCoordRange[1][1]]);\n            var values = [\n                formatMinMax([xminymin[0], xmaxymax[0]]),\n                formatMinMax([xminymin[1], xmaxymax[1]])\n            ];\n            return {values: values, xyMinMax: values};\n        },\n\n        polygon: function (to, coordSys, rangeOrCoordRange) {\n            var xyMinMax = [[Infinity, -Infinity], [Infinity, -Infinity]];\n            var values = zrUtil.map(rangeOrCoordRange, function (item) {\n                var p = coordSys[COORD_CONVERTS[to]](item);\n                xyMinMax[0][0] = Math.min(xyMinMax[0][0], p[0]);\n                xyMinMax[1][0] = Math.min(xyMinMax[1][0], p[1]);\n                xyMinMax[0][1] = Math.max(xyMinMax[0][1], p[0]);\n                xyMinMax[1][1] = Math.max(xyMinMax[1][1], p[1]);\n                return p;\n            });\n            return {values: values, xyMinMax: xyMinMax};\n        }\n    };\n\n    function axisConvert(axisNameIndex, to, coordSys, rangeOrCoordRange) {\n        if (true) {\n            zrUtil.assert(\n                coordSys.type === 'cartesian2d',\n                'lineX/lineY brush is available only in cartesian2d.'\n            );\n        }\n\n        var axis = coordSys.getAxis(['x', 'y'][axisNameIndex]);\n        var values = formatMinMax(zrUtil.map([0, 1], function (i) {\n            return to\n                ? axis.coordToData(axis.toLocalCoord(rangeOrCoordRange[i]))\n                : axis.toGlobalCoord(axis.dataToCoord(rangeOrCoordRange[i]));\n        }));\n        var xyMinMax = [];\n        xyMinMax[axisNameIndex] = values;\n        xyMinMax[1 - axisNameIndex] = [NaN, NaN];\n\n        return {values: values, xyMinMax: xyMinMax};\n    }\n\n    var diffProcessor = {\n        lineX: curry(axisDiffProcessor, 0),\n\n        lineY: curry(axisDiffProcessor, 1),\n\n        rect: function (values, refer, scales) {\n            return [\n                [values[0][0] - scales[0] * refer[0][0], values[0][1] - scales[0] * refer[0][1]],\n                [values[1][0] - scales[1] * refer[1][0], values[1][1] - scales[1] * refer[1][1]]\n            ];\n        },\n\n        polygon: function (values, refer, scales) {\n            return zrUtil.map(values, function (item, idx) {\n                return [item[0] - scales[0] * refer[idx][0], item[1] - scales[1] * refer[idx][1]];\n            });\n        }\n    };\n\n    function axisDiffProcessor(axisNameIndex, values, refer, scales) {\n        return [\n            values[0] - scales[axisNameIndex] * refer[0],\n            values[1] - scales[axisNameIndex] * refer[1]\n        ];\n    }\n\n    // We have to process scale caused by dataZoom manually,\n    // although it might be not accurate.\n    function getScales(xyMinMaxCurr, xyMinMaxOrigin) {\n        var sizeCurr = getSize(xyMinMaxCurr);\n        var sizeOrigin = getSize(xyMinMaxOrigin);\n        var scales = [sizeCurr[0] / sizeOrigin[0], sizeCurr[1] / sizeOrigin[1]];\n        isNaN(scales[0]) && (scales[0] = 1);\n        isNaN(scales[1]) && (scales[1] = 1);\n        return scales;\n    }\n\n    function getSize(xyMinMax) {\n        return xyMinMax\n            ? [xyMinMax[0][1] - xyMinMax[0][0], xyMinMax[1][1] - xyMinMax[1][0]]\n            : [NaN, NaN];\n    }\n\n    module.exports = BrushTargetManager;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTk2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2NvbXBvbmVudC9oZWxwZXIvQnJ1c2hUYXJnZXRNYW5hZ2VyLmpzP2FiMzYiXSwic291cmNlc0NvbnRlbnQiOlsiXG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKCcuLi8uLi91dGlsL2dyYXBoaWMnKTtcbiAgICB2YXIgbW9kZWxVdGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9tb2RlbCcpO1xuICAgIHZhciBicnVzaEhlbHBlciA9IHJlcXVpcmUoJy4vYnJ1c2hIZWxwZXInKTtcblxuICAgIHZhciBlYWNoID0genJVdGlsLmVhY2g7XG4gICAgdmFyIGluZGV4T2YgPSB6clV0aWwuaW5kZXhPZjtcbiAgICB2YXIgY3VycnkgPSB6clV0aWwuY3Vycnk7XG5cbiAgICB2YXIgQ09PUkRfQ09OVkVSVFMgPSBbJ2RhdGFUb1BvaW50JywgJ3BvaW50VG9EYXRhJ107XG5cbiAgICAvLyBGSVhNRVxuICAgIC8vIGhvdyB0byBnZW5hcmlhbGl6ZSB0byBtb3JlIGNvb3JkaW5hdGUgc3lzdGVtcy5cbiAgICB2YXIgSU5DTFVERV9GSU5ERVJfTUFJTl9UWVBFUyA9IFtcbiAgICAgICAgJ2dyaWQnLCAneEF4aXMnLCAneUF4aXMnLCAnZ2VvJywgJ2dyYXBoJyxcbiAgICAgICAgJ3BvbGFyJywgJ3JhZGl1c0F4aXMnLCAnYW5nbGVBeGlzJywgJ2JtYXAnXG4gICAgXTtcblxuICAgIC8qKlxuICAgICAqIFtvcHRpb24gaW4gY29uc3RydWN0b3JdOlxuICAgICAqIHtcbiAgICAgKiAgICAgSW5kZXgvSWQvTmFtZSBvZiBnZW8sIHhBeGlzLCB5QXhpcywgZ3JpZDogU2VlIHV0aWwvbW9kZWwjcGFyc2VGaW5kZXIuXG4gICAgICogfVxuICAgICAqXG4gICAgICpcbiAgICAgKiBbdGFyZ2V0SW5mb106XG4gICAgICpcbiAgICAgKiBUaGVyZSBjYW4gYmUgbXVsdGlwbGUgYXhlcyBpbiBhIHNpbmdsZSB0YXJnZXRJbmZvLiBDb25zaWRlciB0aGUgY2FzZVxuICAgICAqIG9mIGBncmlkYCBjb21wb25lbnQsIGEgdGFyZ2V0SW5mbyByZXByZXNlbnRzIGEgZ3JpZCB3aGljaCBjb250YWlucyBvbmUgb3IgbW9yZVxuICAgICAqIGNhcnRlc2lhbiBhbmQgb25lIG9yIG1vcmUgYXhlcy4gQW5kIGNvbnNpZGVyIHRoZSBjYXNlIG9mIHBhcmFsbGVsIHN5c3RlbSxcbiAgICAgKiB3aGljaCBoYXMgbXVsdGlwbGUgYXhlcyBpbiBhIGNvb3JkaW5hdGUgc3lzdGVtLlxuICAgICAqIENhbiBiZSB7XG4gICAgICogICAgIHBhbmVsSWQ6IC4uLixcbiAgICAgKiAgICAgY29vcmRTeXM6IDxhIHJlcHJlc2VudGl0aXZlIGNhcnRlc2lhbiBpbiBncmlkIChmaXJzdCBjYXJ0ZXNpYW4gYnkgZGVmYXVsdCk+LFxuICAgICAqICAgICBjb29yZFN5c2VzOiBhbGwgY2FydGVzaWFucy5cbiAgICAgKiAgICAgZ3JpZE1vZGVsOiA8Z3JpZCBjb21wb25lbnQ+XG4gICAgICogICAgIHhBeGVzOiBjb3JyZXNwb25kIHRvIGNvb3JkU3lzZXMgb24gaW5kZXhcbiAgICAgKiAgICAgeUF4ZXM6IGNvcnJlc3BvbmQgdG8gY29vcmRTeXNlcyBvbiBpbmRleFxuICAgICAqIH1cbiAgICAgKiBvciB7XG4gICAgICogICAgIHBhbmVsSWQ6IC4uLixcbiAgICAgKiAgICAgY29vcmRTeXM6IDxnZW8gY29vcmQgc3lzPlxuICAgICAqICAgICBjb29yZFN5c2VzOiBbPGdlbyBjb29yZCBzeXM+XVxuICAgICAqICAgICBnZW9Nb2RlbDogPGdlbyBjb21wb25lbnQ+XG4gICAgICogfVxuICAgICAqXG4gICAgICpcbiAgICAgKiBbcGFuZWxPcHRdOlxuICAgICAqXG4gICAgICogTWFrZSBmcm9tIHRhcmdldEluZm8uIElucHV0IHRvIEJydXNoQ29udHJvbGxlci5cbiAgICAgKiB7XG4gICAgICogICAgIHBhbmVsSWQ6IC4uLixcbiAgICAgKiAgICAgcmVjdDogLi4uXG4gICAgICogfVxuICAgICAqXG4gICAgICpcbiAgICAgKiBbYXJlYV06XG4gICAgICpcbiAgICAgKiBHZW5lcmF0ZWQgYnkgQnJ1c2hDb250cm9sbGVyIG9yIHVzZXIgaW5wdXQuXG4gICAgICoge1xuICAgICAqICAgICBwYW5lbElkOiBVc2VkIHRvIGxvY2F0ZSBjb29yZEluZm8gZGlyZWN0bHkuIElmIHVzZXIgaW5wcHV0LCBubyBwYW5lbElkLlxuICAgICAqICAgICBicnVzaFR5cGU6IGRldGVybWluZSBob3cgdG8gY29udmVydCB0by9mcm9tIGNvb3JkKCdyZWN0JyBvciAncG9seWdvbicgb3IgJ2xpbmVYL1knKS5cbiAgICAgKiAgICAgSW5kZXgvSWQvTmFtZSBvZiBnZW8sIHhBeGlzLCB5QXhpcywgZ3JpZDogU2VlIHV0aWwvbW9kZWwjcGFyc2VGaW5kZXIuXG4gICAgICogICAgIHJhbmdlOiBwaXhlbCByYW5nZS5cbiAgICAgKiAgICAgY29vcmRSYW5nZTogcmVwcmVzZW50aXRpdmUgY29vcmQgcmFuZ2UgKHRoZSBmaXJzdCBvbmUgb2YgY29vcmRSYW5nZXMpLlxuICAgICAqICAgICBjb29yZFJhbmdlczogPEFycmF5PiBjb29yZCByYW5nZXMsIHVzZWQgaW4gbXVsdGlwbGUgY2FydGVzaWFuIGluIG9uZSBncmlkLlxuICAgICAqIH1cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb24gY29udGFpbnMgSW5kZXgvSWQvTmFtZSBvZiB4QXhpcy95QXhpcy9nZW8vZ3JpZFxuICAgICAqICAgICAgICBFYWNoIGNhbiBiZSB7bnVtYmVyfEFycmF5LjxudW1iZXI+fS4gbGlrZToge3hBeGlzSW5kZXg6IFszLCA0XX1cbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL0dsb2JhbH0gZWNNb2RlbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0XVxuICAgICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IFtvcHQuaW5jbHVkZV0gaW5jbHVkZSBjb29yZGluYXRlIHN5c3RlbSB0eXBlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBCcnVzaFRhcmdldE1hbmFnZXIob3B0aW9uLCBlY01vZGVsLCBvcHQpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48T2JqZWN0Pn1cbiAgICAgICAgICovXG4gICAgICAgIHZhciB0YXJnZXRJbmZvTGlzdCA9IHRoaXMuX3RhcmdldEluZm9MaXN0ID0gW107XG4gICAgICAgIHZhciBpbmZvID0ge307XG4gICAgICAgIHZhciBmb3VuZENwdHMgPSBwYXJzZUZpbmRlcihlY01vZGVsLCBvcHRpb24pO1xuXG4gICAgICAgIGVhY2godGFyZ2V0SW5mb0J1aWxkZXJzLCBmdW5jdGlvbiAoYnVpbGRlciwgdHlwZSkge1xuICAgICAgICAgICAgaWYgKCFvcHQgfHwgIW9wdC5pbmNsdWRlIHx8IGluZGV4T2Yob3B0LmluY2x1ZGUsIHR5cGUpID49IDApIHtcbiAgICAgICAgICAgICAgICBidWlsZGVyKGZvdW5kQ3B0cywgdGFyZ2V0SW5mb0xpc3QsIGluZm8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgcHJvdG8gPSBCcnVzaFRhcmdldE1hbmFnZXIucHJvdG90eXBlO1xuXG4gICAgcHJvdG8uc2V0T3V0cHV0UmFuZ2VzID0gZnVuY3Rpb24gKGFyZWFzLCBlY01vZGVsKSB7XG4gICAgICAgIHRoaXMubWF0Y2hPdXRwdXRSYW5nZXMoYXJlYXMsIGVjTW9kZWwsIGZ1bmN0aW9uIChhcmVhLCBjb29yZFJhbmdlLCBjb29yZFN5cykge1xuICAgICAgICAgICAgKGFyZWEuY29vcmRSYW5nZXMgfHwgKGFyZWEuY29vcmRSYW5nZXMgPSBbXSkpLnB1c2goY29vcmRSYW5nZSk7XG4gICAgICAgICAgICAvLyBhcmVhLmNvb3JkUmFuZ2UgaXMgdGhlIGZpcnN0IG9mIGFyZWEuY29vcmRSYW5nZXNcbiAgICAgICAgICAgIGlmICghYXJlYS5jb29yZFJhbmdlKSB7XG4gICAgICAgICAgICAgICAgYXJlYS5jb29yZFJhbmdlID0gY29vcmRSYW5nZTtcbiAgICAgICAgICAgICAgICAvLyBJbiAnY2F0ZWdvcnknIGF4aXMsIGNvb3JkIHRvIHBpeGVsIGlzIG5vdCByZXZlcnNpYmxlLCBzbyB3ZSBjYW4gbm90XG4gICAgICAgICAgICAgICAgLy8gcmVidWlsZCByYW5nZSBieSBjb29yZFJhbmdlIGFjY3JhdGVseSwgd2hpY2ggbWF5IGJyaW5nIHRyb3VibGUgd2hlblxuICAgICAgICAgICAgICAgIC8vIGJydXNoaW5nIG9ubHkgb25lIGl0ZW0uIFNvIHdlIHVzZSBfX3JhbmdlT2Zmc2V0IHRvIHJlYnVpbGRpbmcgcmFuZ2VcbiAgICAgICAgICAgICAgICAvLyBieSBjb29yZFJhbmdlLiBBbmQgdGhpcyBpdCBvbmx5IHVzZWQgaW4gYnJ1c2ggY29tcG9uZW50IHNvIGl0IGlzIG5vXG4gICAgICAgICAgICAgICAgLy8gbmVlZCB0byBiZSBhZGFwdGVkIHRvIGNvb3JkUmFuZ2VzLlxuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBjb29yZENvbnZlcnRbYXJlYS5icnVzaFR5cGVdKDAsIGNvb3JkU3lzLCBjb29yZFJhbmdlKTtcbiAgICAgICAgICAgICAgICBhcmVhLl9fcmFuZ2VPZmZzZXQgPSB7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldDogZGlmZlByb2Nlc3NvclthcmVhLmJydXNoVHlwZV0ocmVzdWx0LnZhbHVlcywgYXJlYS5yYW5nZSwgWzEsIDFdKSxcbiAgICAgICAgICAgICAgICAgICAgeHlNaW5NYXg6IHJlc3VsdC54eU1pbk1heFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBwcm90by5tYXRjaE91dHB1dFJhbmdlcyA9IGZ1bmN0aW9uIChhcmVhcywgZWNNb2RlbCwgY2IpIHtcbiAgICAgICAgZWFjaChhcmVhcywgZnVuY3Rpb24gKGFyZWEpIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXRJbmZvID0gdGhpcy5maW5kVGFyZ2V0SW5mbyhhcmVhLCBlY01vZGVsKTtcblxuICAgICAgICAgICAgaWYgKHRhcmdldEluZm8gJiYgdGFyZ2V0SW5mbyAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHpyVXRpbC5lYWNoKFxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRJbmZvLmNvb3JkU3lzZXMsXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChjb29yZFN5cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGNvb3JkQ29udmVydFthcmVhLmJydXNoVHlwZV0oMSwgY29vcmRTeXMsIGFyZWEucmFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2IoYXJlYSwgcmVzdWx0LnZhbHVlcywgY29vcmRTeXMsIGVjTW9kZWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfTtcblxuICAgIHByb3RvLnNldElucHV0UmFuZ2VzID0gZnVuY3Rpb24gKGFyZWFzLCBlY01vZGVsKSB7XG4gICAgICAgIGVhY2goYXJlYXMsIGZ1bmN0aW9uIChhcmVhKSB7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0SW5mbyA9IHRoaXMuZmluZFRhcmdldEluZm8oYXJlYSwgZWNNb2RlbCk7XG5cbiAgICAgICAgICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgICAgICAgICAgenJVdGlsLmFzc2VydChcbiAgICAgICAgICAgICAgICAgICAgIXRhcmdldEluZm8gfHwgdGFyZ2V0SW5mbyA9PT0gdHJ1ZSB8fCBhcmVhLmNvb3JkUmFuZ2UsXG4gICAgICAgICAgICAgICAgICAgICdjb29yZFJhbmdlIG11c3QgYmUgc3BlY2lmaWVkIHdoZW4gY29vcmQgaW5kZXggc3BlY2lmaWVkLidcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHpyVXRpbC5hc3NlcnQoXG4gICAgICAgICAgICAgICAgICAgICF0YXJnZXRJbmZvIHx8IHRhcmdldEluZm8gIT09IHRydWUgfHwgYXJlYS5yYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgJ3JhbmdlIG11c3QgYmUgc3BlY2lmaWVkIGluIGdsb2JhbCBicnVzaC4nXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYXJlYS5yYW5nZSA9IGFyZWEucmFuZ2UgfHwgW107XG5cbiAgICAgICAgICAgIC8vIGNvbnZlcnQgY29vcmRSYW5nZSB0byBnbG9iYWwgcmFuZ2UgYW5kIHNldCBwYW5lbElkLlxuICAgICAgICAgICAgaWYgKHRhcmdldEluZm8gJiYgdGFyZ2V0SW5mbyAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGFyZWEucGFuZWxJZCA9IHRhcmdldEluZm8ucGFuZWxJZDtcbiAgICAgICAgICAgICAgICAvLyAoMSkgYXJlYS5yYW5nZSBzaG91bGUgYWx3YXlzIGJlIGNhbGN1bGF0ZSBmcm9tIGNvb3JkUmFuZ2UgYnV0IGRvZXNcbiAgICAgICAgICAgICAgICAvLyBub3Qga2VlcCBpdHMgb3JpZ2luYWwgdmFsdWUsIGZvciB0aGUgc2FrZSBvZiB0aGUgZGF0YVpvb20gc2NlbmFyaW8sXG4gICAgICAgICAgICAgICAgLy8gd2hlcmUgYXJlYS5jb29yZFJhbmdlIHJlbWFpbnMgdW5jaGFuZ2VkIGJ1dCBhcmVhLnJhbmdlIG1heSBiZSBjaGFuZ2VkLlxuICAgICAgICAgICAgICAgIC8vICgyKSBPbmx5IHN1cHBvcnQgY29udmVydGluZyBvbmUgY29vcmRSYW5nZSB0byBwaXhlbCByYW5nZSBpbiBicnVzaFxuICAgICAgICAgICAgICAgIC8vIGNvbXBvbmVudC4gU28gZG8gbm90IGNvbnNpZGVyIGBjb29yZFJhbmdlc2AuXG4gICAgICAgICAgICAgICAgLy8gKDMpIEFib3V0IF9fcmFuZ2VPZmZzZXQsIHNlZSBjb21tZW50IGFib3ZlLlxuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBjb29yZENvbnZlcnRbYXJlYS5icnVzaFR5cGVdKDAsIHRhcmdldEluZm8uY29vcmRTeXMsIGFyZWEuY29vcmRSYW5nZSk7XG4gICAgICAgICAgICAgICAgdmFyIHJhbmdlT2Zmc2V0ID0gYXJlYS5fX3JhbmdlT2Zmc2V0O1xuICAgICAgICAgICAgICAgIGFyZWEucmFuZ2UgPSByYW5nZU9mZnNldFxuICAgICAgICAgICAgICAgICAgICA/IGRpZmZQcm9jZXNzb3JbYXJlYS5icnVzaFR5cGVdKFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnZhbHVlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlT2Zmc2V0Lm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFNjYWxlcyhyZXN1bHQueHlNaW5NYXgsIHJhbmdlT2Zmc2V0Lnh5TWluTWF4KVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIDogcmVzdWx0LnZhbHVlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfTtcblxuICAgIHByb3RvLm1ha2VQYW5lbE9wdHMgPSBmdW5jdGlvbiAoYXBpLCBnZXREZWZhdWx0QnJ1c2hUeXBlKSB7XG4gICAgICAgIHJldHVybiB6clV0aWwubWFwKHRoaXMuX3RhcmdldEluZm9MaXN0LCBmdW5jdGlvbiAodGFyZ2V0SW5mbykge1xuICAgICAgICAgICAgdmFyIHJlY3QgPSB0YXJnZXRJbmZvLmdldFBhbmVsUmVjdCgpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBwYW5lbElkOiB0YXJnZXRJbmZvLnBhbmVsSWQsXG4gICAgICAgICAgICAgICAgZGVmYXVsdEJydXNoVHlwZTogZ2V0RGVmYXVsdEJydXNoVHlwZSAmJiBnZXREZWZhdWx0QnJ1c2hUeXBlKHRhcmdldEluZm8pLFxuICAgICAgICAgICAgICAgIGNsaXBQYXRoOiBicnVzaEhlbHBlci5tYWtlUmVjdFBhbmVsQ2xpcFBhdGgocmVjdCksXG4gICAgICAgICAgICAgICAgaXNUYXJnZXRCeUN1cnNvcjogYnJ1c2hIZWxwZXIubWFrZVJlY3RJc1RhcmdldEJ5Q3Vyc29yKFxuICAgICAgICAgICAgICAgICAgICByZWN0LCBhcGksIHRhcmdldEluZm8uY29vcmRTeXNNb2RlbFxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgZ2V0TGluZWFyQnJ1c2hPdGhlckV4dGVudDogYnJ1c2hIZWxwZXIubWFrZUxpbmVhckJydXNoT3RoZXJFeHRlbnQocmVjdClcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBwcm90by5jb250cm9sU2VyaWVzID0gZnVuY3Rpb24gKGFyZWEsIHNlcmllc01vZGVsLCBlY01vZGVsKSB7XG4gICAgICAgIC8vIENoZWNrIHdoZXRoZXIgYXJlYSBpcyBib3VuZCBpbiBjb29yZCwgYW5kIHNlcmllcyBkbyBub3QgYmVsb25nIHRvIHRoYXQgY29vcmQuXG4gICAgICAgIC8vIElmIGRvIG5vdCBkbyB0aGlzIGNoZWNrLCBzb21lIGJydXNoIChsaWtlIGxpbmVYKSB3aWxsIGNvbnRyb2xsIGFsbCBheGVzLlxuICAgICAgICB2YXIgdGFyZ2V0SW5mbyA9IHRoaXMuZmluZFRhcmdldEluZm8oYXJlYSwgZWNNb2RlbCk7XG4gICAgICAgIHJldHVybiB0YXJnZXRJbmZvID09PSB0cnVlIHx8IChcbiAgICAgICAgICAgIHRhcmdldEluZm8gJiYgaW5kZXhPZih0YXJnZXRJbmZvLmNvb3JkU3lzZXMsIHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW0pID49IDBcbiAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSWYgcmV0dXJuIE9iamVjdCwgYSBjb29yZCBmb3VuZC5cbiAgICAgKiBJZiByZXV0cm4gdHJ1ZSwgZ2xvYmFsIGZvdW5kLlxuICAgICAqIE90aGVyd2lzZSBub3RoaW5nIGZvdW5kLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFyZWFcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB0YXJnZXRJbmZvTGlzdFxuICAgICAqIEByZXR1cm4ge09iZWpjdHxib29sZWFufVxuICAgICAqL1xuICAgIHByb3RvLmZpbmRUYXJnZXRJbmZvID0gZnVuY3Rpb24gKGFyZWEsIGVjTW9kZWwpIHtcbiAgICAgICAgdmFyIHRhcmdldEluZm9MaXN0ID0gdGhpcy5fdGFyZ2V0SW5mb0xpc3Q7XG4gICAgICAgIHZhciBmb3VuZENwdHMgPSBwYXJzZUZpbmRlcihlY01vZGVsLCBhcmVhKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRhcmdldEluZm9MaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0SW5mbyA9IHRhcmdldEluZm9MaXN0W2ldO1xuICAgICAgICAgICAgdmFyIGFyZWFQYW5lbElkID0gYXJlYS5wYW5lbElkO1xuICAgICAgICAgICAgaWYgKGFyZWFQYW5lbElkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldEluZm8ucGFuZWxJZCA9PT0gYXJlYVBhbmVsSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldEluZm87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0YXJnZXRJbmZvTWF0Y2hlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldEluZm9NYXRjaGVyc1tpXShmb3VuZENwdHMsIHRhcmdldEluZm8pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0SW5mbztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBmb3JtYXRNaW5NYXgobWluTWF4KSB7XG4gICAgICAgIG1pbk1heFswXSA+IG1pbk1heFsxXSAmJiBtaW5NYXgucmV2ZXJzZSgpO1xuICAgICAgICByZXR1cm4gbWluTWF4O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlRmluZGVyKGVjTW9kZWwsIG9wdGlvbikge1xuICAgICAgICByZXR1cm4gbW9kZWxVdGlsLnBhcnNlRmluZGVyKFxuICAgICAgICAgICAgZWNNb2RlbCwgb3B0aW9uLCB7aW5jbHVkZU1haW5UeXBlczogSU5DTFVERV9GSU5ERVJfTUFJTl9UWVBFU31cbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgdGFyZ2V0SW5mb0J1aWxkZXJzID0ge1xuXG4gICAgICAgIGdyaWQ6IGZ1bmN0aW9uIChmb3VuZENwdHMsIHRhcmdldEluZm9MaXN0KSB7XG4gICAgICAgICAgICB2YXIgeEF4aXNNb2RlbHMgPSBmb3VuZENwdHMueEF4aXNNb2RlbHM7XG4gICAgICAgICAgICB2YXIgeUF4aXNNb2RlbHMgPSBmb3VuZENwdHMueUF4aXNNb2RlbHM7XG4gICAgICAgICAgICB2YXIgZ3JpZE1vZGVscyA9IGZvdW5kQ3B0cy5ncmlkTW9kZWxzO1xuICAgICAgICAgICAgLy8gUmVtb3ZlIGR1cGxpY2F0ZWQuXG4gICAgICAgICAgICB2YXIgZ3JpZE1vZGVsTWFwID0ge307XG4gICAgICAgICAgICB2YXIgeEF4ZXNIYXMgPSB7fTtcbiAgICAgICAgICAgIHZhciB5QXhlc0hhcyA9IHt9O1xuXG4gICAgICAgICAgICBpZiAoIXhBeGlzTW9kZWxzICYmICF5QXhpc01vZGVscyAmJiAhZ3JpZE1vZGVscykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZWFjaCh4QXhpc01vZGVscywgZnVuY3Rpb24gKGF4aXNNb2RlbCkge1xuICAgICAgICAgICAgICAgIHZhciBncmlkTW9kZWwgPSBheGlzTW9kZWwuYXhpcy5ncmlkLm1vZGVsO1xuICAgICAgICAgICAgICAgIGdyaWRNb2RlbE1hcFtncmlkTW9kZWwuaWRdID0gZ3JpZE1vZGVsO1xuICAgICAgICAgICAgICAgIHhBeGVzSGFzW2dyaWRNb2RlbC5pZF0gPSB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBlYWNoKHlBeGlzTW9kZWxzLCBmdW5jdGlvbiAoYXhpc01vZGVsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGdyaWRNb2RlbCA9IGF4aXNNb2RlbC5heGlzLmdyaWQubW9kZWw7XG4gICAgICAgICAgICAgICAgZ3JpZE1vZGVsTWFwW2dyaWRNb2RlbC5pZF0gPSBncmlkTW9kZWw7XG4gICAgICAgICAgICAgICAgeUF4ZXNIYXNbZ3JpZE1vZGVsLmlkXSA9IHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGVhY2goZ3JpZE1vZGVscywgZnVuY3Rpb24gKGdyaWRNb2RlbCkge1xuICAgICAgICAgICAgICAgIGdyaWRNb2RlbE1hcFtncmlkTW9kZWwuaWRdID0gZ3JpZE1vZGVsO1xuICAgICAgICAgICAgICAgIHhBeGVzSGFzW2dyaWRNb2RlbC5pZF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHlBeGVzSGFzW2dyaWRNb2RlbC5pZF0gPSB0cnVlO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGVhY2goZ3JpZE1vZGVsTWFwLCBmdW5jdGlvbiAoZ3JpZE1vZGVsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGdyaWQgPSBncmlkTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcbiAgICAgICAgICAgICAgICB2YXIgY2FydGVzaWFucyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgZWFjaChncmlkLmdldENhcnRlc2lhbnMoKSwgZnVuY3Rpb24gKGNhcnRlc2lhbiwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4T2YoeEF4aXNNb2RlbHMsIGNhcnRlc2lhbi5nZXRBeGlzKCd4JykubW9kZWwpID49IDBcbiAgICAgICAgICAgICAgICAgICAgICAgIHx8IGluZGV4T2YoeUF4aXNNb2RlbHMsIGNhcnRlc2lhbi5nZXRBeGlzKCd5JykubW9kZWwpID49IDBcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXJ0ZXNpYW5zLnB1c2goY2FydGVzaWFuKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRhcmdldEluZm9MaXN0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBwYW5lbElkOiAnZ3JpZC0tJyArIGdyaWRNb2RlbC5pZCxcbiAgICAgICAgICAgICAgICAgICAgZ3JpZE1vZGVsOiBncmlkTW9kZWwsXG4gICAgICAgICAgICAgICAgICAgIGNvb3JkU3lzTW9kZWw6IGdyaWRNb2RlbCxcbiAgICAgICAgICAgICAgICAgICAgLy8gVXNlIHRoZSBmaXJzdCBvbmUgYXMgdGhlIHJlcHJlc2VudGl0aXZlIGNvb3JkU3lzLlxuICAgICAgICAgICAgICAgICAgICBjb29yZFN5czogY2FydGVzaWFuc1swXSxcbiAgICAgICAgICAgICAgICAgICAgY29vcmRTeXNlczogY2FydGVzaWFucyxcbiAgICAgICAgICAgICAgICAgICAgZ2V0UGFuZWxSZWN0OiBwYW5lbFJlY3RCdWlsZGVyLmdyaWQsXG4gICAgICAgICAgICAgICAgICAgIHhBeGlzRGVjbGFyZWQ6IHhBeGVzSGFzW2dyaWRNb2RlbC5pZF0sXG4gICAgICAgICAgICAgICAgICAgIHlBeGlzRGVjbGFyZWQ6IHlBeGVzSGFzW2dyaWRNb2RlbC5pZF1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdlbzogZnVuY3Rpb24gKGZvdW5kQ3B0cywgdGFyZ2V0SW5mb0xpc3QpIHtcbiAgICAgICAgICAgIGVhY2goZm91bmRDcHRzLmdlb01vZGVscywgZnVuY3Rpb24gKGdlb01vZGVsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvb3JkU3lzID0gZ2VvTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcbiAgICAgICAgICAgICAgICB0YXJnZXRJbmZvTGlzdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgcGFuZWxJZDogJ2dlby0tJyArIGdlb01vZGVsLmlkLFxuICAgICAgICAgICAgICAgICAgICBnZW9Nb2RlbDogZ2VvTW9kZWwsXG4gICAgICAgICAgICAgICAgICAgIGNvb3JkU3lzTW9kZWw6IGdlb01vZGVsLFxuICAgICAgICAgICAgICAgICAgICBjb29yZFN5czogY29vcmRTeXMsXG4gICAgICAgICAgICAgICAgICAgIGNvb3JkU3lzZXM6IFtjb29yZFN5c10sXG4gICAgICAgICAgICAgICAgICAgIGdldFBhbmVsUmVjdDogcGFuZWxSZWN0QnVpbGRlci5nZW9cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciB0YXJnZXRJbmZvTWF0Y2hlcnMgPSBbXG5cbiAgICAgICAgLy8gZ3JpZFxuICAgICAgICBmdW5jdGlvbiAoZm91bmRDcHRzLCB0YXJnZXRJbmZvKSB7XG4gICAgICAgICAgICB2YXIgeEF4aXNNb2RlbCA9IGZvdW5kQ3B0cy54QXhpc01vZGVsO1xuICAgICAgICAgICAgdmFyIHlBeGlzTW9kZWwgPSBmb3VuZENwdHMueUF4aXNNb2RlbDtcbiAgICAgICAgICAgIHZhciBncmlkTW9kZWwgPSBmb3VuZENwdHMuZ3JpZE1vZGVsO1xuXG4gICAgICAgICAgICAhZ3JpZE1vZGVsICYmIHhBeGlzTW9kZWwgJiYgKGdyaWRNb2RlbCA9IHhBeGlzTW9kZWwuYXhpcy5ncmlkLm1vZGVsKTtcbiAgICAgICAgICAgICFncmlkTW9kZWwgJiYgeUF4aXNNb2RlbCAmJiAoZ3JpZE1vZGVsID0geUF4aXNNb2RlbC5heGlzLmdyaWQubW9kZWwpO1xuXG4gICAgICAgICAgICByZXR1cm4gZ3JpZE1vZGVsICYmIGdyaWRNb2RlbCA9PT0gdGFyZ2V0SW5mby5ncmlkTW9kZWw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gZ2VvXG4gICAgICAgIGZ1bmN0aW9uIChmb3VuZENwdHMsIHRhcmdldEluZm8pIHtcbiAgICAgICAgICAgIHZhciBnZW9Nb2RlbCA9IGZvdW5kQ3B0cy5nZW9Nb2RlbDtcbiAgICAgICAgICAgIHJldHVybiBnZW9Nb2RlbCAmJiBnZW9Nb2RlbCA9PT0gdGFyZ2V0SW5mby5nZW9Nb2RlbDtcbiAgICAgICAgfVxuICAgIF07XG5cbiAgICB2YXIgcGFuZWxSZWN0QnVpbGRlciA9IHtcblxuICAgICAgICBncmlkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBncmlkIGlzIG5vdCBUcmFuc2Zvcm1hYmxlLlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29vcmRTeXMuZ3JpZC5nZXRSZWN0KCkuY2xvbmUoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZW86IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjb29yZFN5cyA9IHRoaXMuY29vcmRTeXM7XG4gICAgICAgICAgICB2YXIgcmVjdCA9IGNvb3JkU3lzLmdldEJvdW5kaW5nUmVjdCgpLmNsb25lKCk7XG4gICAgICAgICAgICAvLyBnZW8gcm9hbSBhbmQgem9vbSB0cmFuc2Zvcm1cbiAgICAgICAgICAgIHJlY3QuYXBwbHlUcmFuc2Zvcm0oZ3JhcGhpYy5nZXRUcmFuc2Zvcm0oY29vcmRTeXMpKTtcbiAgICAgICAgICAgIHJldHVybiByZWN0O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBjb29yZENvbnZlcnQgPSB7XG5cbiAgICAgICAgbGluZVg6IGN1cnJ5KGF4aXNDb252ZXJ0LCAwKSxcblxuICAgICAgICBsaW5lWTogY3VycnkoYXhpc0NvbnZlcnQsIDEpLFxuXG4gICAgICAgIHJlY3Q6IGZ1bmN0aW9uICh0bywgY29vcmRTeXMsIHJhbmdlT3JDb29yZFJhbmdlKSB7XG4gICAgICAgICAgICB2YXIgeG1pbnltaW4gPSBjb29yZFN5c1tDT09SRF9DT05WRVJUU1t0b11dKFtyYW5nZU9yQ29vcmRSYW5nZVswXVswXSwgcmFuZ2VPckNvb3JkUmFuZ2VbMV1bMF1dKTtcbiAgICAgICAgICAgIHZhciB4bWF4eW1heCA9IGNvb3JkU3lzW0NPT1JEX0NPTlZFUlRTW3RvXV0oW3JhbmdlT3JDb29yZFJhbmdlWzBdWzFdLCByYW5nZU9yQ29vcmRSYW5nZVsxXVsxXV0pO1xuICAgICAgICAgICAgdmFyIHZhbHVlcyA9IFtcbiAgICAgICAgICAgICAgICBmb3JtYXRNaW5NYXgoW3htaW55bWluWzBdLCB4bWF4eW1heFswXV0pLFxuICAgICAgICAgICAgICAgIGZvcm1hdE1pbk1heChbeG1pbnltaW5bMV0sIHhtYXh5bWF4WzFdXSlcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICByZXR1cm4ge3ZhbHVlczogdmFsdWVzLCB4eU1pbk1heDogdmFsdWVzfTtcbiAgICAgICAgfSxcblxuICAgICAgICBwb2x5Z29uOiBmdW5jdGlvbiAodG8sIGNvb3JkU3lzLCByYW5nZU9yQ29vcmRSYW5nZSkge1xuICAgICAgICAgICAgdmFyIHh5TWluTWF4ID0gW1tJbmZpbml0eSwgLUluZmluaXR5XSwgW0luZmluaXR5LCAtSW5maW5pdHldXTtcbiAgICAgICAgICAgIHZhciB2YWx1ZXMgPSB6clV0aWwubWFwKHJhbmdlT3JDb29yZFJhbmdlLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgIHZhciBwID0gY29vcmRTeXNbQ09PUkRfQ09OVkVSVFNbdG9dXShpdGVtKTtcbiAgICAgICAgICAgICAgICB4eU1pbk1heFswXVswXSA9IE1hdGgubWluKHh5TWluTWF4WzBdWzBdLCBwWzBdKTtcbiAgICAgICAgICAgICAgICB4eU1pbk1heFsxXVswXSA9IE1hdGgubWluKHh5TWluTWF4WzFdWzBdLCBwWzFdKTtcbiAgICAgICAgICAgICAgICB4eU1pbk1heFswXVsxXSA9IE1hdGgubWF4KHh5TWluTWF4WzBdWzFdLCBwWzBdKTtcbiAgICAgICAgICAgICAgICB4eU1pbk1heFsxXVsxXSA9IE1hdGgubWF4KHh5TWluTWF4WzFdWzFdLCBwWzFdKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHt2YWx1ZXM6IHZhbHVlcywgeHlNaW5NYXg6IHh5TWluTWF4fTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBheGlzQ29udmVydChheGlzTmFtZUluZGV4LCB0bywgY29vcmRTeXMsIHJhbmdlT3JDb29yZFJhbmdlKSB7XG4gICAgICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgICAgICB6clV0aWwuYXNzZXJ0KFxuICAgICAgICAgICAgICAgIGNvb3JkU3lzLnR5cGUgPT09ICdjYXJ0ZXNpYW4yZCcsXG4gICAgICAgICAgICAgICAgJ2xpbmVYL2xpbmVZIGJydXNoIGlzIGF2YWlsYWJsZSBvbmx5IGluIGNhcnRlc2lhbjJkLidcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYXhpcyA9IGNvb3JkU3lzLmdldEF4aXMoWyd4JywgJ3knXVtheGlzTmFtZUluZGV4XSk7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBmb3JtYXRNaW5NYXgoenJVdGlsLm1hcChbMCwgMV0sIGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9cbiAgICAgICAgICAgICAgICA/IGF4aXMuY29vcmRUb0RhdGEoYXhpcy50b0xvY2FsQ29vcmQocmFuZ2VPckNvb3JkUmFuZ2VbaV0pKVxuICAgICAgICAgICAgICAgIDogYXhpcy50b0dsb2JhbENvb3JkKGF4aXMuZGF0YVRvQ29vcmQocmFuZ2VPckNvb3JkUmFuZ2VbaV0pKTtcbiAgICAgICAgfSkpO1xuICAgICAgICB2YXIgeHlNaW5NYXggPSBbXTtcbiAgICAgICAgeHlNaW5NYXhbYXhpc05hbWVJbmRleF0gPSB2YWx1ZXM7XG4gICAgICAgIHh5TWluTWF4WzEgLSBheGlzTmFtZUluZGV4XSA9IFtOYU4sIE5hTl07XG5cbiAgICAgICAgcmV0dXJuIHt2YWx1ZXM6IHZhbHVlcywgeHlNaW5NYXg6IHh5TWluTWF4fTtcbiAgICB9XG5cbiAgICB2YXIgZGlmZlByb2Nlc3NvciA9IHtcbiAgICAgICAgbGluZVg6IGN1cnJ5KGF4aXNEaWZmUHJvY2Vzc29yLCAwKSxcblxuICAgICAgICBsaW5lWTogY3VycnkoYXhpc0RpZmZQcm9jZXNzb3IsIDEpLFxuXG4gICAgICAgIHJlY3Q6IGZ1bmN0aW9uICh2YWx1ZXMsIHJlZmVyLCBzY2FsZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgW3ZhbHVlc1swXVswXSAtIHNjYWxlc1swXSAqIHJlZmVyWzBdWzBdLCB2YWx1ZXNbMF1bMV0gLSBzY2FsZXNbMF0gKiByZWZlclswXVsxXV0sXG4gICAgICAgICAgICAgICAgW3ZhbHVlc1sxXVswXSAtIHNjYWxlc1sxXSAqIHJlZmVyWzFdWzBdLCB2YWx1ZXNbMV1bMV0gLSBzY2FsZXNbMV0gKiByZWZlclsxXVsxXV1cbiAgICAgICAgICAgIF07XG4gICAgICAgIH0sXG5cbiAgICAgICAgcG9seWdvbjogZnVuY3Rpb24gKHZhbHVlcywgcmVmZXIsIHNjYWxlcykge1xuICAgICAgICAgICAgcmV0dXJuIHpyVXRpbC5tYXAodmFsdWVzLCBmdW5jdGlvbiAoaXRlbSwgaWR4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtpdGVtWzBdIC0gc2NhbGVzWzBdICogcmVmZXJbaWR4XVswXSwgaXRlbVsxXSAtIHNjYWxlc1sxXSAqIHJlZmVyW2lkeF1bMV1dO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gYXhpc0RpZmZQcm9jZXNzb3IoYXhpc05hbWVJbmRleCwgdmFsdWVzLCByZWZlciwgc2NhbGVzKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB2YWx1ZXNbMF0gLSBzY2FsZXNbYXhpc05hbWVJbmRleF0gKiByZWZlclswXSxcbiAgICAgICAgICAgIHZhbHVlc1sxXSAtIHNjYWxlc1theGlzTmFtZUluZGV4XSAqIHJlZmVyWzFdXG4gICAgICAgIF07XG4gICAgfVxuXG4gICAgLy8gV2UgaGF2ZSB0byBwcm9jZXNzIHNjYWxlIGNhdXNlZCBieSBkYXRhWm9vbSBtYW51YWxseSxcbiAgICAvLyBhbHRob3VnaCBpdCBtaWdodCBiZSBub3QgYWNjdXJhdGUuXG4gICAgZnVuY3Rpb24gZ2V0U2NhbGVzKHh5TWluTWF4Q3VyciwgeHlNaW5NYXhPcmlnaW4pIHtcbiAgICAgICAgdmFyIHNpemVDdXJyID0gZ2V0U2l6ZSh4eU1pbk1heEN1cnIpO1xuICAgICAgICB2YXIgc2l6ZU9yaWdpbiA9IGdldFNpemUoeHlNaW5NYXhPcmlnaW4pO1xuICAgICAgICB2YXIgc2NhbGVzID0gW3NpemVDdXJyWzBdIC8gc2l6ZU9yaWdpblswXSwgc2l6ZUN1cnJbMV0gLyBzaXplT3JpZ2luWzFdXTtcbiAgICAgICAgaXNOYU4oc2NhbGVzWzBdKSAmJiAoc2NhbGVzWzBdID0gMSk7XG4gICAgICAgIGlzTmFOKHNjYWxlc1sxXSkgJiYgKHNjYWxlc1sxXSA9IDEpO1xuICAgICAgICByZXR1cm4gc2NhbGVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNpemUoeHlNaW5NYXgpIHtcbiAgICAgICAgcmV0dXJuIHh5TWluTWF4XG4gICAgICAgICAgICA/IFt4eU1pbk1heFswXVsxXSAtIHh5TWluTWF4WzBdWzBdLCB4eU1pbk1heFsxXVsxXSAtIHh5TWluTWF4WzFdWzBdXVxuICAgICAgICAgICAgOiBbTmFOLCBOYU5dO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gQnJ1c2hUYXJnZXRNYW5hZ2VyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvY29tcG9uZW50L2hlbHBlci9CcnVzaFRhcmdldE1hbmFnZXIuanNcbi8vIG1vZHVsZSBpZCA9IDE5NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 197 */
/* unknown exports provided */
/* all exports used */
/*!*********************************************!*\
  !*** ./lib/component/helper/brushHelper.js ***!
  \*********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 0);\n    var cursorHelper = __webpack_require__(/*! ./cursorHelper */ 157);\n    var BoundingRect = __webpack_require__(/*! zrender/lib/core/BoundingRect */ 10);\n\n    var mathMax = Math.max;\n    var mathMin = Math.min;\n\n    var helper = {};\n\n    helper.makeRectPanelClipPath = function (rect) {\n        rect = normalizeRect(rect);\n        return function (localPoints, transform) {\n            return zrUtil.map(localPoints, function (localPoint) {\n                var x = localPoint[0];\n                x = mathMax(x, rect.x);\n                x = mathMin(x, rect.x + rect.width);\n                var y = localPoint[1];\n                y = mathMax(y, rect.y);\n                y = mathMin(y, rect.y + rect.height);\n                return [x, y];\n            });\n        };\n    };\n\n    helper.makeLinearBrushOtherExtent = function (rect, specifiedXYIndex) {\n        rect = normalizeRect(rect);\n        return function (xyIndex) {\n            var idx = specifiedXYIndex != null ? specifiedXYIndex : xyIndex;\n            var brushWidth = idx ? rect.width : rect.height;\n            var base = idx ? rect.x : rect.y;\n            return [base, base + (brushWidth || 0)];\n        };\n    };\n\n    helper.makeRectIsTargetByCursor = function (rect, api, targetModel) {\n        rect = normalizeRect(rect);\n        return function (e, localCursorPoint, transform) {\n            return rect.contain(localCursorPoint[0], localCursorPoint[1])\n                && !cursorHelper.onIrrelevantElement(e, api, targetModel);\n        };\n    };\n\n    // Consider width/height is negative.\n    function normalizeRect(rect) {\n        return BoundingRect.create(rect);\n    }\n\n    module.exports = helper;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTk3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2NvbXBvbmVudC9oZWxwZXIvYnJ1c2hIZWxwZXIuanM/OWE0NiJdLCJzb3VyY2VzQ29udGVudCI6WyJcblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgY3Vyc29ySGVscGVyID0gcmVxdWlyZSgnLi9jdXJzb3JIZWxwZXInKTtcbiAgICB2YXIgQm91bmRpbmdSZWN0ID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS9Cb3VuZGluZ1JlY3QnKTtcblxuICAgIHZhciBtYXRoTWF4ID0gTWF0aC5tYXg7XG4gICAgdmFyIG1hdGhNaW4gPSBNYXRoLm1pbjtcblxuICAgIHZhciBoZWxwZXIgPSB7fTtcblxuICAgIGhlbHBlci5tYWtlUmVjdFBhbmVsQ2xpcFBhdGggPSBmdW5jdGlvbiAocmVjdCkge1xuICAgICAgICByZWN0ID0gbm9ybWFsaXplUmVjdChyZWN0KTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChsb2NhbFBvaW50cywgdHJhbnNmb3JtKSB7XG4gICAgICAgICAgICByZXR1cm4genJVdGlsLm1hcChsb2NhbFBvaW50cywgZnVuY3Rpb24gKGxvY2FsUG9pbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgeCA9IGxvY2FsUG9pbnRbMF07XG4gICAgICAgICAgICAgICAgeCA9IG1hdGhNYXgoeCwgcmVjdC54KTtcbiAgICAgICAgICAgICAgICB4ID0gbWF0aE1pbih4LCByZWN0LnggKyByZWN0LndpZHRoKTtcbiAgICAgICAgICAgICAgICB2YXIgeSA9IGxvY2FsUG9pbnRbMV07XG4gICAgICAgICAgICAgICAgeSA9IG1hdGhNYXgoeSwgcmVjdC55KTtcbiAgICAgICAgICAgICAgICB5ID0gbWF0aE1pbih5LCByZWN0LnkgKyByZWN0LmhlaWdodCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFt4LCB5XTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICBoZWxwZXIubWFrZUxpbmVhckJydXNoT3RoZXJFeHRlbnQgPSBmdW5jdGlvbiAocmVjdCwgc3BlY2lmaWVkWFlJbmRleCkge1xuICAgICAgICByZWN0ID0gbm9ybWFsaXplUmVjdChyZWN0KTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh4eUluZGV4KSB7XG4gICAgICAgICAgICB2YXIgaWR4ID0gc3BlY2lmaWVkWFlJbmRleCAhPSBudWxsID8gc3BlY2lmaWVkWFlJbmRleCA6IHh5SW5kZXg7XG4gICAgICAgICAgICB2YXIgYnJ1c2hXaWR0aCA9IGlkeCA/IHJlY3Qud2lkdGggOiByZWN0LmhlaWdodDtcbiAgICAgICAgICAgIHZhciBiYXNlID0gaWR4ID8gcmVjdC54IDogcmVjdC55O1xuICAgICAgICAgICAgcmV0dXJuIFtiYXNlLCBiYXNlICsgKGJydXNoV2lkdGggfHwgMCldO1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICBoZWxwZXIubWFrZVJlY3RJc1RhcmdldEJ5Q3Vyc29yID0gZnVuY3Rpb24gKHJlY3QsIGFwaSwgdGFyZ2V0TW9kZWwpIHtcbiAgICAgICAgcmVjdCA9IG5vcm1hbGl6ZVJlY3QocmVjdCk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZSwgbG9jYWxDdXJzb3JQb2ludCwgdHJhbnNmb3JtKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVjdC5jb250YWluKGxvY2FsQ3Vyc29yUG9pbnRbMF0sIGxvY2FsQ3Vyc29yUG9pbnRbMV0pXG4gICAgICAgICAgICAgICAgJiYgIWN1cnNvckhlbHBlci5vbklycmVsZXZhbnRFbGVtZW50KGUsIGFwaSwgdGFyZ2V0TW9kZWwpO1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICAvLyBDb25zaWRlciB3aWR0aC9oZWlnaHQgaXMgbmVnYXRpdmUuXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplUmVjdChyZWN0KSB7XG4gICAgICAgIHJldHVybiBCb3VuZGluZ1JlY3QuY3JlYXRlKHJlY3QpO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gaGVscGVyO1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9jb21wb25lbnQvaGVscGVyL2JydXNoSGVscGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxOTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 198 */,
/* 199 */,
/* 200 */
/* unknown exports provided */
/* all exports used */
/*!*********************************************!*\
  !*** /home/yx/~/zrender/lib/vml/Painter.js ***!
  \*********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * VML Painter.\n *\n * @module zrender/vml/Painter\n */\n\n\n\n    var zrLog = __webpack_require__(/*! ../core/log */ 52);\n    var vmlCore = __webpack_require__(/*! ./core */ 132);\n\n    function parseInt10(val) {\n        return parseInt(val, 10);\n    }\n\n    /**\n     * @alias module:zrender/vml/Painter\n     */\n    function VMLPainter(root, storage) {\n\n        vmlCore.initVML();\n\n        this.root = root;\n\n        this.storage = storage;\n\n        var vmlViewport = document.createElement('div');\n\n        var vmlRoot = document.createElement('div');\n\n        vmlViewport.style.cssText = 'display:inline-block;overflow:hidden;position:relative;width:300px;height:150px;';\n\n        vmlRoot.style.cssText = 'position:absolute;left:0;top:0;';\n\n        root.appendChild(vmlViewport);\n\n        this._vmlRoot = vmlRoot;\n        this._vmlViewport = vmlViewport;\n\n        this.resize();\n\n        // Modify storage\n        var oldDelFromStorage = storage.delFromStorage;\n        var oldAddToStorage = storage.addToStorage;\n        storage.delFromStorage = function (el) {\n            oldDelFromStorage.call(storage, el);\n\n            if (el) {\n                el.onRemove && el.onRemove(vmlRoot);\n            }\n        };\n\n        storage.addToStorage = function (el) {\n            // Displayable already has a vml node\n            el.onAdd && el.onAdd(vmlRoot);\n\n            oldAddToStorage.call(storage, el);\n        };\n\n        this._firstPaint = true;\n    }\n\n    VMLPainter.prototype = {\n\n        constructor: VMLPainter,\n\n        /**\n         * @return {HTMLDivElement}\n         */\n        getViewportRoot: function () {\n            return this._vmlViewport;\n        },\n\n        /**\n         * 刷新\n         */\n        refresh: function () {\n\n            var list = this.storage.getDisplayList(true, true);\n\n            this._paintList(list);\n        },\n\n        _paintList: function (list) {\n            var vmlRoot = this._vmlRoot;\n            for (var i = 0; i < list.length; i++) {\n                var el = list[i];\n                if (el.invisible || el.ignore) {\n                    if (!el.__alreadyNotVisible) {\n                        el.onRemove(vmlRoot);\n                    }\n                    // Set as already invisible\n                    el.__alreadyNotVisible = true;\n                }\n                else {\n                    if (el.__alreadyNotVisible) {\n                        el.onAdd(vmlRoot);\n                    }\n                    el.__alreadyNotVisible = false;\n                    if (el.__dirty) {\n                        el.beforeBrush && el.beforeBrush();\n                        (el.brushVML || el.brush).call(el, vmlRoot);\n                        el.afterBrush && el.afterBrush();\n                    }\n                }\n                el.__dirty = false;\n            }\n\n            if (this._firstPaint) {\n                // Detached from document at first time\n                // to avoid page refreshing too many times\n\n                // FIXME 如果每次都先 removeChild 可能会导致一些填充和描边的效果改变\n                this._vmlViewport.appendChild(vmlRoot);\n                this._firstPaint = false;\n            }\n        },\n\n        resize: function (width, height) {\n            var width = width == null ? this._getWidth() : width;\n            var height = height == null ? this._getHeight() : height;\n\n            if (this._width != width || this._height != height) {\n                this._width = width;\n                this._height = height;\n\n                var vmlViewportStyle = this._vmlViewport.style;\n                vmlViewportStyle.width = width + 'px';\n                vmlViewportStyle.height = height + 'px';\n            }\n        },\n\n        dispose: function () {\n            this.root.innerHTML = '';\n\n            this._vmlRoot =\n            this._vmlViewport =\n            this.storage = null;\n        },\n\n        getWidth: function () {\n            return this._width;\n        },\n\n        getHeight: function () {\n            return this._height;\n        },\n\n        clear: function () {\n            if (this._vmlViewport) {\n                this.root.removeChild(this._vmlViewport);\n            }\n        },\n\n        _getWidth: function () {\n            var root = this.root;\n            var stl = root.currentStyle;\n\n            return ((root.clientWidth || parseInt10(stl.width))\n                    - parseInt10(stl.paddingLeft)\n                    - parseInt10(stl.paddingRight)) | 0;\n        },\n\n        _getHeight: function () {\n            var root = this.root;\n            var stl = root.currentStyle;\n\n            return ((root.clientHeight || parseInt10(stl.height))\n                    - parseInt10(stl.paddingTop)\n                    - parseInt10(stl.paddingBottom)) | 0;\n        }\n    };\n\n    // Not supported methods\n    function createMethodNotSupport(method) {\n        return function () {\n            zrLog('In IE8.0 VML mode painter not support method \"' + method + '\"');\n        };\n    }\n\n    var notSupportedMethods = [\n        'getLayer', 'insertLayer', 'eachLayer', 'eachBuiltinLayer', 'eachOtherLayer', 'getLayers',\n        'modLayer', 'delLayer', 'clearLayer', 'toDataURL', 'pathToImage'\n    ];\n\n    for (var i = 0; i < notSupportedMethods.length; i++) {\n        var name = notSupportedMethods[i];\n        VMLPainter.prototype[name] = createMethodNotSupport(name);\n    }\n\n    module.exports = VMLPainter;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjAwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy9ob21lL3l4L34venJlbmRlci9saWIvdm1sL1BhaW50ZXIuanM/NDhhMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFZNTCBQYWludGVyLlxuICpcbiAqIEBtb2R1bGUgenJlbmRlci92bWwvUGFpbnRlclxuICovXG5cblxuXG4gICAgdmFyIHpyTG9nID0gcmVxdWlyZSgnLi4vY29yZS9sb2cnKTtcbiAgICB2YXIgdm1sQ29yZSA9IHJlcXVpcmUoJy4vY29yZScpO1xuXG4gICAgZnVuY3Rpb24gcGFyc2VJbnQxMCh2YWwpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KHZhbCwgMTApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci92bWwvUGFpbnRlclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFZNTFBhaW50ZXIocm9vdCwgc3RvcmFnZSkge1xuXG4gICAgICAgIHZtbENvcmUuaW5pdFZNTCgpO1xuXG4gICAgICAgIHRoaXMucm9vdCA9IHJvb3Q7XG5cbiAgICAgICAgdGhpcy5zdG9yYWdlID0gc3RvcmFnZTtcblxuICAgICAgICB2YXIgdm1sVmlld3BvcnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgICAgICB2YXIgdm1sUm9vdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gICAgICAgIHZtbFZpZXdwb3J0LnN0eWxlLmNzc1RleHQgPSAnZGlzcGxheTppbmxpbmUtYmxvY2s7b3ZlcmZsb3c6aGlkZGVuO3Bvc2l0aW9uOnJlbGF0aXZlO3dpZHRoOjMwMHB4O2hlaWdodDoxNTBweDsnO1xuXG4gICAgICAgIHZtbFJvb3Quc3R5bGUuY3NzVGV4dCA9ICdwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0OjA7dG9wOjA7JztcblxuICAgICAgICByb290LmFwcGVuZENoaWxkKHZtbFZpZXdwb3J0KTtcblxuICAgICAgICB0aGlzLl92bWxSb290ID0gdm1sUm9vdDtcbiAgICAgICAgdGhpcy5fdm1sVmlld3BvcnQgPSB2bWxWaWV3cG9ydDtcblxuICAgICAgICB0aGlzLnJlc2l6ZSgpO1xuXG4gICAgICAgIC8vIE1vZGlmeSBzdG9yYWdlXG4gICAgICAgIHZhciBvbGREZWxGcm9tU3RvcmFnZSA9IHN0b3JhZ2UuZGVsRnJvbVN0b3JhZ2U7XG4gICAgICAgIHZhciBvbGRBZGRUb1N0b3JhZ2UgPSBzdG9yYWdlLmFkZFRvU3RvcmFnZTtcbiAgICAgICAgc3RvcmFnZS5kZWxGcm9tU3RvcmFnZSA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgb2xkRGVsRnJvbVN0b3JhZ2UuY2FsbChzdG9yYWdlLCBlbCk7XG5cbiAgICAgICAgICAgIGlmIChlbCkge1xuICAgICAgICAgICAgICAgIGVsLm9uUmVtb3ZlICYmIGVsLm9uUmVtb3ZlKHZtbFJvb3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHN0b3JhZ2UuYWRkVG9TdG9yYWdlID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAvLyBEaXNwbGF5YWJsZSBhbHJlYWR5IGhhcyBhIHZtbCBub2RlXG4gICAgICAgICAgICBlbC5vbkFkZCAmJiBlbC5vbkFkZCh2bWxSb290KTtcblxuICAgICAgICAgICAgb2xkQWRkVG9TdG9yYWdlLmNhbGwoc3RvcmFnZSwgZWwpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuX2ZpcnN0UGFpbnQgPSB0cnVlO1xuICAgIH1cblxuICAgIFZNTFBhaW50ZXIucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBWTUxQYWludGVyLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtIVE1MRGl2RWxlbWVudH1cbiAgICAgICAgICovXG4gICAgICAgIGdldFZpZXdwb3J0Um9vdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ZtbFZpZXdwb3J0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDliLfmlrBcbiAgICAgICAgICovXG4gICAgICAgIHJlZnJlc2g6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgdmFyIGxpc3QgPSB0aGlzLnN0b3JhZ2UuZ2V0RGlzcGxheUxpc3QodHJ1ZSwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIHRoaXMuX3BhaW50TGlzdChsaXN0KTtcbiAgICAgICAgfSxcblxuICAgICAgICBfcGFpbnRMaXN0OiBmdW5jdGlvbiAobGlzdCkge1xuICAgICAgICAgICAgdmFyIHZtbFJvb3QgPSB0aGlzLl92bWxSb290O1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsID0gbGlzdFtpXTtcbiAgICAgICAgICAgICAgICBpZiAoZWwuaW52aXNpYmxlIHx8IGVsLmlnbm9yZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWVsLl9fYWxyZWFkeU5vdFZpc2libGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLm9uUmVtb3ZlKHZtbFJvb3QpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFNldCBhcyBhbHJlYWR5IGludmlzaWJsZVxuICAgICAgICAgICAgICAgICAgICBlbC5fX2FscmVhZHlOb3RWaXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbC5fX2FscmVhZHlOb3RWaXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbC5vbkFkZCh2bWxSb290KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbC5fX2FscmVhZHlOb3RWaXNpYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbC5fX2RpcnR5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbC5iZWZvcmVCcnVzaCAmJiBlbC5iZWZvcmVCcnVzaCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgKGVsLmJydXNoVk1MIHx8IGVsLmJydXNoKS5jYWxsKGVsLCB2bWxSb290KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLmFmdGVyQnJ1c2ggJiYgZWwuYWZ0ZXJCcnVzaCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsLl9fZGlydHkgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuX2ZpcnN0UGFpbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBEZXRhY2hlZCBmcm9tIGRvY3VtZW50IGF0IGZpcnN0IHRpbWVcbiAgICAgICAgICAgICAgICAvLyB0byBhdm9pZCBwYWdlIHJlZnJlc2hpbmcgdG9vIG1hbnkgdGltZXNcblxuICAgICAgICAgICAgICAgIC8vIEZJWE1FIOWmguaenOavj+asoemDveWFiCByZW1vdmVDaGlsZCDlj6/og73kvJrlr7zoh7TkuIDkupvloavlhYXlkozmj4/ovrnnmoTmlYjmnpzmlLnlj5hcbiAgICAgICAgICAgICAgICB0aGlzLl92bWxWaWV3cG9ydC5hcHBlbmRDaGlsZCh2bWxSb290KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9maXJzdFBhaW50ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVzaXplOiBmdW5jdGlvbiAod2lkdGgsIGhlaWdodCkge1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gd2lkdGggPT0gbnVsbCA/IHRoaXMuX2dldFdpZHRoKCkgOiB3aWR0aDtcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSBoZWlnaHQgPT0gbnVsbCA/IHRoaXMuX2dldEhlaWdodCgpIDogaGVpZ2h0O1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fd2lkdGggIT0gd2lkdGggfHwgdGhpcy5faGVpZ2h0ICE9IGhlaWdodCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICAgICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgICAgICAgICAgICAgdmFyIHZtbFZpZXdwb3J0U3R5bGUgPSB0aGlzLl92bWxWaWV3cG9ydC5zdHlsZTtcbiAgICAgICAgICAgICAgICB2bWxWaWV3cG9ydFN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICAgICAgICAgICAgICAgIHZtbFZpZXdwb3J0U3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnJvb3QuaW5uZXJIVE1MID0gJyc7XG5cbiAgICAgICAgICAgIHRoaXMuX3ZtbFJvb3QgPVxuICAgICAgICAgICAgdGhpcy5fdm1sVmlld3BvcnQgPVxuICAgICAgICAgICAgdGhpcy5zdG9yYWdlID0gbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRXaWR0aDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dpZHRoO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldEhlaWdodDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hlaWdodDtcbiAgICAgICAgfSxcblxuICAgICAgICBjbGVhcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3ZtbFZpZXdwb3J0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yb290LnJlbW92ZUNoaWxkKHRoaXMuX3ZtbFZpZXdwb3J0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfZ2V0V2lkdGg6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByb290ID0gdGhpcy5yb290O1xuICAgICAgICAgICAgdmFyIHN0bCA9IHJvb3QuY3VycmVudFN0eWxlO1xuXG4gICAgICAgICAgICByZXR1cm4gKChyb290LmNsaWVudFdpZHRoIHx8IHBhcnNlSW50MTAoc3RsLndpZHRoKSlcbiAgICAgICAgICAgICAgICAgICAgLSBwYXJzZUludDEwKHN0bC5wYWRkaW5nTGVmdClcbiAgICAgICAgICAgICAgICAgICAgLSBwYXJzZUludDEwKHN0bC5wYWRkaW5nUmlnaHQpKSB8IDA7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2dldEhlaWdodDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJvb3QgPSB0aGlzLnJvb3Q7XG4gICAgICAgICAgICB2YXIgc3RsID0gcm9vdC5jdXJyZW50U3R5bGU7XG5cbiAgICAgICAgICAgIHJldHVybiAoKHJvb3QuY2xpZW50SGVpZ2h0IHx8IHBhcnNlSW50MTAoc3RsLmhlaWdodCkpXG4gICAgICAgICAgICAgICAgICAgIC0gcGFyc2VJbnQxMChzdGwucGFkZGluZ1RvcClcbiAgICAgICAgICAgICAgICAgICAgLSBwYXJzZUludDEwKHN0bC5wYWRkaW5nQm90dG9tKSkgfCAwO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIE5vdCBzdXBwb3J0ZWQgbWV0aG9kc1xuICAgIGZ1bmN0aW9uIGNyZWF0ZU1ldGhvZE5vdFN1cHBvcnQobWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB6ckxvZygnSW4gSUU4LjAgVk1MIG1vZGUgcGFpbnRlciBub3Qgc3VwcG9ydCBtZXRob2QgXCInICsgbWV0aG9kICsgJ1wiJyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIG5vdFN1cHBvcnRlZE1ldGhvZHMgPSBbXG4gICAgICAgICdnZXRMYXllcicsICdpbnNlcnRMYXllcicsICdlYWNoTGF5ZXInLCAnZWFjaEJ1aWx0aW5MYXllcicsICdlYWNoT3RoZXJMYXllcicsICdnZXRMYXllcnMnLFxuICAgICAgICAnbW9kTGF5ZXInLCAnZGVsTGF5ZXInLCAnY2xlYXJMYXllcicsICd0b0RhdGFVUkwnLCAncGF0aFRvSW1hZ2UnXG4gICAgXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm90U3VwcG9ydGVkTWV0aG9kcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbmFtZSA9IG5vdFN1cHBvcnRlZE1ldGhvZHNbaV07XG4gICAgICAgIFZNTFBhaW50ZXIucHJvdG90eXBlW25hbWVdID0gY3JlYXRlTWV0aG9kTm90U3VwcG9ydChuYW1lKTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFZNTFBhaW50ZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvaG9tZS95eC9+L3pyZW5kZXIvbGliL3ZtbC9QYWludGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAyMDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 201 */
/* unknown exports provided */
/* all exports used */
/*!*********************************************!*\
  !*** /home/yx/~/zrender/lib/vml/graphic.js ***!
  \*********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("// http://www.w3.org/TR/NOTE-VML\n// TODO Use proxy like svg instead of overwrite brush methods\n\n\nif (!__webpack_require__(/*! ../core/env */ 8).canvasSupported) {\n    var vec2 = __webpack_require__(/*! ../core/vector */ 4);\n    var BoundingRect = __webpack_require__(/*! ../core/BoundingRect */ 10);\n    var CMD = __webpack_require__(/*! ../core/PathProxy */ 25).CMD;\n    var colorTool = __webpack_require__(/*! ../tool/color */ 21);\n    var textContain = __webpack_require__(/*! ../contain/text */ 15);\n    var RectText = __webpack_require__(/*! ../graphic/mixin/RectText */ 78);\n    var Displayable = __webpack_require__(/*! ../graphic/Displayable */ 36);\n    var ZImage = __webpack_require__(/*! ../graphic/Image */ 53);\n    var Text = __webpack_require__(/*! ../graphic/Text */ 77);\n    var Path = __webpack_require__(/*! ../graphic/Path */ 7);\n    var PathProxy = __webpack_require__(/*! ../core/PathProxy */ 25);\n\n    var Gradient = __webpack_require__(/*! ../graphic/Gradient */ 37);\n\n    var vmlCore = __webpack_require__(/*! ./core */ 132);\n\n    var round = Math.round;\n    var sqrt = Math.sqrt;\n    var abs = Math.abs;\n    var cos = Math.cos;\n    var sin = Math.sin;\n    var mathMax = Math.max;\n\n    var applyTransform = vec2.applyTransform;\n\n    var comma = ',';\n    var imageTransformPrefix = 'progid:DXImageTransform.Microsoft';\n\n    var Z = 21600;\n    var Z2 = Z / 2;\n\n    var ZLEVEL_BASE = 100000;\n    var Z_BASE = 1000;\n\n    var initRootElStyle = function (el) {\n        el.style.cssText = 'position:absolute;left:0;top:0;width:1px;height:1px;';\n        el.coordsize = Z + ','  + Z;\n        el.coordorigin = '0,0';\n    };\n\n    var encodeHtmlAttribute = function (s) {\n        return String(s).replace(/&/g, '&amp;').replace(/\"/g, '&quot;');\n    };\n\n    var rgb2Str = function (r, g, b) {\n        return 'rgb(' + [r, g, b].join(',') + ')';\n    };\n\n    var append = function (parent, child) {\n        if (child && parent && child.parentNode !== parent) {\n            parent.appendChild(child);\n        }\n    };\n\n    var remove = function (parent, child) {\n        if (child && parent && child.parentNode === parent) {\n            parent.removeChild(child);\n        }\n    };\n\n    var getZIndex = function (zlevel, z, z2) {\n        // z 的取值范围为 [0, 1000]\n        return (parseFloat(zlevel) || 0) * ZLEVEL_BASE + (parseFloat(z) || 0) * Z_BASE + z2;\n    };\n\n    var parsePercent = function (value, maxValue) {\n        if (typeof value === 'string') {\n            if (value.lastIndexOf('%') >= 0) {\n                return parseFloat(value) / 100 * maxValue;\n            }\n            return parseFloat(value);\n        }\n        return value;\n    };\n\n    /***************************************************\n     * PATH\n     **************************************************/\n\n    var setColorAndOpacity = function (el, color, opacity) {\n        var colorArr = colorTool.parse(color);\n        opacity = +opacity;\n        if (isNaN(opacity)) {\n            opacity = 1;\n        }\n        if (colorArr) {\n            el.color = rgb2Str(colorArr[0], colorArr[1], colorArr[2]);\n            el.opacity = opacity * colorArr[3];\n        }\n    };\n\n    var getColorAndAlpha = function (color) {\n        var colorArr = colorTool.parse(color);\n        return [\n            rgb2Str(colorArr[0], colorArr[1], colorArr[2]),\n            colorArr[3]\n        ];\n    };\n\n    var updateFillNode = function (el, style, zrEl) {\n        // TODO pattern\n        var fill = style.fill;\n        if (fill != null) {\n            // Modified from excanvas\n            if (fill instanceof Gradient) {\n                var gradientType;\n                var angle = 0;\n                var focus = [0, 0];\n                // additional offset\n                var shift = 0;\n                // scale factor for offset\n                var expansion = 1;\n                var rect = zrEl.getBoundingRect();\n                var rectWidth = rect.width;\n                var rectHeight = rect.height;\n                if (fill.type === 'linear') {\n                    gradientType = 'gradient';\n                    var transform = zrEl.transform;\n                    var p0 = [fill.x * rectWidth, fill.y * rectHeight];\n                    var p1 = [fill.x2 * rectWidth, fill.y2 * rectHeight];\n                    if (transform) {\n                        applyTransform(p0, p0, transform);\n                        applyTransform(p1, p1, transform);\n                    }\n                    var dx = p1[0] - p0[0];\n                    var dy = p1[1] - p0[1];\n                    angle = Math.atan2(dx, dy) * 180 / Math.PI;\n                    // The angle should be a non-negative number.\n                    if (angle < 0) {\n                        angle += 360;\n                    }\n\n                    // Very small angles produce an unexpected result because they are\n                    // converted to a scientific notation string.\n                    if (angle < 1e-6) {\n                        angle = 0;\n                    }\n                }\n                else {\n                    gradientType = 'gradientradial';\n                    var p0 = [fill.x * rectWidth, fill.y * rectHeight];\n                    var transform = zrEl.transform;\n                    var scale = zrEl.scale;\n                    var width = rectWidth;\n                    var height = rectHeight;\n                    focus = [\n                        // Percent in bounding rect\n                        (p0[0] - rect.x) / width,\n                        (p0[1] - rect.y) / height\n                    ];\n                    if (transform) {\n                        applyTransform(p0, p0, transform);\n                    }\n\n                    width /= scale[0] * Z;\n                    height /= scale[1] * Z;\n                    var dimension = mathMax(width, height);\n                    shift = 2 * 0 / dimension;\n                    expansion = 2 * fill.r / dimension - shift;\n                }\n\n                // We need to sort the color stops in ascending order by offset,\n                // otherwise IE won't interpret it correctly.\n                var stops = fill.colorStops.slice();\n                stops.sort(function(cs1, cs2) {\n                    return cs1.offset - cs2.offset;\n                });\n\n                var length = stops.length;\n                // Color and alpha list of first and last stop\n                var colorAndAlphaList = [];\n                var colors = [];\n                for (var i = 0; i < length; i++) {\n                    var stop = stops[i];\n                    var colorAndAlpha = getColorAndAlpha(stop.color);\n                    colors.push(stop.offset * expansion + shift + ' ' + colorAndAlpha[0]);\n                    if (i === 0 || i === length - 1) {\n                        colorAndAlphaList.push(colorAndAlpha);\n                    }\n                }\n\n                if (length >= 2) {\n                    var color1 = colorAndAlphaList[0][0];\n                    var color2 = colorAndAlphaList[1][0];\n                    var opacity1 = colorAndAlphaList[0][1] * style.opacity;\n                    var opacity2 = colorAndAlphaList[1][1] * style.opacity;\n\n                    el.type = gradientType;\n                    el.method = 'none';\n                    el.focus = '100%';\n                    el.angle = angle;\n                    el.color = color1;\n                    el.color2 = color2;\n                    el.colors = colors.join(',');\n                    // When colors attribute is used, the meanings of opacity and o:opacity2\n                    // are reversed.\n                    el.opacity = opacity2;\n                    // FIXME g_o_:opacity ?\n                    el.opacity2 = opacity1;\n                }\n                if (gradientType === 'radial') {\n                    el.focusposition = focus.join(',');\n                }\n            }\n            else {\n                // FIXME Change from Gradient fill to color fill\n                setColorAndOpacity(el, fill, style.opacity);\n            }\n        }\n    };\n\n    var updateStrokeNode = function (el, style) {\n        // if (style.lineJoin != null) {\n        //     el.joinstyle = style.lineJoin;\n        // }\n        // if (style.miterLimit != null) {\n        //     el.miterlimit = style.miterLimit * Z;\n        // }\n        // if (style.lineCap != null) {\n        //     el.endcap = style.lineCap;\n        // }\n        if (style.lineDash != null) {\n            el.dashstyle = style.lineDash.join(' ');\n        }\n        if (style.stroke != null && !(style.stroke instanceof Gradient)) {\n            setColorAndOpacity(el, style.stroke, style.opacity);\n        }\n    };\n\n    var updateFillAndStroke = function (vmlEl, type, style, zrEl) {\n        var isFill = type == 'fill';\n        var el = vmlEl.getElementsByTagName(type)[0];\n        // Stroke must have lineWidth\n        if (style[type] != null && style[type] !== 'none' && (isFill || (!isFill && style.lineWidth))) {\n            vmlEl[isFill ? 'filled' : 'stroked'] = 'true';\n            // FIXME Remove before updating, or set `colors` will throw error\n            if (style[type] instanceof Gradient) {\n                remove(vmlEl, el);\n            }\n            if (!el) {\n                el = vmlCore.createNode(type);\n            }\n\n            isFill ? updateFillNode(el, style, zrEl) : updateStrokeNode(el, style);\n            append(vmlEl, el);\n        }\n        else {\n            vmlEl[isFill ? 'filled' : 'stroked'] = 'false';\n            remove(vmlEl, el);\n        }\n    };\n\n    var points = [[], [], []];\n    var pathDataToString = function (data, m) {\n        var M = CMD.M;\n        var C = CMD.C;\n        var L = CMD.L;\n        var A = CMD.A;\n        var Q = CMD.Q;\n\n        var str = [];\n        var nPoint;\n        var cmdStr;\n        var cmd;\n        var i;\n        var xi;\n        var yi;\n        for (i = 0; i < data.length;) {\n            cmd = data[i++];\n            cmdStr = '';\n            nPoint = 0;\n            switch (cmd) {\n                case M:\n                    cmdStr = ' m ';\n                    nPoint = 1;\n                    xi = data[i++];\n                    yi = data[i++];\n                    points[0][0] = xi;\n                    points[0][1] = yi;\n                    break;\n                case L:\n                    cmdStr = ' l ';\n                    nPoint = 1;\n                    xi = data[i++];\n                    yi = data[i++];\n                    points[0][0] = xi;\n                    points[0][1] = yi;\n                    break;\n                case Q:\n                case C:\n                    cmdStr = ' c ';\n                    nPoint = 3;\n                    var x1 = data[i++];\n                    var y1 = data[i++];\n                    var x2 = data[i++];\n                    var y2 = data[i++];\n                    var x3;\n                    var y3;\n                    if (cmd === Q) {\n                        // Convert quadratic to cubic using degree elevation\n                        x3 = x2;\n                        y3 = y2;\n                        x2 = (x2 + 2 * x1) / 3;\n                        y2 = (y2 + 2 * y1) / 3;\n                        x1 = (xi + 2 * x1) / 3;\n                        y1 = (yi + 2 * y1) / 3;\n                    }\n                    else {\n                        x3 = data[i++];\n                        y3 = data[i++];\n                    }\n                    points[0][0] = x1;\n                    points[0][1] = y1;\n                    points[1][0] = x2;\n                    points[1][1] = y2;\n                    points[2][0] = x3;\n                    points[2][1] = y3;\n\n                    xi = x3;\n                    yi = y3;\n                    break;\n                case A:\n                    var x = 0;\n                    var y = 0;\n                    var sx = 1;\n                    var sy = 1;\n                    var angle = 0;\n                    if (m) {\n                        // Extract SRT from matrix\n                        x = m[4];\n                        y = m[5];\n                        sx = sqrt(m[0] * m[0] + m[1] * m[1]);\n                        sy = sqrt(m[2] * m[2] + m[3] * m[3]);\n                        angle = Math.atan2(-m[1] / sy, m[0] / sx);\n                    }\n\n                    var cx = data[i++];\n                    var cy = data[i++];\n                    var rx = data[i++];\n                    var ry = data[i++];\n                    var startAngle = data[i++] + angle;\n                    var endAngle = data[i++] + startAngle + angle;\n                    // FIXME\n                    // var psi = data[i++];\n                    i++;\n                    var clockwise = data[i++];\n\n                    var x0 = cx + cos(startAngle) * rx;\n                    var y0 = cy + sin(startAngle) * ry;\n\n                    var x1 = cx + cos(endAngle) * rx;\n                    var y1 = cy + sin(endAngle) * ry;\n\n                    var type = clockwise ? ' wa ' : ' at ';\n                    if (Math.abs(x0 - x1) < 1e-4) {\n                        // IE won't render arches drawn counter clockwise if x0 == x1.\n                        if (Math.abs(endAngle - startAngle) > 1e-2) {\n                            // Offset x0 by 1/80 of a pixel. Use something\n                            // that can be represented in binary\n                            if (clockwise) {\n                                x0 += 270 / Z;\n                            }\n                        }\n                        else {\n                            // Avoid case draw full circle\n                            if (Math.abs(y0 - cy) < 1e-4) {\n                                if ((clockwise && x0 < cx) || (!clockwise && x0 > cx)) {\n                                    y1 -= 270 / Z;\n                                }\n                                else {\n                                    y1 += 270 / Z;\n                                }\n                            }\n                            else if ((clockwise && y0 < cy) || (!clockwise && y0 > cy)) {\n                                x1 += 270 / Z;\n                            }\n                            else {\n                                x1 -= 270 / Z;\n                            }\n                        }\n                    }\n                    str.push(\n                        type,\n                        round(((cx - rx) * sx + x) * Z - Z2), comma,\n                        round(((cy - ry) * sy + y) * Z - Z2), comma,\n                        round(((cx + rx) * sx + x) * Z - Z2), comma,\n                        round(((cy + ry) * sy + y) * Z - Z2), comma,\n                        round((x0 * sx + x) * Z - Z2), comma,\n                        round((y0 * sy + y) * Z - Z2), comma,\n                        round((x1 * sx + x) * Z - Z2), comma,\n                        round((y1 * sy + y) * Z - Z2)\n                    );\n\n                    xi = x1;\n                    yi = y1;\n                    break;\n                case CMD.R:\n                    var p0 = points[0];\n                    var p1 = points[1];\n                    // x0, y0\n                    p0[0] = data[i++];\n                    p0[1] = data[i++];\n                    // x1, y1\n                    p1[0] = p0[0] + data[i++];\n                    p1[1] = p0[1] + data[i++];\n\n                    if (m) {\n                        applyTransform(p0, p0, m);\n                        applyTransform(p1, p1, m);\n                    }\n\n                    p0[0] = round(p0[0] * Z - Z2);\n                    p1[0] = round(p1[0] * Z - Z2);\n                    p0[1] = round(p0[1] * Z - Z2);\n                    p1[1] = round(p1[1] * Z - Z2);\n                    str.push(\n                        // x0, y0\n                        ' m ', p0[0], comma, p0[1],\n                        // x1, y0\n                        ' l ', p1[0], comma, p0[1],\n                        // x1, y1\n                        ' l ', p1[0], comma, p1[1],\n                        // x0, y1\n                        ' l ', p0[0], comma, p1[1]\n                    );\n                    break;\n                case CMD.Z:\n                    // FIXME Update xi, yi\n                    str.push(' x ');\n            }\n\n            if (nPoint > 0) {\n                str.push(cmdStr);\n                for (var k = 0; k < nPoint; k++) {\n                    var p = points[k];\n\n                    m && applyTransform(p, p, m);\n                    // 不 round 会非常慢\n                    str.push(\n                        round(p[0] * Z - Z2), comma, round(p[1] * Z - Z2),\n                        k < nPoint - 1 ? comma : ''\n                    );\n                }\n            }\n        }\n\n        return str.join('');\n    };\n\n    // Rewrite the original path method\n    Path.prototype.brushVML = function (vmlRoot) {\n        var style = this.style;\n\n        var vmlEl = this._vmlEl;\n        if (!vmlEl) {\n            vmlEl = vmlCore.createNode('shape');\n            initRootElStyle(vmlEl);\n\n            this._vmlEl = vmlEl;\n        }\n\n        updateFillAndStroke(vmlEl, 'fill', style, this);\n        updateFillAndStroke(vmlEl, 'stroke', style, this);\n\n        var m = this.transform;\n        var needTransform = m != null;\n        var strokeEl = vmlEl.getElementsByTagName('stroke')[0];\n        if (strokeEl) {\n            var lineWidth = style.lineWidth;\n            // Get the line scale.\n            // Determinant of this.m_ means how much the area is enlarged by the\n            // transformation. So its square root can be used as a scale factor\n            // for width.\n            if (needTransform && !style.strokeNoScale) {\n                var det = m[0] * m[3] - m[1] * m[2];\n                lineWidth *= sqrt(abs(det));\n            }\n            strokeEl.weight = lineWidth + 'px';\n        }\n\n        var path = this.path || (this.path = new PathProxy());\n        if (this.__dirtyPath) {\n            path.beginPath();\n            this.buildPath(path, this.shape);\n            path.toStatic();\n            this.__dirtyPath = false;\n        }\n\n        vmlEl.path = pathDataToString(path.data, this.transform);\n\n        vmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2);\n\n        // Append to root\n        append(vmlRoot, vmlEl);\n\n        // Text\n        if (style.text != null) {\n            this.drawRectText(vmlRoot, this.getBoundingRect());\n        }\n        else {\n            this.removeRectText(vmlRoot);\n        }\n    };\n\n    Path.prototype.onRemove = function (vmlRoot) {\n        remove(vmlRoot, this._vmlEl);\n        this.removeRectText(vmlRoot);\n    };\n\n    Path.prototype.onAdd = function (vmlRoot) {\n        append(vmlRoot, this._vmlEl);\n        this.appendRectText(vmlRoot);\n    };\n\n    /***************************************************\n     * IMAGE\n     **************************************************/\n    var isImage = function (img) {\n        // FIXME img instanceof Image 如果 img 是一个字符串的时候，IE8 下会报错\n        return (typeof img === 'object') && img.tagName && img.tagName.toUpperCase() === 'IMG';\n        // return img instanceof Image;\n    };\n\n    // Rewrite the original path method\n    ZImage.prototype.brushVML = function (vmlRoot) {\n        var style = this.style;\n        var image = style.image;\n\n        // Image original width, height\n        var ow;\n        var oh;\n\n        if (isImage(image)) {\n            var src = image.src;\n            if (src === this._imageSrc) {\n                ow = this._imageWidth;\n                oh = this._imageHeight;\n            }\n            else {\n                var imageRuntimeStyle = image.runtimeStyle;\n                var oldRuntimeWidth = imageRuntimeStyle.width;\n                var oldRuntimeHeight = imageRuntimeStyle.height;\n                imageRuntimeStyle.width = 'auto';\n                imageRuntimeStyle.height = 'auto';\n\n                // get the original size\n                ow = image.width;\n                oh = image.height;\n\n                // and remove overides\n                imageRuntimeStyle.width = oldRuntimeWidth;\n                imageRuntimeStyle.height = oldRuntimeHeight;\n\n                // Caching image original width, height and src\n                this._imageSrc = src;\n                this._imageWidth = ow;\n                this._imageHeight = oh;\n            }\n            image = src;\n        }\n        else {\n            if (image === this._imageSrc) {\n                ow = this._imageWidth;\n                oh = this._imageHeight;\n            }\n        }\n        if (!image) {\n            return;\n        }\n\n        var x = style.x || 0;\n        var y = style.y || 0;\n\n        var dw = style.width;\n        var dh = style.height;\n\n        var sw = style.sWidth;\n        var sh = style.sHeight;\n        var sx = style.sx || 0;\n        var sy = style.sy || 0;\n\n        var hasCrop = sw && sh;\n\n        var vmlEl = this._vmlEl;\n        if (!vmlEl) {\n            // FIXME 使用 group 在 left, top 都不是 0 的时候就无法显示了。\n            // vmlEl = vmlCore.createNode('group');\n            vmlEl = vmlCore.doc.createElement('div');\n            initRootElStyle(vmlEl);\n\n            this._vmlEl = vmlEl;\n        }\n\n        var vmlElStyle = vmlEl.style;\n        var hasRotation = false;\n        var m;\n        var scaleX = 1;\n        var scaleY = 1;\n        if (this.transform) {\n            m = this.transform;\n            scaleX = sqrt(m[0] * m[0] + m[1] * m[1]);\n            scaleY = sqrt(m[2] * m[2] + m[3] * m[3]);\n\n            hasRotation = m[1] || m[2];\n        }\n        if (hasRotation) {\n            // If filters are necessary (rotation exists), create them\n            // filters are bog-slow, so only create them if abbsolutely necessary\n            // The following check doesn't account for skews (which don't exist\n            // in the canvas spec (yet) anyway.\n            // From excanvas\n            var p0 = [x, y];\n            var p1 = [x + dw, y];\n            var p2 = [x, y + dh];\n            var p3 = [x + dw, y + dh];\n            applyTransform(p0, p0, m);\n            applyTransform(p1, p1, m);\n            applyTransform(p2, p2, m);\n            applyTransform(p3, p3, m);\n\n            var maxX = mathMax(p0[0], p1[0], p2[0], p3[0]);\n            var maxY = mathMax(p0[1], p1[1], p2[1], p3[1]);\n\n            var transformFilter = [];\n            transformFilter.push('M11=', m[0] / scaleX, comma,\n                        'M12=', m[2] / scaleY, comma,\n                        'M21=', m[1] / scaleX, comma,\n                        'M22=', m[3] / scaleY, comma,\n                        'Dx=', round(x * scaleX + m[4]), comma,\n                        'Dy=', round(y * scaleY + m[5]));\n\n            vmlElStyle.padding = '0 ' + round(maxX) + 'px ' + round(maxY) + 'px 0';\n            // FIXME DXImageTransform 在 IE11 的兼容模式下不起作用\n            vmlElStyle.filter = imageTransformPrefix + '.Matrix('\n                + transformFilter.join('') + ', SizingMethod=clip)';\n\n        }\n        else {\n            if (m) {\n                x = x * scaleX + m[4];\n                y = y * scaleY + m[5];\n            }\n            vmlElStyle.filter = '';\n            vmlElStyle.left = round(x) + 'px';\n            vmlElStyle.top = round(y) + 'px';\n        }\n\n        var imageEl = this._imageEl;\n        var cropEl = this._cropEl;\n\n        if (!imageEl) {\n            imageEl = vmlCore.doc.createElement('div');\n            this._imageEl = imageEl;\n        }\n        var imageELStyle = imageEl.style;\n        if (hasCrop) {\n            // Needs know image original width and height\n            if (! (ow && oh)) {\n                var tmpImage = new Image();\n                var self = this;\n                tmpImage.onload = function () {\n                    tmpImage.onload = null;\n                    ow = tmpImage.width;\n                    oh = tmpImage.height;\n                    // Adjust image width and height to fit the ratio destinationSize / sourceSize\n                    imageELStyle.width = round(scaleX * ow * dw / sw) + 'px';\n                    imageELStyle.height = round(scaleY * oh * dh / sh) + 'px';\n\n                    // Caching image original width, height and src\n                    self._imageWidth = ow;\n                    self._imageHeight = oh;\n                    self._imageSrc = image;\n                };\n                tmpImage.src = image;\n            }\n            else {\n                imageELStyle.width = round(scaleX * ow * dw / sw) + 'px';\n                imageELStyle.height = round(scaleY * oh * dh / sh) + 'px';\n            }\n\n            if (! cropEl) {\n                cropEl = vmlCore.doc.createElement('div');\n                cropEl.style.overflow = 'hidden';\n                this._cropEl = cropEl;\n            }\n            var cropElStyle = cropEl.style;\n            cropElStyle.width = round((dw + sx * dw / sw) * scaleX);\n            cropElStyle.height = round((dh + sy * dh / sh) * scaleY);\n            cropElStyle.filter = imageTransformPrefix + '.Matrix(Dx='\n                    + (-sx * dw / sw * scaleX) + ',Dy=' + (-sy * dh / sh * scaleY) + ')';\n\n            if (! cropEl.parentNode) {\n                vmlEl.appendChild(cropEl);\n            }\n            if (imageEl.parentNode != cropEl) {\n                cropEl.appendChild(imageEl);\n            }\n        }\n        else {\n            imageELStyle.width = round(scaleX * dw) + 'px';\n            imageELStyle.height = round(scaleY * dh) + 'px';\n\n            vmlEl.appendChild(imageEl);\n\n            if (cropEl && cropEl.parentNode) {\n                vmlEl.removeChild(cropEl);\n                this._cropEl = null;\n            }\n        }\n\n        var filterStr = '';\n        var alpha = style.opacity;\n        if (alpha < 1) {\n            filterStr += '.Alpha(opacity=' + round(alpha * 100) + ') ';\n        }\n        filterStr += imageTransformPrefix + '.AlphaImageLoader(src=' + image + ', SizingMethod=scale)';\n\n        imageELStyle.filter = filterStr;\n\n        vmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2);\n\n        // Append to root\n        append(vmlRoot, vmlEl);\n\n        // Text\n        if (style.text != null) {\n            this.drawRectText(vmlRoot, this.getBoundingRect());\n        }\n    };\n\n    ZImage.prototype.onRemove = function (vmlRoot) {\n        remove(vmlRoot, this._vmlEl);\n\n        this._vmlEl = null;\n        this._cropEl = null;\n        this._imageEl = null;\n\n        this.removeRectText(vmlRoot);\n    };\n\n    ZImage.prototype.onAdd = function (vmlRoot) {\n        append(vmlRoot, this._vmlEl);\n        this.appendRectText(vmlRoot);\n    };\n\n\n    /***************************************************\n     * TEXT\n     **************************************************/\n\n    var DEFAULT_STYLE_NORMAL = 'normal';\n\n    var fontStyleCache = {};\n    var fontStyleCacheCount = 0;\n    var MAX_FONT_CACHE_SIZE = 100;\n    var fontEl = document.createElement('div');\n\n    var getFontStyle = function (fontString) {\n        var fontStyle = fontStyleCache[fontString];\n        if (!fontStyle) {\n            // Clear cache\n            if (fontStyleCacheCount > MAX_FONT_CACHE_SIZE) {\n                fontStyleCacheCount = 0;\n                fontStyleCache = {};\n            }\n\n            var style = fontEl.style;\n            var fontFamily;\n            try {\n                style.font = fontString;\n                fontFamily = style.fontFamily.split(',')[0];\n            }\n            catch (e) {\n            }\n\n            fontStyle = {\n                style: style.fontStyle || DEFAULT_STYLE_NORMAL,\n                variant: style.fontVariant || DEFAULT_STYLE_NORMAL,\n                weight: style.fontWeight || DEFAULT_STYLE_NORMAL,\n                size: parseFloat(style.fontSize || 12) | 0,\n                family: fontFamily || 'Microsoft YaHei'\n            };\n\n            fontStyleCache[fontString] = fontStyle;\n            fontStyleCacheCount++;\n        }\n        return fontStyle;\n    };\n\n    var textMeasureEl;\n    // Overwrite measure text method\n    textContain.measureText = function (text, textFont) {\n        var doc = vmlCore.doc;\n        if (!textMeasureEl) {\n            textMeasureEl = doc.createElement('div');\n            textMeasureEl.style.cssText = 'position:absolute;top:-20000px;left:0;'\n                + 'padding:0;margin:0;border:none;white-space:pre;';\n            vmlCore.doc.body.appendChild(textMeasureEl);\n        }\n\n        try {\n            textMeasureEl.style.font = textFont;\n        } catch (ex) {\n            // Ignore failures to set to invalid font.\n        }\n        textMeasureEl.innerHTML = '';\n        // Don't use innerHTML or innerText because they allow markup/whitespace.\n        textMeasureEl.appendChild(doc.createTextNode(text));\n        return {\n            width: textMeasureEl.offsetWidth\n        };\n    };\n\n    var tmpRect = new BoundingRect();\n\n    var drawRectText = function (vmlRoot, rect, textRect, fromTextEl) {\n\n        var style = this.style;\n        var text = style.text;\n        // Convert to string\n        text != null && (text += '');\n        if (!text) {\n            return;\n        }\n\n        var x;\n        var y;\n        var align = style.textAlign;\n        var fontStyle = getFontStyle(style.textFont);\n        // FIXME encodeHtmlAttribute ?\n        var font = fontStyle.style + ' ' + fontStyle.variant + ' ' + fontStyle.weight + ' '\n            + fontStyle.size + 'px \"' + fontStyle.family + '\"';\n\n        var baseline = style.textBaseline;\n        var verticalAlign = style.textVerticalAlign;\n\n        textRect = textRect || textContain.getBoundingRect(text, font, align, baseline);\n\n        // Transform rect to view space\n        var m = this.transform;\n        // Ignore transform for text in other element\n        if (m && !fromTextEl) {\n            tmpRect.copy(rect);\n            tmpRect.applyTransform(m);\n            rect = tmpRect;\n        }\n\n        if (!fromTextEl) {\n            var textPosition = style.textPosition;\n            var distance = style.textDistance;\n            // Text position represented by coord\n            if (textPosition instanceof Array) {\n                x = rect.x + parsePercent(textPosition[0], rect.width);\n                y = rect.y + parsePercent(textPosition[1], rect.height);\n\n                align = align || 'left';\n                baseline = baseline || 'top';\n            }\n            else {\n                var res = textContain.adjustTextPositionOnRect(\n                    textPosition, rect, textRect, distance\n                );\n                x = res.x;\n                y = res.y;\n\n                // Default align and baseline when has textPosition\n                align = align || res.textAlign;\n                baseline = baseline || res.textBaseline;\n            }\n        }\n        else {\n            x = rect.x;\n            y = rect.y;\n        }\n        if (verticalAlign) {\n            switch (verticalAlign) {\n                case 'middle':\n                    y -= textRect.height / 2;\n                    break;\n                case 'bottom':\n                    y -= textRect.height;\n                    break;\n                // 'top'\n            }\n            // Ignore baseline\n            baseline = 'top';\n        }\n\n        var fontSize = fontStyle.size;\n        // 1.75 is an arbitrary number, as there is no info about the text baseline\n        switch (baseline) {\n            case 'hanging':\n            case 'top':\n                y += fontSize / 1.75;\n                break;\n            case 'middle':\n                break;\n            default:\n            // case null:\n            // case 'alphabetic':\n            // case 'ideographic':\n            // case 'bottom':\n                y -= fontSize / 2.25;\n                break;\n        }\n        switch (align) {\n            case 'left':\n                break;\n            case 'center':\n                x -= textRect.width / 2;\n                break;\n            case 'right':\n                x -= textRect.width;\n                break;\n            // case 'end':\n                // align = elementStyle.direction == 'ltr' ? 'right' : 'left';\n                // break;\n            // case 'start':\n                // align = elementStyle.direction == 'rtl' ? 'right' : 'left';\n                // break;\n            // default:\n            //     align = 'left';\n        }\n\n        var createNode = vmlCore.createNode;\n\n        var textVmlEl = this._textVmlEl;\n        var pathEl;\n        var textPathEl;\n        var skewEl;\n        if (!textVmlEl) {\n            textVmlEl = createNode('line');\n            pathEl = createNode('path');\n            textPathEl = createNode('textpath');\n            skewEl = createNode('skew');\n\n            // FIXME Why here is not cammel case\n            // Align 'center' seems wrong\n            textPathEl.style['v-text-align'] = 'left';\n\n            initRootElStyle(textVmlEl);\n\n            pathEl.textpathok = true;\n            textPathEl.on = true;\n\n            textVmlEl.from = '0 0';\n            textVmlEl.to = '1000 0.05';\n\n            append(textVmlEl, skewEl);\n            append(textVmlEl, pathEl);\n            append(textVmlEl, textPathEl);\n\n            this._textVmlEl = textVmlEl;\n        }\n        else {\n            // 这里是在前面 appendChild 保证顺序的前提下\n            skewEl = textVmlEl.firstChild;\n            pathEl = skewEl.nextSibling;\n            textPathEl = pathEl.nextSibling;\n        }\n\n        var coords = [x, y];\n        var textVmlElStyle = textVmlEl.style;\n        // Ignore transform for text in other element\n        if (m && fromTextEl) {\n            applyTransform(coords, coords, m);\n\n            skewEl.on = true;\n\n            skewEl.matrix = m[0].toFixed(3) + comma + m[2].toFixed(3) + comma +\n            m[1].toFixed(3) + comma + m[3].toFixed(3) + ',0,0';\n\n            // Text position\n            skewEl.offset = (round(coords[0]) || 0) + ',' + (round(coords[1]) || 0);\n            // Left top point as origin\n            skewEl.origin = '0 0';\n\n            textVmlElStyle.left = '0px';\n            textVmlElStyle.top = '0px';\n        }\n        else {\n            skewEl.on = false;\n            textVmlElStyle.left = round(x) + 'px';\n            textVmlElStyle.top = round(y) + 'px';\n        }\n\n        textPathEl.string = encodeHtmlAttribute(text);\n        // TODO\n        try {\n            textPathEl.style.font = font;\n        }\n        // Error font format\n        catch (e) {}\n\n        updateFillAndStroke(textVmlEl, 'fill', {\n            fill: fromTextEl ? style.fill : style.textFill,\n            opacity: style.opacity\n        }, this);\n        updateFillAndStroke(textVmlEl, 'stroke', {\n            stroke: fromTextEl ? style.stroke : style.textStroke,\n            opacity: style.opacity,\n            lineDash: style.lineDash\n        }, this);\n\n        textVmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2);\n\n        // Attached to root\n        append(vmlRoot, textVmlEl);\n    };\n\n    var removeRectText = function (vmlRoot) {\n        remove(vmlRoot, this._textVmlEl);\n        this._textVmlEl = null;\n    };\n\n    var appendRectText = function (vmlRoot) {\n        append(vmlRoot, this._textVmlEl);\n    };\n\n    var list = [RectText, Displayable, ZImage, Path, Text];\n\n    // In case Displayable has been mixed in RectText\n    for (var i = 0; i < list.length; i++) {\n        var proto = list[i].prototype;\n        proto.drawRectText = drawRectText;\n        proto.removeRectText = removeRectText;\n        proto.appendRectText = appendRectText;\n    }\n\n    Text.prototype.brushVML = function (vmlRoot) {\n        var style = this.style;\n        if (style.text != null) {\n            this.drawRectText(vmlRoot, {\n                x: style.x || 0, y: style.y || 0,\n                width: 0, height: 0\n            }, this.getBoundingRect(), true);\n        }\n        else {\n            this.removeRectText(vmlRoot);\n        }\n    };\n\n    Text.prototype.onRemove = function (vmlRoot) {\n        this.removeRectText(vmlRoot);\n    };\n\n    Text.prototype.onAdd = function (vmlRoot) {\n        this.appendRectText(vmlRoot);\n    };\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjAxLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy9ob21lL3l4L34venJlbmRlci9saWIvdm1sL2dyYXBoaWMuanM/MjVmNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9OT1RFLVZNTFxuLy8gVE9ETyBVc2UgcHJveHkgbGlrZSBzdmcgaW5zdGVhZCBvZiBvdmVyd3JpdGUgYnJ1c2ggbWV0aG9kc1xuXG5cbmlmICghcmVxdWlyZSgnLi4vY29yZS9lbnYnKS5jYW52YXNTdXBwb3J0ZWQpIHtcbiAgICB2YXIgdmVjMiA9IHJlcXVpcmUoJy4uL2NvcmUvdmVjdG9yJyk7XG4gICAgdmFyIEJvdW5kaW5nUmVjdCA9IHJlcXVpcmUoJy4uL2NvcmUvQm91bmRpbmdSZWN0Jyk7XG4gICAgdmFyIENNRCA9IHJlcXVpcmUoJy4uL2NvcmUvUGF0aFByb3h5JykuQ01EO1xuICAgIHZhciBjb2xvclRvb2wgPSByZXF1aXJlKCcuLi90b29sL2NvbG9yJyk7XG4gICAgdmFyIHRleHRDb250YWluID0gcmVxdWlyZSgnLi4vY29udGFpbi90ZXh0Jyk7XG4gICAgdmFyIFJlY3RUZXh0ID0gcmVxdWlyZSgnLi4vZ3JhcGhpYy9taXhpbi9SZWN0VGV4dCcpO1xuICAgIHZhciBEaXNwbGF5YWJsZSA9IHJlcXVpcmUoJy4uL2dyYXBoaWMvRGlzcGxheWFibGUnKTtcbiAgICB2YXIgWkltYWdlID0gcmVxdWlyZSgnLi4vZ3JhcGhpYy9JbWFnZScpO1xuICAgIHZhciBUZXh0ID0gcmVxdWlyZSgnLi4vZ3JhcGhpYy9UZXh0Jyk7XG4gICAgdmFyIFBhdGggPSByZXF1aXJlKCcuLi9ncmFwaGljL1BhdGgnKTtcbiAgICB2YXIgUGF0aFByb3h5ID0gcmVxdWlyZSgnLi4vY29yZS9QYXRoUHJveHknKTtcblxuICAgIHZhciBHcmFkaWVudCA9IHJlcXVpcmUoJy4uL2dyYXBoaWMvR3JhZGllbnQnKTtcblxuICAgIHZhciB2bWxDb3JlID0gcmVxdWlyZSgnLi9jb3JlJyk7XG5cbiAgICB2YXIgcm91bmQgPSBNYXRoLnJvdW5kO1xuICAgIHZhciBzcXJ0ID0gTWF0aC5zcXJ0O1xuICAgIHZhciBhYnMgPSBNYXRoLmFicztcbiAgICB2YXIgY29zID0gTWF0aC5jb3M7XG4gICAgdmFyIHNpbiA9IE1hdGguc2luO1xuICAgIHZhciBtYXRoTWF4ID0gTWF0aC5tYXg7XG5cbiAgICB2YXIgYXBwbHlUcmFuc2Zvcm0gPSB2ZWMyLmFwcGx5VHJhbnNmb3JtO1xuXG4gICAgdmFyIGNvbW1hID0gJywnO1xuICAgIHZhciBpbWFnZVRyYW5zZm9ybVByZWZpeCA9ICdwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQnO1xuXG4gICAgdmFyIFogPSAyMTYwMDtcbiAgICB2YXIgWjIgPSBaIC8gMjtcblxuICAgIHZhciBaTEVWRUxfQkFTRSA9IDEwMDAwMDtcbiAgICB2YXIgWl9CQVNFID0gMTAwMDtcblxuICAgIHZhciBpbml0Um9vdEVsU3R5bGUgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgZWwuc3R5bGUuY3NzVGV4dCA9ICdwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0OjA7dG9wOjA7d2lkdGg6MXB4O2hlaWdodDoxcHg7JztcbiAgICAgICAgZWwuY29vcmRzaXplID0gWiArICcsJyAgKyBaO1xuICAgICAgICBlbC5jb29yZG9yaWdpbiA9ICcwLDAnO1xuICAgIH07XG5cbiAgICB2YXIgZW5jb2RlSHRtbEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChzKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcocykucmVwbGFjZSgvJi9nLCAnJmFtcDsnKS5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7Jyk7XG4gICAgfTtcblxuICAgIHZhciByZ2IyU3RyID0gZnVuY3Rpb24gKHIsIGcsIGIpIHtcbiAgICAgICAgcmV0dXJuICdyZ2IoJyArIFtyLCBnLCBiXS5qb2luKCcsJykgKyAnKSc7XG4gICAgfTtcblxuICAgIHZhciBhcHBlbmQgPSBmdW5jdGlvbiAocGFyZW50LCBjaGlsZCkge1xuICAgICAgICBpZiAoY2hpbGQgJiYgcGFyZW50ICYmIGNoaWxkLnBhcmVudE5vZGUgIT09IHBhcmVudCkge1xuICAgICAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgcmVtb3ZlID0gZnVuY3Rpb24gKHBhcmVudCwgY2hpbGQpIHtcbiAgICAgICAgaWYgKGNoaWxkICYmIHBhcmVudCAmJiBjaGlsZC5wYXJlbnROb2RlID09PSBwYXJlbnQpIHtcbiAgICAgICAgICAgIHBhcmVudC5yZW1vdmVDaGlsZChjaGlsZCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGdldFpJbmRleCA9IGZ1bmN0aW9uICh6bGV2ZWwsIHosIHoyKSB7XG4gICAgICAgIC8vIHog55qE5Y+W5YC86IyD5Zu05Li6IFswLCAxMDAwXVxuICAgICAgICByZXR1cm4gKHBhcnNlRmxvYXQoemxldmVsKSB8fCAwKSAqIFpMRVZFTF9CQVNFICsgKHBhcnNlRmxvYXQoeikgfHwgMCkgKiBaX0JBU0UgKyB6MjtcbiAgICB9O1xuXG4gICAgdmFyIHBhcnNlUGVyY2VudCA9IGZ1bmN0aW9uICh2YWx1ZSwgbWF4VmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZS5sYXN0SW5kZXhPZignJScpID49IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCh2YWx1ZSkgLyAxMDAgKiBtYXhWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgKiBQQVRIXG4gICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgdmFyIHNldENvbG9yQW5kT3BhY2l0eSA9IGZ1bmN0aW9uIChlbCwgY29sb3IsIG9wYWNpdHkpIHtcbiAgICAgICAgdmFyIGNvbG9yQXJyID0gY29sb3JUb29sLnBhcnNlKGNvbG9yKTtcbiAgICAgICAgb3BhY2l0eSA9ICtvcGFjaXR5O1xuICAgICAgICBpZiAoaXNOYU4ob3BhY2l0eSkpIHtcbiAgICAgICAgICAgIG9wYWNpdHkgPSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb2xvckFycikge1xuICAgICAgICAgICAgZWwuY29sb3IgPSByZ2IyU3RyKGNvbG9yQXJyWzBdLCBjb2xvckFyclsxXSwgY29sb3JBcnJbMl0pO1xuICAgICAgICAgICAgZWwub3BhY2l0eSA9IG9wYWNpdHkgKiBjb2xvckFyclszXTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgZ2V0Q29sb3JBbmRBbHBoYSA9IGZ1bmN0aW9uIChjb2xvcikge1xuICAgICAgICB2YXIgY29sb3JBcnIgPSBjb2xvclRvb2wucGFyc2UoY29sb3IpO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgcmdiMlN0cihjb2xvckFyclswXSwgY29sb3JBcnJbMV0sIGNvbG9yQXJyWzJdKSxcbiAgICAgICAgICAgIGNvbG9yQXJyWzNdXG4gICAgICAgIF07XG4gICAgfTtcblxuICAgIHZhciB1cGRhdGVGaWxsTm9kZSA9IGZ1bmN0aW9uIChlbCwgc3R5bGUsIHpyRWwpIHtcbiAgICAgICAgLy8gVE9ETyBwYXR0ZXJuXG4gICAgICAgIHZhciBmaWxsID0gc3R5bGUuZmlsbDtcbiAgICAgICAgaWYgKGZpbGwgIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gTW9kaWZpZWQgZnJvbSBleGNhbnZhc1xuICAgICAgICAgICAgaWYgKGZpbGwgaW5zdGFuY2VvZiBHcmFkaWVudCkge1xuICAgICAgICAgICAgICAgIHZhciBncmFkaWVudFR5cGU7XG4gICAgICAgICAgICAgICAgdmFyIGFuZ2xlID0gMDtcbiAgICAgICAgICAgICAgICB2YXIgZm9jdXMgPSBbMCwgMF07XG4gICAgICAgICAgICAgICAgLy8gYWRkaXRpb25hbCBvZmZzZXRcbiAgICAgICAgICAgICAgICB2YXIgc2hpZnQgPSAwO1xuICAgICAgICAgICAgICAgIC8vIHNjYWxlIGZhY3RvciBmb3Igb2Zmc2V0XG4gICAgICAgICAgICAgICAgdmFyIGV4cGFuc2lvbiA9IDE7XG4gICAgICAgICAgICAgICAgdmFyIHJlY3QgPSB6ckVsLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgICAgICAgICAgICAgIHZhciByZWN0V2lkdGggPSByZWN0LndpZHRoO1xuICAgICAgICAgICAgICAgIHZhciByZWN0SGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgaWYgKGZpbGwudHlwZSA9PT0gJ2xpbmVhcicpIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnRUeXBlID0gJ2dyYWRpZW50JztcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRyYW5zZm9ybSA9IHpyRWwudHJhbnNmb3JtO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcDAgPSBbZmlsbC54ICogcmVjdFdpZHRoLCBmaWxsLnkgKiByZWN0SGVpZ2h0XTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHAxID0gW2ZpbGwueDIgKiByZWN0V2lkdGgsIGZpbGwueTIgKiByZWN0SGVpZ2h0XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXBwbHlUcmFuc2Zvcm0ocDAsIHAwLCB0cmFuc2Zvcm0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXBwbHlUcmFuc2Zvcm0ocDEsIHAxLCB0cmFuc2Zvcm0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBkeCA9IHAxWzBdIC0gcDBbMF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBkeSA9IHAxWzFdIC0gcDBbMV07XG4gICAgICAgICAgICAgICAgICAgIGFuZ2xlID0gTWF0aC5hdGFuMihkeCwgZHkpICogMTgwIC8gTWF0aC5QSTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGFuZ2xlIHNob3VsZCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuXG4gICAgICAgICAgICAgICAgICAgIGlmIChhbmdsZSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuZ2xlICs9IDM2MDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFZlcnkgc21hbGwgYW5nbGVzIHByb2R1Y2UgYW4gdW5leHBlY3RlZCByZXN1bHQgYmVjYXVzZSB0aGV5IGFyZVxuICAgICAgICAgICAgICAgICAgICAvLyBjb252ZXJ0ZWQgdG8gYSBzY2llbnRpZmljIG5vdGF0aW9uIHN0cmluZy5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGFuZ2xlIDwgMWUtNikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYW5nbGUgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBncmFkaWVudFR5cGUgPSAnZ3JhZGllbnRyYWRpYWwnO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcDAgPSBbZmlsbC54ICogcmVjdFdpZHRoLCBmaWxsLnkgKiByZWN0SGVpZ2h0XTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRyYW5zZm9ybSA9IHpyRWwudHJhbnNmb3JtO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2NhbGUgPSB6ckVsLnNjYWxlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSByZWN0V2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIHZhciBoZWlnaHQgPSByZWN0SGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBmb2N1cyA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBlcmNlbnQgaW4gYm91bmRpbmcgcmVjdFxuICAgICAgICAgICAgICAgICAgICAgICAgKHAwWzBdIC0gcmVjdC54KSAvIHdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgKHAwWzFdIC0gcmVjdC55KSAvIGhlaWdodFxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcHBseVRyYW5zZm9ybShwMCwgcDAsIHRyYW5zZm9ybSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB3aWR0aCAvPSBzY2FsZVswXSAqIFo7XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCAvPSBzY2FsZVsxXSAqIFo7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkaW1lbnNpb24gPSBtYXRoTWF4KHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBzaGlmdCA9IDIgKiAwIC8gZGltZW5zaW9uO1xuICAgICAgICAgICAgICAgICAgICBleHBhbnNpb24gPSAyICogZmlsbC5yIC8gZGltZW5zaW9uIC0gc2hpZnQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBzb3J0IHRoZSBjb2xvciBzdG9wcyBpbiBhc2NlbmRpbmcgb3JkZXIgYnkgb2Zmc2V0LFxuICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZSBJRSB3b24ndCBpbnRlcnByZXQgaXQgY29ycmVjdGx5LlxuICAgICAgICAgICAgICAgIHZhciBzdG9wcyA9IGZpbGwuY29sb3JTdG9wcy5zbGljZSgpO1xuICAgICAgICAgICAgICAgIHN0b3BzLnNvcnQoZnVuY3Rpb24oY3MxLCBjczIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNzMS5vZmZzZXQgLSBjczIub2Zmc2V0O1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgdmFyIGxlbmd0aCA9IHN0b3BzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAvLyBDb2xvciBhbmQgYWxwaGEgbGlzdCBvZiBmaXJzdCBhbmQgbGFzdCBzdG9wXG4gICAgICAgICAgICAgICAgdmFyIGNvbG9yQW5kQWxwaGFMaXN0ID0gW107XG4gICAgICAgICAgICAgICAgdmFyIGNvbG9ycyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0b3AgPSBzdG9wc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbG9yQW5kQWxwaGEgPSBnZXRDb2xvckFuZEFscGhhKHN0b3AuY29sb3IpO1xuICAgICAgICAgICAgICAgICAgICBjb2xvcnMucHVzaChzdG9wLm9mZnNldCAqIGV4cGFuc2lvbiArIHNoaWZ0ICsgJyAnICsgY29sb3JBbmRBbHBoYVswXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpID09PSAwIHx8IGkgPT09IGxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yQW5kQWxwaGFMaXN0LnB1c2goY29sb3JBbmRBbHBoYSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAobGVuZ3RoID49IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbG9yMSA9IGNvbG9yQW5kQWxwaGFMaXN0WzBdWzBdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29sb3IyID0gY29sb3JBbmRBbHBoYUxpc3RbMV1bMF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBvcGFjaXR5MSA9IGNvbG9yQW5kQWxwaGFMaXN0WzBdWzFdICogc3R5bGUub3BhY2l0eTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wYWNpdHkyID0gY29sb3JBbmRBbHBoYUxpc3RbMV1bMV0gKiBzdHlsZS5vcGFjaXR5O1xuXG4gICAgICAgICAgICAgICAgICAgIGVsLnR5cGUgPSBncmFkaWVudFR5cGU7XG4gICAgICAgICAgICAgICAgICAgIGVsLm1ldGhvZCA9ICdub25lJztcbiAgICAgICAgICAgICAgICAgICAgZWwuZm9jdXMgPSAnMTAwJSc7XG4gICAgICAgICAgICAgICAgICAgIGVsLmFuZ2xlID0gYW5nbGU7XG4gICAgICAgICAgICAgICAgICAgIGVsLmNvbG9yID0gY29sb3IxO1xuICAgICAgICAgICAgICAgICAgICBlbC5jb2xvcjIgPSBjb2xvcjI7XG4gICAgICAgICAgICAgICAgICAgIGVsLmNvbG9ycyA9IGNvbG9ycy5qb2luKCcsJyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gY29sb3JzIGF0dHJpYnV0ZSBpcyB1c2VkLCB0aGUgbWVhbmluZ3Mgb2Ygb3BhY2l0eSBhbmQgbzpvcGFjaXR5MlxuICAgICAgICAgICAgICAgICAgICAvLyBhcmUgcmV2ZXJzZWQuXG4gICAgICAgICAgICAgICAgICAgIGVsLm9wYWNpdHkgPSBvcGFjaXR5MjtcbiAgICAgICAgICAgICAgICAgICAgLy8gRklYTUUgZ19vXzpvcGFjaXR5ID9cbiAgICAgICAgICAgICAgICAgICAgZWwub3BhY2l0eTIgPSBvcGFjaXR5MTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGdyYWRpZW50VHlwZSA9PT0gJ3JhZGlhbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgZWwuZm9jdXNwb3NpdGlvbiA9IGZvY3VzLmpvaW4oJywnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBGSVhNRSBDaGFuZ2UgZnJvbSBHcmFkaWVudCBmaWxsIHRvIGNvbG9yIGZpbGxcbiAgICAgICAgICAgICAgICBzZXRDb2xvckFuZE9wYWNpdHkoZWwsIGZpbGwsIHN0eWxlLm9wYWNpdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciB1cGRhdGVTdHJva2VOb2RlID0gZnVuY3Rpb24gKGVsLCBzdHlsZSkge1xuICAgICAgICAvLyBpZiAoc3R5bGUubGluZUpvaW4gIT0gbnVsbCkge1xuICAgICAgICAvLyAgICAgZWwuam9pbnN0eWxlID0gc3R5bGUubGluZUpvaW47XG4gICAgICAgIC8vIH1cbiAgICAgICAgLy8gaWYgKHN0eWxlLm1pdGVyTGltaXQgIT0gbnVsbCkge1xuICAgICAgICAvLyAgICAgZWwubWl0ZXJsaW1pdCA9IHN0eWxlLm1pdGVyTGltaXQgKiBaO1xuICAgICAgICAvLyB9XG4gICAgICAgIC8vIGlmIChzdHlsZS5saW5lQ2FwICE9IG51bGwpIHtcbiAgICAgICAgLy8gICAgIGVsLmVuZGNhcCA9IHN0eWxlLmxpbmVDYXA7XG4gICAgICAgIC8vIH1cbiAgICAgICAgaWYgKHN0eWxlLmxpbmVEYXNoICE9IG51bGwpIHtcbiAgICAgICAgICAgIGVsLmRhc2hzdHlsZSA9IHN0eWxlLmxpbmVEYXNoLmpvaW4oJyAnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3R5bGUuc3Ryb2tlICE9IG51bGwgJiYgIShzdHlsZS5zdHJva2UgaW5zdGFuY2VvZiBHcmFkaWVudCkpIHtcbiAgICAgICAgICAgIHNldENvbG9yQW5kT3BhY2l0eShlbCwgc3R5bGUuc3Ryb2tlLCBzdHlsZS5vcGFjaXR5KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgdXBkYXRlRmlsbEFuZFN0cm9rZSA9IGZ1bmN0aW9uICh2bWxFbCwgdHlwZSwgc3R5bGUsIHpyRWwpIHtcbiAgICAgICAgdmFyIGlzRmlsbCA9IHR5cGUgPT0gJ2ZpbGwnO1xuICAgICAgICB2YXIgZWwgPSB2bWxFbC5nZXRFbGVtZW50c0J5VGFnTmFtZSh0eXBlKVswXTtcbiAgICAgICAgLy8gU3Ryb2tlIG11c3QgaGF2ZSBsaW5lV2lkdGhcbiAgICAgICAgaWYgKHN0eWxlW3R5cGVdICE9IG51bGwgJiYgc3R5bGVbdHlwZV0gIT09ICdub25lJyAmJiAoaXNGaWxsIHx8ICghaXNGaWxsICYmIHN0eWxlLmxpbmVXaWR0aCkpKSB7XG4gICAgICAgICAgICB2bWxFbFtpc0ZpbGwgPyAnZmlsbGVkJyA6ICdzdHJva2VkJ10gPSAndHJ1ZSc7XG4gICAgICAgICAgICAvLyBGSVhNRSBSZW1vdmUgYmVmb3JlIHVwZGF0aW5nLCBvciBzZXQgYGNvbG9yc2Agd2lsbCB0aHJvdyBlcnJvclxuICAgICAgICAgICAgaWYgKHN0eWxlW3R5cGVdIGluc3RhbmNlb2YgR3JhZGllbnQpIHtcbiAgICAgICAgICAgICAgICByZW1vdmUodm1sRWwsIGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZWwpIHtcbiAgICAgICAgICAgICAgICBlbCA9IHZtbENvcmUuY3JlYXRlTm9kZSh0eXBlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaXNGaWxsID8gdXBkYXRlRmlsbE5vZGUoZWwsIHN0eWxlLCB6ckVsKSA6IHVwZGF0ZVN0cm9rZU5vZGUoZWwsIHN0eWxlKTtcbiAgICAgICAgICAgIGFwcGVuZCh2bWxFbCwgZWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdm1sRWxbaXNGaWxsID8gJ2ZpbGxlZCcgOiAnc3Ryb2tlZCddID0gJ2ZhbHNlJztcbiAgICAgICAgICAgIHJlbW92ZSh2bWxFbCwgZWwpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBwb2ludHMgPSBbW10sIFtdLCBbXV07XG4gICAgdmFyIHBhdGhEYXRhVG9TdHJpbmcgPSBmdW5jdGlvbiAoZGF0YSwgbSkge1xuICAgICAgICB2YXIgTSA9IENNRC5NO1xuICAgICAgICB2YXIgQyA9IENNRC5DO1xuICAgICAgICB2YXIgTCA9IENNRC5MO1xuICAgICAgICB2YXIgQSA9IENNRC5BO1xuICAgICAgICB2YXIgUSA9IENNRC5RO1xuXG4gICAgICAgIHZhciBzdHIgPSBbXTtcbiAgICAgICAgdmFyIG5Qb2ludDtcbiAgICAgICAgdmFyIGNtZFN0cjtcbiAgICAgICAgdmFyIGNtZDtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciB4aTtcbiAgICAgICAgdmFyIHlpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7KSB7XG4gICAgICAgICAgICBjbWQgPSBkYXRhW2krK107XG4gICAgICAgICAgICBjbWRTdHIgPSAnJztcbiAgICAgICAgICAgIG5Qb2ludCA9IDA7XG4gICAgICAgICAgICBzd2l0Y2ggKGNtZCkge1xuICAgICAgICAgICAgICAgIGNhc2UgTTpcbiAgICAgICAgICAgICAgICAgICAgY21kU3RyID0gJyBtICc7XG4gICAgICAgICAgICAgICAgICAgIG5Qb2ludCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIHhpID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICB5aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzWzBdWzBdID0geGk7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50c1swXVsxXSA9IHlpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEw6XG4gICAgICAgICAgICAgICAgICAgIGNtZFN0ciA9ICcgbCAnO1xuICAgICAgICAgICAgICAgICAgICBuUG9pbnQgPSAxO1xuICAgICAgICAgICAgICAgICAgICB4aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgeWkgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHBvaW50c1swXVswXSA9IHhpO1xuICAgICAgICAgICAgICAgICAgICBwb2ludHNbMF1bMV0gPSB5aTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBROlxuICAgICAgICAgICAgICAgIGNhc2UgQzpcbiAgICAgICAgICAgICAgICAgICAgY21kU3RyID0gJyBjICc7XG4gICAgICAgICAgICAgICAgICAgIG5Qb2ludCA9IDM7XG4gICAgICAgICAgICAgICAgICAgIHZhciB4MSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHkxID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgeDIgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHZhciB5MiA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHgzO1xuICAgICAgICAgICAgICAgICAgICB2YXIgeTM7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjbWQgPT09IFEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgcXVhZHJhdGljIHRvIGN1YmljIHVzaW5nIGRlZ3JlZSBlbGV2YXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIHgzID0geDI7XG4gICAgICAgICAgICAgICAgICAgICAgICB5MyA9IHkyO1xuICAgICAgICAgICAgICAgICAgICAgICAgeDIgPSAoeDIgKyAyICogeDEpIC8gMztcbiAgICAgICAgICAgICAgICAgICAgICAgIHkyID0gKHkyICsgMiAqIHkxKSAvIDM7XG4gICAgICAgICAgICAgICAgICAgICAgICB4MSA9ICh4aSArIDIgKiB4MSkgLyAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgeTEgPSAoeWkgKyAyICogeTEpIC8gMztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHgzID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgeTMgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzWzBdWzBdID0geDE7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50c1swXVsxXSA9IHkxO1xuICAgICAgICAgICAgICAgICAgICBwb2ludHNbMV1bMF0gPSB4MjtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzWzFdWzFdID0geTI7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50c1syXVswXSA9IHgzO1xuICAgICAgICAgICAgICAgICAgICBwb2ludHNbMl1bMV0gPSB5MztcblxuICAgICAgICAgICAgICAgICAgICB4aSA9IHgzO1xuICAgICAgICAgICAgICAgICAgICB5aSA9IHkzO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEE6XG4gICAgICAgICAgICAgICAgICAgIHZhciB4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHkgPSAwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3ggPSAxO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3kgPSAxO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYW5nbGUgPSAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBTUlQgZnJvbSBtYXRyaXhcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSBtWzRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IG1bNV07XG4gICAgICAgICAgICAgICAgICAgICAgICBzeCA9IHNxcnQobVswXSAqIG1bMF0gKyBtWzFdICogbVsxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzeSA9IHNxcnQobVsyXSAqIG1bMl0gKyBtWzNdICogbVszXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbmdsZSA9IE1hdGguYXRhbjIoLW1bMV0gLyBzeSwgbVswXSAvIHN4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhciBjeCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN5ID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcnggPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHZhciByeSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0QW5nbGUgPSBkYXRhW2krK10gKyBhbmdsZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVuZEFuZ2xlID0gZGF0YVtpKytdICsgc3RhcnRBbmdsZSArIGFuZ2xlO1xuICAgICAgICAgICAgICAgICAgICAvLyBGSVhNRVxuICAgICAgICAgICAgICAgICAgICAvLyB2YXIgcHNpID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjbG9ja3dpc2UgPSBkYXRhW2krK107XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHgwID0gY3ggKyBjb3Moc3RhcnRBbmdsZSkgKiByeDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHkwID0gY3kgKyBzaW4oc3RhcnRBbmdsZSkgKiByeTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgeDEgPSBjeCArIGNvcyhlbmRBbmdsZSkgKiByeDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHkxID0gY3kgKyBzaW4oZW5kQW5nbGUpICogcnk7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBjbG9ja3dpc2UgPyAnIHdhICcgOiAnIGF0ICc7XG4gICAgICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyh4MCAtIHgxKSA8IDFlLTQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElFIHdvbid0IHJlbmRlciBhcmNoZXMgZHJhd24gY291bnRlciBjbG9ja3dpc2UgaWYgeDAgPT0geDEuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMoZW5kQW5nbGUgLSBzdGFydEFuZ2xlKSA+IDFlLTIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPZmZzZXQgeDAgYnkgMS84MCBvZiBhIHBpeGVsLiBVc2Ugc29tZXRoaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhhdCBjYW4gYmUgcmVwcmVzZW50ZWQgaW4gYmluYXJ5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNsb2Nrd2lzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4MCArPSAyNzAgLyBaO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEF2b2lkIGNhc2UgZHJhdyBmdWxsIGNpcmNsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyh5MCAtIGN5KSA8IDFlLTQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChjbG9ja3dpc2UgJiYgeDAgPCBjeCkgfHwgKCFjbG9ja3dpc2UgJiYgeDAgPiBjeCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkxIC09IDI3MCAvIFo7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5MSArPSAyNzAgLyBaO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKChjbG9ja3dpc2UgJiYgeTAgPCBjeSkgfHwgKCFjbG9ja3dpc2UgJiYgeTAgPiBjeSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDEgKz0gMjcwIC8gWjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgxIC09IDI3MCAvIFo7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN0ci5wdXNoKFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdW5kKCgoY3ggLSByeCkgKiBzeCArIHgpICogWiAtIFoyKSwgY29tbWEsXG4gICAgICAgICAgICAgICAgICAgICAgICByb3VuZCgoKGN5IC0gcnkpICogc3kgKyB5KSAqIFogLSBaMiksIGNvbW1hLFxuICAgICAgICAgICAgICAgICAgICAgICAgcm91bmQoKChjeCArIHJ4KSAqIHN4ICsgeCkgKiBaIC0gWjIpLCBjb21tYSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdW5kKCgoY3kgKyByeSkgKiBzeSArIHkpICogWiAtIFoyKSwgY29tbWEsXG4gICAgICAgICAgICAgICAgICAgICAgICByb3VuZCgoeDAgKiBzeCArIHgpICogWiAtIFoyKSwgY29tbWEsXG4gICAgICAgICAgICAgICAgICAgICAgICByb3VuZCgoeTAgKiBzeSArIHkpICogWiAtIFoyKSwgY29tbWEsXG4gICAgICAgICAgICAgICAgICAgICAgICByb3VuZCgoeDEgKiBzeCArIHgpICogWiAtIFoyKSwgY29tbWEsXG4gICAgICAgICAgICAgICAgICAgICAgICByb3VuZCgoeTEgKiBzeSArIHkpICogWiAtIFoyKVxuICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgIHhpID0geDE7XG4gICAgICAgICAgICAgICAgICAgIHlpID0geTE7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQ01ELlI6XG4gICAgICAgICAgICAgICAgICAgIHZhciBwMCA9IHBvaW50c1swXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHAxID0gcG9pbnRzWzFdO1xuICAgICAgICAgICAgICAgICAgICAvLyB4MCwgeTBcbiAgICAgICAgICAgICAgICAgICAgcDBbMF0gPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHAwWzFdID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICAvLyB4MSwgeTFcbiAgICAgICAgICAgICAgICAgICAgcDFbMF0gPSBwMFswXSArIGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgcDFbMV0gPSBwMFsxXSArIGRhdGFbaSsrXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXBwbHlUcmFuc2Zvcm0ocDAsIHAwLCBtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwcGx5VHJhbnNmb3JtKHAxLCBwMSwgbSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBwMFswXSA9IHJvdW5kKHAwWzBdICogWiAtIFoyKTtcbiAgICAgICAgICAgICAgICAgICAgcDFbMF0gPSByb3VuZChwMVswXSAqIFogLSBaMik7XG4gICAgICAgICAgICAgICAgICAgIHAwWzFdID0gcm91bmQocDBbMV0gKiBaIC0gWjIpO1xuICAgICAgICAgICAgICAgICAgICBwMVsxXSA9IHJvdW5kKHAxWzFdICogWiAtIFoyKTtcbiAgICAgICAgICAgICAgICAgICAgc3RyLnB1c2goXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB4MCwgeTBcbiAgICAgICAgICAgICAgICAgICAgICAgICcgbSAnLCBwMFswXSwgY29tbWEsIHAwWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8geDEsIHkwXG4gICAgICAgICAgICAgICAgICAgICAgICAnIGwgJywgcDFbMF0sIGNvbW1hLCBwMFsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHgxLCB5MVxuICAgICAgICAgICAgICAgICAgICAgICAgJyBsICcsIHAxWzBdLCBjb21tYSwgcDFbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB4MCwgeTFcbiAgICAgICAgICAgICAgICAgICAgICAgICcgbCAnLCBwMFswXSwgY29tbWEsIHAxWzFdXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQ01ELlo6XG4gICAgICAgICAgICAgICAgICAgIC8vIEZJWE1FIFVwZGF0ZSB4aSwgeWlcbiAgICAgICAgICAgICAgICAgICAgc3RyLnB1c2goJyB4ICcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoblBvaW50ID4gMCkge1xuICAgICAgICAgICAgICAgIHN0ci5wdXNoKGNtZFN0cik7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBuUG9pbnQ7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IHBvaW50c1trXTtcblxuICAgICAgICAgICAgICAgICAgICBtICYmIGFwcGx5VHJhbnNmb3JtKHAsIHAsIG0pO1xuICAgICAgICAgICAgICAgICAgICAvLyDkuI0gcm91bmQg5Lya6Z2e5bi45oWiXG4gICAgICAgICAgICAgICAgICAgIHN0ci5wdXNoKFxuICAgICAgICAgICAgICAgICAgICAgICAgcm91bmQocFswXSAqIFogLSBaMiksIGNvbW1hLCByb3VuZChwWzFdICogWiAtIFoyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGsgPCBuUG9pbnQgLSAxID8gY29tbWEgOiAnJ1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdHIuam9pbignJyk7XG4gICAgfTtcblxuICAgIC8vIFJld3JpdGUgdGhlIG9yaWdpbmFsIHBhdGggbWV0aG9kXG4gICAgUGF0aC5wcm90b3R5cGUuYnJ1c2hWTUwgPSBmdW5jdGlvbiAodm1sUm9vdCkge1xuICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLnN0eWxlO1xuXG4gICAgICAgIHZhciB2bWxFbCA9IHRoaXMuX3ZtbEVsO1xuICAgICAgICBpZiAoIXZtbEVsKSB7XG4gICAgICAgICAgICB2bWxFbCA9IHZtbENvcmUuY3JlYXRlTm9kZSgnc2hhcGUnKTtcbiAgICAgICAgICAgIGluaXRSb290RWxTdHlsZSh2bWxFbCk7XG5cbiAgICAgICAgICAgIHRoaXMuX3ZtbEVsID0gdm1sRWw7XG4gICAgICAgIH1cblxuICAgICAgICB1cGRhdGVGaWxsQW5kU3Ryb2tlKHZtbEVsLCAnZmlsbCcsIHN0eWxlLCB0aGlzKTtcbiAgICAgICAgdXBkYXRlRmlsbEFuZFN0cm9rZSh2bWxFbCwgJ3N0cm9rZScsIHN0eWxlLCB0aGlzKTtcblxuICAgICAgICB2YXIgbSA9IHRoaXMudHJhbnNmb3JtO1xuICAgICAgICB2YXIgbmVlZFRyYW5zZm9ybSA9IG0gIT0gbnVsbDtcbiAgICAgICAgdmFyIHN0cm9rZUVsID0gdm1sRWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3N0cm9rZScpWzBdO1xuICAgICAgICBpZiAoc3Ryb2tlRWwpIHtcbiAgICAgICAgICAgIHZhciBsaW5lV2lkdGggPSBzdHlsZS5saW5lV2lkdGg7XG4gICAgICAgICAgICAvLyBHZXQgdGhlIGxpbmUgc2NhbGUuXG4gICAgICAgICAgICAvLyBEZXRlcm1pbmFudCBvZiB0aGlzLm1fIG1lYW5zIGhvdyBtdWNoIHRoZSBhcmVhIGlzIGVubGFyZ2VkIGJ5IHRoZVxuICAgICAgICAgICAgLy8gdHJhbnNmb3JtYXRpb24uIFNvIGl0cyBzcXVhcmUgcm9vdCBjYW4gYmUgdXNlZCBhcyBhIHNjYWxlIGZhY3RvclxuICAgICAgICAgICAgLy8gZm9yIHdpZHRoLlxuICAgICAgICAgICAgaWYgKG5lZWRUcmFuc2Zvcm0gJiYgIXN0eWxlLnN0cm9rZU5vU2NhbGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGV0ID0gbVswXSAqIG1bM10gLSBtWzFdICogbVsyXTtcbiAgICAgICAgICAgICAgICBsaW5lV2lkdGggKj0gc3FydChhYnMoZGV0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHJva2VFbC53ZWlnaHQgPSBsaW5lV2lkdGggKyAncHgnO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBhdGggPSB0aGlzLnBhdGggfHwgKHRoaXMucGF0aCA9IG5ldyBQYXRoUHJveHkoKSk7XG4gICAgICAgIGlmICh0aGlzLl9fZGlydHlQYXRoKSB7XG4gICAgICAgICAgICBwYXRoLmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgdGhpcy5idWlsZFBhdGgocGF0aCwgdGhpcy5zaGFwZSk7XG4gICAgICAgICAgICBwYXRoLnRvU3RhdGljKCk7XG4gICAgICAgICAgICB0aGlzLl9fZGlydHlQYXRoID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB2bWxFbC5wYXRoID0gcGF0aERhdGFUb1N0cmluZyhwYXRoLmRhdGEsIHRoaXMudHJhbnNmb3JtKTtcblxuICAgICAgICB2bWxFbC5zdHlsZS56SW5kZXggPSBnZXRaSW5kZXgodGhpcy56bGV2ZWwsIHRoaXMueiwgdGhpcy56Mik7XG5cbiAgICAgICAgLy8gQXBwZW5kIHRvIHJvb3RcbiAgICAgICAgYXBwZW5kKHZtbFJvb3QsIHZtbEVsKTtcblxuICAgICAgICAvLyBUZXh0XG4gICAgICAgIGlmIChzdHlsZS50ZXh0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhd1JlY3RUZXh0KHZtbFJvb3QsIHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVSZWN0VGV4dCh2bWxSb290KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBQYXRoLnByb3RvdHlwZS5vblJlbW92ZSA9IGZ1bmN0aW9uICh2bWxSb290KSB7XG4gICAgICAgIHJlbW92ZSh2bWxSb290LCB0aGlzLl92bWxFbCk7XG4gICAgICAgIHRoaXMucmVtb3ZlUmVjdFRleHQodm1sUm9vdCk7XG4gICAgfTtcblxuICAgIFBhdGgucHJvdG90eXBlLm9uQWRkID0gZnVuY3Rpb24gKHZtbFJvb3QpIHtcbiAgICAgICAgYXBwZW5kKHZtbFJvb3QsIHRoaXMuX3ZtbEVsKTtcbiAgICAgICAgdGhpcy5hcHBlbmRSZWN0VGV4dCh2bWxSb290KTtcbiAgICB9O1xuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAqIElNQUdFXG4gICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgIHZhciBpc0ltYWdlID0gZnVuY3Rpb24gKGltZykge1xuICAgICAgICAvLyBGSVhNRSBpbWcgaW5zdGFuY2VvZiBJbWFnZSDlpoLmnpwgaW1nIOaYr+S4gOS4quWtl+espuS4sueahOaXtuWAme+8jElFOCDkuIvkvJrmiqXplJlcbiAgICAgICAgcmV0dXJuICh0eXBlb2YgaW1nID09PSAnb2JqZWN0JykgJiYgaW1nLnRhZ05hbWUgJiYgaW1nLnRhZ05hbWUudG9VcHBlckNhc2UoKSA9PT0gJ0lNRyc7XG4gICAgICAgIC8vIHJldHVybiBpbWcgaW5zdGFuY2VvZiBJbWFnZTtcbiAgICB9O1xuXG4gICAgLy8gUmV3cml0ZSB0aGUgb3JpZ2luYWwgcGF0aCBtZXRob2RcbiAgICBaSW1hZ2UucHJvdG90eXBlLmJydXNoVk1MID0gZnVuY3Rpb24gKHZtbFJvb3QpIHtcbiAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTtcbiAgICAgICAgdmFyIGltYWdlID0gc3R5bGUuaW1hZ2U7XG5cbiAgICAgICAgLy8gSW1hZ2Ugb3JpZ2luYWwgd2lkdGgsIGhlaWdodFxuICAgICAgICB2YXIgb3c7XG4gICAgICAgIHZhciBvaDtcblxuICAgICAgICBpZiAoaXNJbWFnZShpbWFnZSkpIHtcbiAgICAgICAgICAgIHZhciBzcmMgPSBpbWFnZS5zcmM7XG4gICAgICAgICAgICBpZiAoc3JjID09PSB0aGlzLl9pbWFnZVNyYykge1xuICAgICAgICAgICAgICAgIG93ID0gdGhpcy5faW1hZ2VXaWR0aDtcbiAgICAgICAgICAgICAgICBvaCA9IHRoaXMuX2ltYWdlSGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGltYWdlUnVudGltZVN0eWxlID0gaW1hZ2UucnVudGltZVN0eWxlO1xuICAgICAgICAgICAgICAgIHZhciBvbGRSdW50aW1lV2lkdGggPSBpbWFnZVJ1bnRpbWVTdHlsZS53aWR0aDtcbiAgICAgICAgICAgICAgICB2YXIgb2xkUnVudGltZUhlaWdodCA9IGltYWdlUnVudGltZVN0eWxlLmhlaWdodDtcbiAgICAgICAgICAgICAgICBpbWFnZVJ1bnRpbWVTdHlsZS53aWR0aCA9ICdhdXRvJztcbiAgICAgICAgICAgICAgICBpbWFnZVJ1bnRpbWVTdHlsZS5oZWlnaHQgPSAnYXV0byc7XG5cbiAgICAgICAgICAgICAgICAvLyBnZXQgdGhlIG9yaWdpbmFsIHNpemVcbiAgICAgICAgICAgICAgICBvdyA9IGltYWdlLndpZHRoO1xuICAgICAgICAgICAgICAgIG9oID0gaW1hZ2UuaGVpZ2h0O1xuXG4gICAgICAgICAgICAgICAgLy8gYW5kIHJlbW92ZSBvdmVyaWRlc1xuICAgICAgICAgICAgICAgIGltYWdlUnVudGltZVN0eWxlLndpZHRoID0gb2xkUnVudGltZVdpZHRoO1xuICAgICAgICAgICAgICAgIGltYWdlUnVudGltZVN0eWxlLmhlaWdodCA9IG9sZFJ1bnRpbWVIZWlnaHQ7XG5cbiAgICAgICAgICAgICAgICAvLyBDYWNoaW5nIGltYWdlIG9yaWdpbmFsIHdpZHRoLCBoZWlnaHQgYW5kIHNyY1xuICAgICAgICAgICAgICAgIHRoaXMuX2ltYWdlU3JjID0gc3JjO1xuICAgICAgICAgICAgICAgIHRoaXMuX2ltYWdlV2lkdGggPSBvdztcbiAgICAgICAgICAgICAgICB0aGlzLl9pbWFnZUhlaWdodCA9IG9oO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW1hZ2UgPSBzcmM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoaW1hZ2UgPT09IHRoaXMuX2ltYWdlU3JjKSB7XG4gICAgICAgICAgICAgICAgb3cgPSB0aGlzLl9pbWFnZVdpZHRoO1xuICAgICAgICAgICAgICAgIG9oID0gdGhpcy5faW1hZ2VIZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpbWFnZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHggPSBzdHlsZS54IHx8IDA7XG4gICAgICAgIHZhciB5ID0gc3R5bGUueSB8fCAwO1xuXG4gICAgICAgIHZhciBkdyA9IHN0eWxlLndpZHRoO1xuICAgICAgICB2YXIgZGggPSBzdHlsZS5oZWlnaHQ7XG5cbiAgICAgICAgdmFyIHN3ID0gc3R5bGUuc1dpZHRoO1xuICAgICAgICB2YXIgc2ggPSBzdHlsZS5zSGVpZ2h0O1xuICAgICAgICB2YXIgc3ggPSBzdHlsZS5zeCB8fCAwO1xuICAgICAgICB2YXIgc3kgPSBzdHlsZS5zeSB8fCAwO1xuXG4gICAgICAgIHZhciBoYXNDcm9wID0gc3cgJiYgc2g7XG5cbiAgICAgICAgdmFyIHZtbEVsID0gdGhpcy5fdm1sRWw7XG4gICAgICAgIGlmICghdm1sRWwpIHtcbiAgICAgICAgICAgIC8vIEZJWE1FIOS9v+eUqCBncm91cCDlnKggbGVmdCwgdG9wIOmDveS4jeaYryAwIOeahOaXtuWAmeWwseaXoOazleaYvuekuuS6huOAglxuICAgICAgICAgICAgLy8gdm1sRWwgPSB2bWxDb3JlLmNyZWF0ZU5vZGUoJ2dyb3VwJyk7XG4gICAgICAgICAgICB2bWxFbCA9IHZtbENvcmUuZG9jLmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgaW5pdFJvb3RFbFN0eWxlKHZtbEVsKTtcblxuICAgICAgICAgICAgdGhpcy5fdm1sRWwgPSB2bWxFbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB2bWxFbFN0eWxlID0gdm1sRWwuc3R5bGU7XG4gICAgICAgIHZhciBoYXNSb3RhdGlvbiA9IGZhbHNlO1xuICAgICAgICB2YXIgbTtcbiAgICAgICAgdmFyIHNjYWxlWCA9IDE7XG4gICAgICAgIHZhciBzY2FsZVkgPSAxO1xuICAgICAgICBpZiAodGhpcy50cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIG0gPSB0aGlzLnRyYW5zZm9ybTtcbiAgICAgICAgICAgIHNjYWxlWCA9IHNxcnQobVswXSAqIG1bMF0gKyBtWzFdICogbVsxXSk7XG4gICAgICAgICAgICBzY2FsZVkgPSBzcXJ0KG1bMl0gKiBtWzJdICsgbVszXSAqIG1bM10pO1xuXG4gICAgICAgICAgICBoYXNSb3RhdGlvbiA9IG1bMV0gfHwgbVsyXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzUm90YXRpb24pIHtcbiAgICAgICAgICAgIC8vIElmIGZpbHRlcnMgYXJlIG5lY2Vzc2FyeSAocm90YXRpb24gZXhpc3RzKSwgY3JlYXRlIHRoZW1cbiAgICAgICAgICAgIC8vIGZpbHRlcnMgYXJlIGJvZy1zbG93LCBzbyBvbmx5IGNyZWF0ZSB0aGVtIGlmIGFiYnNvbHV0ZWx5IG5lY2Vzc2FyeVxuICAgICAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBjaGVjayBkb2Vzbid0IGFjY291bnQgZm9yIHNrZXdzICh3aGljaCBkb24ndCBleGlzdFxuICAgICAgICAgICAgLy8gaW4gdGhlIGNhbnZhcyBzcGVjICh5ZXQpIGFueXdheS5cbiAgICAgICAgICAgIC8vIEZyb20gZXhjYW52YXNcbiAgICAgICAgICAgIHZhciBwMCA9IFt4LCB5XTtcbiAgICAgICAgICAgIHZhciBwMSA9IFt4ICsgZHcsIHldO1xuICAgICAgICAgICAgdmFyIHAyID0gW3gsIHkgKyBkaF07XG4gICAgICAgICAgICB2YXIgcDMgPSBbeCArIGR3LCB5ICsgZGhdO1xuICAgICAgICAgICAgYXBwbHlUcmFuc2Zvcm0ocDAsIHAwLCBtKTtcbiAgICAgICAgICAgIGFwcGx5VHJhbnNmb3JtKHAxLCBwMSwgbSk7XG4gICAgICAgICAgICBhcHBseVRyYW5zZm9ybShwMiwgcDIsIG0pO1xuICAgICAgICAgICAgYXBwbHlUcmFuc2Zvcm0ocDMsIHAzLCBtKTtcblxuICAgICAgICAgICAgdmFyIG1heFggPSBtYXRoTWF4KHAwWzBdLCBwMVswXSwgcDJbMF0sIHAzWzBdKTtcbiAgICAgICAgICAgIHZhciBtYXhZID0gbWF0aE1heChwMFsxXSwgcDFbMV0sIHAyWzFdLCBwM1sxXSk7XG5cbiAgICAgICAgICAgIHZhciB0cmFuc2Zvcm1GaWx0ZXIgPSBbXTtcbiAgICAgICAgICAgIHRyYW5zZm9ybUZpbHRlci5wdXNoKCdNMTE9JywgbVswXSAvIHNjYWxlWCwgY29tbWEsXG4gICAgICAgICAgICAgICAgICAgICAgICAnTTEyPScsIG1bMl0gLyBzY2FsZVksIGNvbW1hLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ00yMT0nLCBtWzFdIC8gc2NhbGVYLCBjb21tYSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdNMjI9JywgbVszXSAvIHNjYWxlWSwgY29tbWEsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRHg9Jywgcm91bmQoeCAqIHNjYWxlWCArIG1bNF0pLCBjb21tYSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdEeT0nLCByb3VuZCh5ICogc2NhbGVZICsgbVs1XSkpO1xuXG4gICAgICAgICAgICB2bWxFbFN0eWxlLnBhZGRpbmcgPSAnMCAnICsgcm91bmQobWF4WCkgKyAncHggJyArIHJvdW5kKG1heFkpICsgJ3B4IDAnO1xuICAgICAgICAgICAgLy8gRklYTUUgRFhJbWFnZVRyYW5zZm9ybSDlnKggSUUxMSDnmoTlhbzlrrnmqKHlvI/kuIvkuI3otbfkvZznlKhcbiAgICAgICAgICAgIHZtbEVsU3R5bGUuZmlsdGVyID0gaW1hZ2VUcmFuc2Zvcm1QcmVmaXggKyAnLk1hdHJpeCgnXG4gICAgICAgICAgICAgICAgKyB0cmFuc2Zvcm1GaWx0ZXIuam9pbignJykgKyAnLCBTaXppbmdNZXRob2Q9Y2xpcCknO1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgICAgIHggPSB4ICogc2NhbGVYICsgbVs0XTtcbiAgICAgICAgICAgICAgICB5ID0geSAqIHNjYWxlWSArIG1bNV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2bWxFbFN0eWxlLmZpbHRlciA9ICcnO1xuICAgICAgICAgICAgdm1sRWxTdHlsZS5sZWZ0ID0gcm91bmQoeCkgKyAncHgnO1xuICAgICAgICAgICAgdm1sRWxTdHlsZS50b3AgPSByb3VuZCh5KSArICdweCc7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaW1hZ2VFbCA9IHRoaXMuX2ltYWdlRWw7XG4gICAgICAgIHZhciBjcm9wRWwgPSB0aGlzLl9jcm9wRWw7XG5cbiAgICAgICAgaWYgKCFpbWFnZUVsKSB7XG4gICAgICAgICAgICBpbWFnZUVsID0gdm1sQ29yZS5kb2MuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICB0aGlzLl9pbWFnZUVsID0gaW1hZ2VFbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW1hZ2VFTFN0eWxlID0gaW1hZ2VFbC5zdHlsZTtcbiAgICAgICAgaWYgKGhhc0Nyb3ApIHtcbiAgICAgICAgICAgIC8vIE5lZWRzIGtub3cgaW1hZ2Ugb3JpZ2luYWwgd2lkdGggYW5kIGhlaWdodFxuICAgICAgICAgICAgaWYgKCEgKG93ICYmIG9oKSkge1xuICAgICAgICAgICAgICAgIHZhciB0bXBJbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICB0bXBJbWFnZS5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRtcEltYWdlLm9ubG9hZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIG93ID0gdG1wSW1hZ2Uud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIG9oID0gdG1wSW1hZ2UuaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAvLyBBZGp1c3QgaW1hZ2Ugd2lkdGggYW5kIGhlaWdodCB0byBmaXQgdGhlIHJhdGlvIGRlc3RpbmF0aW9uU2l6ZSAvIHNvdXJjZVNpemVcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VFTFN0eWxlLndpZHRoID0gcm91bmQoc2NhbGVYICogb3cgKiBkdyAvIHN3KSArICdweCc7XG4gICAgICAgICAgICAgICAgICAgIGltYWdlRUxTdHlsZS5oZWlnaHQgPSByb3VuZChzY2FsZVkgKiBvaCAqIGRoIC8gc2gpICsgJ3B4JztcblxuICAgICAgICAgICAgICAgICAgICAvLyBDYWNoaW5nIGltYWdlIG9yaWdpbmFsIHdpZHRoLCBoZWlnaHQgYW5kIHNyY1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl9pbWFnZVdpZHRoID0gb3c7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX2ltYWdlSGVpZ2h0ID0gb2g7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX2ltYWdlU3JjID0gaW1hZ2U7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0bXBJbWFnZS5zcmMgPSBpbWFnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGltYWdlRUxTdHlsZS53aWR0aCA9IHJvdW5kKHNjYWxlWCAqIG93ICogZHcgLyBzdykgKyAncHgnO1xuICAgICAgICAgICAgICAgIGltYWdlRUxTdHlsZS5oZWlnaHQgPSByb3VuZChzY2FsZVkgKiBvaCAqIGRoIC8gc2gpICsgJ3B4JztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCEgY3JvcEVsKSB7XG4gICAgICAgICAgICAgICAgY3JvcEVsID0gdm1sQ29yZS5kb2MuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICAgICAgY3JvcEVsLnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG4gICAgICAgICAgICAgICAgdGhpcy5fY3JvcEVsID0gY3JvcEVsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNyb3BFbFN0eWxlID0gY3JvcEVsLnN0eWxlO1xuICAgICAgICAgICAgY3JvcEVsU3R5bGUud2lkdGggPSByb3VuZCgoZHcgKyBzeCAqIGR3IC8gc3cpICogc2NhbGVYKTtcbiAgICAgICAgICAgIGNyb3BFbFN0eWxlLmhlaWdodCA9IHJvdW5kKChkaCArIHN5ICogZGggLyBzaCkgKiBzY2FsZVkpO1xuICAgICAgICAgICAgY3JvcEVsU3R5bGUuZmlsdGVyID0gaW1hZ2VUcmFuc2Zvcm1QcmVmaXggKyAnLk1hdHJpeChEeD0nXG4gICAgICAgICAgICAgICAgICAgICsgKC1zeCAqIGR3IC8gc3cgKiBzY2FsZVgpICsgJyxEeT0nICsgKC1zeSAqIGRoIC8gc2ggKiBzY2FsZVkpICsgJyknO1xuXG4gICAgICAgICAgICBpZiAoISBjcm9wRWwucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgIHZtbEVsLmFwcGVuZENoaWxkKGNyb3BFbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW1hZ2VFbC5wYXJlbnROb2RlICE9IGNyb3BFbCkge1xuICAgICAgICAgICAgICAgIGNyb3BFbC5hcHBlbmRDaGlsZChpbWFnZUVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGltYWdlRUxTdHlsZS53aWR0aCA9IHJvdW5kKHNjYWxlWCAqIGR3KSArICdweCc7XG4gICAgICAgICAgICBpbWFnZUVMU3R5bGUuaGVpZ2h0ID0gcm91bmQoc2NhbGVZICogZGgpICsgJ3B4JztcblxuICAgICAgICAgICAgdm1sRWwuYXBwZW5kQ2hpbGQoaW1hZ2VFbCk7XG5cbiAgICAgICAgICAgIGlmIChjcm9wRWwgJiYgY3JvcEVsLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICB2bWxFbC5yZW1vdmVDaGlsZChjcm9wRWwpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2Nyb3BFbCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZmlsdGVyU3RyID0gJyc7XG4gICAgICAgIHZhciBhbHBoYSA9IHN0eWxlLm9wYWNpdHk7XG4gICAgICAgIGlmIChhbHBoYSA8IDEpIHtcbiAgICAgICAgICAgIGZpbHRlclN0ciArPSAnLkFscGhhKG9wYWNpdHk9JyArIHJvdW5kKGFscGhhICogMTAwKSArICcpICc7XG4gICAgICAgIH1cbiAgICAgICAgZmlsdGVyU3RyICs9IGltYWdlVHJhbnNmb3JtUHJlZml4ICsgJy5BbHBoYUltYWdlTG9hZGVyKHNyYz0nICsgaW1hZ2UgKyAnLCBTaXppbmdNZXRob2Q9c2NhbGUpJztcblxuICAgICAgICBpbWFnZUVMU3R5bGUuZmlsdGVyID0gZmlsdGVyU3RyO1xuXG4gICAgICAgIHZtbEVsLnN0eWxlLnpJbmRleCA9IGdldFpJbmRleCh0aGlzLnpsZXZlbCwgdGhpcy56LCB0aGlzLnoyKTtcblxuICAgICAgICAvLyBBcHBlbmQgdG8gcm9vdFxuICAgICAgICBhcHBlbmQodm1sUm9vdCwgdm1sRWwpO1xuXG4gICAgICAgIC8vIFRleHRcbiAgICAgICAgaWYgKHN0eWxlLnRleHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5kcmF3UmVjdFRleHQodm1sUm9vdCwgdGhpcy5nZXRCb3VuZGluZ1JlY3QoKSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgWkltYWdlLnByb3RvdHlwZS5vblJlbW92ZSA9IGZ1bmN0aW9uICh2bWxSb290KSB7XG4gICAgICAgIHJlbW92ZSh2bWxSb290LCB0aGlzLl92bWxFbCk7XG5cbiAgICAgICAgdGhpcy5fdm1sRWwgPSBudWxsO1xuICAgICAgICB0aGlzLl9jcm9wRWwgPSBudWxsO1xuICAgICAgICB0aGlzLl9pbWFnZUVsID0gbnVsbDtcblxuICAgICAgICB0aGlzLnJlbW92ZVJlY3RUZXh0KHZtbFJvb3QpO1xuICAgIH07XG5cbiAgICBaSW1hZ2UucHJvdG90eXBlLm9uQWRkID0gZnVuY3Rpb24gKHZtbFJvb3QpIHtcbiAgICAgICAgYXBwZW5kKHZtbFJvb3QsIHRoaXMuX3ZtbEVsKTtcbiAgICAgICAgdGhpcy5hcHBlbmRSZWN0VGV4dCh2bWxSb290KTtcbiAgICB9O1xuXG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICogVEVYVFxuICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgIHZhciBERUZBVUxUX1NUWUxFX05PUk1BTCA9ICdub3JtYWwnO1xuXG4gICAgdmFyIGZvbnRTdHlsZUNhY2hlID0ge307XG4gICAgdmFyIGZvbnRTdHlsZUNhY2hlQ291bnQgPSAwO1xuICAgIHZhciBNQVhfRk9OVF9DQUNIRV9TSVpFID0gMTAwO1xuICAgIHZhciBmb250RWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgIHZhciBnZXRGb250U3R5bGUgPSBmdW5jdGlvbiAoZm9udFN0cmluZykge1xuICAgICAgICB2YXIgZm9udFN0eWxlID0gZm9udFN0eWxlQ2FjaGVbZm9udFN0cmluZ107XG4gICAgICAgIGlmICghZm9udFN0eWxlKSB7XG4gICAgICAgICAgICAvLyBDbGVhciBjYWNoZVxuICAgICAgICAgICAgaWYgKGZvbnRTdHlsZUNhY2hlQ291bnQgPiBNQVhfRk9OVF9DQUNIRV9TSVpFKSB7XG4gICAgICAgICAgICAgICAgZm9udFN0eWxlQ2FjaGVDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgZm9udFN0eWxlQ2FjaGUgPSB7fTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHN0eWxlID0gZm9udEVsLnN0eWxlO1xuICAgICAgICAgICAgdmFyIGZvbnRGYW1pbHk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHN0eWxlLmZvbnQgPSBmb250U3RyaW5nO1xuICAgICAgICAgICAgICAgIGZvbnRGYW1pbHkgPSBzdHlsZS5mb250RmFtaWx5LnNwbGl0KCcsJylbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb250U3R5bGUgPSB7XG4gICAgICAgICAgICAgICAgc3R5bGU6IHN0eWxlLmZvbnRTdHlsZSB8fCBERUZBVUxUX1NUWUxFX05PUk1BTCxcbiAgICAgICAgICAgICAgICB2YXJpYW50OiBzdHlsZS5mb250VmFyaWFudCB8fCBERUZBVUxUX1NUWUxFX05PUk1BTCxcbiAgICAgICAgICAgICAgICB3ZWlnaHQ6IHN0eWxlLmZvbnRXZWlnaHQgfHwgREVGQVVMVF9TVFlMRV9OT1JNQUwsXG4gICAgICAgICAgICAgICAgc2l6ZTogcGFyc2VGbG9hdChzdHlsZS5mb250U2l6ZSB8fCAxMikgfCAwLFxuICAgICAgICAgICAgICAgIGZhbWlseTogZm9udEZhbWlseSB8fCAnTWljcm9zb2Z0IFlhSGVpJ1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgZm9udFN0eWxlQ2FjaGVbZm9udFN0cmluZ10gPSBmb250U3R5bGU7XG4gICAgICAgICAgICBmb250U3R5bGVDYWNoZUNvdW50Kys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvbnRTdHlsZTtcbiAgICB9O1xuXG4gICAgdmFyIHRleHRNZWFzdXJlRWw7XG4gICAgLy8gT3ZlcndyaXRlIG1lYXN1cmUgdGV4dCBtZXRob2RcbiAgICB0ZXh0Q29udGFpbi5tZWFzdXJlVGV4dCA9IGZ1bmN0aW9uICh0ZXh0LCB0ZXh0Rm9udCkge1xuICAgICAgICB2YXIgZG9jID0gdm1sQ29yZS5kb2M7XG4gICAgICAgIGlmICghdGV4dE1lYXN1cmVFbCkge1xuICAgICAgICAgICAgdGV4dE1lYXN1cmVFbCA9IGRvYy5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIHRleHRNZWFzdXJlRWwuc3R5bGUuY3NzVGV4dCA9ICdwb3NpdGlvbjphYnNvbHV0ZTt0b3A6LTIwMDAwcHg7bGVmdDowOydcbiAgICAgICAgICAgICAgICArICdwYWRkaW5nOjA7bWFyZ2luOjA7Ym9yZGVyOm5vbmU7d2hpdGUtc3BhY2U6cHJlOyc7XG4gICAgICAgICAgICB2bWxDb3JlLmRvYy5ib2R5LmFwcGVuZENoaWxkKHRleHRNZWFzdXJlRWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRleHRNZWFzdXJlRWwuc3R5bGUuZm9udCA9IHRleHRGb250O1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICAgLy8gSWdub3JlIGZhaWx1cmVzIHRvIHNldCB0byBpbnZhbGlkIGZvbnQuXG4gICAgICAgIH1cbiAgICAgICAgdGV4dE1lYXN1cmVFbC5pbm5lckhUTUwgPSAnJztcbiAgICAgICAgLy8gRG9uJ3QgdXNlIGlubmVySFRNTCBvciBpbm5lclRleHQgYmVjYXVzZSB0aGV5IGFsbG93IG1hcmt1cC93aGl0ZXNwYWNlLlxuICAgICAgICB0ZXh0TWVhc3VyZUVsLmFwcGVuZENoaWxkKGRvYy5jcmVhdGVUZXh0Tm9kZSh0ZXh0KSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3aWR0aDogdGV4dE1lYXN1cmVFbC5vZmZzZXRXaWR0aFxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgdG1wUmVjdCA9IG5ldyBCb3VuZGluZ1JlY3QoKTtcblxuICAgIHZhciBkcmF3UmVjdFRleHQgPSBmdW5jdGlvbiAodm1sUm9vdCwgcmVjdCwgdGV4dFJlY3QsIGZyb21UZXh0RWwpIHtcblxuICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLnN0eWxlO1xuICAgICAgICB2YXIgdGV4dCA9IHN0eWxlLnRleHQ7XG4gICAgICAgIC8vIENvbnZlcnQgdG8gc3RyaW5nXG4gICAgICAgIHRleHQgIT0gbnVsbCAmJiAodGV4dCArPSAnJyk7XG4gICAgICAgIGlmICghdGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHg7XG4gICAgICAgIHZhciB5O1xuICAgICAgICB2YXIgYWxpZ24gPSBzdHlsZS50ZXh0QWxpZ247XG4gICAgICAgIHZhciBmb250U3R5bGUgPSBnZXRGb250U3R5bGUoc3R5bGUudGV4dEZvbnQpO1xuICAgICAgICAvLyBGSVhNRSBlbmNvZGVIdG1sQXR0cmlidXRlID9cbiAgICAgICAgdmFyIGZvbnQgPSBmb250U3R5bGUuc3R5bGUgKyAnICcgKyBmb250U3R5bGUudmFyaWFudCArICcgJyArIGZvbnRTdHlsZS53ZWlnaHQgKyAnICdcbiAgICAgICAgICAgICsgZm9udFN0eWxlLnNpemUgKyAncHggXCInICsgZm9udFN0eWxlLmZhbWlseSArICdcIic7XG5cbiAgICAgICAgdmFyIGJhc2VsaW5lID0gc3R5bGUudGV4dEJhc2VsaW5lO1xuICAgICAgICB2YXIgdmVydGljYWxBbGlnbiA9IHN0eWxlLnRleHRWZXJ0aWNhbEFsaWduO1xuXG4gICAgICAgIHRleHRSZWN0ID0gdGV4dFJlY3QgfHwgdGV4dENvbnRhaW4uZ2V0Qm91bmRpbmdSZWN0KHRleHQsIGZvbnQsIGFsaWduLCBiYXNlbGluZSk7XG5cbiAgICAgICAgLy8gVHJhbnNmb3JtIHJlY3QgdG8gdmlldyBzcGFjZVxuICAgICAgICB2YXIgbSA9IHRoaXMudHJhbnNmb3JtO1xuICAgICAgICAvLyBJZ25vcmUgdHJhbnNmb3JtIGZvciB0ZXh0IGluIG90aGVyIGVsZW1lbnRcbiAgICAgICAgaWYgKG0gJiYgIWZyb21UZXh0RWwpIHtcbiAgICAgICAgICAgIHRtcFJlY3QuY29weShyZWN0KTtcbiAgICAgICAgICAgIHRtcFJlY3QuYXBwbHlUcmFuc2Zvcm0obSk7XG4gICAgICAgICAgICByZWN0ID0gdG1wUmVjdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZnJvbVRleHRFbCkge1xuICAgICAgICAgICAgdmFyIHRleHRQb3NpdGlvbiA9IHN0eWxlLnRleHRQb3NpdGlvbjtcbiAgICAgICAgICAgIHZhciBkaXN0YW5jZSA9IHN0eWxlLnRleHREaXN0YW5jZTtcbiAgICAgICAgICAgIC8vIFRleHQgcG9zaXRpb24gcmVwcmVzZW50ZWQgYnkgY29vcmRcbiAgICAgICAgICAgIGlmICh0ZXh0UG9zaXRpb24gaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgIHggPSByZWN0LnggKyBwYXJzZVBlcmNlbnQodGV4dFBvc2l0aW9uWzBdLCByZWN0LndpZHRoKTtcbiAgICAgICAgICAgICAgICB5ID0gcmVjdC55ICsgcGFyc2VQZXJjZW50KHRleHRQb3NpdGlvblsxXSwgcmVjdC5oZWlnaHQpO1xuXG4gICAgICAgICAgICAgICAgYWxpZ24gPSBhbGlnbiB8fCAnbGVmdCc7XG4gICAgICAgICAgICAgICAgYmFzZWxpbmUgPSBiYXNlbGluZSB8fCAndG9wJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciByZXMgPSB0ZXh0Q29udGFpbi5hZGp1c3RUZXh0UG9zaXRpb25PblJlY3QoXG4gICAgICAgICAgICAgICAgICAgIHRleHRQb3NpdGlvbiwgcmVjdCwgdGV4dFJlY3QsIGRpc3RhbmNlXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB4ID0gcmVzLng7XG4gICAgICAgICAgICAgICAgeSA9IHJlcy55O1xuXG4gICAgICAgICAgICAgICAgLy8gRGVmYXVsdCBhbGlnbiBhbmQgYmFzZWxpbmUgd2hlbiBoYXMgdGV4dFBvc2l0aW9uXG4gICAgICAgICAgICAgICAgYWxpZ24gPSBhbGlnbiB8fCByZXMudGV4dEFsaWduO1xuICAgICAgICAgICAgICAgIGJhc2VsaW5lID0gYmFzZWxpbmUgfHwgcmVzLnRleHRCYXNlbGluZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHggPSByZWN0Lng7XG4gICAgICAgICAgICB5ID0gcmVjdC55O1xuICAgICAgICB9XG4gICAgICAgIGlmICh2ZXJ0aWNhbEFsaWduKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHZlcnRpY2FsQWxpZ24pIHtcbiAgICAgICAgICAgICAgICBjYXNlICdtaWRkbGUnOlxuICAgICAgICAgICAgICAgICAgICB5IC09IHRleHRSZWN0LmhlaWdodCAvIDI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICAgICAgICAgIHkgLT0gdGV4dFJlY3QuaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAvLyAndG9wJ1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWdub3JlIGJhc2VsaW5lXG4gICAgICAgICAgICBiYXNlbGluZSA9ICd0b3AnO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGZvbnRTaXplID0gZm9udFN0eWxlLnNpemU7XG4gICAgICAgIC8vIDEuNzUgaXMgYW4gYXJiaXRyYXJ5IG51bWJlciwgYXMgdGhlcmUgaXMgbm8gaW5mbyBhYm91dCB0aGUgdGV4dCBiYXNlbGluZVxuICAgICAgICBzd2l0Y2ggKGJhc2VsaW5lKSB7XG4gICAgICAgICAgICBjYXNlICdoYW5naW5nJzpcbiAgICAgICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICAgICAgeSArPSBmb250U2l6ZSAvIDEuNzU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtaWRkbGUnOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIC8vIGNhc2UgbnVsbDpcbiAgICAgICAgICAgIC8vIGNhc2UgJ2FscGhhYmV0aWMnOlxuICAgICAgICAgICAgLy8gY2FzZSAnaWRlb2dyYXBoaWMnOlxuICAgICAgICAgICAgLy8gY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgICAgICB5IC09IGZvbnRTaXplIC8gMi4yNTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGFsaWduKSB7XG4gICAgICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgICAgICAgICAgeCAtPSB0ZXh0UmVjdC53aWR0aCAvIDI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICAgICAgeCAtPSB0ZXh0UmVjdC53aWR0aDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8vIGNhc2UgJ2VuZCc6XG4gICAgICAgICAgICAgICAgLy8gYWxpZ24gPSBlbGVtZW50U3R5bGUuZGlyZWN0aW9uID09ICdsdHInID8gJ3JpZ2h0JyA6ICdsZWZ0JztcbiAgICAgICAgICAgICAgICAvLyBicmVhaztcbiAgICAgICAgICAgIC8vIGNhc2UgJ3N0YXJ0JzpcbiAgICAgICAgICAgICAgICAvLyBhbGlnbiA9IGVsZW1lbnRTdHlsZS5kaXJlY3Rpb24gPT0gJ3J0bCcgPyAncmlnaHQnIDogJ2xlZnQnO1xuICAgICAgICAgICAgICAgIC8vIGJyZWFrO1xuICAgICAgICAgICAgLy8gZGVmYXVsdDpcbiAgICAgICAgICAgIC8vICAgICBhbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjcmVhdGVOb2RlID0gdm1sQ29yZS5jcmVhdGVOb2RlO1xuXG4gICAgICAgIHZhciB0ZXh0Vm1sRWwgPSB0aGlzLl90ZXh0Vm1sRWw7XG4gICAgICAgIHZhciBwYXRoRWw7XG4gICAgICAgIHZhciB0ZXh0UGF0aEVsO1xuICAgICAgICB2YXIgc2tld0VsO1xuICAgICAgICBpZiAoIXRleHRWbWxFbCkge1xuICAgICAgICAgICAgdGV4dFZtbEVsID0gY3JlYXRlTm9kZSgnbGluZScpO1xuICAgICAgICAgICAgcGF0aEVsID0gY3JlYXRlTm9kZSgncGF0aCcpO1xuICAgICAgICAgICAgdGV4dFBhdGhFbCA9IGNyZWF0ZU5vZGUoJ3RleHRwYXRoJyk7XG4gICAgICAgICAgICBza2V3RWwgPSBjcmVhdGVOb2RlKCdza2V3Jyk7XG5cbiAgICAgICAgICAgIC8vIEZJWE1FIFdoeSBoZXJlIGlzIG5vdCBjYW1tZWwgY2FzZVxuICAgICAgICAgICAgLy8gQWxpZ24gJ2NlbnRlcicgc2VlbXMgd3JvbmdcbiAgICAgICAgICAgIHRleHRQYXRoRWwuc3R5bGVbJ3YtdGV4dC1hbGlnbiddID0gJ2xlZnQnO1xuXG4gICAgICAgICAgICBpbml0Um9vdEVsU3R5bGUodGV4dFZtbEVsKTtcblxuICAgICAgICAgICAgcGF0aEVsLnRleHRwYXRob2sgPSB0cnVlO1xuICAgICAgICAgICAgdGV4dFBhdGhFbC5vbiA9IHRydWU7XG5cbiAgICAgICAgICAgIHRleHRWbWxFbC5mcm9tID0gJzAgMCc7XG4gICAgICAgICAgICB0ZXh0Vm1sRWwudG8gPSAnMTAwMCAwLjA1JztcblxuICAgICAgICAgICAgYXBwZW5kKHRleHRWbWxFbCwgc2tld0VsKTtcbiAgICAgICAgICAgIGFwcGVuZCh0ZXh0Vm1sRWwsIHBhdGhFbCk7XG4gICAgICAgICAgICBhcHBlbmQodGV4dFZtbEVsLCB0ZXh0UGF0aEVsKTtcblxuICAgICAgICAgICAgdGhpcy5fdGV4dFZtbEVsID0gdGV4dFZtbEVsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8g6L+Z6YeM5piv5Zyo5YmN6Z2iIGFwcGVuZENoaWxkIOS/neivgemhuuW6j+eahOWJjeaPkOS4i1xuICAgICAgICAgICAgc2tld0VsID0gdGV4dFZtbEVsLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICBwYXRoRWwgPSBza2V3RWwubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICB0ZXh0UGF0aEVsID0gcGF0aEVsLm5leHRTaWJsaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvb3JkcyA9IFt4LCB5XTtcbiAgICAgICAgdmFyIHRleHRWbWxFbFN0eWxlID0gdGV4dFZtbEVsLnN0eWxlO1xuICAgICAgICAvLyBJZ25vcmUgdHJhbnNmb3JtIGZvciB0ZXh0IGluIG90aGVyIGVsZW1lbnRcbiAgICAgICAgaWYgKG0gJiYgZnJvbVRleHRFbCkge1xuICAgICAgICAgICAgYXBwbHlUcmFuc2Zvcm0oY29vcmRzLCBjb29yZHMsIG0pO1xuXG4gICAgICAgICAgICBza2V3RWwub24gPSB0cnVlO1xuXG4gICAgICAgICAgICBza2V3RWwubWF0cml4ID0gbVswXS50b0ZpeGVkKDMpICsgY29tbWEgKyBtWzJdLnRvRml4ZWQoMykgKyBjb21tYSArXG4gICAgICAgICAgICBtWzFdLnRvRml4ZWQoMykgKyBjb21tYSArIG1bM10udG9GaXhlZCgzKSArICcsMCwwJztcblxuICAgICAgICAgICAgLy8gVGV4dCBwb3NpdGlvblxuICAgICAgICAgICAgc2tld0VsLm9mZnNldCA9IChyb3VuZChjb29yZHNbMF0pIHx8IDApICsgJywnICsgKHJvdW5kKGNvb3Jkc1sxXSkgfHwgMCk7XG4gICAgICAgICAgICAvLyBMZWZ0IHRvcCBwb2ludCBhcyBvcmlnaW5cbiAgICAgICAgICAgIHNrZXdFbC5vcmlnaW4gPSAnMCAwJztcblxuICAgICAgICAgICAgdGV4dFZtbEVsU3R5bGUubGVmdCA9ICcwcHgnO1xuICAgICAgICAgICAgdGV4dFZtbEVsU3R5bGUudG9wID0gJzBweCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBza2V3RWwub24gPSBmYWxzZTtcbiAgICAgICAgICAgIHRleHRWbWxFbFN0eWxlLmxlZnQgPSByb3VuZCh4KSArICdweCc7XG4gICAgICAgICAgICB0ZXh0Vm1sRWxTdHlsZS50b3AgPSByb3VuZCh5KSArICdweCc7XG4gICAgICAgIH1cblxuICAgICAgICB0ZXh0UGF0aEVsLnN0cmluZyA9IGVuY29kZUh0bWxBdHRyaWJ1dGUodGV4dCk7XG4gICAgICAgIC8vIFRPRE9cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRleHRQYXRoRWwuc3R5bGUuZm9udCA9IGZvbnQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRXJyb3IgZm9udCBmb3JtYXRcbiAgICAgICAgY2F0Y2ggKGUpIHt9XG5cbiAgICAgICAgdXBkYXRlRmlsbEFuZFN0cm9rZSh0ZXh0Vm1sRWwsICdmaWxsJywge1xuICAgICAgICAgICAgZmlsbDogZnJvbVRleHRFbCA/IHN0eWxlLmZpbGwgOiBzdHlsZS50ZXh0RmlsbCxcbiAgICAgICAgICAgIG9wYWNpdHk6IHN0eWxlLm9wYWNpdHlcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIHVwZGF0ZUZpbGxBbmRTdHJva2UodGV4dFZtbEVsLCAnc3Ryb2tlJywge1xuICAgICAgICAgICAgc3Ryb2tlOiBmcm9tVGV4dEVsID8gc3R5bGUuc3Ryb2tlIDogc3R5bGUudGV4dFN0cm9rZSxcbiAgICAgICAgICAgIG9wYWNpdHk6IHN0eWxlLm9wYWNpdHksXG4gICAgICAgICAgICBsaW5lRGFzaDogc3R5bGUubGluZURhc2hcbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgdGV4dFZtbEVsLnN0eWxlLnpJbmRleCA9IGdldFpJbmRleCh0aGlzLnpsZXZlbCwgdGhpcy56LCB0aGlzLnoyKTtcblxuICAgICAgICAvLyBBdHRhY2hlZCB0byByb290XG4gICAgICAgIGFwcGVuZCh2bWxSb290LCB0ZXh0Vm1sRWwpO1xuICAgIH07XG5cbiAgICB2YXIgcmVtb3ZlUmVjdFRleHQgPSBmdW5jdGlvbiAodm1sUm9vdCkge1xuICAgICAgICByZW1vdmUodm1sUm9vdCwgdGhpcy5fdGV4dFZtbEVsKTtcbiAgICAgICAgdGhpcy5fdGV4dFZtbEVsID0gbnVsbDtcbiAgICB9O1xuXG4gICAgdmFyIGFwcGVuZFJlY3RUZXh0ID0gZnVuY3Rpb24gKHZtbFJvb3QpIHtcbiAgICAgICAgYXBwZW5kKHZtbFJvb3QsIHRoaXMuX3RleHRWbWxFbCk7XG4gICAgfTtcblxuICAgIHZhciBsaXN0ID0gW1JlY3RUZXh0LCBEaXNwbGF5YWJsZSwgWkltYWdlLCBQYXRoLCBUZXh0XTtcblxuICAgIC8vIEluIGNhc2UgRGlzcGxheWFibGUgaGFzIGJlZW4gbWl4ZWQgaW4gUmVjdFRleHRcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHByb3RvID0gbGlzdFtpXS5wcm90b3R5cGU7XG4gICAgICAgIHByb3RvLmRyYXdSZWN0VGV4dCA9IGRyYXdSZWN0VGV4dDtcbiAgICAgICAgcHJvdG8ucmVtb3ZlUmVjdFRleHQgPSByZW1vdmVSZWN0VGV4dDtcbiAgICAgICAgcHJvdG8uYXBwZW5kUmVjdFRleHQgPSBhcHBlbmRSZWN0VGV4dDtcbiAgICB9XG5cbiAgICBUZXh0LnByb3RvdHlwZS5icnVzaFZNTCA9IGZ1bmN0aW9uICh2bWxSb290KSB7XG4gICAgICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XG4gICAgICAgIGlmIChzdHlsZS50ZXh0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhd1JlY3RUZXh0KHZtbFJvb3QsIHtcbiAgICAgICAgICAgICAgICB4OiBzdHlsZS54IHx8IDAsIHk6IHN0eWxlLnkgfHwgMCxcbiAgICAgICAgICAgICAgICB3aWR0aDogMCwgaGVpZ2h0OiAwXG4gICAgICAgICAgICB9LCB0aGlzLmdldEJvdW5kaW5nUmVjdCgpLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlUmVjdFRleHQodm1sUm9vdCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgVGV4dC5wcm90b3R5cGUub25SZW1vdmUgPSBmdW5jdGlvbiAodm1sUm9vdCkge1xuICAgICAgICB0aGlzLnJlbW92ZVJlY3RUZXh0KHZtbFJvb3QpO1xuICAgIH07XG5cbiAgICBUZXh0LnByb3RvdHlwZS5vbkFkZCA9IGZ1bmN0aW9uICh2bWxSb290KSB7XG4gICAgICAgIHRoaXMuYXBwZW5kUmVjdFRleHQodm1sUm9vdCk7XG4gICAgfTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9ob21lL3l4L34venJlbmRlci9saWIvdm1sL2dyYXBoaWMuanNcbi8vIG1vZHVsZSBpZCA9IDIwMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 202 */
/* unknown exports provided */
/* all exports used */
/*!*********************************************!*\
  !*** ./lib/chart/helper/LargeSymbolDraw.js ***!
  \*********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("// TODO Batch by color\n\n\n\n    var graphic = __webpack_require__(/*! ../../util/graphic */ 2);\n    var symbolUtil = __webpack_require__(/*! ../../util/symbol */ 23);\n\n    var LargeSymbolPath = graphic.extendShape({\n\n        shape: {\n            points: null,\n            sizes: null\n        },\n\n        symbolProxy: null,\n\n        buildPath: function (path, shape) {\n            var points = shape.points;\n            var sizes = shape.sizes;\n\n            var symbolProxy = this.symbolProxy;\n            var symbolProxyShape = symbolProxy.shape;\n            for (var i = 0; i < points.length; i++) {\n                var pt = points[i];\n                var size = sizes[i];\n                if (size[0] < 4) {\n                    // Optimize for small symbol\n                    path.rect(\n                        pt[0] - size[0] / 2, pt[1] - size[1] / 2,\n                        size[0], size[1]\n                    );\n                }\n                else {\n                    symbolProxyShape.x = pt[0] - size[0] / 2;\n                    symbolProxyShape.y = pt[1] - size[1] / 2;\n                    symbolProxyShape.width = size[0];\n                    symbolProxyShape.height = size[1];\n\n                    symbolProxy.buildPath(path, symbolProxyShape, true);\n                }\n            }\n        },\n\n        findDataIndex: function (x, y) {\n            var shape = this.shape;\n            var points = shape.points;\n            var sizes = shape.sizes;\n\n            // Not consider transform\n            // Treat each element as a rect\n            // top down traverse\n            for (var i = points.length - 1; i >= 0; i--) {\n                var pt = points[i];\n                var size = sizes[i];\n                var x0 = pt[0] - size[0] / 2;\n                var y0 = pt[1] - size[1] / 2;\n                if (x >= x0 && y >= y0 && x <= x0 + size[0] && y <= y0 + size[1]) {\n                    // i is dataIndex\n                    return i;\n                }\n            }\n\n            return -1;\n        }\n    });\n\n    function LargeSymbolDraw() {\n        this.group = new graphic.Group();\n\n        this._symbolEl = new LargeSymbolPath({\n            // rectHover: true,\n            // cursor: 'default'\n        });\n    }\n\n    var largeSymbolProto = LargeSymbolDraw.prototype;\n\n    /**\n     * Update symbols draw by new data\n     * @param {module:echarts/data/List} data\n     */\n    largeSymbolProto.updateData = function (data) {\n        this.group.removeAll();\n\n        var symbolEl = this._symbolEl;\n\n        var seriesModel = data.hostModel;\n\n        symbolEl.setShape({\n            points: data.mapArray(data.getItemLayout),\n            sizes: data.mapArray(\n                function (idx) {\n                    var size = data.getItemVisual(idx, 'symbolSize');\n                    if (!(size instanceof Array)) {\n                        size = [size, size];\n                    }\n                    return size;\n                }\n            )\n        });\n\n        // Create symbolProxy to build path for each data\n        symbolEl.symbolProxy = symbolUtil.createSymbol(\n            data.getVisual('symbol'), 0, 0, 0, 0\n        );\n        // Use symbolProxy setColor method\n        symbolEl.setColor = symbolEl.symbolProxy.setColor;\n\n        symbolEl.useStyle(\n            seriesModel.getModel('itemStyle.normal').getItemStyle(['color'])\n        );\n\n        var visualColor = data.getVisual('color');\n        if (visualColor) {\n            symbolEl.setColor(visualColor);\n        }\n\n        // Enable tooltip\n        // PENDING May have performance issue when path is extremely large\n        symbolEl.seriesIndex = seriesModel.seriesIndex;\n        symbolEl.on('mousemove', function (e) {\n            symbolEl.dataIndex = null;\n            var dataIndex = symbolEl.findDataIndex(e.offsetX, e.offsetY);\n            if (dataIndex > 0) {\n                // Provide dataIndex for tooltip\n                symbolEl.dataIndex = dataIndex;\n            }\n        });\n\n        // Add back\n        this.group.add(symbolEl);\n    };\n\n    largeSymbolProto.updateLayout = function (seriesModel) {\n        var data = seriesModel.getData();\n        this._symbolEl.setShape({\n            points: data.mapArray(data.getItemLayout)\n        });\n    };\n\n    largeSymbolProto.remove = function () {\n        this.group.removeAll();\n    };\n\n    module.exports = LargeSymbolDraw;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjAyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2NoYXJ0L2hlbHBlci9MYXJnZVN5bWJvbERyYXcuanM/YTk0YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUT0RPIEJhdGNoIGJ5IGNvbG9yXG5cblxuXG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKCcuLi8uLi91dGlsL2dyYXBoaWMnKTtcbiAgICB2YXIgc3ltYm9sVXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvc3ltYm9sJyk7XG5cbiAgICB2YXIgTGFyZ2VTeW1ib2xQYXRoID0gZ3JhcGhpYy5leHRlbmRTaGFwZSh7XG5cbiAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgIHBvaW50czogbnVsbCxcbiAgICAgICAgICAgIHNpemVzOiBudWxsXG4gICAgICAgIH0sXG5cbiAgICAgICAgc3ltYm9sUHJveHk6IG51bGwsXG5cbiAgICAgICAgYnVpbGRQYXRoOiBmdW5jdGlvbiAocGF0aCwgc2hhcGUpIHtcbiAgICAgICAgICAgIHZhciBwb2ludHMgPSBzaGFwZS5wb2ludHM7XG4gICAgICAgICAgICB2YXIgc2l6ZXMgPSBzaGFwZS5zaXplcztcblxuICAgICAgICAgICAgdmFyIHN5bWJvbFByb3h5ID0gdGhpcy5zeW1ib2xQcm94eTtcbiAgICAgICAgICAgIHZhciBzeW1ib2xQcm94eVNoYXBlID0gc3ltYm9sUHJveHkuc2hhcGU7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBwdCA9IHBvaW50c1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgc2l6ZSA9IHNpemVzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChzaXplWzBdIDwgNCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBPcHRpbWl6ZSBmb3Igc21hbGwgc3ltYm9sXG4gICAgICAgICAgICAgICAgICAgIHBhdGgucmVjdChcbiAgICAgICAgICAgICAgICAgICAgICAgIHB0WzBdIC0gc2l6ZVswXSAvIDIsIHB0WzFdIC0gc2l6ZVsxXSAvIDIsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplWzBdLCBzaXplWzFdXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzeW1ib2xQcm94eVNoYXBlLnggPSBwdFswXSAtIHNpemVbMF0gLyAyO1xuICAgICAgICAgICAgICAgICAgICBzeW1ib2xQcm94eVNoYXBlLnkgPSBwdFsxXSAtIHNpemVbMV0gLyAyO1xuICAgICAgICAgICAgICAgICAgICBzeW1ib2xQcm94eVNoYXBlLndpZHRoID0gc2l6ZVswXTtcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sUHJveHlTaGFwZS5oZWlnaHQgPSBzaXplWzFdO1xuXG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbFByb3h5LmJ1aWxkUGF0aChwYXRoLCBzeW1ib2xQcm94eVNoYXBlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluZERhdGFJbmRleDogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgIHZhciBzaGFwZSA9IHRoaXMuc2hhcGU7XG4gICAgICAgICAgICB2YXIgcG9pbnRzID0gc2hhcGUucG9pbnRzO1xuICAgICAgICAgICAgdmFyIHNpemVzID0gc2hhcGUuc2l6ZXM7XG5cbiAgICAgICAgICAgIC8vIE5vdCBjb25zaWRlciB0cmFuc2Zvcm1cbiAgICAgICAgICAgIC8vIFRyZWF0IGVhY2ggZWxlbWVudCBhcyBhIHJlY3RcbiAgICAgICAgICAgIC8vIHRvcCBkb3duIHRyYXZlcnNlXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gcG9pbnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgdmFyIHB0ID0gcG9pbnRzW2ldO1xuICAgICAgICAgICAgICAgIHZhciBzaXplID0gc2l6ZXNbaV07XG4gICAgICAgICAgICAgICAgdmFyIHgwID0gcHRbMF0gLSBzaXplWzBdIC8gMjtcbiAgICAgICAgICAgICAgICB2YXIgeTAgPSBwdFsxXSAtIHNpemVbMV0gLyAyO1xuICAgICAgICAgICAgICAgIGlmICh4ID49IHgwICYmIHkgPj0geTAgJiYgeCA8PSB4MCArIHNpemVbMF0gJiYgeSA8PSB5MCArIHNpemVbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaSBpcyBkYXRhSW5kZXhcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIExhcmdlU3ltYm9sRHJhdygpIHtcbiAgICAgICAgdGhpcy5ncm91cCA9IG5ldyBncmFwaGljLkdyb3VwKCk7XG5cbiAgICAgICAgdGhpcy5fc3ltYm9sRWwgPSBuZXcgTGFyZ2VTeW1ib2xQYXRoKHtcbiAgICAgICAgICAgIC8vIHJlY3RIb3ZlcjogdHJ1ZSxcbiAgICAgICAgICAgIC8vIGN1cnNvcjogJ2RlZmF1bHQnXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBsYXJnZVN5bWJvbFByb3RvID0gTGFyZ2VTeW1ib2xEcmF3LnByb3RvdHlwZTtcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBzeW1ib2xzIGRyYXcgYnkgbmV3IGRhdGFcbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2RhdGEvTGlzdH0gZGF0YVxuICAgICAqL1xuICAgIGxhcmdlU3ltYm9sUHJvdG8udXBkYXRlRGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHRoaXMuZ3JvdXAucmVtb3ZlQWxsKCk7XG5cbiAgICAgICAgdmFyIHN5bWJvbEVsID0gdGhpcy5fc3ltYm9sRWw7XG5cbiAgICAgICAgdmFyIHNlcmllc01vZGVsID0gZGF0YS5ob3N0TW9kZWw7XG5cbiAgICAgICAgc3ltYm9sRWwuc2V0U2hhcGUoe1xuICAgICAgICAgICAgcG9pbnRzOiBkYXRhLm1hcEFycmF5KGRhdGEuZ2V0SXRlbUxheW91dCksXG4gICAgICAgICAgICBzaXplczogZGF0YS5tYXBBcnJheShcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoaWR4KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzaXplID0gZGF0YS5nZXRJdGVtVmlzdWFsKGlkeCwgJ3N5bWJvbFNpemUnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoc2l6ZSBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZSA9IFtzaXplLCBzaXplXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2l6ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIENyZWF0ZSBzeW1ib2xQcm94eSB0byBidWlsZCBwYXRoIGZvciBlYWNoIGRhdGFcbiAgICAgICAgc3ltYm9sRWwuc3ltYm9sUHJveHkgPSBzeW1ib2xVdGlsLmNyZWF0ZVN5bWJvbChcbiAgICAgICAgICAgIGRhdGEuZ2V0VmlzdWFsKCdzeW1ib2wnKSwgMCwgMCwgMCwgMFxuICAgICAgICApO1xuICAgICAgICAvLyBVc2Ugc3ltYm9sUHJveHkgc2V0Q29sb3IgbWV0aG9kXG4gICAgICAgIHN5bWJvbEVsLnNldENvbG9yID0gc3ltYm9sRWwuc3ltYm9sUHJveHkuc2V0Q29sb3I7XG5cbiAgICAgICAgc3ltYm9sRWwudXNlU3R5bGUoXG4gICAgICAgICAgICBzZXJpZXNNb2RlbC5nZXRNb2RlbCgnaXRlbVN0eWxlLm5vcm1hbCcpLmdldEl0ZW1TdHlsZShbJ2NvbG9yJ10pXG4gICAgICAgICk7XG5cbiAgICAgICAgdmFyIHZpc3VhbENvbG9yID0gZGF0YS5nZXRWaXN1YWwoJ2NvbG9yJyk7XG4gICAgICAgIGlmICh2aXN1YWxDb2xvcikge1xuICAgICAgICAgICAgc3ltYm9sRWwuc2V0Q29sb3IodmlzdWFsQ29sb3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRW5hYmxlIHRvb2x0aXBcbiAgICAgICAgLy8gUEVORElORyBNYXkgaGF2ZSBwZXJmb3JtYW5jZSBpc3N1ZSB3aGVuIHBhdGggaXMgZXh0cmVtZWx5IGxhcmdlXG4gICAgICAgIHN5bWJvbEVsLnNlcmllc0luZGV4ID0gc2VyaWVzTW9kZWwuc2VyaWVzSW5kZXg7XG4gICAgICAgIHN5bWJvbEVsLm9uKCdtb3VzZW1vdmUnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgc3ltYm9sRWwuZGF0YUluZGV4ID0gbnVsbDtcbiAgICAgICAgICAgIHZhciBkYXRhSW5kZXggPSBzeW1ib2xFbC5maW5kRGF0YUluZGV4KGUub2Zmc2V0WCwgZS5vZmZzZXRZKTtcbiAgICAgICAgICAgIGlmIChkYXRhSW5kZXggPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gUHJvdmlkZSBkYXRhSW5kZXggZm9yIHRvb2x0aXBcbiAgICAgICAgICAgICAgICBzeW1ib2xFbC5kYXRhSW5kZXggPSBkYXRhSW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEFkZCBiYWNrXG4gICAgICAgIHRoaXMuZ3JvdXAuYWRkKHN5bWJvbEVsKTtcbiAgICB9O1xuXG4gICAgbGFyZ2VTeW1ib2xQcm90by51cGRhdGVMYXlvdXQgPSBmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgICAgIHRoaXMuX3N5bWJvbEVsLnNldFNoYXBlKHtcbiAgICAgICAgICAgIHBvaW50czogZGF0YS5tYXBBcnJheShkYXRhLmdldEl0ZW1MYXlvdXQpXG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBsYXJnZVN5bWJvbFByb3RvLnJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5ncm91cC5yZW1vdmVBbGwoKTtcbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBMYXJnZVN5bWJvbERyYXc7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9jaGFydC9oZWxwZXIvTGFyZ2VTeW1ib2xEcmF3LmpzXG4vLyBtb2R1bGUgaWQgPSAyMDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 203 */
/* unknown exports provided */
/* all exports used */
/*!**************************************!*\
  !*** ./lib/chart/helper/LinePath.js ***!
  \**************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Line path for bezier and straight line draw\n */\n\n    var graphic = __webpack_require__(/*! ../../util/graphic */ 2);\n    var vec2 = __webpack_require__(/*! zrender/lib/core/vector */ 4);\n\n    var straightLineProto = graphic.Line.prototype;\n    var bezierCurveProto = graphic.BezierCurve.prototype;\n\n    function isLine(shape) {\n        return isNaN(+shape.cpx1) || isNaN(+shape.cpy1);\n    }\n\n    module.exports = graphic.extendShape({\n\n        type: 'ec-line',\n\n        style: {\n            stroke: '#000',\n            fill: null\n        },\n\n        shape: {\n            x1: 0,\n            y1: 0,\n            x2: 0,\n            y2: 0,\n            percent: 1,\n            cpx1: null,\n            cpy1: null\n        },\n\n        buildPath: function (ctx, shape) {\n            (isLine(shape) ? straightLineProto : bezierCurveProto).buildPath(ctx, shape);\n        },\n\n        pointAt: function (t) {\n            return isLine(this.shape)\n                ? straightLineProto.pointAt.call(this, t)\n                : bezierCurveProto.pointAt.call(this, t);\n        },\n\n        tangentAt: function (t) {\n            var shape = this.shape;\n            var p = isLine(shape)\n                ? [shape.x2 - shape.x1, shape.y2 - shape.y1]\n                : bezierCurveProto.tangentAt.call(this, t);\n            return vec2.normalize(p, p);\n        }\n    });\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjAzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2NoYXJ0L2hlbHBlci9MaW5lUGF0aC5qcz9lNzk5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogTGluZSBwYXRoIGZvciBiZXppZXIgYW5kIHN0cmFpZ2h0IGxpbmUgZHJhd1xuICovXG5cbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvZ3JhcGhpYycpO1xuICAgIHZhciB2ZWMyID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS92ZWN0b3InKTtcblxuICAgIHZhciBzdHJhaWdodExpbmVQcm90byA9IGdyYXBoaWMuTGluZS5wcm90b3R5cGU7XG4gICAgdmFyIGJlemllckN1cnZlUHJvdG8gPSBncmFwaGljLkJlemllckN1cnZlLnByb3RvdHlwZTtcblxuICAgIGZ1bmN0aW9uIGlzTGluZShzaGFwZSkge1xuICAgICAgICByZXR1cm4gaXNOYU4oK3NoYXBlLmNweDEpIHx8IGlzTmFOKCtzaGFwZS5jcHkxKTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGdyYXBoaWMuZXh0ZW5kU2hhcGUoe1xuXG4gICAgICAgIHR5cGU6ICdlYy1saW5lJyxcblxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgc3Ryb2tlOiAnIzAwMCcsXG4gICAgICAgICAgICBmaWxsOiBudWxsXG4gICAgICAgIH0sXG5cbiAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgIHgxOiAwLFxuICAgICAgICAgICAgeTE6IDAsXG4gICAgICAgICAgICB4MjogMCxcbiAgICAgICAgICAgIHkyOiAwLFxuICAgICAgICAgICAgcGVyY2VudDogMSxcbiAgICAgICAgICAgIGNweDE6IG51bGwsXG4gICAgICAgICAgICBjcHkxOiBudWxsXG4gICAgICAgIH0sXG5cbiAgICAgICAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xuICAgICAgICAgICAgKGlzTGluZShzaGFwZSkgPyBzdHJhaWdodExpbmVQcm90byA6IGJlemllckN1cnZlUHJvdG8pLmJ1aWxkUGF0aChjdHgsIHNoYXBlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBwb2ludEF0OiBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgcmV0dXJuIGlzTGluZSh0aGlzLnNoYXBlKVxuICAgICAgICAgICAgICAgID8gc3RyYWlnaHRMaW5lUHJvdG8ucG9pbnRBdC5jYWxsKHRoaXMsIHQpXG4gICAgICAgICAgICAgICAgOiBiZXppZXJDdXJ2ZVByb3RvLnBvaW50QXQuY2FsbCh0aGlzLCB0KTtcbiAgICAgICAgfSxcblxuICAgICAgICB0YW5nZW50QXQ6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICB2YXIgc2hhcGUgPSB0aGlzLnNoYXBlO1xuICAgICAgICAgICAgdmFyIHAgPSBpc0xpbmUoc2hhcGUpXG4gICAgICAgICAgICAgICAgPyBbc2hhcGUueDIgLSBzaGFwZS54MSwgc2hhcGUueTIgLSBzaGFwZS55MV1cbiAgICAgICAgICAgICAgICA6IGJlemllckN1cnZlUHJvdG8udGFuZ2VudEF0LmNhbGwodGhpcywgdCk7XG4gICAgICAgICAgICByZXR1cm4gdmVjMi5ub3JtYWxpemUocCwgcCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2NoYXJ0L2hlbHBlci9MaW5lUGF0aC5qc1xuLy8gbW9kdWxlIGlkID0gMjAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 204 */
/* unknown exports provided */
/* all exports used */
/*!********************************************!*\
  !*** ./lib/chart/scatter/ScatterSeries.js ***!
  \********************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\n    var createListFromArray = __webpack_require__(/*! ../helper/createListFromArray */ 27);\n    var SeriesModel = __webpack_require__(/*! ../../model/Series */ 17);\n\n    module.exports = SeriesModel.extend({\n\n        type: 'series.scatter',\n\n        dependencies: ['grid', 'polar', 'geo', 'singleAxis'],\n\n        getInitialData: function (option, ecModel) {\n            var list = createListFromArray(option.data, this, ecModel);\n            return list;\n        },\n\n        brushSelector: 'point',\n\n        defaultOption: {\n            coordinateSystem: 'cartesian2d',\n            zlevel: 0,\n            z: 2,\n            legendHoverLink: true,\n\n            hoverAnimation: true,\n            // Cartesian coordinate system\n            // xAxisIndex: 0,\n            // yAxisIndex: 0,\n\n            // Polar coordinate system\n            // polarIndex: 0,\n\n            // Geo coordinate system\n            // geoIndex: 0,\n\n            // symbol: null,        // 图形类型\n            symbolSize: 10,          // 图形大小，半宽（半径）参数，当图形为方向或菱形则总宽度为symbolSize * 2\n            // symbolRotate: null,  // 图形旋转控制\n\n            large: false,\n            // Available when large is true\n            largeThreshold: 2000,\n\n            // label: {\n                // normal: {\n                    // show: false\n                    // distance: 5,\n                    // formatter: 标签文本格式器，同Tooltip.formatter，不支持异步回调\n                    // position: 默认自适应，水平布局为'top'，垂直布局为'right'，可选为\n                    //           'inside'|'left'|'right'|'top'|'bottom'\n                    // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE\n            //     }\n            // },\n            itemStyle: {\n                normal: {\n                    opacity: 0.8\n                    // color: 各异\n                }\n            }\n        }\n\n    });\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjA0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2NoYXJ0L3NjYXR0ZXIvU2NhdHRlclNlcmllcy5qcz84MzA3Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuXG4gICAgdmFyIGNyZWF0ZUxpc3RGcm9tQXJyYXkgPSByZXF1aXJlKCcuLi9oZWxwZXIvY3JlYXRlTGlzdEZyb21BcnJheScpO1xuICAgIHZhciBTZXJpZXNNb2RlbCA9IHJlcXVpcmUoJy4uLy4uL21vZGVsL1NlcmllcycpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBTZXJpZXNNb2RlbC5leHRlbmQoe1xuXG4gICAgICAgIHR5cGU6ICdzZXJpZXMuc2NhdHRlcicsXG5cbiAgICAgICAgZGVwZW5kZW5jaWVzOiBbJ2dyaWQnLCAncG9sYXInLCAnZ2VvJywgJ3NpbmdsZUF4aXMnXSxcblxuICAgICAgICBnZXRJbml0aWFsRGF0YTogZnVuY3Rpb24gKG9wdGlvbiwgZWNNb2RlbCkge1xuICAgICAgICAgICAgdmFyIGxpc3QgPSBjcmVhdGVMaXN0RnJvbUFycmF5KG9wdGlvbi5kYXRhLCB0aGlzLCBlY01vZGVsKTtcbiAgICAgICAgICAgIHJldHVybiBsaXN0O1xuICAgICAgICB9LFxuXG4gICAgICAgIGJydXNoU2VsZWN0b3I6ICdwb2ludCcsXG5cbiAgICAgICAgZGVmYXVsdE9wdGlvbjoge1xuICAgICAgICAgICAgY29vcmRpbmF0ZVN5c3RlbTogJ2NhcnRlc2lhbjJkJyxcbiAgICAgICAgICAgIHpsZXZlbDogMCxcbiAgICAgICAgICAgIHo6IDIsXG4gICAgICAgICAgICBsZWdlbmRIb3Zlckxpbms6IHRydWUsXG5cbiAgICAgICAgICAgIGhvdmVyQW5pbWF0aW9uOiB0cnVlLFxuICAgICAgICAgICAgLy8gQ2FydGVzaWFuIGNvb3JkaW5hdGUgc3lzdGVtXG4gICAgICAgICAgICAvLyB4QXhpc0luZGV4OiAwLFxuICAgICAgICAgICAgLy8geUF4aXNJbmRleDogMCxcblxuICAgICAgICAgICAgLy8gUG9sYXIgY29vcmRpbmF0ZSBzeXN0ZW1cbiAgICAgICAgICAgIC8vIHBvbGFySW5kZXg6IDAsXG5cbiAgICAgICAgICAgIC8vIEdlbyBjb29yZGluYXRlIHN5c3RlbVxuICAgICAgICAgICAgLy8gZ2VvSW5kZXg6IDAsXG5cbiAgICAgICAgICAgIC8vIHN5bWJvbDogbnVsbCwgICAgICAgIC8vIOWbvuW9ouexu+Wei1xuICAgICAgICAgICAgc3ltYm9sU2l6ZTogMTAsICAgICAgICAgIC8vIOWbvuW9ouWkp+Wwj++8jOWNiuWuve+8iOWNiuW+hO+8ieWPguaVsO+8jOW9k+WbvuW9ouS4uuaWueWQkeaIluiPseW9ouWImeaAu+WuveW6puS4unN5bWJvbFNpemUgKiAyXG4gICAgICAgICAgICAvLyBzeW1ib2xSb3RhdGU6IG51bGwsICAvLyDlm77lvaLml4vovazmjqfliLZcblxuICAgICAgICAgICAgbGFyZ2U6IGZhbHNlLFxuICAgICAgICAgICAgLy8gQXZhaWxhYmxlIHdoZW4gbGFyZ2UgaXMgdHJ1ZVxuICAgICAgICAgICAgbGFyZ2VUaHJlc2hvbGQ6IDIwMDAsXG5cbiAgICAgICAgICAgIC8vIGxhYmVsOiB7XG4gICAgICAgICAgICAgICAgLy8gbm9ybWFsOiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNob3c6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIC8vIGRpc3RhbmNlOiA1LFxuICAgICAgICAgICAgICAgICAgICAvLyBmb3JtYXR0ZXI6IOagh+etvuaWh+acrOagvOW8j+WZqO+8jOWQjFRvb2x0aXAuZm9ybWF0dGVy77yM5LiN5pSv5oyB5byC5q2l5Zue6LCDXG4gICAgICAgICAgICAgICAgICAgIC8vIHBvc2l0aW9uOiDpu5jorqToh6rpgILlupTvvIzmsLTlubPluIPlsYDkuLondG9wJ++8jOWeguebtOW4g+WxgOS4uidyaWdodCfvvIzlj6/pgInkuLpcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICdpbnNpZGUnfCdsZWZ0J3wncmlnaHQnfCd0b3AnfCdib3R0b20nXG4gICAgICAgICAgICAgICAgICAgIC8vIHRleHRTdHlsZTogbnVsbCAgICAgIC8vIOm7mOiupOS9v+eUqOWFqOWxgOaWh+acrOagt+W8j++8jOivpuingVRFWFRTVFlMRVxuICAgICAgICAgICAgLy8gICAgIH1cbiAgICAgICAgICAgIC8vIH0sXG4gICAgICAgICAgICBpdGVtU3R5bGU6IHtcbiAgICAgICAgICAgICAgICBub3JtYWw6IHtcbiAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogMC44XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbG9yOiDlkITlvIJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvY2hhcnQvc2NhdHRlci9TY2F0dGVyU2VyaWVzLmpzXG4vLyBtb2R1bGUgaWQgPSAyMDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 205 */
/* unknown exports provided */
/* all exports used */
/*!******************************************!*\
  !*** ./lib/chart/scatter/ScatterView.js ***!
  \******************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var SymbolDraw = __webpack_require__(/*! ../helper/SymbolDraw */ 44);\n    var LargeSymbolDraw = __webpack_require__(/*! ../helper/LargeSymbolDraw */ 202);\n\n    __webpack_require__(/*! ../../echarts */ 1).extendChartView({\n\n        type: 'scatter',\n\n        init: function () {\n            this._normalSymbolDraw = new SymbolDraw();\n            this._largeSymbolDraw = new LargeSymbolDraw();\n        },\n\n        render: function (seriesModel, ecModel, api) {\n            var data = seriesModel.getData();\n            var largeSymbolDraw = this._largeSymbolDraw;\n            var normalSymbolDraw = this._normalSymbolDraw;\n            var group = this.group;\n\n            var symbolDraw = seriesModel.get('large') && data.count() > seriesModel.get('largeThreshold')\n                ? largeSymbolDraw : normalSymbolDraw;\n\n            this._symbolDraw = symbolDraw;\n            symbolDraw.updateData(data);\n            group.add(symbolDraw.group);\n\n            group.remove(\n                symbolDraw === largeSymbolDraw\n                ? normalSymbolDraw.group : largeSymbolDraw.group\n            );\n        },\n\n        updateLayout: function (seriesModel) {\n            this._symbolDraw.updateLayout(seriesModel);\n        },\n\n        remove: function (ecModel, api) {\n            this._symbolDraw && this._symbolDraw.remove(api, true);\n        },\n\n        dispose: function () {}\n    });\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjA1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2NoYXJ0L3NjYXR0ZXIvU2NhdHRlclZpZXcuanM/ZjUzOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcblxuICAgIHZhciBTeW1ib2xEcmF3ID0gcmVxdWlyZSgnLi4vaGVscGVyL1N5bWJvbERyYXcnKTtcbiAgICB2YXIgTGFyZ2VTeW1ib2xEcmF3ID0gcmVxdWlyZSgnLi4vaGVscGVyL0xhcmdlU3ltYm9sRHJhdycpO1xuXG4gICAgcmVxdWlyZSgnLi4vLi4vZWNoYXJ0cycpLmV4dGVuZENoYXJ0Vmlldyh7XG5cbiAgICAgICAgdHlwZTogJ3NjYXR0ZXInLFxuXG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX25vcm1hbFN5bWJvbERyYXcgPSBuZXcgU3ltYm9sRHJhdygpO1xuICAgICAgICAgICAgdGhpcy5fbGFyZ2VTeW1ib2xEcmF3ID0gbmV3IExhcmdlU3ltYm9sRHJhdygpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbmRlcjogZnVuY3Rpb24gKHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgICAgICAgICAgdmFyIGxhcmdlU3ltYm9sRHJhdyA9IHRoaXMuX2xhcmdlU3ltYm9sRHJhdztcbiAgICAgICAgICAgIHZhciBub3JtYWxTeW1ib2xEcmF3ID0gdGhpcy5fbm9ybWFsU3ltYm9sRHJhdztcbiAgICAgICAgICAgIHZhciBncm91cCA9IHRoaXMuZ3JvdXA7XG5cbiAgICAgICAgICAgIHZhciBzeW1ib2xEcmF3ID0gc2VyaWVzTW9kZWwuZ2V0KCdsYXJnZScpICYmIGRhdGEuY291bnQoKSA+IHNlcmllc01vZGVsLmdldCgnbGFyZ2VUaHJlc2hvbGQnKVxuICAgICAgICAgICAgICAgID8gbGFyZ2VTeW1ib2xEcmF3IDogbm9ybWFsU3ltYm9sRHJhdztcblxuICAgICAgICAgICAgdGhpcy5fc3ltYm9sRHJhdyA9IHN5bWJvbERyYXc7XG4gICAgICAgICAgICBzeW1ib2xEcmF3LnVwZGF0ZURhdGEoZGF0YSk7XG4gICAgICAgICAgICBncm91cC5hZGQoc3ltYm9sRHJhdy5ncm91cCk7XG5cbiAgICAgICAgICAgIGdyb3VwLnJlbW92ZShcbiAgICAgICAgICAgICAgICBzeW1ib2xEcmF3ID09PSBsYXJnZVN5bWJvbERyYXdcbiAgICAgICAgICAgICAgICA/IG5vcm1hbFN5bWJvbERyYXcuZ3JvdXAgOiBsYXJnZVN5bWJvbERyYXcuZ3JvdXBcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdXBkYXRlTGF5b3V0OiBmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICAgICAgICAgIHRoaXMuX3N5bWJvbERyYXcudXBkYXRlTGF5b3V0KHNlcmllc01vZGVsKTtcbiAgICAgICAgfSxcblxuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHtcbiAgICAgICAgICAgIHRoaXMuX3N5bWJvbERyYXcgJiYgdGhpcy5fc3ltYm9sRHJhdy5yZW1vdmUoYXBpLCB0cnVlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7fVxuICAgIH0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvY2hhcnQvc2NhdHRlci9TY2F0dGVyVmlldy5qc1xuLy8gbW9kdWxlIGlkID0gMjA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 206 */
/* unknown exports provided */
/* all exports used */
/*!*******************************************************!*\
  !*** ./lib/component/axisPointer/AxisPointerModel.js ***!
  \*******************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var echarts = __webpack_require__(/*! ../../echarts */ 1);\n\n    var AxisPointerModel = echarts.extendComponentModel({\n\n        type: 'axisPointer',\n\n        coordSysAxesInfo: null,\n\n        defaultOption: {\n            // 'auto' means that show when triggered by tooltip or handle.\n            show: 'auto',\n            // 'click' | 'mousemove' | 'none'\n            triggerOn: null, // set default in AxisPonterView.js\n\n            zlevel: 0,\n            z: 50,\n\n            type: 'line',\n            // axispointer triggered by tootip determine snap automatically,\n            // see `modelHelper`.\n            snap: false,\n            triggerTooltip: true,\n\n            value: null,\n            status: null, // Init value depends on whether handle is used.\n\n            // [group0, group1, ...]\n            // Each group can be: {\n            //      mapper: function () {},\n            //      singleTooltip: 'multiple',  // 'multiple' or 'single'\n            //      xAxisId: ...,\n            //      yAxisName: ...,\n            //      angleAxisIndex: ...\n            // }\n            // mapper: can be ignored.\n            //      input: {axisInfo, value}\n            //      output: {axisInfo, value}\n            link: [],\n\n            // Do not set 'auto' here, otherwise global animation: false\n            // will not effect at this axispointer.\n            animation: null,\n            animationDurationUpdate: 200,\n\n            lineStyle: {\n                color: '#aaa',\n                width: 1,\n                type: 'solid'\n            },\n\n            shadowStyle: {\n                color: 'rgba(150,150,150,0.3)'\n            },\n\n            label: {\n                show: true,\n                formatter: null, // string | Function\n                precision: 'auto', // Or a number like 0, 1, 2 ...\n                margin: 3,\n                textStyle: {\n                    color: '#fff'\n                },\n                padding: [5, 7, 5, 7],\n                backgroundColor: 'auto', // default: axis line color\n                borderColor: null,\n                borderWidth: 0,\n                shadowBlur: 3,\n                shadowColor: '#aaa'\n                // Considering applicability, common style should\n                // better not have shadowOffset.\n                // shadowOffsetX: 0,\n                // shadowOffsetY: 2\n            },\n\n            handle: {\n                show: false,\n                icon: 'M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4h1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7v-1.2h6.6z M13.3,22H6.7v-1.2h6.6z M13.3,19.6H6.7v-1.2h6.6z', // jshint ignore:line\n                size: 45,\n                // handle margin is from symbol center to axis, which is stable when circular move.\n                margin: 50,\n                // color: '#1b8bbd'\n                // color: '#2f4554'\n                color: '#333',\n                shadowBlur: 3,\n                shadowColor: '#aaa',\n                shadowOffsetX: 0,\n                shadowOffsetY: 2,\n\n                // For mobile performance\n                throttle: 40\n            }\n        }\n\n    });\n\n    module.exports = AxisPointerModel;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjA2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2NvbXBvbmVudC9heGlzUG9pbnRlci9BeGlzUG9pbnRlck1vZGVsLmpzPzJhOTgiXSwic291cmNlc0NvbnRlbnQiOlsiXG5cbiAgICB2YXIgZWNoYXJ0cyA9IHJlcXVpcmUoJy4uLy4uL2VjaGFydHMnKTtcblxuICAgIHZhciBBeGlzUG9pbnRlck1vZGVsID0gZWNoYXJ0cy5leHRlbmRDb21wb25lbnRNb2RlbCh7XG5cbiAgICAgICAgdHlwZTogJ2F4aXNQb2ludGVyJyxcblxuICAgICAgICBjb29yZFN5c0F4ZXNJbmZvOiBudWxsLFxuXG4gICAgICAgIGRlZmF1bHRPcHRpb246IHtcbiAgICAgICAgICAgIC8vICdhdXRvJyBtZWFucyB0aGF0IHNob3cgd2hlbiB0cmlnZ2VyZWQgYnkgdG9vbHRpcCBvciBoYW5kbGUuXG4gICAgICAgICAgICBzaG93OiAnYXV0bycsXG4gICAgICAgICAgICAvLyAnY2xpY2snIHwgJ21vdXNlbW92ZScgfCAnbm9uZSdcbiAgICAgICAgICAgIHRyaWdnZXJPbjogbnVsbCwgLy8gc2V0IGRlZmF1bHQgaW4gQXhpc1BvbnRlclZpZXcuanNcblxuICAgICAgICAgICAgemxldmVsOiAwLFxuICAgICAgICAgICAgejogNTAsXG5cbiAgICAgICAgICAgIHR5cGU6ICdsaW5lJyxcbiAgICAgICAgICAgIC8vIGF4aXNwb2ludGVyIHRyaWdnZXJlZCBieSB0b290aXAgZGV0ZXJtaW5lIHNuYXAgYXV0b21hdGljYWxseSxcbiAgICAgICAgICAgIC8vIHNlZSBgbW9kZWxIZWxwZXJgLlxuICAgICAgICAgICAgc25hcDogZmFsc2UsXG4gICAgICAgICAgICB0cmlnZ2VyVG9vbHRpcDogdHJ1ZSxcblxuICAgICAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgICAgICBzdGF0dXM6IG51bGwsIC8vIEluaXQgdmFsdWUgZGVwZW5kcyBvbiB3aGV0aGVyIGhhbmRsZSBpcyB1c2VkLlxuXG4gICAgICAgICAgICAvLyBbZ3JvdXAwLCBncm91cDEsIC4uLl1cbiAgICAgICAgICAgIC8vIEVhY2ggZ3JvdXAgY2FuIGJlOiB7XG4gICAgICAgICAgICAvLyAgICAgIG1hcHBlcjogZnVuY3Rpb24gKCkge30sXG4gICAgICAgICAgICAvLyAgICAgIHNpbmdsZVRvb2x0aXA6ICdtdWx0aXBsZScsICAvLyAnbXVsdGlwbGUnIG9yICdzaW5nbGUnXG4gICAgICAgICAgICAvLyAgICAgIHhBeGlzSWQ6IC4uLixcbiAgICAgICAgICAgIC8vICAgICAgeUF4aXNOYW1lOiAuLi4sXG4gICAgICAgICAgICAvLyAgICAgIGFuZ2xlQXhpc0luZGV4OiAuLi5cbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgIC8vIG1hcHBlcjogY2FuIGJlIGlnbm9yZWQuXG4gICAgICAgICAgICAvLyAgICAgIGlucHV0OiB7YXhpc0luZm8sIHZhbHVlfVxuICAgICAgICAgICAgLy8gICAgICBvdXRwdXQ6IHtheGlzSW5mbywgdmFsdWV9XG4gICAgICAgICAgICBsaW5rOiBbXSxcblxuICAgICAgICAgICAgLy8gRG8gbm90IHNldCAnYXV0bycgaGVyZSwgb3RoZXJ3aXNlIGdsb2JhbCBhbmltYXRpb246IGZhbHNlXG4gICAgICAgICAgICAvLyB3aWxsIG5vdCBlZmZlY3QgYXQgdGhpcyBheGlzcG9pbnRlci5cbiAgICAgICAgICAgIGFuaW1hdGlvbjogbnVsbCxcbiAgICAgICAgICAgIGFuaW1hdGlvbkR1cmF0aW9uVXBkYXRlOiAyMDAsXG5cbiAgICAgICAgICAgIGxpbmVTdHlsZToge1xuICAgICAgICAgICAgICAgIGNvbG9yOiAnI2FhYScsXG4gICAgICAgICAgICAgICAgd2lkdGg6IDEsXG4gICAgICAgICAgICAgICAgdHlwZTogJ3NvbGlkJ1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc2hhZG93U3R5bGU6IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogJ3JnYmEoMTUwLDE1MCwxNTAsMC4zKSdcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGxhYmVsOiB7XG4gICAgICAgICAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZXI6IG51bGwsIC8vIHN0cmluZyB8IEZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgcHJlY2lzaW9uOiAnYXV0bycsIC8vIE9yIGEgbnVtYmVyIGxpa2UgMCwgMSwgMiAuLi5cbiAgICAgICAgICAgICAgICBtYXJnaW46IDMsXG4gICAgICAgICAgICAgICAgdGV4dFN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiAnI2ZmZidcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHBhZGRpbmc6IFs1LCA3LCA1LCA3XSxcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdhdXRvJywgLy8gZGVmYXVsdDogYXhpcyBsaW5lIGNvbG9yXG4gICAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6IG51bGwsXG4gICAgICAgICAgICAgICAgYm9yZGVyV2lkdGg6IDAsXG4gICAgICAgICAgICAgICAgc2hhZG93Qmx1cjogMyxcbiAgICAgICAgICAgICAgICBzaGFkb3dDb2xvcjogJyNhYWEnXG4gICAgICAgICAgICAgICAgLy8gQ29uc2lkZXJpbmcgYXBwbGljYWJpbGl0eSwgY29tbW9uIHN0eWxlIHNob3VsZFxuICAgICAgICAgICAgICAgIC8vIGJldHRlciBub3QgaGF2ZSBzaGFkb3dPZmZzZXQuXG4gICAgICAgICAgICAgICAgLy8gc2hhZG93T2Zmc2V0WDogMCxcbiAgICAgICAgICAgICAgICAvLyBzaGFkb3dPZmZzZXRZOiAyXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBoYW5kbGU6IHtcbiAgICAgICAgICAgICAgICBzaG93OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpY29uOiAnTTEwLjcsMTEuOXYtMS4zSDkuM3YxLjNjLTQuOSwwLjMtOC44LDQuNC04LjgsOS40YzAsNSwzLjksOS4xLDguOCw5LjRoMS4zYzQuOS0wLjMsOC44LTQuNCw4LjgtOS40QzE5LjUsMTYuMywxNS42LDEyLjIsMTAuNywxMS45eiBNMTMuMywyNC40SDYuN3YtMS4yaDYuNnogTTEzLjMsMjJINi43di0xLjJoNi42eiBNMTMuMywxOS42SDYuN3YtMS4yaDYuNnonLCAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICAgICAgICAgICAgICBzaXplOiA0NSxcbiAgICAgICAgICAgICAgICAvLyBoYW5kbGUgbWFyZ2luIGlzIGZyb20gc3ltYm9sIGNlbnRlciB0byBheGlzLCB3aGljaCBpcyBzdGFibGUgd2hlbiBjaXJjdWxhciBtb3ZlLlxuICAgICAgICAgICAgICAgIG1hcmdpbjogNTAsXG4gICAgICAgICAgICAgICAgLy8gY29sb3I6ICcjMWI4YmJkJ1xuICAgICAgICAgICAgICAgIC8vIGNvbG9yOiAnIzJmNDU1NCdcbiAgICAgICAgICAgICAgICBjb2xvcjogJyMzMzMnLFxuICAgICAgICAgICAgICAgIHNoYWRvd0JsdXI6IDMsXG4gICAgICAgICAgICAgICAgc2hhZG93Q29sb3I6ICcjYWFhJyxcbiAgICAgICAgICAgICAgICBzaGFkb3dPZmZzZXRYOiAwLFxuICAgICAgICAgICAgICAgIHNoYWRvd09mZnNldFk6IDIsXG5cbiAgICAgICAgICAgICAgICAvLyBGb3IgbW9iaWxlIHBlcmZvcm1hbmNlXG4gICAgICAgICAgICAgICAgdGhyb3R0bGU6IDQwXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH0pO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBBeGlzUG9pbnRlck1vZGVsO1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9jb21wb25lbnQvYXhpc1BvaW50ZXIvQXhpc1BvaW50ZXJNb2RlbC5qc1xuLy8gbW9kdWxlIGlkID0gMjA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 207 */
/* unknown exports provided */
/* all exports used */
/*!******************************************************!*\
  !*** ./lib/component/axisPointer/AxisPointerView.js ***!
  \******************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var globalListener = __webpack_require__(/*! ./globalListener */ 151);\n\n    var AxisPonterView = __webpack_require__(/*! ../../echarts */ 1).extendComponentView({\n\n        type: 'axisPointer',\n\n        render: function (globalAxisPointerModel, ecModel, api) {\n            var globalTooltipModel = ecModel.getComponent('tooltip');\n            var triggerOn = globalAxisPointerModel.get('triggerOn')\n                || (globalTooltipModel && globalTooltipModel.get('triggerOn') || 'mousemove|click');\n\n            // Register global listener in AxisPointerView to enable\n            // AxisPointerView to be independent to Tooltip.\n            globalListener.register(\n                'axisPointer',\n                api,\n                function (currTrigger, e, dispatchAction) {\n                    // If 'none', it is not controlled by mouse totally.\n                    if (triggerOn !== 'none'\n                        && (currTrigger === 'leave' || triggerOn.indexOf(currTrigger) >= 0)\n                    ) {\n                        dispatchAction({\n                            type: 'updateAxisPointer',\n                            currTrigger: currTrigger,\n                            x: e && e.offsetX,\n                            y: e && e.offsetY\n                        });\n                    }\n                }\n            );\n        },\n\n        /**\n         * @override\n         */\n        remove: function (ecModel, api) {\n            globalListener.disopse(api.getZr(), 'axisPointer');\n            AxisPonterView.superApply(this._model, 'remove', arguments);\n        },\n\n        /**\n         * @override\n         */\n        dispose: function (ecModel, api) {\n            globalListener.unregister('axisPointer', api);\n            AxisPonterView.superApply(this._model, 'dispose', arguments);\n        }\n\n    });\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjA3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2NvbXBvbmVudC9heGlzUG9pbnRlci9BeGlzUG9pbnRlclZpZXcuanM/MWMzYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcblxuICAgIHZhciBnbG9iYWxMaXN0ZW5lciA9IHJlcXVpcmUoJy4vZ2xvYmFsTGlzdGVuZXInKTtcblxuICAgIHZhciBBeGlzUG9udGVyVmlldyA9IHJlcXVpcmUoJy4uLy4uL2VjaGFydHMnKS5leHRlbmRDb21wb25lbnRWaWV3KHtcblxuICAgICAgICB0eXBlOiAnYXhpc1BvaW50ZXInLFxuXG4gICAgICAgIHJlbmRlcjogZnVuY3Rpb24gKGdsb2JhbEF4aXNQb2ludGVyTW9kZWwsIGVjTW9kZWwsIGFwaSkge1xuICAgICAgICAgICAgdmFyIGdsb2JhbFRvb2x0aXBNb2RlbCA9IGVjTW9kZWwuZ2V0Q29tcG9uZW50KCd0b29sdGlwJyk7XG4gICAgICAgICAgICB2YXIgdHJpZ2dlck9uID0gZ2xvYmFsQXhpc1BvaW50ZXJNb2RlbC5nZXQoJ3RyaWdnZXJPbicpXG4gICAgICAgICAgICAgICAgfHwgKGdsb2JhbFRvb2x0aXBNb2RlbCAmJiBnbG9iYWxUb29sdGlwTW9kZWwuZ2V0KCd0cmlnZ2VyT24nKSB8fCAnbW91c2Vtb3ZlfGNsaWNrJyk7XG5cbiAgICAgICAgICAgIC8vIFJlZ2lzdGVyIGdsb2JhbCBsaXN0ZW5lciBpbiBBeGlzUG9pbnRlclZpZXcgdG8gZW5hYmxlXG4gICAgICAgICAgICAvLyBBeGlzUG9pbnRlclZpZXcgdG8gYmUgaW5kZXBlbmRlbnQgdG8gVG9vbHRpcC5cbiAgICAgICAgICAgIGdsb2JhbExpc3RlbmVyLnJlZ2lzdGVyKFxuICAgICAgICAgICAgICAgICdheGlzUG9pbnRlcicsXG4gICAgICAgICAgICAgICAgYXBpLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChjdXJyVHJpZ2dlciwgZSwgZGlzcGF0Y2hBY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgJ25vbmUnLCBpdCBpcyBub3QgY29udHJvbGxlZCBieSBtb3VzZSB0b3RhbGx5LlxuICAgICAgICAgICAgICAgICAgICBpZiAodHJpZ2dlck9uICE9PSAnbm9uZSdcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIChjdXJyVHJpZ2dlciA9PT0gJ2xlYXZlJyB8fCB0cmlnZ2VyT24uaW5kZXhPZihjdXJyVHJpZ2dlcikgPj0gMClcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaEFjdGlvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3VwZGF0ZUF4aXNQb2ludGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyVHJpZ2dlcjogY3VyclRyaWdnZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogZSAmJiBlLm9mZnNldFgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogZSAmJiBlLm9mZnNldFlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgICAqL1xuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHtcbiAgICAgICAgICAgIGdsb2JhbExpc3RlbmVyLmRpc29wc2UoYXBpLmdldFpyKCksICdheGlzUG9pbnRlcicpO1xuICAgICAgICAgICAgQXhpc1BvbnRlclZpZXcuc3VwZXJBcHBseSh0aGlzLl9tb2RlbCwgJ3JlbW92ZScsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICAgKi9cbiAgICAgICAgZGlzcG9zZTogZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICAgICAgICAgICAgZ2xvYmFsTGlzdGVuZXIudW5yZWdpc3RlcignYXhpc1BvaW50ZXInLCBhcGkpO1xuICAgICAgICAgICAgQXhpc1BvbnRlclZpZXcuc3VwZXJBcHBseSh0aGlzLl9tb2RlbCwgJ2Rpc3Bvc2UnLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG5cbiAgICB9KTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvY29tcG9uZW50L2F4aXNQb2ludGVyL0F4aXNQb2ludGVyVmlldy5qc1xuLy8gbW9kdWxlIGlkID0gMjA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 208 */
/* unknown exports provided */
/* all exports used */
/*!**************************************************!*\
  !*** ./lib/component/axisPointer/axisTrigger.js ***!
  \**************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 0);\n    var modelUtil = __webpack_require__(/*! ../../util/model */ 5);\n    var modelHelper = __webpack_require__(/*! ./modelHelper */ 45);\n    var findPointFromSeries = __webpack_require__(/*! ./findPointFromSeries */ 150);\n\n    var each = zrUtil.each;\n    var curry = zrUtil.curry;\n    var get = modelUtil.makeGetter();\n\n    /**\n     * Basic logic: check all axis, if they do not demand show/highlight,\n     * then hide/downplay them.\n     *\n     * @param {Object} coordSysAxesInfo\n     * @param {string} [currTrigger] 'click' | 'mousemove' | 'leave'\n     * @param {Array.<number>} [point] x and y, which are mandatory, specify a point to\n     *              tigger axisPointer and tooltip.\n     * @param {Object} [finder] {xAxisId: ...[], yAxisName: ...[], angleAxisIndex: ...[]}\n     *              These properties, which are optional, restrict target axes.\n     * @param {Function} dispatchAction\n     * @param {module:echarts/ExtensionAPI} api\n     * @param {Object} [tooltipOption]\n     * @param {string} [highDownKey]\n     * @return {Object} content of event obj for echarts.connect.\n     */\n    function axisTrigger(\n        coordSysAxesInfo, currTrigger, point, finder, dispatchAction,\n        ecModel, api, tooltipOption, highDownKey\n    ) {\n        finder = finder || {};\n        if (!point || point[0] == null || point[1] == null) {\n            point = findPointFromSeries({\n                seriesIndex: finder.seriesIndex,\n                // Do not use dataIndexInside from other ec instance.\n                // FIXME: auto detect it?\n                dataIndex: finder.dataIndex\n            }, ecModel).point;\n        }\n\n        var axesInfo = coordSysAxesInfo.axesInfo;\n        var shouldHide = currTrigger === 'leave' || illegalPoint(point);\n        var outputFinder = {};\n\n        var showValueMap = {};\n        var dataByCoordSys = {list: [], map: {}};\n        var highlightBatch = [];\n        var updaters = {\n            showPointer: curry(showPointer, showValueMap),\n            showTooltip: curry(showTooltip, dataByCoordSys),\n            highlight: curry(highlight, highlightBatch)\n        };\n\n        // Process for triggered axes.\n        each(coordSysAxesInfo.coordSysMap, function (coordSys, coordSysKey) {\n            var coordSysContainsPoint = coordSys.containPoint(point);\n\n            each(coordSysAxesInfo.coordSysAxesInfo[coordSysKey], function (axisInfo, key) {\n                var axis = axisInfo.axis;\n                if (!shouldHide && coordSysContainsPoint && !notTargetAxis(finder, axis)) {\n                    processOnAxis(axisInfo, axis.pointToData(point), updaters, false, outputFinder);\n                }\n            });\n        });\n\n        // Process for linked axes.\n        var linkTriggers = {};\n        each(axesInfo, function (tarAxisInfo, tarKey) {\n            var linkGroup = tarAxisInfo.linkGroup;\n\n            // If axis has been triggered in the previous stage, it should not be triggered by link.\n            if (linkGroup && !showValueMap[tarKey]) {\n                each(linkGroup.axesInfo, function (srcAxisInfo, srcKey) {\n                    var srcValItem = showValueMap[srcKey];\n                    // If srcValItem exist, source axis is triggered, so link to target axis.\n                    if (srcAxisInfo !== tarAxisInfo && srcValItem) {\n                        var val = srcValItem.value;\n                        linkGroup.mapper && (val = tarAxisInfo.axis.scale.parse(linkGroup.mapper(\n                            val, makeMapperParam(srcAxisInfo), makeMapperParam(tarAxisInfo)\n                        )));\n                        linkTriggers[tarAxisInfo.key] = val;\n                    }\n                });\n            }\n        });\n        each(linkTriggers, function (val, tarKey) {\n            processOnAxis(axesInfo[tarKey], val, updaters, true, outputFinder);\n        });\n\n        updateModelActually(showValueMap, axesInfo);\n        dispatchTooltipActually(dataByCoordSys, point, tooltipOption, dispatchAction);\n        dispatchHighDownActually(highlightBatch, dispatchAction, api, highDownKey);\n\n        return outputFinder;\n    }\n\n    function processOnAxis(axisInfo, newValue, updaters, dontSnap, outputFinder) {\n        var axis = axisInfo.axis;\n\n        if (axis.scale.isBlank() || !axis.containData(newValue)) {\n            return;\n        }\n\n        if (!axisInfo.involveSeries) {\n            updaters.showPointer(axisInfo, newValue);\n            return;\n        }\n\n        // Heavy calculation. So put it after axis.containData checking.\n        var payloadInfo = buildPayloadsBySeries(newValue, axisInfo);\n        var payloadBatch = payloadInfo.payloadBatch;\n        var snapToValue = payloadInfo.snapToValue;\n\n        // Fill content of event obj for echarts.connect.\n        // By defualt use the first involved series data as a sample to connect.\n        if (payloadBatch[0] && outputFinder.seriesIndex == null) {\n            zrUtil.extend(outputFinder, payloadBatch[0]);\n        }\n\n        // If no linkSource input, this process is for collecting link\n        // target, where snap should not be accepted.\n        if (!dontSnap && axisInfo.snap) {\n            if (axis.containData(snapToValue) && snapToValue != null) {\n                newValue = snapToValue;\n            }\n        }\n\n        updaters.highlight('highlight', payloadBatch);\n        updaters.showPointer(axisInfo, newValue, payloadBatch);\n        // Tooltip should always be snapToValue, otherwise there will be\n        // incorrect \"axis value ~ series value\" mapping displayed in tooltip.\n        updaters.showTooltip(axisInfo, payloadInfo, snapToValue);\n    }\n\n    function buildPayloadsBySeries(value, axisInfo) {\n        var axis = axisInfo.axis;\n        var dim = axis.dim;\n        var snapToValue = value;\n        var payloadBatch = [];\n        var minDist = Number.MAX_VALUE;\n        var minDiff = -1;\n\n        each(axisInfo.seriesModels, function (series, idx) {\n            var dataDim = series.coordDimToDataDim(dim);\n            var seriesNestestValue;\n            var dataIndices;\n\n            if (series.getAxisTooltipData) {\n                var result = series.getAxisTooltipData(dataDim, value, axis);\n                dataIndices = result.dataIndices;\n                seriesNestestValue = result.nestestValue;\n            }\n            else {\n                dataIndices = series.getData().indicesOfNearest(\n                    dataDim[0],\n                    value,\n                    // Add a threshold to avoid find the wrong dataIndex\n                    // when data length is not same.\n                    false, axis.type === 'category' ? 0.5 : null\n                );\n                if (!dataIndices.length) {\n                    return;\n                }\n                seriesNestestValue = series.getData().get(dataDim[0], dataIndices[0]);\n            }\n\n            if (seriesNestestValue == null || !isFinite(seriesNestestValue)) {\n                return;\n            }\n\n            var diff = value - seriesNestestValue;\n            var dist = Math.abs(diff);\n            // Consider category case\n            if (dist <= minDist) {\n                if (dist < minDist || (diff >= 0 && minDiff < 0)) {\n                    minDist = dist;\n                    minDiff = diff;\n                    snapToValue = seriesNestestValue;\n                    payloadBatch.length = 0;\n                }\n                each(dataIndices, function (dataIndex) {\n                    payloadBatch.push({\n                        seriesIndex: series.seriesIndex,\n                        dataIndexInside: dataIndex,\n                        dataIndex: series.getData().getRawIndex(dataIndex)\n                    });\n                });\n            }\n        });\n\n        return {\n            payloadBatch: payloadBatch,\n            snapToValue: snapToValue\n        };\n    }\n\n    function showPointer(showValueMap, axisInfo, value, payloadBatch) {\n        showValueMap[axisInfo.key] = {value: value, payloadBatch: payloadBatch};\n    }\n\n    function showTooltip(dataByCoordSys, axisInfo, payloadInfo, value) {\n        var payloadBatch = payloadInfo.payloadBatch;\n        var axis = axisInfo.axis;\n        var axisModel = axis.model;\n        var axisPointerModel = axisInfo.axisPointerModel;\n\n        // If no data, do not create anything in dataByCoordSys,\n        // whose length will be used to judge whether dispatch action.\n        if (!axisInfo.triggerTooltip || !payloadBatch.length) {\n            return;\n        }\n\n        var coordSysModel = axisInfo.coordSys.model;\n        var coordSysKey = modelHelper.makeKey(coordSysModel);\n        var coordSysItem = dataByCoordSys.map[coordSysKey];\n        if (!coordSysItem) {\n            coordSysItem = dataByCoordSys.map[coordSysKey] = {\n                coordSysId: coordSysModel.id,\n                coordSysIndex: coordSysModel.componentIndex,\n                coordSysType: coordSysModel.type,\n                coordSysMainType: coordSysModel.mainType,\n                dataByAxis: []\n            };\n            dataByCoordSys.list.push(coordSysItem);\n        }\n\n        coordSysItem.dataByAxis.push({\n            axisDim: axis.dim,\n            axisIndex: axisModel.componentIndex,\n            axisType: axisModel.type,\n            axisId: axisModel.id,\n            value: value,\n            // Caustion: viewHelper.getValueLabel is actually on \"view stage\", which\n            // depends that all models have been updated. So it should not be performed\n            // here. Considering axisPointerModel used here is volatile, which is hard\n            // to be retrieve in TooltipView, we prepare parameters here.\n            valueLabelOpt: {\n                precision: axisPointerModel.get('label.precision'),\n                formatter: axisPointerModel.get('label.formatter')\n            },\n            seriesDataIndices: payloadBatch.slice()\n        });\n    }\n\n    function highlight(highlightBatch, actionType, batch) {\n        highlightBatch.push.apply(highlightBatch, batch);\n    }\n\n    function updateModelActually(showValueMap, axesInfo) {\n        // Basic logic: If no 'show' required, 'hide' this axisPointer.\n        each(axesInfo, function (axisInfo, key) {\n            var option = axisInfo.axisPointerModel.option;\n            var valItem = showValueMap[key];\n\n            if (valItem) {\n                !axisInfo.useHandle && (option.status = 'show');\n                option.value = valItem.value;\n                // For label formatter param.\n                option.seriesDataIndices = (valItem.payloadBatch || []).slice();\n            }\n            // When always show (e.g., handle used), remain\n            // original value and status.\n            else {\n                // If hide, value still need to be set, consider\n                // click legend to toggle axis blank.\n                !axisInfo.useHandle && (option.status = 'hide');\n            }\n        });\n    }\n\n    function dispatchTooltipActually(dataByCoordSys, point, tooltipOption, dispatchAction) {\n        // Basic logic: If no showTip required, hideTip will be dispatched.\n        if (illegalPoint(point) || !dataByCoordSys.list.length) {\n            dispatchAction({type: 'hideTip'});\n            return;\n        }\n\n        // In most case only one axis (or event one series is used). It is\n        // convinient to fetch payload.seriesIndex and payload.dataIndex\n        // dirtectly. So put the first seriesIndex and dataIndex of the first\n        // axis on the payload.\n        var sampleItem = ((dataByCoordSys.list[0].dataByAxis[0] || {}).seriesDataIndices || [])[0] || {};\n\n        dispatchAction({\n            type: 'showTip',\n            escapeConnect: true,\n            x: point[0],\n            y: point[1],\n            tooltipOption: tooltipOption,\n            dataIndexInside: sampleItem.dataIndexInside,\n            dataIndex: sampleItem.dataIndex,\n            seriesIndex: sampleItem.seriesIndex,\n            dataByCoordSys: dataByCoordSys.list\n        });\n    }\n\n    function dispatchHighDownActually(highlightBatch, dispatchAction, api, highDownKey) {\n        // Basic logic: If nothing highlighted, should downplay all highlighted items.\n        // This case will occur when mouse leave coordSys.\n\n        // FIXME\n        // (1) highlight status shoule be managemented in series.getData()?\n        // (2) If axisPointer A triggerOn 'handle' and axisPointer B triggerOn\n        // 'mousemove', items highlighted by A will be downplayed by B.\n        // It will not be fixed until someone requires this scenario.\n\n        // Consider items area hightlighted by 'handle', and globalListener may\n        // downplay all items (including just highlighted ones) when mousemove.\n        // So we use a highDownKey to separate them as a temporary solution.\n        var zr = api.getZr();\n        highDownKey = 'lastHighlights' + (highDownKey || '');\n        var lastHighlights = get(zr)[highDownKey] || {};\n        var newHighlights = get(zr)[highDownKey] = {};\n\n        // Build hash map and remove duplicate incidentally.\n        zrUtil.each(highlightBatch, function (batchItem) {\n            var key = batchItem.seriesIndex + ' | ' + batchItem.dataIndex;\n            newHighlights[key] = batchItem;\n        });\n\n        // Diff.\n        var toHighlight = [];\n        var toDownplay = [];\n        zrUtil.each(lastHighlights, function (batchItem, key) {\n            !newHighlights[key] && toDownplay.push(batchItem);\n        });\n        zrUtil.each(newHighlights, function (batchItem, key) {\n            !lastHighlights[key] && toHighlight.push(batchItem);\n        });\n\n        toDownplay.length && api.dispatchAction({\n            type: 'downplay', escapeConnect: true, batch: toDownplay\n        });\n        toHighlight.length && api.dispatchAction({\n            type: 'highlight', escapeConnect: true, batch: toHighlight\n        });\n    }\n\n    function notTargetAxis(finder, axis) {\n        var isTarget = 1;\n        // If none of xxxAxisId and xxxAxisName and xxxAxisIndex exists in finder,\n        // no axis is not target axis.\n        each(finder, function (value, propName) {\n            isTarget &= !(/^.+(AxisId|AxisName|AxisIndex)$/.test(propName));\n        });\n        !isTarget && each(\n            [['AxisId', 'id'], ['AxisIndex', 'componentIndex'], ['AxisName', 'name']],\n            function (prop) {\n                var vals = modelUtil.normalizeToArray(finder[axis.dim + prop[0]]);\n                isTarget |= zrUtil.indexOf(vals, axis.model[prop[1]]) >= 0;\n            }\n        );\n        return !isTarget;\n    }\n\n    function makeMapperParam(axisInfo) {\n        var axisModel = axisInfo.axis.model;\n        var item = {};\n        var dim = item.axisDim = axisInfo.axis.dim;\n        item.axisIndex = item[dim + 'AxisIndex'] = axisModel.componentIndex;\n        item.axisName = item[dim + 'AxisName'] = axisModel.name;\n        item.axisId = item[dim + 'AxisId'] = axisModel.id;\n        return item;\n    }\n\n    function illegalPoint(point) {\n        return point[0] == null || isNaN(point[0]) || point[1] == null || isNaN(point[1]);\n    }\n\n    module.exports = axisTrigger;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjA4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2NvbXBvbmVudC9heGlzUG9pbnRlci9heGlzVHJpZ2dlci5qcz82MmU5Il0sInNvdXJjZXNDb250ZW50IjpbIlxuXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuICAgIHZhciBtb2RlbFV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL21vZGVsJyk7XG4gICAgdmFyIG1vZGVsSGVscGVyID0gcmVxdWlyZSgnLi9tb2RlbEhlbHBlcicpO1xuICAgIHZhciBmaW5kUG9pbnRGcm9tU2VyaWVzID0gcmVxdWlyZSgnLi9maW5kUG9pbnRGcm9tU2VyaWVzJyk7XG5cbiAgICB2YXIgZWFjaCA9IHpyVXRpbC5lYWNoO1xuICAgIHZhciBjdXJyeSA9IHpyVXRpbC5jdXJyeTtcbiAgICB2YXIgZ2V0ID0gbW9kZWxVdGlsLm1ha2VHZXR0ZXIoKTtcblxuICAgIC8qKlxuICAgICAqIEJhc2ljIGxvZ2ljOiBjaGVjayBhbGwgYXhpcywgaWYgdGhleSBkbyBub3QgZGVtYW5kIHNob3cvaGlnaGxpZ2h0LFxuICAgICAqIHRoZW4gaGlkZS9kb3ducGxheSB0aGVtLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvb3JkU3lzQXhlc0luZm9cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2N1cnJUcmlnZ2VyXSAnY2xpY2snIHwgJ21vdXNlbW92ZScgfCAnbGVhdmUnXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gW3BvaW50XSB4IGFuZCB5LCB3aGljaCBhcmUgbWFuZGF0b3J5LCBzcGVjaWZ5IGEgcG9pbnQgdG9cbiAgICAgKiAgICAgICAgICAgICAgdGlnZ2VyIGF4aXNQb2ludGVyIGFuZCB0b29sdGlwLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbZmluZGVyXSB7eEF4aXNJZDogLi4uW10sIHlBeGlzTmFtZTogLi4uW10sIGFuZ2xlQXhpc0luZGV4OiAuLi5bXX1cbiAgICAgKiAgICAgICAgICAgICAgVGhlc2UgcHJvcGVydGllcywgd2hpY2ggYXJlIG9wdGlvbmFsLCByZXN0cmljdCB0YXJnZXQgYXhlcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkaXNwYXRjaEFjdGlvblxuICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvRXh0ZW5zaW9uQVBJfSBhcGlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3Rvb2x0aXBPcHRpb25dXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtoaWdoRG93bktleV1cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IGNvbnRlbnQgb2YgZXZlbnQgb2JqIGZvciBlY2hhcnRzLmNvbm5lY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXhpc1RyaWdnZXIoXG4gICAgICAgIGNvb3JkU3lzQXhlc0luZm8sIGN1cnJUcmlnZ2VyLCBwb2ludCwgZmluZGVyLCBkaXNwYXRjaEFjdGlvbixcbiAgICAgICAgZWNNb2RlbCwgYXBpLCB0b29sdGlwT3B0aW9uLCBoaWdoRG93bktleVxuICAgICkge1xuICAgICAgICBmaW5kZXIgPSBmaW5kZXIgfHwge307XG4gICAgICAgIGlmICghcG9pbnQgfHwgcG9pbnRbMF0gPT0gbnVsbCB8fCBwb2ludFsxXSA9PSBudWxsKSB7XG4gICAgICAgICAgICBwb2ludCA9IGZpbmRQb2ludEZyb21TZXJpZXMoe1xuICAgICAgICAgICAgICAgIHNlcmllc0luZGV4OiBmaW5kZXIuc2VyaWVzSW5kZXgsXG4gICAgICAgICAgICAgICAgLy8gRG8gbm90IHVzZSBkYXRhSW5kZXhJbnNpZGUgZnJvbSBvdGhlciBlYyBpbnN0YW5jZS5cbiAgICAgICAgICAgICAgICAvLyBGSVhNRTogYXV0byBkZXRlY3QgaXQ/XG4gICAgICAgICAgICAgICAgZGF0YUluZGV4OiBmaW5kZXIuZGF0YUluZGV4XG4gICAgICAgICAgICB9LCBlY01vZGVsKS5wb2ludDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBheGVzSW5mbyA9IGNvb3JkU3lzQXhlc0luZm8uYXhlc0luZm87XG4gICAgICAgIHZhciBzaG91bGRIaWRlID0gY3VyclRyaWdnZXIgPT09ICdsZWF2ZScgfHwgaWxsZWdhbFBvaW50KHBvaW50KTtcbiAgICAgICAgdmFyIG91dHB1dEZpbmRlciA9IHt9O1xuXG4gICAgICAgIHZhciBzaG93VmFsdWVNYXAgPSB7fTtcbiAgICAgICAgdmFyIGRhdGFCeUNvb3JkU3lzID0ge2xpc3Q6IFtdLCBtYXA6IHt9fTtcbiAgICAgICAgdmFyIGhpZ2hsaWdodEJhdGNoID0gW107XG4gICAgICAgIHZhciB1cGRhdGVycyA9IHtcbiAgICAgICAgICAgIHNob3dQb2ludGVyOiBjdXJyeShzaG93UG9pbnRlciwgc2hvd1ZhbHVlTWFwKSxcbiAgICAgICAgICAgIHNob3dUb29sdGlwOiBjdXJyeShzaG93VG9vbHRpcCwgZGF0YUJ5Q29vcmRTeXMpLFxuICAgICAgICAgICAgaGlnaGxpZ2h0OiBjdXJyeShoaWdobGlnaHQsIGhpZ2hsaWdodEJhdGNoKVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFByb2Nlc3MgZm9yIHRyaWdnZXJlZCBheGVzLlxuICAgICAgICBlYWNoKGNvb3JkU3lzQXhlc0luZm8uY29vcmRTeXNNYXAsIGZ1bmN0aW9uIChjb29yZFN5cywgY29vcmRTeXNLZXkpIHtcbiAgICAgICAgICAgIHZhciBjb29yZFN5c0NvbnRhaW5zUG9pbnQgPSBjb29yZFN5cy5jb250YWluUG9pbnQocG9pbnQpO1xuXG4gICAgICAgICAgICBlYWNoKGNvb3JkU3lzQXhlc0luZm8uY29vcmRTeXNBeGVzSW5mb1tjb29yZFN5c0tleV0sIGZ1bmN0aW9uIChheGlzSW5mbywga2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIGF4aXMgPSBheGlzSW5mby5heGlzO1xuICAgICAgICAgICAgICAgIGlmICghc2hvdWxkSGlkZSAmJiBjb29yZFN5c0NvbnRhaW5zUG9pbnQgJiYgIW5vdFRhcmdldEF4aXMoZmluZGVyLCBheGlzKSkge1xuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzT25BeGlzKGF4aXNJbmZvLCBheGlzLnBvaW50VG9EYXRhKHBvaW50KSwgdXBkYXRlcnMsIGZhbHNlLCBvdXRwdXRGaW5kZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBQcm9jZXNzIGZvciBsaW5rZWQgYXhlcy5cbiAgICAgICAgdmFyIGxpbmtUcmlnZ2VycyA9IHt9O1xuICAgICAgICBlYWNoKGF4ZXNJbmZvLCBmdW5jdGlvbiAodGFyQXhpc0luZm8sIHRhcktleSkge1xuICAgICAgICAgICAgdmFyIGxpbmtHcm91cCA9IHRhckF4aXNJbmZvLmxpbmtHcm91cDtcblxuICAgICAgICAgICAgLy8gSWYgYXhpcyBoYXMgYmVlbiB0cmlnZ2VyZWQgaW4gdGhlIHByZXZpb3VzIHN0YWdlLCBpdCBzaG91bGQgbm90IGJlIHRyaWdnZXJlZCBieSBsaW5rLlxuICAgICAgICAgICAgaWYgKGxpbmtHcm91cCAmJiAhc2hvd1ZhbHVlTWFwW3RhcktleV0pIHtcbiAgICAgICAgICAgICAgICBlYWNoKGxpbmtHcm91cC5heGVzSW5mbywgZnVuY3Rpb24gKHNyY0F4aXNJbmZvLCBzcmNLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNyY1ZhbEl0ZW0gPSBzaG93VmFsdWVNYXBbc3JjS2V5XTtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgc3JjVmFsSXRlbSBleGlzdCwgc291cmNlIGF4aXMgaXMgdHJpZ2dlcmVkLCBzbyBsaW5rIHRvIHRhcmdldCBheGlzLlxuICAgICAgICAgICAgICAgICAgICBpZiAoc3JjQXhpc0luZm8gIT09IHRhckF4aXNJbmZvICYmIHNyY1ZhbEl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWwgPSBzcmNWYWxJdGVtLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGlua0dyb3VwLm1hcHBlciAmJiAodmFsID0gdGFyQXhpc0luZm8uYXhpcy5zY2FsZS5wYXJzZShsaW5rR3JvdXAubWFwcGVyKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCwgbWFrZU1hcHBlclBhcmFtKHNyY0F4aXNJbmZvKSwgbWFrZU1hcHBlclBhcmFtKHRhckF4aXNJbmZvKVxuICAgICAgICAgICAgICAgICAgICAgICAgKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGlua1RyaWdnZXJzW3RhckF4aXNJbmZvLmtleV0gPSB2YWw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGVhY2gobGlua1RyaWdnZXJzLCBmdW5jdGlvbiAodmFsLCB0YXJLZXkpIHtcbiAgICAgICAgICAgIHByb2Nlc3NPbkF4aXMoYXhlc0luZm9bdGFyS2V5XSwgdmFsLCB1cGRhdGVycywgdHJ1ZSwgb3V0cHV0RmluZGVyKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdXBkYXRlTW9kZWxBY3R1YWxseShzaG93VmFsdWVNYXAsIGF4ZXNJbmZvKTtcbiAgICAgICAgZGlzcGF0Y2hUb29sdGlwQWN0dWFsbHkoZGF0YUJ5Q29vcmRTeXMsIHBvaW50LCB0b29sdGlwT3B0aW9uLCBkaXNwYXRjaEFjdGlvbik7XG4gICAgICAgIGRpc3BhdGNoSGlnaERvd25BY3R1YWxseShoaWdobGlnaHRCYXRjaCwgZGlzcGF0Y2hBY3Rpb24sIGFwaSwgaGlnaERvd25LZXkpO1xuXG4gICAgICAgIHJldHVybiBvdXRwdXRGaW5kZXI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJvY2Vzc09uQXhpcyhheGlzSW5mbywgbmV3VmFsdWUsIHVwZGF0ZXJzLCBkb250U25hcCwgb3V0cHV0RmluZGVyKSB7XG4gICAgICAgIHZhciBheGlzID0gYXhpc0luZm8uYXhpcztcblxuICAgICAgICBpZiAoYXhpcy5zY2FsZS5pc0JsYW5rKCkgfHwgIWF4aXMuY29udGFpbkRhdGEobmV3VmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWF4aXNJbmZvLmludm9sdmVTZXJpZXMpIHtcbiAgICAgICAgICAgIHVwZGF0ZXJzLnNob3dQb2ludGVyKGF4aXNJbmZvLCBuZXdWYWx1ZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBIZWF2eSBjYWxjdWxhdGlvbi4gU28gcHV0IGl0IGFmdGVyIGF4aXMuY29udGFpbkRhdGEgY2hlY2tpbmcuXG4gICAgICAgIHZhciBwYXlsb2FkSW5mbyA9IGJ1aWxkUGF5bG9hZHNCeVNlcmllcyhuZXdWYWx1ZSwgYXhpc0luZm8pO1xuICAgICAgICB2YXIgcGF5bG9hZEJhdGNoID0gcGF5bG9hZEluZm8ucGF5bG9hZEJhdGNoO1xuICAgICAgICB2YXIgc25hcFRvVmFsdWUgPSBwYXlsb2FkSW5mby5zbmFwVG9WYWx1ZTtcblxuICAgICAgICAvLyBGaWxsIGNvbnRlbnQgb2YgZXZlbnQgb2JqIGZvciBlY2hhcnRzLmNvbm5lY3QuXG4gICAgICAgIC8vIEJ5IGRlZnVhbHQgdXNlIHRoZSBmaXJzdCBpbnZvbHZlZCBzZXJpZXMgZGF0YSBhcyBhIHNhbXBsZSB0byBjb25uZWN0LlxuICAgICAgICBpZiAocGF5bG9hZEJhdGNoWzBdICYmIG91dHB1dEZpbmRlci5zZXJpZXNJbmRleCA9PSBudWxsKSB7XG4gICAgICAgICAgICB6clV0aWwuZXh0ZW5kKG91dHB1dEZpbmRlciwgcGF5bG9hZEJhdGNoWzBdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIG5vIGxpbmtTb3VyY2UgaW5wdXQsIHRoaXMgcHJvY2VzcyBpcyBmb3IgY29sbGVjdGluZyBsaW5rXG4gICAgICAgIC8vIHRhcmdldCwgd2hlcmUgc25hcCBzaG91bGQgbm90IGJlIGFjY2VwdGVkLlxuICAgICAgICBpZiAoIWRvbnRTbmFwICYmIGF4aXNJbmZvLnNuYXApIHtcbiAgICAgICAgICAgIGlmIChheGlzLmNvbnRhaW5EYXRhKHNuYXBUb1ZhbHVlKSAmJiBzbmFwVG9WYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbmV3VmFsdWUgPSBzbmFwVG9WYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHVwZGF0ZXJzLmhpZ2hsaWdodCgnaGlnaGxpZ2h0JywgcGF5bG9hZEJhdGNoKTtcbiAgICAgICAgdXBkYXRlcnMuc2hvd1BvaW50ZXIoYXhpc0luZm8sIG5ld1ZhbHVlLCBwYXlsb2FkQmF0Y2gpO1xuICAgICAgICAvLyBUb29sdGlwIHNob3VsZCBhbHdheXMgYmUgc25hcFRvVmFsdWUsIG90aGVyd2lzZSB0aGVyZSB3aWxsIGJlXG4gICAgICAgIC8vIGluY29ycmVjdCBcImF4aXMgdmFsdWUgfiBzZXJpZXMgdmFsdWVcIiBtYXBwaW5nIGRpc3BsYXllZCBpbiB0b29sdGlwLlxuICAgICAgICB1cGRhdGVycy5zaG93VG9vbHRpcChheGlzSW5mbywgcGF5bG9hZEluZm8sIHNuYXBUb1ZhbHVlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBidWlsZFBheWxvYWRzQnlTZXJpZXModmFsdWUsIGF4aXNJbmZvKSB7XG4gICAgICAgIHZhciBheGlzID0gYXhpc0luZm8uYXhpcztcbiAgICAgICAgdmFyIGRpbSA9IGF4aXMuZGltO1xuICAgICAgICB2YXIgc25hcFRvVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdmFyIHBheWxvYWRCYXRjaCA9IFtdO1xuICAgICAgICB2YXIgbWluRGlzdCA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICAgIHZhciBtaW5EaWZmID0gLTE7XG5cbiAgICAgICAgZWFjaChheGlzSW5mby5zZXJpZXNNb2RlbHMsIGZ1bmN0aW9uIChzZXJpZXMsIGlkeCkge1xuICAgICAgICAgICAgdmFyIGRhdGFEaW0gPSBzZXJpZXMuY29vcmREaW1Ub0RhdGFEaW0oZGltKTtcbiAgICAgICAgICAgIHZhciBzZXJpZXNOZXN0ZXN0VmFsdWU7XG4gICAgICAgICAgICB2YXIgZGF0YUluZGljZXM7XG5cbiAgICAgICAgICAgIGlmIChzZXJpZXMuZ2V0QXhpc1Rvb2x0aXBEYXRhKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHNlcmllcy5nZXRBeGlzVG9vbHRpcERhdGEoZGF0YURpbSwgdmFsdWUsIGF4aXMpO1xuICAgICAgICAgICAgICAgIGRhdGFJbmRpY2VzID0gcmVzdWx0LmRhdGFJbmRpY2VzO1xuICAgICAgICAgICAgICAgIHNlcmllc05lc3Rlc3RWYWx1ZSA9IHJlc3VsdC5uZXN0ZXN0VmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkYXRhSW5kaWNlcyA9IHNlcmllcy5nZXREYXRhKCkuaW5kaWNlc09mTmVhcmVzdChcbiAgICAgICAgICAgICAgICAgICAgZGF0YURpbVswXSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCBhIHRocmVzaG9sZCB0byBhdm9pZCBmaW5kIHRoZSB3cm9uZyBkYXRhSW5kZXhcbiAgICAgICAgICAgICAgICAgICAgLy8gd2hlbiBkYXRhIGxlbmd0aCBpcyBub3Qgc2FtZS5cbiAgICAgICAgICAgICAgICAgICAgZmFsc2UsIGF4aXMudHlwZSA9PT0gJ2NhdGVnb3J5JyA/IDAuNSA6IG51bGxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGlmICghZGF0YUluZGljZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VyaWVzTmVzdGVzdFZhbHVlID0gc2VyaWVzLmdldERhdGEoKS5nZXQoZGF0YURpbVswXSwgZGF0YUluZGljZXNbMF0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2VyaWVzTmVzdGVzdFZhbHVlID09IG51bGwgfHwgIWlzRmluaXRlKHNlcmllc05lc3Rlc3RWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBkaWZmID0gdmFsdWUgLSBzZXJpZXNOZXN0ZXN0VmFsdWU7XG4gICAgICAgICAgICB2YXIgZGlzdCA9IE1hdGguYWJzKGRpZmYpO1xuICAgICAgICAgICAgLy8gQ29uc2lkZXIgY2F0ZWdvcnkgY2FzZVxuICAgICAgICAgICAgaWYgKGRpc3QgPD0gbWluRGlzdCkge1xuICAgICAgICAgICAgICAgIGlmIChkaXN0IDwgbWluRGlzdCB8fCAoZGlmZiA+PSAwICYmIG1pbkRpZmYgPCAwKSkge1xuICAgICAgICAgICAgICAgICAgICBtaW5EaXN0ID0gZGlzdDtcbiAgICAgICAgICAgICAgICAgICAgbWluRGlmZiA9IGRpZmY7XG4gICAgICAgICAgICAgICAgICAgIHNuYXBUb1ZhbHVlID0gc2VyaWVzTmVzdGVzdFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBwYXlsb2FkQmF0Y2gubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWFjaChkYXRhSW5kaWNlcywgZnVuY3Rpb24gKGRhdGFJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBwYXlsb2FkQmF0Y2gucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXNJbmRleDogc2VyaWVzLnNlcmllc0luZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YUluZGV4SW5zaWRlOiBkYXRhSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhSW5kZXg6IHNlcmllcy5nZXREYXRhKCkuZ2V0UmF3SW5kZXgoZGF0YUluZGV4KVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBheWxvYWRCYXRjaDogcGF5bG9hZEJhdGNoLFxuICAgICAgICAgICAgc25hcFRvVmFsdWU6IHNuYXBUb1ZhbHVlXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2hvd1BvaW50ZXIoc2hvd1ZhbHVlTWFwLCBheGlzSW5mbywgdmFsdWUsIHBheWxvYWRCYXRjaCkge1xuICAgICAgICBzaG93VmFsdWVNYXBbYXhpc0luZm8ua2V5XSA9IHt2YWx1ZTogdmFsdWUsIHBheWxvYWRCYXRjaDogcGF5bG9hZEJhdGNofTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzaG93VG9vbHRpcChkYXRhQnlDb29yZFN5cywgYXhpc0luZm8sIHBheWxvYWRJbmZvLCB2YWx1ZSkge1xuICAgICAgICB2YXIgcGF5bG9hZEJhdGNoID0gcGF5bG9hZEluZm8ucGF5bG9hZEJhdGNoO1xuICAgICAgICB2YXIgYXhpcyA9IGF4aXNJbmZvLmF4aXM7XG4gICAgICAgIHZhciBheGlzTW9kZWwgPSBheGlzLm1vZGVsO1xuICAgICAgICB2YXIgYXhpc1BvaW50ZXJNb2RlbCA9IGF4aXNJbmZvLmF4aXNQb2ludGVyTW9kZWw7XG5cbiAgICAgICAgLy8gSWYgbm8gZGF0YSwgZG8gbm90IGNyZWF0ZSBhbnl0aGluZyBpbiBkYXRhQnlDb29yZFN5cyxcbiAgICAgICAgLy8gd2hvc2UgbGVuZ3RoIHdpbGwgYmUgdXNlZCB0byBqdWRnZSB3aGV0aGVyIGRpc3BhdGNoIGFjdGlvbi5cbiAgICAgICAgaWYgKCFheGlzSW5mby50cmlnZ2VyVG9vbHRpcCB8fCAhcGF5bG9hZEJhdGNoLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvb3JkU3lzTW9kZWwgPSBheGlzSW5mby5jb29yZFN5cy5tb2RlbDtcbiAgICAgICAgdmFyIGNvb3JkU3lzS2V5ID0gbW9kZWxIZWxwZXIubWFrZUtleShjb29yZFN5c01vZGVsKTtcbiAgICAgICAgdmFyIGNvb3JkU3lzSXRlbSA9IGRhdGFCeUNvb3JkU3lzLm1hcFtjb29yZFN5c0tleV07XG4gICAgICAgIGlmICghY29vcmRTeXNJdGVtKSB7XG4gICAgICAgICAgICBjb29yZFN5c0l0ZW0gPSBkYXRhQnlDb29yZFN5cy5tYXBbY29vcmRTeXNLZXldID0ge1xuICAgICAgICAgICAgICAgIGNvb3JkU3lzSWQ6IGNvb3JkU3lzTW9kZWwuaWQsXG4gICAgICAgICAgICAgICAgY29vcmRTeXNJbmRleDogY29vcmRTeXNNb2RlbC5jb21wb25lbnRJbmRleCxcbiAgICAgICAgICAgICAgICBjb29yZFN5c1R5cGU6IGNvb3JkU3lzTW9kZWwudHlwZSxcbiAgICAgICAgICAgICAgICBjb29yZFN5c01haW5UeXBlOiBjb29yZFN5c01vZGVsLm1haW5UeXBlLFxuICAgICAgICAgICAgICAgIGRhdGFCeUF4aXM6IFtdXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZGF0YUJ5Q29vcmRTeXMubGlzdC5wdXNoKGNvb3JkU3lzSXRlbSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb29yZFN5c0l0ZW0uZGF0YUJ5QXhpcy5wdXNoKHtcbiAgICAgICAgICAgIGF4aXNEaW06IGF4aXMuZGltLFxuICAgICAgICAgICAgYXhpc0luZGV4OiBheGlzTW9kZWwuY29tcG9uZW50SW5kZXgsXG4gICAgICAgICAgICBheGlzVHlwZTogYXhpc01vZGVsLnR5cGUsXG4gICAgICAgICAgICBheGlzSWQ6IGF4aXNNb2RlbC5pZCxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIC8vIENhdXN0aW9uOiB2aWV3SGVscGVyLmdldFZhbHVlTGFiZWwgaXMgYWN0dWFsbHkgb24gXCJ2aWV3IHN0YWdlXCIsIHdoaWNoXG4gICAgICAgICAgICAvLyBkZXBlbmRzIHRoYXQgYWxsIG1vZGVscyBoYXZlIGJlZW4gdXBkYXRlZC4gU28gaXQgc2hvdWxkIG5vdCBiZSBwZXJmb3JtZWRcbiAgICAgICAgICAgIC8vIGhlcmUuIENvbnNpZGVyaW5nIGF4aXNQb2ludGVyTW9kZWwgdXNlZCBoZXJlIGlzIHZvbGF0aWxlLCB3aGljaCBpcyBoYXJkXG4gICAgICAgICAgICAvLyB0byBiZSByZXRyaWV2ZSBpbiBUb29sdGlwVmlldywgd2UgcHJlcGFyZSBwYXJhbWV0ZXJzIGhlcmUuXG4gICAgICAgICAgICB2YWx1ZUxhYmVsT3B0OiB7XG4gICAgICAgICAgICAgICAgcHJlY2lzaW9uOiBheGlzUG9pbnRlck1vZGVsLmdldCgnbGFiZWwucHJlY2lzaW9uJyksXG4gICAgICAgICAgICAgICAgZm9ybWF0dGVyOiBheGlzUG9pbnRlck1vZGVsLmdldCgnbGFiZWwuZm9ybWF0dGVyJylcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXJpZXNEYXRhSW5kaWNlczogcGF5bG9hZEJhdGNoLnNsaWNlKClcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGlnaGxpZ2h0KGhpZ2hsaWdodEJhdGNoLCBhY3Rpb25UeXBlLCBiYXRjaCkge1xuICAgICAgICBoaWdobGlnaHRCYXRjaC5wdXNoLmFwcGx5KGhpZ2hsaWdodEJhdGNoLCBiYXRjaCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXBkYXRlTW9kZWxBY3R1YWxseShzaG93VmFsdWVNYXAsIGF4ZXNJbmZvKSB7XG4gICAgICAgIC8vIEJhc2ljIGxvZ2ljOiBJZiBubyAnc2hvdycgcmVxdWlyZWQsICdoaWRlJyB0aGlzIGF4aXNQb2ludGVyLlxuICAgICAgICBlYWNoKGF4ZXNJbmZvLCBmdW5jdGlvbiAoYXhpc0luZm8sIGtleSkge1xuICAgICAgICAgICAgdmFyIG9wdGlvbiA9IGF4aXNJbmZvLmF4aXNQb2ludGVyTW9kZWwub3B0aW9uO1xuICAgICAgICAgICAgdmFyIHZhbEl0ZW0gPSBzaG93VmFsdWVNYXBba2V5XTtcblxuICAgICAgICAgICAgaWYgKHZhbEl0ZW0pIHtcbiAgICAgICAgICAgICAgICAhYXhpc0luZm8udXNlSGFuZGxlICYmIChvcHRpb24uc3RhdHVzID0gJ3Nob3cnKTtcbiAgICAgICAgICAgICAgICBvcHRpb24udmFsdWUgPSB2YWxJdGVtLnZhbHVlO1xuICAgICAgICAgICAgICAgIC8vIEZvciBsYWJlbCBmb3JtYXR0ZXIgcGFyYW0uXG4gICAgICAgICAgICAgICAgb3B0aW9uLnNlcmllc0RhdGFJbmRpY2VzID0gKHZhbEl0ZW0ucGF5bG9hZEJhdGNoIHx8IFtdKS5zbGljZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2hlbiBhbHdheXMgc2hvdyAoZS5nLiwgaGFuZGxlIHVzZWQpLCByZW1haW5cbiAgICAgICAgICAgIC8vIG9yaWdpbmFsIHZhbHVlIGFuZCBzdGF0dXMuXG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBoaWRlLCB2YWx1ZSBzdGlsbCBuZWVkIHRvIGJlIHNldCwgY29uc2lkZXJcbiAgICAgICAgICAgICAgICAvLyBjbGljayBsZWdlbmQgdG8gdG9nZ2xlIGF4aXMgYmxhbmsuXG4gICAgICAgICAgICAgICAgIWF4aXNJbmZvLnVzZUhhbmRsZSAmJiAob3B0aW9uLnN0YXR1cyA9ICdoaWRlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRpc3BhdGNoVG9vbHRpcEFjdHVhbGx5KGRhdGFCeUNvb3JkU3lzLCBwb2ludCwgdG9vbHRpcE9wdGlvbiwgZGlzcGF0Y2hBY3Rpb24pIHtcbiAgICAgICAgLy8gQmFzaWMgbG9naWM6IElmIG5vIHNob3dUaXAgcmVxdWlyZWQsIGhpZGVUaXAgd2lsbCBiZSBkaXNwYXRjaGVkLlxuICAgICAgICBpZiAoaWxsZWdhbFBvaW50KHBvaW50KSB8fCAhZGF0YUJ5Q29vcmRTeXMubGlzdC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGRpc3BhdGNoQWN0aW9uKHt0eXBlOiAnaGlkZVRpcCd9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEluIG1vc3QgY2FzZSBvbmx5IG9uZSBheGlzIChvciBldmVudCBvbmUgc2VyaWVzIGlzIHVzZWQpLiBJdCBpc1xuICAgICAgICAvLyBjb252aW5pZW50IHRvIGZldGNoIHBheWxvYWQuc2VyaWVzSW5kZXggYW5kIHBheWxvYWQuZGF0YUluZGV4XG4gICAgICAgIC8vIGRpcnRlY3RseS4gU28gcHV0IHRoZSBmaXJzdCBzZXJpZXNJbmRleCBhbmQgZGF0YUluZGV4IG9mIHRoZSBmaXJzdFxuICAgICAgICAvLyBheGlzIG9uIHRoZSBwYXlsb2FkLlxuICAgICAgICB2YXIgc2FtcGxlSXRlbSA9ICgoZGF0YUJ5Q29vcmRTeXMubGlzdFswXS5kYXRhQnlBeGlzWzBdIHx8IHt9KS5zZXJpZXNEYXRhSW5kaWNlcyB8fCBbXSlbMF0gfHwge307XG5cbiAgICAgICAgZGlzcGF0Y2hBY3Rpb24oe1xuICAgICAgICAgICAgdHlwZTogJ3Nob3dUaXAnLFxuICAgICAgICAgICAgZXNjYXBlQ29ubmVjdDogdHJ1ZSxcbiAgICAgICAgICAgIHg6IHBvaW50WzBdLFxuICAgICAgICAgICAgeTogcG9pbnRbMV0sXG4gICAgICAgICAgICB0b29sdGlwT3B0aW9uOiB0b29sdGlwT3B0aW9uLFxuICAgICAgICAgICAgZGF0YUluZGV4SW5zaWRlOiBzYW1wbGVJdGVtLmRhdGFJbmRleEluc2lkZSxcbiAgICAgICAgICAgIGRhdGFJbmRleDogc2FtcGxlSXRlbS5kYXRhSW5kZXgsXG4gICAgICAgICAgICBzZXJpZXNJbmRleDogc2FtcGxlSXRlbS5zZXJpZXNJbmRleCxcbiAgICAgICAgICAgIGRhdGFCeUNvb3JkU3lzOiBkYXRhQnlDb29yZFN5cy5saXN0XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRpc3BhdGNoSGlnaERvd25BY3R1YWxseShoaWdobGlnaHRCYXRjaCwgZGlzcGF0Y2hBY3Rpb24sIGFwaSwgaGlnaERvd25LZXkpIHtcbiAgICAgICAgLy8gQmFzaWMgbG9naWM6IElmIG5vdGhpbmcgaGlnaGxpZ2h0ZWQsIHNob3VsZCBkb3ducGxheSBhbGwgaGlnaGxpZ2h0ZWQgaXRlbXMuXG4gICAgICAgIC8vIFRoaXMgY2FzZSB3aWxsIG9jY3VyIHdoZW4gbW91c2UgbGVhdmUgY29vcmRTeXMuXG5cbiAgICAgICAgLy8gRklYTUVcbiAgICAgICAgLy8gKDEpIGhpZ2hsaWdodCBzdGF0dXMgc2hvdWxlIGJlIG1hbmFnZW1lbnRlZCBpbiBzZXJpZXMuZ2V0RGF0YSgpP1xuICAgICAgICAvLyAoMikgSWYgYXhpc1BvaW50ZXIgQSB0cmlnZ2VyT24gJ2hhbmRsZScgYW5kIGF4aXNQb2ludGVyIEIgdHJpZ2dlck9uXG4gICAgICAgIC8vICdtb3VzZW1vdmUnLCBpdGVtcyBoaWdobGlnaHRlZCBieSBBIHdpbGwgYmUgZG93bnBsYXllZCBieSBCLlxuICAgICAgICAvLyBJdCB3aWxsIG5vdCBiZSBmaXhlZCB1bnRpbCBzb21lb25lIHJlcXVpcmVzIHRoaXMgc2NlbmFyaW8uXG5cbiAgICAgICAgLy8gQ29uc2lkZXIgaXRlbXMgYXJlYSBoaWdodGxpZ2h0ZWQgYnkgJ2hhbmRsZScsIGFuZCBnbG9iYWxMaXN0ZW5lciBtYXlcbiAgICAgICAgLy8gZG93bnBsYXkgYWxsIGl0ZW1zIChpbmNsdWRpbmcganVzdCBoaWdobGlnaHRlZCBvbmVzKSB3aGVuIG1vdXNlbW92ZS5cbiAgICAgICAgLy8gU28gd2UgdXNlIGEgaGlnaERvd25LZXkgdG8gc2VwYXJhdGUgdGhlbSBhcyBhIHRlbXBvcmFyeSBzb2x1dGlvbi5cbiAgICAgICAgdmFyIHpyID0gYXBpLmdldFpyKCk7XG4gICAgICAgIGhpZ2hEb3duS2V5ID0gJ2xhc3RIaWdobGlnaHRzJyArIChoaWdoRG93bktleSB8fCAnJyk7XG4gICAgICAgIHZhciBsYXN0SGlnaGxpZ2h0cyA9IGdldCh6cilbaGlnaERvd25LZXldIHx8IHt9O1xuICAgICAgICB2YXIgbmV3SGlnaGxpZ2h0cyA9IGdldCh6cilbaGlnaERvd25LZXldID0ge307XG5cbiAgICAgICAgLy8gQnVpbGQgaGFzaCBtYXAgYW5kIHJlbW92ZSBkdXBsaWNhdGUgaW5jaWRlbnRhbGx5LlxuICAgICAgICB6clV0aWwuZWFjaChoaWdobGlnaHRCYXRjaCwgZnVuY3Rpb24gKGJhdGNoSXRlbSkge1xuICAgICAgICAgICAgdmFyIGtleSA9IGJhdGNoSXRlbS5zZXJpZXNJbmRleCArICcgfCAnICsgYmF0Y2hJdGVtLmRhdGFJbmRleDtcbiAgICAgICAgICAgIG5ld0hpZ2hsaWdodHNba2V5XSA9IGJhdGNoSXRlbTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gRGlmZi5cbiAgICAgICAgdmFyIHRvSGlnaGxpZ2h0ID0gW107XG4gICAgICAgIHZhciB0b0Rvd25wbGF5ID0gW107XG4gICAgICAgIHpyVXRpbC5lYWNoKGxhc3RIaWdobGlnaHRzLCBmdW5jdGlvbiAoYmF0Y2hJdGVtLCBrZXkpIHtcbiAgICAgICAgICAgICFuZXdIaWdobGlnaHRzW2tleV0gJiYgdG9Eb3ducGxheS5wdXNoKGJhdGNoSXRlbSk7XG4gICAgICAgIH0pO1xuICAgICAgICB6clV0aWwuZWFjaChuZXdIaWdobGlnaHRzLCBmdW5jdGlvbiAoYmF0Y2hJdGVtLCBrZXkpIHtcbiAgICAgICAgICAgICFsYXN0SGlnaGxpZ2h0c1trZXldICYmIHRvSGlnaGxpZ2h0LnB1c2goYmF0Y2hJdGVtKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdG9Eb3ducGxheS5sZW5ndGggJiYgYXBpLmRpc3BhdGNoQWN0aW9uKHtcbiAgICAgICAgICAgIHR5cGU6ICdkb3ducGxheScsIGVzY2FwZUNvbm5lY3Q6IHRydWUsIGJhdGNoOiB0b0Rvd25wbGF5XG4gICAgICAgIH0pO1xuICAgICAgICB0b0hpZ2hsaWdodC5sZW5ndGggJiYgYXBpLmRpc3BhdGNoQWN0aW9uKHtcbiAgICAgICAgICAgIHR5cGU6ICdoaWdobGlnaHQnLCBlc2NhcGVDb25uZWN0OiB0cnVlLCBiYXRjaDogdG9IaWdobGlnaHRcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbm90VGFyZ2V0QXhpcyhmaW5kZXIsIGF4aXMpIHtcbiAgICAgICAgdmFyIGlzVGFyZ2V0ID0gMTtcbiAgICAgICAgLy8gSWYgbm9uZSBvZiB4eHhBeGlzSWQgYW5kIHh4eEF4aXNOYW1lIGFuZCB4eHhBeGlzSW5kZXggZXhpc3RzIGluIGZpbmRlcixcbiAgICAgICAgLy8gbm8gYXhpcyBpcyBub3QgdGFyZ2V0IGF4aXMuXG4gICAgICAgIGVhY2goZmluZGVyLCBmdW5jdGlvbiAodmFsdWUsIHByb3BOYW1lKSB7XG4gICAgICAgICAgICBpc1RhcmdldCAmPSAhKC9eLisoQXhpc0lkfEF4aXNOYW1lfEF4aXNJbmRleCkkLy50ZXN0KHByb3BOYW1lKSk7XG4gICAgICAgIH0pO1xuICAgICAgICAhaXNUYXJnZXQgJiYgZWFjaChcbiAgICAgICAgICAgIFtbJ0F4aXNJZCcsICdpZCddLCBbJ0F4aXNJbmRleCcsICdjb21wb25lbnRJbmRleCddLCBbJ0F4aXNOYW1lJywgJ25hbWUnXV0sXG4gICAgICAgICAgICBmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgICAgIHZhciB2YWxzID0gbW9kZWxVdGlsLm5vcm1hbGl6ZVRvQXJyYXkoZmluZGVyW2F4aXMuZGltICsgcHJvcFswXV0pO1xuICAgICAgICAgICAgICAgIGlzVGFyZ2V0IHw9IHpyVXRpbC5pbmRleE9mKHZhbHMsIGF4aXMubW9kZWxbcHJvcFsxXV0pID49IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiAhaXNUYXJnZXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZU1hcHBlclBhcmFtKGF4aXNJbmZvKSB7XG4gICAgICAgIHZhciBheGlzTW9kZWwgPSBheGlzSW5mby5heGlzLm1vZGVsO1xuICAgICAgICB2YXIgaXRlbSA9IHt9O1xuICAgICAgICB2YXIgZGltID0gaXRlbS5heGlzRGltID0gYXhpc0luZm8uYXhpcy5kaW07XG4gICAgICAgIGl0ZW0uYXhpc0luZGV4ID0gaXRlbVtkaW0gKyAnQXhpc0luZGV4J10gPSBheGlzTW9kZWwuY29tcG9uZW50SW5kZXg7XG4gICAgICAgIGl0ZW0uYXhpc05hbWUgPSBpdGVtW2RpbSArICdBeGlzTmFtZSddID0gYXhpc01vZGVsLm5hbWU7XG4gICAgICAgIGl0ZW0uYXhpc0lkID0gaXRlbVtkaW0gKyAnQXhpc0lkJ10gPSBheGlzTW9kZWwuaWQ7XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlsbGVnYWxQb2ludChwb2ludCkge1xuICAgICAgICByZXR1cm4gcG9pbnRbMF0gPT0gbnVsbCB8fCBpc05hTihwb2ludFswXSkgfHwgcG9pbnRbMV0gPT0gbnVsbCB8fCBpc05hTihwb2ludFsxXSk7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBheGlzVHJpZ2dlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2NvbXBvbmVudC9heGlzUG9pbnRlci9heGlzVHJpZ2dlci5qc1xuLy8gbW9kdWxlIGlkID0gMjA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 209 */
/* unknown exports provided */
/* all exports used */
/*!*********************************************!*\
  !*** ./lib/component/dataZoom/AxisProxy.js ***!
  \*********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * @file Axis operator\n */\n\n\n    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 0);\n    var numberUtil = __webpack_require__(/*! ../../util/number */ 3);\n    var helper = __webpack_require__(/*! ./helper */ 82);\n    var each = zrUtil.each;\n    var asc = numberUtil.asc;\n\n    /**\n     * Operate single axis.\n     * One axis can only operated by one axis operator.\n     * Different dataZoomModels may be defined to operate the same axis.\n     * (i.e. 'inside' data zoom and 'slider' data zoom components)\n     * So dataZoomModels share one axisProxy in that case.\n     *\n     * @class\n     */\n    var AxisProxy = function (dimName, axisIndex, dataZoomModel, ecModel) {\n\n        /**\n         * @private\n         * @type {string}\n         */\n        this._dimName = dimName;\n\n        /**\n         * @private\n         */\n        this._axisIndex = axisIndex;\n\n        /**\n         * @private\n         * @type {Array.<number>}\n         */\n        this._valueWindow;\n\n        /**\n         * @private\n         * @type {Array.<number>}\n         */\n        this._percentWindow;\n\n        /**\n         * @private\n         * @type {Array.<number>}\n         */\n        this._dataExtent;\n\n        /**\n         * @readOnly\n         * @type {module: echarts/model/Global}\n         */\n        this.ecModel = ecModel;\n\n        /**\n         * @private\n         * @type {module: echarts/component/dataZoom/DataZoomModel}\n         */\n        this._dataZoomModel = dataZoomModel;\n    };\n\n    AxisProxy.prototype = {\n\n        constructor: AxisProxy,\n\n        /**\n         * Whether the axisProxy is hosted by dataZoomModel.\n         *\n         * @public\n         * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel\n         * @return {boolean}\n         */\n        hostedBy: function (dataZoomModel) {\n            return this._dataZoomModel === dataZoomModel;\n        },\n\n        /**\n         * @return {Array.<number>} Value can only be NaN or finite value.\n         */\n        getDataValueWindow: function () {\n            return this._valueWindow.slice();\n        },\n\n        /**\n         * @return {Array.<number>}\n         */\n        getDataPercentWindow: function () {\n            return this._percentWindow.slice();\n        },\n\n        /**\n         * @public\n         * @param {number} axisIndex\n         * @return {Array} seriesModels\n         */\n        getTargetSeriesModels: function () {\n            var seriesModels = [];\n            var ecModel = this.ecModel;\n\n            ecModel.eachSeries(function (seriesModel) {\n                if (helper.isCoordSupported(seriesModel.get('coordinateSystem'))) {\n                    var dimName = this._dimName;\n                    var axisModel = ecModel.queryComponents({\n                        mainType: dimName + 'Axis',\n                        index: seriesModel.get(dimName + 'AxisIndex'),\n                        id: seriesModel.get(dimName + 'AxisId')\n                    })[0];\n                    if (this._axisIndex === (axisModel && axisModel.componentIndex)) {\n                        seriesModels.push(seriesModel);\n                    }\n                }\n            }, this);\n\n            return seriesModels;\n        },\n\n        getAxisModel: function () {\n            return this.ecModel.getComponent(this._dimName + 'Axis', this._axisIndex);\n        },\n\n        getOtherAxisModel: function () {\n            var axisDim = this._dimName;\n            var ecModel = this.ecModel;\n            var axisModel = this.getAxisModel();\n            var isCartesian = axisDim === 'x' || axisDim === 'y';\n            var otherAxisDim;\n            var coordSysIndexName;\n            if (isCartesian) {\n                coordSysIndexName = 'gridIndex';\n                otherAxisDim = axisDim === 'x' ? 'y' : 'x';\n            }\n            else {\n                coordSysIndexName = 'polarIndex';\n                otherAxisDim = axisDim === 'angle' ? 'radius' : 'angle';\n            }\n            var foundOtherAxisModel;\n            ecModel.eachComponent(otherAxisDim + 'Axis', function (otherAxisModel) {\n                if ((otherAxisModel.get(coordSysIndexName) || 0)\n                    === (axisModel.get(coordSysIndexName) || 0)\n                ) {\n                    foundOtherAxisModel = otherAxisModel;\n                }\n            });\n            return foundOtherAxisModel;\n        },\n\n        /**\n         * Only calculate by given range and this._dataExtent, do not change anything.\n         *\n         * @param {Object} opt\n         * @param {number} [opt.start]\n         * @param {number} [opt.end]\n         * @param {number} [opt.startValue]\n         * @param {number} [opt.endValue]\n         */\n        calculateDataWindow: function (opt) {\n            var dataExtent = this._dataExtent;\n            var axisModel = this.getAxisModel();\n            var scale = axisModel.axis.scale;\n            var rangePropMode = this._dataZoomModel.getRangePropMode();\n            var percentExtent = [0, 100];\n            var percentWindow = [\n                opt.start,\n                opt.end\n            ];\n            var valueWindow = [];\n\n            each(['startValue', 'endValue'], function (prop) {\n                valueWindow.push(opt[prop] != null ? scale.parse(opt[prop]) : null);\n            });\n\n            // Normalize bound.\n            each([0, 1], function (idx) {\n                var boundValue = valueWindow[idx];\n                var boundPercent = percentWindow[idx];\n\n                // Notice: dataZoom is based either on `percentProp` ('start', 'end') or\n                // on `valueProp` ('startValue', 'endValue'). The former one is suitable\n                // for cases that a dataZoom component controls multiple axes with different\n                // unit or extent, and the latter one is suitable for accurate zoom by pixel\n                // (e.g., in dataZoomSelect). `valueProp` can be calculated from `percentProp`,\n                // but it is awkward that `percentProp` can not be obtained from `valueProp`\n                // accurately (because all of values that are overflow the `dataExtent` will\n                // be calculated to percent '100%'). So we have to use\n                // `dataZoom.getRangePropMode()` to mark which prop is used.\n                // `rangePropMode` is updated only when setOption or dispatchAction, otherwise\n                // it remains its original value.\n\n                if (rangePropMode[idx] === 'percent') {\n                    if (boundPercent == null) {\n                        boundPercent = percentExtent[idx];\n                    }\n                    // Use scale.parse to math round for category or time axis.\n                    boundValue = scale.parse(numberUtil.linearMap(\n                        boundPercent, percentExtent, dataExtent, true\n                    ));\n                }\n                else {\n                    // Calculating `percent` from `value` may be not accurate, because\n                    // This calculation can not be inversed, because all of values that\n                    // are overflow the `dataExtent` will be calculated to percent '100%'\n                    boundPercent = numberUtil.linearMap(\n                        boundValue, dataExtent, percentExtent, true\n                    );\n                }\n\n                // valueWindow[idx] = round(boundValue);\n                // percentWindow[idx] = round(boundPercent);\n                valueWindow[idx] = boundValue;\n                percentWindow[idx] = boundPercent;\n            });\n\n            return {\n                valueWindow: asc(valueWindow),\n                percentWindow: asc(percentWindow)\n            };\n        },\n\n        /**\n         * Notice: reset should not be called before series.restoreData() called,\n         * so it is recommanded to be called in \"process stage\" but not \"model init\n         * stage\".\n         *\n         * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel\n         */\n        reset: function (dataZoomModel) {\n            if (dataZoomModel !== this._dataZoomModel) {\n                return;\n            }\n\n            // Culculate data window and data extent, and record them.\n            this._dataExtent = calculateDataExtent(\n                this, this._dimName, this.getTargetSeriesModels()\n            );\n\n            var dataWindow = this.calculateDataWindow(dataZoomModel.option);\n\n            this._valueWindow = dataWindow.valueWindow;\n            this._percentWindow = dataWindow.percentWindow;\n\n            // Update axis setting then.\n            setAxisModel(this);\n        },\n\n        /**\n         * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel\n         */\n        restore: function (dataZoomModel) {\n            if (dataZoomModel !== this._dataZoomModel) {\n                return;\n            }\n\n            this._valueWindow = this._percentWindow = null;\n            setAxisModel(this, true);\n        },\n\n        /**\n         * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel\n         */\n        filterData: function (dataZoomModel) {\n            if (dataZoomModel !== this._dataZoomModel) {\n                return;\n            }\n\n            var axisDim = this._dimName;\n            var seriesModels = this.getTargetSeriesModels();\n            var filterMode = dataZoomModel.get('filterMode');\n            var valueWindow = this._valueWindow;\n\n            // FIXME\n            // Toolbox may has dataZoom injected. And if there are stacked bar chart\n            // with NaN data, NaN will be filtered and stack will be wrong.\n            // So we need to force the mode to be set empty.\n            // In fect, it is not a big deal that do not support filterMode-'filter'\n            // when using toolbox#dataZoom, utill tooltip#dataZoom support \"single axis\n            // selection\" some day, which might need \"adapt to data extent on the\n            // otherAxis\", which is disabled by filterMode-'empty'.\n            var otherAxisModel = this.getOtherAxisModel();\n            if (dataZoomModel.get('$fromToolbox')\n                && otherAxisModel\n                && otherAxisModel.get('type') === 'category'\n            ) {\n                filterMode = 'empty';\n            }\n\n            // Process series data\n            each(seriesModels, function (seriesModel) {\n                var seriesData = seriesModel.getData();\n\n                seriesData && each(seriesModel.coordDimToDataDim(axisDim), function (dim) {\n                    if (filterMode === 'empty') {\n                        seriesModel.setData(\n                            seriesData.map(dim, function (value) {\n                                return !isInWindow(value) ? NaN : value;\n                            })\n                        );\n                    }\n                    else {\n                        seriesData.filterSelf(dim, isInWindow);\n                    }\n                });\n            });\n\n            function isInWindow(value) {\n                return value >= valueWindow[0] && value <= valueWindow[1];\n            }\n        }\n    };\n\n    function calculateDataExtent(axisProxy, axisDim, seriesModels) {\n        var dataExtent = [Infinity, -Infinity];\n\n        each(seriesModels, function (seriesModel) {\n            var seriesData = seriesModel.getData();\n            if (seriesData) {\n                each(seriesModel.coordDimToDataDim(axisDim), function (dim) {\n                    var seriesExtent = seriesData.getDataExtent(dim);\n                    seriesExtent[0] < dataExtent[0] && (dataExtent[0] = seriesExtent[0]);\n                    seriesExtent[1] > dataExtent[1] && (dataExtent[1] = seriesExtent[1]);\n                });\n            }\n        });\n\n        if (dataExtent[1] < dataExtent[0]) {\n            dataExtent = [NaN, NaN];\n        }\n\n        // It is important to get \"consistent\" extent when more then one axes is\n        // controlled by a `dataZoom`, otherwise those axes will not be synchronized\n        // when zooming. But it is difficult to know what is \"consistent\", considering\n        // axes have different type or even different meanings (For example, two\n        // time axes are used to compare data of the same date in different years).\n        // So basically dataZoom just obtains extent by series.data (in category axis\n        // extent can be obtained from axis.data).\n        // Nevertheless, user can set min/max/scale on axes to make extent of axes\n        // consistent.\n        fixExtentByAxis(axisProxy, dataExtent);\n\n        return dataExtent;\n    }\n\n    function fixExtentByAxis(axisProxy, dataExtent) {\n        var axisModel = axisProxy.getAxisModel();\n        var min = axisModel.getMin(true);\n\n        // For category axis, if min/max/scale are not set, extent is determined\n        // by axis.data by default.\n        var isCategoryAxis = axisModel.get('type') === 'category';\n        var axisDataLen = isCategoryAxis && (axisModel.get('data') || []).length;\n\n        if (min != null && min !== 'dataMin') {\n            dataExtent[0] = min;\n        }\n        else if (isCategoryAxis) {\n            dataExtent[0] = axisDataLen > 0 ? 0 : NaN;\n        }\n\n        var max = axisModel.getMax(true);\n        if (max != null && max !== 'dataMax') {\n            dataExtent[1] = max;\n        }\n        else if (isCategoryAxis) {\n            dataExtent[1] = axisDataLen > 0 ? axisDataLen - 1 : NaN;\n        }\n\n        if (!axisModel.get('scale', true)) {\n            dataExtent[0] > 0 && (dataExtent[0] = 0);\n            dataExtent[1] < 0 && (dataExtent[1] = 0);\n        }\n\n        // For value axis, if min/max/scale are not set, we just use the extent obtained\n        // by series data, which may be a little different from the extent calculated by\n        // `axisHelper.getScaleExtent`. But the different just affects the experience a\n        // little when zooming. So it will not be fixed until some users require it strongly.\n\n        return dataExtent;\n    }\n\n    function setAxisModel(axisProxy, isRestore) {\n        var axisModel = axisProxy.getAxisModel();\n\n        var percentWindow = axisProxy._percentWindow;\n        var valueWindow = axisProxy._valueWindow;\n\n        if (!percentWindow) {\n            return;\n        }\n\n        // [0, 500]: arbitrary value, guess axis extent.\n        var precision = numberUtil.getPixelPrecision(valueWindow, [0, 500]);\n        // isRestore or isFull\n        var useOrigin = isRestore || (percentWindow[0] === 0 && percentWindow[1] === 100);\n\n        axisModel.setRange(\n            useOrigin ? null : +valueWindow[0].toFixed(precision),\n            useOrigin ? null : +valueWindow[1].toFixed(precision)\n        );\n    }\n\n    module.exports = AxisProxy;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjA5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2NvbXBvbmVudC9kYXRhWm9vbS9BeGlzUHJveHkuanM/MDQyOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlIEF4aXMgb3BlcmF0b3JcbiAqL1xuXG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG4gICAgdmFyIG51bWJlclV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL251bWJlcicpO1xuICAgIHZhciBoZWxwZXIgPSByZXF1aXJlKCcuL2hlbHBlcicpO1xuICAgIHZhciBlYWNoID0genJVdGlsLmVhY2g7XG4gICAgdmFyIGFzYyA9IG51bWJlclV0aWwuYXNjO1xuXG4gICAgLyoqXG4gICAgICogT3BlcmF0ZSBzaW5nbGUgYXhpcy5cbiAgICAgKiBPbmUgYXhpcyBjYW4gb25seSBvcGVyYXRlZCBieSBvbmUgYXhpcyBvcGVyYXRvci5cbiAgICAgKiBEaWZmZXJlbnQgZGF0YVpvb21Nb2RlbHMgbWF5IGJlIGRlZmluZWQgdG8gb3BlcmF0ZSB0aGUgc2FtZSBheGlzLlxuICAgICAqIChpLmUuICdpbnNpZGUnIGRhdGEgem9vbSBhbmQgJ3NsaWRlcicgZGF0YSB6b29tIGNvbXBvbmVudHMpXG4gICAgICogU28gZGF0YVpvb21Nb2RlbHMgc2hhcmUgb25lIGF4aXNQcm94eSBpbiB0aGF0IGNhc2UuXG4gICAgICpcbiAgICAgKiBAY2xhc3NcbiAgICAgKi9cbiAgICB2YXIgQXhpc1Byb3h5ID0gZnVuY3Rpb24gKGRpbU5hbWUsIGF4aXNJbmRleCwgZGF0YVpvb21Nb2RlbCwgZWNNb2RlbCkge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fZGltTmFtZSA9IGRpbU5hbWU7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9heGlzSW5kZXggPSBheGlzSW5kZXg7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3ZhbHVlV2luZG93O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9wZXJjZW50V2luZG93O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9kYXRhRXh0ZW50O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmVhZE9ubHlcbiAgICAgICAgICogQHR5cGUge21vZHVsZTogZWNoYXJ0cy9tb2RlbC9HbG9iYWx9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmVjTW9kZWwgPSBlY01vZGVsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7bW9kdWxlOiBlY2hhcnRzL2NvbXBvbmVudC9kYXRhWm9vbS9EYXRhWm9vbU1vZGVsfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fZGF0YVpvb21Nb2RlbCA9IGRhdGFab29tTW9kZWw7XG4gICAgfTtcblxuICAgIEF4aXNQcm94eS5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IEF4aXNQcm94eSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgYXhpc1Byb3h5IGlzIGhvc3RlZCBieSBkYXRhWm9vbU1vZGVsLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHVibGljXG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOiBlY2hhcnRzL2NvbXBvbmVudC9kYXRhWm9vbS9EYXRhWm9vbU1vZGVsfSBkYXRhWm9vbU1vZGVsXG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBob3N0ZWRCeTogZnVuY3Rpb24gKGRhdGFab29tTW9kZWwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhWm9vbU1vZGVsID09PSBkYXRhWm9vbU1vZGVsO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn0gVmFsdWUgY2FuIG9ubHkgYmUgTmFOIG9yIGZpbml0ZSB2YWx1ZS5cbiAgICAgICAgICovXG4gICAgICAgIGdldERhdGFWYWx1ZVdpbmRvdzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlV2luZG93LnNsaWNlKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0RGF0YVBlcmNlbnRXaW5kb3c6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wZXJjZW50V2luZG93LnNsaWNlKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwdWJsaWNcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGF4aXNJbmRleFxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheX0gc2VyaWVzTW9kZWxzXG4gICAgICAgICAqL1xuICAgICAgICBnZXRUYXJnZXRTZXJpZXNNb2RlbHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzZXJpZXNNb2RlbHMgPSBbXTtcbiAgICAgICAgICAgIHZhciBlY01vZGVsID0gdGhpcy5lY01vZGVsO1xuXG4gICAgICAgICAgICBlY01vZGVsLmVhY2hTZXJpZXMoZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhlbHBlci5pc0Nvb3JkU3VwcG9ydGVkKHNlcmllc01vZGVsLmdldCgnY29vcmRpbmF0ZVN5c3RlbScpKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGltTmFtZSA9IHRoaXMuX2RpbU5hbWU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBheGlzTW9kZWwgPSBlY01vZGVsLnF1ZXJ5Q29tcG9uZW50cyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYWluVHlwZTogZGltTmFtZSArICdBeGlzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBzZXJpZXNNb2RlbC5nZXQoZGltTmFtZSArICdBeGlzSW5kZXgnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBzZXJpZXNNb2RlbC5nZXQoZGltTmFtZSArICdBeGlzSWQnKVxuICAgICAgICAgICAgICAgICAgICB9KVswXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2F4aXNJbmRleCA9PT0gKGF4aXNNb2RlbCAmJiBheGlzTW9kZWwuY29tcG9uZW50SW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXNNb2RlbHMucHVzaChzZXJpZXNNb2RlbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgcmV0dXJuIHNlcmllc01vZGVscztcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRBeGlzTW9kZWw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVjTW9kZWwuZ2V0Q29tcG9uZW50KHRoaXMuX2RpbU5hbWUgKyAnQXhpcycsIHRoaXMuX2F4aXNJbmRleCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0T3RoZXJBeGlzTW9kZWw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBheGlzRGltID0gdGhpcy5fZGltTmFtZTtcbiAgICAgICAgICAgIHZhciBlY01vZGVsID0gdGhpcy5lY01vZGVsO1xuICAgICAgICAgICAgdmFyIGF4aXNNb2RlbCA9IHRoaXMuZ2V0QXhpc01vZGVsKCk7XG4gICAgICAgICAgICB2YXIgaXNDYXJ0ZXNpYW4gPSBheGlzRGltID09PSAneCcgfHwgYXhpc0RpbSA9PT0gJ3knO1xuICAgICAgICAgICAgdmFyIG90aGVyQXhpc0RpbTtcbiAgICAgICAgICAgIHZhciBjb29yZFN5c0luZGV4TmFtZTtcbiAgICAgICAgICAgIGlmIChpc0NhcnRlc2lhbikge1xuICAgICAgICAgICAgICAgIGNvb3JkU3lzSW5kZXhOYW1lID0gJ2dyaWRJbmRleCc7XG4gICAgICAgICAgICAgICAgb3RoZXJBeGlzRGltID0gYXhpc0RpbSA9PT0gJ3gnID8gJ3knIDogJ3gnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29vcmRTeXNJbmRleE5hbWUgPSAncG9sYXJJbmRleCc7XG4gICAgICAgICAgICAgICAgb3RoZXJBeGlzRGltID0gYXhpc0RpbSA9PT0gJ2FuZ2xlJyA/ICdyYWRpdXMnIDogJ2FuZ2xlJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBmb3VuZE90aGVyQXhpc01vZGVsO1xuICAgICAgICAgICAgZWNNb2RlbC5lYWNoQ29tcG9uZW50KG90aGVyQXhpc0RpbSArICdBeGlzJywgZnVuY3Rpb24gKG90aGVyQXhpc01vZGVsKSB7XG4gICAgICAgICAgICAgICAgaWYgKChvdGhlckF4aXNNb2RlbC5nZXQoY29vcmRTeXNJbmRleE5hbWUpIHx8IDApXG4gICAgICAgICAgICAgICAgICAgID09PSAoYXhpc01vZGVsLmdldChjb29yZFN5c0luZGV4TmFtZSkgfHwgMClcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgZm91bmRPdGhlckF4aXNNb2RlbCA9IG90aGVyQXhpc01vZGVsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGZvdW5kT3RoZXJBeGlzTW9kZWw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9ubHkgY2FsY3VsYXRlIGJ5IGdpdmVuIHJhbmdlIGFuZCB0aGlzLl9kYXRhRXh0ZW50LCBkbyBub3QgY2hhbmdlIGFueXRoaW5nLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0XG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0LnN0YXJ0XVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdC5lbmRdXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0LnN0YXJ0VmFsdWVdXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0LmVuZFZhbHVlXVxuICAgICAgICAgKi9cbiAgICAgICAgY2FsY3VsYXRlRGF0YVdpbmRvdzogZnVuY3Rpb24gKG9wdCkge1xuICAgICAgICAgICAgdmFyIGRhdGFFeHRlbnQgPSB0aGlzLl9kYXRhRXh0ZW50O1xuICAgICAgICAgICAgdmFyIGF4aXNNb2RlbCA9IHRoaXMuZ2V0QXhpc01vZGVsKCk7XG4gICAgICAgICAgICB2YXIgc2NhbGUgPSBheGlzTW9kZWwuYXhpcy5zY2FsZTtcbiAgICAgICAgICAgIHZhciByYW5nZVByb3BNb2RlID0gdGhpcy5fZGF0YVpvb21Nb2RlbC5nZXRSYW5nZVByb3BNb2RlKCk7XG4gICAgICAgICAgICB2YXIgcGVyY2VudEV4dGVudCA9IFswLCAxMDBdO1xuICAgICAgICAgICAgdmFyIHBlcmNlbnRXaW5kb3cgPSBbXG4gICAgICAgICAgICAgICAgb3B0LnN0YXJ0LFxuICAgICAgICAgICAgICAgIG9wdC5lbmRcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICB2YXIgdmFsdWVXaW5kb3cgPSBbXTtcblxuICAgICAgICAgICAgZWFjaChbJ3N0YXJ0VmFsdWUnLCAnZW5kVmFsdWUnXSwgZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgICAgICB2YWx1ZVdpbmRvdy5wdXNoKG9wdFtwcm9wXSAhPSBudWxsID8gc2NhbGUucGFyc2Uob3B0W3Byb3BdKSA6IG51bGwpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIE5vcm1hbGl6ZSBib3VuZC5cbiAgICAgICAgICAgIGVhY2goWzAsIDFdLCBmdW5jdGlvbiAoaWR4KSB7XG4gICAgICAgICAgICAgICAgdmFyIGJvdW5kVmFsdWUgPSB2YWx1ZVdpbmRvd1tpZHhdO1xuICAgICAgICAgICAgICAgIHZhciBib3VuZFBlcmNlbnQgPSBwZXJjZW50V2luZG93W2lkeF07XG5cbiAgICAgICAgICAgICAgICAvLyBOb3RpY2U6IGRhdGFab29tIGlzIGJhc2VkIGVpdGhlciBvbiBgcGVyY2VudFByb3BgICgnc3RhcnQnLCAnZW5kJykgb3JcbiAgICAgICAgICAgICAgICAvLyBvbiBgdmFsdWVQcm9wYCAoJ3N0YXJ0VmFsdWUnLCAnZW5kVmFsdWUnKS4gVGhlIGZvcm1lciBvbmUgaXMgc3VpdGFibGVcbiAgICAgICAgICAgICAgICAvLyBmb3IgY2FzZXMgdGhhdCBhIGRhdGFab29tIGNvbXBvbmVudCBjb250cm9scyBtdWx0aXBsZSBheGVzIHdpdGggZGlmZmVyZW50XG4gICAgICAgICAgICAgICAgLy8gdW5pdCBvciBleHRlbnQsIGFuZCB0aGUgbGF0dGVyIG9uZSBpcyBzdWl0YWJsZSBmb3IgYWNjdXJhdGUgem9vbSBieSBwaXhlbFxuICAgICAgICAgICAgICAgIC8vIChlLmcuLCBpbiBkYXRhWm9vbVNlbGVjdCkuIGB2YWx1ZVByb3BgIGNhbiBiZSBjYWxjdWxhdGVkIGZyb20gYHBlcmNlbnRQcm9wYCxcbiAgICAgICAgICAgICAgICAvLyBidXQgaXQgaXMgYXdrd2FyZCB0aGF0IGBwZXJjZW50UHJvcGAgY2FuIG5vdCBiZSBvYnRhaW5lZCBmcm9tIGB2YWx1ZVByb3BgXG4gICAgICAgICAgICAgICAgLy8gYWNjdXJhdGVseSAoYmVjYXVzZSBhbGwgb2YgdmFsdWVzIHRoYXQgYXJlIG92ZXJmbG93IHRoZSBgZGF0YUV4dGVudGAgd2lsbFxuICAgICAgICAgICAgICAgIC8vIGJlIGNhbGN1bGF0ZWQgdG8gcGVyY2VudCAnMTAwJScpLiBTbyB3ZSBoYXZlIHRvIHVzZVxuICAgICAgICAgICAgICAgIC8vIGBkYXRhWm9vbS5nZXRSYW5nZVByb3BNb2RlKClgIHRvIG1hcmsgd2hpY2ggcHJvcCBpcyB1c2VkLlxuICAgICAgICAgICAgICAgIC8vIGByYW5nZVByb3BNb2RlYCBpcyB1cGRhdGVkIG9ubHkgd2hlbiBzZXRPcHRpb24gb3IgZGlzcGF0Y2hBY3Rpb24sIG90aGVyd2lzZVxuICAgICAgICAgICAgICAgIC8vIGl0IHJlbWFpbnMgaXRzIG9yaWdpbmFsIHZhbHVlLlxuXG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlUHJvcE1vZGVbaWR4XSA9PT0gJ3BlcmNlbnQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChib3VuZFBlcmNlbnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYm91bmRQZXJjZW50ID0gcGVyY2VudEV4dGVudFtpZHhdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFVzZSBzY2FsZS5wYXJzZSB0byBtYXRoIHJvdW5kIGZvciBjYXRlZ29yeSBvciB0aW1lIGF4aXMuXG4gICAgICAgICAgICAgICAgICAgIGJvdW5kVmFsdWUgPSBzY2FsZS5wYXJzZShudW1iZXJVdGlsLmxpbmVhck1hcChcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvdW5kUGVyY2VudCwgcGVyY2VudEV4dGVudCwgZGF0YUV4dGVudCwgdHJ1ZVxuICAgICAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0aW5nIGBwZXJjZW50YCBmcm9tIGB2YWx1ZWAgbWF5IGJlIG5vdCBhY2N1cmF0ZSwgYmVjYXVzZVxuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGNhbGN1bGF0aW9uIGNhbiBub3QgYmUgaW52ZXJzZWQsIGJlY2F1c2UgYWxsIG9mIHZhbHVlcyB0aGF0XG4gICAgICAgICAgICAgICAgICAgIC8vIGFyZSBvdmVyZmxvdyB0aGUgYGRhdGFFeHRlbnRgIHdpbGwgYmUgY2FsY3VsYXRlZCB0byBwZXJjZW50ICcxMDAlJ1xuICAgICAgICAgICAgICAgICAgICBib3VuZFBlcmNlbnQgPSBudW1iZXJVdGlsLmxpbmVhck1hcChcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvdW5kVmFsdWUsIGRhdGFFeHRlbnQsIHBlcmNlbnRFeHRlbnQsIHRydWVcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyB2YWx1ZVdpbmRvd1tpZHhdID0gcm91bmQoYm91bmRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgLy8gcGVyY2VudFdpbmRvd1tpZHhdID0gcm91bmQoYm91bmRQZXJjZW50KTtcbiAgICAgICAgICAgICAgICB2YWx1ZVdpbmRvd1tpZHhdID0gYm91bmRWYWx1ZTtcbiAgICAgICAgICAgICAgICBwZXJjZW50V2luZG93W2lkeF0gPSBib3VuZFBlcmNlbnQ7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB2YWx1ZVdpbmRvdzogYXNjKHZhbHVlV2luZG93KSxcbiAgICAgICAgICAgICAgICBwZXJjZW50V2luZG93OiBhc2MocGVyY2VudFdpbmRvdylcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5vdGljZTogcmVzZXQgc2hvdWxkIG5vdCBiZSBjYWxsZWQgYmVmb3JlIHNlcmllcy5yZXN0b3JlRGF0YSgpIGNhbGxlZCxcbiAgICAgICAgICogc28gaXQgaXMgcmVjb21tYW5kZWQgdG8gYmUgY2FsbGVkIGluIFwicHJvY2VzcyBzdGFnZVwiIGJ1dCBub3QgXCJtb2RlbCBpbml0XG4gICAgICAgICAqIHN0YWdlXCIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOiBlY2hhcnRzL2NvbXBvbmVudC9kYXRhWm9vbS9EYXRhWm9vbU1vZGVsfSBkYXRhWm9vbU1vZGVsXG4gICAgICAgICAqL1xuICAgICAgICByZXNldDogZnVuY3Rpb24gKGRhdGFab29tTW9kZWwpIHtcbiAgICAgICAgICAgIGlmIChkYXRhWm9vbU1vZGVsICE9PSB0aGlzLl9kYXRhWm9vbU1vZGVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDdWxjdWxhdGUgZGF0YSB3aW5kb3cgYW5kIGRhdGEgZXh0ZW50LCBhbmQgcmVjb3JkIHRoZW0uXG4gICAgICAgICAgICB0aGlzLl9kYXRhRXh0ZW50ID0gY2FsY3VsYXRlRGF0YUV4dGVudChcbiAgICAgICAgICAgICAgICB0aGlzLCB0aGlzLl9kaW1OYW1lLCB0aGlzLmdldFRhcmdldFNlcmllc01vZGVscygpXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICB2YXIgZGF0YVdpbmRvdyA9IHRoaXMuY2FsY3VsYXRlRGF0YVdpbmRvdyhkYXRhWm9vbU1vZGVsLm9wdGlvbik7XG5cbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlV2luZG93ID0gZGF0YVdpbmRvdy52YWx1ZVdpbmRvdztcbiAgICAgICAgICAgIHRoaXMuX3BlcmNlbnRXaW5kb3cgPSBkYXRhV2luZG93LnBlcmNlbnRXaW5kb3c7XG5cbiAgICAgICAgICAgIC8vIFVwZGF0ZSBheGlzIHNldHRpbmcgdGhlbi5cbiAgICAgICAgICAgIHNldEF4aXNNb2RlbCh0aGlzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6IGVjaGFydHMvY29tcG9uZW50L2RhdGFab29tL0RhdGFab29tTW9kZWx9IGRhdGFab29tTW9kZWxcbiAgICAgICAgICovXG4gICAgICAgIHJlc3RvcmU6IGZ1bmN0aW9uIChkYXRhWm9vbU1vZGVsKSB7XG4gICAgICAgICAgICBpZiAoZGF0YVpvb21Nb2RlbCAhPT0gdGhpcy5fZGF0YVpvb21Nb2RlbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fdmFsdWVXaW5kb3cgPSB0aGlzLl9wZXJjZW50V2luZG93ID0gbnVsbDtcbiAgICAgICAgICAgIHNldEF4aXNNb2RlbCh0aGlzLCB0cnVlKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6IGVjaGFydHMvY29tcG9uZW50L2RhdGFab29tL0RhdGFab29tTW9kZWx9IGRhdGFab29tTW9kZWxcbiAgICAgICAgICovXG4gICAgICAgIGZpbHRlckRhdGE6IGZ1bmN0aW9uIChkYXRhWm9vbU1vZGVsKSB7XG4gICAgICAgICAgICBpZiAoZGF0YVpvb21Nb2RlbCAhPT0gdGhpcy5fZGF0YVpvb21Nb2RlbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGF4aXNEaW0gPSB0aGlzLl9kaW1OYW1lO1xuICAgICAgICAgICAgdmFyIHNlcmllc01vZGVscyA9IHRoaXMuZ2V0VGFyZ2V0U2VyaWVzTW9kZWxzKCk7XG4gICAgICAgICAgICB2YXIgZmlsdGVyTW9kZSA9IGRhdGFab29tTW9kZWwuZ2V0KCdmaWx0ZXJNb2RlJyk7XG4gICAgICAgICAgICB2YXIgdmFsdWVXaW5kb3cgPSB0aGlzLl92YWx1ZVdpbmRvdztcblxuICAgICAgICAgICAgLy8gRklYTUVcbiAgICAgICAgICAgIC8vIFRvb2xib3ggbWF5IGhhcyBkYXRhWm9vbSBpbmplY3RlZC4gQW5kIGlmIHRoZXJlIGFyZSBzdGFja2VkIGJhciBjaGFydFxuICAgICAgICAgICAgLy8gd2l0aCBOYU4gZGF0YSwgTmFOIHdpbGwgYmUgZmlsdGVyZWQgYW5kIHN0YWNrIHdpbGwgYmUgd3JvbmcuXG4gICAgICAgICAgICAvLyBTbyB3ZSBuZWVkIHRvIGZvcmNlIHRoZSBtb2RlIHRvIGJlIHNldCBlbXB0eS5cbiAgICAgICAgICAgIC8vIEluIGZlY3QsIGl0IGlzIG5vdCBhIGJpZyBkZWFsIHRoYXQgZG8gbm90IHN1cHBvcnQgZmlsdGVyTW9kZS0nZmlsdGVyJ1xuICAgICAgICAgICAgLy8gd2hlbiB1c2luZyB0b29sYm94I2RhdGFab29tLCB1dGlsbCB0b29sdGlwI2RhdGFab29tIHN1cHBvcnQgXCJzaW5nbGUgYXhpc1xuICAgICAgICAgICAgLy8gc2VsZWN0aW9uXCIgc29tZSBkYXksIHdoaWNoIG1pZ2h0IG5lZWQgXCJhZGFwdCB0byBkYXRhIGV4dGVudCBvbiB0aGVcbiAgICAgICAgICAgIC8vIG90aGVyQXhpc1wiLCB3aGljaCBpcyBkaXNhYmxlZCBieSBmaWx0ZXJNb2RlLSdlbXB0eScuXG4gICAgICAgICAgICB2YXIgb3RoZXJBeGlzTW9kZWwgPSB0aGlzLmdldE90aGVyQXhpc01vZGVsKCk7XG4gICAgICAgICAgICBpZiAoZGF0YVpvb21Nb2RlbC5nZXQoJyRmcm9tVG9vbGJveCcpXG4gICAgICAgICAgICAgICAgJiYgb3RoZXJBeGlzTW9kZWxcbiAgICAgICAgICAgICAgICAmJiBvdGhlckF4aXNNb2RlbC5nZXQoJ3R5cGUnKSA9PT0gJ2NhdGVnb3J5J1xuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgZmlsdGVyTW9kZSA9ICdlbXB0eSc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFByb2Nlc3Mgc2VyaWVzIGRhdGFcbiAgICAgICAgICAgIGVhY2goc2VyaWVzTW9kZWxzLCBmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VyaWVzRGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcblxuICAgICAgICAgICAgICAgIHNlcmllc0RhdGEgJiYgZWFjaChzZXJpZXNNb2RlbC5jb29yZERpbVRvRGF0YURpbShheGlzRGltKSwgZnVuY3Rpb24gKGRpbSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmlsdGVyTW9kZSA9PT0gJ2VtcHR5Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzTW9kZWwuc2V0RGF0YShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXNEYXRhLm1hcChkaW0sIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gIWlzSW5XaW5kb3codmFsdWUpID8gTmFOIDogdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXNEYXRhLmZpbHRlclNlbGYoZGltLCBpc0luV2luZG93KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGlzSW5XaW5kb3codmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgPj0gdmFsdWVXaW5kb3dbMF0gJiYgdmFsdWUgPD0gdmFsdWVXaW5kb3dbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gY2FsY3VsYXRlRGF0YUV4dGVudChheGlzUHJveHksIGF4aXNEaW0sIHNlcmllc01vZGVscykge1xuICAgICAgICB2YXIgZGF0YUV4dGVudCA9IFtJbmZpbml0eSwgLUluZmluaXR5XTtcblxuICAgICAgICBlYWNoKHNlcmllc01vZGVscywgZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICAgICAgICB2YXIgc2VyaWVzRGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICAgICAgICAgIGlmIChzZXJpZXNEYXRhKSB7XG4gICAgICAgICAgICAgICAgZWFjaChzZXJpZXNNb2RlbC5jb29yZERpbVRvRGF0YURpbShheGlzRGltKSwgZnVuY3Rpb24gKGRpbSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2VyaWVzRXh0ZW50ID0gc2VyaWVzRGF0YS5nZXREYXRhRXh0ZW50KGRpbSk7XG4gICAgICAgICAgICAgICAgICAgIHNlcmllc0V4dGVudFswXSA8IGRhdGFFeHRlbnRbMF0gJiYgKGRhdGFFeHRlbnRbMF0gPSBzZXJpZXNFeHRlbnRbMF0pO1xuICAgICAgICAgICAgICAgICAgICBzZXJpZXNFeHRlbnRbMV0gPiBkYXRhRXh0ZW50WzFdICYmIChkYXRhRXh0ZW50WzFdID0gc2VyaWVzRXh0ZW50WzFdKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGRhdGFFeHRlbnRbMV0gPCBkYXRhRXh0ZW50WzBdKSB7XG4gICAgICAgICAgICBkYXRhRXh0ZW50ID0gW05hTiwgTmFOXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEl0IGlzIGltcG9ydGFudCB0byBnZXQgXCJjb25zaXN0ZW50XCIgZXh0ZW50IHdoZW4gbW9yZSB0aGVuIG9uZSBheGVzIGlzXG4gICAgICAgIC8vIGNvbnRyb2xsZWQgYnkgYSBgZGF0YVpvb21gLCBvdGhlcndpc2UgdGhvc2UgYXhlcyB3aWxsIG5vdCBiZSBzeW5jaHJvbml6ZWRcbiAgICAgICAgLy8gd2hlbiB6b29taW5nLiBCdXQgaXQgaXMgZGlmZmljdWx0IHRvIGtub3cgd2hhdCBpcyBcImNvbnNpc3RlbnRcIiwgY29uc2lkZXJpbmdcbiAgICAgICAgLy8gYXhlcyBoYXZlIGRpZmZlcmVudCB0eXBlIG9yIGV2ZW4gZGlmZmVyZW50IG1lYW5pbmdzIChGb3IgZXhhbXBsZSwgdHdvXG4gICAgICAgIC8vIHRpbWUgYXhlcyBhcmUgdXNlZCB0byBjb21wYXJlIGRhdGEgb2YgdGhlIHNhbWUgZGF0ZSBpbiBkaWZmZXJlbnQgeWVhcnMpLlxuICAgICAgICAvLyBTbyBiYXNpY2FsbHkgZGF0YVpvb20ganVzdCBvYnRhaW5zIGV4dGVudCBieSBzZXJpZXMuZGF0YSAoaW4gY2F0ZWdvcnkgYXhpc1xuICAgICAgICAvLyBleHRlbnQgY2FuIGJlIG9idGFpbmVkIGZyb20gYXhpcy5kYXRhKS5cbiAgICAgICAgLy8gTmV2ZXJ0aGVsZXNzLCB1c2VyIGNhbiBzZXQgbWluL21heC9zY2FsZSBvbiBheGVzIHRvIG1ha2UgZXh0ZW50IG9mIGF4ZXNcbiAgICAgICAgLy8gY29uc2lzdGVudC5cbiAgICAgICAgZml4RXh0ZW50QnlBeGlzKGF4aXNQcm94eSwgZGF0YUV4dGVudCk7XG5cbiAgICAgICAgcmV0dXJuIGRhdGFFeHRlbnQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZml4RXh0ZW50QnlBeGlzKGF4aXNQcm94eSwgZGF0YUV4dGVudCkge1xuICAgICAgICB2YXIgYXhpc01vZGVsID0gYXhpc1Byb3h5LmdldEF4aXNNb2RlbCgpO1xuICAgICAgICB2YXIgbWluID0gYXhpc01vZGVsLmdldE1pbih0cnVlKTtcblxuICAgICAgICAvLyBGb3IgY2F0ZWdvcnkgYXhpcywgaWYgbWluL21heC9zY2FsZSBhcmUgbm90IHNldCwgZXh0ZW50IGlzIGRldGVybWluZWRcbiAgICAgICAgLy8gYnkgYXhpcy5kYXRhIGJ5IGRlZmF1bHQuXG4gICAgICAgIHZhciBpc0NhdGVnb3J5QXhpcyA9IGF4aXNNb2RlbC5nZXQoJ3R5cGUnKSA9PT0gJ2NhdGVnb3J5JztcbiAgICAgICAgdmFyIGF4aXNEYXRhTGVuID0gaXNDYXRlZ29yeUF4aXMgJiYgKGF4aXNNb2RlbC5nZXQoJ2RhdGEnKSB8fCBbXSkubGVuZ3RoO1xuXG4gICAgICAgIGlmIChtaW4gIT0gbnVsbCAmJiBtaW4gIT09ICdkYXRhTWluJykge1xuICAgICAgICAgICAgZGF0YUV4dGVudFswXSA9IG1pbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0NhdGVnb3J5QXhpcykge1xuICAgICAgICAgICAgZGF0YUV4dGVudFswXSA9IGF4aXNEYXRhTGVuID4gMCA/IDAgOiBOYU47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWF4ID0gYXhpc01vZGVsLmdldE1heCh0cnVlKTtcbiAgICAgICAgaWYgKG1heCAhPSBudWxsICYmIG1heCAhPT0gJ2RhdGFNYXgnKSB7XG4gICAgICAgICAgICBkYXRhRXh0ZW50WzFdID0gbWF4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzQ2F0ZWdvcnlBeGlzKSB7XG4gICAgICAgICAgICBkYXRhRXh0ZW50WzFdID0gYXhpc0RhdGFMZW4gPiAwID8gYXhpc0RhdGFMZW4gLSAxIDogTmFOO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFheGlzTW9kZWwuZ2V0KCdzY2FsZScsIHRydWUpKSB7XG4gICAgICAgICAgICBkYXRhRXh0ZW50WzBdID4gMCAmJiAoZGF0YUV4dGVudFswXSA9IDApO1xuICAgICAgICAgICAgZGF0YUV4dGVudFsxXSA8IDAgJiYgKGRhdGFFeHRlbnRbMV0gPSAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZvciB2YWx1ZSBheGlzLCBpZiBtaW4vbWF4L3NjYWxlIGFyZSBub3Qgc2V0LCB3ZSBqdXN0IHVzZSB0aGUgZXh0ZW50IG9idGFpbmVkXG4gICAgICAgIC8vIGJ5IHNlcmllcyBkYXRhLCB3aGljaCBtYXkgYmUgYSBsaXR0bGUgZGlmZmVyZW50IGZyb20gdGhlIGV4dGVudCBjYWxjdWxhdGVkIGJ5XG4gICAgICAgIC8vIGBheGlzSGVscGVyLmdldFNjYWxlRXh0ZW50YC4gQnV0IHRoZSBkaWZmZXJlbnQganVzdCBhZmZlY3RzIHRoZSBleHBlcmllbmNlIGFcbiAgICAgICAgLy8gbGl0dGxlIHdoZW4gem9vbWluZy4gU28gaXQgd2lsbCBub3QgYmUgZml4ZWQgdW50aWwgc29tZSB1c2VycyByZXF1aXJlIGl0IHN0cm9uZ2x5LlxuXG4gICAgICAgIHJldHVybiBkYXRhRXh0ZW50O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldEF4aXNNb2RlbChheGlzUHJveHksIGlzUmVzdG9yZSkge1xuICAgICAgICB2YXIgYXhpc01vZGVsID0gYXhpc1Byb3h5LmdldEF4aXNNb2RlbCgpO1xuXG4gICAgICAgIHZhciBwZXJjZW50V2luZG93ID0gYXhpc1Byb3h5Ll9wZXJjZW50V2luZG93O1xuICAgICAgICB2YXIgdmFsdWVXaW5kb3cgPSBheGlzUHJveHkuX3ZhbHVlV2luZG93O1xuXG4gICAgICAgIGlmICghcGVyY2VudFdpbmRvdykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gWzAsIDUwMF06IGFyYml0cmFyeSB2YWx1ZSwgZ3Vlc3MgYXhpcyBleHRlbnQuXG4gICAgICAgIHZhciBwcmVjaXNpb24gPSBudW1iZXJVdGlsLmdldFBpeGVsUHJlY2lzaW9uKHZhbHVlV2luZG93LCBbMCwgNTAwXSk7XG4gICAgICAgIC8vIGlzUmVzdG9yZSBvciBpc0Z1bGxcbiAgICAgICAgdmFyIHVzZU9yaWdpbiA9IGlzUmVzdG9yZSB8fCAocGVyY2VudFdpbmRvd1swXSA9PT0gMCAmJiBwZXJjZW50V2luZG93WzFdID09PSAxMDApO1xuXG4gICAgICAgIGF4aXNNb2RlbC5zZXRSYW5nZShcbiAgICAgICAgICAgIHVzZU9yaWdpbiA/IG51bGwgOiArdmFsdWVXaW5kb3dbMF0udG9GaXhlZChwcmVjaXNpb24pLFxuICAgICAgICAgICAgdXNlT3JpZ2luID8gbnVsbCA6ICt2YWx1ZVdpbmRvd1sxXS50b0ZpeGVkKHByZWNpc2lvbilcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IEF4aXNQcm94eTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvY29tcG9uZW50L2RhdGFab29tL0F4aXNQcm94eS5qc1xuLy8gbW9kdWxlIGlkID0gMjA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 210 */
/* unknown exports provided */
/* all exports used */
/*!***************************************************!*\
  !*** ./lib/component/dataZoom/InsideZoomModel.js ***!
  \***************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * @file Data zoom model\n */\n\n\n    module.exports = __webpack_require__(/*! ./DataZoomModel */ 46).extend({\n\n        type: 'dataZoom.inside',\n\n        /**\n         * @protected\n         */\n        defaultOption: {\n            disabled: false,   // Whether disable this inside zoom.\n            zoomLock: false  // Whether disable zoom but only pan.\n        }\n    });\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjEwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2NvbXBvbmVudC9kYXRhWm9vbS9JbnNpZGVab29tTW9kZWwuanM/NzdiMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlIERhdGEgem9vbSBtb2RlbFxuICovXG5cblxuICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9EYXRhWm9vbU1vZGVsJykuZXh0ZW5kKHtcblxuICAgICAgICB0eXBlOiAnZGF0YVpvb20uaW5zaWRlJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgZGVmYXVsdE9wdGlvbjoge1xuICAgICAgICAgICAgZGlzYWJsZWQ6IGZhbHNlLCAgIC8vIFdoZXRoZXIgZGlzYWJsZSB0aGlzIGluc2lkZSB6b29tLlxuICAgICAgICAgICAgem9vbUxvY2s6IGZhbHNlICAvLyBXaGV0aGVyIGRpc2FibGUgem9vbSBidXQgb25seSBwYW4uXG4gICAgICAgIH1cbiAgICB9KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2NvbXBvbmVudC9kYXRhWm9vbS9JbnNpZGVab29tTW9kZWwuanNcbi8vIG1vZHVsZSBpZCA9IDIxMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 211 */
/* unknown exports provided */
/* all exports used */
/*!**************************************************!*\
  !*** ./lib/component/dataZoom/InsideZoomView.js ***!
  \**************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var DataZoomView = __webpack_require__(/*! ./DataZoomView */ 47);\n    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 0);\n    var sliderMove = __webpack_require__(/*! ../helper/sliderMove */ 84);\n    var roams = __webpack_require__(/*! ./roams */ 216);\n    var bind = zrUtil.bind;\n\n    var InsideZoomView = DataZoomView.extend({\n\n        type: 'dataZoom.inside',\n\n        /**\n         * @override\n         */\n        init: function (ecModel, api) {\n            /**\n             * 'throttle' is used in this.dispatchAction, so we save range\n             * to avoid missing some 'pan' info.\n             * @private\n             * @type {Array.<number>}\n             */\n            this._range;\n        },\n\n        /**\n         * @override\n         */\n        render: function (dataZoomModel, ecModel, api, payload) {\n            InsideZoomView.superApply(this, 'render', arguments);\n\n            // Notice: origin this._range should be maintained, and should not be re-fetched\n            // from dataZoomModel when payload.type is 'dataZoom', otherwise 'pan' or 'zoom'\n            // info will be missed because of 'throttle' of this.dispatchAction.\n            if (roams.shouldRecordRange(payload, dataZoomModel.id)) {\n                this._range = dataZoomModel.getPercentRange();\n            }\n\n            // Reset controllers.\n            zrUtil.each(this.getTargetCoordInfo(), function (coordInfoList, coordSysName) {\n\n                var allCoordIds = zrUtil.map(coordInfoList, function (coordInfo) {\n                    return roams.generateCoordId(coordInfo.model);\n                });\n\n                zrUtil.each(coordInfoList, function (coordInfo) {\n                    var coordModel = coordInfo.model;\n\n                    roams.register(\n                        api,\n                        {\n                            coordId: roams.generateCoordId(coordModel),\n                            allCoordIds: allCoordIds,\n                            containsPoint: function (e, x, y) {\n                                return coordModel.coordinateSystem.containPoint([x, y]);\n                            },\n                            dataZoomId: dataZoomModel.id,\n                            throttleRate: dataZoomModel.get('throttle', true),\n                            panGetRange: bind(this._onPan, this, coordInfo, coordSysName),\n                            zoomGetRange: bind(this._onZoom, this, coordInfo, coordSysName)\n                        }\n                    );\n                }, this);\n\n            }, this);\n        },\n\n        /**\n         * @override\n         */\n        dispose: function () {\n            roams.unregister(this.api, this.dataZoomModel.id);\n            InsideZoomView.superApply(this, 'dispose', arguments);\n            this._range = null;\n        },\n\n        /**\n         * @private\n         */\n        _onPan: function (coordInfo, coordSysName, controller, dx, dy, oldX, oldY, newX, newY) {\n            if (this.dataZoomModel.option.disabled) {\n                return this._range;\n            }\n\n            var range = this._range.slice();\n\n            // Calculate transform by the first axis.\n            var axisModel = coordInfo.axisModels[0];\n            if (!axisModel) {\n                return;\n            }\n\n            var directionInfo = getDirectionInfo[coordSysName](\n                [oldX, oldY], [newX, newY], axisModel, controller, coordInfo\n            );\n\n            var percentDelta = directionInfo.signal\n                * (range[1] - range[0])\n                * directionInfo.pixel / directionInfo.pixelLength;\n\n            sliderMove(percentDelta, range, [0, 100], 'rigid');\n\n            return (this._range = range);\n        },\n\n        /**\n         * @private\n         */\n        _onZoom: function (coordInfo, coordSysName, controller, scale, mouseX, mouseY) {\n            var option = this.dataZoomModel.option;\n\n            if (option.disabled || option.zoomLock) {\n                return this._range;\n            }\n\n            var range = this._range.slice();\n\n            // Calculate transform by the first axis.\n            var axisModel = coordInfo.axisModels[0];\n            if (!axisModel) {\n                return;\n            }\n\n            var directionInfo = getDirectionInfo[coordSysName](\n                null, [mouseX, mouseY], axisModel, controller, coordInfo\n            );\n\n            var percentPoint = (directionInfo.pixel - directionInfo.pixelStart) /\n                directionInfo.pixelLength * (range[1] - range[0]) + range[0];\n\n            scale = Math.max(1 / scale, 0);\n            range[0] = (range[0] - percentPoint) * scale + percentPoint;\n            range[1] = (range[1] - percentPoint) * scale + percentPoint;\n            return (this._range = fixRange(range));\n        }\n\n    });\n\n    var getDirectionInfo = {\n\n        grid: function (oldPoint, newPoint, axisModel, controller, coordInfo) {\n            var axis = axisModel.axis;\n            var ret = {};\n            var rect = coordInfo.model.coordinateSystem.getRect();\n            oldPoint = oldPoint || [0, 0];\n\n            if (axis.dim === 'x') {\n                ret.pixel = newPoint[0] - oldPoint[0];\n                ret.pixelLength = rect.width;\n                ret.pixelStart = rect.x;\n                ret.signal = axis.inverse ? 1 : -1;\n            }\n            else { // axis.dim === 'y'\n                ret.pixel = newPoint[1] - oldPoint[1];\n                ret.pixelLength = rect.height;\n                ret.pixelStart = rect.y;\n                ret.signal = axis.inverse ? -1 : 1;\n            }\n\n            return ret;\n        },\n\n        polar: function (oldPoint, newPoint, axisModel, controller, coordInfo) {\n            var axis = axisModel.axis;\n            var ret = {};\n            var polar = coordInfo.model.coordinateSystem;\n            var radiusExtent = polar.getRadiusAxis().getExtent();\n            var angleExtent = polar.getAngleAxis().getExtent();\n\n            oldPoint = oldPoint ? polar.pointToCoord(oldPoint) : [0, 0];\n            newPoint = polar.pointToCoord(newPoint);\n\n            if (axisModel.mainType === 'radiusAxis') {\n                ret.pixel = newPoint[0] - oldPoint[0];\n                // ret.pixelLength = Math.abs(radiusExtent[1] - radiusExtent[0]);\n                // ret.pixelStart = Math.min(radiusExtent[0], radiusExtent[1]);\n                ret.pixelLength = radiusExtent[1] - radiusExtent[0];\n                ret.pixelStart = radiusExtent[0];\n                ret.signal = axis.inverse ? 1 : -1;\n            }\n            else { // 'angleAxis'\n                ret.pixel = newPoint[1] - oldPoint[1];\n                // ret.pixelLength = Math.abs(angleExtent[1] - angleExtent[0]);\n                // ret.pixelStart = Math.min(angleExtent[0], angleExtent[1]);\n                ret.pixelLength = angleExtent[1] - angleExtent[0];\n                ret.pixelStart = angleExtent[0];\n                ret.signal = axis.inverse ? -1 : 1;\n            }\n\n            return ret;\n        },\n\n        singleAxis: function (oldPoint, newPoint, axisModel, controller, coordInfo) {\n            var axis = axisModel.axis;\n            var rect = coordInfo.model.coordinateSystem.getRect();\n            var ret = {};\n\n            oldPoint = oldPoint || [0, 0];\n\n            if (axis.orient === 'horizontal') {\n                ret.pixel = newPoint[0] - oldPoint[0];\n                ret.pixelLength = rect.width;\n                ret.pixelStart = rect.x;\n                ret.signal = axis.inverse ? 1 : -1;\n            }\n            else { // 'vertical'\n                ret.pixel = newPoint[1] - oldPoint[1];\n                ret.pixelLength = rect.height;\n                ret.pixelStart = rect.y;\n                ret.signal = axis.inverse ? -1 : 1;\n            }\n\n            return ret;\n        }\n    };\n\n    function fixRange(range) {\n        // Clamp, using !(<= or >=) to handle NaN.\n        // jshint ignore:start\n        var bound = [0, 100];\n        !(range[0] <= bound[1]) && (range[0] = bound[1]);\n        !(range[1] <= bound[1]) && (range[1] = bound[1]);\n        !(range[0] >= bound[0]) && (range[0] = bound[0]);\n        !(range[1] >= bound[0]) && (range[1] = bound[0]);\n        // jshint ignore:end\n\n        return range;\n    }\n\n    module.exports = InsideZoomView;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjExLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2NvbXBvbmVudC9kYXRhWm9vbS9JbnNpZGVab29tVmlldy5qcz8xZDZjIl0sInNvdXJjZXNDb250ZW50IjpbIlxuXG4gICAgdmFyIERhdGFab29tVmlldyA9IHJlcXVpcmUoJy4vRGF0YVpvb21WaWV3Jyk7XG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuICAgIHZhciBzbGlkZXJNb3ZlID0gcmVxdWlyZSgnLi4vaGVscGVyL3NsaWRlck1vdmUnKTtcbiAgICB2YXIgcm9hbXMgPSByZXF1aXJlKCcuL3JvYW1zJyk7XG4gICAgdmFyIGJpbmQgPSB6clV0aWwuYmluZDtcblxuICAgIHZhciBJbnNpZGVab29tVmlldyA9IERhdGFab29tVmlldy5leHRlbmQoe1xuXG4gICAgICAgIHR5cGU6ICdkYXRhWm9vbS5pbnNpZGUnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAb3ZlcnJpZGVcbiAgICAgICAgICovXG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogJ3Rocm90dGxlJyBpcyB1c2VkIGluIHRoaXMuZGlzcGF0Y2hBY3Rpb24sIHNvIHdlIHNhdmUgcmFuZ2VcbiAgICAgICAgICAgICAqIHRvIGF2b2lkIG1pc3Npbmcgc29tZSAncGFuJyBpbmZvLlxuICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5fcmFuZ2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICAgKi9cbiAgICAgICAgcmVuZGVyOiBmdW5jdGlvbiAoZGF0YVpvb21Nb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKSB7XG4gICAgICAgICAgICBJbnNpZGVab29tVmlldy5zdXBlckFwcGx5KHRoaXMsICdyZW5kZXInLCBhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICAvLyBOb3RpY2U6IG9yaWdpbiB0aGlzLl9yYW5nZSBzaG91bGQgYmUgbWFpbnRhaW5lZCwgYW5kIHNob3VsZCBub3QgYmUgcmUtZmV0Y2hlZFxuICAgICAgICAgICAgLy8gZnJvbSBkYXRhWm9vbU1vZGVsIHdoZW4gcGF5bG9hZC50eXBlIGlzICdkYXRhWm9vbScsIG90aGVyd2lzZSAncGFuJyBvciAnem9vbSdcbiAgICAgICAgICAgIC8vIGluZm8gd2lsbCBiZSBtaXNzZWQgYmVjYXVzZSBvZiAndGhyb3R0bGUnIG9mIHRoaXMuZGlzcGF0Y2hBY3Rpb24uXG4gICAgICAgICAgICBpZiAocm9hbXMuc2hvdWxkUmVjb3JkUmFuZ2UocGF5bG9hZCwgZGF0YVpvb21Nb2RlbC5pZCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yYW5nZSA9IGRhdGFab29tTW9kZWwuZ2V0UGVyY2VudFJhbmdlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJlc2V0IGNvbnRyb2xsZXJzLlxuICAgICAgICAgICAgenJVdGlsLmVhY2godGhpcy5nZXRUYXJnZXRDb29yZEluZm8oKSwgZnVuY3Rpb24gKGNvb3JkSW5mb0xpc3QsIGNvb3JkU3lzTmFtZSkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGFsbENvb3JkSWRzID0genJVdGlsLm1hcChjb29yZEluZm9MaXN0LCBmdW5jdGlvbiAoY29vcmRJbmZvKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByb2Ftcy5nZW5lcmF0ZUNvb3JkSWQoY29vcmRJbmZvLm1vZGVsKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHpyVXRpbC5lYWNoKGNvb3JkSW5mb0xpc3QsIGZ1bmN0aW9uIChjb29yZEluZm8pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvb3JkTW9kZWwgPSBjb29yZEluZm8ubW9kZWw7XG5cbiAgICAgICAgICAgICAgICAgICAgcm9hbXMucmVnaXN0ZXIoXG4gICAgICAgICAgICAgICAgICAgICAgICBhcGksXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29vcmRJZDogcm9hbXMuZ2VuZXJhdGVDb29yZElkKGNvb3JkTW9kZWwpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbENvb3JkSWRzOiBhbGxDb29yZElkcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250YWluc1BvaW50OiBmdW5jdGlvbiAoZSwgeCwgeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29vcmRNb2RlbC5jb29yZGluYXRlU3lzdGVtLmNvbnRhaW5Qb2ludChbeCwgeV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVpvb21JZDogZGF0YVpvb21Nb2RlbC5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdHRsZVJhdGU6IGRhdGFab29tTW9kZWwuZ2V0KCd0aHJvdHRsZScsIHRydWUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhbkdldFJhbmdlOiBiaW5kKHRoaXMuX29uUGFuLCB0aGlzLCBjb29yZEluZm8sIGNvb3JkU3lzTmFtZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgem9vbUdldFJhbmdlOiBiaW5kKHRoaXMuX29uWm9vbSwgdGhpcywgY29vcmRJbmZvLCBjb29yZFN5c05hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAb3ZlcnJpZGVcbiAgICAgICAgICovXG4gICAgICAgIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJvYW1zLnVucmVnaXN0ZXIodGhpcy5hcGksIHRoaXMuZGF0YVpvb21Nb2RlbC5pZCk7XG4gICAgICAgICAgICBJbnNpZGVab29tVmlldy5zdXBlckFwcGx5KHRoaXMsICdkaXNwb3NlJywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHRoaXMuX3JhbmdlID0gbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF9vblBhbjogZnVuY3Rpb24gKGNvb3JkSW5mbywgY29vcmRTeXNOYW1lLCBjb250cm9sbGVyLCBkeCwgZHksIG9sZFgsIG9sZFksIG5ld1gsIG5ld1kpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRhdGFab29tTW9kZWwub3B0aW9uLmRpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JhbmdlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSB0aGlzLl9yYW5nZS5zbGljZSgpO1xuXG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgdHJhbnNmb3JtIGJ5IHRoZSBmaXJzdCBheGlzLlxuICAgICAgICAgICAgdmFyIGF4aXNNb2RlbCA9IGNvb3JkSW5mby5heGlzTW9kZWxzWzBdO1xuICAgICAgICAgICAgaWYgKCFheGlzTW9kZWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBkaXJlY3Rpb25JbmZvID0gZ2V0RGlyZWN0aW9uSW5mb1tjb29yZFN5c05hbWVdKFxuICAgICAgICAgICAgICAgIFtvbGRYLCBvbGRZXSwgW25ld1gsIG5ld1ldLCBheGlzTW9kZWwsIGNvbnRyb2xsZXIsIGNvb3JkSW5mb1xuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgdmFyIHBlcmNlbnREZWx0YSA9IGRpcmVjdGlvbkluZm8uc2lnbmFsXG4gICAgICAgICAgICAgICAgKiAocmFuZ2VbMV0gLSByYW5nZVswXSlcbiAgICAgICAgICAgICAgICAqIGRpcmVjdGlvbkluZm8ucGl4ZWwgLyBkaXJlY3Rpb25JbmZvLnBpeGVsTGVuZ3RoO1xuXG4gICAgICAgICAgICBzbGlkZXJNb3ZlKHBlcmNlbnREZWx0YSwgcmFuZ2UsIFswLCAxMDBdLCAncmlnaWQnKTtcblxuICAgICAgICAgICAgcmV0dXJuICh0aGlzLl9yYW5nZSA9IHJhbmdlKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF9vblpvb206IGZ1bmN0aW9uIChjb29yZEluZm8sIGNvb3JkU3lzTmFtZSwgY29udHJvbGxlciwgc2NhbGUsIG1vdXNlWCwgbW91c2VZKSB7XG4gICAgICAgICAgICB2YXIgb3B0aW9uID0gdGhpcy5kYXRhWm9vbU1vZGVsLm9wdGlvbjtcblxuICAgICAgICAgICAgaWYgKG9wdGlvbi5kaXNhYmxlZCB8fCBvcHRpb24uem9vbUxvY2spIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmFuZ2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciByYW5nZSA9IHRoaXMuX3JhbmdlLnNsaWNlKCk7XG5cbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0cmFuc2Zvcm0gYnkgdGhlIGZpcnN0IGF4aXMuXG4gICAgICAgICAgICB2YXIgYXhpc01vZGVsID0gY29vcmRJbmZvLmF4aXNNb2RlbHNbMF07XG4gICAgICAgICAgICBpZiAoIWF4aXNNb2RlbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGRpcmVjdGlvbkluZm8gPSBnZXREaXJlY3Rpb25JbmZvW2Nvb3JkU3lzTmFtZV0oXG4gICAgICAgICAgICAgICAgbnVsbCwgW21vdXNlWCwgbW91c2VZXSwgYXhpc01vZGVsLCBjb250cm9sbGVyLCBjb29yZEluZm9cbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHZhciBwZXJjZW50UG9pbnQgPSAoZGlyZWN0aW9uSW5mby5waXhlbCAtIGRpcmVjdGlvbkluZm8ucGl4ZWxTdGFydCkgL1xuICAgICAgICAgICAgICAgIGRpcmVjdGlvbkluZm8ucGl4ZWxMZW5ndGggKiAocmFuZ2VbMV0gLSByYW5nZVswXSkgKyByYW5nZVswXTtcblxuICAgICAgICAgICAgc2NhbGUgPSBNYXRoLm1heCgxIC8gc2NhbGUsIDApO1xuICAgICAgICAgICAgcmFuZ2VbMF0gPSAocmFuZ2VbMF0gLSBwZXJjZW50UG9pbnQpICogc2NhbGUgKyBwZXJjZW50UG9pbnQ7XG4gICAgICAgICAgICByYW5nZVsxXSA9IChyYW5nZVsxXSAtIHBlcmNlbnRQb2ludCkgKiBzY2FsZSArIHBlcmNlbnRQb2ludDtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5fcmFuZ2UgPSBmaXhSYW5nZShyYW5nZSkpO1xuICAgICAgICB9XG5cbiAgICB9KTtcblxuICAgIHZhciBnZXREaXJlY3Rpb25JbmZvID0ge1xuXG4gICAgICAgIGdyaWQ6IGZ1bmN0aW9uIChvbGRQb2ludCwgbmV3UG9pbnQsIGF4aXNNb2RlbCwgY29udHJvbGxlciwgY29vcmRJbmZvKSB7XG4gICAgICAgICAgICB2YXIgYXhpcyA9IGF4aXNNb2RlbC5heGlzO1xuICAgICAgICAgICAgdmFyIHJldCA9IHt9O1xuICAgICAgICAgICAgdmFyIHJlY3QgPSBjb29yZEluZm8ubW9kZWwuY29vcmRpbmF0ZVN5c3RlbS5nZXRSZWN0KCk7XG4gICAgICAgICAgICBvbGRQb2ludCA9IG9sZFBvaW50IHx8IFswLCAwXTtcblxuICAgICAgICAgICAgaWYgKGF4aXMuZGltID09PSAneCcpIHtcbiAgICAgICAgICAgICAgICByZXQucGl4ZWwgPSBuZXdQb2ludFswXSAtIG9sZFBvaW50WzBdO1xuICAgICAgICAgICAgICAgIHJldC5waXhlbExlbmd0aCA9IHJlY3Qud2lkdGg7XG4gICAgICAgICAgICAgICAgcmV0LnBpeGVsU3RhcnQgPSByZWN0Lng7XG4gICAgICAgICAgICAgICAgcmV0LnNpZ25hbCA9IGF4aXMuaW52ZXJzZSA/IDEgOiAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgeyAvLyBheGlzLmRpbSA9PT0gJ3knXG4gICAgICAgICAgICAgICAgcmV0LnBpeGVsID0gbmV3UG9pbnRbMV0gLSBvbGRQb2ludFsxXTtcbiAgICAgICAgICAgICAgICByZXQucGl4ZWxMZW5ndGggPSByZWN0LmhlaWdodDtcbiAgICAgICAgICAgICAgICByZXQucGl4ZWxTdGFydCA9IHJlY3QueTtcbiAgICAgICAgICAgICAgICByZXQuc2lnbmFsID0gYXhpcy5pbnZlcnNlID8gLTEgOiAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9LFxuXG4gICAgICAgIHBvbGFyOiBmdW5jdGlvbiAob2xkUG9pbnQsIG5ld1BvaW50LCBheGlzTW9kZWwsIGNvbnRyb2xsZXIsIGNvb3JkSW5mbykge1xuICAgICAgICAgICAgdmFyIGF4aXMgPSBheGlzTW9kZWwuYXhpcztcbiAgICAgICAgICAgIHZhciByZXQgPSB7fTtcbiAgICAgICAgICAgIHZhciBwb2xhciA9IGNvb3JkSW5mby5tb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICAgICAgICAgICAgdmFyIHJhZGl1c0V4dGVudCA9IHBvbGFyLmdldFJhZGl1c0F4aXMoKS5nZXRFeHRlbnQoKTtcbiAgICAgICAgICAgIHZhciBhbmdsZUV4dGVudCA9IHBvbGFyLmdldEFuZ2xlQXhpcygpLmdldEV4dGVudCgpO1xuXG4gICAgICAgICAgICBvbGRQb2ludCA9IG9sZFBvaW50ID8gcG9sYXIucG9pbnRUb0Nvb3JkKG9sZFBvaW50KSA6IFswLCAwXTtcbiAgICAgICAgICAgIG5ld1BvaW50ID0gcG9sYXIucG9pbnRUb0Nvb3JkKG5ld1BvaW50KTtcblxuICAgICAgICAgICAgaWYgKGF4aXNNb2RlbC5tYWluVHlwZSA9PT0gJ3JhZGl1c0F4aXMnKSB7XG4gICAgICAgICAgICAgICAgcmV0LnBpeGVsID0gbmV3UG9pbnRbMF0gLSBvbGRQb2ludFswXTtcbiAgICAgICAgICAgICAgICAvLyByZXQucGl4ZWxMZW5ndGggPSBNYXRoLmFicyhyYWRpdXNFeHRlbnRbMV0gLSByYWRpdXNFeHRlbnRbMF0pO1xuICAgICAgICAgICAgICAgIC8vIHJldC5waXhlbFN0YXJ0ID0gTWF0aC5taW4ocmFkaXVzRXh0ZW50WzBdLCByYWRpdXNFeHRlbnRbMV0pO1xuICAgICAgICAgICAgICAgIHJldC5waXhlbExlbmd0aCA9IHJhZGl1c0V4dGVudFsxXSAtIHJhZGl1c0V4dGVudFswXTtcbiAgICAgICAgICAgICAgICByZXQucGl4ZWxTdGFydCA9IHJhZGl1c0V4dGVudFswXTtcbiAgICAgICAgICAgICAgICByZXQuc2lnbmFsID0gYXhpcy5pbnZlcnNlID8gMSA6IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7IC8vICdhbmdsZUF4aXMnXG4gICAgICAgICAgICAgICAgcmV0LnBpeGVsID0gbmV3UG9pbnRbMV0gLSBvbGRQb2ludFsxXTtcbiAgICAgICAgICAgICAgICAvLyByZXQucGl4ZWxMZW5ndGggPSBNYXRoLmFicyhhbmdsZUV4dGVudFsxXSAtIGFuZ2xlRXh0ZW50WzBdKTtcbiAgICAgICAgICAgICAgICAvLyByZXQucGl4ZWxTdGFydCA9IE1hdGgubWluKGFuZ2xlRXh0ZW50WzBdLCBhbmdsZUV4dGVudFsxXSk7XG4gICAgICAgICAgICAgICAgcmV0LnBpeGVsTGVuZ3RoID0gYW5nbGVFeHRlbnRbMV0gLSBhbmdsZUV4dGVudFswXTtcbiAgICAgICAgICAgICAgICByZXQucGl4ZWxTdGFydCA9IGFuZ2xlRXh0ZW50WzBdO1xuICAgICAgICAgICAgICAgIHJldC5zaWduYWwgPSBheGlzLmludmVyc2UgPyAtMSA6IDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2luZ2xlQXhpczogZnVuY3Rpb24gKG9sZFBvaW50LCBuZXdQb2ludCwgYXhpc01vZGVsLCBjb250cm9sbGVyLCBjb29yZEluZm8pIHtcbiAgICAgICAgICAgIHZhciBheGlzID0gYXhpc01vZGVsLmF4aXM7XG4gICAgICAgICAgICB2YXIgcmVjdCA9IGNvb3JkSW5mby5tb2RlbC5jb29yZGluYXRlU3lzdGVtLmdldFJlY3QoKTtcbiAgICAgICAgICAgIHZhciByZXQgPSB7fTtcblxuICAgICAgICAgICAgb2xkUG9pbnQgPSBvbGRQb2ludCB8fCBbMCwgMF07XG5cbiAgICAgICAgICAgIGlmIChheGlzLm9yaWVudCA9PT0gJ2hvcml6b250YWwnKSB7XG4gICAgICAgICAgICAgICAgcmV0LnBpeGVsID0gbmV3UG9pbnRbMF0gLSBvbGRQb2ludFswXTtcbiAgICAgICAgICAgICAgICByZXQucGl4ZWxMZW5ndGggPSByZWN0LndpZHRoO1xuICAgICAgICAgICAgICAgIHJldC5waXhlbFN0YXJ0ID0gcmVjdC54O1xuICAgICAgICAgICAgICAgIHJldC5zaWduYWwgPSBheGlzLmludmVyc2UgPyAxIDogLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHsgLy8gJ3ZlcnRpY2FsJ1xuICAgICAgICAgICAgICAgIHJldC5waXhlbCA9IG5ld1BvaW50WzFdIC0gb2xkUG9pbnRbMV07XG4gICAgICAgICAgICAgICAgcmV0LnBpeGVsTGVuZ3RoID0gcmVjdC5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgcmV0LnBpeGVsU3RhcnQgPSByZWN0Lnk7XG4gICAgICAgICAgICAgICAgcmV0LnNpZ25hbCA9IGF4aXMuaW52ZXJzZSA/IC0xIDogMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBmaXhSYW5nZShyYW5nZSkge1xuICAgICAgICAvLyBDbGFtcCwgdXNpbmcgISg8PSBvciA+PSkgdG8gaGFuZGxlIE5hTi5cbiAgICAgICAgLy8ganNoaW50IGlnbm9yZTpzdGFydFxuICAgICAgICB2YXIgYm91bmQgPSBbMCwgMTAwXTtcbiAgICAgICAgIShyYW5nZVswXSA8PSBib3VuZFsxXSkgJiYgKHJhbmdlWzBdID0gYm91bmRbMV0pO1xuICAgICAgICAhKHJhbmdlWzFdIDw9IGJvdW5kWzFdKSAmJiAocmFuZ2VbMV0gPSBib3VuZFsxXSk7XG4gICAgICAgICEocmFuZ2VbMF0gPj0gYm91bmRbMF0pICYmIChyYW5nZVswXSA9IGJvdW5kWzBdKTtcbiAgICAgICAgIShyYW5nZVsxXSA+PSBib3VuZFswXSkgJiYgKHJhbmdlWzFdID0gYm91bmRbMF0pO1xuICAgICAgICAvLyBqc2hpbnQgaWdub3JlOmVuZFxuXG4gICAgICAgIHJldHVybiByYW5nZTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IEluc2lkZVpvb21WaWV3O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvY29tcG9uZW50L2RhdGFab29tL0luc2lkZVpvb21WaWV3LmpzXG4vLyBtb2R1bGUgaWQgPSAyMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 212 */
/* unknown exports provided */
/* all exports used */
/*!***************************************************!*\
  !*** ./lib/component/dataZoom/SelectZoomModel.js ***!
  \***************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * @file Data zoom model\n */\n\n\n    var DataZoomModel = __webpack_require__(/*! ./DataZoomModel */ 46);\n\n    module.exports = DataZoomModel.extend({\n\n        type: 'dataZoom.select'\n\n    });\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjEyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2NvbXBvbmVudC9kYXRhWm9vbS9TZWxlY3Rab29tTW9kZWwuanM/NThhMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlIERhdGEgem9vbSBtb2RlbFxuICovXG5cblxuICAgIHZhciBEYXRhWm9vbU1vZGVsID0gcmVxdWlyZSgnLi9EYXRhWm9vbU1vZGVsJyk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IERhdGFab29tTW9kZWwuZXh0ZW5kKHtcblxuICAgICAgICB0eXBlOiAnZGF0YVpvb20uc2VsZWN0J1xuXG4gICAgfSk7XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2NvbXBvbmVudC9kYXRhWm9vbS9TZWxlY3Rab29tTW9kZWwuanNcbi8vIG1vZHVsZSBpZCA9IDIxMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 213 */
/* unknown exports provided */
/* all exports used */
/*!**************************************************!*\
  !*** ./lib/component/dataZoom/SelectZoomView.js ***!
  \**************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    module.exports = __webpack_require__(/*! ./DataZoomView */ 47).extend({\n\n        type: 'dataZoom.select'\n\n    });\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjEzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2NvbXBvbmVudC9kYXRhWm9vbS9TZWxlY3Rab29tVmlldy5qcz82NTUzIl0sInNvdXJjZXNDb250ZW50IjpbIlxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL0RhdGFab29tVmlldycpLmV4dGVuZCh7XG5cbiAgICAgICAgdHlwZTogJ2RhdGFab29tLnNlbGVjdCdcblxuICAgIH0pO1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9jb21wb25lbnQvZGF0YVpvb20vU2VsZWN0Wm9vbVZpZXcuanNcbi8vIG1vZHVsZSBpZCA9IDIxM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 214 */
/* unknown exports provided */
/* all exports used */
/*!***************************************************!*\
  !*** ./lib/component/dataZoom/SliderZoomModel.js ***!
  \***************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * @file Data zoom model\n */\n\n\n    var DataZoomModel = __webpack_require__(/*! ./DataZoomModel */ 46);\n\n    var SliderZoomModel = DataZoomModel.extend({\n\n        type: 'dataZoom.slider',\n\n        layoutMode: 'box',\n\n        /**\n         * @protected\n         */\n        defaultOption: {\n            show: true,\n\n            // ph => placeholder. Using placehoder here because\n            // deault value can only be drived in view stage.\n            right: 'ph',  // Default align to grid rect.\n            top: 'ph',    // Default align to grid rect.\n            width: 'ph',  // Default align to grid rect.\n            height: 'ph', // Default align to grid rect.\n            left: null,   // Default align to grid rect.\n            bottom: null, // Default align to grid rect.\n\n            backgroundColor: 'rgba(47,69,84,0)',    // Background of slider zoom component.\n            // dataBackgroundColor: '#ddd',         // Background coor of data shadow and border of box,\n                                                    // highest priority, remain for compatibility of\n                                                    // previous version, but not recommended any more.\n            dataBackground: {\n                lineStyle: {\n                    color: '#2f4554',\n                    width: 0.5,\n                    opacity: 0.3\n                },\n                areaStyle: {\n                    color: 'rgba(47,69,84,0.3)',\n                    opacity: 0.3\n                }\n            },\n            borderColor: '#ddd',                    // border color of the box. For compatibility,\n                                                    // if dataBackgroundColor is set, borderColor\n                                                    // is ignored.\n\n            fillerColor: 'rgba(167,183,204,0.4)',     // Color of selected area.\n            // handleColor: 'rgba(89,170,216,0.95)',     // Color of handle.\n            // handleIcon: 'path://M4.9,17.8c0-1.4,4.5-10.5,5.5-12.4c0-0.1,0.6-1.1,0.9-1.1c0.4,0,0.9,1,0.9,1.1c1.1,2.2,5.4,11,5.4,12.4v17.8c0,1.5-0.6,2.1-1.3,2.1H6.1c-0.7,0-1.3-0.6-1.3-2.1V17.8z',\n            handleIcon: 'M8.2,13.6V3.9H6.3v9.7H3.1v14.9h3.3v9.7h1.8v-9.7h3.3V13.6H8.2z M9.7,24.4H4.8v-1.4h4.9V24.4z M9.7,19.1H4.8v-1.4h4.9V19.1z',\n            // Percent of the slider height\n            handleSize: '100%',\n\n            handleStyle: {\n                color: '#a7b7cc'\n            },\n\n            labelPrecision: null,\n            labelFormatter: null,\n            showDetail: true,\n            showDataShadow: 'auto',                 // Default auto decision.\n            realtime: true,\n            zoomLock: false,                        // Whether disable zoom.\n            textStyle: {\n                color: '#333'\n            }\n        }\n\n    });\n\n    module.exports = SliderZoomModel;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjE0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2NvbXBvbmVudC9kYXRhWm9vbS9TbGlkZXJab29tTW9kZWwuanM/YTgyOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlIERhdGEgem9vbSBtb2RlbFxuICovXG5cblxuICAgIHZhciBEYXRhWm9vbU1vZGVsID0gcmVxdWlyZSgnLi9EYXRhWm9vbU1vZGVsJyk7XG5cbiAgICB2YXIgU2xpZGVyWm9vbU1vZGVsID0gRGF0YVpvb21Nb2RlbC5leHRlbmQoe1xuXG4gICAgICAgIHR5cGU6ICdkYXRhWm9vbS5zbGlkZXInLFxuXG4gICAgICAgIGxheW91dE1vZGU6ICdib3gnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBkZWZhdWx0T3B0aW9uOiB7XG4gICAgICAgICAgICBzaG93OiB0cnVlLFxuXG4gICAgICAgICAgICAvLyBwaCA9PiBwbGFjZWhvbGRlci4gVXNpbmcgcGxhY2Vob2RlciBoZXJlIGJlY2F1c2VcbiAgICAgICAgICAgIC8vIGRlYXVsdCB2YWx1ZSBjYW4gb25seSBiZSBkcml2ZWQgaW4gdmlldyBzdGFnZS5cbiAgICAgICAgICAgIHJpZ2h0OiAncGgnLCAgLy8gRGVmYXVsdCBhbGlnbiB0byBncmlkIHJlY3QuXG4gICAgICAgICAgICB0b3A6ICdwaCcsICAgIC8vIERlZmF1bHQgYWxpZ24gdG8gZ3JpZCByZWN0LlxuICAgICAgICAgICAgd2lkdGg6ICdwaCcsICAvLyBEZWZhdWx0IGFsaWduIHRvIGdyaWQgcmVjdC5cbiAgICAgICAgICAgIGhlaWdodDogJ3BoJywgLy8gRGVmYXVsdCBhbGlnbiB0byBncmlkIHJlY3QuXG4gICAgICAgICAgICBsZWZ0OiBudWxsLCAgIC8vIERlZmF1bHQgYWxpZ24gdG8gZ3JpZCByZWN0LlxuICAgICAgICAgICAgYm90dG9tOiBudWxsLCAvLyBEZWZhdWx0IGFsaWduIHRvIGdyaWQgcmVjdC5cblxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAncmdiYSg0Nyw2OSw4NCwwKScsICAgIC8vIEJhY2tncm91bmQgb2Ygc2xpZGVyIHpvb20gY29tcG9uZW50LlxuICAgICAgICAgICAgLy8gZGF0YUJhY2tncm91bmRDb2xvcjogJyNkZGQnLCAgICAgICAgIC8vIEJhY2tncm91bmQgY29vciBvZiBkYXRhIHNoYWRvdyBhbmQgYm9yZGVyIG9mIGJveCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBoaWdoZXN0IHByaW9yaXR5LCByZW1haW4gZm9yIGNvbXBhdGliaWxpdHkgb2ZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwcmV2aW91cyB2ZXJzaW9uLCBidXQgbm90IHJlY29tbWVuZGVkIGFueSBtb3JlLlxuICAgICAgICAgICAgZGF0YUJhY2tncm91bmQ6IHtcbiAgICAgICAgICAgICAgICBsaW5lU3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6ICcjMmY0NTU0JyxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDAuNSxcbiAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogMC4zXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBhcmVhU3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6ICdyZ2JhKDQ3LDY5LDg0LDAuMyknLFxuICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiAwLjNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYm9yZGVyQ29sb3I6ICcjZGRkJywgICAgICAgICAgICAgICAgICAgIC8vIGJvcmRlciBjb2xvciBvZiB0aGUgYm94LiBGb3IgY29tcGF0aWJpbGl0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBkYXRhQmFja2dyb3VuZENvbG9yIGlzIHNldCwgYm9yZGVyQ29sb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpcyBpZ25vcmVkLlxuXG4gICAgICAgICAgICBmaWxsZXJDb2xvcjogJ3JnYmEoMTY3LDE4MywyMDQsMC40KScsICAgICAvLyBDb2xvciBvZiBzZWxlY3RlZCBhcmVhLlxuICAgICAgICAgICAgLy8gaGFuZGxlQ29sb3I6ICdyZ2JhKDg5LDE3MCwyMTYsMC45NSknLCAgICAgLy8gQ29sb3Igb2YgaGFuZGxlLlxuICAgICAgICAgICAgLy8gaGFuZGxlSWNvbjogJ3BhdGg6Ly9NNC45LDE3LjhjMC0xLjQsNC41LTEwLjUsNS41LTEyLjRjMC0wLjEsMC42LTEuMSwwLjktMS4xYzAuNCwwLDAuOSwxLDAuOSwxLjFjMS4xLDIuMiw1LjQsMTEsNS40LDEyLjR2MTcuOGMwLDEuNS0wLjYsMi4xLTEuMywyLjFINi4xYy0wLjcsMC0xLjMtMC42LTEuMy0yLjFWMTcuOHonLFxuICAgICAgICAgICAgaGFuZGxlSWNvbjogJ004LjIsMTMuNlYzLjlINi4zdjkuN0gzLjF2MTQuOWgzLjN2OS43aDEuOHYtOS43aDMuM1YxMy42SDguMnogTTkuNywyNC40SDQuOHYtMS40aDQuOVYyNC40eiBNOS43LDE5LjFINC44di0xLjRoNC45VjE5LjF6JyxcbiAgICAgICAgICAgIC8vIFBlcmNlbnQgb2YgdGhlIHNsaWRlciBoZWlnaHRcbiAgICAgICAgICAgIGhhbmRsZVNpemU6ICcxMDAlJyxcblxuICAgICAgICAgICAgaGFuZGxlU3R5bGU6IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogJyNhN2I3Y2MnXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBsYWJlbFByZWNpc2lvbjogbnVsbCxcbiAgICAgICAgICAgIGxhYmVsRm9ybWF0dGVyOiBudWxsLFxuICAgICAgICAgICAgc2hvd0RldGFpbDogdHJ1ZSxcbiAgICAgICAgICAgIHNob3dEYXRhU2hhZG93OiAnYXV0bycsICAgICAgICAgICAgICAgICAvLyBEZWZhdWx0IGF1dG8gZGVjaXNpb24uXG4gICAgICAgICAgICByZWFsdGltZTogdHJ1ZSxcbiAgICAgICAgICAgIHpvb21Mb2NrOiBmYWxzZSwgICAgICAgICAgICAgICAgICAgICAgICAvLyBXaGV0aGVyIGRpc2FibGUgem9vbS5cbiAgICAgICAgICAgIHRleHRTdHlsZToge1xuICAgICAgICAgICAgICAgIGNvbG9yOiAnIzMzMydcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfSk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFNsaWRlclpvb21Nb2RlbDtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvY29tcG9uZW50L2RhdGFab29tL1NsaWRlclpvb21Nb2RlbC5qc1xuLy8gbW9kdWxlIGlkID0gMjE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 215 */
/* unknown exports provided */
/* all exports used */
/*!**************************************************!*\
  !*** ./lib/component/dataZoom/SliderZoomView.js ***!
  \**************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 0);\n    var graphic = __webpack_require__(/*! ../../util/graphic */ 2);\n    var throttle = __webpack_require__(/*! ../../util/throttle */ 38);\n    var DataZoomView = __webpack_require__(/*! ./DataZoomView */ 47);\n    var Rect = graphic.Rect;\n    var numberUtil = __webpack_require__(/*! ../../util/number */ 3);\n    var linearMap = numberUtil.linearMap;\n    var layout = __webpack_require__(/*! ../../util/layout */ 11);\n    var sliderMove = __webpack_require__(/*! ../helper/sliderMove */ 84);\n    var eventTool = __webpack_require__(/*! zrender/lib/core/event */ 20);\n\n    var asc = numberUtil.asc;\n    var bind = zrUtil.bind;\n    // var mathMax = Math.max;\n    var each = zrUtil.each;\n\n    // Constants\n    var DEFAULT_LOCATION_EDGE_GAP = 7;\n    var DEFAULT_FRAME_BORDER_WIDTH = 1;\n    var DEFAULT_FILLER_SIZE = 30;\n    var HORIZONTAL = 'horizontal';\n    var VERTICAL = 'vertical';\n    var LABEL_GAP = 5;\n    var SHOW_DATA_SHADOW_SERIES_TYPE = ['line', 'bar', 'candlestick', 'scatter'];\n\n    var SliderZoomView = DataZoomView.extend({\n\n        type: 'dataZoom.slider',\n\n        init: function (ecModel, api) {\n\n            /**\n             * @private\n             * @type {Object}\n             */\n            this._displayables = {};\n\n            /**\n             * @private\n             * @type {string}\n             */\n            this._orient;\n\n            /**\n             * [0, 100]\n             * @private\n             */\n            this._range;\n\n            /**\n             * [coord of the first handle, coord of the second handle]\n             * @private\n             */\n            this._handleEnds;\n\n            /**\n             * [length, thick]\n             * @private\n             * @type {Array.<number>}\n             */\n            this._size;\n\n            /**\n             * @private\n             * @type {number}\n             */\n            this._handleWidth;\n\n            /**\n             * @private\n             * @type {number}\n             */\n            this._handleHeight;\n\n            /**\n             * @private\n             */\n            this._location;\n\n            /**\n             * @private\n             */\n            this._dragging;\n\n            /**\n             * @private\n             */\n            this._dataShadowInfo;\n\n            this.api = api;\n        },\n\n        /**\n         * @override\n         */\n        render: function (dataZoomModel, ecModel, api, payload) {\n            SliderZoomView.superApply(this, 'render', arguments);\n\n            throttle.createOrUpdate(\n                this,\n                '_dispatchZoomAction',\n                this.dataZoomModel.get('throttle'),\n                'fixRate'\n            );\n\n            this._orient = dataZoomModel.get('orient');\n\n            if (this.dataZoomModel.get('show') === false) {\n                this.group.removeAll();\n                return;\n            }\n\n            // Notice: this._resetInterval() should not be executed when payload.type\n            // is 'dataZoom', origin this._range should be maintained, otherwise 'pan'\n            // or 'zoom' info will be missed because of 'throttle' of this.dispatchAction,\n            if (!payload || payload.type !== 'dataZoom' || payload.from !== this.uid) {\n                this._buildView();\n            }\n\n            this._updateView();\n        },\n\n        /**\n         * @override\n         */\n        remove: function () {\n            SliderZoomView.superApply(this, 'remove', arguments);\n            throttle.clear(this, '_dispatchZoomAction');\n        },\n\n        /**\n         * @override\n         */\n        dispose: function () {\n            SliderZoomView.superApply(this, 'dispose', arguments);\n            throttle.clear(this, '_dispatchZoomAction');\n        },\n\n        _buildView: function () {\n            var thisGroup = this.group;\n\n            thisGroup.removeAll();\n\n            this._resetLocation();\n            this._resetInterval();\n\n            var barGroup = this._displayables.barGroup = new graphic.Group();\n\n            this._renderBackground();\n\n            this._renderHandle();\n\n            this._renderDataShadow();\n\n            thisGroup.add(barGroup);\n\n            this._positionGroup();\n        },\n\n        /**\n         * @private\n         */\n        _resetLocation: function () {\n            var dataZoomModel = this.dataZoomModel;\n            var api = this.api;\n\n            // If some of x/y/width/height are not specified,\n            // auto-adapt according to target grid.\n            var coordRect = this._findCoordRect();\n            var ecSize = {width: api.getWidth(), height: api.getHeight()};\n            // Default align by coordinate system rect.\n            var positionInfo = this._orient === HORIZONTAL\n                ? {\n                    // Why using 'right', because right should be used in vertical,\n                    // and it is better to be consistent for dealing with position param merge.\n                    right: ecSize.width - coordRect.x - coordRect.width,\n                    top: (ecSize.height - DEFAULT_FILLER_SIZE - DEFAULT_LOCATION_EDGE_GAP),\n                    width: coordRect.width,\n                    height: DEFAULT_FILLER_SIZE\n                }\n                : { // vertical\n                    right: DEFAULT_LOCATION_EDGE_GAP,\n                    top: coordRect.y,\n                    width: DEFAULT_FILLER_SIZE,\n                    height: coordRect.height\n                };\n\n            // Do not write back to option and replace value 'ph', because\n            // the 'ph' value should be recalculated when resize.\n            var layoutParams = layout.getLayoutParams(dataZoomModel.option);\n\n            // Replace the placeholder value.\n            zrUtil.each(['right', 'top', 'width', 'height'], function (name) {\n                if (layoutParams[name] === 'ph') {\n                    layoutParams[name] = positionInfo[name];\n                }\n            });\n\n            var layoutRect = layout.getLayoutRect(\n                layoutParams,\n                ecSize,\n                dataZoomModel.padding\n            );\n\n            this._location = {x: layoutRect.x, y: layoutRect.y};\n            this._size = [layoutRect.width, layoutRect.height];\n            this._orient === VERTICAL && this._size.reverse();\n        },\n\n        /**\n         * @private\n         */\n        _positionGroup: function () {\n            var thisGroup = this.group;\n            var location = this._location;\n            var orient = this._orient;\n\n            // Just use the first axis to determine mapping.\n            var targetAxisModel = this.dataZoomModel.getFirstTargetAxisModel();\n            var inverse = targetAxisModel && targetAxisModel.get('inverse');\n\n            var barGroup = this._displayables.barGroup;\n            var otherAxisInverse = (this._dataShadowInfo || {}).otherAxisInverse;\n\n            // Transform barGroup.\n            barGroup.attr(\n                (orient === HORIZONTAL && !inverse)\n                ? {scale: otherAxisInverse ? [1, 1] : [1, -1]}\n                : (orient === HORIZONTAL && inverse)\n                ? {scale: otherAxisInverse ? [-1, 1] : [-1, -1]}\n                : (orient === VERTICAL && !inverse)\n                ? {scale: otherAxisInverse ? [1, -1] : [1, 1], rotation: Math.PI / 2}\n                // Dont use Math.PI, considering shadow direction.\n                : {scale: otherAxisInverse ? [-1, -1] : [-1, 1], rotation: Math.PI / 2}\n            );\n\n            // Position barGroup\n            var rect = thisGroup.getBoundingRect([barGroup]);\n            thisGroup.attr('position', [location.x - rect.x, location.y - rect.y]);\n        },\n\n        /**\n         * @private\n         */\n        _getViewExtent: function () {\n            return [0, this._size[0]];\n        },\n\n        _renderBackground : function () {\n            var dataZoomModel = this.dataZoomModel;\n            var size = this._size;\n\n            this._displayables.barGroup.add(new Rect({\n                silent: true,\n                shape: {\n                    x: 0, y: 0, width: size[0], height: size[1]\n                },\n                style: {\n                    fill: dataZoomModel.get('backgroundColor')\n                },\n                z2: -40\n            }));\n        },\n\n        _renderDataShadow: function () {\n            var info = this._dataShadowInfo = this._prepareDataShadowInfo();\n\n            if (!info) {\n                return;\n            }\n\n            var size = this._size;\n            var seriesModel = info.series;\n            var data = seriesModel.getRawData();\n            var otherDim = seriesModel.getShadowDim\n                ? seriesModel.getShadowDim() // @see candlestick\n                : info.otherDim;\n\n            if (otherDim == null) {\n                return;\n            }\n\n            var otherDataExtent = data.getDataExtent(otherDim);\n            // Nice extent.\n            var otherOffset = (otherDataExtent[1] - otherDataExtent[0]) * 0.3;\n            otherDataExtent = [\n                otherDataExtent[0] - otherOffset,\n                otherDataExtent[1] + otherOffset\n            ];\n            var otherShadowExtent = [0, size[1]];\n\n            var thisShadowExtent = [0, size[0]];\n\n            var areaPoints = [[size[0], 0], [0, 0]];\n            var linePoints = [];\n            var step = thisShadowExtent[1] / (data.count() - 1);\n            var thisCoord = 0;\n\n            // Optimize for large data shadow\n            var stride = Math.round(data.count() / size[0]);\n            var lastIsEmpty;\n            data.each([otherDim], function (value, index) {\n                if (stride > 0 && (index % stride)) {\n                    thisCoord += step;\n                    return;\n                }\n\n                // FIXME\n                // Should consider axis.min/axis.max when drawing dataShadow.\n\n                // FIXME\n                // 应该使用统一的空判断？还是在list里进行空判断？\n                var isEmpty = value == null || isNaN(value) || value === '';\n                // See #4235.\n                var otherCoord = isEmpty\n                    ? 0 : linearMap(value, otherDataExtent, otherShadowExtent, true);\n\n                // Attempt to draw data shadow precisely when there are empty value.\n                if (isEmpty && !lastIsEmpty && index) {\n                    areaPoints.push([areaPoints[areaPoints.length - 1][0], 0]);\n                    linePoints.push([linePoints[linePoints.length - 1][0], 0]);\n                }\n                else if (!isEmpty && lastIsEmpty) {\n                    areaPoints.push([thisCoord, 0]);\n                    linePoints.push([thisCoord, 0]);\n                }\n\n                areaPoints.push([thisCoord, otherCoord]);\n                linePoints.push([thisCoord, otherCoord]);\n\n                thisCoord += step;\n                lastIsEmpty = isEmpty;\n            });\n\n            var dataZoomModel = this.dataZoomModel;\n            // var dataBackgroundModel = dataZoomModel.getModel('dataBackground');\n            this._displayables.barGroup.add(new graphic.Polygon({\n                shape: {points: areaPoints},\n                style: zrUtil.defaults(\n                    {fill: dataZoomModel.get('dataBackgroundColor')},\n                    dataZoomModel.getModel('dataBackground.areaStyle').getAreaStyle()\n                ),\n                silent: true,\n                z2: -20\n            }));\n            this._displayables.barGroup.add(new graphic.Polyline({\n                shape: {points: linePoints},\n                style: dataZoomModel.getModel('dataBackground.lineStyle').getLineStyle(),\n                silent: true,\n                z2: -19\n            }));\n        },\n\n        _prepareDataShadowInfo: function () {\n            var dataZoomModel = this.dataZoomModel;\n            var showDataShadow = dataZoomModel.get('showDataShadow');\n\n            if (showDataShadow === false) {\n                return;\n            }\n\n            // Find a representative series.\n            var result;\n            var ecModel = this.ecModel;\n\n            dataZoomModel.eachTargetAxis(function (dimNames, axisIndex) {\n                var seriesModels = dataZoomModel\n                    .getAxisProxy(dimNames.name, axisIndex)\n                    .getTargetSeriesModels();\n\n                zrUtil.each(seriesModels, function (seriesModel) {\n                    if (result) {\n                        return;\n                    }\n\n                    if (showDataShadow !== true && zrUtil.indexOf(\n                            SHOW_DATA_SHADOW_SERIES_TYPE, seriesModel.get('type')\n                        ) < 0\n                    ) {\n                        return;\n                    }\n\n                    var thisAxis = ecModel.getComponent(dimNames.axis, axisIndex).axis;\n                    var otherDim = getOtherDim(dimNames.name);\n                    var otherAxisInverse;\n                    var coordSys = seriesModel.coordinateSystem;\n                    if (otherDim != null && coordSys.getOtherAxis) {\n                        otherAxisInverse = coordSys.getOtherAxis(thisAxis).inverse;\n                    }\n\n                    result = {\n                        thisAxis: thisAxis,\n                        series: seriesModel,\n                        thisDim: dimNames.name,\n                        otherDim: otherDim,\n                        otherAxisInverse: otherAxisInverse\n                    };\n\n                }, this);\n\n            }, this);\n\n            return result;\n        },\n\n        _renderHandle: function () {\n            var displaybles = this._displayables;\n            var handles = displaybles.handles = [];\n            var handleLabels = displaybles.handleLabels = [];\n            var barGroup = this._displayables.barGroup;\n            var size = this._size;\n            var dataZoomModel = this.dataZoomModel;\n\n            barGroup.add(displaybles.filler = new Rect({\n                draggable: true,\n                cursor: 'move',\n                drift: bind(this._onDragMove, this, 'all'),\n                onmousemove: function (e) {\n                    // Fot mobile devicem, prevent screen slider on the button.\n                    eventTool.stop(e.event);\n                },\n                ondragstart: bind(this._showDataInfo, this, true),\n                ondragend: bind(this._onDragEnd, this),\n                onmouseover: bind(this._showDataInfo, this, true),\n                onmouseout: bind(this._showDataInfo, this, false),\n                style: {\n                    fill: dataZoomModel.get('fillerColor'),\n                    textPosition : 'inside'\n                }\n            }));\n\n            // Frame border.\n            barGroup.add(new Rect(graphic.subPixelOptimizeRect({\n                silent: true,\n                shape: {\n                    x: 0,\n                    y: 0,\n                    width: size[0],\n                    height: size[1]\n                },\n                style: {\n                    stroke: dataZoomModel.get('dataBackgroundColor')\n                        || dataZoomModel.get('borderColor'),\n                    lineWidth: DEFAULT_FRAME_BORDER_WIDTH,\n                    fill: 'rgba(0,0,0,0)'\n                }\n            })));\n\n            var iconStr = dataZoomModel.get('handleIcon');\n            each([0, 1], function (handleIndex) {\n                var path = graphic.makePath(iconStr, {\n                    style: {\n                        strokeNoScale: true\n                    },\n                    rectHover: true,\n                    cursor: this._orient === 'vertical' ? 'ns-resize' : 'ew-resize',\n                    draggable: true,\n                    drift: bind(this._onDragMove, this, handleIndex),\n                    onmousemove: function (e) {\n                        // Fot mobile devicem, prevent screen slider on the button.\n                        eventTool.stop(e.event);\n                    },\n                    ondragend: bind(this._onDragEnd, this),\n                    onmouseover: bind(this._showDataInfo, this, true),\n                    onmouseout: bind(this._showDataInfo, this, false)\n                }, {\n                    x: -0.5,\n                    y: 0,\n                    width: 1,\n                    height: 1\n                }, 'center');\n\n                var bRect = path.getBoundingRect();\n                this._handleHeight = numberUtil.parsePercent(dataZoomModel.get('handleSize'), this._size[1]);\n                this._handleWidth = bRect.width / bRect.height * this._handleHeight;\n\n                path.setStyle(dataZoomModel.getModel('handleStyle').getItemStyle());\n                var handleColor = dataZoomModel.get('handleColor');\n                // Compatitable with previous version\n                if (handleColor != null) {\n                    path.style.fill = handleColor;\n                }\n\n                barGroup.add(handles[handleIndex] = path);\n\n                var textStyleModel = dataZoomModel.textStyleModel;\n\n                this.group.add(\n                    handleLabels[handleIndex] = new graphic.Text({\n                    silent: true,\n                    invisible: true,\n                    style: {\n                        x: 0, y: 0, text: '',\n                        textVerticalAlign: 'middle',\n                        textAlign: 'center',\n                        fill: textStyleModel.getTextColor(),\n                        textFont: textStyleModel.getFont()\n                    },\n                    z2: 10\n                }));\n\n            }, this);\n        },\n\n        /**\n         * @private\n         */\n        _resetInterval: function () {\n            var range = this._range = this.dataZoomModel.getPercentRange();\n            var viewExtent = this._getViewExtent();\n\n            this._handleEnds = [\n                linearMap(range[0], [0, 100], viewExtent, true),\n                linearMap(range[1], [0, 100], viewExtent, true)\n            ];\n        },\n\n        /**\n         * @private\n         * @param {(number|string)} handleIndex 0 or 1 or 'all'\n         * @param {number} dx\n         * @param {number} dy\n         */\n        _updateInterval: function (handleIndex, delta) {\n            var handleEnds = this._handleEnds;\n            var viewExtend = this._getViewExtent();\n\n            sliderMove(\n                delta,\n                handleEnds,\n                viewExtend,\n                (handleIndex === 'all' || this.dataZoomModel.get('zoomLock'))\n                    ? 'rigid' : 'cross',\n                handleIndex\n            );\n\n            this._range = asc([\n                linearMap(handleEnds[0], viewExtend, [0, 100], true),\n                linearMap(handleEnds[1], viewExtend, [0, 100], true)\n            ]);\n        },\n\n        /**\n         * @private\n         */\n        _updateView: function (nonRealtime) {\n            var displaybles = this._displayables;\n            var handleEnds = this._handleEnds;\n            var handleInterval = asc(handleEnds.slice());\n            var size = this._size;\n\n            each([0, 1], function (handleIndex) {\n                // Handles\n                var handle = displaybles.handles[handleIndex];\n                var handleHeight = this._handleHeight;\n                handle.attr({\n                    scale: [handleHeight, handleHeight],\n                    position: [handleEnds[handleIndex], size[1] / 2 - handleHeight / 2]\n                });\n            }, this);\n\n            // Filler\n            displaybles.filler.setShape({\n                x: handleInterval[0],\n                y: 0,\n                width: handleInterval[1] - handleInterval[0],\n                height: size[1]\n            });\n\n            this._updateDataInfo(nonRealtime);\n        },\n\n        /**\n         * @private\n         */\n        _updateDataInfo: function (nonRealtime) {\n            var dataZoomModel = this.dataZoomModel;\n            var displaybles = this._displayables;\n            var handleLabels = displaybles.handleLabels;\n            var orient = this._orient;\n            var labelTexts = ['', ''];\n\n            // FIXME\n            // date型，支持formatter，autoformatter（ec2 date.getAutoFormatter）\n            if (dataZoomModel.get('showDetail')) {\n                var axisProxy = dataZoomModel.findRepresentativeAxisProxy();\n\n                if (axisProxy) {\n                    var axis = axisProxy.getAxisModel().axis;\n                    var range = this._range;\n\n                    var dataInterval = nonRealtime\n                        // See #4434, data and axis are not processed and reset yet in non-realtime mode.\n                        ? axisProxy.calculateDataWindow({\n                            start: range[0], end: range[1]\n                        }).valueWindow\n                        : axisProxy.getDataValueWindow();\n\n                    labelTexts = [\n                        this._formatLabel(dataInterval[0], axis),\n                        this._formatLabel(dataInterval[1], axis)\n                    ];\n                }\n            }\n\n            var orderedHandleEnds = asc(this._handleEnds.slice());\n\n            setLabel.call(this, 0);\n            setLabel.call(this, 1);\n\n            function setLabel(handleIndex) {\n                // Label\n                // Text should not transform by barGroup.\n                // Ignore handlers transform\n                var barTransform = graphic.getTransform(\n                    displaybles.handles[handleIndex].parent, this.group\n                );\n                var direction = graphic.transformDirection(\n                    handleIndex === 0 ? 'right' : 'left', barTransform\n                );\n                var offset = this._handleWidth / 2 + LABEL_GAP;\n                var textPoint = graphic.applyTransform(\n                    [\n                        orderedHandleEnds[handleIndex] + (handleIndex === 0 ? -offset : offset),\n                        this._size[1] / 2\n                    ],\n                    barTransform\n                );\n                handleLabels[handleIndex].setStyle({\n                    x: textPoint[0],\n                    y: textPoint[1],\n                    textVerticalAlign: orient === HORIZONTAL ? 'middle' : direction,\n                    textAlign: orient === HORIZONTAL ? direction : 'center',\n                    text: labelTexts[handleIndex]\n                });\n            }\n        },\n\n        /**\n         * @private\n         */\n        _formatLabel: function (value, axis) {\n            var dataZoomModel = this.dataZoomModel;\n            var labelFormatter = dataZoomModel.get('labelFormatter');\n\n            var labelPrecision = dataZoomModel.get('labelPrecision');\n            if (labelPrecision == null || labelPrecision === 'auto') {\n                labelPrecision = axis.getPixelPrecision();\n            }\n\n            var valueStr = (value == null || isNaN(value))\n                ? ''\n                // FIXME Glue code\n                : (axis.type === 'category' || axis.type === 'time')\n                    ? axis.scale.getLabel(Math.round(value))\n                    // param of toFixed should less then 20.\n                    : value.toFixed(Math.min(labelPrecision, 20));\n\n            return zrUtil.isFunction(labelFormatter)\n                ? labelFormatter(value, valueStr)\n                : zrUtil.isString(labelFormatter)\n                ? labelFormatter.replace('{value}', valueStr)\n                : valueStr;\n        },\n\n        /**\n         * @private\n         * @param {boolean} showOrHide true: show, false: hide\n         */\n        _showDataInfo: function (showOrHide) {\n            // Always show when drgging.\n            showOrHide = this._dragging || showOrHide;\n\n            var handleLabels = this._displayables.handleLabels;\n            handleLabels[0].attr('invisible', !showOrHide);\n            handleLabels[1].attr('invisible', !showOrHide);\n        },\n\n        _onDragMove: function (handleIndex, dx, dy) {\n            this._dragging = true;\n\n            // Transform dx, dy to bar coordination.\n            var vertex = this._applyBarTransform([dx, dy], true);\n\n            this._updateInterval(handleIndex, vertex[0]);\n\n            var realtime = this.dataZoomModel.get('realtime');\n\n            this._updateView(!realtime);\n\n            if (realtime) {\n                realtime && this._dispatchZoomAction();\n            }\n        },\n\n        _onDragEnd: function () {\n            this._dragging = false;\n            this._showDataInfo(false);\n            this._dispatchZoomAction();\n        },\n\n        /**\n         * This action will be throttled.\n         * @private\n         */\n        _dispatchZoomAction: function () {\n            var range = this._range;\n\n            this.api.dispatchAction({\n                type: 'dataZoom',\n                from: this.uid,\n                dataZoomId: this.dataZoomModel.id,\n                start: range[0],\n                end: range[1]\n            });\n        },\n\n        /**\n         * @private\n         */\n        _applyBarTransform: function (vertex, inverse) {\n            var barTransform = this._displayables.barGroup.getLocalTransform();\n            return graphic.applyTransform(vertex, barTransform, inverse);\n        },\n\n        /**\n         * @private\n         */\n        _findCoordRect: function () {\n            // Find the grid coresponding to the first axis referred by dataZoom.\n            var rect;\n            each(this.getTargetCoordInfo(), function (coordInfoList) {\n                if (!rect && coordInfoList.length) {\n                    var coordSys = coordInfoList[0].model.coordinateSystem;\n                    rect = coordSys.getRect && coordSys.getRect();\n                }\n            });\n            if (!rect) {\n                var width = this.api.getWidth();\n                var height = this.api.getHeight();\n                rect = {\n                    x: width * 0.2,\n                    y: height * 0.2,\n                    width: width * 0.6,\n                    height: height * 0.6\n                };\n            }\n\n            return rect;\n        }\n\n    });\n\n    function getOtherDim(thisDim) {\n        // FIXME\n        // 这个逻辑和getOtherAxis里一致，但是写在这里是否不好\n        var map = {x: 'y', y: 'x', radius: 'angle', angle: 'radius'};\n        return map[thisDim];\n    }\n\n    module.exports = SliderZoomView;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjE1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2NvbXBvbmVudC9kYXRhWm9vbS9TbGlkZXJab29tVmlldy5qcz9lYzQ4Il0sInNvdXJjZXNDb250ZW50IjpbIlxuXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuICAgIHZhciBncmFwaGljID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9ncmFwaGljJyk7XG4gICAgdmFyIHRocm90dGxlID0gcmVxdWlyZSgnLi4vLi4vdXRpbC90aHJvdHRsZScpO1xuICAgIHZhciBEYXRhWm9vbVZpZXcgPSByZXF1aXJlKCcuL0RhdGFab29tVmlldycpO1xuICAgIHZhciBSZWN0ID0gZ3JhcGhpYy5SZWN0O1xuICAgIHZhciBudW1iZXJVdGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9udW1iZXInKTtcbiAgICB2YXIgbGluZWFyTWFwID0gbnVtYmVyVXRpbC5saW5lYXJNYXA7XG4gICAgdmFyIGxheW91dCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvbGF5b3V0Jyk7XG4gICAgdmFyIHNsaWRlck1vdmUgPSByZXF1aXJlKCcuLi9oZWxwZXIvc2xpZGVyTW92ZScpO1xuICAgIHZhciBldmVudFRvb2wgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL2V2ZW50Jyk7XG5cbiAgICB2YXIgYXNjID0gbnVtYmVyVXRpbC5hc2M7XG4gICAgdmFyIGJpbmQgPSB6clV0aWwuYmluZDtcbiAgICAvLyB2YXIgbWF0aE1heCA9IE1hdGgubWF4O1xuICAgIHZhciBlYWNoID0genJVdGlsLmVhY2g7XG5cbiAgICAvLyBDb25zdGFudHNcbiAgICB2YXIgREVGQVVMVF9MT0NBVElPTl9FREdFX0dBUCA9IDc7XG4gICAgdmFyIERFRkFVTFRfRlJBTUVfQk9SREVSX1dJRFRIID0gMTtcbiAgICB2YXIgREVGQVVMVF9GSUxMRVJfU0laRSA9IDMwO1xuICAgIHZhciBIT1JJWk9OVEFMID0gJ2hvcml6b250YWwnO1xuICAgIHZhciBWRVJUSUNBTCA9ICd2ZXJ0aWNhbCc7XG4gICAgdmFyIExBQkVMX0dBUCA9IDU7XG4gICAgdmFyIFNIT1dfREFUQV9TSEFET1dfU0VSSUVTX1RZUEUgPSBbJ2xpbmUnLCAnYmFyJywgJ2NhbmRsZXN0aWNrJywgJ3NjYXR0ZXInXTtcblxuICAgIHZhciBTbGlkZXJab29tVmlldyA9IERhdGFab29tVmlldy5leHRlbmQoe1xuXG4gICAgICAgIHR5cGU6ICdkYXRhWm9vbS5zbGlkZXInLFxuXG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5fZGlzcGxheWFibGVzID0ge307XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuX29yaWVudDtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBbMCwgMTAwXVxuICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5fcmFuZ2U7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogW2Nvb3JkIG9mIHRoZSBmaXJzdCBoYW5kbGUsIGNvb3JkIG9mIHRoZSBzZWNvbmQgaGFuZGxlXVxuICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5faGFuZGxlRW5kcztcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBbbGVuZ3RoLCB0aGlja11cbiAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuX3NpemU7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZVdpZHRoO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVIZWlnaHQ7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5fbG9jYXRpb247XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5fZHJhZ2dpbmc7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5fZGF0YVNoYWRvd0luZm87XG5cbiAgICAgICAgICAgIHRoaXMuYXBpID0gYXBpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAb3ZlcnJpZGVcbiAgICAgICAgICovXG4gICAgICAgIHJlbmRlcjogZnVuY3Rpb24gKGRhdGFab29tTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCkge1xuICAgICAgICAgICAgU2xpZGVyWm9vbVZpZXcuc3VwZXJBcHBseSh0aGlzLCAncmVuZGVyJywgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgdGhyb3R0bGUuY3JlYXRlT3JVcGRhdGUoXG4gICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICAnX2Rpc3BhdGNoWm9vbUFjdGlvbicsXG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhWm9vbU1vZGVsLmdldCgndGhyb3R0bGUnKSxcbiAgICAgICAgICAgICAgICAnZml4UmF0ZSdcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHRoaXMuX29yaWVudCA9IGRhdGFab29tTW9kZWwuZ2V0KCdvcmllbnQnKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuZGF0YVpvb21Nb2RlbC5nZXQoJ3Nob3cnKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3VwLnJlbW92ZUFsbCgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTm90aWNlOiB0aGlzLl9yZXNldEludGVydmFsKCkgc2hvdWxkIG5vdCBiZSBleGVjdXRlZCB3aGVuIHBheWxvYWQudHlwZVxuICAgICAgICAgICAgLy8gaXMgJ2RhdGFab29tJywgb3JpZ2luIHRoaXMuX3JhbmdlIHNob3VsZCBiZSBtYWludGFpbmVkLCBvdGhlcndpc2UgJ3BhbidcbiAgICAgICAgICAgIC8vIG9yICd6b29tJyBpbmZvIHdpbGwgYmUgbWlzc2VkIGJlY2F1c2Ugb2YgJ3Rocm90dGxlJyBvZiB0aGlzLmRpc3BhdGNoQWN0aW9uLFxuICAgICAgICAgICAgaWYgKCFwYXlsb2FkIHx8IHBheWxvYWQudHlwZSAhPT0gJ2RhdGFab29tJyB8fCBwYXlsb2FkLmZyb20gIT09IHRoaXMudWlkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYnVpbGRWaWV3KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVZpZXcoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgICAqL1xuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIFNsaWRlclpvb21WaWV3LnN1cGVyQXBwbHkodGhpcywgJ3JlbW92ZScsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB0aHJvdHRsZS5jbGVhcih0aGlzLCAnX2Rpc3BhdGNoWm9vbUFjdGlvbicpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAb3ZlcnJpZGVcbiAgICAgICAgICovXG4gICAgICAgIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIFNsaWRlclpvb21WaWV3LnN1cGVyQXBwbHkodGhpcywgJ2Rpc3Bvc2UnLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgdGhyb3R0bGUuY2xlYXIodGhpcywgJ19kaXNwYXRjaFpvb21BY3Rpb24nKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfYnVpbGRWaWV3OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdGhpc0dyb3VwID0gdGhpcy5ncm91cDtcblxuICAgICAgICAgICAgdGhpc0dyb3VwLnJlbW92ZUFsbCgpO1xuXG4gICAgICAgICAgICB0aGlzLl9yZXNldExvY2F0aW9uKCk7XG4gICAgICAgICAgICB0aGlzLl9yZXNldEludGVydmFsKCk7XG5cbiAgICAgICAgICAgIHZhciBiYXJHcm91cCA9IHRoaXMuX2Rpc3BsYXlhYmxlcy5iYXJHcm91cCA9IG5ldyBncmFwaGljLkdyb3VwKCk7XG5cbiAgICAgICAgICAgIHRoaXMuX3JlbmRlckJhY2tncm91bmQoKTtcblxuICAgICAgICAgICAgdGhpcy5fcmVuZGVySGFuZGxlKCk7XG5cbiAgICAgICAgICAgIHRoaXMuX3JlbmRlckRhdGFTaGFkb3coKTtcblxuICAgICAgICAgICAgdGhpc0dyb3VwLmFkZChiYXJHcm91cCk7XG5cbiAgICAgICAgICAgIHRoaXMuX3Bvc2l0aW9uR3JvdXAoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF9yZXNldExvY2F0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZGF0YVpvb21Nb2RlbCA9IHRoaXMuZGF0YVpvb21Nb2RlbDtcbiAgICAgICAgICAgIHZhciBhcGkgPSB0aGlzLmFwaTtcblxuICAgICAgICAgICAgLy8gSWYgc29tZSBvZiB4L3kvd2lkdGgvaGVpZ2h0IGFyZSBub3Qgc3BlY2lmaWVkLFxuICAgICAgICAgICAgLy8gYXV0by1hZGFwdCBhY2NvcmRpbmcgdG8gdGFyZ2V0IGdyaWQuXG4gICAgICAgICAgICB2YXIgY29vcmRSZWN0ID0gdGhpcy5fZmluZENvb3JkUmVjdCgpO1xuICAgICAgICAgICAgdmFyIGVjU2l6ZSA9IHt3aWR0aDogYXBpLmdldFdpZHRoKCksIGhlaWdodDogYXBpLmdldEhlaWdodCgpfTtcbiAgICAgICAgICAgIC8vIERlZmF1bHQgYWxpZ24gYnkgY29vcmRpbmF0ZSBzeXN0ZW0gcmVjdC5cbiAgICAgICAgICAgIHZhciBwb3NpdGlvbkluZm8gPSB0aGlzLl9vcmllbnQgPT09IEhPUklaT05UQUxcbiAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2h5IHVzaW5nICdyaWdodCcsIGJlY2F1c2UgcmlnaHQgc2hvdWxkIGJlIHVzZWQgaW4gdmVydGljYWwsXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZCBpdCBpcyBiZXR0ZXIgdG8gYmUgY29uc2lzdGVudCBmb3IgZGVhbGluZyB3aXRoIHBvc2l0aW9uIHBhcmFtIG1lcmdlLlxuICAgICAgICAgICAgICAgICAgICByaWdodDogZWNTaXplLndpZHRoIC0gY29vcmRSZWN0LnggLSBjb29yZFJlY3Qud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIHRvcDogKGVjU2l6ZS5oZWlnaHQgLSBERUZBVUxUX0ZJTExFUl9TSVpFIC0gREVGQVVMVF9MT0NBVElPTl9FREdFX0dBUCksXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBjb29yZFJlY3Qud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogREVGQVVMVF9GSUxMRVJfU0laRVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA6IHsgLy8gdmVydGljYWxcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IERFRkFVTFRfTE9DQVRJT05fRURHRV9HQVAsXG4gICAgICAgICAgICAgICAgICAgIHRvcDogY29vcmRSZWN0LnksXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBERUZBVUxUX0ZJTExFUl9TSVpFLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGNvb3JkUmVjdC5oZWlnaHRcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBEbyBub3Qgd3JpdGUgYmFjayB0byBvcHRpb24gYW5kIHJlcGxhY2UgdmFsdWUgJ3BoJywgYmVjYXVzZVxuICAgICAgICAgICAgLy8gdGhlICdwaCcgdmFsdWUgc2hvdWxkIGJlIHJlY2FsY3VsYXRlZCB3aGVuIHJlc2l6ZS5cbiAgICAgICAgICAgIHZhciBsYXlvdXRQYXJhbXMgPSBsYXlvdXQuZ2V0TGF5b3V0UGFyYW1zKGRhdGFab29tTW9kZWwub3B0aW9uKTtcblxuICAgICAgICAgICAgLy8gUmVwbGFjZSB0aGUgcGxhY2Vob2xkZXIgdmFsdWUuXG4gICAgICAgICAgICB6clV0aWwuZWFjaChbJ3JpZ2h0JywgJ3RvcCcsICd3aWR0aCcsICdoZWlnaHQnXSwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAobGF5b3V0UGFyYW1zW25hbWVdID09PSAncGgnKSB7XG4gICAgICAgICAgICAgICAgICAgIGxheW91dFBhcmFtc1tuYW1lXSA9IHBvc2l0aW9uSW5mb1tuYW1lXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdmFyIGxheW91dFJlY3QgPSBsYXlvdXQuZ2V0TGF5b3V0UmVjdChcbiAgICAgICAgICAgICAgICBsYXlvdXRQYXJhbXMsXG4gICAgICAgICAgICAgICAgZWNTaXplLFxuICAgICAgICAgICAgICAgIGRhdGFab29tTW9kZWwucGFkZGluZ1xuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgdGhpcy5fbG9jYXRpb24gPSB7eDogbGF5b3V0UmVjdC54LCB5OiBsYXlvdXRSZWN0Lnl9O1xuICAgICAgICAgICAgdGhpcy5fc2l6ZSA9IFtsYXlvdXRSZWN0LndpZHRoLCBsYXlvdXRSZWN0LmhlaWdodF07XG4gICAgICAgICAgICB0aGlzLl9vcmllbnQgPT09IFZFUlRJQ0FMICYmIHRoaXMuX3NpemUucmV2ZXJzZSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX3Bvc2l0aW9uR3JvdXA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB0aGlzR3JvdXAgPSB0aGlzLmdyb3VwO1xuICAgICAgICAgICAgdmFyIGxvY2F0aW9uID0gdGhpcy5fbG9jYXRpb247XG4gICAgICAgICAgICB2YXIgb3JpZW50ID0gdGhpcy5fb3JpZW50O1xuXG4gICAgICAgICAgICAvLyBKdXN0IHVzZSB0aGUgZmlyc3QgYXhpcyB0byBkZXRlcm1pbmUgbWFwcGluZy5cbiAgICAgICAgICAgIHZhciB0YXJnZXRBeGlzTW9kZWwgPSB0aGlzLmRhdGFab29tTW9kZWwuZ2V0Rmlyc3RUYXJnZXRBeGlzTW9kZWwoKTtcbiAgICAgICAgICAgIHZhciBpbnZlcnNlID0gdGFyZ2V0QXhpc01vZGVsICYmIHRhcmdldEF4aXNNb2RlbC5nZXQoJ2ludmVyc2UnKTtcblxuICAgICAgICAgICAgdmFyIGJhckdyb3VwID0gdGhpcy5fZGlzcGxheWFibGVzLmJhckdyb3VwO1xuICAgICAgICAgICAgdmFyIG90aGVyQXhpc0ludmVyc2UgPSAodGhpcy5fZGF0YVNoYWRvd0luZm8gfHwge30pLm90aGVyQXhpc0ludmVyc2U7XG5cbiAgICAgICAgICAgIC8vIFRyYW5zZm9ybSBiYXJHcm91cC5cbiAgICAgICAgICAgIGJhckdyb3VwLmF0dHIoXG4gICAgICAgICAgICAgICAgKG9yaWVudCA9PT0gSE9SSVpPTlRBTCAmJiAhaW52ZXJzZSlcbiAgICAgICAgICAgICAgICA/IHtzY2FsZTogb3RoZXJBeGlzSW52ZXJzZSA/IFsxLCAxXSA6IFsxLCAtMV19XG4gICAgICAgICAgICAgICAgOiAob3JpZW50ID09PSBIT1JJWk9OVEFMICYmIGludmVyc2UpXG4gICAgICAgICAgICAgICAgPyB7c2NhbGU6IG90aGVyQXhpc0ludmVyc2UgPyBbLTEsIDFdIDogWy0xLCAtMV19XG4gICAgICAgICAgICAgICAgOiAob3JpZW50ID09PSBWRVJUSUNBTCAmJiAhaW52ZXJzZSlcbiAgICAgICAgICAgICAgICA/IHtzY2FsZTogb3RoZXJBeGlzSW52ZXJzZSA/IFsxLCAtMV0gOiBbMSwgMV0sIHJvdGF0aW9uOiBNYXRoLlBJIC8gMn1cbiAgICAgICAgICAgICAgICAvLyBEb250IHVzZSBNYXRoLlBJLCBjb25zaWRlcmluZyBzaGFkb3cgZGlyZWN0aW9uLlxuICAgICAgICAgICAgICAgIDoge3NjYWxlOiBvdGhlckF4aXNJbnZlcnNlID8gWy0xLCAtMV0gOiBbLTEsIDFdLCByb3RhdGlvbjogTWF0aC5QSSAvIDJ9XG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAvLyBQb3NpdGlvbiBiYXJHcm91cFxuICAgICAgICAgICAgdmFyIHJlY3QgPSB0aGlzR3JvdXAuZ2V0Qm91bmRpbmdSZWN0KFtiYXJHcm91cF0pO1xuICAgICAgICAgICAgdGhpc0dyb3VwLmF0dHIoJ3Bvc2l0aW9uJywgW2xvY2F0aW9uLnggLSByZWN0LngsIGxvY2F0aW9uLnkgLSByZWN0LnldKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF9nZXRWaWV3RXh0ZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gWzAsIHRoaXMuX3NpemVbMF1dO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9yZW5kZXJCYWNrZ3JvdW5kIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGRhdGFab29tTW9kZWwgPSB0aGlzLmRhdGFab29tTW9kZWw7XG4gICAgICAgICAgICB2YXIgc2l6ZSA9IHRoaXMuX3NpemU7XG5cbiAgICAgICAgICAgIHRoaXMuX2Rpc3BsYXlhYmxlcy5iYXJHcm91cC5hZGQobmV3IFJlY3Qoe1xuICAgICAgICAgICAgICAgIHNpbGVudDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgICAgICAgICB4OiAwLCB5OiAwLCB3aWR0aDogc2l6ZVswXSwgaGVpZ2h0OiBzaXplWzFdXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICBmaWxsOiBkYXRhWm9vbU1vZGVsLmdldCgnYmFja2dyb3VuZENvbG9yJylcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHoyOiAtNDBcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfcmVuZGVyRGF0YVNoYWRvdzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGluZm8gPSB0aGlzLl9kYXRhU2hhZG93SW5mbyA9IHRoaXMuX3ByZXBhcmVEYXRhU2hhZG93SW5mbygpO1xuXG4gICAgICAgICAgICBpZiAoIWluZm8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzaXplID0gdGhpcy5fc2l6ZTtcbiAgICAgICAgICAgIHZhciBzZXJpZXNNb2RlbCA9IGluZm8uc2VyaWVzO1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXRSYXdEYXRhKCk7XG4gICAgICAgICAgICB2YXIgb3RoZXJEaW0gPSBzZXJpZXNNb2RlbC5nZXRTaGFkb3dEaW1cbiAgICAgICAgICAgICAgICA/IHNlcmllc01vZGVsLmdldFNoYWRvd0RpbSgpIC8vIEBzZWUgY2FuZGxlc3RpY2tcbiAgICAgICAgICAgICAgICA6IGluZm8ub3RoZXJEaW07XG5cbiAgICAgICAgICAgIGlmIChvdGhlckRpbSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgb3RoZXJEYXRhRXh0ZW50ID0gZGF0YS5nZXREYXRhRXh0ZW50KG90aGVyRGltKTtcbiAgICAgICAgICAgIC8vIE5pY2UgZXh0ZW50LlxuICAgICAgICAgICAgdmFyIG90aGVyT2Zmc2V0ID0gKG90aGVyRGF0YUV4dGVudFsxXSAtIG90aGVyRGF0YUV4dGVudFswXSkgKiAwLjM7XG4gICAgICAgICAgICBvdGhlckRhdGFFeHRlbnQgPSBbXG4gICAgICAgICAgICAgICAgb3RoZXJEYXRhRXh0ZW50WzBdIC0gb3RoZXJPZmZzZXQsXG4gICAgICAgICAgICAgICAgb3RoZXJEYXRhRXh0ZW50WzFdICsgb3RoZXJPZmZzZXRcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICB2YXIgb3RoZXJTaGFkb3dFeHRlbnQgPSBbMCwgc2l6ZVsxXV07XG5cbiAgICAgICAgICAgIHZhciB0aGlzU2hhZG93RXh0ZW50ID0gWzAsIHNpemVbMF1dO1xuXG4gICAgICAgICAgICB2YXIgYXJlYVBvaW50cyA9IFtbc2l6ZVswXSwgMF0sIFswLCAwXV07XG4gICAgICAgICAgICB2YXIgbGluZVBvaW50cyA9IFtdO1xuICAgICAgICAgICAgdmFyIHN0ZXAgPSB0aGlzU2hhZG93RXh0ZW50WzFdIC8gKGRhdGEuY291bnQoKSAtIDEpO1xuICAgICAgICAgICAgdmFyIHRoaXNDb29yZCA9IDA7XG5cbiAgICAgICAgICAgIC8vIE9wdGltaXplIGZvciBsYXJnZSBkYXRhIHNoYWRvd1xuICAgICAgICAgICAgdmFyIHN0cmlkZSA9IE1hdGgucm91bmQoZGF0YS5jb3VudCgpIC8gc2l6ZVswXSk7XG4gICAgICAgICAgICB2YXIgbGFzdElzRW1wdHk7XG4gICAgICAgICAgICBkYXRhLmVhY2goW290aGVyRGltXSwgZnVuY3Rpb24gKHZhbHVlLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIGlmIChzdHJpZGUgPiAwICYmIChpbmRleCAlIHN0cmlkZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc0Nvb3JkICs9IHN0ZXA7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBGSVhNRVxuICAgICAgICAgICAgICAgIC8vIFNob3VsZCBjb25zaWRlciBheGlzLm1pbi9heGlzLm1heCB3aGVuIGRyYXdpbmcgZGF0YVNoYWRvdy5cblxuICAgICAgICAgICAgICAgIC8vIEZJWE1FXG4gICAgICAgICAgICAgICAgLy8g5bqU6K+l5L2/55So57uf5LiA55qE56m65Yik5pat77yf6L+Y5piv5ZyobGlzdOmHjOi/m+ihjOepuuWIpOaWre+8n1xuICAgICAgICAgICAgICAgIHZhciBpc0VtcHR5ID0gdmFsdWUgPT0gbnVsbCB8fCBpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09ICcnO1xuICAgICAgICAgICAgICAgIC8vIFNlZSAjNDIzNS5cbiAgICAgICAgICAgICAgICB2YXIgb3RoZXJDb29yZCA9IGlzRW1wdHlcbiAgICAgICAgICAgICAgICAgICAgPyAwIDogbGluZWFyTWFwKHZhbHVlLCBvdGhlckRhdGFFeHRlbnQsIG90aGVyU2hhZG93RXh0ZW50LCB0cnVlKTtcblxuICAgICAgICAgICAgICAgIC8vIEF0dGVtcHQgdG8gZHJhdyBkYXRhIHNoYWRvdyBwcmVjaXNlbHkgd2hlbiB0aGVyZSBhcmUgZW1wdHkgdmFsdWUuXG4gICAgICAgICAgICAgICAgaWYgKGlzRW1wdHkgJiYgIWxhc3RJc0VtcHR5ICYmIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZWFQb2ludHMucHVzaChbYXJlYVBvaW50c1thcmVhUG9pbnRzLmxlbmd0aCAtIDFdWzBdLCAwXSk7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVQb2ludHMucHVzaChbbGluZVBvaW50c1tsaW5lUG9pbnRzLmxlbmd0aCAtIDFdWzBdLCAwXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFpc0VtcHR5ICYmIGxhc3RJc0VtcHR5KSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZWFQb2ludHMucHVzaChbdGhpc0Nvb3JkLCAwXSk7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVQb2ludHMucHVzaChbdGhpc0Nvb3JkLCAwXSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYXJlYVBvaW50cy5wdXNoKFt0aGlzQ29vcmQsIG90aGVyQ29vcmRdKTtcbiAgICAgICAgICAgICAgICBsaW5lUG9pbnRzLnB1c2goW3RoaXNDb29yZCwgb3RoZXJDb29yZF0pO1xuXG4gICAgICAgICAgICAgICAgdGhpc0Nvb3JkICs9IHN0ZXA7XG4gICAgICAgICAgICAgICAgbGFzdElzRW1wdHkgPSBpc0VtcHR5O1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHZhciBkYXRhWm9vbU1vZGVsID0gdGhpcy5kYXRhWm9vbU1vZGVsO1xuICAgICAgICAgICAgLy8gdmFyIGRhdGFCYWNrZ3JvdW5kTW9kZWwgPSBkYXRhWm9vbU1vZGVsLmdldE1vZGVsKCdkYXRhQmFja2dyb3VuZCcpO1xuICAgICAgICAgICAgdGhpcy5fZGlzcGxheWFibGVzLmJhckdyb3VwLmFkZChuZXcgZ3JhcGhpYy5Qb2x5Z29uKHtcbiAgICAgICAgICAgICAgICBzaGFwZToge3BvaW50czogYXJlYVBvaW50c30sXG4gICAgICAgICAgICAgICAgc3R5bGU6IHpyVXRpbC5kZWZhdWx0cyhcbiAgICAgICAgICAgICAgICAgICAge2ZpbGw6IGRhdGFab29tTW9kZWwuZ2V0KCdkYXRhQmFja2dyb3VuZENvbG9yJyl9LFxuICAgICAgICAgICAgICAgICAgICBkYXRhWm9vbU1vZGVsLmdldE1vZGVsKCdkYXRhQmFja2dyb3VuZC5hcmVhU3R5bGUnKS5nZXRBcmVhU3R5bGUoKVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgc2lsZW50OiB0cnVlLFxuICAgICAgICAgICAgICAgIHoyOiAtMjBcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHRoaXMuX2Rpc3BsYXlhYmxlcy5iYXJHcm91cC5hZGQobmV3IGdyYXBoaWMuUG9seWxpbmUoe1xuICAgICAgICAgICAgICAgIHNoYXBlOiB7cG9pbnRzOiBsaW5lUG9pbnRzfSxcbiAgICAgICAgICAgICAgICBzdHlsZTogZGF0YVpvb21Nb2RlbC5nZXRNb2RlbCgnZGF0YUJhY2tncm91bmQubGluZVN0eWxlJykuZ2V0TGluZVN0eWxlKCksXG4gICAgICAgICAgICAgICAgc2lsZW50OiB0cnVlLFxuICAgICAgICAgICAgICAgIHoyOiAtMTlcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfcHJlcGFyZURhdGFTaGFkb3dJbmZvOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZGF0YVpvb21Nb2RlbCA9IHRoaXMuZGF0YVpvb21Nb2RlbDtcbiAgICAgICAgICAgIHZhciBzaG93RGF0YVNoYWRvdyA9IGRhdGFab29tTW9kZWwuZ2V0KCdzaG93RGF0YVNoYWRvdycpO1xuXG4gICAgICAgICAgICBpZiAoc2hvd0RhdGFTaGFkb3cgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGaW5kIGEgcmVwcmVzZW50YXRpdmUgc2VyaWVzLlxuICAgICAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgICAgIHZhciBlY01vZGVsID0gdGhpcy5lY01vZGVsO1xuXG4gICAgICAgICAgICBkYXRhWm9vbU1vZGVsLmVhY2hUYXJnZXRBeGlzKGZ1bmN0aW9uIChkaW1OYW1lcywgYXhpc0luZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlcmllc01vZGVscyA9IGRhdGFab29tTW9kZWxcbiAgICAgICAgICAgICAgICAgICAgLmdldEF4aXNQcm94eShkaW1OYW1lcy5uYW1lLCBheGlzSW5kZXgpXG4gICAgICAgICAgICAgICAgICAgIC5nZXRUYXJnZXRTZXJpZXNNb2RlbHMoKTtcblxuICAgICAgICAgICAgICAgIHpyVXRpbC5lYWNoKHNlcmllc01vZGVscywgZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzaG93RGF0YVNoYWRvdyAhPT0gdHJ1ZSAmJiB6clV0aWwuaW5kZXhPZihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBTSE9XX0RBVEFfU0hBRE9XX1NFUklFU19UWVBFLCBzZXJpZXNNb2RlbC5nZXQoJ3R5cGUnKVxuICAgICAgICAgICAgICAgICAgICAgICAgKSA8IDBcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgdGhpc0F4aXMgPSBlY01vZGVsLmdldENvbXBvbmVudChkaW1OYW1lcy5heGlzLCBheGlzSW5kZXgpLmF4aXM7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvdGhlckRpbSA9IGdldE90aGVyRGltKGRpbU5hbWVzLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3RoZXJBeGlzSW52ZXJzZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvb3JkU3lzID0gc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG90aGVyRGltICE9IG51bGwgJiYgY29vcmRTeXMuZ2V0T3RoZXJBeGlzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdGhlckF4aXNJbnZlcnNlID0gY29vcmRTeXMuZ2V0T3RoZXJBeGlzKHRoaXNBeGlzKS5pbnZlcnNlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc0F4aXM6IHRoaXNBeGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzOiBzZXJpZXNNb2RlbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNEaW06IGRpbU5hbWVzLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBvdGhlckRpbTogb3RoZXJEaW0sXG4gICAgICAgICAgICAgICAgICAgICAgICBvdGhlckF4aXNJbnZlcnNlOiBvdGhlckF4aXNJbnZlcnNlXG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3JlbmRlckhhbmRsZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGRpc3BsYXlibGVzID0gdGhpcy5fZGlzcGxheWFibGVzO1xuICAgICAgICAgICAgdmFyIGhhbmRsZXMgPSBkaXNwbGF5Ymxlcy5oYW5kbGVzID0gW107XG4gICAgICAgICAgICB2YXIgaGFuZGxlTGFiZWxzID0gZGlzcGxheWJsZXMuaGFuZGxlTGFiZWxzID0gW107XG4gICAgICAgICAgICB2YXIgYmFyR3JvdXAgPSB0aGlzLl9kaXNwbGF5YWJsZXMuYmFyR3JvdXA7XG4gICAgICAgICAgICB2YXIgc2l6ZSA9IHRoaXMuX3NpemU7XG4gICAgICAgICAgICB2YXIgZGF0YVpvb21Nb2RlbCA9IHRoaXMuZGF0YVpvb21Nb2RlbDtcblxuICAgICAgICAgICAgYmFyR3JvdXAuYWRkKGRpc3BsYXlibGVzLmZpbGxlciA9IG5ldyBSZWN0KHtcbiAgICAgICAgICAgICAgICBkcmFnZ2FibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgY3Vyc29yOiAnbW92ZScsXG4gICAgICAgICAgICAgICAgZHJpZnQ6IGJpbmQodGhpcy5fb25EcmFnTW92ZSwgdGhpcywgJ2FsbCcpLFxuICAgICAgICAgICAgICAgIG9ubW91c2Vtb3ZlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBGb3QgbW9iaWxlIGRldmljZW0sIHByZXZlbnQgc2NyZWVuIHNsaWRlciBvbiB0aGUgYnV0dG9uLlxuICAgICAgICAgICAgICAgICAgICBldmVudFRvb2wuc3RvcChlLmV2ZW50KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9uZHJhZ3N0YXJ0OiBiaW5kKHRoaXMuX3Nob3dEYXRhSW5mbywgdGhpcywgdHJ1ZSksXG4gICAgICAgICAgICAgICAgb25kcmFnZW5kOiBiaW5kKHRoaXMuX29uRHJhZ0VuZCwgdGhpcyksXG4gICAgICAgICAgICAgICAgb25tb3VzZW92ZXI6IGJpbmQodGhpcy5fc2hvd0RhdGFJbmZvLCB0aGlzLCB0cnVlKSxcbiAgICAgICAgICAgICAgICBvbm1vdXNlb3V0OiBiaW5kKHRoaXMuX3Nob3dEYXRhSW5mbywgdGhpcywgZmFsc2UpLFxuICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGw6IGRhdGFab29tTW9kZWwuZ2V0KCdmaWxsZXJDb2xvcicpLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0UG9zaXRpb24gOiAnaW5zaWRlJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgLy8gRnJhbWUgYm9yZGVyLlxuICAgICAgICAgICAgYmFyR3JvdXAuYWRkKG5ldyBSZWN0KGdyYXBoaWMuc3ViUGl4ZWxPcHRpbWl6ZVJlY3Qoe1xuICAgICAgICAgICAgICAgIHNpbGVudDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogc2l6ZVswXSxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBzaXplWzFdXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICBzdHJva2U6IGRhdGFab29tTW9kZWwuZ2V0KCdkYXRhQmFja2dyb3VuZENvbG9yJylcbiAgICAgICAgICAgICAgICAgICAgICAgIHx8IGRhdGFab29tTW9kZWwuZ2V0KCdib3JkZXJDb2xvcicpLFxuICAgICAgICAgICAgICAgICAgICBsaW5lV2lkdGg6IERFRkFVTFRfRlJBTUVfQk9SREVSX1dJRFRILFxuICAgICAgICAgICAgICAgICAgICBmaWxsOiAncmdiYSgwLDAsMCwwKSdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSkpO1xuXG4gICAgICAgICAgICB2YXIgaWNvblN0ciA9IGRhdGFab29tTW9kZWwuZ2V0KCdoYW5kbGVJY29uJyk7XG4gICAgICAgICAgICBlYWNoKFswLCAxXSwgZnVuY3Rpb24gKGhhbmRsZUluZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhdGggPSBncmFwaGljLm1ha2VQYXRoKGljb25TdHIsIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZU5vU2NhbGU6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcmVjdEhvdmVyOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBjdXJzb3I6IHRoaXMuX29yaWVudCA9PT0gJ3ZlcnRpY2FsJyA/ICducy1yZXNpemUnIDogJ2V3LXJlc2l6ZScsXG4gICAgICAgICAgICAgICAgICAgIGRyYWdnYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZHJpZnQ6IGJpbmQodGhpcy5fb25EcmFnTW92ZSwgdGhpcywgaGFuZGxlSW5kZXgpLFxuICAgICAgICAgICAgICAgICAgICBvbm1vdXNlbW92ZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZvdCBtb2JpbGUgZGV2aWNlbSwgcHJldmVudCBzY3JlZW4gc2xpZGVyIG9uIHRoZSBidXR0b24uXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudFRvb2wuc3RvcChlLmV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgb25kcmFnZW5kOiBiaW5kKHRoaXMuX29uRHJhZ0VuZCwgdGhpcyksXG4gICAgICAgICAgICAgICAgICAgIG9ubW91c2VvdmVyOiBiaW5kKHRoaXMuX3Nob3dEYXRhSW5mbywgdGhpcywgdHJ1ZSksXG4gICAgICAgICAgICAgICAgICAgIG9ubW91c2VvdXQ6IGJpbmQodGhpcy5fc2hvd0RhdGFJbmZvLCB0aGlzLCBmYWxzZSlcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIHg6IC0wLjUsXG4gICAgICAgICAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiAxLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IDFcbiAgICAgICAgICAgICAgICB9LCAnY2VudGVyJyk7XG5cbiAgICAgICAgICAgICAgICB2YXIgYlJlY3QgPSBwYXRoLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZUhlaWdodCA9IG51bWJlclV0aWwucGFyc2VQZXJjZW50KGRhdGFab29tTW9kZWwuZ2V0KCdoYW5kbGVTaXplJyksIHRoaXMuX3NpemVbMV0pO1xuICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZVdpZHRoID0gYlJlY3Qud2lkdGggLyBiUmVjdC5oZWlnaHQgKiB0aGlzLl9oYW5kbGVIZWlnaHQ7XG5cbiAgICAgICAgICAgICAgICBwYXRoLnNldFN0eWxlKGRhdGFab29tTW9kZWwuZ2V0TW9kZWwoJ2hhbmRsZVN0eWxlJykuZ2V0SXRlbVN0eWxlKCkpO1xuICAgICAgICAgICAgICAgIHZhciBoYW5kbGVDb2xvciA9IGRhdGFab29tTW9kZWwuZ2V0KCdoYW5kbGVDb2xvcicpO1xuICAgICAgICAgICAgICAgIC8vIENvbXBhdGl0YWJsZSB3aXRoIHByZXZpb3VzIHZlcnNpb25cbiAgICAgICAgICAgICAgICBpZiAoaGFuZGxlQ29sb3IgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBwYXRoLnN0eWxlLmZpbGwgPSBoYW5kbGVDb2xvcjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBiYXJHcm91cC5hZGQoaGFuZGxlc1toYW5kbGVJbmRleF0gPSBwYXRoKTtcblxuICAgICAgICAgICAgICAgIHZhciB0ZXh0U3R5bGVNb2RlbCA9IGRhdGFab29tTW9kZWwudGV4dFN0eWxlTW9kZWw7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmdyb3VwLmFkZChcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlTGFiZWxzW2hhbmRsZUluZGV4XSA9IG5ldyBncmFwaGljLlRleHQoe1xuICAgICAgICAgICAgICAgICAgICBzaWxlbnQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGludmlzaWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IDAsIHk6IDAsIHRleHQ6ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dFZlcnRpY2FsQWxpZ246ICdtaWRkbGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dEFsaWduOiAnY2VudGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGw6IHRleHRTdHlsZU1vZGVsLmdldFRleHRDb2xvcigpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dEZvbnQ6IHRleHRTdHlsZU1vZGVsLmdldEZvbnQoKVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB6MjogMTBcbiAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX3Jlc2V0SW50ZXJ2YWw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByYW5nZSA9IHRoaXMuX3JhbmdlID0gdGhpcy5kYXRhWm9vbU1vZGVsLmdldFBlcmNlbnRSYW5nZSgpO1xuICAgICAgICAgICAgdmFyIHZpZXdFeHRlbnQgPSB0aGlzLl9nZXRWaWV3RXh0ZW50KCk7XG5cbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZUVuZHMgPSBbXG4gICAgICAgICAgICAgICAgbGluZWFyTWFwKHJhbmdlWzBdLCBbMCwgMTAwXSwgdmlld0V4dGVudCwgdHJ1ZSksXG4gICAgICAgICAgICAgICAgbGluZWFyTWFwKHJhbmdlWzFdLCBbMCwgMTAwXSwgdmlld0V4dGVudCwgdHJ1ZSlcbiAgICAgICAgICAgIF07XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBwYXJhbSB7KG51bWJlcnxzdHJpbmcpfSBoYW5kbGVJbmRleCAwIG9yIDEgb3IgJ2FsbCdcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGR4XG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkeVxuICAgICAgICAgKi9cbiAgICAgICAgX3VwZGF0ZUludGVydmFsOiBmdW5jdGlvbiAoaGFuZGxlSW5kZXgsIGRlbHRhKSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlRW5kcyA9IHRoaXMuX2hhbmRsZUVuZHM7XG4gICAgICAgICAgICB2YXIgdmlld0V4dGVuZCA9IHRoaXMuX2dldFZpZXdFeHRlbnQoKTtcblxuICAgICAgICAgICAgc2xpZGVyTW92ZShcbiAgICAgICAgICAgICAgICBkZWx0YSxcbiAgICAgICAgICAgICAgICBoYW5kbGVFbmRzLFxuICAgICAgICAgICAgICAgIHZpZXdFeHRlbmQsXG4gICAgICAgICAgICAgICAgKGhhbmRsZUluZGV4ID09PSAnYWxsJyB8fCB0aGlzLmRhdGFab29tTW9kZWwuZ2V0KCd6b29tTG9jaycpKVxuICAgICAgICAgICAgICAgICAgICA/ICdyaWdpZCcgOiAnY3Jvc3MnLFxuICAgICAgICAgICAgICAgIGhhbmRsZUluZGV4XG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICB0aGlzLl9yYW5nZSA9IGFzYyhbXG4gICAgICAgICAgICAgICAgbGluZWFyTWFwKGhhbmRsZUVuZHNbMF0sIHZpZXdFeHRlbmQsIFswLCAxMDBdLCB0cnVlKSxcbiAgICAgICAgICAgICAgICBsaW5lYXJNYXAoaGFuZGxlRW5kc1sxXSwgdmlld0V4dGVuZCwgWzAsIDEwMF0sIHRydWUpXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF91cGRhdGVWaWV3OiBmdW5jdGlvbiAobm9uUmVhbHRpbWUpIHtcbiAgICAgICAgICAgIHZhciBkaXNwbGF5YmxlcyA9IHRoaXMuX2Rpc3BsYXlhYmxlcztcbiAgICAgICAgICAgIHZhciBoYW5kbGVFbmRzID0gdGhpcy5faGFuZGxlRW5kcztcbiAgICAgICAgICAgIHZhciBoYW5kbGVJbnRlcnZhbCA9IGFzYyhoYW5kbGVFbmRzLnNsaWNlKCkpO1xuICAgICAgICAgICAgdmFyIHNpemUgPSB0aGlzLl9zaXplO1xuXG4gICAgICAgICAgICBlYWNoKFswLCAxXSwgZnVuY3Rpb24gKGhhbmRsZUluZGV4KSB7XG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlc1xuICAgICAgICAgICAgICAgIHZhciBoYW5kbGUgPSBkaXNwbGF5Ymxlcy5oYW5kbGVzW2hhbmRsZUluZGV4XTtcbiAgICAgICAgICAgICAgICB2YXIgaGFuZGxlSGVpZ2h0ID0gdGhpcy5faGFuZGxlSGVpZ2h0O1xuICAgICAgICAgICAgICAgIGhhbmRsZS5hdHRyKHtcbiAgICAgICAgICAgICAgICAgICAgc2NhbGU6IFtoYW5kbGVIZWlnaHQsIGhhbmRsZUhlaWdodF0sXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBbaGFuZGxlRW5kc1toYW5kbGVJbmRleF0sIHNpemVbMV0gLyAyIC0gaGFuZGxlSGVpZ2h0IC8gMl1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgICAvLyBGaWxsZXJcbiAgICAgICAgICAgIGRpc3BsYXlibGVzLmZpbGxlci5zZXRTaGFwZSh7XG4gICAgICAgICAgICAgICAgeDogaGFuZGxlSW50ZXJ2YWxbMF0sXG4gICAgICAgICAgICAgICAgeTogMCxcbiAgICAgICAgICAgICAgICB3aWR0aDogaGFuZGxlSW50ZXJ2YWxbMV0gLSBoYW5kbGVJbnRlcnZhbFswXSxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHNpemVbMV1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0aGlzLl91cGRhdGVEYXRhSW5mbyhub25SZWFsdGltZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfdXBkYXRlRGF0YUluZm86IGZ1bmN0aW9uIChub25SZWFsdGltZSkge1xuICAgICAgICAgICAgdmFyIGRhdGFab29tTW9kZWwgPSB0aGlzLmRhdGFab29tTW9kZWw7XG4gICAgICAgICAgICB2YXIgZGlzcGxheWJsZXMgPSB0aGlzLl9kaXNwbGF5YWJsZXM7XG4gICAgICAgICAgICB2YXIgaGFuZGxlTGFiZWxzID0gZGlzcGxheWJsZXMuaGFuZGxlTGFiZWxzO1xuICAgICAgICAgICAgdmFyIG9yaWVudCA9IHRoaXMuX29yaWVudDtcbiAgICAgICAgICAgIHZhciBsYWJlbFRleHRzID0gWycnLCAnJ107XG5cbiAgICAgICAgICAgIC8vIEZJWE1FXG4gICAgICAgICAgICAvLyBkYXRl5Z6L77yM5pSv5oyBZm9ybWF0dGVy77yMYXV0b2Zvcm1hdHRlcu+8iGVjMiBkYXRlLmdldEF1dG9Gb3JtYXR0ZXLvvIlcbiAgICAgICAgICAgIGlmIChkYXRhWm9vbU1vZGVsLmdldCgnc2hvd0RldGFpbCcpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGF4aXNQcm94eSA9IGRhdGFab29tTW9kZWwuZmluZFJlcHJlc2VudGF0aXZlQXhpc1Byb3h5KCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoYXhpc1Byb3h5KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBheGlzID0gYXhpc1Byb3h5LmdldEF4aXNNb2RlbCgpLmF4aXM7XG4gICAgICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IHRoaXMuX3JhbmdlO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBkYXRhSW50ZXJ2YWwgPSBub25SZWFsdGltZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2VlICM0NDM0LCBkYXRhIGFuZCBheGlzIGFyZSBub3QgcHJvY2Vzc2VkIGFuZCByZXNldCB5ZXQgaW4gbm9uLXJlYWx0aW1lIG1vZGUuXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGF4aXNQcm94eS5jYWxjdWxhdGVEYXRhV2luZG93KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogcmFuZ2VbMF0sIGVuZDogcmFuZ2VbMV1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLnZhbHVlV2luZG93XG4gICAgICAgICAgICAgICAgICAgICAgICA6IGF4aXNQcm94eS5nZXREYXRhVmFsdWVXaW5kb3coKTtcblxuICAgICAgICAgICAgICAgICAgICBsYWJlbFRleHRzID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZm9ybWF0TGFiZWwoZGF0YUludGVydmFsWzBdLCBheGlzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2Zvcm1hdExhYmVsKGRhdGFJbnRlcnZhbFsxXSwgYXhpcylcbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBvcmRlcmVkSGFuZGxlRW5kcyA9IGFzYyh0aGlzLl9oYW5kbGVFbmRzLnNsaWNlKCkpO1xuXG4gICAgICAgICAgICBzZXRMYWJlbC5jYWxsKHRoaXMsIDApO1xuICAgICAgICAgICAgc2V0TGFiZWwuY2FsbCh0aGlzLCAxKTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gc2V0TGFiZWwoaGFuZGxlSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAvLyBMYWJlbFxuICAgICAgICAgICAgICAgIC8vIFRleHQgc2hvdWxkIG5vdCB0cmFuc2Zvcm0gYnkgYmFyR3JvdXAuXG4gICAgICAgICAgICAgICAgLy8gSWdub3JlIGhhbmRsZXJzIHRyYW5zZm9ybVxuICAgICAgICAgICAgICAgIHZhciBiYXJUcmFuc2Zvcm0gPSBncmFwaGljLmdldFRyYW5zZm9ybShcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheWJsZXMuaGFuZGxlc1toYW5kbGVJbmRleF0ucGFyZW50LCB0aGlzLmdyb3VwXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB2YXIgZGlyZWN0aW9uID0gZ3JhcGhpYy50cmFuc2Zvcm1EaXJlY3Rpb24oXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUluZGV4ID09PSAwID8gJ3JpZ2h0JyA6ICdsZWZ0JywgYmFyVHJhbnNmb3JtXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5faGFuZGxlV2lkdGggLyAyICsgTEFCRUxfR0FQO1xuICAgICAgICAgICAgICAgIHZhciB0ZXh0UG9pbnQgPSBncmFwaGljLmFwcGx5VHJhbnNmb3JtKFxuICAgICAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgICAgICBvcmRlcmVkSGFuZGxlRW5kc1toYW5kbGVJbmRleF0gKyAoaGFuZGxlSW5kZXggPT09IDAgPyAtb2Zmc2V0IDogb2Zmc2V0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NpemVbMV0gLyAyXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgIGJhclRyYW5zZm9ybVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaGFuZGxlTGFiZWxzW2hhbmRsZUluZGV4XS5zZXRTdHlsZSh7XG4gICAgICAgICAgICAgICAgICAgIHg6IHRleHRQb2ludFswXSxcbiAgICAgICAgICAgICAgICAgICAgeTogdGV4dFBvaW50WzFdLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0VmVydGljYWxBbGlnbjogb3JpZW50ID09PSBIT1JJWk9OVEFMID8gJ21pZGRsZScgOiBkaXJlY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgIHRleHRBbGlnbjogb3JpZW50ID09PSBIT1JJWk9OVEFMID8gZGlyZWN0aW9uIDogJ2NlbnRlcicsXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IGxhYmVsVGV4dHNbaGFuZGxlSW5kZXhdXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfZm9ybWF0TGFiZWw6IGZ1bmN0aW9uICh2YWx1ZSwgYXhpcykge1xuICAgICAgICAgICAgdmFyIGRhdGFab29tTW9kZWwgPSB0aGlzLmRhdGFab29tTW9kZWw7XG4gICAgICAgICAgICB2YXIgbGFiZWxGb3JtYXR0ZXIgPSBkYXRhWm9vbU1vZGVsLmdldCgnbGFiZWxGb3JtYXR0ZXInKTtcblxuICAgICAgICAgICAgdmFyIGxhYmVsUHJlY2lzaW9uID0gZGF0YVpvb21Nb2RlbC5nZXQoJ2xhYmVsUHJlY2lzaW9uJyk7XG4gICAgICAgICAgICBpZiAobGFiZWxQcmVjaXNpb24gPT0gbnVsbCB8fCBsYWJlbFByZWNpc2lvbiA9PT0gJ2F1dG8nKSB7XG4gICAgICAgICAgICAgICAgbGFiZWxQcmVjaXNpb24gPSBheGlzLmdldFBpeGVsUHJlY2lzaW9uKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB2YWx1ZVN0ciA9ICh2YWx1ZSA9PSBudWxsIHx8IGlzTmFOKHZhbHVlKSlcbiAgICAgICAgICAgICAgICA/ICcnXG4gICAgICAgICAgICAgICAgLy8gRklYTUUgR2x1ZSBjb2RlXG4gICAgICAgICAgICAgICAgOiAoYXhpcy50eXBlID09PSAnY2F0ZWdvcnknIHx8IGF4aXMudHlwZSA9PT0gJ3RpbWUnKVxuICAgICAgICAgICAgICAgICAgICA/IGF4aXMuc2NhbGUuZ2V0TGFiZWwoTWF0aC5yb3VuZCh2YWx1ZSkpXG4gICAgICAgICAgICAgICAgICAgIC8vIHBhcmFtIG9mIHRvRml4ZWQgc2hvdWxkIGxlc3MgdGhlbiAyMC5cbiAgICAgICAgICAgICAgICAgICAgOiB2YWx1ZS50b0ZpeGVkKE1hdGgubWluKGxhYmVsUHJlY2lzaW9uLCAyMCkpO1xuXG4gICAgICAgICAgICByZXR1cm4genJVdGlsLmlzRnVuY3Rpb24obGFiZWxGb3JtYXR0ZXIpXG4gICAgICAgICAgICAgICAgPyBsYWJlbEZvcm1hdHRlcih2YWx1ZSwgdmFsdWVTdHIpXG4gICAgICAgICAgICAgICAgOiB6clV0aWwuaXNTdHJpbmcobGFiZWxGb3JtYXR0ZXIpXG4gICAgICAgICAgICAgICAgPyBsYWJlbEZvcm1hdHRlci5yZXBsYWNlKCd7dmFsdWV9JywgdmFsdWVTdHIpXG4gICAgICAgICAgICAgICAgOiB2YWx1ZVN0cjtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBzaG93T3JIaWRlIHRydWU6IHNob3csIGZhbHNlOiBoaWRlXG4gICAgICAgICAqL1xuICAgICAgICBfc2hvd0RhdGFJbmZvOiBmdW5jdGlvbiAoc2hvd09ySGlkZSkge1xuICAgICAgICAgICAgLy8gQWx3YXlzIHNob3cgd2hlbiBkcmdnaW5nLlxuICAgICAgICAgICAgc2hvd09ySGlkZSA9IHRoaXMuX2RyYWdnaW5nIHx8IHNob3dPckhpZGU7XG5cbiAgICAgICAgICAgIHZhciBoYW5kbGVMYWJlbHMgPSB0aGlzLl9kaXNwbGF5YWJsZXMuaGFuZGxlTGFiZWxzO1xuICAgICAgICAgICAgaGFuZGxlTGFiZWxzWzBdLmF0dHIoJ2ludmlzaWJsZScsICFzaG93T3JIaWRlKTtcbiAgICAgICAgICAgIGhhbmRsZUxhYmVsc1sxXS5hdHRyKCdpbnZpc2libGUnLCAhc2hvd09ySGlkZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX29uRHJhZ01vdmU6IGZ1bmN0aW9uIChoYW5kbGVJbmRleCwgZHgsIGR5KSB7XG4gICAgICAgICAgICB0aGlzLl9kcmFnZ2luZyA9IHRydWU7XG5cbiAgICAgICAgICAgIC8vIFRyYW5zZm9ybSBkeCwgZHkgdG8gYmFyIGNvb3JkaW5hdGlvbi5cbiAgICAgICAgICAgIHZhciB2ZXJ0ZXggPSB0aGlzLl9hcHBseUJhclRyYW5zZm9ybShbZHgsIGR5XSwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUludGVydmFsKGhhbmRsZUluZGV4LCB2ZXJ0ZXhbMF0pO1xuXG4gICAgICAgICAgICB2YXIgcmVhbHRpbWUgPSB0aGlzLmRhdGFab29tTW9kZWwuZ2V0KCdyZWFsdGltZScpO1xuXG4gICAgICAgICAgICB0aGlzLl91cGRhdGVWaWV3KCFyZWFsdGltZSk7XG5cbiAgICAgICAgICAgIGlmIChyZWFsdGltZSkge1xuICAgICAgICAgICAgICAgIHJlYWx0aW1lICYmIHRoaXMuX2Rpc3BhdGNoWm9vbUFjdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIF9vbkRyYWdFbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX2RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9zaG93RGF0YUluZm8oZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy5fZGlzcGF0Y2hab29tQWN0aW9uKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgYWN0aW9uIHdpbGwgYmUgdGhyb3R0bGVkLlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX2Rpc3BhdGNoWm9vbUFjdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJhbmdlID0gdGhpcy5fcmFuZ2U7XG5cbiAgICAgICAgICAgIHRoaXMuYXBpLmRpc3BhdGNoQWN0aW9uKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnZGF0YVpvb20nLFxuICAgICAgICAgICAgICAgIGZyb206IHRoaXMudWlkLFxuICAgICAgICAgICAgICAgIGRhdGFab29tSWQ6IHRoaXMuZGF0YVpvb21Nb2RlbC5pZCxcbiAgICAgICAgICAgICAgICBzdGFydDogcmFuZ2VbMF0sXG4gICAgICAgICAgICAgICAgZW5kOiByYW5nZVsxXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfYXBwbHlCYXJUcmFuc2Zvcm06IGZ1bmN0aW9uICh2ZXJ0ZXgsIGludmVyc2UpIHtcbiAgICAgICAgICAgIHZhciBiYXJUcmFuc2Zvcm0gPSB0aGlzLl9kaXNwbGF5YWJsZXMuYmFyR3JvdXAuZ2V0TG9jYWxUcmFuc2Zvcm0oKTtcbiAgICAgICAgICAgIHJldHVybiBncmFwaGljLmFwcGx5VHJhbnNmb3JtKHZlcnRleCwgYmFyVHJhbnNmb3JtLCBpbnZlcnNlKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF9maW5kQ29vcmRSZWN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBGaW5kIHRoZSBncmlkIGNvcmVzcG9uZGluZyB0byB0aGUgZmlyc3QgYXhpcyByZWZlcnJlZCBieSBkYXRhWm9vbS5cbiAgICAgICAgICAgIHZhciByZWN0O1xuICAgICAgICAgICAgZWFjaCh0aGlzLmdldFRhcmdldENvb3JkSW5mbygpLCBmdW5jdGlvbiAoY29vcmRJbmZvTGlzdCkge1xuICAgICAgICAgICAgICAgIGlmICghcmVjdCAmJiBjb29yZEluZm9MaXN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29vcmRTeXMgPSBjb29yZEluZm9MaXN0WzBdLm1vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG4gICAgICAgICAgICAgICAgICAgIHJlY3QgPSBjb29yZFN5cy5nZXRSZWN0ICYmIGNvb3JkU3lzLmdldFJlY3QoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghcmVjdCkge1xuICAgICAgICAgICAgICAgIHZhciB3aWR0aCA9IHRoaXMuYXBpLmdldFdpZHRoKCk7XG4gICAgICAgICAgICAgICAgdmFyIGhlaWdodCA9IHRoaXMuYXBpLmdldEhlaWdodCgpO1xuICAgICAgICAgICAgICAgIHJlY3QgPSB7XG4gICAgICAgICAgICAgICAgICAgIHg6IHdpZHRoICogMC4yLFxuICAgICAgICAgICAgICAgICAgICB5OiBoZWlnaHQgKiAwLjIsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCAqIDAuNixcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQgKiAwLjZcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVjdDtcbiAgICAgICAgfVxuXG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBnZXRPdGhlckRpbSh0aGlzRGltKSB7XG4gICAgICAgIC8vIEZJWE1FXG4gICAgICAgIC8vIOi/meS4qumAu+i+keWSjGdldE90aGVyQXhpc+mHjOS4gOiHtO+8jOS9huaYr+WGmeWcqOi/memHjOaYr+WQpuS4jeWlvVxuICAgICAgICB2YXIgbWFwID0ge3g6ICd5JywgeTogJ3gnLCByYWRpdXM6ICdhbmdsZScsIGFuZ2xlOiAncmFkaXVzJ307XG4gICAgICAgIHJldHVybiBtYXBbdGhpc0RpbV07XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBTbGlkZXJab29tVmlldztcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvY29tcG9uZW50L2RhdGFab29tL1NsaWRlclpvb21WaWV3LmpzXG4vLyBtb2R1bGUgaWQgPSAyMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 216 */
/* unknown exports provided */
/* all exports used */
/*!*****************************************!*\
  !*** ./lib/component/dataZoom/roams.js ***!
  \*****************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * @file Roam controller manager.\n */\n\n\n    // Only create one roam controller for each coordinate system.\n    // one roam controller might be refered by two inside data zoom\n    // components (for example, one for x and one for y). When user\n    // pan or zoom, only dispatch one action for those data zoom\n    // components.\n\n    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 0);\n    var RoamController = __webpack_require__(/*! ../../component/helper/RoamController */ 99);\n    var throttle = __webpack_require__(/*! ../../util/throttle */ 38);\n    var curry = zrUtil.curry;\n\n    var ATTR = '\\0_ec_dataZoom_roams';\n\n    var roams = {\n\n        /**\n         * @public\n         * @param {module:echarts/ExtensionAPI} api\n         * @param {Object} dataZoomInfo\n         * @param {string} dataZoomInfo.coordId\n         * @param {Function} dataZoomInfo.containsPoint\n         * @param {Array.<string>} dataZoomInfo.allCoordIds\n         * @param {string} dataZoomInfo.dataZoomId\n         * @param {number} dataZoomInfo.throttleRate\n         * @param {Function} dataZoomInfo.panGetRange\n         * @param {Function} dataZoomInfo.zoomGetRange\n         */\n        register: function (api, dataZoomInfo) {\n            var store = giveStore(api);\n            var theDataZoomId = dataZoomInfo.dataZoomId;\n            var theCoordId = dataZoomInfo.coordId;\n\n            // Do clean when a dataZoom changes its target coordnate system.\n            // Avoid memory leak, dispose all not-used-registered.\n            zrUtil.each(store, function (record, coordId) {\n                var dataZoomInfos = record.dataZoomInfos;\n                if (dataZoomInfos[theDataZoomId]\n                    && zrUtil.indexOf(dataZoomInfo.allCoordIds, theCoordId) < 0\n                ) {\n                    delete dataZoomInfos[theDataZoomId];\n                    record.count--;\n                }\n            });\n\n            cleanStore(store);\n\n            var record = store[theCoordId];\n            // Create if needed.\n            if (!record) {\n                record = store[theCoordId] = {\n                    coordId: theCoordId,\n                    dataZoomInfos: {},\n                    count: 0\n                };\n                record.controller = createController(api, dataZoomInfo, record);\n                record.dispatchAction = zrUtil.curry(dispatchAction, api);\n            }\n\n            // Consider resize, area should be always updated.\n            record.controller.setPointerChecker(dataZoomInfo.containsPoint);\n\n            // Update throttle.\n            throttle.createOrUpdate(\n                record,\n                'dispatchAction',\n                dataZoomInfo.throttleRate,\n                'fixRate'\n            );\n\n            // Update reference of dataZoom.\n            !(record.dataZoomInfos[theDataZoomId]) && record.count++;\n            record.dataZoomInfos[theDataZoomId] = dataZoomInfo;\n        },\n\n        /**\n         * @public\n         * @param {module:echarts/ExtensionAPI} api\n         * @param {string} dataZoomId\n         */\n        unregister: function (api, dataZoomId) {\n            var store = giveStore(api);\n\n            zrUtil.each(store, function (record) {\n                record.controller.dispose();\n                var dataZoomInfos = record.dataZoomInfos;\n                if (dataZoomInfos[dataZoomId]) {\n                    delete dataZoomInfos[dataZoomId];\n                    record.count--;\n                }\n            });\n\n            cleanStore(store);\n        },\n\n        /**\n         * @public\n         */\n        shouldRecordRange: function (payload, dataZoomId) {\n            if (payload && payload.type === 'dataZoom' && payload.batch) {\n                for (var i = 0, len = payload.batch.length; i < len; i++) {\n                    if (payload.batch[i].dataZoomId === dataZoomId) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        },\n\n        /**\n         * @public\n         */\n        generateCoordId: function (coordModel) {\n            return coordModel.type + '\\0_' + coordModel.id;\n        }\n    };\n\n    /**\n     * Key: coordId, value: {dataZoomInfos: [], count, controller}\n     * @type {Array.<Object>}\n     */\n    function giveStore(api) {\n        // Mount store on zrender instance, so that we do not\n        // need to worry about dispose.\n        var zr = api.getZr();\n        return zr[ATTR] || (zr[ATTR] = {});\n    }\n\n    function createController(api, dataZoomInfo, newRecord) {\n        var controller = new RoamController(api.getZr());\n        controller.enable();\n        controller.on('pan', curry(onPan, newRecord));\n        controller.on('zoom', curry(onZoom, newRecord));\n\n        return controller;\n    }\n\n    function cleanStore(store) {\n        zrUtil.each(store, function (record, coordId) {\n            if (!record.count) {\n                record.controller.dispose();\n                delete store[coordId];\n            }\n        });\n    }\n\n    function onPan(record, dx, dy, oldX, oldY, newX, newY) {\n        wrapAndDispatch(record, function (info) {\n            return info.panGetRange(record.controller, dx, dy, oldX, oldY, newX, newY);\n        });\n    }\n\n    function onZoom(record, scale, mouseX, mouseY) {\n        wrapAndDispatch(record, function (info) {\n            return info.zoomGetRange(record.controller, scale, mouseX, mouseY);\n        });\n    }\n\n    function wrapAndDispatch(record, getRange) {\n        var batch = [];\n\n        zrUtil.each(record.dataZoomInfos, function (info) {\n            var range = getRange(info);\n            range && batch.push({\n                dataZoomId: info.dataZoomId,\n                start: range[0],\n                end: range[1]\n            });\n        });\n\n        record.dispatchAction(batch);\n    }\n\n    /**\n     * This action will be throttled.\n     */\n    function dispatchAction(api, batch) {\n        api.dispatchAction({\n            type: 'dataZoom',\n            batch: batch\n        });\n    }\n\n    module.exports = roams;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjE2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2NvbXBvbmVudC9kYXRhWm9vbS9yb2Ftcy5qcz82YjA5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGZpbGUgUm9hbSBjb250cm9sbGVyIG1hbmFnZXIuXG4gKi9cblxuXG4gICAgLy8gT25seSBjcmVhdGUgb25lIHJvYW0gY29udHJvbGxlciBmb3IgZWFjaCBjb29yZGluYXRlIHN5c3RlbS5cbiAgICAvLyBvbmUgcm9hbSBjb250cm9sbGVyIG1pZ2h0IGJlIHJlZmVyZWQgYnkgdHdvIGluc2lkZSBkYXRhIHpvb21cbiAgICAvLyBjb21wb25lbnRzIChmb3IgZXhhbXBsZSwgb25lIGZvciB4IGFuZCBvbmUgZm9yIHkpLiBXaGVuIHVzZXJcbiAgICAvLyBwYW4gb3Igem9vbSwgb25seSBkaXNwYXRjaCBvbmUgYWN0aW9uIGZvciB0aG9zZSBkYXRhIHpvb21cbiAgICAvLyBjb21wb25lbnRzLlxuXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuICAgIHZhciBSb2FtQ29udHJvbGxlciA9IHJlcXVpcmUoJy4uLy4uL2NvbXBvbmVudC9oZWxwZXIvUm9hbUNvbnRyb2xsZXInKTtcbiAgICB2YXIgdGhyb3R0bGUgPSByZXF1aXJlKCcuLi8uLi91dGlsL3Rocm90dGxlJyk7XG4gICAgdmFyIGN1cnJ5ID0genJVdGlsLmN1cnJ5O1xuXG4gICAgdmFyIEFUVFIgPSAnXFwwX2VjX2RhdGFab29tX3JvYW1zJztcblxuICAgIHZhciByb2FtcyA9IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHB1YmxpY1xuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL0V4dGVuc2lvbkFQSX0gYXBpXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhWm9vbUluZm9cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFab29tSW5mby5jb29yZElkXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGRhdGFab29tSW5mby5jb250YWluc1BvaW50XG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IGRhdGFab29tSW5mby5hbGxDb29yZElkc1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0YVpvb21JbmZvLmRhdGFab29tSWRcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGRhdGFab29tSW5mby50aHJvdHRsZVJhdGVcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZGF0YVpvb21JbmZvLnBhbkdldFJhbmdlXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGRhdGFab29tSW5mby56b29tR2V0UmFuZ2VcbiAgICAgICAgICovXG4gICAgICAgIHJlZ2lzdGVyOiBmdW5jdGlvbiAoYXBpLCBkYXRhWm9vbUluZm8pIHtcbiAgICAgICAgICAgIHZhciBzdG9yZSA9IGdpdmVTdG9yZShhcGkpO1xuICAgICAgICAgICAgdmFyIHRoZURhdGFab29tSWQgPSBkYXRhWm9vbUluZm8uZGF0YVpvb21JZDtcbiAgICAgICAgICAgIHZhciB0aGVDb29yZElkID0gZGF0YVpvb21JbmZvLmNvb3JkSWQ7XG5cbiAgICAgICAgICAgIC8vIERvIGNsZWFuIHdoZW4gYSBkYXRhWm9vbSBjaGFuZ2VzIGl0cyB0YXJnZXQgY29vcmRuYXRlIHN5c3RlbS5cbiAgICAgICAgICAgIC8vIEF2b2lkIG1lbW9yeSBsZWFrLCBkaXNwb3NlIGFsbCBub3QtdXNlZC1yZWdpc3RlcmVkLlxuICAgICAgICAgICAgenJVdGlsLmVhY2goc3RvcmUsIGZ1bmN0aW9uIChyZWNvcmQsIGNvb3JkSWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGF0YVpvb21JbmZvcyA9IHJlY29yZC5kYXRhWm9vbUluZm9zO1xuICAgICAgICAgICAgICAgIGlmIChkYXRhWm9vbUluZm9zW3RoZURhdGFab29tSWRdXG4gICAgICAgICAgICAgICAgICAgICYmIHpyVXRpbC5pbmRleE9mKGRhdGFab29tSW5mby5hbGxDb29yZElkcywgdGhlQ29vcmRJZCkgPCAwXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBkYXRhWm9vbUluZm9zW3RoZURhdGFab29tSWRdO1xuICAgICAgICAgICAgICAgICAgICByZWNvcmQuY291bnQtLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY2xlYW5TdG9yZShzdG9yZSk7XG5cbiAgICAgICAgICAgIHZhciByZWNvcmQgPSBzdG9yZVt0aGVDb29yZElkXTtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBpZiBuZWVkZWQuXG4gICAgICAgICAgICBpZiAoIXJlY29yZCkge1xuICAgICAgICAgICAgICAgIHJlY29yZCA9IHN0b3JlW3RoZUNvb3JkSWRdID0ge1xuICAgICAgICAgICAgICAgICAgICBjb29yZElkOiB0aGVDb29yZElkLFxuICAgICAgICAgICAgICAgICAgICBkYXRhWm9vbUluZm9zOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgY291bnQ6IDBcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJlY29yZC5jb250cm9sbGVyID0gY3JlYXRlQ29udHJvbGxlcihhcGksIGRhdGFab29tSW5mbywgcmVjb3JkKTtcbiAgICAgICAgICAgICAgICByZWNvcmQuZGlzcGF0Y2hBY3Rpb24gPSB6clV0aWwuY3VycnkoZGlzcGF0Y2hBY3Rpb24sIGFwaSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENvbnNpZGVyIHJlc2l6ZSwgYXJlYSBzaG91bGQgYmUgYWx3YXlzIHVwZGF0ZWQuXG4gICAgICAgICAgICByZWNvcmQuY29udHJvbGxlci5zZXRQb2ludGVyQ2hlY2tlcihkYXRhWm9vbUluZm8uY29udGFpbnNQb2ludCk7XG5cbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aHJvdHRsZS5cbiAgICAgICAgICAgIHRocm90dGxlLmNyZWF0ZU9yVXBkYXRlKFxuICAgICAgICAgICAgICAgIHJlY29yZCxcbiAgICAgICAgICAgICAgICAnZGlzcGF0Y2hBY3Rpb24nLFxuICAgICAgICAgICAgICAgIGRhdGFab29tSW5mby50aHJvdHRsZVJhdGUsXG4gICAgICAgICAgICAgICAgJ2ZpeFJhdGUnXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAvLyBVcGRhdGUgcmVmZXJlbmNlIG9mIGRhdGFab29tLlxuICAgICAgICAgICAgIShyZWNvcmQuZGF0YVpvb21JbmZvc1t0aGVEYXRhWm9vbUlkXSkgJiYgcmVjb3JkLmNvdW50Kys7XG4gICAgICAgICAgICByZWNvcmQuZGF0YVpvb21JbmZvc1t0aGVEYXRhWm9vbUlkXSA9IGRhdGFab29tSW5mbztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHB1YmxpY1xuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL0V4dGVuc2lvbkFQSX0gYXBpXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhWm9vbUlkXG4gICAgICAgICAqL1xuICAgICAgICB1bnJlZ2lzdGVyOiBmdW5jdGlvbiAoYXBpLCBkYXRhWm9vbUlkKSB7XG4gICAgICAgICAgICB2YXIgc3RvcmUgPSBnaXZlU3RvcmUoYXBpKTtcblxuICAgICAgICAgICAgenJVdGlsLmVhY2goc3RvcmUsIGZ1bmN0aW9uIChyZWNvcmQpIHtcbiAgICAgICAgICAgICAgICByZWNvcmQuY29udHJvbGxlci5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGFab29tSW5mb3MgPSByZWNvcmQuZGF0YVpvb21JbmZvcztcbiAgICAgICAgICAgICAgICBpZiAoZGF0YVpvb21JbmZvc1tkYXRhWm9vbUlkXSkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgZGF0YVpvb21JbmZvc1tkYXRhWm9vbUlkXTtcbiAgICAgICAgICAgICAgICAgICAgcmVjb3JkLmNvdW50LS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGNsZWFuU3RvcmUoc3RvcmUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHVibGljXG4gICAgICAgICAqL1xuICAgICAgICBzaG91bGRSZWNvcmRSYW5nZTogZnVuY3Rpb24gKHBheWxvYWQsIGRhdGFab29tSWQpIHtcbiAgICAgICAgICAgIGlmIChwYXlsb2FkICYmIHBheWxvYWQudHlwZSA9PT0gJ2RhdGFab29tJyAmJiBwYXlsb2FkLmJhdGNoKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHBheWxvYWQuYmF0Y2gubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBheWxvYWQuYmF0Y2hbaV0uZGF0YVpvb21JZCA9PT0gZGF0YVpvb21JZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwdWJsaWNcbiAgICAgICAgICovXG4gICAgICAgIGdlbmVyYXRlQ29vcmRJZDogZnVuY3Rpb24gKGNvb3JkTW9kZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBjb29yZE1vZGVsLnR5cGUgKyAnXFwwXycgKyBjb29yZE1vZGVsLmlkO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEtleTogY29vcmRJZCwgdmFsdWU6IHtkYXRhWm9vbUluZm9zOiBbXSwgY291bnQsIGNvbnRyb2xsZXJ9XG4gICAgICogQHR5cGUge0FycmF5LjxPYmplY3Q+fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdpdmVTdG9yZShhcGkpIHtcbiAgICAgICAgLy8gTW91bnQgc3RvcmUgb24genJlbmRlciBpbnN0YW5jZSwgc28gdGhhdCB3ZSBkbyBub3RcbiAgICAgICAgLy8gbmVlZCB0byB3b3JyeSBhYm91dCBkaXNwb3NlLlxuICAgICAgICB2YXIgenIgPSBhcGkuZ2V0WnIoKTtcbiAgICAgICAgcmV0dXJuIHpyW0FUVFJdIHx8ICh6cltBVFRSXSA9IHt9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVDb250cm9sbGVyKGFwaSwgZGF0YVpvb21JbmZvLCBuZXdSZWNvcmQpIHtcbiAgICAgICAgdmFyIGNvbnRyb2xsZXIgPSBuZXcgUm9hbUNvbnRyb2xsZXIoYXBpLmdldFpyKCkpO1xuICAgICAgICBjb250cm9sbGVyLmVuYWJsZSgpO1xuICAgICAgICBjb250cm9sbGVyLm9uKCdwYW4nLCBjdXJyeShvblBhbiwgbmV3UmVjb3JkKSk7XG4gICAgICAgIGNvbnRyb2xsZXIub24oJ3pvb20nLCBjdXJyeShvblpvb20sIG5ld1JlY29yZCkpO1xuXG4gICAgICAgIHJldHVybiBjb250cm9sbGVyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFuU3RvcmUoc3RvcmUpIHtcbiAgICAgICAgenJVdGlsLmVhY2goc3RvcmUsIGZ1bmN0aW9uIChyZWNvcmQsIGNvb3JkSWQpIHtcbiAgICAgICAgICAgIGlmICghcmVjb3JkLmNvdW50KSB7XG4gICAgICAgICAgICAgICAgcmVjb3JkLmNvbnRyb2xsZXIuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBzdG9yZVtjb29yZElkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25QYW4ocmVjb3JkLCBkeCwgZHksIG9sZFgsIG9sZFksIG5ld1gsIG5ld1kpIHtcbiAgICAgICAgd3JhcEFuZERpc3BhdGNoKHJlY29yZCwgZnVuY3Rpb24gKGluZm8pIHtcbiAgICAgICAgICAgIHJldHVybiBpbmZvLnBhbkdldFJhbmdlKHJlY29yZC5jb250cm9sbGVyLCBkeCwgZHksIG9sZFgsIG9sZFksIG5ld1gsIG5ld1kpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvblpvb20ocmVjb3JkLCBzY2FsZSwgbW91c2VYLCBtb3VzZVkpIHtcbiAgICAgICAgd3JhcEFuZERpc3BhdGNoKHJlY29yZCwgZnVuY3Rpb24gKGluZm8pIHtcbiAgICAgICAgICAgIHJldHVybiBpbmZvLnpvb21HZXRSYW5nZShyZWNvcmQuY29udHJvbGxlciwgc2NhbGUsIG1vdXNlWCwgbW91c2VZKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd3JhcEFuZERpc3BhdGNoKHJlY29yZCwgZ2V0UmFuZ2UpIHtcbiAgICAgICAgdmFyIGJhdGNoID0gW107XG5cbiAgICAgICAgenJVdGlsLmVhY2gocmVjb3JkLmRhdGFab29tSW5mb3MsIGZ1bmN0aW9uIChpbmZvKSB7XG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSBnZXRSYW5nZShpbmZvKTtcbiAgICAgICAgICAgIHJhbmdlICYmIGJhdGNoLnB1c2goe1xuICAgICAgICAgICAgICAgIGRhdGFab29tSWQ6IGluZm8uZGF0YVpvb21JZCxcbiAgICAgICAgICAgICAgICBzdGFydDogcmFuZ2VbMF0sXG4gICAgICAgICAgICAgICAgZW5kOiByYW5nZVsxXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJlY29yZC5kaXNwYXRjaEFjdGlvbihiYXRjaCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBhY3Rpb24gd2lsbCBiZSB0aHJvdHRsZWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGlzcGF0Y2hBY3Rpb24oYXBpLCBiYXRjaCkge1xuICAgICAgICBhcGkuZGlzcGF0Y2hBY3Rpb24oe1xuICAgICAgICAgICAgdHlwZTogJ2RhdGFab29tJyxcbiAgICAgICAgICAgIGJhdGNoOiBiYXRjaFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJvYW1zO1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9jb21wb25lbnQvZGF0YVpvb20vcm9hbXMuanNcbi8vIG1vZHVsZSBpZCA9IDIxNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 217 */
/* unknown exports provided */
/* all exports used */
/*!*****************************************!*\
  !*** ./lib/component/dataZoomSelect.js ***!
  \*****************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * DataZoom component entry\n */\n\n\n    __webpack_require__(/*! ./dataZoom/typeDefaulter */ 155);\n\n    __webpack_require__(/*! ./dataZoom/DataZoomModel */ 46);\n    __webpack_require__(/*! ./dataZoom/DataZoomView */ 47);\n\n    __webpack_require__(/*! ./dataZoom/SelectZoomModel */ 212);\n    __webpack_require__(/*! ./dataZoom/SelectZoomView */ 213);\n\n    __webpack_require__(/*! ./dataZoom/dataZoomProcessor */ 153);\n    __webpack_require__(/*! ./dataZoom/dataZoomAction */ 152);\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjE3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2NvbXBvbmVudC9kYXRhWm9vbVNlbGVjdC5qcz9hN2VmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRGF0YVpvb20gY29tcG9uZW50IGVudHJ5XG4gKi9cblxuXG4gICAgcmVxdWlyZSgnLi9kYXRhWm9vbS90eXBlRGVmYXVsdGVyJyk7XG5cbiAgICByZXF1aXJlKCcuL2RhdGFab29tL0RhdGFab29tTW9kZWwnKTtcbiAgICByZXF1aXJlKCcuL2RhdGFab29tL0RhdGFab29tVmlldycpO1xuXG4gICAgcmVxdWlyZSgnLi9kYXRhWm9vbS9TZWxlY3Rab29tTW9kZWwnKTtcbiAgICByZXF1aXJlKCcuL2RhdGFab29tL1NlbGVjdFpvb21WaWV3Jyk7XG5cbiAgICByZXF1aXJlKCcuL2RhdGFab29tL2RhdGFab29tUHJvY2Vzc29yJyk7XG4gICAgcmVxdWlyZSgnLi9kYXRhWm9vbS9kYXRhWm9vbUFjdGlvbicpO1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9jb21wb25lbnQvZGF0YVpvb21TZWxlY3QuanNcbi8vIG1vZHVsZSBpZCA9IDIxN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 218 */
/* unknown exports provided */
/* all exports used */
/*!*********************************************!*\
  !*** ./lib/component/legend/LegendModel.js ***!
  \*********************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\n    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 0);\n    var Model = __webpack_require__(/*! ../../model/Model */ 9);\n\n    var LegendModel = __webpack_require__(/*! ../../echarts */ 1).extendComponentModel({\n\n        type: 'legend',\n\n        dependencies: ['series'],\n\n        layoutMode: {\n            type: 'box',\n            ignoreSize: true\n        },\n\n        init: function (option, parentModel, ecModel) {\n            this.mergeDefaultAndTheme(option, ecModel);\n\n            option.selected = option.selected || {};\n        },\n\n        mergeOption: function (option) {\n            LegendModel.superCall(this, 'mergeOption', option);\n        },\n\n        optionUpdated: function () {\n            this._updateData(this.ecModel);\n\n            var legendData = this._data;\n\n            // If selectedMode is single, try to select one\n            if (legendData[0] && this.get('selectedMode') === 'single') {\n                var hasSelected = false;\n                // If has any selected in option.selected\n                for (var i = 0; i < legendData.length; i++) {\n                    var name = legendData[i].get('name');\n                    if (this.isSelected(name)) {\n                        // Force to unselect others\n                        this.select(name);\n                        hasSelected = true;\n                        break;\n                    }\n                }\n                // Try select the first if selectedMode is single\n                !hasSelected && this.select(legendData[0].get('name'));\n            }\n        },\n\n        _updateData: function (ecModel) {\n            var legendData = zrUtil.map(this.get('data') || [], function (dataItem) {\n                // Can be string or number\n                if (typeof dataItem === 'string' || typeof dataItem === 'number') {\n                    dataItem = {\n                        name: dataItem\n                    };\n                }\n                return new Model(dataItem, this, this.ecModel);\n            }, this);\n            this._data = legendData;\n\n            var availableNames = zrUtil.map(ecModel.getSeries(), function (series) {\n                return series.name;\n            });\n            ecModel.eachSeries(function (seriesModel) {\n                if (seriesModel.legendDataProvider) {\n                    var data = seriesModel.legendDataProvider();\n                    availableNames = availableNames.concat(data.mapArray(data.getName));\n                }\n            });\n            /**\n             * @type {Array.<string>}\n             * @private\n             */\n            this._availableNames = availableNames;\n        },\n\n        /**\n         * @return {Array.<module:echarts/model/Model>}\n         */\n        getData: function () {\n            return this._data;\n        },\n\n        /**\n         * @param {string} name\n         */\n        select: function (name) {\n            var selected = this.option.selected;\n            var selectedMode = this.get('selectedMode');\n            if (selectedMode === 'single') {\n                var data = this._data;\n                zrUtil.each(data, function (dataItem) {\n                    selected[dataItem.get('name')] = false;\n                });\n            }\n            selected[name] = true;\n        },\n\n        /**\n         * @param {string} name\n         */\n        unSelect: function (name) {\n            if (this.get('selectedMode') !== 'single') {\n                this.option.selected[name] = false;\n            }\n        },\n\n        /**\n         * @param {string} name\n         */\n        toggleSelected: function (name) {\n            var selected = this.option.selected;\n            // Default is true\n            if (!selected.hasOwnProperty(name)) {\n                selected[name] = true;\n            }\n            this[selected[name] ? 'unSelect' : 'select'](name);\n        },\n\n        /**\n         * @param {string} name\n         */\n        isSelected: function (name) {\n            var selected = this.option.selected;\n            return !(selected.hasOwnProperty(name) && !selected[name])\n                && zrUtil.indexOf(this._availableNames, name) >= 0;\n        },\n\n        defaultOption: {\n            // 一级层叠\n            zlevel: 0,\n            // 二级层叠\n            z: 4,\n            show: true,\n\n            // 布局方式，默认为水平布局，可选为：\n            // 'horizontal' | 'vertical'\n            orient: 'horizontal',\n\n            left: 'center',\n            // right: 'center',\n\n            top: 'top',\n            // bottom: 'top',\n\n            // 水平对齐\n            // 'auto' | 'left' | 'right'\n            // 默认为 'auto', 根据 x 的位置判断是左对齐还是右对齐\n            align: 'auto',\n\n            backgroundColor: 'rgba(0,0,0,0)',\n            // 图例边框颜色\n            borderColor: '#ccc',\n            // 图例边框线宽，单位px，默认为0（无边框）\n            borderWidth: 0,\n            // 图例内边距，单位px，默认各方向内边距为5，\n            // 接受数组分别设定上右下左边距，同css\n            padding: 5,\n            // 各个item之间的间隔，单位px，默认为10，\n            // 横向布局时为水平间隔，纵向布局时为纵向间隔\n            itemGap: 10,\n            // 图例图形宽度\n            itemWidth: 25,\n            // 图例图形高度\n            itemHeight: 14,\n\n            // 图例关闭时候的颜色\n            inactiveColor: '#ccc',\n\n            textStyle: {\n                // 图例文字颜色\n                color: '#333'\n            },\n            // formatter: '',\n            // 选择模式，默认开启图例开关\n            selectedMode: true,\n            // 配置默认选中状态，可配合LEGEND.SELECTED事件做动态数据载入\n            // selected: null,\n            // 图例内容（详见legend.data，数组中每一项代表一个item\n            // data: [],\n\n            // Tooltip 相关配置\n            tooltip: {\n                show: false\n            }\n        }\n    });\n\n    module.exports = LegendModel;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjE4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2NvbXBvbmVudC9sZWdlbmQvTGVnZW5kTW9kZWwuanM/ZDk1YSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgTW9kZWwgPSByZXF1aXJlKCcuLi8uLi9tb2RlbC9Nb2RlbCcpO1xuXG4gICAgdmFyIExlZ2VuZE1vZGVsID0gcmVxdWlyZSgnLi4vLi4vZWNoYXJ0cycpLmV4dGVuZENvbXBvbmVudE1vZGVsKHtcblxuICAgICAgICB0eXBlOiAnbGVnZW5kJyxcblxuICAgICAgICBkZXBlbmRlbmNpZXM6IFsnc2VyaWVzJ10sXG5cbiAgICAgICAgbGF5b3V0TW9kZToge1xuICAgICAgICAgICAgdHlwZTogJ2JveCcsXG4gICAgICAgICAgICBpZ25vcmVTaXplOiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgaW5pdDogZnVuY3Rpb24gKG9wdGlvbiwgcGFyZW50TW9kZWwsIGVjTW9kZWwpIHtcbiAgICAgICAgICAgIHRoaXMubWVyZ2VEZWZhdWx0QW5kVGhlbWUob3B0aW9uLCBlY01vZGVsKTtcblxuICAgICAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gb3B0aW9uLnNlbGVjdGVkIHx8IHt9O1xuICAgICAgICB9LFxuXG4gICAgICAgIG1lcmdlT3B0aW9uOiBmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgICAgICAgICBMZWdlbmRNb2RlbC5zdXBlckNhbGwodGhpcywgJ21lcmdlT3B0aW9uJywgb3B0aW9uKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvcHRpb25VcGRhdGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVEYXRhKHRoaXMuZWNNb2RlbCk7XG5cbiAgICAgICAgICAgIHZhciBsZWdlbmREYXRhID0gdGhpcy5fZGF0YTtcblxuICAgICAgICAgICAgLy8gSWYgc2VsZWN0ZWRNb2RlIGlzIHNpbmdsZSwgdHJ5IHRvIHNlbGVjdCBvbmVcbiAgICAgICAgICAgIGlmIChsZWdlbmREYXRhWzBdICYmIHRoaXMuZ2V0KCdzZWxlY3RlZE1vZGUnKSA9PT0gJ3NpbmdsZScpIHtcbiAgICAgICAgICAgICAgICB2YXIgaGFzU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAvLyBJZiBoYXMgYW55IHNlbGVjdGVkIGluIG9wdGlvbi5zZWxlY3RlZFxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVnZW5kRGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IGxlZ2VuZERhdGFbaV0uZ2V0KCduYW1lJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzU2VsZWN0ZWQobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZvcmNlIHRvIHVuc2VsZWN0IG90aGVyc1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3QobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNTZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUcnkgc2VsZWN0IHRoZSBmaXJzdCBpZiBzZWxlY3RlZE1vZGUgaXMgc2luZ2xlXG4gICAgICAgICAgICAgICAgIWhhc1NlbGVjdGVkICYmIHRoaXMuc2VsZWN0KGxlZ2VuZERhdGFbMF0uZ2V0KCduYW1lJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIF91cGRhdGVEYXRhOiBmdW5jdGlvbiAoZWNNb2RlbCkge1xuICAgICAgICAgICAgdmFyIGxlZ2VuZERhdGEgPSB6clV0aWwubWFwKHRoaXMuZ2V0KCdkYXRhJykgfHwgW10sIGZ1bmN0aW9uIChkYXRhSXRlbSkge1xuICAgICAgICAgICAgICAgIC8vIENhbiBiZSBzdHJpbmcgb3IgbnVtYmVyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhSXRlbSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGRhdGFJdGVtID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICBkYXRhSXRlbSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGRhdGFJdGVtXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTW9kZWwoZGF0YUl0ZW0sIHRoaXMsIHRoaXMuZWNNb2RlbCk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX2RhdGEgPSBsZWdlbmREYXRhO1xuXG4gICAgICAgICAgICB2YXIgYXZhaWxhYmxlTmFtZXMgPSB6clV0aWwubWFwKGVjTW9kZWwuZ2V0U2VyaWVzKCksIGZ1bmN0aW9uIChzZXJpZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VyaWVzLm5hbWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGVjTW9kZWwuZWFjaFNlcmllcyhmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VyaWVzTW9kZWwubGVnZW5kRGF0YVByb3ZpZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwubGVnZW5kRGF0YVByb3ZpZGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIGF2YWlsYWJsZU5hbWVzID0gYXZhaWxhYmxlTmFtZXMuY29uY2F0KGRhdGEubWFwQXJyYXkoZGF0YS5nZXROYW1lKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEB0eXBlIHtBcnJheS48c3RyaW5nPn1cbiAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuX2F2YWlsYWJsZU5hbWVzID0gYXZhaWxhYmxlTmFtZXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5Ljxtb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbD59XG4gICAgICAgICAqL1xuICAgICAgICBnZXREYXRhOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgICAgICovXG4gICAgICAgIHNlbGVjdDogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3RlZCA9IHRoaXMub3B0aW9uLnNlbGVjdGVkO1xuICAgICAgICAgICAgdmFyIHNlbGVjdGVkTW9kZSA9IHRoaXMuZ2V0KCdzZWxlY3RlZE1vZGUnKTtcbiAgICAgICAgICAgIGlmIChzZWxlY3RlZE1vZGUgPT09ICdzaW5nbGUnKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xuICAgICAgICAgICAgICAgIHpyVXRpbC5lYWNoKGRhdGEsIGZ1bmN0aW9uIChkYXRhSXRlbSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZFtkYXRhSXRlbS5nZXQoJ25hbWUnKV0gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGVjdGVkW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgICAgICovXG4gICAgICAgIHVuU2VsZWN0OiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0KCdzZWxlY3RlZE1vZGUnKSAhPT0gJ3NpbmdsZScpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbi5zZWxlY3RlZFtuYW1lXSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAgICAgKi9cbiAgICAgICAgdG9nZ2xlU2VsZWN0ZWQ6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0ZWQgPSB0aGlzLm9wdGlvbi5zZWxlY3RlZDtcbiAgICAgICAgICAgIC8vIERlZmF1bHQgaXMgdHJ1ZVxuICAgICAgICAgICAgaWYgKCFzZWxlY3RlZC5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXNbc2VsZWN0ZWRbbmFtZV0gPyAndW5TZWxlY3QnIDogJ3NlbGVjdCddKG5hbWUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAgICAgKi9cbiAgICAgICAgaXNTZWxlY3RlZDogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3RlZCA9IHRoaXMub3B0aW9uLnNlbGVjdGVkO1xuICAgICAgICAgICAgcmV0dXJuICEoc2VsZWN0ZWQuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgIXNlbGVjdGVkW25hbWVdKVxuICAgICAgICAgICAgICAgICYmIHpyVXRpbC5pbmRleE9mKHRoaXMuX2F2YWlsYWJsZU5hbWVzLCBuYW1lKSA+PSAwO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRlZmF1bHRPcHRpb246IHtcbiAgICAgICAgICAgIC8vIOS4gOe6p+WxguWPoFxuICAgICAgICAgICAgemxldmVsOiAwLFxuICAgICAgICAgICAgLy8g5LqM57qn5bGC5Y+gXG4gICAgICAgICAgICB6OiA0LFxuICAgICAgICAgICAgc2hvdzogdHJ1ZSxcblxuICAgICAgICAgICAgLy8g5biD5bGA5pa55byP77yM6buY6K6k5Li65rC05bmz5biD5bGA77yM5Y+v6YCJ5Li677yaXG4gICAgICAgICAgICAvLyAnaG9yaXpvbnRhbCcgfCAndmVydGljYWwnXG4gICAgICAgICAgICBvcmllbnQ6ICdob3Jpem9udGFsJyxcblxuICAgICAgICAgICAgbGVmdDogJ2NlbnRlcicsXG4gICAgICAgICAgICAvLyByaWdodDogJ2NlbnRlcicsXG5cbiAgICAgICAgICAgIHRvcDogJ3RvcCcsXG4gICAgICAgICAgICAvLyBib3R0b206ICd0b3AnLFxuXG4gICAgICAgICAgICAvLyDmsLTlubPlr7npvZBcbiAgICAgICAgICAgIC8vICdhdXRvJyB8ICdsZWZ0JyB8ICdyaWdodCdcbiAgICAgICAgICAgIC8vIOm7mOiupOS4uiAnYXV0bycsIOagueaNriB4IOeahOS9jee9ruWIpOaWreaYr+W3puWvuem9kOi/mOaYr+WPs+Wvuem9kFxuICAgICAgICAgICAgYWxpZ246ICdhdXRvJyxcblxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAncmdiYSgwLDAsMCwwKScsXG4gICAgICAgICAgICAvLyDlm77kvovovrnmoYbpopzoibJcbiAgICAgICAgICAgIGJvcmRlckNvbG9yOiAnI2NjYycsXG4gICAgICAgICAgICAvLyDlm77kvovovrnmoYbnur/lrr3vvIzljZXkvY1weO+8jOm7mOiupOS4ujDvvIjml6DovrnmoYbvvIlcbiAgICAgICAgICAgIGJvcmRlcldpZHRoOiAwLFxuICAgICAgICAgICAgLy8g5Zu+5L6L5YaF6L656Led77yM5Y2V5L2NcHjvvIzpu5jorqTlkITmlrnlkJHlhoXovrnot53kuLo177yMXG4gICAgICAgICAgICAvLyDmjqXlj5fmlbDnu4TliIbliKvorr7lrprkuIrlj7PkuIvlt6bovrnot53vvIzlkIxjc3NcbiAgICAgICAgICAgIHBhZGRpbmc6IDUsXG4gICAgICAgICAgICAvLyDlkITkuKppdGVt5LmL6Ze055qE6Ze06ZqU77yM5Y2V5L2NcHjvvIzpu5jorqTkuLoxMO+8jFxuICAgICAgICAgICAgLy8g5qiq5ZCR5biD5bGA5pe25Li65rC05bmz6Ze06ZqU77yM57q15ZCR5biD5bGA5pe25Li657q15ZCR6Ze06ZqUXG4gICAgICAgICAgICBpdGVtR2FwOiAxMCxcbiAgICAgICAgICAgIC8vIOWbvuS+i+WbvuW9ouWuveW6plxuICAgICAgICAgICAgaXRlbVdpZHRoOiAyNSxcbiAgICAgICAgICAgIC8vIOWbvuS+i+WbvuW9oumrmOW6plxuICAgICAgICAgICAgaXRlbUhlaWdodDogMTQsXG5cbiAgICAgICAgICAgIC8vIOWbvuS+i+WFs+mXreaXtuWAmeeahOminOiJslxuICAgICAgICAgICAgaW5hY3RpdmVDb2xvcjogJyNjY2MnLFxuXG4gICAgICAgICAgICB0ZXh0U3R5bGU6IHtcbiAgICAgICAgICAgICAgICAvLyDlm77kvovmloflrZfpopzoibJcbiAgICAgICAgICAgICAgICBjb2xvcjogJyMzMzMnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gZm9ybWF0dGVyOiAnJyxcbiAgICAgICAgICAgIC8vIOmAieaLqeaooeW8j++8jOm7mOiupOW8gOWQr+WbvuS+i+W8gOWFs1xuICAgICAgICAgICAgc2VsZWN0ZWRNb2RlOiB0cnVlLFxuICAgICAgICAgICAgLy8g6YWN572u6buY6K6k6YCJ5Lit54q25oCB77yM5Y+v6YWN5ZCITEVHRU5ELlNFTEVDVEVE5LqL5Lu25YGa5Yqo5oCB5pWw5o2u6L295YWlXG4gICAgICAgICAgICAvLyBzZWxlY3RlZDogbnVsbCxcbiAgICAgICAgICAgIC8vIOWbvuS+i+WGheWuue+8iOivpuingWxlZ2VuZC5kYXRh77yM5pWw57uE5Lit5q+P5LiA6aG55Luj6KGo5LiA5LiqaXRlbVxuICAgICAgICAgICAgLy8gZGF0YTogW10sXG5cbiAgICAgICAgICAgIC8vIFRvb2x0aXAg55u45YWz6YWN572uXG4gICAgICAgICAgICB0b29sdGlwOiB7XG4gICAgICAgICAgICAgICAgc2hvdzogZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBMZWdlbmRNb2RlbDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2NvbXBvbmVudC9sZWdlbmQvTGVnZW5kTW9kZWwuanNcbi8vIG1vZHVsZSBpZCA9IDIxOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 219 */
/* unknown exports provided */
/* all exports used */
/*!********************************************!*\
  !*** ./lib/component/legend/LegendView.js ***!
  \********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 0);\n    var symbolCreator = __webpack_require__(/*! ../../util/symbol */ 23);\n    var graphic = __webpack_require__(/*! ../../util/graphic */ 2);\n    var listComponentHelper = __webpack_require__(/*! ../helper/listComponent */ 159);\n\n    var curry = zrUtil.curry;\n\n    function dispatchSelectAction(name, api) {\n        api.dispatchAction({\n            type: 'legendToggleSelect',\n            name: name\n        });\n    }\n\n    function dispatchHighlightAction(seriesModel, dataName, api) {\n        // If element hover will move to a hoverLayer.\n        var el = api.getZr().storage.getDisplayList()[0];\n        if (!(el && el.useHoverLayer)) {\n            seriesModel.get('legendHoverLink') && api.dispatchAction({\n                type: 'highlight',\n                seriesName: seriesModel.name,\n                name: dataName\n            });\n        }\n    }\n\n    function dispatchDownplayAction(seriesModel, dataName, api) {\n        // If element hover will move to a hoverLayer.\n        var el = api.getZr().storage.getDisplayList()[0];\n        if (!(el && el.useHoverLayer)) {\n            seriesModel.get('legendHoverLink') && api.dispatchAction({\n                type: 'downplay',\n                seriesName: seriesModel.name,\n                name: dataName\n            });\n        }\n    }\n\n    module.exports = __webpack_require__(/*! ../../echarts */ 1).extendComponentView({\n\n        type: 'legend',\n\n        init: function () {\n            this._symbolTypeStore = {};\n        },\n\n        render: function (legendModel, ecModel, api) {\n            var group = this.group;\n            group.removeAll();\n\n            if (!legendModel.get('show')) {\n                return;\n            }\n\n            var selectMode = legendModel.get('selectedMode');\n            var itemAlign = legendModel.get('align');\n\n            if (itemAlign === 'auto') {\n                itemAlign = (legendModel.get('left') === 'right'\n                    && legendModel.get('orient') === 'vertical')\n                    ? 'right' : 'left';\n            }\n\n            var legendDrawedMap = {};\n\n            zrUtil.each(legendModel.getData(), function (itemModel) {\n                var name = itemModel.get('name');\n\n                // Use empty string or \\n as a newline string\n                if (name === '' || name === '\\n') {\n                    group.add(new graphic.Group({\n                        newline: true\n                    }));\n                    return;\n                }\n\n                var seriesModel = ecModel.getSeriesByName(name)[0];\n\n                if (legendDrawedMap[name]) {\n                    // Have been drawed\n                    return;\n                }\n\n                // Series legend\n                if (seriesModel) {\n                    var data = seriesModel.getData();\n                    var color = data.getVisual('color');\n\n                    // If color is a callback function\n                    if (typeof color === 'function') {\n                        // Use the first data\n                        color = color(seriesModel.getDataParams(0));\n                    }\n\n                    // Using rect symbol defaultly\n                    var legendSymbolType = data.getVisual('legendSymbol') || 'roundRect';\n                    var symbolType = data.getVisual('symbol');\n\n                    var itemGroup = this._createItem(\n                        name, itemModel, legendModel,\n                        legendSymbolType, symbolType,\n                        itemAlign, color,\n                        selectMode\n                    );\n\n                    itemGroup.on('click', curry(dispatchSelectAction, name, api))\n                        .on('mouseover', curry(dispatchHighlightAction, seriesModel, null, api))\n                        .on('mouseout', curry(dispatchDownplayAction, seriesModel, null, api));\n\n                    legendDrawedMap[name] = true;\n                }\n                else {\n                    // Data legend of pie, funnel\n                    ecModel.eachRawSeries(function (seriesModel) {\n                        // In case multiple series has same data name\n                        if (legendDrawedMap[name]) {\n                            return;\n                        }\n                        if (seriesModel.legendDataProvider) {\n                            var data = seriesModel.legendDataProvider();\n                            var idx = data.indexOfName(name);\n                            if (idx < 0) {\n                                return;\n                            }\n\n                            var color = data.getItemVisual(idx, 'color');\n\n                            var legendSymbolType = 'roundRect';\n\n                            var itemGroup = this._createItem(\n                                name, itemModel, legendModel,\n                                legendSymbolType, null,\n                                itemAlign, color,\n                                selectMode\n                            );\n\n                            itemGroup.on('click', curry(dispatchSelectAction, name, api))\n                                // FIXME Should not specify the series name\n                                .on('mouseover', curry(dispatchHighlightAction, seriesModel, name, api))\n                                .on('mouseout', curry(dispatchDownplayAction, seriesModel, name, api));\n\n                            legendDrawedMap[name] = true;\n                        }\n                    }, this);\n                }\n\n                if (true) {\n                    if (!legendDrawedMap[name]) {\n                        console.warn(name + ' series not exists. Legend data should be same with series name or data name.');\n                    }\n                }\n            }, this);\n\n            listComponentHelper.layout(group, legendModel, api);\n            // Render background after group is layout\n            // FIXME\n            listComponentHelper.addBackground(group, legendModel);\n        },\n\n        _createItem: function (\n            name, itemModel, legendModel,\n            legendSymbolType, symbolType,\n            itemAlign, color, selectMode\n        ) {\n            var itemWidth = legendModel.get('itemWidth');\n            var itemHeight = legendModel.get('itemHeight');\n            var inactiveColor = legendModel.get('inactiveColor');\n\n            var isSelected = legendModel.isSelected(name);\n            var itemGroup = new graphic.Group();\n\n            var textStyleModel = itemModel.getModel('textStyle');\n\n            var itemIcon = itemModel.get('icon');\n\n            var tooltipModel = itemModel.getModel('tooltip');\n            var legendGlobalTooltipModel = tooltipModel.parentModel;\n\n            // Use user given icon first\n            legendSymbolType = itemIcon || legendSymbolType;\n            itemGroup.add(symbolCreator.createSymbol(\n                legendSymbolType, 0, 0, itemWidth, itemHeight, isSelected ? color : inactiveColor\n            ));\n\n            // Compose symbols\n            // PENDING\n            if (!itemIcon && symbolType\n                // At least show one symbol, can't be all none\n                && ((symbolType !== legendSymbolType) || symbolType == 'none')\n            ) {\n                var size = itemHeight * 0.8;\n                if (symbolType === 'none') {\n                    symbolType = 'circle';\n                }\n                // Put symbol in the center\n                itemGroup.add(symbolCreator.createSymbol(\n                    symbolType, (itemWidth - size) / 2, (itemHeight - size) / 2, size, size,\n                    isSelected ? color : inactiveColor\n                ));\n            }\n\n            // Text\n            var textX = itemAlign === 'left' ? itemWidth + 5 : -5;\n            var textAlign = itemAlign;\n\n            var formatter = legendModel.get('formatter');\n            var content = name;\n            if (typeof formatter === 'string' && formatter) {\n                content = formatter.replace('{name}', name != null ? name : '');\n            }\n            else if (typeof formatter === 'function') {\n                content = formatter(name);\n            }\n\n            var text = new graphic.Text({\n                style: {\n                    text: content,\n                    x: textX,\n                    y: itemHeight / 2,\n                    fill: isSelected ? textStyleModel.getTextColor() : inactiveColor,\n                    textFont: textStyleModel.getFont(),\n                    textAlign: textAlign,\n                    textVerticalAlign: 'middle'\n                }\n            });\n            itemGroup.add(text);\n\n            // Add a invisible rect to increase the area of mouse hover\n            var hitRect = new graphic.Rect({\n                shape: itemGroup.getBoundingRect(),\n                invisible: true,\n                tooltip: tooltipModel.get('show') ? zrUtil.extend({\n                    content: name,\n                    // Defaul formatter\n                    formatter: legendGlobalTooltipModel.get('formatter', true) || function () {\n                        return name;\n                    },\n                    formatterParams: {\n                        componentType: 'legend',\n                        legendIndex: legendModel.componentIndex,\n                        name: name,\n                        $vars: ['name']\n                    }\n                }, tooltipModel.option) : null\n            });\n            itemGroup.add(hitRect);\n\n            itemGroup.eachChild(function (child) {\n                child.silent = true;\n            });\n\n            hitRect.silent = !selectMode;\n\n\n\n            this.group.add(itemGroup);\n\n            graphic.setHoverStyle(itemGroup);\n\n            return itemGroup;\n        }\n    });\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjE5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2NvbXBvbmVudC9sZWdlbmQvTGVnZW5kVmlldy5qcz9mMGViIl0sInNvdXJjZXNDb250ZW50IjpbIlxuXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuICAgIHZhciBzeW1ib2xDcmVhdG9yID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9zeW1ib2wnKTtcbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvZ3JhcGhpYycpO1xuICAgIHZhciBsaXN0Q29tcG9uZW50SGVscGVyID0gcmVxdWlyZSgnLi4vaGVscGVyL2xpc3RDb21wb25lbnQnKTtcblxuICAgIHZhciBjdXJyeSA9IHpyVXRpbC5jdXJyeTtcblxuICAgIGZ1bmN0aW9uIGRpc3BhdGNoU2VsZWN0QWN0aW9uKG5hbWUsIGFwaSkge1xuICAgICAgICBhcGkuZGlzcGF0Y2hBY3Rpb24oe1xuICAgICAgICAgICAgdHlwZTogJ2xlZ2VuZFRvZ2dsZVNlbGVjdCcsXG4gICAgICAgICAgICBuYW1lOiBuYW1lXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRpc3BhdGNoSGlnaGxpZ2h0QWN0aW9uKHNlcmllc01vZGVsLCBkYXRhTmFtZSwgYXBpKSB7XG4gICAgICAgIC8vIElmIGVsZW1lbnQgaG92ZXIgd2lsbCBtb3ZlIHRvIGEgaG92ZXJMYXllci5cbiAgICAgICAgdmFyIGVsID0gYXBpLmdldFpyKCkuc3RvcmFnZS5nZXREaXNwbGF5TGlzdCgpWzBdO1xuICAgICAgICBpZiAoIShlbCAmJiBlbC51c2VIb3ZlckxheWVyKSkge1xuICAgICAgICAgICAgc2VyaWVzTW9kZWwuZ2V0KCdsZWdlbmRIb3ZlckxpbmsnKSAmJiBhcGkuZGlzcGF0Y2hBY3Rpb24oe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdoaWdobGlnaHQnLFxuICAgICAgICAgICAgICAgIHNlcmllc05hbWU6IHNlcmllc01vZGVsLm5hbWUsXG4gICAgICAgICAgICAgICAgbmFtZTogZGF0YU5hbWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGlzcGF0Y2hEb3ducGxheUFjdGlvbihzZXJpZXNNb2RlbCwgZGF0YU5hbWUsIGFwaSkge1xuICAgICAgICAvLyBJZiBlbGVtZW50IGhvdmVyIHdpbGwgbW92ZSB0byBhIGhvdmVyTGF5ZXIuXG4gICAgICAgIHZhciBlbCA9IGFwaS5nZXRacigpLnN0b3JhZ2UuZ2V0RGlzcGxheUxpc3QoKVswXTtcbiAgICAgICAgaWYgKCEoZWwgJiYgZWwudXNlSG92ZXJMYXllcikpIHtcbiAgICAgICAgICAgIHNlcmllc01vZGVsLmdldCgnbGVnZW5kSG92ZXJMaW5rJykgJiYgYXBpLmRpc3BhdGNoQWN0aW9uKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnZG93bnBsYXknLFxuICAgICAgICAgICAgICAgIHNlcmllc05hbWU6IHNlcmllc01vZGVsLm5hbWUsXG4gICAgICAgICAgICAgICAgbmFtZTogZGF0YU5hbWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9lY2hhcnRzJykuZXh0ZW5kQ29tcG9uZW50Vmlldyh7XG5cbiAgICAgICAgdHlwZTogJ2xlZ2VuZCcsXG5cbiAgICAgICAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fc3ltYm9sVHlwZVN0b3JlID0ge307XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVuZGVyOiBmdW5jdGlvbiAobGVnZW5kTW9kZWwsIGVjTW9kZWwsIGFwaSkge1xuICAgICAgICAgICAgdmFyIGdyb3VwID0gdGhpcy5ncm91cDtcbiAgICAgICAgICAgIGdyb3VwLnJlbW92ZUFsbCgpO1xuXG4gICAgICAgICAgICBpZiAoIWxlZ2VuZE1vZGVsLmdldCgnc2hvdycpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgc2VsZWN0TW9kZSA9IGxlZ2VuZE1vZGVsLmdldCgnc2VsZWN0ZWRNb2RlJyk7XG4gICAgICAgICAgICB2YXIgaXRlbUFsaWduID0gbGVnZW5kTW9kZWwuZ2V0KCdhbGlnbicpO1xuXG4gICAgICAgICAgICBpZiAoaXRlbUFsaWduID09PSAnYXV0bycpIHtcbiAgICAgICAgICAgICAgICBpdGVtQWxpZ24gPSAobGVnZW5kTW9kZWwuZ2V0KCdsZWZ0JykgPT09ICdyaWdodCdcbiAgICAgICAgICAgICAgICAgICAgJiYgbGVnZW5kTW9kZWwuZ2V0KCdvcmllbnQnKSA9PT0gJ3ZlcnRpY2FsJylcbiAgICAgICAgICAgICAgICAgICAgPyAncmlnaHQnIDogJ2xlZnQnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbGVnZW5kRHJhd2VkTWFwID0ge307XG5cbiAgICAgICAgICAgIHpyVXRpbC5lYWNoKGxlZ2VuZE1vZGVsLmdldERhdGEoKSwgZnVuY3Rpb24gKGl0ZW1Nb2RlbCkge1xuICAgICAgICAgICAgICAgIHZhciBuYW1lID0gaXRlbU1vZGVsLmdldCgnbmFtZScpO1xuXG4gICAgICAgICAgICAgICAgLy8gVXNlIGVtcHR5IHN0cmluZyBvciBcXG4gYXMgYSBuZXdsaW5lIHN0cmluZ1xuICAgICAgICAgICAgICAgIGlmIChuYW1lID09PSAnJyB8fCBuYW1lID09PSAnXFxuJykge1xuICAgICAgICAgICAgICAgICAgICBncm91cC5hZGQobmV3IGdyYXBoaWMuR3JvdXAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3bGluZTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgc2VyaWVzTW9kZWwgPSBlY01vZGVsLmdldFNlcmllc0J5TmFtZShuYW1lKVswXTtcblxuICAgICAgICAgICAgICAgIGlmIChsZWdlbmREcmF3ZWRNYXBbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSGF2ZSBiZWVuIGRyYXdlZFxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gU2VyaWVzIGxlZ2VuZFxuICAgICAgICAgICAgICAgIGlmIChzZXJpZXNNb2RlbCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbG9yID0gZGF0YS5nZXRWaXN1YWwoJ2NvbG9yJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgY29sb3IgaXMgYSBjYWxsYmFjayBmdW5jdGlvblxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVc2UgdGhlIGZpcnN0IGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yID0gY29sb3Ioc2VyaWVzTW9kZWwuZ2V0RGF0YVBhcmFtcygwKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBVc2luZyByZWN0IHN5bWJvbCBkZWZhdWx0bHlcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxlZ2VuZFN5bWJvbFR5cGUgPSBkYXRhLmdldFZpc3VhbCgnbGVnZW5kU3ltYm9sJykgfHwgJ3JvdW5kUmVjdCc7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzeW1ib2xUeXBlID0gZGF0YS5nZXRWaXN1YWwoJ3N5bWJvbCcpO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBpdGVtR3JvdXAgPSB0aGlzLl9jcmVhdGVJdGVtKFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSwgaXRlbU1vZGVsLCBsZWdlbmRNb2RlbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZ2VuZFN5bWJvbFR5cGUsIHN5bWJvbFR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtQWxpZ24sIGNvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0TW9kZVxuICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1Hcm91cC5vbignY2xpY2snLCBjdXJyeShkaXNwYXRjaFNlbGVjdEFjdGlvbiwgbmFtZSwgYXBpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgY3VycnkoZGlzcGF0Y2hIaWdobGlnaHRBY3Rpb24sIHNlcmllc01vZGVsLCBudWxsLCBhcGkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm9uKCdtb3VzZW91dCcsIGN1cnJ5KGRpc3BhdGNoRG93bnBsYXlBY3Rpb24sIHNlcmllc01vZGVsLCBudWxsLCBhcGkpKTtcblxuICAgICAgICAgICAgICAgICAgICBsZWdlbmREcmF3ZWRNYXBbbmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRGF0YSBsZWdlbmQgb2YgcGllLCBmdW5uZWxcbiAgICAgICAgICAgICAgICAgICAgZWNNb2RlbC5lYWNoUmF3U2VyaWVzKGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW4gY2FzZSBtdWx0aXBsZSBzZXJpZXMgaGFzIHNhbWUgZGF0YSBuYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGVnZW5kRHJhd2VkTWFwW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlcmllc01vZGVsLmxlZ2VuZERhdGFQcm92aWRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwubGVnZW5kRGF0YVByb3ZpZGVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlkeCA9IGRhdGEuaW5kZXhPZk5hbWUobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlkeCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2xvciA9IGRhdGEuZ2V0SXRlbVZpc3VhbChpZHgsICdjb2xvcicpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlZ2VuZFN5bWJvbFR5cGUgPSAncm91bmRSZWN0JztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpdGVtR3JvdXAgPSB0aGlzLl9jcmVhdGVJdGVtKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lLCBpdGVtTW9kZWwsIGxlZ2VuZE1vZGVsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWdlbmRTeW1ib2xUeXBlLCBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtQWxpZ24sIGNvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RNb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1Hcm91cC5vbignY2xpY2snLCBjdXJyeShkaXNwYXRjaFNlbGVjdEFjdGlvbiwgbmFtZSwgYXBpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRklYTUUgU2hvdWxkIG5vdCBzcGVjaWZ5IHRoZSBzZXJpZXMgbmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIGN1cnJ5KGRpc3BhdGNoSGlnaGxpZ2h0QWN0aW9uLCBzZXJpZXNNb2RlbCwgbmFtZSwgYXBpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm9uKCdtb3VzZW91dCcsIGN1cnJ5KGRpc3BhdGNoRG93bnBsYXlBY3Rpb24sIHNlcmllc01vZGVsLCBuYW1lLCBhcGkpKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZ2VuZERyYXdlZE1hcFtuYW1lXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbGVnZW5kRHJhd2VkTWFwW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4obmFtZSArICcgc2VyaWVzIG5vdCBleGlzdHMuIExlZ2VuZCBkYXRhIHNob3VsZCBiZSBzYW1lIHdpdGggc2VyaWVzIG5hbWUgb3IgZGF0YSBuYW1lLicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgICAgIGxpc3RDb21wb25lbnRIZWxwZXIubGF5b3V0KGdyb3VwLCBsZWdlbmRNb2RlbCwgYXBpKTtcbiAgICAgICAgICAgIC8vIFJlbmRlciBiYWNrZ3JvdW5kIGFmdGVyIGdyb3VwIGlzIGxheW91dFxuICAgICAgICAgICAgLy8gRklYTUVcbiAgICAgICAgICAgIGxpc3RDb21wb25lbnRIZWxwZXIuYWRkQmFja2dyb3VuZChncm91cCwgbGVnZW5kTW9kZWwpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9jcmVhdGVJdGVtOiBmdW5jdGlvbiAoXG4gICAgICAgICAgICBuYW1lLCBpdGVtTW9kZWwsIGxlZ2VuZE1vZGVsLFxuICAgICAgICAgICAgbGVnZW5kU3ltYm9sVHlwZSwgc3ltYm9sVHlwZSxcbiAgICAgICAgICAgIGl0ZW1BbGlnbiwgY29sb3IsIHNlbGVjdE1vZGVcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB2YXIgaXRlbVdpZHRoID0gbGVnZW5kTW9kZWwuZ2V0KCdpdGVtV2lkdGgnKTtcbiAgICAgICAgICAgIHZhciBpdGVtSGVpZ2h0ID0gbGVnZW5kTW9kZWwuZ2V0KCdpdGVtSGVpZ2h0Jyk7XG4gICAgICAgICAgICB2YXIgaW5hY3RpdmVDb2xvciA9IGxlZ2VuZE1vZGVsLmdldCgnaW5hY3RpdmVDb2xvcicpO1xuXG4gICAgICAgICAgICB2YXIgaXNTZWxlY3RlZCA9IGxlZ2VuZE1vZGVsLmlzU2VsZWN0ZWQobmFtZSk7XG4gICAgICAgICAgICB2YXIgaXRlbUdyb3VwID0gbmV3IGdyYXBoaWMuR3JvdXAoKTtcblxuICAgICAgICAgICAgdmFyIHRleHRTdHlsZU1vZGVsID0gaXRlbU1vZGVsLmdldE1vZGVsKCd0ZXh0U3R5bGUnKTtcblxuICAgICAgICAgICAgdmFyIGl0ZW1JY29uID0gaXRlbU1vZGVsLmdldCgnaWNvbicpO1xuXG4gICAgICAgICAgICB2YXIgdG9vbHRpcE1vZGVsID0gaXRlbU1vZGVsLmdldE1vZGVsKCd0b29sdGlwJyk7XG4gICAgICAgICAgICB2YXIgbGVnZW5kR2xvYmFsVG9vbHRpcE1vZGVsID0gdG9vbHRpcE1vZGVsLnBhcmVudE1vZGVsO1xuXG4gICAgICAgICAgICAvLyBVc2UgdXNlciBnaXZlbiBpY29uIGZpcnN0XG4gICAgICAgICAgICBsZWdlbmRTeW1ib2xUeXBlID0gaXRlbUljb24gfHwgbGVnZW5kU3ltYm9sVHlwZTtcbiAgICAgICAgICAgIGl0ZW1Hcm91cC5hZGQoc3ltYm9sQ3JlYXRvci5jcmVhdGVTeW1ib2woXG4gICAgICAgICAgICAgICAgbGVnZW5kU3ltYm9sVHlwZSwgMCwgMCwgaXRlbVdpZHRoLCBpdGVtSGVpZ2h0LCBpc1NlbGVjdGVkID8gY29sb3IgOiBpbmFjdGl2ZUNvbG9yXG4gICAgICAgICAgICApKTtcblxuICAgICAgICAgICAgLy8gQ29tcG9zZSBzeW1ib2xzXG4gICAgICAgICAgICAvLyBQRU5ESU5HXG4gICAgICAgICAgICBpZiAoIWl0ZW1JY29uICYmIHN5bWJvbFR5cGVcbiAgICAgICAgICAgICAgICAvLyBBdCBsZWFzdCBzaG93IG9uZSBzeW1ib2wsIGNhbid0IGJlIGFsbCBub25lXG4gICAgICAgICAgICAgICAgJiYgKChzeW1ib2xUeXBlICE9PSBsZWdlbmRTeW1ib2xUeXBlKSB8fCBzeW1ib2xUeXBlID09ICdub25lJylcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHZhciBzaXplID0gaXRlbUhlaWdodCAqIDAuODtcbiAgICAgICAgICAgICAgICBpZiAoc3ltYm9sVHlwZSA9PT0gJ25vbmUnKSB7XG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbFR5cGUgPSAnY2lyY2xlJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUHV0IHN5bWJvbCBpbiB0aGUgY2VudGVyXG4gICAgICAgICAgICAgICAgaXRlbUdyb3VwLmFkZChzeW1ib2xDcmVhdG9yLmNyZWF0ZVN5bWJvbChcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sVHlwZSwgKGl0ZW1XaWR0aCAtIHNpemUpIC8gMiwgKGl0ZW1IZWlnaHQgLSBzaXplKSAvIDIsIHNpemUsIHNpemUsXG4gICAgICAgICAgICAgICAgICAgIGlzU2VsZWN0ZWQgPyBjb2xvciA6IGluYWN0aXZlQ29sb3JcbiAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVGV4dFxuICAgICAgICAgICAgdmFyIHRleHRYID0gaXRlbUFsaWduID09PSAnbGVmdCcgPyBpdGVtV2lkdGggKyA1IDogLTU7XG4gICAgICAgICAgICB2YXIgdGV4dEFsaWduID0gaXRlbUFsaWduO1xuXG4gICAgICAgICAgICB2YXIgZm9ybWF0dGVyID0gbGVnZW5kTW9kZWwuZ2V0KCdmb3JtYXR0ZXInKTtcbiAgICAgICAgICAgIHZhciBjb250ZW50ID0gbmFtZTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZm9ybWF0dGVyID09PSAnc3RyaW5nJyAmJiBmb3JtYXR0ZXIpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gZm9ybWF0dGVyLnJlcGxhY2UoJ3tuYW1lfScsIG5hbWUgIT0gbnVsbCA/IG5hbWUgOiAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgZm9ybWF0dGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgY29udGVudCA9IGZvcm1hdHRlcihuYW1lKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHRleHQgPSBuZXcgZ3JhcGhpYy5UZXh0KHtcbiAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBjb250ZW50LFxuICAgICAgICAgICAgICAgICAgICB4OiB0ZXh0WCxcbiAgICAgICAgICAgICAgICAgICAgeTogaXRlbUhlaWdodCAvIDIsXG4gICAgICAgICAgICAgICAgICAgIGZpbGw6IGlzU2VsZWN0ZWQgPyB0ZXh0U3R5bGVNb2RlbC5nZXRUZXh0Q29sb3IoKSA6IGluYWN0aXZlQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgIHRleHRGb250OiB0ZXh0U3R5bGVNb2RlbC5nZXRGb250KCksXG4gICAgICAgICAgICAgICAgICAgIHRleHRBbGlnbjogdGV4dEFsaWduLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0VmVydGljYWxBbGlnbjogJ21pZGRsZSdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGl0ZW1Hcm91cC5hZGQodGV4dCk7XG5cbiAgICAgICAgICAgIC8vIEFkZCBhIGludmlzaWJsZSByZWN0IHRvIGluY3JlYXNlIHRoZSBhcmVhIG9mIG1vdXNlIGhvdmVyXG4gICAgICAgICAgICB2YXIgaGl0UmVjdCA9IG5ldyBncmFwaGljLlJlY3Qoe1xuICAgICAgICAgICAgICAgIHNoYXBlOiBpdGVtR3JvdXAuZ2V0Qm91bmRpbmdSZWN0KCksXG4gICAgICAgICAgICAgICAgaW52aXNpYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHRvb2x0aXA6IHRvb2x0aXBNb2RlbC5nZXQoJ3Nob3cnKSA/IHpyVXRpbC5leHRlbmQoe1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAvLyBEZWZhdWwgZm9ybWF0dGVyXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlcjogbGVnZW5kR2xvYmFsVG9vbHRpcE1vZGVsLmdldCgnZm9ybWF0dGVyJywgdHJ1ZSkgfHwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlclBhcmFtczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50VHlwZTogJ2xlZ2VuZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWdlbmRJbmRleDogbGVnZW5kTW9kZWwuY29tcG9uZW50SW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgJHZhcnM6IFsnbmFtZSddXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCB0b29sdGlwTW9kZWwub3B0aW9uKSA6IG51bGxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaXRlbUdyb3VwLmFkZChoaXRSZWN0KTtcblxuICAgICAgICAgICAgaXRlbUdyb3VwLmVhY2hDaGlsZChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICBjaGlsZC5zaWxlbnQgPSB0cnVlO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGhpdFJlY3Quc2lsZW50ID0gIXNlbGVjdE1vZGU7XG5cblxuXG4gICAgICAgICAgICB0aGlzLmdyb3VwLmFkZChpdGVtR3JvdXApO1xuXG4gICAgICAgICAgICBncmFwaGljLnNldEhvdmVyU3R5bGUoaXRlbUdyb3VwKTtcblxuICAgICAgICAgICAgcmV0dXJuIGl0ZW1Hcm91cDtcbiAgICAgICAgfVxuICAgIH0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvY29tcG9uZW50L2xlZ2VuZC9MZWdlbmRWaWV3LmpzXG4vLyBtb2R1bGUgaWQgPSAyMTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 220 */
/* unknown exports provided */
/* all exports used */
/*!**********************************************!*\
  !*** ./lib/component/legend/legendAction.js ***!
  \**********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * @file Legend action\n */\n\n\n    var echarts = __webpack_require__(/*! ../../echarts */ 1);\n    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 0);\n\n    function legendSelectActionHandler(methodName, payload, ecModel) {\n        var selectedMap = {};\n        var isToggleSelect = methodName === 'toggleSelected';\n        var isSelected;\n        // Update all legend components\n        ecModel.eachComponent('legend', function (legendModel) {\n            if (isToggleSelect && isSelected != null) {\n                // Force other legend has same selected status\n                // Or the first is toggled to true and other are toggled to false\n                // In the case one legend has some item unSelected in option. And if other legend\n                // doesn't has the item, they will assume it is selected.\n                legendModel[isSelected ? 'select' : 'unSelect'](payload.name);\n            }\n            else {\n                legendModel[methodName](payload.name);\n                isSelected = legendModel.isSelected(payload.name);\n            }\n            var legendData = legendModel.getData();\n            zrUtil.each(legendData, function (model) {\n                var name = model.get('name');\n                // Wrap element\n                if (name === '\\n' || name === '') {\n                    return;\n                }\n                var isItemSelected = legendModel.isSelected(name);\n                if (name in selectedMap) {\n                    // Unselected if any legend is unselected\n                    selectedMap[name] = selectedMap[name] && isItemSelected;\n                }\n                else {\n                    selectedMap[name] = isItemSelected;\n                }\n            });\n        });\n        // Return the event explicitly\n        return {\n            name: payload.name,\n            selected: selectedMap\n        };\n    }\n    /**\n     * @event legendToggleSelect\n     * @type {Object}\n     * @property {string} type 'legendToggleSelect'\n     * @property {string} [from]\n     * @property {string} name Series name or data item name\n     */\n    echarts.registerAction(\n        'legendToggleSelect', 'legendselectchanged',\n        zrUtil.curry(legendSelectActionHandler, 'toggleSelected')\n    );\n\n    /**\n     * @event legendSelect\n     * @type {Object}\n     * @property {string} type 'legendSelect'\n     * @property {string} name Series name or data item name\n     */\n    echarts.registerAction(\n        'legendSelect', 'legendselected',\n        zrUtil.curry(legendSelectActionHandler, 'select')\n    );\n\n    /**\n     * @event legendUnSelect\n     * @type {Object}\n     * @property {string} type 'legendUnSelect'\n     * @property {string} name Series name or data item name\n     */\n    echarts.registerAction(\n        'legendUnSelect', 'legendunselected',\n        zrUtil.curry(legendSelectActionHandler, 'unSelect')\n    );\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjIwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2NvbXBvbmVudC9sZWdlbmQvbGVnZW5kQWN0aW9uLmpzP2IxNDciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZmlsZSBMZWdlbmQgYWN0aW9uXG4gKi9cblxuXG4gICAgdmFyIGVjaGFydHMgPSByZXF1aXJlKCcuLi8uLi9lY2hhcnRzJyk7XG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuXG4gICAgZnVuY3Rpb24gbGVnZW5kU2VsZWN0QWN0aW9uSGFuZGxlcihtZXRob2ROYW1lLCBwYXlsb2FkLCBlY01vZGVsKSB7XG4gICAgICAgIHZhciBzZWxlY3RlZE1hcCA9IHt9O1xuICAgICAgICB2YXIgaXNUb2dnbGVTZWxlY3QgPSBtZXRob2ROYW1lID09PSAndG9nZ2xlU2VsZWN0ZWQnO1xuICAgICAgICB2YXIgaXNTZWxlY3RlZDtcbiAgICAgICAgLy8gVXBkYXRlIGFsbCBsZWdlbmQgY29tcG9uZW50c1xuICAgICAgICBlY01vZGVsLmVhY2hDb21wb25lbnQoJ2xlZ2VuZCcsIGZ1bmN0aW9uIChsZWdlbmRNb2RlbCkge1xuICAgICAgICAgICAgaWYgKGlzVG9nZ2xlU2VsZWN0ICYmIGlzU2VsZWN0ZWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIEZvcmNlIG90aGVyIGxlZ2VuZCBoYXMgc2FtZSBzZWxlY3RlZCBzdGF0dXNcbiAgICAgICAgICAgICAgICAvLyBPciB0aGUgZmlyc3QgaXMgdG9nZ2xlZCB0byB0cnVlIGFuZCBvdGhlciBhcmUgdG9nZ2xlZCB0byBmYWxzZVxuICAgICAgICAgICAgICAgIC8vIEluIHRoZSBjYXNlIG9uZSBsZWdlbmQgaGFzIHNvbWUgaXRlbSB1blNlbGVjdGVkIGluIG9wdGlvbi4gQW5kIGlmIG90aGVyIGxlZ2VuZFxuICAgICAgICAgICAgICAgIC8vIGRvZXNuJ3QgaGFzIHRoZSBpdGVtLCB0aGV5IHdpbGwgYXNzdW1lIGl0IGlzIHNlbGVjdGVkLlxuICAgICAgICAgICAgICAgIGxlZ2VuZE1vZGVsW2lzU2VsZWN0ZWQgPyAnc2VsZWN0JyA6ICd1blNlbGVjdCddKHBheWxvYWQubmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZWdlbmRNb2RlbFttZXRob2ROYW1lXShwYXlsb2FkLm5hbWUpO1xuICAgICAgICAgICAgICAgIGlzU2VsZWN0ZWQgPSBsZWdlbmRNb2RlbC5pc1NlbGVjdGVkKHBheWxvYWQubmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbGVnZW5kRGF0YSA9IGxlZ2VuZE1vZGVsLmdldERhdGEoKTtcbiAgICAgICAgICAgIHpyVXRpbC5lYWNoKGxlZ2VuZERhdGEsIGZ1bmN0aW9uIChtb2RlbCkge1xuICAgICAgICAgICAgICAgIHZhciBuYW1lID0gbW9kZWwuZ2V0KCduYW1lJyk7XG4gICAgICAgICAgICAgICAgLy8gV3JhcCBlbGVtZW50XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdcXG4nIHx8IG5hbWUgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGlzSXRlbVNlbGVjdGVkID0gbGVnZW5kTW9kZWwuaXNTZWxlY3RlZChuYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAobmFtZSBpbiBzZWxlY3RlZE1hcCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBVbnNlbGVjdGVkIGlmIGFueSBsZWdlbmQgaXMgdW5zZWxlY3RlZFxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZE1hcFtuYW1lXSA9IHNlbGVjdGVkTWFwW25hbWVdICYmIGlzSXRlbVNlbGVjdGVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRNYXBbbmFtZV0gPSBpc0l0ZW1TZWxlY3RlZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFJldHVybiB0aGUgZXZlbnQgZXhwbGljaXRseVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZTogcGF5bG9hZC5uYW1lLFxuICAgICAgICAgICAgc2VsZWN0ZWQ6IHNlbGVjdGVkTWFwXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBldmVudCBsZWdlbmRUb2dnbGVTZWxlY3RcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0eXBlICdsZWdlbmRUb2dnbGVTZWxlY3QnXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtmcm9tXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lIFNlcmllcyBuYW1lIG9yIGRhdGEgaXRlbSBuYW1lXG4gICAgICovXG4gICAgZWNoYXJ0cy5yZWdpc3RlckFjdGlvbihcbiAgICAgICAgJ2xlZ2VuZFRvZ2dsZVNlbGVjdCcsICdsZWdlbmRzZWxlY3RjaGFuZ2VkJyxcbiAgICAgICAgenJVdGlsLmN1cnJ5KGxlZ2VuZFNlbGVjdEFjdGlvbkhhbmRsZXIsICd0b2dnbGVTZWxlY3RlZCcpXG4gICAgKTtcblxuICAgIC8qKlxuICAgICAqIEBldmVudCBsZWdlbmRTZWxlY3RcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0eXBlICdsZWdlbmRTZWxlY3QnXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWUgU2VyaWVzIG5hbWUgb3IgZGF0YSBpdGVtIG5hbWVcbiAgICAgKi9cbiAgICBlY2hhcnRzLnJlZ2lzdGVyQWN0aW9uKFxuICAgICAgICAnbGVnZW5kU2VsZWN0JywgJ2xlZ2VuZHNlbGVjdGVkJyxcbiAgICAgICAgenJVdGlsLmN1cnJ5KGxlZ2VuZFNlbGVjdEFjdGlvbkhhbmRsZXIsICdzZWxlY3QnKVxuICAgICk7XG5cbiAgICAvKipcbiAgICAgKiBAZXZlbnQgbGVnZW5kVW5TZWxlY3RcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0eXBlICdsZWdlbmRVblNlbGVjdCdcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZSBTZXJpZXMgbmFtZSBvciBkYXRhIGl0ZW0gbmFtZVxuICAgICAqL1xuICAgIGVjaGFydHMucmVnaXN0ZXJBY3Rpb24oXG4gICAgICAgICdsZWdlbmRVblNlbGVjdCcsICdsZWdlbmR1bnNlbGVjdGVkJyxcbiAgICAgICAgenJVdGlsLmN1cnJ5KGxlZ2VuZFNlbGVjdEFjdGlvbkhhbmRsZXIsICd1blNlbGVjdCcpXG4gICAgKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2NvbXBvbmVudC9sZWdlbmQvbGVnZW5kQWN0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAyMjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 221 */
/* unknown exports provided */
/* all exports used */
/*!**********************************************!*\
  !*** ./lib/component/legend/legendFilter.js ***!
  \**********************************************/
/***/ (function(module, exports) {

eval("\n   module.exports = function (ecModel) {\n        var legendModels = ecModel.findComponents({\n            mainType: 'legend'\n        });\n        if (legendModels && legendModels.length) {\n            ecModel.filterSeries(function (series) {\n                // If in any legend component the status is not selected.\n                // Because in legend series is assumed selected when it is not in the legend data.\n                for (var i = 0; i < legendModels.length; i++) {\n                    if (!legendModels[i].isSelected(series.name)) {\n                        return false;\n                    }\n                }\n                return true;\n            });\n        }\n    };\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjIxLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2NvbXBvbmVudC9sZWdlbmQvbGVnZW5kRmlsdGVyLmpzPzgzOGUiXSwic291cmNlc0NvbnRlbnQiOlsiXG4gICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChlY01vZGVsKSB7XG4gICAgICAgIHZhciBsZWdlbmRNb2RlbHMgPSBlY01vZGVsLmZpbmRDb21wb25lbnRzKHtcbiAgICAgICAgICAgIG1haW5UeXBlOiAnbGVnZW5kJ1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGxlZ2VuZE1vZGVscyAmJiBsZWdlbmRNb2RlbHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBlY01vZGVsLmZpbHRlclNlcmllcyhmdW5jdGlvbiAoc2VyaWVzKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgaW4gYW55IGxlZ2VuZCBjb21wb25lbnQgdGhlIHN0YXR1cyBpcyBub3Qgc2VsZWN0ZWQuXG4gICAgICAgICAgICAgICAgLy8gQmVjYXVzZSBpbiBsZWdlbmQgc2VyaWVzIGlzIGFzc3VtZWQgc2VsZWN0ZWQgd2hlbiBpdCBpcyBub3QgaW4gdGhlIGxlZ2VuZCBkYXRhLlxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVnZW5kTW9kZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbGVnZW5kTW9kZWxzW2ldLmlzU2VsZWN0ZWQoc2VyaWVzLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9jb21wb25lbnQvbGVnZW5kL2xlZ2VuZEZpbHRlci5qc1xuLy8gbW9kdWxlIGlkID0gMjIxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 222 */
/* unknown exports provided */
/* all exports used */
/*!***********************************************!*\
  !*** ./lib/component/marker/MarkAreaModel.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    module.exports = __webpack_require__(/*! ./MarkerModel */ 85).extend({\n\n        type: 'markArea',\n\n        defaultOption: {\n            zlevel: 0,\n            // PENDING\n            z: 1,\n            tooltip: {\n                trigger: 'item'\n            },\n            // markArea should fixed on the coordinate system\n            animation: false,\n            label: {\n                normal: {\n                    show: true,\n                    position: 'top'\n                },\n                emphasis: {\n                    show: true,\n                    position: 'top'\n                }\n            },\n            itemStyle: {\n                normal: {\n                    // color and borderColor default to use color from series\n                    // color: 'auto'\n                    // borderColor: 'auto'\n                    borderWidth: 0\n                }\n            }\n        }\n    });\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjIyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2NvbXBvbmVudC9tYXJrZXIvTWFya0FyZWFNb2RlbC5qcz9hZDk4Il0sInNvdXJjZXNDb250ZW50IjpbIlxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL01hcmtlck1vZGVsJykuZXh0ZW5kKHtcblxuICAgICAgICB0eXBlOiAnbWFya0FyZWEnLFxuXG4gICAgICAgIGRlZmF1bHRPcHRpb246IHtcbiAgICAgICAgICAgIHpsZXZlbDogMCxcbiAgICAgICAgICAgIC8vIFBFTkRJTkdcbiAgICAgICAgICAgIHo6IDEsXG4gICAgICAgICAgICB0b29sdGlwOiB7XG4gICAgICAgICAgICAgICAgdHJpZ2dlcjogJ2l0ZW0nXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gbWFya0FyZWEgc2hvdWxkIGZpeGVkIG9uIHRoZSBjb29yZGluYXRlIHN5c3RlbVxuICAgICAgICAgICAgYW5pbWF0aW9uOiBmYWxzZSxcbiAgICAgICAgICAgIGxhYmVsOiB7XG4gICAgICAgICAgICAgICAgbm9ybWFsOiB7XG4gICAgICAgICAgICAgICAgICAgIHNob3c6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAndG9wJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZW1waGFzaXM6IHtcbiAgICAgICAgICAgICAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246ICd0b3AnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGl0ZW1TdHlsZToge1xuICAgICAgICAgICAgICAgIG5vcm1hbDoge1xuICAgICAgICAgICAgICAgICAgICAvLyBjb2xvciBhbmQgYm9yZGVyQ29sb3IgZGVmYXVsdCB0byB1c2UgY29sb3IgZnJvbSBzZXJpZXNcbiAgICAgICAgICAgICAgICAgICAgLy8gY29sb3I6ICdhdXRvJ1xuICAgICAgICAgICAgICAgICAgICAvLyBib3JkZXJDb2xvcjogJ2F1dG8nXG4gICAgICAgICAgICAgICAgICAgIGJvcmRlcldpZHRoOiAwXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9jb21wb25lbnQvbWFya2VyL01hcmtBcmVhTW9kZWwuanNcbi8vIG1vZHVsZSBpZCA9IDIyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 223 */
/* unknown exports provided */
/* all exports used */
/*!**********************************************!*\
  !*** ./lib/component/marker/MarkAreaView.js ***!
  \**********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("// TODO Better on polar\n\n\n    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 0);\n    var List = __webpack_require__(/*! ../../data/List */ 13);\n    var numberUtil = __webpack_require__(/*! ../../util/number */ 3);\n    var graphic = __webpack_require__(/*! ../../util/graphic */ 2);\n    var colorUtil = __webpack_require__(/*! zrender/lib/tool/color */ 21);\n\n    var markerHelper = __webpack_require__(/*! ./markerHelper */ 87);\n\n    var markAreaTransform = function (seriesModel, coordSys, maModel, item) {\n        var lt = markerHelper.dataTransform(seriesModel, item[0]);\n        var rb = markerHelper.dataTransform(seriesModel, item[1]);\n        var retrieve = zrUtil.retrieve;\n\n        // FIXME make sure lt is less than rb\n        var ltCoord = lt.coord;\n        var rbCoord = rb.coord;\n        ltCoord[0] = retrieve(ltCoord[0], -Infinity);\n        ltCoord[1] = retrieve(ltCoord[1], -Infinity);\n\n        rbCoord[0] = retrieve(rbCoord[0], Infinity);\n        rbCoord[1] = retrieve(rbCoord[1], Infinity);\n\n        // Merge option into one\n        var result = zrUtil.mergeAll([{}, lt, rb]);\n\n        result.coord = [\n            lt.coord, rb.coord\n        ];\n        result.x0 = lt.x;\n        result.y0 = lt.y;\n        result.x1 = rb.x;\n        result.y1 = rb.y;\n        return result;\n    };\n\n    function isInifinity(val) {\n        return !isNaN(val) && !isFinite(val);\n    }\n\n    // If a markArea has one dim\n    function ifMarkLineHasOnlyDim(dimIndex, fromCoord, toCoord, coordSys) {\n        var otherDimIndex = 1 - dimIndex;\n        return isInifinity(fromCoord[otherDimIndex]) && isInifinity(toCoord[otherDimIndex]);\n    }\n\n    function markAreaFilter(coordSys, item) {\n        var fromCoord = item.coord[0];\n        var toCoord = item.coord[1];\n        if (coordSys.type === 'cartesian2d') {\n            // In case\n            // {\n            //  markArea: {\n            //    data: [{ yAxis: 2 }]\n            //  }\n            // }\n            if (\n                fromCoord && toCoord &&\n                (ifMarkLineHasOnlyDim(1, fromCoord, toCoord, coordSys)\n                || ifMarkLineHasOnlyDim(0, fromCoord, toCoord, coordSys))\n            ) {\n                return true;\n            }\n        }\n        return markerHelper.dataFilter(coordSys, {\n                coord: fromCoord,\n                x: item.x0,\n                y: item.y0\n            })\n            || markerHelper.dataFilter(coordSys, {\n                coord: toCoord,\n                x: item.x1,\n                y: item.y1\n            });\n    }\n\n    // dims can be ['x0', 'y0'], ['x1', 'y1'], ['x0', 'y1'], ['x1', 'y0']\n    function getSingleMarkerEndPoint(data, idx, dims, seriesModel, api) {\n        var coordSys = seriesModel.coordinateSystem;\n        var itemModel = data.getItemModel(idx);\n\n        var point;\n        var xPx = numberUtil.parsePercent(itemModel.get(dims[0]), api.getWidth());\n        var yPx = numberUtil.parsePercent(itemModel.get(dims[1]), api.getHeight());\n        if (!isNaN(xPx) && !isNaN(yPx)) {\n            point = [xPx, yPx];\n        }\n        else {\n            // Chart like bar may have there own marker positioning logic\n            if (seriesModel.getMarkerPosition) {\n                // Use the getMarkerPoisition\n                point = seriesModel.getMarkerPosition(\n                    data.getValues(dims, idx)\n                );\n            }\n            else {\n                var x = data.get(dims[0], idx);\n                var y = data.get(dims[1], idx);\n                point = coordSys.dataToPoint([x, y], true);\n            }\n            if (coordSys.type === 'cartesian2d') {\n                var xAxis = coordSys.getAxis('x');\n                var yAxis = coordSys.getAxis('y');\n                var x = data.get(dims[0], idx);\n                var y = data.get(dims[1], idx);\n                if (isInifinity(x)) {\n                    point[0] = xAxis.toGlobalCoord(xAxis.getExtent()[dims[0] === 'x0' ? 0 : 1]);\n                }\n                else if (isInifinity(y)) {\n                    point[1] = yAxis.toGlobalCoord(yAxis.getExtent()[dims[1] === 'y0' ? 0 : 1]);\n                }\n            }\n\n            // Use x, y if has any\n            if (!isNaN(xPx)) {\n                point[0] = xPx;\n            }\n            if (!isNaN(yPx)) {\n                point[1] = yPx;\n            }\n        }\n\n        return point;\n    }\n\n    var dimPermutations = [['x0', 'y0'], ['x1', 'y0'], ['x1', 'y1'], ['x0', 'y1']];\n\n    __webpack_require__(/*! ./MarkerView */ 86).extend({\n\n        type: 'markArea',\n\n        updateLayout: function (markAreaModel, ecModel, api) {\n            ecModel.eachSeries(function (seriesModel) {\n                var maModel = seriesModel.markAreaModel;\n                if (maModel) {\n                    var areaData = maModel.getData();\n                    areaData.each(function (idx) {\n                        var points = zrUtil.map(dimPermutations, function (dim) {\n                            return getSingleMarkerEndPoint(areaData, idx, dim, seriesModel, api);\n                        });\n                        // Layout\n                        areaData.setItemLayout(idx, points);\n                        var el = areaData.getItemGraphicEl(idx);\n                        el.setShape('points', points);\n                    });\n                }\n            }, this);\n        },\n\n        renderSeries: function (seriesModel, maModel, ecModel, api) {\n            var coordSys = seriesModel.coordinateSystem;\n            var seriesName = seriesModel.name;\n            var seriesData = seriesModel.getData();\n\n            var areaGroupMap = this.markerGroupMap;\n            var polygonGroup = areaGroupMap[seriesName];\n            if (!polygonGroup) {\n                polygonGroup = areaGroupMap[seriesName] = {\n                    group: new graphic.Group()\n                };\n            }\n            this.group.add(polygonGroup.group);\n            polygonGroup.__keep = true;\n\n            var areaData = createList(coordSys, seriesModel, maModel);\n\n            // Line data for tooltip and formatter\n            maModel.setData(areaData);\n\n            // Update visual and layout of line\n            areaData.each(function (idx) {\n                // Layout\n                areaData.setItemLayout(idx, zrUtil.map(dimPermutations, function (dim) {\n                    return getSingleMarkerEndPoint(areaData, idx, dim, seriesModel, api);\n                }));\n\n                // Visual\n                areaData.setItemVisual(idx, {\n                    color: seriesData.getVisual('color')\n                });\n            });\n\n\n            areaData.diff(polygonGroup.__data)\n                .add(function (idx) {\n                    var polygon = new graphic.Polygon({\n                        shape: {\n                            points: areaData.getItemLayout(idx)\n                        }\n                    });\n                    areaData.setItemGraphicEl(idx, polygon);\n                    polygonGroup.group.add(polygon);\n                })\n                .update(function (newIdx, oldIdx) {\n                    var polygon = polygonGroup.__data.getItemGraphicEl(oldIdx);\n                    graphic.updateProps(polygon, {\n                        shape: {\n                            points: areaData.getItemLayout(newIdx)\n                        }\n                    }, maModel, newIdx);\n                    polygonGroup.group.add(polygon);\n                    areaData.setItemGraphicEl(newIdx, polygon);\n                })\n                .remove(function (idx) {\n                    var polygon = polygonGroup.__data.getItemGraphicEl(idx);\n                    polygonGroup.group.remove(polygon);\n                })\n                .execute();\n\n            areaData.eachItemGraphicEl(function (polygon, idx) {\n                var itemModel = areaData.getItemModel(idx);\n                var labelModel = itemModel.getModel('label.normal');\n                var labelHoverModel = itemModel.getModel('label.emphasis');\n                var color = areaData.getItemVisual(idx, 'color');\n                polygon.useStyle(\n                    zrUtil.defaults(\n                        itemModel.getModel('itemStyle.normal').getItemStyle(),\n                        {\n                            fill: colorUtil.modifyAlpha(color, 0.4),\n                            stroke: color\n                        }\n                    )\n                );\n\n                polygon.hoverStyle = itemModel.getModel('itemStyle.normal').getItemStyle();\n\n                var defaultValue = areaData.getName(idx) || '';\n                var textColor = color || polygon.style.fill;\n\n                if (labelModel.getShallow('show')) {\n                    graphic.setText(polygon.style, labelModel, textColor);\n                    polygon.style.text = zrUtil.retrieve(\n                        maModel.getFormattedLabel(idx, 'normal'),\n                        defaultValue\n                    );\n                }\n                else {\n                    polygon.style.text = '';\n                }\n\n                if (labelHoverModel.getShallow('show')) {\n                    graphic.setText(polygon.hoverStyle, labelHoverModel, textColor);\n                    polygon.hoverStyle.text = zrUtil.retrieve(\n                        maModel.getFormattedLabel(idx, 'emphasis'),\n                        defaultValue\n                    );\n                }\n                else {\n                    polygon.hoverStyle.text = '';\n                }\n\n                graphic.setHoverStyle(polygon, {});\n\n                polygon.dataModel = maModel;\n            });\n\n            polygonGroup.__data = areaData;\n\n            polygonGroup.group.silent = maModel.get('silent') || seriesModel.get('silent');\n        }\n    });\n\n    /**\n     * @inner\n     * @param {module:echarts/coord/*} coordSys\n     * @param {module:echarts/model/Series} seriesModel\n     * @param {module:echarts/model/Model} mpModel\n     */\n    function createList(coordSys, seriesModel, maModel) {\n\n        var coordDimsInfos;\n        var areaData;\n        var dims = ['x0', 'y0', 'x1', 'y1'];\n        if (coordSys) {\n            coordDimsInfos = zrUtil.map(coordSys && coordSys.dimensions, function (coordDim) {\n                var info = seriesModel.getData().getDimensionInfo(\n                    seriesModel.coordDimToDataDim(coordDim)[0]\n                ) || {}; // In map series data don't have lng and lat dimension. Fallback to same with coordSys\n                info.name = coordDim;\n                return info;\n            });\n            areaData = new List(zrUtil.map(dims, function (dim, idx) {\n                return {\n                    name: dim,\n                    type: coordDimsInfos[idx % 2].type\n                };\n            }), maModel);\n        }\n        else {\n            coordDimsInfos =[{\n                name: 'value',\n                type: 'float'\n            }];\n            areaData = new List(coordDimsInfos, maModel);\n        }\n\n        var optData = zrUtil.map(maModel.get('data'), zrUtil.curry(\n            markAreaTransform, seriesModel, coordSys, maModel\n        ));\n        if (coordSys) {\n            optData = zrUtil.filter(\n                optData, zrUtil.curry(markAreaFilter, coordSys)\n            );\n        }\n\n        var dimValueGetter = coordSys ? function (item, dimName, dataIndex, dimIndex) {\n            return item.coord[Math.floor(dimIndex / 2)][dimIndex % 2];\n        } : function (item) {\n            return item.value;\n        };\n        areaData.initData(optData, null, dimValueGetter);\n        areaData.hasItemOption = true;\n        return areaData;\n    }\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjIzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2NvbXBvbmVudC9tYXJrZXIvTWFya0FyZWFWaWV3LmpzPzAyYjciXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVE9ETyBCZXR0ZXIgb24gcG9sYXJcblxuXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuICAgIHZhciBMaXN0ID0gcmVxdWlyZSgnLi4vLi4vZGF0YS9MaXN0Jyk7XG4gICAgdmFyIG51bWJlclV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL251bWJlcicpO1xuICAgIHZhciBncmFwaGljID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9ncmFwaGljJyk7XG4gICAgdmFyIGNvbG9yVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL3Rvb2wvY29sb3InKTtcblxuICAgIHZhciBtYXJrZXJIZWxwZXIgPSByZXF1aXJlKCcuL21hcmtlckhlbHBlcicpO1xuXG4gICAgdmFyIG1hcmtBcmVhVHJhbnNmb3JtID0gZnVuY3Rpb24gKHNlcmllc01vZGVsLCBjb29yZFN5cywgbWFNb2RlbCwgaXRlbSkge1xuICAgICAgICB2YXIgbHQgPSBtYXJrZXJIZWxwZXIuZGF0YVRyYW5zZm9ybShzZXJpZXNNb2RlbCwgaXRlbVswXSk7XG4gICAgICAgIHZhciByYiA9IG1hcmtlckhlbHBlci5kYXRhVHJhbnNmb3JtKHNlcmllc01vZGVsLCBpdGVtWzFdKTtcbiAgICAgICAgdmFyIHJldHJpZXZlID0genJVdGlsLnJldHJpZXZlO1xuXG4gICAgICAgIC8vIEZJWE1FIG1ha2Ugc3VyZSBsdCBpcyBsZXNzIHRoYW4gcmJcbiAgICAgICAgdmFyIGx0Q29vcmQgPSBsdC5jb29yZDtcbiAgICAgICAgdmFyIHJiQ29vcmQgPSByYi5jb29yZDtcbiAgICAgICAgbHRDb29yZFswXSA9IHJldHJpZXZlKGx0Q29vcmRbMF0sIC1JbmZpbml0eSk7XG4gICAgICAgIGx0Q29vcmRbMV0gPSByZXRyaWV2ZShsdENvb3JkWzFdLCAtSW5maW5pdHkpO1xuXG4gICAgICAgIHJiQ29vcmRbMF0gPSByZXRyaWV2ZShyYkNvb3JkWzBdLCBJbmZpbml0eSk7XG4gICAgICAgIHJiQ29vcmRbMV0gPSByZXRyaWV2ZShyYkNvb3JkWzFdLCBJbmZpbml0eSk7XG5cbiAgICAgICAgLy8gTWVyZ2Ugb3B0aW9uIGludG8gb25lXG4gICAgICAgIHZhciByZXN1bHQgPSB6clV0aWwubWVyZ2VBbGwoW3t9LCBsdCwgcmJdKTtcblxuICAgICAgICByZXN1bHQuY29vcmQgPSBbXG4gICAgICAgICAgICBsdC5jb29yZCwgcmIuY29vcmRcbiAgICAgICAgXTtcbiAgICAgICAgcmVzdWx0LngwID0gbHQueDtcbiAgICAgICAgcmVzdWx0LnkwID0gbHQueTtcbiAgICAgICAgcmVzdWx0LngxID0gcmIueDtcbiAgICAgICAgcmVzdWx0LnkxID0gcmIueTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gaXNJbmlmaW5pdHkodmFsKSB7XG4gICAgICAgIHJldHVybiAhaXNOYU4odmFsKSAmJiAhaXNGaW5pdGUodmFsKTtcbiAgICB9XG5cbiAgICAvLyBJZiBhIG1hcmtBcmVhIGhhcyBvbmUgZGltXG4gICAgZnVuY3Rpb24gaWZNYXJrTGluZUhhc09ubHlEaW0oZGltSW5kZXgsIGZyb21Db29yZCwgdG9Db29yZCwgY29vcmRTeXMpIHtcbiAgICAgICAgdmFyIG90aGVyRGltSW5kZXggPSAxIC0gZGltSW5kZXg7XG4gICAgICAgIHJldHVybiBpc0luaWZpbml0eShmcm9tQ29vcmRbb3RoZXJEaW1JbmRleF0pICYmIGlzSW5pZmluaXR5KHRvQ29vcmRbb3RoZXJEaW1JbmRleF0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1hcmtBcmVhRmlsdGVyKGNvb3JkU3lzLCBpdGVtKSB7XG4gICAgICAgIHZhciBmcm9tQ29vcmQgPSBpdGVtLmNvb3JkWzBdO1xuICAgICAgICB2YXIgdG9Db29yZCA9IGl0ZW0uY29vcmRbMV07XG4gICAgICAgIGlmIChjb29yZFN5cy50eXBlID09PSAnY2FydGVzaWFuMmQnKSB7XG4gICAgICAgICAgICAvLyBJbiBjYXNlXG4gICAgICAgICAgICAvLyB7XG4gICAgICAgICAgICAvLyAgbWFya0FyZWE6IHtcbiAgICAgICAgICAgIC8vICAgIGRhdGE6IFt7IHlBeGlzOiAyIH1dXG4gICAgICAgICAgICAvLyAgfVxuICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIGZyb21Db29yZCAmJiB0b0Nvb3JkICYmXG4gICAgICAgICAgICAgICAgKGlmTWFya0xpbmVIYXNPbmx5RGltKDEsIGZyb21Db29yZCwgdG9Db29yZCwgY29vcmRTeXMpXG4gICAgICAgICAgICAgICAgfHwgaWZNYXJrTGluZUhhc09ubHlEaW0oMCwgZnJvbUNvb3JkLCB0b0Nvb3JkLCBjb29yZFN5cykpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWFya2VySGVscGVyLmRhdGFGaWx0ZXIoY29vcmRTeXMsIHtcbiAgICAgICAgICAgICAgICBjb29yZDogZnJvbUNvb3JkLFxuICAgICAgICAgICAgICAgIHg6IGl0ZW0ueDAsXG4gICAgICAgICAgICAgICAgeTogaXRlbS55MFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIHx8IG1hcmtlckhlbHBlci5kYXRhRmlsdGVyKGNvb3JkU3lzLCB7XG4gICAgICAgICAgICAgICAgY29vcmQ6IHRvQ29vcmQsXG4gICAgICAgICAgICAgICAgeDogaXRlbS54MSxcbiAgICAgICAgICAgICAgICB5OiBpdGVtLnkxXG4gICAgICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBkaW1zIGNhbiBiZSBbJ3gwJywgJ3kwJ10sIFsneDEnLCAneTEnXSwgWyd4MCcsICd5MSddLCBbJ3gxJywgJ3kwJ11cbiAgICBmdW5jdGlvbiBnZXRTaW5nbGVNYXJrZXJFbmRQb2ludChkYXRhLCBpZHgsIGRpbXMsIHNlcmllc01vZGVsLCBhcGkpIHtcbiAgICAgICAgdmFyIGNvb3JkU3lzID0gc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcbiAgICAgICAgdmFyIGl0ZW1Nb2RlbCA9IGRhdGEuZ2V0SXRlbU1vZGVsKGlkeCk7XG5cbiAgICAgICAgdmFyIHBvaW50O1xuICAgICAgICB2YXIgeFB4ID0gbnVtYmVyVXRpbC5wYXJzZVBlcmNlbnQoaXRlbU1vZGVsLmdldChkaW1zWzBdKSwgYXBpLmdldFdpZHRoKCkpO1xuICAgICAgICB2YXIgeVB4ID0gbnVtYmVyVXRpbC5wYXJzZVBlcmNlbnQoaXRlbU1vZGVsLmdldChkaW1zWzFdKSwgYXBpLmdldEhlaWdodCgpKTtcbiAgICAgICAgaWYgKCFpc05hTih4UHgpICYmICFpc05hTih5UHgpKSB7XG4gICAgICAgICAgICBwb2ludCA9IFt4UHgsIHlQeF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBDaGFydCBsaWtlIGJhciBtYXkgaGF2ZSB0aGVyZSBvd24gbWFya2VyIHBvc2l0aW9uaW5nIGxvZ2ljXG4gICAgICAgICAgICBpZiAoc2VyaWVzTW9kZWwuZ2V0TWFya2VyUG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAvLyBVc2UgdGhlIGdldE1hcmtlclBvaXNpdGlvblxuICAgICAgICAgICAgICAgIHBvaW50ID0gc2VyaWVzTW9kZWwuZ2V0TWFya2VyUG9zaXRpb24oXG4gICAgICAgICAgICAgICAgICAgIGRhdGEuZ2V0VmFsdWVzKGRpbXMsIGlkeClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHggPSBkYXRhLmdldChkaW1zWzBdLCBpZHgpO1xuICAgICAgICAgICAgICAgIHZhciB5ID0gZGF0YS5nZXQoZGltc1sxXSwgaWR4KTtcbiAgICAgICAgICAgICAgICBwb2ludCA9IGNvb3JkU3lzLmRhdGFUb1BvaW50KFt4LCB5XSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29vcmRTeXMudHlwZSA9PT0gJ2NhcnRlc2lhbjJkJykge1xuICAgICAgICAgICAgICAgIHZhciB4QXhpcyA9IGNvb3JkU3lzLmdldEF4aXMoJ3gnKTtcbiAgICAgICAgICAgICAgICB2YXIgeUF4aXMgPSBjb29yZFN5cy5nZXRBeGlzKCd5Jyk7XG4gICAgICAgICAgICAgICAgdmFyIHggPSBkYXRhLmdldChkaW1zWzBdLCBpZHgpO1xuICAgICAgICAgICAgICAgIHZhciB5ID0gZGF0YS5nZXQoZGltc1sxXSwgaWR4KTtcbiAgICAgICAgICAgICAgICBpZiAoaXNJbmlmaW5pdHkoeCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRbMF0gPSB4QXhpcy50b0dsb2JhbENvb3JkKHhBeGlzLmdldEV4dGVudCgpW2RpbXNbMF0gPT09ICd4MCcgPyAwIDogMV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0luaWZpbml0eSh5KSkge1xuICAgICAgICAgICAgICAgICAgICBwb2ludFsxXSA9IHlBeGlzLnRvR2xvYmFsQ29vcmQoeUF4aXMuZ2V0RXh0ZW50KClbZGltc1sxXSA9PT0gJ3kwJyA/IDAgOiAxXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBVc2UgeCwgeSBpZiBoYXMgYW55XG4gICAgICAgICAgICBpZiAoIWlzTmFOKHhQeCkpIHtcbiAgICAgICAgICAgICAgICBwb2ludFswXSA9IHhQeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNOYU4oeVB4KSkge1xuICAgICAgICAgICAgICAgIHBvaW50WzFdID0geVB4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBvaW50O1xuICAgIH1cblxuICAgIHZhciBkaW1QZXJtdXRhdGlvbnMgPSBbWyd4MCcsICd5MCddLCBbJ3gxJywgJ3kwJ10sIFsneDEnLCAneTEnXSwgWyd4MCcsICd5MSddXTtcblxuICAgIHJlcXVpcmUoJy4vTWFya2VyVmlldycpLmV4dGVuZCh7XG5cbiAgICAgICAgdHlwZTogJ21hcmtBcmVhJyxcblxuICAgICAgICB1cGRhdGVMYXlvdXQ6IGZ1bmN0aW9uIChtYXJrQXJlYU1vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgICAgICAgICAgIGVjTW9kZWwuZWFjaFNlcmllcyhmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWFNb2RlbCA9IHNlcmllc01vZGVsLm1hcmtBcmVhTW9kZWw7XG4gICAgICAgICAgICAgICAgaWYgKG1hTW9kZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyZWFEYXRhID0gbWFNb2RlbC5nZXREYXRhKCk7XG4gICAgICAgICAgICAgICAgICAgIGFyZWFEYXRhLmVhY2goZnVuY3Rpb24gKGlkeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBvaW50cyA9IHpyVXRpbC5tYXAoZGltUGVybXV0YXRpb25zLCBmdW5jdGlvbiAoZGltKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldFNpbmdsZU1hcmtlckVuZFBvaW50KGFyZWFEYXRhLCBpZHgsIGRpbSwgc2VyaWVzTW9kZWwsIGFwaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIExheW91dFxuICAgICAgICAgICAgICAgICAgICAgICAgYXJlYURhdGEuc2V0SXRlbUxheW91dChpZHgsIHBvaW50cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWwgPSBhcmVhRGF0YS5nZXRJdGVtR3JhcGhpY0VsKGlkeCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbC5zZXRTaGFwZSgncG9pbnRzJywgcG9pbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVuZGVyU2VyaWVzOiBmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIG1hTW9kZWwsIGVjTW9kZWwsIGFwaSkge1xuICAgICAgICAgICAgdmFyIGNvb3JkU3lzID0gc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcbiAgICAgICAgICAgIHZhciBzZXJpZXNOYW1lID0gc2VyaWVzTW9kZWwubmFtZTtcbiAgICAgICAgICAgIHZhciBzZXJpZXNEYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuXG4gICAgICAgICAgICB2YXIgYXJlYUdyb3VwTWFwID0gdGhpcy5tYXJrZXJHcm91cE1hcDtcbiAgICAgICAgICAgIHZhciBwb2x5Z29uR3JvdXAgPSBhcmVhR3JvdXBNYXBbc2VyaWVzTmFtZV07XG4gICAgICAgICAgICBpZiAoIXBvbHlnb25Hcm91cCkge1xuICAgICAgICAgICAgICAgIHBvbHlnb25Hcm91cCA9IGFyZWFHcm91cE1hcFtzZXJpZXNOYW1lXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXA6IG5ldyBncmFwaGljLkdyb3VwKClcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ncm91cC5hZGQocG9seWdvbkdyb3VwLmdyb3VwKTtcbiAgICAgICAgICAgIHBvbHlnb25Hcm91cC5fX2tlZXAgPSB0cnVlO1xuXG4gICAgICAgICAgICB2YXIgYXJlYURhdGEgPSBjcmVhdGVMaXN0KGNvb3JkU3lzLCBzZXJpZXNNb2RlbCwgbWFNb2RlbCk7XG5cbiAgICAgICAgICAgIC8vIExpbmUgZGF0YSBmb3IgdG9vbHRpcCBhbmQgZm9ybWF0dGVyXG4gICAgICAgICAgICBtYU1vZGVsLnNldERhdGEoYXJlYURhdGEpO1xuXG4gICAgICAgICAgICAvLyBVcGRhdGUgdmlzdWFsIGFuZCBsYXlvdXQgb2YgbGluZVxuICAgICAgICAgICAgYXJlYURhdGEuZWFjaChmdW5jdGlvbiAoaWR4KSB7XG4gICAgICAgICAgICAgICAgLy8gTGF5b3V0XG4gICAgICAgICAgICAgICAgYXJlYURhdGEuc2V0SXRlbUxheW91dChpZHgsIHpyVXRpbC5tYXAoZGltUGVybXV0YXRpb25zLCBmdW5jdGlvbiAoZGltKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRTaW5nbGVNYXJrZXJFbmRQb2ludChhcmVhRGF0YSwgaWR4LCBkaW0sIHNlcmllc01vZGVsLCBhcGkpO1xuICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgICAgIC8vIFZpc3VhbFxuICAgICAgICAgICAgICAgIGFyZWFEYXRhLnNldEl0ZW1WaXN1YWwoaWR4LCB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiBzZXJpZXNEYXRhLmdldFZpc3VhbCgnY29sb3InKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG5cblxuICAgICAgICAgICAgYXJlYURhdGEuZGlmZihwb2x5Z29uR3JvdXAuX19kYXRhKVxuICAgICAgICAgICAgICAgIC5hZGQoZnVuY3Rpb24gKGlkeCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcG9seWdvbiA9IG5ldyBncmFwaGljLlBvbHlnb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludHM6IGFyZWFEYXRhLmdldEl0ZW1MYXlvdXQoaWR4KVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgYXJlYURhdGEuc2V0SXRlbUdyYXBoaWNFbChpZHgsIHBvbHlnb24pO1xuICAgICAgICAgICAgICAgICAgICBwb2x5Z29uR3JvdXAuZ3JvdXAuYWRkKHBvbHlnb24pO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnVwZGF0ZShmdW5jdGlvbiAobmV3SWR4LCBvbGRJZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvbHlnb24gPSBwb2x5Z29uR3JvdXAuX19kYXRhLmdldEl0ZW1HcmFwaGljRWwob2xkSWR4KTtcbiAgICAgICAgICAgICAgICAgICAgZ3JhcGhpYy51cGRhdGVQcm9wcyhwb2x5Z29uLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50czogYXJlYURhdGEuZ2V0SXRlbUxheW91dChuZXdJZHgpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIG1hTW9kZWwsIG5ld0lkeCk7XG4gICAgICAgICAgICAgICAgICAgIHBvbHlnb25Hcm91cC5ncm91cC5hZGQocG9seWdvbik7XG4gICAgICAgICAgICAgICAgICAgIGFyZWFEYXRhLnNldEl0ZW1HcmFwaGljRWwobmV3SWR4LCBwb2x5Z29uKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5yZW1vdmUoZnVuY3Rpb24gKGlkeCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcG9seWdvbiA9IHBvbHlnb25Hcm91cC5fX2RhdGEuZ2V0SXRlbUdyYXBoaWNFbChpZHgpO1xuICAgICAgICAgICAgICAgICAgICBwb2x5Z29uR3JvdXAuZ3JvdXAucmVtb3ZlKHBvbHlnb24pO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmV4ZWN1dGUoKTtcblxuICAgICAgICAgICAgYXJlYURhdGEuZWFjaEl0ZW1HcmFwaGljRWwoZnVuY3Rpb24gKHBvbHlnb24sIGlkeCkge1xuICAgICAgICAgICAgICAgIHZhciBpdGVtTW9kZWwgPSBhcmVhRGF0YS5nZXRJdGVtTW9kZWwoaWR4KTtcbiAgICAgICAgICAgICAgICB2YXIgbGFiZWxNb2RlbCA9IGl0ZW1Nb2RlbC5nZXRNb2RlbCgnbGFiZWwubm9ybWFsJyk7XG4gICAgICAgICAgICAgICAgdmFyIGxhYmVsSG92ZXJNb2RlbCA9IGl0ZW1Nb2RlbC5nZXRNb2RlbCgnbGFiZWwuZW1waGFzaXMnKTtcbiAgICAgICAgICAgICAgICB2YXIgY29sb3IgPSBhcmVhRGF0YS5nZXRJdGVtVmlzdWFsKGlkeCwgJ2NvbG9yJyk7XG4gICAgICAgICAgICAgICAgcG9seWdvbi51c2VTdHlsZShcbiAgICAgICAgICAgICAgICAgICAgenJVdGlsLmRlZmF1bHRzKFxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbU1vZGVsLmdldE1vZGVsKCdpdGVtU3R5bGUubm9ybWFsJykuZ2V0SXRlbVN0eWxlKCksXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsbDogY29sb3JVdGlsLm1vZGlmeUFscGhhKGNvbG9yLCAwLjQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZTogY29sb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICBwb2x5Z29uLmhvdmVyU3R5bGUgPSBpdGVtTW9kZWwuZ2V0TW9kZWwoJ2l0ZW1TdHlsZS5ub3JtYWwnKS5nZXRJdGVtU3R5bGUoKTtcblxuICAgICAgICAgICAgICAgIHZhciBkZWZhdWx0VmFsdWUgPSBhcmVhRGF0YS5nZXROYW1lKGlkeCkgfHwgJyc7XG4gICAgICAgICAgICAgICAgdmFyIHRleHRDb2xvciA9IGNvbG9yIHx8IHBvbHlnb24uc3R5bGUuZmlsbDtcblxuICAgICAgICAgICAgICAgIGlmIChsYWJlbE1vZGVsLmdldFNoYWxsb3coJ3Nob3cnKSkge1xuICAgICAgICAgICAgICAgICAgICBncmFwaGljLnNldFRleHQocG9seWdvbi5zdHlsZSwgbGFiZWxNb2RlbCwgdGV4dENvbG9yKTtcbiAgICAgICAgICAgICAgICAgICAgcG9seWdvbi5zdHlsZS50ZXh0ID0genJVdGlsLnJldHJpZXZlKFxuICAgICAgICAgICAgICAgICAgICAgICAgbWFNb2RlbC5nZXRGb3JtYXR0ZWRMYWJlbChpZHgsICdub3JtYWwnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcG9seWdvbi5zdHlsZS50ZXh0ID0gJyc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGxhYmVsSG92ZXJNb2RlbC5nZXRTaGFsbG93KCdzaG93JykpIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JhcGhpYy5zZXRUZXh0KHBvbHlnb24uaG92ZXJTdHlsZSwgbGFiZWxIb3Zlck1vZGVsLCB0ZXh0Q29sb3IpO1xuICAgICAgICAgICAgICAgICAgICBwb2x5Z29uLmhvdmVyU3R5bGUudGV4dCA9IHpyVXRpbC5yZXRyaWV2ZShcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hTW9kZWwuZ2V0Rm9ybWF0dGVkTGFiZWwoaWR4LCAnZW1waGFzaXMnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcG9seWdvbi5ob3ZlclN0eWxlLnRleHQgPSAnJztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBncmFwaGljLnNldEhvdmVyU3R5bGUocG9seWdvbiwge30pO1xuXG4gICAgICAgICAgICAgICAgcG9seWdvbi5kYXRhTW9kZWwgPSBtYU1vZGVsO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHBvbHlnb25Hcm91cC5fX2RhdGEgPSBhcmVhRGF0YTtcblxuICAgICAgICAgICAgcG9seWdvbkdyb3VwLmdyb3VwLnNpbGVudCA9IG1hTW9kZWwuZ2V0KCdzaWxlbnQnKSB8fCBzZXJpZXNNb2RlbC5nZXQoJ3NpbGVudCcpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBAaW5uZXJcbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2Nvb3JkLyp9IGNvb3JkU3lzXG4gICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9TZXJpZXN9IHNlcmllc01vZGVsXG4gICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH0gbXBNb2RlbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUxpc3QoY29vcmRTeXMsIHNlcmllc01vZGVsLCBtYU1vZGVsKSB7XG5cbiAgICAgICAgdmFyIGNvb3JkRGltc0luZm9zO1xuICAgICAgICB2YXIgYXJlYURhdGE7XG4gICAgICAgIHZhciBkaW1zID0gWyd4MCcsICd5MCcsICd4MScsICd5MSddO1xuICAgICAgICBpZiAoY29vcmRTeXMpIHtcbiAgICAgICAgICAgIGNvb3JkRGltc0luZm9zID0genJVdGlsLm1hcChjb29yZFN5cyAmJiBjb29yZFN5cy5kaW1lbnNpb25zLCBmdW5jdGlvbiAoY29vcmREaW0pIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5mbyA9IHNlcmllc01vZGVsLmdldERhdGEoKS5nZXREaW1lbnNpb25JbmZvKFxuICAgICAgICAgICAgICAgICAgICBzZXJpZXNNb2RlbC5jb29yZERpbVRvRGF0YURpbShjb29yZERpbSlbMF1cbiAgICAgICAgICAgICAgICApIHx8IHt9OyAvLyBJbiBtYXAgc2VyaWVzIGRhdGEgZG9uJ3QgaGF2ZSBsbmcgYW5kIGxhdCBkaW1lbnNpb24uIEZhbGxiYWNrIHRvIHNhbWUgd2l0aCBjb29yZFN5c1xuICAgICAgICAgICAgICAgIGluZm8ubmFtZSA9IGNvb3JkRGltO1xuICAgICAgICAgICAgICAgIHJldHVybiBpbmZvO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhcmVhRGF0YSA9IG5ldyBMaXN0KHpyVXRpbC5tYXAoZGltcywgZnVuY3Rpb24gKGRpbSwgaWR4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogZGltLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBjb29yZERpbXNJbmZvc1tpZHggJSAyXS50eXBlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pLCBtYU1vZGVsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvb3JkRGltc0luZm9zID1be1xuICAgICAgICAgICAgICAgIG5hbWU6ICd2YWx1ZScsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2Zsb2F0J1xuICAgICAgICAgICAgfV07XG4gICAgICAgICAgICBhcmVhRGF0YSA9IG5ldyBMaXN0KGNvb3JkRGltc0luZm9zLCBtYU1vZGVsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvcHREYXRhID0genJVdGlsLm1hcChtYU1vZGVsLmdldCgnZGF0YScpLCB6clV0aWwuY3VycnkoXG4gICAgICAgICAgICBtYXJrQXJlYVRyYW5zZm9ybSwgc2VyaWVzTW9kZWwsIGNvb3JkU3lzLCBtYU1vZGVsXG4gICAgICAgICkpO1xuICAgICAgICBpZiAoY29vcmRTeXMpIHtcbiAgICAgICAgICAgIG9wdERhdGEgPSB6clV0aWwuZmlsdGVyKFxuICAgICAgICAgICAgICAgIG9wdERhdGEsIHpyVXRpbC5jdXJyeShtYXJrQXJlYUZpbHRlciwgY29vcmRTeXMpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRpbVZhbHVlR2V0dGVyID0gY29vcmRTeXMgPyBmdW5jdGlvbiAoaXRlbSwgZGltTmFtZSwgZGF0YUluZGV4LCBkaW1JbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW0uY29vcmRbTWF0aC5mbG9vcihkaW1JbmRleCAvIDIpXVtkaW1JbmRleCAlIDJdO1xuICAgICAgICB9IDogZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtLnZhbHVlO1xuICAgICAgICB9O1xuICAgICAgICBhcmVhRGF0YS5pbml0RGF0YShvcHREYXRhLCBudWxsLCBkaW1WYWx1ZUdldHRlcik7XG4gICAgICAgIGFyZWFEYXRhLmhhc0l0ZW1PcHRpb24gPSB0cnVlO1xuICAgICAgICByZXR1cm4gYXJlYURhdGE7XG4gICAgfVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvY29tcG9uZW50L21hcmtlci9NYXJrQXJlYVZpZXcuanNcbi8vIG1vZHVsZSBpZCA9IDIyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 224 */
/* unknown exports provided */
/* all exports used */
/*!***********************************************!*\
  !*** ./lib/component/marker/MarkLineModel.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    module.exports = __webpack_require__(/*! ./MarkerModel */ 85).extend({\n\n        type: 'markLine',\n\n        defaultOption: {\n            zlevel: 0,\n            z: 5,\n\n            symbol: ['circle', 'arrow'],\n            symbolSize: [8, 16],\n\n            //symbolRotate: 0,\n\n            precision: 2,\n            tooltip: {\n                trigger: 'item'\n            },\n            label: {\n                normal: {\n                    show: true,\n                    position: 'end'\n                },\n                emphasis: {\n                    show: true\n                }\n            },\n            lineStyle: {\n                normal: {\n                    type: 'dashed'\n                },\n                emphasis: {\n                    width: 3\n                }\n            },\n            animationEasing: 'linear'\n        }\n    });\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjI0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2NvbXBvbmVudC9tYXJrZXIvTWFya0xpbmVNb2RlbC5qcz9lZjhkIl0sInNvdXJjZXNDb250ZW50IjpbIlxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL01hcmtlck1vZGVsJykuZXh0ZW5kKHtcblxuICAgICAgICB0eXBlOiAnbWFya0xpbmUnLFxuXG4gICAgICAgIGRlZmF1bHRPcHRpb246IHtcbiAgICAgICAgICAgIHpsZXZlbDogMCxcbiAgICAgICAgICAgIHo6IDUsXG5cbiAgICAgICAgICAgIHN5bWJvbDogWydjaXJjbGUnLCAnYXJyb3cnXSxcbiAgICAgICAgICAgIHN5bWJvbFNpemU6IFs4LCAxNl0sXG5cbiAgICAgICAgICAgIC8vc3ltYm9sUm90YXRlOiAwLFxuXG4gICAgICAgICAgICBwcmVjaXNpb246IDIsXG4gICAgICAgICAgICB0b29sdGlwOiB7XG4gICAgICAgICAgICAgICAgdHJpZ2dlcjogJ2l0ZW0nXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICAgICAgICBub3JtYWw6IHtcbiAgICAgICAgICAgICAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246ICdlbmQnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlbXBoYXNpczoge1xuICAgICAgICAgICAgICAgICAgICBzaG93OiB0cnVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxpbmVTdHlsZToge1xuICAgICAgICAgICAgICAgIG5vcm1hbDoge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZGFzaGVkJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZW1waGFzaXM6IHtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYW5pbWF0aW9uRWFzaW5nOiAnbGluZWFyJ1xuICAgICAgICB9XG4gICAgfSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9jb21wb25lbnQvbWFya2VyL01hcmtMaW5lTW9kZWwuanNcbi8vIG1vZHVsZSBpZCA9IDIyNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 225 */
/* unknown exports provided */
/* all exports used */
/*!**********************************************!*\
  !*** ./lib/component/marker/MarkLineView.js ***!
  \**********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 0);\n    var List = __webpack_require__(/*! ../../data/List */ 13);\n    var numberUtil = __webpack_require__(/*! ../../util/number */ 3);\n\n    var markerHelper = __webpack_require__(/*! ./markerHelper */ 87);\n\n    var LineDraw = __webpack_require__(/*! ../../chart/helper/LineDraw */ 138);\n\n    var markLineTransform = function (seriesModel, coordSys, mlModel, item) {\n        var data = seriesModel.getData();\n        // Special type markLine like 'min', 'max', 'average'\n        var mlType = item.type;\n\n        if (!zrUtil.isArray(item)\n            && (\n                mlType === 'min' || mlType === 'max' || mlType === 'average'\n                // In case\n                // data: [{\n                //   yAxis: 10\n                // }]\n                || (item.xAxis != null || item.yAxis != null)\n            )\n        ) {\n            var valueAxis;\n            var valueDataDim;\n            var value;\n\n            if (item.yAxis != null || item.xAxis != null) {\n                valueDataDim = item.yAxis != null ? 'y' : 'x';\n                valueAxis = coordSys.getAxis(valueDataDim);\n\n                value = zrUtil.retrieve(item.yAxis, item.xAxis);\n            }\n            else {\n                var axisInfo = markerHelper.getAxisInfo(item, data, coordSys, seriesModel);\n                valueDataDim = axisInfo.valueDataDim;\n                valueAxis = axisInfo.valueAxis;\n                value = markerHelper.numCalculate(data, valueDataDim, mlType);\n            }\n            var valueIndex = valueDataDim === 'x' ? 0 : 1;\n            var baseIndex = 1 - valueIndex;\n\n            var mlFrom = zrUtil.clone(item);\n            var mlTo = {};\n\n            mlFrom.type = null;\n\n            mlFrom.coord = [];\n            mlTo.coord = [];\n            mlFrom.coord[baseIndex] = -Infinity;\n            mlTo.coord[baseIndex] = Infinity;\n\n            var precision = mlModel.get('precision');\n            if (precision >= 0 && typeof value === 'number') {\n                value = +value.toFixed(precision);\n            }\n\n            mlFrom.coord[valueIndex] = mlTo.coord[valueIndex] = value;\n\n            item = [mlFrom, mlTo, { // Extra option for tooltip and label\n                type: mlType,\n                valueIndex: item.valueIndex,\n                // Force to use the value of calculated value.\n                value: value\n            }];\n        }\n\n        item = [\n            markerHelper.dataTransform(seriesModel, item[0]),\n            markerHelper.dataTransform(seriesModel, item[1]),\n            zrUtil.extend({}, item[2])\n        ];\n\n        // Avoid line data type is extended by from(to) data type\n        item[2].type = item[2].type || '';\n\n        // Merge from option and to option into line option\n        zrUtil.merge(item[2], item[0]);\n        zrUtil.merge(item[2], item[1]);\n\n        return item;\n    };\n\n    function isInifinity(val) {\n        return !isNaN(val) && !isFinite(val);\n    }\n\n    // If a markLine has one dim\n    function ifMarkLineHasOnlyDim(dimIndex, fromCoord, toCoord, coordSys) {\n        var otherDimIndex = 1 - dimIndex;\n        var dimName = coordSys.dimensions[dimIndex];\n        return isInifinity(fromCoord[otherDimIndex]) && isInifinity(toCoord[otherDimIndex])\n            && fromCoord[dimIndex] === toCoord[dimIndex] && coordSys.getAxis(dimName).containData(fromCoord[dimIndex]);\n    }\n\n    function markLineFilter(coordSys, item) {\n        if (coordSys.type === 'cartesian2d') {\n            var fromCoord = item[0].coord;\n            var toCoord = item[1].coord;\n            // In case\n            // {\n            //  markLine: {\n            //    data: [{ yAxis: 2 }]\n            //  }\n            // }\n            if (\n                fromCoord && toCoord &&\n                (ifMarkLineHasOnlyDim(1, fromCoord, toCoord, coordSys)\n                || ifMarkLineHasOnlyDim(0, fromCoord, toCoord, coordSys))\n            ) {\n                return true;\n            }\n        }\n        return markerHelper.dataFilter(coordSys, item[0])\n            && markerHelper.dataFilter(coordSys, item[1]);\n    }\n\n    function updateSingleMarkerEndLayout(\n        data, idx, isFrom, seriesModel, api\n    ) {\n        var coordSys = seriesModel.coordinateSystem;\n        var itemModel = data.getItemModel(idx);\n\n        var point;\n        var xPx = numberUtil.parsePercent(itemModel.get('x'), api.getWidth());\n        var yPx = numberUtil.parsePercent(itemModel.get('y'), api.getHeight());\n        if (!isNaN(xPx) && !isNaN(yPx)) {\n            point = [xPx, yPx];\n        }\n        else {\n            // Chart like bar may have there own marker positioning logic\n            if (seriesModel.getMarkerPosition) {\n                // Use the getMarkerPoisition\n                point = seriesModel.getMarkerPosition(\n                    data.getValues(data.dimensions, idx)\n                );\n            }\n            else {\n                var dims = coordSys.dimensions;\n                var x = data.get(dims[0], idx);\n                var y = data.get(dims[1], idx);\n                point = coordSys.dataToPoint([x, y]);\n            }\n            // Expand line to the edge of grid if value on one axis is Inifnity\n            // In case\n            //  markLine: {\n            //    data: [{\n            //      yAxis: 2\n            //      // or\n            //      type: 'average'\n            //    }]\n            //  }\n            if (coordSys.type === 'cartesian2d') {\n                var xAxis = coordSys.getAxis('x');\n                var yAxis = coordSys.getAxis('y');\n                var dims = coordSys.dimensions;\n                if (isInifinity(data.get(dims[0], idx))) {\n                    point[0] = xAxis.toGlobalCoord(xAxis.getExtent()[isFrom ? 0 : 1]);\n                }\n                else if (isInifinity(data.get(dims[1], idx))) {\n                    point[1] = yAxis.toGlobalCoord(yAxis.getExtent()[isFrom ? 0 : 1]);\n                }\n            }\n\n            // Use x, y if has any\n            if (!isNaN(xPx)) {\n                point[0] = xPx;\n            }\n            if (!isNaN(yPx)) {\n                point[1] = yPx;\n            }\n        }\n\n        data.setItemLayout(idx, point);\n    }\n\n    __webpack_require__(/*! ./MarkerView */ 86).extend({\n\n        type: 'markLine',\n\n        updateLayout: function (markLineModel, ecModel, api) {\n            ecModel.eachSeries(function (seriesModel) {\n                var mlModel = seriesModel.markLineModel;\n                if (mlModel) {\n                    var mlData = mlModel.getData();\n                    var fromData = mlModel.__from;\n                    var toData = mlModel.__to;\n                    // Update visual and layout of from symbol and to symbol\n                    fromData.each(function (idx) {\n                        updateSingleMarkerEndLayout(fromData, idx, true, seriesModel, api);\n                        updateSingleMarkerEndLayout(toData, idx, false, seriesModel, api);\n                    });\n                    // Update layout of line\n                    mlData.each(function (idx) {\n                        mlData.setItemLayout(idx, [\n                            fromData.getItemLayout(idx),\n                            toData.getItemLayout(idx)\n                        ]);\n                    });\n\n                    this.markerGroupMap[seriesModel.name].updateLayout();\n\n                }\n            }, this);\n        },\n\n        renderSeries: function (seriesModel, mlModel, ecModel, api) {\n            var coordSys = seriesModel.coordinateSystem;\n            var seriesName = seriesModel.name;\n            var seriesData = seriesModel.getData();\n\n            var lineDrawMap = this.markerGroupMap;\n            var lineDraw = lineDrawMap[seriesName];\n            if (!lineDraw) {\n                lineDraw = lineDrawMap[seriesName] = new LineDraw();\n            }\n            this.group.add(lineDraw.group);\n\n            var mlData = createList(coordSys, seriesModel, mlModel);\n\n            var fromData = mlData.from;\n            var toData = mlData.to;\n            var lineData = mlData.line;\n\n            mlModel.__from = fromData;\n            mlModel.__to = toData;\n            // Line data for tooltip and formatter\n            mlModel.setData(lineData);\n\n            var symbolType = mlModel.get('symbol');\n            var symbolSize = mlModel.get('symbolSize');\n            if (!zrUtil.isArray(symbolType)) {\n                symbolType = [symbolType, symbolType];\n            }\n            if (typeof symbolSize === 'number') {\n                symbolSize = [symbolSize, symbolSize];\n            }\n\n            // Update visual and layout of from symbol and to symbol\n            mlData.from.each(function (idx) {\n                updateDataVisualAndLayout(fromData, idx, true);\n                updateDataVisualAndLayout(toData, idx, false);\n            });\n\n            // Update visual and layout of line\n            lineData.each(function (idx) {\n                var lineColor = lineData.getItemModel(idx).get('lineStyle.normal.color');\n                lineData.setItemVisual(idx, {\n                    color: lineColor || fromData.getItemVisual(idx, 'color')\n                });\n                lineData.setItemLayout(idx, [\n                    fromData.getItemLayout(idx),\n                    toData.getItemLayout(idx)\n                ]);\n\n                lineData.setItemVisual(idx, {\n                    'fromSymbolSize': fromData.getItemVisual(idx, 'symbolSize'),\n                    'fromSymbol': fromData.getItemVisual(idx, 'symbol'),\n                    'toSymbolSize': toData.getItemVisual(idx, 'symbolSize'),\n                    'toSymbol': toData.getItemVisual(idx, 'symbol')\n                });\n            });\n\n            lineDraw.updateData(lineData);\n\n            // Set host model for tooltip\n            // FIXME\n            mlData.line.eachItemGraphicEl(function (el, idx) {\n                el.traverse(function (child) {\n                    child.dataModel = mlModel;\n                });\n            });\n\n            function updateDataVisualAndLayout(data, idx, isFrom) {\n                var itemModel = data.getItemModel(idx);\n\n                updateSingleMarkerEndLayout(\n                    data, idx, isFrom, seriesModel, api\n                );\n\n                data.setItemVisual(idx, {\n                    symbolSize: itemModel.get('symbolSize') || symbolSize[isFrom ? 0 : 1],\n                    symbol: itemModel.get('symbol', true) || symbolType[isFrom ? 0 : 1],\n                    color: itemModel.get('itemStyle.normal.color') || seriesData.getVisual('color')\n                });\n            }\n\n            lineDraw.__keep = true;\n\n            lineDraw.group.silent = mlModel.get('silent') || seriesModel.get('silent');\n        }\n    });\n\n    /**\n     * @inner\n     * @param {module:echarts/coord/*} coordSys\n     * @param {module:echarts/model/Series} seriesModel\n     * @param {module:echarts/model/Model} mpModel\n     */\n    function createList(coordSys, seriesModel, mlModel) {\n\n        var coordDimsInfos;\n        if (coordSys) {\n            coordDimsInfos = zrUtil.map(coordSys && coordSys.dimensions, function (coordDim) {\n                var info = seriesModel.getData().getDimensionInfo(\n                    seriesModel.coordDimToDataDim(coordDim)[0]\n                ) || {}; // In map series data don't have lng and lat dimension. Fallback to same with coordSys\n                info.name = coordDim;\n                return info;\n            });\n        }\n        else {\n            coordDimsInfos =[{\n                name: 'value',\n                type: 'float'\n            }];\n        }\n\n        var fromData = new List(coordDimsInfos, mlModel);\n        var toData = new List(coordDimsInfos, mlModel);\n        // No dimensions\n        var lineData = new List([], mlModel);\n\n        var optData = zrUtil.map(mlModel.get('data'), zrUtil.curry(\n            markLineTransform, seriesModel, coordSys, mlModel\n        ));\n        if (coordSys) {\n            optData = zrUtil.filter(\n                optData, zrUtil.curry(markLineFilter, coordSys)\n            );\n        }\n        var dimValueGetter = coordSys ? markerHelper.dimValueGetter : function (item) {\n            return item.value;\n        };\n        fromData.initData(\n            zrUtil.map(optData, function (item) { return item[0]; }),\n            null, dimValueGetter\n        );\n        toData.initData(\n            zrUtil.map(optData, function (item) { return item[1]; }),\n            null, dimValueGetter\n        );\n        lineData.initData(\n            zrUtil.map(optData, function (item) { return item[2]; })\n        );\n        lineData.hasItemOption = true;\n        return {\n            from: fromData,\n            to: toData,\n            line: lineData\n        };\n    }\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjI1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2NvbXBvbmVudC9tYXJrZXIvTWFya0xpbmVWaWV3LmpzP2UyNzgiXSwic291cmNlc0NvbnRlbnQiOlsiXG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG4gICAgdmFyIExpc3QgPSByZXF1aXJlKCcuLi8uLi9kYXRhL0xpc3QnKTtcbiAgICB2YXIgbnVtYmVyVXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvbnVtYmVyJyk7XG5cbiAgICB2YXIgbWFya2VySGVscGVyID0gcmVxdWlyZSgnLi9tYXJrZXJIZWxwZXInKTtcblxuICAgIHZhciBMaW5lRHJhdyA9IHJlcXVpcmUoJy4uLy4uL2NoYXJ0L2hlbHBlci9MaW5lRHJhdycpO1xuXG4gICAgdmFyIG1hcmtMaW5lVHJhbnNmb3JtID0gZnVuY3Rpb24gKHNlcmllc01vZGVsLCBjb29yZFN5cywgbWxNb2RlbCwgaXRlbSkge1xuICAgICAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICAgICAgLy8gU3BlY2lhbCB0eXBlIG1hcmtMaW5lIGxpa2UgJ21pbicsICdtYXgnLCAnYXZlcmFnZSdcbiAgICAgICAgdmFyIG1sVHlwZSA9IGl0ZW0udHlwZTtcblxuICAgICAgICBpZiAoIXpyVXRpbC5pc0FycmF5KGl0ZW0pXG4gICAgICAgICAgICAmJiAoXG4gICAgICAgICAgICAgICAgbWxUeXBlID09PSAnbWluJyB8fCBtbFR5cGUgPT09ICdtYXgnIHx8IG1sVHlwZSA9PT0gJ2F2ZXJhZ2UnXG4gICAgICAgICAgICAgICAgLy8gSW4gY2FzZVxuICAgICAgICAgICAgICAgIC8vIGRhdGE6IFt7XG4gICAgICAgICAgICAgICAgLy8gICB5QXhpczogMTBcbiAgICAgICAgICAgICAgICAvLyB9XVxuICAgICAgICAgICAgICAgIHx8IChpdGVtLnhBeGlzICE9IG51bGwgfHwgaXRlbS55QXhpcyAhPSBudWxsKVxuICAgICAgICAgICAgKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZUF4aXM7XG4gICAgICAgICAgICB2YXIgdmFsdWVEYXRhRGltO1xuICAgICAgICAgICAgdmFyIHZhbHVlO1xuXG4gICAgICAgICAgICBpZiAoaXRlbS55QXhpcyAhPSBudWxsIHx8IGl0ZW0ueEF4aXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhbHVlRGF0YURpbSA9IGl0ZW0ueUF4aXMgIT0gbnVsbCA/ICd5JyA6ICd4JztcbiAgICAgICAgICAgICAgICB2YWx1ZUF4aXMgPSBjb29yZFN5cy5nZXRBeGlzKHZhbHVlRGF0YURpbSk7XG5cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHpyVXRpbC5yZXRyaWV2ZShpdGVtLnlBeGlzLCBpdGVtLnhBeGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBheGlzSW5mbyA9IG1hcmtlckhlbHBlci5nZXRBeGlzSW5mbyhpdGVtLCBkYXRhLCBjb29yZFN5cywgc2VyaWVzTW9kZWwpO1xuICAgICAgICAgICAgICAgIHZhbHVlRGF0YURpbSA9IGF4aXNJbmZvLnZhbHVlRGF0YURpbTtcbiAgICAgICAgICAgICAgICB2YWx1ZUF4aXMgPSBheGlzSW5mby52YWx1ZUF4aXM7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBtYXJrZXJIZWxwZXIubnVtQ2FsY3VsYXRlKGRhdGEsIHZhbHVlRGF0YURpbSwgbWxUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB2YWx1ZUluZGV4ID0gdmFsdWVEYXRhRGltID09PSAneCcgPyAwIDogMTtcbiAgICAgICAgICAgIHZhciBiYXNlSW5kZXggPSAxIC0gdmFsdWVJbmRleDtcblxuICAgICAgICAgICAgdmFyIG1sRnJvbSA9IHpyVXRpbC5jbG9uZShpdGVtKTtcbiAgICAgICAgICAgIHZhciBtbFRvID0ge307XG5cbiAgICAgICAgICAgIG1sRnJvbS50eXBlID0gbnVsbDtcblxuICAgICAgICAgICAgbWxGcm9tLmNvb3JkID0gW107XG4gICAgICAgICAgICBtbFRvLmNvb3JkID0gW107XG4gICAgICAgICAgICBtbEZyb20uY29vcmRbYmFzZUluZGV4XSA9IC1JbmZpbml0eTtcbiAgICAgICAgICAgIG1sVG8uY29vcmRbYmFzZUluZGV4XSA9IEluZmluaXR5O1xuXG4gICAgICAgICAgICB2YXIgcHJlY2lzaW9uID0gbWxNb2RlbC5nZXQoJ3ByZWNpc2lvbicpO1xuICAgICAgICAgICAgaWYgKHByZWNpc2lvbiA+PSAwICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9ICt2YWx1ZS50b0ZpeGVkKHByZWNpc2lvbik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1sRnJvbS5jb29yZFt2YWx1ZUluZGV4XSA9IG1sVG8uY29vcmRbdmFsdWVJbmRleF0gPSB2YWx1ZTtcblxuICAgICAgICAgICAgaXRlbSA9IFttbEZyb20sIG1sVG8sIHsgLy8gRXh0cmEgb3B0aW9uIGZvciB0b29sdGlwIGFuZCBsYWJlbFxuICAgICAgICAgICAgICAgIHR5cGU6IG1sVHlwZSxcbiAgICAgICAgICAgICAgICB2YWx1ZUluZGV4OiBpdGVtLnZhbHVlSW5kZXgsXG4gICAgICAgICAgICAgICAgLy8gRm9yY2UgdG8gdXNlIHRoZSB2YWx1ZSBvZiBjYWxjdWxhdGVkIHZhbHVlLlxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgICAgfV07XG4gICAgICAgIH1cblxuICAgICAgICBpdGVtID0gW1xuICAgICAgICAgICAgbWFya2VySGVscGVyLmRhdGFUcmFuc2Zvcm0oc2VyaWVzTW9kZWwsIGl0ZW1bMF0pLFxuICAgICAgICAgICAgbWFya2VySGVscGVyLmRhdGFUcmFuc2Zvcm0oc2VyaWVzTW9kZWwsIGl0ZW1bMV0pLFxuICAgICAgICAgICAgenJVdGlsLmV4dGVuZCh7fSwgaXRlbVsyXSlcbiAgICAgICAgXTtcblxuICAgICAgICAvLyBBdm9pZCBsaW5lIGRhdGEgdHlwZSBpcyBleHRlbmRlZCBieSBmcm9tKHRvKSBkYXRhIHR5cGVcbiAgICAgICAgaXRlbVsyXS50eXBlID0gaXRlbVsyXS50eXBlIHx8ICcnO1xuXG4gICAgICAgIC8vIE1lcmdlIGZyb20gb3B0aW9uIGFuZCB0byBvcHRpb24gaW50byBsaW5lIG9wdGlvblxuICAgICAgICB6clV0aWwubWVyZ2UoaXRlbVsyXSwgaXRlbVswXSk7XG4gICAgICAgIHpyVXRpbC5tZXJnZShpdGVtWzJdLCBpdGVtWzFdKTtcblxuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gaXNJbmlmaW5pdHkodmFsKSB7XG4gICAgICAgIHJldHVybiAhaXNOYU4odmFsKSAmJiAhaXNGaW5pdGUodmFsKTtcbiAgICB9XG5cbiAgICAvLyBJZiBhIG1hcmtMaW5lIGhhcyBvbmUgZGltXG4gICAgZnVuY3Rpb24gaWZNYXJrTGluZUhhc09ubHlEaW0oZGltSW5kZXgsIGZyb21Db29yZCwgdG9Db29yZCwgY29vcmRTeXMpIHtcbiAgICAgICAgdmFyIG90aGVyRGltSW5kZXggPSAxIC0gZGltSW5kZXg7XG4gICAgICAgIHZhciBkaW1OYW1lID0gY29vcmRTeXMuZGltZW5zaW9uc1tkaW1JbmRleF07XG4gICAgICAgIHJldHVybiBpc0luaWZpbml0eShmcm9tQ29vcmRbb3RoZXJEaW1JbmRleF0pICYmIGlzSW5pZmluaXR5KHRvQ29vcmRbb3RoZXJEaW1JbmRleF0pXG4gICAgICAgICAgICAmJiBmcm9tQ29vcmRbZGltSW5kZXhdID09PSB0b0Nvb3JkW2RpbUluZGV4XSAmJiBjb29yZFN5cy5nZXRBeGlzKGRpbU5hbWUpLmNvbnRhaW5EYXRhKGZyb21Db29yZFtkaW1JbmRleF0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1hcmtMaW5lRmlsdGVyKGNvb3JkU3lzLCBpdGVtKSB7XG4gICAgICAgIGlmIChjb29yZFN5cy50eXBlID09PSAnY2FydGVzaWFuMmQnKSB7XG4gICAgICAgICAgICB2YXIgZnJvbUNvb3JkID0gaXRlbVswXS5jb29yZDtcbiAgICAgICAgICAgIHZhciB0b0Nvb3JkID0gaXRlbVsxXS5jb29yZDtcbiAgICAgICAgICAgIC8vIEluIGNhc2VcbiAgICAgICAgICAgIC8vIHtcbiAgICAgICAgICAgIC8vICBtYXJrTGluZToge1xuICAgICAgICAgICAgLy8gICAgZGF0YTogW3sgeUF4aXM6IDIgfV1cbiAgICAgICAgICAgIC8vICB9XG4gICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgZnJvbUNvb3JkICYmIHRvQ29vcmQgJiZcbiAgICAgICAgICAgICAgICAoaWZNYXJrTGluZUhhc09ubHlEaW0oMSwgZnJvbUNvb3JkLCB0b0Nvb3JkLCBjb29yZFN5cylcbiAgICAgICAgICAgICAgICB8fCBpZk1hcmtMaW5lSGFzT25seURpbSgwLCBmcm9tQ29vcmQsIHRvQ29vcmQsIGNvb3JkU3lzKSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXJrZXJIZWxwZXIuZGF0YUZpbHRlcihjb29yZFN5cywgaXRlbVswXSlcbiAgICAgICAgICAgICYmIG1hcmtlckhlbHBlci5kYXRhRmlsdGVyKGNvb3JkU3lzLCBpdGVtWzFdKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVTaW5nbGVNYXJrZXJFbmRMYXlvdXQoXG4gICAgICAgIGRhdGEsIGlkeCwgaXNGcm9tLCBzZXJpZXNNb2RlbCwgYXBpXG4gICAgKSB7XG4gICAgICAgIHZhciBjb29yZFN5cyA9IHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG4gICAgICAgIHZhciBpdGVtTW9kZWwgPSBkYXRhLmdldEl0ZW1Nb2RlbChpZHgpO1xuXG4gICAgICAgIHZhciBwb2ludDtcbiAgICAgICAgdmFyIHhQeCA9IG51bWJlclV0aWwucGFyc2VQZXJjZW50KGl0ZW1Nb2RlbC5nZXQoJ3gnKSwgYXBpLmdldFdpZHRoKCkpO1xuICAgICAgICB2YXIgeVB4ID0gbnVtYmVyVXRpbC5wYXJzZVBlcmNlbnQoaXRlbU1vZGVsLmdldCgneScpLCBhcGkuZ2V0SGVpZ2h0KCkpO1xuICAgICAgICBpZiAoIWlzTmFOKHhQeCkgJiYgIWlzTmFOKHlQeCkpIHtcbiAgICAgICAgICAgIHBvaW50ID0gW3hQeCwgeVB4XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIENoYXJ0IGxpa2UgYmFyIG1heSBoYXZlIHRoZXJlIG93biBtYXJrZXIgcG9zaXRpb25pbmcgbG9naWNcbiAgICAgICAgICAgIGlmIChzZXJpZXNNb2RlbC5nZXRNYXJrZXJQb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIC8vIFVzZSB0aGUgZ2V0TWFya2VyUG9pc2l0aW9uXG4gICAgICAgICAgICAgICAgcG9pbnQgPSBzZXJpZXNNb2RlbC5nZXRNYXJrZXJQb3NpdGlvbihcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5nZXRWYWx1ZXMoZGF0YS5kaW1lbnNpb25zLCBpZHgpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBkaW1zID0gY29vcmRTeXMuZGltZW5zaW9ucztcbiAgICAgICAgICAgICAgICB2YXIgeCA9IGRhdGEuZ2V0KGRpbXNbMF0sIGlkeCk7XG4gICAgICAgICAgICAgICAgdmFyIHkgPSBkYXRhLmdldChkaW1zWzFdLCBpZHgpO1xuICAgICAgICAgICAgICAgIHBvaW50ID0gY29vcmRTeXMuZGF0YVRvUG9pbnQoW3gsIHldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEV4cGFuZCBsaW5lIHRvIHRoZSBlZGdlIG9mIGdyaWQgaWYgdmFsdWUgb24gb25lIGF4aXMgaXMgSW5pZm5pdHlcbiAgICAgICAgICAgIC8vIEluIGNhc2VcbiAgICAgICAgICAgIC8vICBtYXJrTGluZToge1xuICAgICAgICAgICAgLy8gICAgZGF0YTogW3tcbiAgICAgICAgICAgIC8vICAgICAgeUF4aXM6IDJcbiAgICAgICAgICAgIC8vICAgICAgLy8gb3JcbiAgICAgICAgICAgIC8vICAgICAgdHlwZTogJ2F2ZXJhZ2UnXG4gICAgICAgICAgICAvLyAgICB9XVxuICAgICAgICAgICAgLy8gIH1cbiAgICAgICAgICAgIGlmIChjb29yZFN5cy50eXBlID09PSAnY2FydGVzaWFuMmQnKSB7XG4gICAgICAgICAgICAgICAgdmFyIHhBeGlzID0gY29vcmRTeXMuZ2V0QXhpcygneCcpO1xuICAgICAgICAgICAgICAgIHZhciB5QXhpcyA9IGNvb3JkU3lzLmdldEF4aXMoJ3knKTtcbiAgICAgICAgICAgICAgICB2YXIgZGltcyA9IGNvb3JkU3lzLmRpbWVuc2lvbnM7XG4gICAgICAgICAgICAgICAgaWYgKGlzSW5pZmluaXR5KGRhdGEuZ2V0KGRpbXNbMF0sIGlkeCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50WzBdID0geEF4aXMudG9HbG9iYWxDb29yZCh4QXhpcy5nZXRFeHRlbnQoKVtpc0Zyb20gPyAwIDogMV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0luaWZpbml0eShkYXRhLmdldChkaW1zWzFdLCBpZHgpKSkge1xuICAgICAgICAgICAgICAgICAgICBwb2ludFsxXSA9IHlBeGlzLnRvR2xvYmFsQ29vcmQoeUF4aXMuZ2V0RXh0ZW50KClbaXNGcm9tID8gMCA6IDFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFVzZSB4LCB5IGlmIGhhcyBhbnlcbiAgICAgICAgICAgIGlmICghaXNOYU4oeFB4KSkge1xuICAgICAgICAgICAgICAgIHBvaW50WzBdID0geFB4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc05hTih5UHgpKSB7XG4gICAgICAgICAgICAgICAgcG9pbnRbMV0gPSB5UHg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBkYXRhLnNldEl0ZW1MYXlvdXQoaWR4LCBwb2ludCk7XG4gICAgfVxuXG4gICAgcmVxdWlyZSgnLi9NYXJrZXJWaWV3JykuZXh0ZW5kKHtcblxuICAgICAgICB0eXBlOiAnbWFya0xpbmUnLFxuXG4gICAgICAgIHVwZGF0ZUxheW91dDogZnVuY3Rpb24gKG1hcmtMaW5lTW9kZWwsIGVjTW9kZWwsIGFwaSkge1xuICAgICAgICAgICAgZWNNb2RlbC5lYWNoU2VyaWVzKGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgICAgICAgICAgICAgIHZhciBtbE1vZGVsID0gc2VyaWVzTW9kZWwubWFya0xpbmVNb2RlbDtcbiAgICAgICAgICAgICAgICBpZiAobWxNb2RlbCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWxEYXRhID0gbWxNb2RlbC5nZXREYXRhKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmcm9tRGF0YSA9IG1sTW9kZWwuX19mcm9tO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdG9EYXRhID0gbWxNb2RlbC5fX3RvO1xuICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdmlzdWFsIGFuZCBsYXlvdXQgb2YgZnJvbSBzeW1ib2wgYW5kIHRvIHN5bWJvbFxuICAgICAgICAgICAgICAgICAgICBmcm9tRGF0YS5lYWNoKGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVNpbmdsZU1hcmtlckVuZExheW91dChmcm9tRGF0YSwgaWR4LCB0cnVlLCBzZXJpZXNNb2RlbCwgYXBpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVNpbmdsZU1hcmtlckVuZExheW91dCh0b0RhdGEsIGlkeCwgZmFsc2UsIHNlcmllc01vZGVsLCBhcGkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIGxheW91dCBvZiBsaW5lXG4gICAgICAgICAgICAgICAgICAgIG1sRGF0YS5lYWNoKGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1sRGF0YS5zZXRJdGVtTGF5b3V0KGlkeCwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb21EYXRhLmdldEl0ZW1MYXlvdXQoaWR4KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b0RhdGEuZ2V0SXRlbUxheW91dChpZHgpXG4gICAgICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXJrZXJHcm91cE1hcFtzZXJpZXNNb2RlbC5uYW1lXS51cGRhdGVMYXlvdXQoKTtcblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbmRlclNlcmllczogZnVuY3Rpb24gKHNlcmllc01vZGVsLCBtbE1vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgICAgICAgICAgIHZhciBjb29yZFN5cyA9IHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG4gICAgICAgICAgICB2YXIgc2VyaWVzTmFtZSA9IHNlcmllc01vZGVsLm5hbWU7XG4gICAgICAgICAgICB2YXIgc2VyaWVzRGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcblxuICAgICAgICAgICAgdmFyIGxpbmVEcmF3TWFwID0gdGhpcy5tYXJrZXJHcm91cE1hcDtcbiAgICAgICAgICAgIHZhciBsaW5lRHJhdyA9IGxpbmVEcmF3TWFwW3Nlcmllc05hbWVdO1xuICAgICAgICAgICAgaWYgKCFsaW5lRHJhdykge1xuICAgICAgICAgICAgICAgIGxpbmVEcmF3ID0gbGluZURyYXdNYXBbc2VyaWVzTmFtZV0gPSBuZXcgTGluZURyYXcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZ3JvdXAuYWRkKGxpbmVEcmF3Lmdyb3VwKTtcblxuICAgICAgICAgICAgdmFyIG1sRGF0YSA9IGNyZWF0ZUxpc3QoY29vcmRTeXMsIHNlcmllc01vZGVsLCBtbE1vZGVsKTtcblxuICAgICAgICAgICAgdmFyIGZyb21EYXRhID0gbWxEYXRhLmZyb207XG4gICAgICAgICAgICB2YXIgdG9EYXRhID0gbWxEYXRhLnRvO1xuICAgICAgICAgICAgdmFyIGxpbmVEYXRhID0gbWxEYXRhLmxpbmU7XG5cbiAgICAgICAgICAgIG1sTW9kZWwuX19mcm9tID0gZnJvbURhdGE7XG4gICAgICAgICAgICBtbE1vZGVsLl9fdG8gPSB0b0RhdGE7XG4gICAgICAgICAgICAvLyBMaW5lIGRhdGEgZm9yIHRvb2x0aXAgYW5kIGZvcm1hdHRlclxuICAgICAgICAgICAgbWxNb2RlbC5zZXREYXRhKGxpbmVEYXRhKTtcblxuICAgICAgICAgICAgdmFyIHN5bWJvbFR5cGUgPSBtbE1vZGVsLmdldCgnc3ltYm9sJyk7XG4gICAgICAgICAgICB2YXIgc3ltYm9sU2l6ZSA9IG1sTW9kZWwuZ2V0KCdzeW1ib2xTaXplJyk7XG4gICAgICAgICAgICBpZiAoIXpyVXRpbC5pc0FycmF5KHN5bWJvbFR5cGUpKSB7XG4gICAgICAgICAgICAgICAgc3ltYm9sVHlwZSA9IFtzeW1ib2xUeXBlLCBzeW1ib2xUeXBlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3ltYm9sU2l6ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICBzeW1ib2xTaXplID0gW3N5bWJvbFNpemUsIHN5bWJvbFNpemVdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBVcGRhdGUgdmlzdWFsIGFuZCBsYXlvdXQgb2YgZnJvbSBzeW1ib2wgYW5kIHRvIHN5bWJvbFxuICAgICAgICAgICAgbWxEYXRhLmZyb20uZWFjaChmdW5jdGlvbiAoaWR4KSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlRGF0YVZpc3VhbEFuZExheW91dChmcm9tRGF0YSwgaWR4LCB0cnVlKTtcbiAgICAgICAgICAgICAgICB1cGRhdGVEYXRhVmlzdWFsQW5kTGF5b3V0KHRvRGF0YSwgaWR4LCBmYWxzZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gVXBkYXRlIHZpc3VhbCBhbmQgbGF5b3V0IG9mIGxpbmVcbiAgICAgICAgICAgIGxpbmVEYXRhLmVhY2goZnVuY3Rpb24gKGlkeCkge1xuICAgICAgICAgICAgICAgIHZhciBsaW5lQ29sb3IgPSBsaW5lRGF0YS5nZXRJdGVtTW9kZWwoaWR4KS5nZXQoJ2xpbmVTdHlsZS5ub3JtYWwuY29sb3InKTtcbiAgICAgICAgICAgICAgICBsaW5lRGF0YS5zZXRJdGVtVmlzdWFsKGlkeCwge1xuICAgICAgICAgICAgICAgICAgICBjb2xvcjogbGluZUNvbG9yIHx8IGZyb21EYXRhLmdldEl0ZW1WaXN1YWwoaWR4LCAnY29sb3InKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGxpbmVEYXRhLnNldEl0ZW1MYXlvdXQoaWR4LCBbXG4gICAgICAgICAgICAgICAgICAgIGZyb21EYXRhLmdldEl0ZW1MYXlvdXQoaWR4KSxcbiAgICAgICAgICAgICAgICAgICAgdG9EYXRhLmdldEl0ZW1MYXlvdXQoaWR4KVxuICAgICAgICAgICAgICAgIF0pO1xuXG4gICAgICAgICAgICAgICAgbGluZURhdGEuc2V0SXRlbVZpc3VhbChpZHgsIHtcbiAgICAgICAgICAgICAgICAgICAgJ2Zyb21TeW1ib2xTaXplJzogZnJvbURhdGEuZ2V0SXRlbVZpc3VhbChpZHgsICdzeW1ib2xTaXplJyksXG4gICAgICAgICAgICAgICAgICAgICdmcm9tU3ltYm9sJzogZnJvbURhdGEuZ2V0SXRlbVZpc3VhbChpZHgsICdzeW1ib2wnKSxcbiAgICAgICAgICAgICAgICAgICAgJ3RvU3ltYm9sU2l6ZSc6IHRvRGF0YS5nZXRJdGVtVmlzdWFsKGlkeCwgJ3N5bWJvbFNpemUnKSxcbiAgICAgICAgICAgICAgICAgICAgJ3RvU3ltYm9sJzogdG9EYXRhLmdldEl0ZW1WaXN1YWwoaWR4LCAnc3ltYm9sJylcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBsaW5lRHJhdy51cGRhdGVEYXRhKGxpbmVEYXRhKTtcblxuICAgICAgICAgICAgLy8gU2V0IGhvc3QgbW9kZWwgZm9yIHRvb2x0aXBcbiAgICAgICAgICAgIC8vIEZJWE1FXG4gICAgICAgICAgICBtbERhdGEubGluZS5lYWNoSXRlbUdyYXBoaWNFbChmdW5jdGlvbiAoZWwsIGlkeCkge1xuICAgICAgICAgICAgICAgIGVsLnRyYXZlcnNlKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZC5kYXRhTW9kZWwgPSBtbE1vZGVsO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHVwZGF0ZURhdGFWaXN1YWxBbmRMYXlvdXQoZGF0YSwgaWR4LCBpc0Zyb20pIHtcbiAgICAgICAgICAgICAgICB2YXIgaXRlbU1vZGVsID0gZGF0YS5nZXRJdGVtTW9kZWwoaWR4KTtcblxuICAgICAgICAgICAgICAgIHVwZGF0ZVNpbmdsZU1hcmtlckVuZExheW91dChcbiAgICAgICAgICAgICAgICAgICAgZGF0YSwgaWR4LCBpc0Zyb20sIHNlcmllc01vZGVsLCBhcGlcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgZGF0YS5zZXRJdGVtVmlzdWFsKGlkeCwge1xuICAgICAgICAgICAgICAgICAgICBzeW1ib2xTaXplOiBpdGVtTW9kZWwuZ2V0KCdzeW1ib2xTaXplJykgfHwgc3ltYm9sU2l6ZVtpc0Zyb20gPyAwIDogMV0sXG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbDogaXRlbU1vZGVsLmdldCgnc3ltYm9sJywgdHJ1ZSkgfHwgc3ltYm9sVHlwZVtpc0Zyb20gPyAwIDogMV0sXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiBpdGVtTW9kZWwuZ2V0KCdpdGVtU3R5bGUubm9ybWFsLmNvbG9yJykgfHwgc2VyaWVzRGF0YS5nZXRWaXN1YWwoJ2NvbG9yJylcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGluZURyYXcuX19rZWVwID0gdHJ1ZTtcblxuICAgICAgICAgICAgbGluZURyYXcuZ3JvdXAuc2lsZW50ID0gbWxNb2RlbC5nZXQoJ3NpbGVudCcpIHx8IHNlcmllc01vZGVsLmdldCgnc2lsZW50Jyk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEBpbm5lclxuICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvY29vcmQvKn0gY29vcmRTeXNcbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL1Nlcmllc30gc2VyaWVzTW9kZWxcbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBtcE1vZGVsXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlTGlzdChjb29yZFN5cywgc2VyaWVzTW9kZWwsIG1sTW9kZWwpIHtcblxuICAgICAgICB2YXIgY29vcmREaW1zSW5mb3M7XG4gICAgICAgIGlmIChjb29yZFN5cykge1xuICAgICAgICAgICAgY29vcmREaW1zSW5mb3MgPSB6clV0aWwubWFwKGNvb3JkU3lzICYmIGNvb3JkU3lzLmRpbWVuc2lvbnMsIGZ1bmN0aW9uIChjb29yZERpbSkge1xuICAgICAgICAgICAgICAgIHZhciBpbmZvID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpLmdldERpbWVuc2lvbkluZm8oXG4gICAgICAgICAgICAgICAgICAgIHNlcmllc01vZGVsLmNvb3JkRGltVG9EYXRhRGltKGNvb3JkRGltKVswXVxuICAgICAgICAgICAgICAgICkgfHwge307IC8vIEluIG1hcCBzZXJpZXMgZGF0YSBkb24ndCBoYXZlIGxuZyBhbmQgbGF0IGRpbWVuc2lvbi4gRmFsbGJhY2sgdG8gc2FtZSB3aXRoIGNvb3JkU3lzXG4gICAgICAgICAgICAgICAgaW5mby5uYW1lID0gY29vcmREaW07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZm87XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvb3JkRGltc0luZm9zID1be1xuICAgICAgICAgICAgICAgIG5hbWU6ICd2YWx1ZScsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2Zsb2F0J1xuICAgICAgICAgICAgfV07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZnJvbURhdGEgPSBuZXcgTGlzdChjb29yZERpbXNJbmZvcywgbWxNb2RlbCk7XG4gICAgICAgIHZhciB0b0RhdGEgPSBuZXcgTGlzdChjb29yZERpbXNJbmZvcywgbWxNb2RlbCk7XG4gICAgICAgIC8vIE5vIGRpbWVuc2lvbnNcbiAgICAgICAgdmFyIGxpbmVEYXRhID0gbmV3IExpc3QoW10sIG1sTW9kZWwpO1xuXG4gICAgICAgIHZhciBvcHREYXRhID0genJVdGlsLm1hcChtbE1vZGVsLmdldCgnZGF0YScpLCB6clV0aWwuY3VycnkoXG4gICAgICAgICAgICBtYXJrTGluZVRyYW5zZm9ybSwgc2VyaWVzTW9kZWwsIGNvb3JkU3lzLCBtbE1vZGVsXG4gICAgICAgICkpO1xuICAgICAgICBpZiAoY29vcmRTeXMpIHtcbiAgICAgICAgICAgIG9wdERhdGEgPSB6clV0aWwuZmlsdGVyKFxuICAgICAgICAgICAgICAgIG9wdERhdGEsIHpyVXRpbC5jdXJyeShtYXJrTGluZUZpbHRlciwgY29vcmRTeXMpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkaW1WYWx1ZUdldHRlciA9IGNvb3JkU3lzID8gbWFya2VySGVscGVyLmRpbVZhbHVlR2V0dGVyIDogZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtLnZhbHVlO1xuICAgICAgICB9O1xuICAgICAgICBmcm9tRGF0YS5pbml0RGF0YShcbiAgICAgICAgICAgIHpyVXRpbC5tYXAob3B0RGF0YSwgZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIGl0ZW1bMF07IH0pLFxuICAgICAgICAgICAgbnVsbCwgZGltVmFsdWVHZXR0ZXJcbiAgICAgICAgKTtcbiAgICAgICAgdG9EYXRhLmluaXREYXRhKFxuICAgICAgICAgICAgenJVdGlsLm1hcChvcHREYXRhLCBmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gaXRlbVsxXTsgfSksXG4gICAgICAgICAgICBudWxsLCBkaW1WYWx1ZUdldHRlclxuICAgICAgICApO1xuICAgICAgICBsaW5lRGF0YS5pbml0RGF0YShcbiAgICAgICAgICAgIHpyVXRpbC5tYXAob3B0RGF0YSwgZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIGl0ZW1bMl07IH0pXG4gICAgICAgICk7XG4gICAgICAgIGxpbmVEYXRhLmhhc0l0ZW1PcHRpb24gPSB0cnVlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZnJvbTogZnJvbURhdGEsXG4gICAgICAgICAgICB0bzogdG9EYXRhLFxuICAgICAgICAgICAgbGluZTogbGluZURhdGFcbiAgICAgICAgfTtcbiAgICB9XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9jb21wb25lbnQvbWFya2VyL01hcmtMaW5lVmlldy5qc1xuLy8gbW9kdWxlIGlkID0gMjI1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 226 */
/* unknown exports provided */
/* all exports used */
/*!************************************************!*\
  !*** ./lib/component/marker/MarkPointModel.js ***!
  \************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    module.exports = __webpack_require__(/*! ./MarkerModel */ 85).extend({\n\n        type: 'markPoint',\n\n        defaultOption: {\n            zlevel: 0,\n            z: 5,\n            symbol: 'pin',\n            symbolSize: 50,\n            //symbolRotate: 0,\n            //symbolOffset: [0, 0]\n            tooltip: {\n                trigger: 'item'\n            },\n            label: {\n                normal: {\n                    show: true,\n                    position: 'inside'\n                },\n                emphasis: {\n                    show: true\n                }\n            },\n            itemStyle: {\n                normal: {\n                    borderWidth: 2\n                }\n            }\n        }\n    });\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjI2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2NvbXBvbmVudC9tYXJrZXIvTWFya1BvaW50TW9kZWwuanM/OWQwNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcblxuICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9NYXJrZXJNb2RlbCcpLmV4dGVuZCh7XG5cbiAgICAgICAgdHlwZTogJ21hcmtQb2ludCcsXG5cbiAgICAgICAgZGVmYXVsdE9wdGlvbjoge1xuICAgICAgICAgICAgemxldmVsOiAwLFxuICAgICAgICAgICAgejogNSxcbiAgICAgICAgICAgIHN5bWJvbDogJ3BpbicsXG4gICAgICAgICAgICBzeW1ib2xTaXplOiA1MCxcbiAgICAgICAgICAgIC8vc3ltYm9sUm90YXRlOiAwLFxuICAgICAgICAgICAgLy9zeW1ib2xPZmZzZXQ6IFswLCAwXVxuICAgICAgICAgICAgdG9vbHRpcDoge1xuICAgICAgICAgICAgICAgIHRyaWdnZXI6ICdpdGVtJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxhYmVsOiB7XG4gICAgICAgICAgICAgICAgbm9ybWFsOiB7XG4gICAgICAgICAgICAgICAgICAgIHNob3c6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnaW5zaWRlJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZW1waGFzaXM6IHtcbiAgICAgICAgICAgICAgICAgICAgc2hvdzogdHJ1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpdGVtU3R5bGU6IHtcbiAgICAgICAgICAgICAgICBub3JtYWw6IHtcbiAgICAgICAgICAgICAgICAgICAgYm9yZGVyV2lkdGg6IDJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2NvbXBvbmVudC9tYXJrZXIvTWFya1BvaW50TW9kZWwuanNcbi8vIG1vZHVsZSBpZCA9IDIyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 227 */
/* unknown exports provided */
/* all exports used */
/*!***********************************************!*\
  !*** ./lib/component/marker/MarkPointView.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var SymbolDraw = __webpack_require__(/*! ../../chart/helper/SymbolDraw */ 44);\n    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 0);\n    var numberUtil = __webpack_require__(/*! ../../util/number */ 3);\n\n    var List = __webpack_require__(/*! ../../data/List */ 13);\n\n    var markerHelper = __webpack_require__(/*! ./markerHelper */ 87);\n\n    function updateMarkerLayout(mpData, seriesModel, api) {\n        var coordSys = seriesModel.coordinateSystem;\n        mpData.each(function (idx) {\n            var itemModel = mpData.getItemModel(idx);\n            var point;\n            var xPx = numberUtil.parsePercent(itemModel.get('x'), api.getWidth());\n            var yPx = numberUtil.parsePercent(itemModel.get('y'), api.getHeight());\n            if (!isNaN(xPx) && !isNaN(yPx)) {\n                point = [xPx, yPx];\n            }\n            // Chart like bar may have there own marker positioning logic\n            else if (seriesModel.getMarkerPosition) {\n                // Use the getMarkerPoisition\n                point = seriesModel.getMarkerPosition(\n                    mpData.getValues(mpData.dimensions, idx)\n                );\n            }\n            else if (coordSys) {\n                var x = mpData.get(coordSys.dimensions[0], idx);\n                var y = mpData.get(coordSys.dimensions[1], idx);\n                point = coordSys.dataToPoint([x, y]);\n\n            }\n\n            // Use x, y if has any\n            if (!isNaN(xPx)) {\n                point[0] = xPx;\n            }\n            if (!isNaN(yPx)) {\n                point[1] = yPx;\n            }\n\n            mpData.setItemLayout(idx, point);\n        });\n    }\n\n    __webpack_require__(/*! ./MarkerView */ 86).extend({\n\n        type: 'markPoint',\n\n        updateLayout: function (markPointModel, ecModel, api) {\n            ecModel.eachSeries(function (seriesModel) {\n                var mpModel = seriesModel.markPointModel;\n                if (mpModel) {\n                    updateMarkerLayout(mpModel.getData(), seriesModel, api);\n                    this.markerGroupMap[seriesModel.name].updateLayout(mpModel);\n                }\n            }, this);\n        },\n\n        renderSeries: function (seriesModel, mpModel, ecModel, api) {\n            var coordSys = seriesModel.coordinateSystem;\n            var seriesName = seriesModel.name;\n            var seriesData = seriesModel.getData();\n\n            var symbolDrawMap = this.markerGroupMap;\n            var symbolDraw = symbolDrawMap[seriesName];\n            if (!symbolDraw) {\n                symbolDraw = symbolDrawMap[seriesName] = new SymbolDraw();\n            }\n\n            var mpData = createList(coordSys, seriesModel, mpModel);\n\n            // FIXME\n            mpModel.setData(mpData);\n\n            updateMarkerLayout(mpModel.getData(), seriesModel, api);\n\n            mpData.each(function (idx) {\n                var itemModel = mpData.getItemModel(idx);\n                var symbolSize = itemModel.getShallow('symbolSize');\n                if (typeof symbolSize === 'function') {\n                    // FIXME 这里不兼容 ECharts 2.x，2.x 貌似参数是整个数据？\n                    symbolSize = symbolSize(\n                        mpModel.getRawValue(idx), mpModel.getDataParams(idx)\n                    );\n                }\n                mpData.setItemVisual(idx, {\n                    symbolSize: symbolSize,\n                    color: itemModel.get('itemStyle.normal.color')\n                        || seriesData.getVisual('color'),\n                    symbol: itemModel.getShallow('symbol')\n                });\n            });\n\n            // TODO Text are wrong\n            symbolDraw.updateData(mpData);\n            this.group.add(symbolDraw.group);\n\n            // Set host model for tooltip\n            // FIXME\n            mpData.eachItemGraphicEl(function (el) {\n                el.traverse(function (child) {\n                    child.dataModel = mpModel;\n                });\n            });\n\n            symbolDraw.__keep = true;\n\n            symbolDraw.group.silent = mpModel.get('silent') || seriesModel.get('silent');\n        }\n    });\n\n    /**\n     * @inner\n     * @param {module:echarts/coord/*} [coordSys]\n     * @param {module:echarts/model/Series} seriesModel\n     * @param {module:echarts/model/Model} mpModel\n     */\n    function createList(coordSys, seriesModel, mpModel) {\n        var coordDimsInfos;\n        if (coordSys) {\n            coordDimsInfos = zrUtil.map(coordSys && coordSys.dimensions, function (coordDim) {\n                var info = seriesModel.getData().getDimensionInfo(\n                    seriesModel.coordDimToDataDim(coordDim)[0]\n                ) || {}; // In map series data don't have lng and lat dimension. Fallback to same with coordSys\n                info.name = coordDim;\n                return info;\n            });\n        }\n        else {\n            coordDimsInfos =[{\n                name: 'value',\n                type: 'float'\n            }];\n        }\n\n        var mpData = new List(coordDimsInfos, mpModel);\n        var dataOpt = zrUtil.map(mpModel.get('data'), zrUtil.curry(\n                markerHelper.dataTransform, seriesModel\n            ));\n        if (coordSys) {\n            dataOpt = zrUtil.filter(\n                dataOpt, zrUtil.curry(markerHelper.dataFilter, coordSys)\n            );\n        }\n\n        mpData.initData(dataOpt, null,\n            coordSys ? markerHelper.dimValueGetter : function (item) {\n                return item.value;\n            }\n        );\n        return mpData;\n    }\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjI3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2NvbXBvbmVudC9tYXJrZXIvTWFya1BvaW50Vmlldy5qcz8yNjE2Il0sInNvdXJjZXNDb250ZW50IjpbIlxuXG4gICAgdmFyIFN5bWJvbERyYXcgPSByZXF1aXJlKCcuLi8uLi9jaGFydC9oZWxwZXIvU3ltYm9sRHJhdycpO1xuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgbnVtYmVyVXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvbnVtYmVyJyk7XG5cbiAgICB2YXIgTGlzdCA9IHJlcXVpcmUoJy4uLy4uL2RhdGEvTGlzdCcpO1xuXG4gICAgdmFyIG1hcmtlckhlbHBlciA9IHJlcXVpcmUoJy4vbWFya2VySGVscGVyJyk7XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVNYXJrZXJMYXlvdXQobXBEYXRhLCBzZXJpZXNNb2RlbCwgYXBpKSB7XG4gICAgICAgIHZhciBjb29yZFN5cyA9IHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW07XG4gICAgICAgIG1wRGF0YS5lYWNoKGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgICAgIHZhciBpdGVtTW9kZWwgPSBtcERhdGEuZ2V0SXRlbU1vZGVsKGlkeCk7XG4gICAgICAgICAgICB2YXIgcG9pbnQ7XG4gICAgICAgICAgICB2YXIgeFB4ID0gbnVtYmVyVXRpbC5wYXJzZVBlcmNlbnQoaXRlbU1vZGVsLmdldCgneCcpLCBhcGkuZ2V0V2lkdGgoKSk7XG4gICAgICAgICAgICB2YXIgeVB4ID0gbnVtYmVyVXRpbC5wYXJzZVBlcmNlbnQoaXRlbU1vZGVsLmdldCgneScpLCBhcGkuZ2V0SGVpZ2h0KCkpO1xuICAgICAgICAgICAgaWYgKCFpc05hTih4UHgpICYmICFpc05hTih5UHgpKSB7XG4gICAgICAgICAgICAgICAgcG9pbnQgPSBbeFB4LCB5UHhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2hhcnQgbGlrZSBiYXIgbWF5IGhhdmUgdGhlcmUgb3duIG1hcmtlciBwb3NpdGlvbmluZyBsb2dpY1xuICAgICAgICAgICAgZWxzZSBpZiAoc2VyaWVzTW9kZWwuZ2V0TWFya2VyUG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAvLyBVc2UgdGhlIGdldE1hcmtlclBvaXNpdGlvblxuICAgICAgICAgICAgICAgIHBvaW50ID0gc2VyaWVzTW9kZWwuZ2V0TWFya2VyUG9zaXRpb24oXG4gICAgICAgICAgICAgICAgICAgIG1wRGF0YS5nZXRWYWx1ZXMobXBEYXRhLmRpbWVuc2lvbnMsIGlkeClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY29vcmRTeXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgeCA9IG1wRGF0YS5nZXQoY29vcmRTeXMuZGltZW5zaW9uc1swXSwgaWR4KTtcbiAgICAgICAgICAgICAgICB2YXIgeSA9IG1wRGF0YS5nZXQoY29vcmRTeXMuZGltZW5zaW9uc1sxXSwgaWR4KTtcbiAgICAgICAgICAgICAgICBwb2ludCA9IGNvb3JkU3lzLmRhdGFUb1BvaW50KFt4LCB5XSk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVXNlIHgsIHkgaWYgaGFzIGFueVxuICAgICAgICAgICAgaWYgKCFpc05hTih4UHgpKSB7XG4gICAgICAgICAgICAgICAgcG9pbnRbMF0gPSB4UHg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzTmFOKHlQeCkpIHtcbiAgICAgICAgICAgICAgICBwb2ludFsxXSA9IHlQeDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbXBEYXRhLnNldEl0ZW1MYXlvdXQoaWR4LCBwb2ludCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJlcXVpcmUoJy4vTWFya2VyVmlldycpLmV4dGVuZCh7XG5cbiAgICAgICAgdHlwZTogJ21hcmtQb2ludCcsXG5cbiAgICAgICAgdXBkYXRlTGF5b3V0OiBmdW5jdGlvbiAobWFya1BvaW50TW9kZWwsIGVjTW9kZWwsIGFwaSkge1xuICAgICAgICAgICAgZWNNb2RlbC5lYWNoU2VyaWVzKGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgICAgICAgICAgICAgIHZhciBtcE1vZGVsID0gc2VyaWVzTW9kZWwubWFya1BvaW50TW9kZWw7XG4gICAgICAgICAgICAgICAgaWYgKG1wTW9kZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlTWFya2VyTGF5b3V0KG1wTW9kZWwuZ2V0RGF0YSgpLCBzZXJpZXNNb2RlbCwgYXBpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXJrZXJHcm91cE1hcFtzZXJpZXNNb2RlbC5uYW1lXS51cGRhdGVMYXlvdXQobXBNb2RlbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVuZGVyU2VyaWVzOiBmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIG1wTW9kZWwsIGVjTW9kZWwsIGFwaSkge1xuICAgICAgICAgICAgdmFyIGNvb3JkU3lzID0gc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcbiAgICAgICAgICAgIHZhciBzZXJpZXNOYW1lID0gc2VyaWVzTW9kZWwubmFtZTtcbiAgICAgICAgICAgIHZhciBzZXJpZXNEYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuXG4gICAgICAgICAgICB2YXIgc3ltYm9sRHJhd01hcCA9IHRoaXMubWFya2VyR3JvdXBNYXA7XG4gICAgICAgICAgICB2YXIgc3ltYm9sRHJhdyA9IHN5bWJvbERyYXdNYXBbc2VyaWVzTmFtZV07XG4gICAgICAgICAgICBpZiAoIXN5bWJvbERyYXcpIHtcbiAgICAgICAgICAgICAgICBzeW1ib2xEcmF3ID0gc3ltYm9sRHJhd01hcFtzZXJpZXNOYW1lXSA9IG5ldyBTeW1ib2xEcmF3KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBtcERhdGEgPSBjcmVhdGVMaXN0KGNvb3JkU3lzLCBzZXJpZXNNb2RlbCwgbXBNb2RlbCk7XG5cbiAgICAgICAgICAgIC8vIEZJWE1FXG4gICAgICAgICAgICBtcE1vZGVsLnNldERhdGEobXBEYXRhKTtcblxuICAgICAgICAgICAgdXBkYXRlTWFya2VyTGF5b3V0KG1wTW9kZWwuZ2V0RGF0YSgpLCBzZXJpZXNNb2RlbCwgYXBpKTtcblxuICAgICAgICAgICAgbXBEYXRhLmVhY2goZnVuY3Rpb24gKGlkeCkge1xuICAgICAgICAgICAgICAgIHZhciBpdGVtTW9kZWwgPSBtcERhdGEuZ2V0SXRlbU1vZGVsKGlkeCk7XG4gICAgICAgICAgICAgICAgdmFyIHN5bWJvbFNpemUgPSBpdGVtTW9kZWwuZ2V0U2hhbGxvdygnc3ltYm9sU2l6ZScpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc3ltYm9sU2l6ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBGSVhNRSDov5nph4zkuI3lhbzlrrkgRUNoYXJ0cyAyLnjvvIwyLngg6LKM5Ly85Y+C5pWw5piv5pW05Liq5pWw5o2u77yfXG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbFNpemUgPSBzeW1ib2xTaXplKFxuICAgICAgICAgICAgICAgICAgICAgICAgbXBNb2RlbC5nZXRSYXdWYWx1ZShpZHgpLCBtcE1vZGVsLmdldERhdGFQYXJhbXMoaWR4KVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtcERhdGEuc2V0SXRlbVZpc3VhbChpZHgsIHtcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sU2l6ZTogc3ltYm9sU2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6IGl0ZW1Nb2RlbC5nZXQoJ2l0ZW1TdHlsZS5ub3JtYWwuY29sb3InKVxuICAgICAgICAgICAgICAgICAgICAgICAgfHwgc2VyaWVzRGF0YS5nZXRWaXN1YWwoJ2NvbG9yJyksXG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbDogaXRlbU1vZGVsLmdldFNoYWxsb3coJ3N5bWJvbCcpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gVE9ETyBUZXh0IGFyZSB3cm9uZ1xuICAgICAgICAgICAgc3ltYm9sRHJhdy51cGRhdGVEYXRhKG1wRGF0YSk7XG4gICAgICAgICAgICB0aGlzLmdyb3VwLmFkZChzeW1ib2xEcmF3Lmdyb3VwKTtcblxuICAgICAgICAgICAgLy8gU2V0IGhvc3QgbW9kZWwgZm9yIHRvb2x0aXBcbiAgICAgICAgICAgIC8vIEZJWE1FXG4gICAgICAgICAgICBtcERhdGEuZWFjaEl0ZW1HcmFwaGljRWwoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgZWwudHJhdmVyc2UoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLmRhdGFNb2RlbCA9IG1wTW9kZWw7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgc3ltYm9sRHJhdy5fX2tlZXAgPSB0cnVlO1xuXG4gICAgICAgICAgICBzeW1ib2xEcmF3Lmdyb3VwLnNpbGVudCA9IG1wTW9kZWwuZ2V0KCdzaWxlbnQnKSB8fCBzZXJpZXNNb2RlbC5nZXQoJ3NpbGVudCcpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBAaW5uZXJcbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2Nvb3JkLyp9IFtjb29yZFN5c11cbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL1Nlcmllc30gc2VyaWVzTW9kZWxcbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBtcE1vZGVsXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlTGlzdChjb29yZFN5cywgc2VyaWVzTW9kZWwsIG1wTW9kZWwpIHtcbiAgICAgICAgdmFyIGNvb3JkRGltc0luZm9zO1xuICAgICAgICBpZiAoY29vcmRTeXMpIHtcbiAgICAgICAgICAgIGNvb3JkRGltc0luZm9zID0genJVdGlsLm1hcChjb29yZFN5cyAmJiBjb29yZFN5cy5kaW1lbnNpb25zLCBmdW5jdGlvbiAoY29vcmREaW0pIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5mbyA9IHNlcmllc01vZGVsLmdldERhdGEoKS5nZXREaW1lbnNpb25JbmZvKFxuICAgICAgICAgICAgICAgICAgICBzZXJpZXNNb2RlbC5jb29yZERpbVRvRGF0YURpbShjb29yZERpbSlbMF1cbiAgICAgICAgICAgICAgICApIHx8IHt9OyAvLyBJbiBtYXAgc2VyaWVzIGRhdGEgZG9uJ3QgaGF2ZSBsbmcgYW5kIGxhdCBkaW1lbnNpb24uIEZhbGxiYWNrIHRvIHNhbWUgd2l0aCBjb29yZFN5c1xuICAgICAgICAgICAgICAgIGluZm8ubmFtZSA9IGNvb3JkRGltO1xuICAgICAgICAgICAgICAgIHJldHVybiBpbmZvO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb29yZERpbXNJbmZvcyA9W3tcbiAgICAgICAgICAgICAgICBuYW1lOiAndmFsdWUnLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdmbG9hdCdcbiAgICAgICAgICAgIH1dO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1wRGF0YSA9IG5ldyBMaXN0KGNvb3JkRGltc0luZm9zLCBtcE1vZGVsKTtcbiAgICAgICAgdmFyIGRhdGFPcHQgPSB6clV0aWwubWFwKG1wTW9kZWwuZ2V0KCdkYXRhJyksIHpyVXRpbC5jdXJyeShcbiAgICAgICAgICAgICAgICBtYXJrZXJIZWxwZXIuZGF0YVRyYW5zZm9ybSwgc2VyaWVzTW9kZWxcbiAgICAgICAgICAgICkpO1xuICAgICAgICBpZiAoY29vcmRTeXMpIHtcbiAgICAgICAgICAgIGRhdGFPcHQgPSB6clV0aWwuZmlsdGVyKFxuICAgICAgICAgICAgICAgIGRhdGFPcHQsIHpyVXRpbC5jdXJyeShtYXJrZXJIZWxwZXIuZGF0YUZpbHRlciwgY29vcmRTeXMpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgbXBEYXRhLmluaXREYXRhKGRhdGFPcHQsIG51bGwsXG4gICAgICAgICAgICBjb29yZFN5cyA/IG1hcmtlckhlbHBlci5kaW1WYWx1ZUdldHRlciA6IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0udmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBtcERhdGE7XG4gICAgfVxuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9jb21wb25lbnQvbWFya2VyL01hcmtQb2ludFZpZXcuanNcbi8vIG1vZHVsZSBpZCA9IDIyN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 228 */
/* unknown exports provided */
/* all exports used */
/*!***********************************************!*\
  !*** ./lib/component/toolbox/ToolboxModel.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var featureManager = __webpack_require__(/*! ./featureManager */ 28);\n    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 0);\n\n    var ToolboxModel = __webpack_require__(/*! ../../echarts */ 1).extendComponentModel({\n\n        type: 'toolbox',\n\n        layoutMode: {\n            type: 'box',\n            ignoreSize: true\n        },\n\n        mergeDefaultAndTheme: function (option) {\n            ToolboxModel.superApply(this, 'mergeDefaultAndTheme', arguments);\n\n            zrUtil.each(this.option.feature, function (featureOpt, featureName) {\n                var Feature = featureManager.get(featureName);\n                Feature && zrUtil.merge(featureOpt, Feature.defaultOption);\n            });\n        },\n\n        defaultOption: {\n\n            show: true,\n\n            z: 6,\n\n            zlevel: 0,\n\n            orient: 'horizontal',\n\n            left: 'right',\n\n            top: 'top',\n\n            // right\n            // bottom\n\n            backgroundColor: 'transparent',\n\n            borderColor: '#ccc',\n\n            borderWidth: 0,\n\n            padding: 5,\n\n            itemSize: 15,\n\n            itemGap: 8,\n\n            showTitle: true,\n\n            iconStyle: {\n                normal: {\n                    borderColor: '#666',\n                    color: 'none'\n                },\n                emphasis: {\n                    borderColor: '#3E98C5'\n                }\n            }\n            // textStyle: {},\n\n            // feature\n        }\n    });\n\n    module.exports = ToolboxModel;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjI4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2NvbXBvbmVudC90b29sYm94L1Rvb2xib3hNb2RlbC5qcz9mZjFmIl0sInNvdXJjZXNDb250ZW50IjpbIlxuXG4gICAgdmFyIGZlYXR1cmVNYW5hZ2VyID0gcmVxdWlyZSgnLi9mZWF0dXJlTWFuYWdlcicpO1xuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcblxuICAgIHZhciBUb29sYm94TW9kZWwgPSByZXF1aXJlKCcuLi8uLi9lY2hhcnRzJykuZXh0ZW5kQ29tcG9uZW50TW9kZWwoe1xuXG4gICAgICAgIHR5cGU6ICd0b29sYm94JyxcblxuICAgICAgICBsYXlvdXRNb2RlOiB7XG4gICAgICAgICAgICB0eXBlOiAnYm94JyxcbiAgICAgICAgICAgIGlnbm9yZVNpemU6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICBtZXJnZURlZmF1bHRBbmRUaGVtZTogZnVuY3Rpb24gKG9wdGlvbikge1xuICAgICAgICAgICAgVG9vbGJveE1vZGVsLnN1cGVyQXBwbHkodGhpcywgJ21lcmdlRGVmYXVsdEFuZFRoZW1lJywgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgenJVdGlsLmVhY2godGhpcy5vcHRpb24uZmVhdHVyZSwgZnVuY3Rpb24gKGZlYXR1cmVPcHQsIGZlYXR1cmVOYW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIEZlYXR1cmUgPSBmZWF0dXJlTWFuYWdlci5nZXQoZmVhdHVyZU5hbWUpO1xuICAgICAgICAgICAgICAgIEZlYXR1cmUgJiYgenJVdGlsLm1lcmdlKGZlYXR1cmVPcHQsIEZlYXR1cmUuZGVmYXVsdE9wdGlvbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBkZWZhdWx0T3B0aW9uOiB7XG5cbiAgICAgICAgICAgIHNob3c6IHRydWUsXG5cbiAgICAgICAgICAgIHo6IDYsXG5cbiAgICAgICAgICAgIHpsZXZlbDogMCxcblxuICAgICAgICAgICAgb3JpZW50OiAnaG9yaXpvbnRhbCcsXG5cbiAgICAgICAgICAgIGxlZnQ6ICdyaWdodCcsXG5cbiAgICAgICAgICAgIHRvcDogJ3RvcCcsXG5cbiAgICAgICAgICAgIC8vIHJpZ2h0XG4gICAgICAgICAgICAvLyBib3R0b21cblxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAndHJhbnNwYXJlbnQnLFxuXG4gICAgICAgICAgICBib3JkZXJDb2xvcjogJyNjY2MnLFxuXG4gICAgICAgICAgICBib3JkZXJXaWR0aDogMCxcblxuICAgICAgICAgICAgcGFkZGluZzogNSxcblxuICAgICAgICAgICAgaXRlbVNpemU6IDE1LFxuXG4gICAgICAgICAgICBpdGVtR2FwOiA4LFxuXG4gICAgICAgICAgICBzaG93VGl0bGU6IHRydWUsXG5cbiAgICAgICAgICAgIGljb25TdHlsZToge1xuICAgICAgICAgICAgICAgIG5vcm1hbDoge1xuICAgICAgICAgICAgICAgICAgICBib3JkZXJDb2xvcjogJyM2NjYnLFxuICAgICAgICAgICAgICAgICAgICBjb2xvcjogJ25vbmUnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlbXBoYXNpczoge1xuICAgICAgICAgICAgICAgICAgICBib3JkZXJDb2xvcjogJyMzRTk4QzUnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGV4dFN0eWxlOiB7fSxcblxuICAgICAgICAgICAgLy8gZmVhdHVyZVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFRvb2xib3hNb2RlbDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2NvbXBvbmVudC90b29sYm94L1Rvb2xib3hNb2RlbC5qc1xuLy8gbW9kdWxlIGlkID0gMjI4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 229 */
/* unknown exports provided */
/* all exports used */
/*!**********************************************!*\
  !*** ./lib/component/toolbox/ToolboxView.js ***!
  \**********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var featureManager = __webpack_require__(/*! ./featureManager */ 28);\n    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 0);\n    var graphic = __webpack_require__(/*! ../../util/graphic */ 2);\n    var Model = __webpack_require__(/*! ../../model/Model */ 9);\n    var DataDiffer = __webpack_require__(/*! ../../data/DataDiffer */ 48);\n    var listComponentHelper = __webpack_require__(/*! ../helper/listComponent */ 159);\n    var textContain = __webpack_require__(/*! zrender/lib/contain/text */ 15);\n\n    module.exports = __webpack_require__(/*! ../../echarts */ 1).extendComponentView({\n\n        type: 'toolbox',\n\n        render: function (toolboxModel, ecModel, api, payload) {\n            var group = this.group;\n            group.removeAll();\n\n            if (!toolboxModel.get('show')) {\n                return;\n            }\n\n            var itemSize = +toolboxModel.get('itemSize');\n            var featureOpts = toolboxModel.get('feature') || {};\n            var features = this._features || (this._features = {});\n\n            var featureNames = [];\n            zrUtil.each(featureOpts, function (opt, name) {\n                featureNames.push(name);\n            });\n\n            (new DataDiffer(this._featureNames || [], featureNames))\n                .add(process)\n                .update(process)\n                .remove(zrUtil.curry(process, null))\n                .execute();\n\n            // Keep for diff.\n            this._featureNames = featureNames;\n\n            function process(newIndex, oldIndex) {\n                var featureName = featureNames[newIndex];\n                var oldName = featureNames[oldIndex];\n                var featureOpt = featureOpts[featureName];\n                var featureModel = new Model(featureOpt, toolboxModel, toolboxModel.ecModel);\n                var feature;\n\n                if (featureName && !oldName) { // Create\n                    if (isUserFeatureName(featureName)) {\n                        feature = {\n                            model: featureModel,\n                            onclick: featureModel.option.onclick,\n                            featureName: featureName\n                        };\n                    }\n                    else {\n                        var Feature = featureManager.get(featureName);\n                        if (!Feature) {\n                            return;\n                        }\n                        feature = new Feature(featureModel, ecModel, api);\n                    }\n                    features[featureName] = feature;\n                }\n                else {\n                    feature = features[oldName];\n                    // If feature does not exsit.\n                    if (!feature) {\n                        return;\n                    }\n                    feature.model = featureModel;\n                    feature.ecModel = ecModel;\n                    feature.api = api;\n                }\n\n                if (!featureName && oldName) {\n                    feature.dispose && feature.dispose(ecModel, api);\n                    return;\n                }\n\n                if (!featureModel.get('show') || feature.unusable) {\n                    feature.remove && feature.remove(ecModel, api);\n                    return;\n                }\n\n                createIconPaths(featureModel, feature, featureName);\n\n                featureModel.setIconStatus = function (iconName, status) {\n                    var option = this.option;\n                    var iconPaths = this.iconPaths;\n                    option.iconStatus = option.iconStatus || {};\n                    option.iconStatus[iconName] = status;\n                    // FIXME\n                    iconPaths[iconName] && iconPaths[iconName].trigger(status);\n                };\n\n                if (feature.render) {\n                    feature.render(featureModel, ecModel, api, payload);\n                }\n            }\n\n            function createIconPaths(featureModel, feature, featureName) {\n                var iconStyleModel = featureModel.getModel('iconStyle');\n\n                // If one feature has mutiple icon. they are orginaized as\n                // {\n                //     icon: {\n                //         foo: '',\n                //         bar: ''\n                //     },\n                //     title: {\n                //         foo: '',\n                //         bar: ''\n                //     }\n                // }\n                var icons = feature.getIcons ? feature.getIcons() : featureModel.get('icon');\n                var titles = featureModel.get('title') || {};\n                if (typeof icons === 'string') {\n                    var icon = icons;\n                    var title = titles;\n                    icons = {};\n                    titles = {};\n                    icons[featureName] = icon;\n                    titles[featureName] = title;\n                }\n                var iconPaths = featureModel.iconPaths = {};\n                zrUtil.each(icons, function (icon, iconName) {\n                    var normalStyle = iconStyleModel.getModel('normal').getItemStyle();\n                    var hoverStyle = iconStyleModel.getModel('emphasis').getItemStyle();\n\n                    var style = {\n                        x: -itemSize / 2,\n                        y: -itemSize / 2,\n                        width: itemSize,\n                        height: itemSize\n                    };\n                    var path = icon.indexOf('image://') === 0\n                        ? (\n                            style.image = icon.slice(8),\n                            new graphic.Image({style: style})\n                        )\n                        : graphic.makePath(\n                            icon.replace('path://', ''),\n                            {\n                                style: normalStyle,\n                                hoverStyle: hoverStyle,\n                                rectHover: true\n                            },\n                            style,\n                            'center'\n                        );\n\n                    graphic.setHoverStyle(path);\n\n                    if (toolboxModel.get('showTitle')) {\n                        path.__title = titles[iconName];\n                        path.on('mouseover', function () {\n                                // Should not reuse above hoverStyle, which might be modified.\n                                var hoverStyle = iconStyleModel.getModel('emphasis').getItemStyle();\n                                path.setStyle({\n                                    text: titles[iconName],\n                                    textPosition: hoverStyle.textPosition || 'bottom',\n                                    textFill: hoverStyle.fill || hoverStyle.stroke || '#000',\n                                    textAlign: hoverStyle.textAlign || 'center'\n                                });\n                            })\n                            .on('mouseout', function () {\n                                path.setStyle({\n                                    textFill: null\n                                });\n                            });\n                    }\n                    path.trigger(featureModel.get('iconStatus.' + iconName) || 'normal');\n\n                    group.add(path);\n                    path.on('click', zrUtil.bind(\n                        feature.onclick, feature, ecModel, api, iconName\n                    ));\n\n                    iconPaths[iconName] = path;\n                });\n            }\n\n            listComponentHelper.layout(group, toolboxModel, api);\n            // Render background after group is layout\n            // FIXME\n            listComponentHelper.addBackground(group, toolboxModel);\n\n            // Adjust icon title positions to avoid them out of screen\n            group.eachChild(function (icon) {\n                var titleText = icon.__title;\n                var hoverStyle = icon.hoverStyle;\n                // May be background element\n                if (hoverStyle && titleText) {\n                    var rect = textContain.getBoundingRect(\n                        titleText, hoverStyle.font\n                    );\n                    var offsetX = icon.position[0] + group.position[0];\n                    var offsetY = icon.position[1] + group.position[1] + itemSize;\n\n                    var needPutOnTop = false;\n                    if (offsetY + rect.height > api.getHeight()) {\n                        hoverStyle.textPosition = 'top';\n                        needPutOnTop = true;\n                    }\n                    var topOffset = needPutOnTop ? (-5 - rect.height) : (itemSize + 8);\n                    if (offsetX + rect.width /  2 > api.getWidth()) {\n                        hoverStyle.textPosition = ['100%', topOffset];\n                        hoverStyle.textAlign = 'right';\n                    }\n                    else if (offsetX - rect.width / 2 < 0) {\n                        hoverStyle.textPosition = [0, topOffset];\n                        hoverStyle.textAlign = 'left';\n                    }\n                }\n            });\n        },\n\n        updateView: function (toolboxModel, ecModel, api, payload) {\n            zrUtil.each(this._features, function (feature) {\n                feature.updateView && feature.updateView(feature.model, ecModel, api, payload);\n            });\n        },\n\n        updateLayout: function (toolboxModel, ecModel, api, payload) {\n            zrUtil.each(this._features, function (feature) {\n                feature.updateLayout && feature.updateLayout(feature.model, ecModel, api, payload);\n            });\n        },\n\n        remove: function (ecModel, api) {\n            zrUtil.each(this._features, function (feature) {\n                feature.remove && feature.remove(ecModel, api);\n            });\n            this.group.removeAll();\n        },\n\n        dispose: function (ecModel, api) {\n            zrUtil.each(this._features, function (feature) {\n                feature.dispose && feature.dispose(ecModel, api);\n            });\n        }\n    });\n\n    function isUserFeatureName(featureName) {\n        return featureName.indexOf('my') === 0;\n    }\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjI5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2NvbXBvbmVudC90b29sYm94L1Rvb2xib3hWaWV3LmpzP2Q2YzQiXSwic291cmNlc0NvbnRlbnQiOlsiXG5cbiAgICB2YXIgZmVhdHVyZU1hbmFnZXIgPSByZXF1aXJlKCcuL2ZlYXR1cmVNYW5hZ2VyJyk7XG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuICAgIHZhciBncmFwaGljID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9ncmFwaGljJyk7XG4gICAgdmFyIE1vZGVsID0gcmVxdWlyZSgnLi4vLi4vbW9kZWwvTW9kZWwnKTtcbiAgICB2YXIgRGF0YURpZmZlciA9IHJlcXVpcmUoJy4uLy4uL2RhdGEvRGF0YURpZmZlcicpO1xuICAgIHZhciBsaXN0Q29tcG9uZW50SGVscGVyID0gcmVxdWlyZSgnLi4vaGVscGVyL2xpc3RDb21wb25lbnQnKTtcbiAgICB2YXIgdGV4dENvbnRhaW4gPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb250YWluL3RleHQnKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vZWNoYXJ0cycpLmV4dGVuZENvbXBvbmVudFZpZXcoe1xuXG4gICAgICAgIHR5cGU6ICd0b29sYm94JyxcblxuICAgICAgICByZW5kZXI6IGZ1bmN0aW9uICh0b29sYm94TW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCkge1xuICAgICAgICAgICAgdmFyIGdyb3VwID0gdGhpcy5ncm91cDtcbiAgICAgICAgICAgIGdyb3VwLnJlbW92ZUFsbCgpO1xuXG4gICAgICAgICAgICBpZiAoIXRvb2xib3hNb2RlbC5nZXQoJ3Nob3cnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGl0ZW1TaXplID0gK3Rvb2xib3hNb2RlbC5nZXQoJ2l0ZW1TaXplJyk7XG4gICAgICAgICAgICB2YXIgZmVhdHVyZU9wdHMgPSB0b29sYm94TW9kZWwuZ2V0KCdmZWF0dXJlJykgfHwge307XG4gICAgICAgICAgICB2YXIgZmVhdHVyZXMgPSB0aGlzLl9mZWF0dXJlcyB8fCAodGhpcy5fZmVhdHVyZXMgPSB7fSk7XG5cbiAgICAgICAgICAgIHZhciBmZWF0dXJlTmFtZXMgPSBbXTtcbiAgICAgICAgICAgIHpyVXRpbC5lYWNoKGZlYXR1cmVPcHRzLCBmdW5jdGlvbiAob3B0LCBuYW1lKSB7XG4gICAgICAgICAgICAgICAgZmVhdHVyZU5hbWVzLnB1c2gobmFtZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgKG5ldyBEYXRhRGlmZmVyKHRoaXMuX2ZlYXR1cmVOYW1lcyB8fCBbXSwgZmVhdHVyZU5hbWVzKSlcbiAgICAgICAgICAgICAgICAuYWRkKHByb2Nlc3MpXG4gICAgICAgICAgICAgICAgLnVwZGF0ZShwcm9jZXNzKVxuICAgICAgICAgICAgICAgIC5yZW1vdmUoenJVdGlsLmN1cnJ5KHByb2Nlc3MsIG51bGwpKVxuICAgICAgICAgICAgICAgIC5leGVjdXRlKCk7XG5cbiAgICAgICAgICAgIC8vIEtlZXAgZm9yIGRpZmYuXG4gICAgICAgICAgICB0aGlzLl9mZWF0dXJlTmFtZXMgPSBmZWF0dXJlTmFtZXM7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHByb2Nlc3MobmV3SW5kZXgsIG9sZEluZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIGZlYXR1cmVOYW1lID0gZmVhdHVyZU5hbWVzW25ld0luZGV4XTtcbiAgICAgICAgICAgICAgICB2YXIgb2xkTmFtZSA9IGZlYXR1cmVOYW1lc1tvbGRJbmRleF07XG4gICAgICAgICAgICAgICAgdmFyIGZlYXR1cmVPcHQgPSBmZWF0dXJlT3B0c1tmZWF0dXJlTmFtZV07XG4gICAgICAgICAgICAgICAgdmFyIGZlYXR1cmVNb2RlbCA9IG5ldyBNb2RlbChmZWF0dXJlT3B0LCB0b29sYm94TW9kZWwsIHRvb2xib3hNb2RlbC5lY01vZGVsKTtcbiAgICAgICAgICAgICAgICB2YXIgZmVhdHVyZTtcblxuICAgICAgICAgICAgICAgIGlmIChmZWF0dXJlTmFtZSAmJiAhb2xkTmFtZSkgeyAvLyBDcmVhdGVcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzVXNlckZlYXR1cmVOYW1lKGZlYXR1cmVOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmVhdHVyZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlbDogZmVhdHVyZU1vZGVsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uY2xpY2s6IGZlYXR1cmVNb2RlbC5vcHRpb24ub25jbGljayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmZWF0dXJlTmFtZTogZmVhdHVyZU5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgRmVhdHVyZSA9IGZlYXR1cmVNYW5hZ2VyLmdldChmZWF0dXJlTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIUZlYXR1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmZWF0dXJlID0gbmV3IEZlYXR1cmUoZmVhdHVyZU1vZGVsLCBlY01vZGVsLCBhcGkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZlYXR1cmVzW2ZlYXR1cmVOYW1lXSA9IGZlYXR1cmU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmZWF0dXJlID0gZmVhdHVyZXNbb2xkTmFtZV07XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIGZlYXR1cmUgZG9lcyBub3QgZXhzaXQuXG4gICAgICAgICAgICAgICAgICAgIGlmICghZmVhdHVyZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZlYXR1cmUubW9kZWwgPSBmZWF0dXJlTW9kZWw7XG4gICAgICAgICAgICAgICAgICAgIGZlYXR1cmUuZWNNb2RlbCA9IGVjTW9kZWw7XG4gICAgICAgICAgICAgICAgICAgIGZlYXR1cmUuYXBpID0gYXBpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghZmVhdHVyZU5hbWUgJiYgb2xkTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBmZWF0dXJlLmRpc3Bvc2UgJiYgZmVhdHVyZS5kaXNwb3NlKGVjTW9kZWwsIGFwaSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIWZlYXR1cmVNb2RlbC5nZXQoJ3Nob3cnKSB8fCBmZWF0dXJlLnVudXNhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGZlYXR1cmUucmVtb3ZlICYmIGZlYXR1cmUucmVtb3ZlKGVjTW9kZWwsIGFwaSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjcmVhdGVJY29uUGF0aHMoZmVhdHVyZU1vZGVsLCBmZWF0dXJlLCBmZWF0dXJlTmFtZSk7XG5cbiAgICAgICAgICAgICAgICBmZWF0dXJlTW9kZWwuc2V0SWNvblN0YXR1cyA9IGZ1bmN0aW9uIChpY29uTmFtZSwgc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvcHRpb24gPSB0aGlzLm9wdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGljb25QYXRocyA9IHRoaXMuaWNvblBhdGhzO1xuICAgICAgICAgICAgICAgICAgICBvcHRpb24uaWNvblN0YXR1cyA9IG9wdGlvbi5pY29uU3RhdHVzIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICBvcHRpb24uaWNvblN0YXR1c1tpY29uTmFtZV0gPSBzdGF0dXM7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZJWE1FXG4gICAgICAgICAgICAgICAgICAgIGljb25QYXRoc1tpY29uTmFtZV0gJiYgaWNvblBhdGhzW2ljb25OYW1lXS50cmlnZ2VyKHN0YXR1cyk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGlmIChmZWF0dXJlLnJlbmRlcikge1xuICAgICAgICAgICAgICAgICAgICBmZWF0dXJlLnJlbmRlcihmZWF0dXJlTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBjcmVhdGVJY29uUGF0aHMoZmVhdHVyZU1vZGVsLCBmZWF0dXJlLCBmZWF0dXJlTmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBpY29uU3R5bGVNb2RlbCA9IGZlYXR1cmVNb2RlbC5nZXRNb2RlbCgnaWNvblN0eWxlJyk7XG5cbiAgICAgICAgICAgICAgICAvLyBJZiBvbmUgZmVhdHVyZSBoYXMgbXV0aXBsZSBpY29uLiB0aGV5IGFyZSBvcmdpbmFpemVkIGFzXG4gICAgICAgICAgICAgICAgLy8ge1xuICAgICAgICAgICAgICAgIC8vICAgICBpY29uOiB7XG4gICAgICAgICAgICAgICAgLy8gICAgICAgICBmb286ICcnLFxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgYmFyOiAnJ1xuICAgICAgICAgICAgICAgIC8vICAgICB9LFxuICAgICAgICAgICAgICAgIC8vICAgICB0aXRsZToge1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgZm9vOiAnJyxcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgIGJhcjogJydcbiAgICAgICAgICAgICAgICAvLyAgICAgfVxuICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICB2YXIgaWNvbnMgPSBmZWF0dXJlLmdldEljb25zID8gZmVhdHVyZS5nZXRJY29ucygpIDogZmVhdHVyZU1vZGVsLmdldCgnaWNvbicpO1xuICAgICAgICAgICAgICAgIHZhciB0aXRsZXMgPSBmZWF0dXJlTW9kZWwuZ2V0KCd0aXRsZScpIHx8IHt9O1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaWNvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpY29uID0gaWNvbnM7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0aXRsZSA9IHRpdGxlcztcbiAgICAgICAgICAgICAgICAgICAgaWNvbnMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgdGl0bGVzID0ge307XG4gICAgICAgICAgICAgICAgICAgIGljb25zW2ZlYXR1cmVOYW1lXSA9IGljb247XG4gICAgICAgICAgICAgICAgICAgIHRpdGxlc1tmZWF0dXJlTmFtZV0gPSB0aXRsZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGljb25QYXRocyA9IGZlYXR1cmVNb2RlbC5pY29uUGF0aHMgPSB7fTtcbiAgICAgICAgICAgICAgICB6clV0aWwuZWFjaChpY29ucywgZnVuY3Rpb24gKGljb24sIGljb25OYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBub3JtYWxTdHlsZSA9IGljb25TdHlsZU1vZGVsLmdldE1vZGVsKCdub3JtYWwnKS5nZXRJdGVtU3R5bGUoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhvdmVyU3R5bGUgPSBpY29uU3R5bGVNb2RlbC5nZXRNb2RlbCgnZW1waGFzaXMnKS5nZXRJdGVtU3R5bGUoKTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgc3R5bGUgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiAtaXRlbVNpemUgLyAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogLWl0ZW1TaXplIC8gMixcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBpdGVtU2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogaXRlbVNpemVcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhdGggPSBpY29uLmluZGV4T2YoJ2ltYWdlOi8vJykgPT09IDBcbiAgICAgICAgICAgICAgICAgICAgICAgID8gKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlLmltYWdlID0gaWNvbi5zbGljZSg4KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgZ3JhcGhpYy5JbWFnZSh7c3R5bGU6IHN0eWxlfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgIDogZ3JhcGhpYy5tYWtlUGF0aChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpY29uLnJlcGxhY2UoJ3BhdGg6Ly8nLCAnJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogbm9ybWFsU3R5bGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvdmVyU3R5bGU6IGhvdmVyU3R5bGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY3RIb3ZlcjogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2NlbnRlcidcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgZ3JhcGhpYy5zZXRIb3ZlclN0eWxlKHBhdGgpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0b29sYm94TW9kZWwuZ2V0KCdzaG93VGl0bGUnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5fX3RpdGxlID0gdGl0bGVzW2ljb25OYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGgub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2hvdWxkIG5vdCByZXVzZSBhYm92ZSBob3ZlclN0eWxlLCB3aGljaCBtaWdodCBiZSBtb2RpZmllZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhvdmVyU3R5bGUgPSBpY29uU3R5bGVNb2RlbC5nZXRNb2RlbCgnZW1waGFzaXMnKS5nZXRJdGVtU3R5bGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5zZXRTdHlsZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiB0aXRsZXNbaWNvbk5hbWVdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dFBvc2l0aW9uOiBob3ZlclN0eWxlLnRleHRQb3NpdGlvbiB8fCAnYm90dG9tJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRGaWxsOiBob3ZlclN0eWxlLmZpbGwgfHwgaG92ZXJTdHlsZS5zdHJva2UgfHwgJyMwMDAnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dEFsaWduOiBob3ZlclN0eWxlLnRleHRBbGlnbiB8fCAnY2VudGVyJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGguc2V0U3R5bGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dEZpbGw6IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcGF0aC50cmlnZ2VyKGZlYXR1cmVNb2RlbC5nZXQoJ2ljb25TdGF0dXMuJyArIGljb25OYW1lKSB8fCAnbm9ybWFsJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgZ3JvdXAuYWRkKHBhdGgpO1xuICAgICAgICAgICAgICAgICAgICBwYXRoLm9uKCdjbGljaycsIHpyVXRpbC5iaW5kKFxuICAgICAgICAgICAgICAgICAgICAgICAgZmVhdHVyZS5vbmNsaWNrLCBmZWF0dXJlLCBlY01vZGVsLCBhcGksIGljb25OYW1lXG4gICAgICAgICAgICAgICAgICAgICkpO1xuXG4gICAgICAgICAgICAgICAgICAgIGljb25QYXRoc1tpY29uTmFtZV0gPSBwYXRoO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsaXN0Q29tcG9uZW50SGVscGVyLmxheW91dChncm91cCwgdG9vbGJveE1vZGVsLCBhcGkpO1xuICAgICAgICAgICAgLy8gUmVuZGVyIGJhY2tncm91bmQgYWZ0ZXIgZ3JvdXAgaXMgbGF5b3V0XG4gICAgICAgICAgICAvLyBGSVhNRVxuICAgICAgICAgICAgbGlzdENvbXBvbmVudEhlbHBlci5hZGRCYWNrZ3JvdW5kKGdyb3VwLCB0b29sYm94TW9kZWwpO1xuXG4gICAgICAgICAgICAvLyBBZGp1c3QgaWNvbiB0aXRsZSBwb3NpdGlvbnMgdG8gYXZvaWQgdGhlbSBvdXQgb2Ygc2NyZWVuXG4gICAgICAgICAgICBncm91cC5lYWNoQ2hpbGQoZnVuY3Rpb24gKGljb24pIHtcbiAgICAgICAgICAgICAgICB2YXIgdGl0bGVUZXh0ID0gaWNvbi5fX3RpdGxlO1xuICAgICAgICAgICAgICAgIHZhciBob3ZlclN0eWxlID0gaWNvbi5ob3ZlclN0eWxlO1xuICAgICAgICAgICAgICAgIC8vIE1heSBiZSBiYWNrZ3JvdW5kIGVsZW1lbnRcbiAgICAgICAgICAgICAgICBpZiAoaG92ZXJTdHlsZSAmJiB0aXRsZVRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlY3QgPSB0ZXh0Q29udGFpbi5nZXRCb3VuZGluZ1JlY3QoXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZVRleHQsIGhvdmVyU3R5bGUuZm9udFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0WCA9IGljb24ucG9zaXRpb25bMF0gKyBncm91cC5wb3NpdGlvblswXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9mZnNldFkgPSBpY29uLnBvc2l0aW9uWzFdICsgZ3JvdXAucG9zaXRpb25bMV0gKyBpdGVtU2l6ZTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgbmVlZFB1dE9uVG9wID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvZmZzZXRZICsgcmVjdC5oZWlnaHQgPiBhcGkuZ2V0SGVpZ2h0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvdmVyU3R5bGUudGV4dFBvc2l0aW9uID0gJ3RvcCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZWVkUHV0T25Ub3AgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciB0b3BPZmZzZXQgPSBuZWVkUHV0T25Ub3AgPyAoLTUgLSByZWN0LmhlaWdodCkgOiAoaXRlbVNpemUgKyA4KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9mZnNldFggKyByZWN0LndpZHRoIC8gIDIgPiBhcGkuZ2V0V2lkdGgoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaG92ZXJTdHlsZS50ZXh0UG9zaXRpb24gPSBbJzEwMCUnLCB0b3BPZmZzZXRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaG92ZXJTdHlsZS50ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9mZnNldFggLSByZWN0LndpZHRoIC8gMiA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvdmVyU3R5bGUudGV4dFBvc2l0aW9uID0gWzAsIHRvcE9mZnNldF07XG4gICAgICAgICAgICAgICAgICAgICAgICBob3ZlclN0eWxlLnRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIHVwZGF0ZVZpZXc6IGZ1bmN0aW9uICh0b29sYm94TW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCkge1xuICAgICAgICAgICAgenJVdGlsLmVhY2godGhpcy5fZmVhdHVyZXMsIGZ1bmN0aW9uIChmZWF0dXJlKSB7XG4gICAgICAgICAgICAgICAgZmVhdHVyZS51cGRhdGVWaWV3ICYmIGZlYXR1cmUudXBkYXRlVmlldyhmZWF0dXJlLm1vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdXBkYXRlTGF5b3V0OiBmdW5jdGlvbiAodG9vbGJveE1vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpIHtcbiAgICAgICAgICAgIHpyVXRpbC5lYWNoKHRoaXMuX2ZlYXR1cmVzLCBmdW5jdGlvbiAoZmVhdHVyZSkge1xuICAgICAgICAgICAgICAgIGZlYXR1cmUudXBkYXRlTGF5b3V0ICYmIGZlYXR1cmUudXBkYXRlTGF5b3V0KGZlYXR1cmUubW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHtcbiAgICAgICAgICAgIHpyVXRpbC5lYWNoKHRoaXMuX2ZlYXR1cmVzLCBmdW5jdGlvbiAoZmVhdHVyZSkge1xuICAgICAgICAgICAgICAgIGZlYXR1cmUucmVtb3ZlICYmIGZlYXR1cmUucmVtb3ZlKGVjTW9kZWwsIGFwaSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXAucmVtb3ZlQWxsKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGlzcG9zZTogZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICAgICAgICAgICAgenJVdGlsLmVhY2godGhpcy5fZmVhdHVyZXMsIGZ1bmN0aW9uIChmZWF0dXJlKSB7XG4gICAgICAgICAgICAgICAgZmVhdHVyZS5kaXNwb3NlICYmIGZlYXR1cmUuZGlzcG9zZShlY01vZGVsLCBhcGkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGlzVXNlckZlYXR1cmVOYW1lKGZlYXR1cmVOYW1lKSB7XG4gICAgICAgIHJldHVybiBmZWF0dXJlTmFtZS5pbmRleE9mKCdteScpID09PSAwO1xuICAgIH1cblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvY29tcG9uZW50L3Rvb2xib3gvVG9vbGJveFZpZXcuanNcbi8vIG1vZHVsZSBpZCA9IDIyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 230 */
/* unknown exports provided */
/* all exports used */
/*!***************************************************!*\
  !*** ./lib/component/toolbox/feature/DataView.js ***!
  \***************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * @module echarts/component/toolbox/feature/DataView\n */\n\n\n\n    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 0);\n    var eventTool = __webpack_require__(/*! zrender/lib/core/event */ 20);\n\n\n    var BLOCK_SPLITER = new Array(60).join('-');\n    var ITEM_SPLITER = '\\t';\n    /**\n     * Group series into two types\n     *  1. on category axis, like line, bar\n     *  2. others, like scatter, pie\n     * @param {module:echarts/model/Global} ecModel\n     * @return {Object}\n     * @inner\n     */\n    function groupSeries(ecModel) {\n        var seriesGroupByCategoryAxis = {};\n        var otherSeries = [];\n        var meta = [];\n        ecModel.eachRawSeries(function (seriesModel) {\n            var coordSys = seriesModel.coordinateSystem;\n\n            if (coordSys && (coordSys.type === 'cartesian2d' || coordSys.type === 'polar')) {\n                var baseAxis = coordSys.getBaseAxis();\n                if (baseAxis.type === 'category') {\n                    var key = baseAxis.dim + '_' + baseAxis.index;\n                    if (!seriesGroupByCategoryAxis[key]) {\n                        seriesGroupByCategoryAxis[key] = {\n                            categoryAxis: baseAxis,\n                            valueAxis: coordSys.getOtherAxis(baseAxis),\n                            series: []\n                        };\n                        meta.push({\n                            axisDim: baseAxis.dim,\n                            axisIndex: baseAxis.index\n                        });\n                    }\n                    seriesGroupByCategoryAxis[key].series.push(seriesModel);\n                }\n                else {\n                    otherSeries.push(seriesModel);\n                }\n            }\n            else {\n                otherSeries.push(seriesModel);\n            }\n        });\n\n        return {\n            seriesGroupByCategoryAxis: seriesGroupByCategoryAxis,\n            other: otherSeries,\n            meta: meta\n        };\n    }\n\n    /**\n     * Assemble content of series on cateogory axis\n     * @param {Array.<module:echarts/model/Series>} series\n     * @return {string}\n     * @inner\n     */\n    function assembleSeriesWithCategoryAxis(series) {\n        var tables = [];\n        zrUtil.each(series, function (group, key) {\n            var categoryAxis = group.categoryAxis;\n            var valueAxis = group.valueAxis;\n            var valueAxisDim = valueAxis.dim;\n\n            var headers = [' '].concat(zrUtil.map(group.series, function (series) {\n                return series.name;\n            }));\n            var columns = [categoryAxis.model.getCategories()];\n            zrUtil.each(group.series, function (series) {\n                columns.push(series.getRawData().mapArray(valueAxisDim, function (val) {\n                    return val;\n                }));\n            });\n            // Assemble table content\n            var lines = [headers.join(ITEM_SPLITER)];\n            for (var i = 0; i < columns[0].length; i++) {\n                var items = [];\n                for (var j = 0; j < columns.length; j++) {\n                    items.push(columns[j][i]);\n                }\n                lines.push(items.join(ITEM_SPLITER));\n            }\n            tables.push(lines.join('\\n'));\n        });\n        return tables.join('\\n\\n' +  BLOCK_SPLITER + '\\n\\n');\n    }\n\n    /**\n     * Assemble content of other series\n     * @param {Array.<module:echarts/model/Series>} series\n     * @return {string}\n     * @inner\n     */\n    function assembleOtherSeries(series) {\n        return zrUtil.map(series, function (series) {\n            var data = series.getRawData();\n            var lines = [series.name];\n            var vals = [];\n            data.each(data.dimensions, function () {\n                var argLen = arguments.length;\n                var dataIndex = arguments[argLen - 1];\n                var name = data.getName(dataIndex);\n                for (var i = 0; i < argLen - 1; i++) {\n                    vals[i] = arguments[i];\n                }\n                lines.push((name ? (name + ITEM_SPLITER) : '') + vals.join(ITEM_SPLITER));\n            });\n            return lines.join('\\n');\n        }).join('\\n\\n' + BLOCK_SPLITER + '\\n\\n');\n    }\n\n    /**\n     * @param {module:echarts/model/Global}\n     * @return {string}\n     * @inner\n     */\n    function getContentFromModel(ecModel) {\n\n        var result = groupSeries(ecModel);\n\n        return {\n            value: zrUtil.filter([\n                    assembleSeriesWithCategoryAxis(result.seriesGroupByCategoryAxis),\n                    assembleOtherSeries(result.other)\n                ], function (str) {\n                    return str.replace(/[\\n\\t\\s]/g, '');\n                }).join('\\n\\n' + BLOCK_SPLITER + '\\n\\n'),\n\n            meta: result.meta\n        };\n    }\n\n\n    function trim(str) {\n        return str.replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, '');\n    }\n    /**\n     * If a block is tsv format\n     */\n    function isTSVFormat(block) {\n        // Simple method to find out if a block is tsv format\n        var firstLine = block.slice(0, block.indexOf('\\n'));\n        if (firstLine.indexOf(ITEM_SPLITER) >= 0) {\n            return true;\n        }\n    }\n\n    var itemSplitRegex = new RegExp('[' + ITEM_SPLITER + ']+', 'g');\n    /**\n     * @param {string} tsv\n     * @return {Array.<Object>}\n     */\n    function parseTSVContents(tsv) {\n        var tsvLines = tsv.split(/\\n+/g);\n        var headers = trim(tsvLines.shift()).split(itemSplitRegex);\n\n        var categories = [];\n        var series = zrUtil.map(headers, function (header) {\n            return {\n                name: header,\n                data: []\n            };\n        });\n        for (var i = 0; i < tsvLines.length; i++) {\n            var items = trim(tsvLines[i]).split(itemSplitRegex);\n            categories.push(items.shift());\n            for (var j = 0; j < items.length; j++) {\n                series[j] && (series[j].data[i] = items[j]);\n            }\n        }\n        return {\n            series: series,\n            categories: categories\n        };\n    }\n\n    /**\n     * @param {string} str\n     * @return {Array.<Object>}\n     * @inner\n     */\n    function parseListContents(str) {\n        var lines = str.split(/\\n+/g);\n        var seriesName = trim(lines.shift());\n\n        var data = [];\n        for (var i = 0; i < lines.length; i++) {\n            var items = trim(lines[i]).split(itemSplitRegex);\n            var name = '';\n            var value;\n            var hasName = false;\n            if (isNaN(items[0])) { // First item is name\n                hasName = true;\n                name = items[0];\n                items = items.slice(1);\n                data[i] = {\n                    name: name,\n                    value: []\n                };\n                value = data[i].value;\n            }\n            else {\n                value = data[i] = [];\n            }\n            for (var j = 0; j < items.length; j++) {\n                value.push(+items[j]);\n            }\n            if (value.length === 1) {\n                hasName ? (data[i].value = value[0]) : (data[i] = value[0]);\n            }\n        }\n\n        return {\n            name: seriesName,\n            data: data\n        };\n    }\n\n    /**\n     * @param {string} str\n     * @param {Array.<Object>} blockMetaList\n     * @return {Object}\n     * @inner\n     */\n    function parseContents(str, blockMetaList) {\n        var blocks = str.split(new RegExp('\\n*' + BLOCK_SPLITER + '\\n*', 'g'));\n        var newOption = {\n            series: []\n        };\n        zrUtil.each(blocks, function (block, idx) {\n            if (isTSVFormat(block)) {\n                var result = parseTSVContents(block);\n                var blockMeta = blockMetaList[idx];\n                var axisKey = blockMeta.axisDim + 'Axis';\n\n                if (blockMeta) {\n                    newOption[axisKey] = newOption[axisKey] || [];\n                    newOption[axisKey][blockMeta.axisIndex] = {\n                        data: result.categories\n                    };\n                    newOption.series = newOption.series.concat(result.series);\n                }\n            }\n            else {\n                var result = parseListContents(block);\n                newOption.series.push(result);\n            }\n        });\n        return newOption;\n    }\n\n    /**\n     * @alias {module:echarts/component/toolbox/feature/DataView}\n     * @constructor\n     * @param {module:echarts/model/Model} model\n     */\n    function DataView(model) {\n\n        this._dom = null;\n\n        this.model = model;\n    }\n\n    DataView.defaultOption = {\n        show: true,\n        readOnly: false,\n        optionToContent: null,\n        contentToOption: null,\n\n        icon: 'M17.5,17.3H33 M17.5,17.3H33 M45.4,29.5h-28 M11.5,2v56H51V14.8L38.4,2H11.5z M38.4,2.2v12.7H51 M45.4,41.7h-28',\n        title: '数据视图',\n        lang: ['数据视图', '关闭', '刷新'],\n        backgroundColor: '#fff',\n        textColor: '#000',\n        textareaColor: '#fff',\n        textareaBorderColor: '#333',\n        buttonColor: '#c23531',\n        buttonTextColor: '#fff'\n    };\n\n    DataView.prototype.onclick = function (ecModel, api) {\n        var container = api.getDom();\n        var model = this.model;\n        if (this._dom) {\n            container.removeChild(this._dom);\n        }\n        var root = document.createElement('div');\n        root.style.cssText = 'position:absolute;left:5px;top:5px;bottom:5px;right:5px;';\n        root.style.backgroundColor = model.get('backgroundColor') || '#fff';\n\n        // Create elements\n        var header = document.createElement('h4');\n        var lang = model.get('lang') || [];\n        header.innerHTML = lang[0] || model.get('title');\n        header.style.cssText = 'margin: 10px 20px;';\n        header.style.color = model.get('textColor');\n\n        var viewMain = document.createElement('div');\n        var textarea = document.createElement('textarea');\n        viewMain.style.cssText = 'display:block;width:100%;overflow:auto;';\n\n        var optionToContent = model.get('optionToContent');\n        var contentToOption = model.get('contentToOption');\n        var result = getContentFromModel(ecModel);\n        if (typeof optionToContent === 'function') {\n            var htmlOrDom = optionToContent(api.getOption());\n            if (typeof htmlOrDom === 'string') {\n                viewMain.innerHTML = htmlOrDom;\n            }\n            else if (zrUtil.isDom(htmlOrDom)) {\n                viewMain.appendChild(htmlOrDom);\n            }\n        }\n        else {\n            // Use default textarea\n            viewMain.appendChild(textarea);\n            textarea.readOnly = model.get('readOnly');\n            textarea.style.cssText = 'width:100%;height:100%;font-family:monospace;font-size:14px;line-height:1.6rem;';\n            textarea.style.color = model.get('textColor');\n            textarea.style.borderColor = model.get('textareaBorderColor');\n            textarea.style.backgroundColor = model.get('textareaColor');\n            textarea.value = result.value;\n        }\n\n        var blockMetaList = result.meta;\n\n        var buttonContainer = document.createElement('div');\n        buttonContainer.style.cssText = 'position:absolute;bottom:0;left:0;right:0;';\n\n        var buttonStyle = 'float:right;margin-right:20px;border:none;'\n            + 'cursor:pointer;padding:2px 5px;font-size:12px;border-radius:3px';\n        var closeButton = document.createElement('div');\n        var refreshButton = document.createElement('div');\n\n        buttonStyle += ';background-color:' + model.get('buttonColor');\n        buttonStyle += ';color:' + model.get('buttonTextColor');\n\n        var self = this;\n\n        function close() {\n            container.removeChild(root);\n            self._dom = null;\n        }\n        eventTool.addEventListener(closeButton, 'click', close);\n\n        eventTool.addEventListener(refreshButton, 'click', function () {\n            var newOption;\n            try {\n                if (typeof contentToOption === 'function') {\n                    newOption = contentToOption(viewMain, api.getOption());\n                }\n                else {\n                    newOption = parseContents(textarea.value, blockMetaList);\n                }\n            }\n            catch (e) {\n                close();\n                throw new Error('Data view format error ' + e);\n            }\n            if (newOption) {\n                api.dispatchAction({\n                    type: 'changeDataView',\n                    newOption: newOption\n                });\n            }\n\n            close();\n        });\n\n        closeButton.innerHTML = lang[1];\n        refreshButton.innerHTML = lang[2];\n        refreshButton.style.cssText = buttonStyle;\n        closeButton.style.cssText = buttonStyle;\n\n        !model.get('readOnly') && buttonContainer.appendChild(refreshButton);\n        buttonContainer.appendChild(closeButton);\n\n        // http://stackoverflow.com/questions/6637341/use-tab-to-indent-in-textarea\n        eventTool.addEventListener(textarea, 'keydown', function (e) {\n            if ((e.keyCode || e.which) === 9) {\n                // get caret position/selection\n                var val = this.value;\n                var start = this.selectionStart;\n                var end = this.selectionEnd;\n\n                // set textarea value to: text before caret + tab + text after caret\n                this.value = val.substring(0, start) + ITEM_SPLITER + val.substring(end);\n\n                // put caret at right position again\n                this.selectionStart = this.selectionEnd = start + 1;\n\n                // prevent the focus lose\n                eventTool.stop(e);\n            }\n        });\n\n        root.appendChild(header);\n        root.appendChild(viewMain);\n        root.appendChild(buttonContainer);\n\n        viewMain.style.height = (container.clientHeight - 80) + 'px';\n\n        container.appendChild(root);\n        this._dom = root;\n    };\n\n    DataView.prototype.remove = function (ecModel, api) {\n        this._dom && api.getDom().removeChild(this._dom);\n    };\n\n    DataView.prototype.dispose = function (ecModel, api) {\n        this.remove(ecModel, api);\n    };\n\n    /**\n     * @inner\n     */\n    function tryMergeDataOption(newData, originalData) {\n        return zrUtil.map(newData, function (newVal, idx) {\n            var original = originalData && originalData[idx];\n            if (zrUtil.isObject(original) && !zrUtil.isArray(original)) {\n                if (zrUtil.isObject(newVal) && !zrUtil.isArray(newVal)) {\n                    newVal = newVal.value;\n                }\n                // Original data has option\n                return zrUtil.defaults({\n                    value: newVal\n                }, original);\n            }\n            else {\n                return newVal;\n            }\n        });\n    }\n\n    __webpack_require__(/*! ../featureManager */ 28).register('dataView', DataView);\n\n    __webpack_require__(/*! ../../../echarts */ 1).registerAction({\n        type: 'changeDataView',\n        event: 'dataViewChanged',\n        update: 'prepareAndUpdate'\n    }, function (payload, ecModel) {\n        var newSeriesOptList = [];\n        zrUtil.each(payload.newOption.series, function (seriesOpt) {\n            var seriesModel = ecModel.getSeriesByName(seriesOpt.name)[0];\n            if (!seriesModel) {\n                // New created series\n                // Geuss the series type\n                newSeriesOptList.push(zrUtil.extend({\n                    // Default is scatter\n                    type: 'scatter'\n                }, seriesOpt));\n            }\n            else {\n                var originalData = seriesModel.get('data');\n                newSeriesOptList.push({\n                    name: seriesOpt.name,\n                    data: tryMergeDataOption(seriesOpt.data, originalData)\n                });\n            }\n        });\n\n        ecModel.mergeOption(zrUtil.defaults({\n            series: newSeriesOptList\n        }, payload.newOption));\n    });\n\n    module.exports = DataView;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjMwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2NvbXBvbmVudC90b29sYm94L2ZlYXR1cmUvRGF0YVZpZXcuanM/ZjFkZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgZWNoYXJ0cy9jb21wb25lbnQvdG9vbGJveC9mZWF0dXJlL0RhdGFWaWV3XG4gKi9cblxuXG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG4gICAgdmFyIGV2ZW50VG9vbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvZXZlbnQnKTtcblxuXG4gICAgdmFyIEJMT0NLX1NQTElURVIgPSBuZXcgQXJyYXkoNjApLmpvaW4oJy0nKTtcbiAgICB2YXIgSVRFTV9TUExJVEVSID0gJ1xcdCc7XG4gICAgLyoqXG4gICAgICogR3JvdXAgc2VyaWVzIGludG8gdHdvIHR5cGVzXG4gICAgICogIDEuIG9uIGNhdGVnb3J5IGF4aXMsIGxpa2UgbGluZSwgYmFyXG4gICAgICogIDIuIG90aGVycywgbGlrZSBzY2F0dGVyLCBwaWVcbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL0dsb2JhbH0gZWNNb2RlbFxuICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBncm91cFNlcmllcyhlY01vZGVsKSB7XG4gICAgICAgIHZhciBzZXJpZXNHcm91cEJ5Q2F0ZWdvcnlBeGlzID0ge307XG4gICAgICAgIHZhciBvdGhlclNlcmllcyA9IFtdO1xuICAgICAgICB2YXIgbWV0YSA9IFtdO1xuICAgICAgICBlY01vZGVsLmVhY2hSYXdTZXJpZXMoZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICAgICAgICB2YXIgY29vcmRTeXMgPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuXG4gICAgICAgICAgICBpZiAoY29vcmRTeXMgJiYgKGNvb3JkU3lzLnR5cGUgPT09ICdjYXJ0ZXNpYW4yZCcgfHwgY29vcmRTeXMudHlwZSA9PT0gJ3BvbGFyJykpIHtcbiAgICAgICAgICAgICAgICB2YXIgYmFzZUF4aXMgPSBjb29yZFN5cy5nZXRCYXNlQXhpcygpO1xuICAgICAgICAgICAgICAgIGlmIChiYXNlQXhpcy50eXBlID09PSAnY2F0ZWdvcnknKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBiYXNlQXhpcy5kaW0gKyAnXycgKyBiYXNlQXhpcy5pbmRleDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzZXJpZXNHcm91cEJ5Q2F0ZWdvcnlBeGlzW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllc0dyb3VwQnlDYXRlZ29yeUF4aXNba2V5XSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRlZ29yeUF4aXM6IGJhc2VBeGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlQXhpczogY29vcmRTeXMuZ2V0T3RoZXJBeGlzKGJhc2VBeGlzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXM6IFtdXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0YS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBheGlzRGltOiBiYXNlQXhpcy5kaW0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXhpc0luZGV4OiBiYXNlQXhpcy5pbmRleFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2VyaWVzR3JvdXBCeUNhdGVnb3J5QXhpc1trZXldLnNlcmllcy5wdXNoKHNlcmllc01vZGVsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG90aGVyU2VyaWVzLnB1c2goc2VyaWVzTW9kZWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG90aGVyU2VyaWVzLnB1c2goc2VyaWVzTW9kZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2VyaWVzR3JvdXBCeUNhdGVnb3J5QXhpczogc2VyaWVzR3JvdXBCeUNhdGVnb3J5QXhpcyxcbiAgICAgICAgICAgIG90aGVyOiBvdGhlclNlcmllcyxcbiAgICAgICAgICAgIG1ldGE6IG1ldGFcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBc3NlbWJsZSBjb250ZW50IG9mIHNlcmllcyBvbiBjYXRlb2dvcnkgYXhpc1xuICAgICAqIEBwYXJhbSB7QXJyYXkuPG1vZHVsZTplY2hhcnRzL21vZGVsL1Nlcmllcz59IHNlcmllc1xuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhc3NlbWJsZVNlcmllc1dpdGhDYXRlZ29yeUF4aXMoc2VyaWVzKSB7XG4gICAgICAgIHZhciB0YWJsZXMgPSBbXTtcbiAgICAgICAgenJVdGlsLmVhY2goc2VyaWVzLCBmdW5jdGlvbiAoZ3JvdXAsIGtleSkge1xuICAgICAgICAgICAgdmFyIGNhdGVnb3J5QXhpcyA9IGdyb3VwLmNhdGVnb3J5QXhpcztcbiAgICAgICAgICAgIHZhciB2YWx1ZUF4aXMgPSBncm91cC52YWx1ZUF4aXM7XG4gICAgICAgICAgICB2YXIgdmFsdWVBeGlzRGltID0gdmFsdWVBeGlzLmRpbTtcblxuICAgICAgICAgICAgdmFyIGhlYWRlcnMgPSBbJyAnXS5jb25jYXQoenJVdGlsLm1hcChncm91cC5zZXJpZXMsIGZ1bmN0aW9uIChzZXJpZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VyaWVzLm5hbWU7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB2YXIgY29sdW1ucyA9IFtjYXRlZ29yeUF4aXMubW9kZWwuZ2V0Q2F0ZWdvcmllcygpXTtcbiAgICAgICAgICAgIHpyVXRpbC5lYWNoKGdyb3VwLnNlcmllcywgZnVuY3Rpb24gKHNlcmllcykge1xuICAgICAgICAgICAgICAgIGNvbHVtbnMucHVzaChzZXJpZXMuZ2V0UmF3RGF0YSgpLm1hcEFycmF5KHZhbHVlQXhpc0RpbSwgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gQXNzZW1ibGUgdGFibGUgY29udGVudFxuICAgICAgICAgICAgdmFyIGxpbmVzID0gW2hlYWRlcnMuam9pbihJVEVNX1NQTElURVIpXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sdW1uc1swXS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBpdGVtcyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY29sdW1ucy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpdGVtcy5wdXNoKGNvbHVtbnNbal1baV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKGl0ZW1zLmpvaW4oSVRFTV9TUExJVEVSKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YWJsZXMucHVzaChsaW5lcy5qb2luKCdcXG4nKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGFibGVzLmpvaW4oJ1xcblxcbicgKyAgQkxPQ0tfU1BMSVRFUiArICdcXG5cXG4nKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBc3NlbWJsZSBjb250ZW50IG9mIG90aGVyIHNlcmllc1xuICAgICAqIEBwYXJhbSB7QXJyYXkuPG1vZHVsZTplY2hhcnRzL21vZGVsL1Nlcmllcz59IHNlcmllc1xuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhc3NlbWJsZU90aGVyU2VyaWVzKHNlcmllcykge1xuICAgICAgICByZXR1cm4genJVdGlsLm1hcChzZXJpZXMsIGZ1bmN0aW9uIChzZXJpZXMpIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0gc2VyaWVzLmdldFJhd0RhdGEoKTtcbiAgICAgICAgICAgIHZhciBsaW5lcyA9IFtzZXJpZXMubmFtZV07XG4gICAgICAgICAgICB2YXIgdmFscyA9IFtdO1xuICAgICAgICAgICAgZGF0YS5lYWNoKGRhdGEuZGltZW5zaW9ucywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBhcmdMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHZhciBkYXRhSW5kZXggPSBhcmd1bWVudHNbYXJnTGVuIC0gMV07XG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBkYXRhLmdldE5hbWUoZGF0YUluZGV4KTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ0xlbiAtIDE7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YWxzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKChuYW1lID8gKG5hbWUgKyBJVEVNX1NQTElURVIpIDogJycpICsgdmFscy5qb2luKElURU1fU1BMSVRFUikpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gbGluZXMuam9pbignXFxuJyk7XG4gICAgICAgIH0pLmpvaW4oJ1xcblxcbicgKyBCTE9DS19TUExJVEVSICsgJ1xcblxcbicpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvR2xvYmFsfVxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRDb250ZW50RnJvbU1vZGVsKGVjTW9kZWwpIHtcblxuICAgICAgICB2YXIgcmVzdWx0ID0gZ3JvdXBTZXJpZXMoZWNNb2RlbCk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiB6clV0aWwuZmlsdGVyKFtcbiAgICAgICAgICAgICAgICAgICAgYXNzZW1ibGVTZXJpZXNXaXRoQ2F0ZWdvcnlBeGlzKHJlc3VsdC5zZXJpZXNHcm91cEJ5Q2F0ZWdvcnlBeGlzKSxcbiAgICAgICAgICAgICAgICAgICAgYXNzZW1ibGVPdGhlclNlcmllcyhyZXN1bHQub3RoZXIpXG4gICAgICAgICAgICAgICAgXSwgZnVuY3Rpb24gKHN0cikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoL1tcXG5cXHRcXHNdL2csICcnKTtcbiAgICAgICAgICAgICAgICB9KS5qb2luKCdcXG5cXG4nICsgQkxPQ0tfU1BMSVRFUiArICdcXG5cXG4nKSxcblxuICAgICAgICAgICAgbWV0YTogcmVzdWx0Lm1ldGFcbiAgICAgICAgfTtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIHRyaW0oc3RyKSB7XG4gICAgICAgIHJldHVybiBzdHIucmVwbGFjZSgvXlxcc1xccyovLCAnJykucmVwbGFjZSgvXFxzXFxzKiQvLCAnJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIGEgYmxvY2sgaXMgdHN2IGZvcm1hdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzVFNWRm9ybWF0KGJsb2NrKSB7XG4gICAgICAgIC8vIFNpbXBsZSBtZXRob2QgdG8gZmluZCBvdXQgaWYgYSBibG9jayBpcyB0c3YgZm9ybWF0XG4gICAgICAgIHZhciBmaXJzdExpbmUgPSBibG9jay5zbGljZSgwLCBibG9jay5pbmRleE9mKCdcXG4nKSk7XG4gICAgICAgIGlmIChmaXJzdExpbmUuaW5kZXhPZihJVEVNX1NQTElURVIpID49IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGl0ZW1TcGxpdFJlZ2V4ID0gbmV3IFJlZ0V4cCgnWycgKyBJVEVNX1NQTElURVIgKyAnXSsnLCAnZycpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0c3ZcbiAgICAgKiBAcmV0dXJuIHtBcnJheS48T2JqZWN0Pn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYXJzZVRTVkNvbnRlbnRzKHRzdikge1xuICAgICAgICB2YXIgdHN2TGluZXMgPSB0c3Yuc3BsaXQoL1xcbisvZyk7XG4gICAgICAgIHZhciBoZWFkZXJzID0gdHJpbSh0c3ZMaW5lcy5zaGlmdCgpKS5zcGxpdChpdGVtU3BsaXRSZWdleCk7XG5cbiAgICAgICAgdmFyIGNhdGVnb3JpZXMgPSBbXTtcbiAgICAgICAgdmFyIHNlcmllcyA9IHpyVXRpbC5tYXAoaGVhZGVycywgZnVuY3Rpb24gKGhlYWRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBoZWFkZXIsXG4gICAgICAgICAgICAgICAgZGF0YTogW11cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRzdkxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgaXRlbXMgPSB0cmltKHRzdkxpbmVzW2ldKS5zcGxpdChpdGVtU3BsaXRSZWdleCk7XG4gICAgICAgICAgICBjYXRlZ29yaWVzLnB1c2goaXRlbXMuc2hpZnQoKSk7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGl0ZW1zLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgc2VyaWVzW2pdICYmIChzZXJpZXNbal0uZGF0YVtpXSA9IGl0ZW1zW2pdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2VyaWVzOiBzZXJpZXMsXG4gICAgICAgICAgICBjYXRlZ29yaWVzOiBjYXRlZ29yaWVzXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICAgICAqIEByZXR1cm4ge0FycmF5LjxPYmplY3Q+fVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhcnNlTGlzdENvbnRlbnRzKHN0cikge1xuICAgICAgICB2YXIgbGluZXMgPSBzdHIuc3BsaXQoL1xcbisvZyk7XG4gICAgICAgIHZhciBzZXJpZXNOYW1lID0gdHJpbShsaW5lcy5zaGlmdCgpKTtcblxuICAgICAgICB2YXIgZGF0YSA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgaXRlbXMgPSB0cmltKGxpbmVzW2ldKS5zcGxpdChpdGVtU3BsaXRSZWdleCk7XG4gICAgICAgICAgICB2YXIgbmFtZSA9ICcnO1xuICAgICAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICAgICAgdmFyIGhhc05hbWUgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChpc05hTihpdGVtc1swXSkpIHsgLy8gRmlyc3QgaXRlbSBpcyBuYW1lXG4gICAgICAgICAgICAgICAgaGFzTmFtZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgbmFtZSA9IGl0ZW1zWzBdO1xuICAgICAgICAgICAgICAgIGl0ZW1zID0gaXRlbXMuc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgZGF0YVtpXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGRhdGFbaV0udmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGRhdGFbaV0gPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaXRlbXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICB2YWx1ZS5wdXNoKCtpdGVtc1tqXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgaGFzTmFtZSA/IChkYXRhW2ldLnZhbHVlID0gdmFsdWVbMF0pIDogKGRhdGFbaV0gPSB2YWx1ZVswXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZTogc2VyaWVzTmFtZSxcbiAgICAgICAgICAgIGRhdGE6IGRhdGFcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gICAgICogQHBhcmFtIHtBcnJheS48T2JqZWN0Pn0gYmxvY2tNZXRhTGlzdFxuICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYXJzZUNvbnRlbnRzKHN0ciwgYmxvY2tNZXRhTGlzdCkge1xuICAgICAgICB2YXIgYmxvY2tzID0gc3RyLnNwbGl0KG5ldyBSZWdFeHAoJ1xcbionICsgQkxPQ0tfU1BMSVRFUiArICdcXG4qJywgJ2cnKSk7XG4gICAgICAgIHZhciBuZXdPcHRpb24gPSB7XG4gICAgICAgICAgICBzZXJpZXM6IFtdXG4gICAgICAgIH07XG4gICAgICAgIHpyVXRpbC5lYWNoKGJsb2NrcywgZnVuY3Rpb24gKGJsb2NrLCBpZHgpIHtcbiAgICAgICAgICAgIGlmIChpc1RTVkZvcm1hdChibG9jaykpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gcGFyc2VUU1ZDb250ZW50cyhibG9jayk7XG4gICAgICAgICAgICAgICAgdmFyIGJsb2NrTWV0YSA9IGJsb2NrTWV0YUxpc3RbaWR4XTtcbiAgICAgICAgICAgICAgICB2YXIgYXhpc0tleSA9IGJsb2NrTWV0YS5heGlzRGltICsgJ0F4aXMnO1xuXG4gICAgICAgICAgICAgICAgaWYgKGJsb2NrTWV0YSkge1xuICAgICAgICAgICAgICAgICAgICBuZXdPcHRpb25bYXhpc0tleV0gPSBuZXdPcHRpb25bYXhpc0tleV0gfHwgW107XG4gICAgICAgICAgICAgICAgICAgIG5ld09wdGlvbltheGlzS2V5XVtibG9ja01ldGEuYXhpc0luZGV4XSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHJlc3VsdC5jYXRlZ29yaWVzXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIG5ld09wdGlvbi5zZXJpZXMgPSBuZXdPcHRpb24uc2VyaWVzLmNvbmNhdChyZXN1bHQuc2VyaWVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gcGFyc2VMaXN0Q29udGVudHMoYmxvY2spO1xuICAgICAgICAgICAgICAgIG5ld09wdGlvbi5zZXJpZXMucHVzaChyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ld09wdGlvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAYWxpYXMge21vZHVsZTplY2hhcnRzL2NvbXBvbmVudC90b29sYm94L2ZlYXR1cmUvRGF0YVZpZXd9XG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH0gbW9kZWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBEYXRhVmlldyhtb2RlbCkge1xuXG4gICAgICAgIHRoaXMuX2RvbSA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5tb2RlbCA9IG1vZGVsO1xuICAgIH1cblxuICAgIERhdGFWaWV3LmRlZmF1bHRPcHRpb24gPSB7XG4gICAgICAgIHNob3c6IHRydWUsXG4gICAgICAgIHJlYWRPbmx5OiBmYWxzZSxcbiAgICAgICAgb3B0aW9uVG9Db250ZW50OiBudWxsLFxuICAgICAgICBjb250ZW50VG9PcHRpb246IG51bGwsXG5cbiAgICAgICAgaWNvbjogJ00xNy41LDE3LjNIMzMgTTE3LjUsMTcuM0gzMyBNNDUuNCwyOS41aC0yOCBNMTEuNSwydjU2SDUxVjE0LjhMMzguNCwySDExLjV6IE0zOC40LDIuMnYxMi43SDUxIE00NS40LDQxLjdoLTI4JyxcbiAgICAgICAgdGl0bGU6ICfmlbDmja7op4blm74nLFxuICAgICAgICBsYW5nOiBbJ+aVsOaNruinhuWbvicsICflhbPpl60nLCAn5Yi35pawJ10sXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogJyNmZmYnLFxuICAgICAgICB0ZXh0Q29sb3I6ICcjMDAwJyxcbiAgICAgICAgdGV4dGFyZWFDb2xvcjogJyNmZmYnLFxuICAgICAgICB0ZXh0YXJlYUJvcmRlckNvbG9yOiAnIzMzMycsXG4gICAgICAgIGJ1dHRvbkNvbG9yOiAnI2MyMzUzMScsXG4gICAgICAgIGJ1dHRvblRleHRDb2xvcjogJyNmZmYnXG4gICAgfTtcblxuICAgIERhdGFWaWV3LnByb3RvdHlwZS5vbmNsaWNrID0gZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICAgICAgICB2YXIgY29udGFpbmVyID0gYXBpLmdldERvbSgpO1xuICAgICAgICB2YXIgbW9kZWwgPSB0aGlzLm1vZGVsO1xuICAgICAgICBpZiAodGhpcy5fZG9tKSB7XG4gICAgICAgICAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQodGhpcy5fZG9tKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcm9vdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICByb290LnN0eWxlLmNzc1RleHQgPSAncG9zaXRpb246YWJzb2x1dGU7bGVmdDo1cHg7dG9wOjVweDtib3R0b206NXB4O3JpZ2h0OjVweDsnO1xuICAgICAgICByb290LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IG1vZGVsLmdldCgnYmFja2dyb3VuZENvbG9yJykgfHwgJyNmZmYnO1xuXG4gICAgICAgIC8vIENyZWF0ZSBlbGVtZW50c1xuICAgICAgICB2YXIgaGVhZGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaDQnKTtcbiAgICAgICAgdmFyIGxhbmcgPSBtb2RlbC5nZXQoJ2xhbmcnKSB8fCBbXTtcbiAgICAgICAgaGVhZGVyLmlubmVySFRNTCA9IGxhbmdbMF0gfHwgbW9kZWwuZ2V0KCd0aXRsZScpO1xuICAgICAgICBoZWFkZXIuc3R5bGUuY3NzVGV4dCA9ICdtYXJnaW46IDEwcHggMjBweDsnO1xuICAgICAgICBoZWFkZXIuc3R5bGUuY29sb3IgPSBtb2RlbC5nZXQoJ3RleHRDb2xvcicpO1xuXG4gICAgICAgIHZhciB2aWV3TWFpbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB2YXIgdGV4dGFyZWEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZXh0YXJlYScpO1xuICAgICAgICB2aWV3TWFpbi5zdHlsZS5jc3NUZXh0ID0gJ2Rpc3BsYXk6YmxvY2s7d2lkdGg6MTAwJTtvdmVyZmxvdzphdXRvOyc7XG5cbiAgICAgICAgdmFyIG9wdGlvblRvQ29udGVudCA9IG1vZGVsLmdldCgnb3B0aW9uVG9Db250ZW50Jyk7XG4gICAgICAgIHZhciBjb250ZW50VG9PcHRpb24gPSBtb2RlbC5nZXQoJ2NvbnRlbnRUb09wdGlvbicpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gZ2V0Q29udGVudEZyb21Nb2RlbChlY01vZGVsKTtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25Ub0NvbnRlbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhciBodG1sT3JEb20gPSBvcHRpb25Ub0NvbnRlbnQoYXBpLmdldE9wdGlvbigpKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaHRtbE9yRG9tID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHZpZXdNYWluLmlubmVySFRNTCA9IGh0bWxPckRvbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHpyVXRpbC5pc0RvbShodG1sT3JEb20pKSB7XG4gICAgICAgICAgICAgICAgdmlld01haW4uYXBwZW5kQ2hpbGQoaHRtbE9yRG9tKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFVzZSBkZWZhdWx0IHRleHRhcmVhXG4gICAgICAgICAgICB2aWV3TWFpbi5hcHBlbmRDaGlsZCh0ZXh0YXJlYSk7XG4gICAgICAgICAgICB0ZXh0YXJlYS5yZWFkT25seSA9IG1vZGVsLmdldCgncmVhZE9ubHknKTtcbiAgICAgICAgICAgIHRleHRhcmVhLnN0eWxlLmNzc1RleHQgPSAnd2lkdGg6MTAwJTtoZWlnaHQ6MTAwJTtmb250LWZhbWlseTptb25vc3BhY2U7Zm9udC1zaXplOjE0cHg7bGluZS1oZWlnaHQ6MS42cmVtOyc7XG4gICAgICAgICAgICB0ZXh0YXJlYS5zdHlsZS5jb2xvciA9IG1vZGVsLmdldCgndGV4dENvbG9yJyk7XG4gICAgICAgICAgICB0ZXh0YXJlYS5zdHlsZS5ib3JkZXJDb2xvciA9IG1vZGVsLmdldCgndGV4dGFyZWFCb3JkZXJDb2xvcicpO1xuICAgICAgICAgICAgdGV4dGFyZWEuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gbW9kZWwuZ2V0KCd0ZXh0YXJlYUNvbG9yJyk7XG4gICAgICAgICAgICB0ZXh0YXJlYS52YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBibG9ja01ldGFMaXN0ID0gcmVzdWx0Lm1ldGE7XG5cbiAgICAgICAgdmFyIGJ1dHRvbkNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBidXR0b25Db250YWluZXIuc3R5bGUuY3NzVGV4dCA9ICdwb3NpdGlvbjphYnNvbHV0ZTtib3R0b206MDtsZWZ0OjA7cmlnaHQ6MDsnO1xuXG4gICAgICAgIHZhciBidXR0b25TdHlsZSA9ICdmbG9hdDpyaWdodDttYXJnaW4tcmlnaHQ6MjBweDtib3JkZXI6bm9uZTsnXG4gICAgICAgICAgICArICdjdXJzb3I6cG9pbnRlcjtwYWRkaW5nOjJweCA1cHg7Zm9udC1zaXplOjEycHg7Ym9yZGVyLXJhZGl1czozcHgnO1xuICAgICAgICB2YXIgY2xvc2VCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdmFyIHJlZnJlc2hCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgICAgICBidXR0b25TdHlsZSArPSAnO2JhY2tncm91bmQtY29sb3I6JyArIG1vZGVsLmdldCgnYnV0dG9uQ29sb3InKTtcbiAgICAgICAgYnV0dG9uU3R5bGUgKz0gJztjb2xvcjonICsgbW9kZWwuZ2V0KCdidXR0b25UZXh0Q29sb3InKTtcblxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgICAgICAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQocm9vdCk7XG4gICAgICAgICAgICBzZWxmLl9kb20gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGV2ZW50VG9vbC5hZGRFdmVudExpc3RlbmVyKGNsb3NlQnV0dG9uLCAnY2xpY2snLCBjbG9zZSk7XG5cbiAgICAgICAgZXZlbnRUb29sLmFkZEV2ZW50TGlzdGVuZXIocmVmcmVzaEJ1dHRvbiwgJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG5ld09wdGlvbjtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50VG9PcHRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3T3B0aW9uID0gY29udGVudFRvT3B0aW9uKHZpZXdNYWluLCBhcGkuZ2V0T3B0aW9uKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3T3B0aW9uID0gcGFyc2VDb250ZW50cyh0ZXh0YXJlYS52YWx1ZSwgYmxvY2tNZXRhTGlzdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjbG9zZSgpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRGF0YSB2aWV3IGZvcm1hdCBlcnJvciAnICsgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV3T3B0aW9uKSB7XG4gICAgICAgICAgICAgICAgYXBpLmRpc3BhdGNoQWN0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2NoYW5nZURhdGFWaWV3JyxcbiAgICAgICAgICAgICAgICAgICAgbmV3T3B0aW9uOiBuZXdPcHRpb25cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2xvc2UoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY2xvc2VCdXR0b24uaW5uZXJIVE1MID0gbGFuZ1sxXTtcbiAgICAgICAgcmVmcmVzaEJ1dHRvbi5pbm5lckhUTUwgPSBsYW5nWzJdO1xuICAgICAgICByZWZyZXNoQnV0dG9uLnN0eWxlLmNzc1RleHQgPSBidXR0b25TdHlsZTtcbiAgICAgICAgY2xvc2VCdXR0b24uc3R5bGUuY3NzVGV4dCA9IGJ1dHRvblN0eWxlO1xuXG4gICAgICAgICFtb2RlbC5nZXQoJ3JlYWRPbmx5JykgJiYgYnV0dG9uQ29udGFpbmVyLmFwcGVuZENoaWxkKHJlZnJlc2hCdXR0b24pO1xuICAgICAgICBidXR0b25Db250YWluZXIuYXBwZW5kQ2hpbGQoY2xvc2VCdXR0b24pO1xuXG4gICAgICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNjYzNzM0MS91c2UtdGFiLXRvLWluZGVudC1pbi10ZXh0YXJlYVxuICAgICAgICBldmVudFRvb2wuYWRkRXZlbnRMaXN0ZW5lcih0ZXh0YXJlYSwgJ2tleWRvd24nLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgaWYgKChlLmtleUNvZGUgfHwgZS53aGljaCkgPT09IDkpIHtcbiAgICAgICAgICAgICAgICAvLyBnZXQgY2FyZXQgcG9zaXRpb24vc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgdmFyIHZhbCA9IHRoaXMudmFsdWU7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5zZWxlY3Rpb25TdGFydDtcbiAgICAgICAgICAgICAgICB2YXIgZW5kID0gdGhpcy5zZWxlY3Rpb25FbmQ7XG5cbiAgICAgICAgICAgICAgICAvLyBzZXQgdGV4dGFyZWEgdmFsdWUgdG86IHRleHQgYmVmb3JlIGNhcmV0ICsgdGFiICsgdGV4dCBhZnRlciBjYXJldFxuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWwuc3Vic3RyaW5nKDAsIHN0YXJ0KSArIElURU1fU1BMSVRFUiArIHZhbC5zdWJzdHJpbmcoZW5kKTtcblxuICAgICAgICAgICAgICAgIC8vIHB1dCBjYXJldCBhdCByaWdodCBwb3NpdGlvbiBhZ2FpblxuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uU3RhcnQgPSB0aGlzLnNlbGVjdGlvbkVuZCA9IHN0YXJ0ICsgMTtcblxuICAgICAgICAgICAgICAgIC8vIHByZXZlbnQgdGhlIGZvY3VzIGxvc2VcbiAgICAgICAgICAgICAgICBldmVudFRvb2wuc3RvcChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcm9vdC5hcHBlbmRDaGlsZChoZWFkZXIpO1xuICAgICAgICByb290LmFwcGVuZENoaWxkKHZpZXdNYWluKTtcbiAgICAgICAgcm9vdC5hcHBlbmRDaGlsZChidXR0b25Db250YWluZXIpO1xuXG4gICAgICAgIHZpZXdNYWluLnN0eWxlLmhlaWdodCA9IChjb250YWluZXIuY2xpZW50SGVpZ2h0IC0gODApICsgJ3B4JztcblxuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQocm9vdCk7XG4gICAgICAgIHRoaXMuX2RvbSA9IHJvb3Q7XG4gICAgfTtcblxuICAgIERhdGFWaWV3LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoZWNNb2RlbCwgYXBpKSB7XG4gICAgICAgIHRoaXMuX2RvbSAmJiBhcGkuZ2V0RG9tKCkucmVtb3ZlQ2hpbGQodGhpcy5fZG9tKTtcbiAgICB9O1xuXG4gICAgRGF0YVZpZXcucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoZWNNb2RlbCwgYXBpKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlKGVjTW9kZWwsIGFwaSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyeU1lcmdlRGF0YU9wdGlvbihuZXdEYXRhLCBvcmlnaW5hbERhdGEpIHtcbiAgICAgICAgcmV0dXJuIHpyVXRpbC5tYXAobmV3RGF0YSwgZnVuY3Rpb24gKG5ld1ZhbCwgaWR4KSB7XG4gICAgICAgICAgICB2YXIgb3JpZ2luYWwgPSBvcmlnaW5hbERhdGEgJiYgb3JpZ2luYWxEYXRhW2lkeF07XG4gICAgICAgICAgICBpZiAoenJVdGlsLmlzT2JqZWN0KG9yaWdpbmFsKSAmJiAhenJVdGlsLmlzQXJyYXkob3JpZ2luYWwpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHpyVXRpbC5pc09iamVjdChuZXdWYWwpICYmICF6clV0aWwuaXNBcnJheShuZXdWYWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1ZhbCA9IG5ld1ZhbC52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gT3JpZ2luYWwgZGF0YSBoYXMgb3B0aW9uXG4gICAgICAgICAgICAgICAgcmV0dXJuIHpyVXRpbC5kZWZhdWx0cyh7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBuZXdWYWxcbiAgICAgICAgICAgICAgICB9LCBvcmlnaW5hbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3VmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXF1aXJlKCcuLi9mZWF0dXJlTWFuYWdlcicpLnJlZ2lzdGVyKCdkYXRhVmlldycsIERhdGFWaWV3KTtcblxuICAgIHJlcXVpcmUoJy4uLy4uLy4uL2VjaGFydHMnKS5yZWdpc3RlckFjdGlvbih7XG4gICAgICAgIHR5cGU6ICdjaGFuZ2VEYXRhVmlldycsXG4gICAgICAgIGV2ZW50OiAnZGF0YVZpZXdDaGFuZ2VkJyxcbiAgICAgICAgdXBkYXRlOiAncHJlcGFyZUFuZFVwZGF0ZSdcbiAgICB9LCBmdW5jdGlvbiAocGF5bG9hZCwgZWNNb2RlbCkge1xuICAgICAgICB2YXIgbmV3U2VyaWVzT3B0TGlzdCA9IFtdO1xuICAgICAgICB6clV0aWwuZWFjaChwYXlsb2FkLm5ld09wdGlvbi5zZXJpZXMsIGZ1bmN0aW9uIChzZXJpZXNPcHQpIHtcbiAgICAgICAgICAgIHZhciBzZXJpZXNNb2RlbCA9IGVjTW9kZWwuZ2V0U2VyaWVzQnlOYW1lKHNlcmllc09wdC5uYW1lKVswXTtcbiAgICAgICAgICAgIGlmICghc2VyaWVzTW9kZWwpIHtcbiAgICAgICAgICAgICAgICAvLyBOZXcgY3JlYXRlZCBzZXJpZXNcbiAgICAgICAgICAgICAgICAvLyBHZXVzcyB0aGUgc2VyaWVzIHR5cGVcbiAgICAgICAgICAgICAgICBuZXdTZXJpZXNPcHRMaXN0LnB1c2goenJVdGlsLmV4dGVuZCh7XG4gICAgICAgICAgICAgICAgICAgIC8vIERlZmF1bHQgaXMgc2NhdHRlclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnc2NhdHRlcidcbiAgICAgICAgICAgICAgICB9LCBzZXJpZXNPcHQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBvcmlnaW5hbERhdGEgPSBzZXJpZXNNb2RlbC5nZXQoJ2RhdGEnKTtcbiAgICAgICAgICAgICAgICBuZXdTZXJpZXNPcHRMaXN0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBzZXJpZXNPcHQubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogdHJ5TWVyZ2VEYXRhT3B0aW9uKHNlcmllc09wdC5kYXRhLCBvcmlnaW5hbERhdGEpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGVjTW9kZWwubWVyZ2VPcHRpb24oenJVdGlsLmRlZmF1bHRzKHtcbiAgICAgICAgICAgIHNlcmllczogbmV3U2VyaWVzT3B0TGlzdFxuICAgICAgICB9LCBwYXlsb2FkLm5ld09wdGlvbikpO1xuICAgIH0pO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBEYXRhVmlldztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2NvbXBvbmVudC90b29sYm94L2ZlYXR1cmUvRGF0YVZpZXcuanNcbi8vIG1vZHVsZSBpZCA9IDIzMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 231 */
/* unknown exports provided */
/* all exports used */
/*!***************************************************!*\
  !*** ./lib/component/toolbox/feature/DataZoom.js ***!
  \***************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\n    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 0);\n    var BrushController = __webpack_require__(/*! ../../helper/BrushController */ 156);\n    var BrushTargetManager = __webpack_require__(/*! ../../helper/BrushTargetManager */ 196);\n    var history = __webpack_require__(/*! ../../dataZoom/history */ 154);\n\n    var each = zrUtil.each;\n\n    // Use dataZoomSelect\n    __webpack_require__(/*! ../../dataZoomSelect */ 217);\n\n    // Spectial component id start with \\0ec\\0, see echarts/model/Global.js~hasInnerId\n    var DATA_ZOOM_ID_BASE = '\\0_ec_\\0toolbox-dataZoom_';\n\n    function DataZoom(model, ecModel, api) {\n\n        /**\n         * @private\n         * @type {module:echarts/component/helper/BrushController}\n         */\n        (this._brushController = new BrushController(api.getZr()))\n            .on('brush', zrUtil.bind(this._onBrush, this))\n            .mount();\n\n        /**\n         * @private\n         * @type {boolean}\n         */\n        this._isZoomActive;\n    }\n\n    DataZoom.defaultOption = {\n        show: true,\n        // Icon group\n        icon: {\n            zoom: 'M0,13.5h26.9 M13.5,26.9V0 M32.1,13.5H58V58H13.5 V32.1',\n            back: 'M22,1.4L9.9,13.5l12.3,12.3 M10.3,13.5H54.9v44.6 H10.3v-26'\n        },\n        title: {\n            zoom: '区域缩放',\n            back: '区域缩放还原'\n        }\n    };\n\n    var proto = DataZoom.prototype;\n\n    proto.render = function (featureModel, ecModel, api, payload) {\n        this.model = featureModel;\n        this.ecModel = ecModel;\n        this.api = api;\n\n        updateZoomBtnStatus(featureModel, ecModel, this, payload, api);\n        updateBackBtnStatus(featureModel, ecModel);\n    };\n\n    proto.onclick = function (ecModel, api, type) {\n        handlers[type].call(this);\n    };\n\n    proto.remove = function (ecModel, api) {\n        this._brushController.unmount();\n    };\n\n    proto.dispose = function (ecModel, api) {\n        this._brushController.dispose();\n    };\n\n    /**\n     * @private\n     */\n    var handlers = {\n\n        zoom: function () {\n            var nextActive = !this._isZoomActive;\n\n            this.api.dispatchAction({\n                type: 'takeGlobalCursor',\n                key: 'dataZoomSelect',\n                dataZoomSelectActive: nextActive\n            });\n        },\n\n        back: function () {\n            this._dispatchZoomAction(history.pop(this.ecModel));\n        }\n    };\n\n    /**\n     * @private\n     */\n    proto._onBrush = function (areas, opt) {\n        if (!opt.isEnd || !areas.length) {\n            return;\n        }\n        var snapshot = {};\n        var ecModel = this.ecModel;\n\n        this._brushController.updateCovers([]); // remove cover\n\n        var brushTargetManager = new BrushTargetManager(\n            retrieveAxisSetting(this.model.option), ecModel, {include: ['grid']}\n        );\n        brushTargetManager.matchOutputRanges(areas, ecModel, function (area, coordRange, coordSys) {\n            if (coordSys.type !== 'cartesian2d') {\n                return;\n            }\n\n            var brushType = area.brushType;\n            if (brushType === 'rect') {\n                setBatch('x', coordSys, coordRange[0]);\n                setBatch('y', coordSys, coordRange[1]);\n            }\n            else {\n                setBatch(({lineX: 'x', lineY: 'y'})[brushType], coordSys, coordRange);\n            }\n        });\n\n        history.push(ecModel, snapshot);\n\n        this._dispatchZoomAction(snapshot);\n\n        function setBatch(dimName, coordSys, minMax) {\n            var dataZoomModel = findDataZoom(dimName, coordSys.getAxis(dimName).model, ecModel);\n            dataZoomModel && (snapshot[dataZoomModel.id] = {\n                dataZoomId: dataZoomModel.id,\n                startValue: minMax[0],\n                endValue: minMax[1]\n            });\n        }\n\n        function findDataZoom(dimName, axisModel, ecModel) {\n            var found;\n            ecModel.eachComponent({mainType: 'dataZoom', subType: 'select'}, function (dzModel) {\n                var has = dzModel.getAxisModel(dimName, axisModel.componentIndex);\n                has && (found = dzModel);\n            });\n            return found;\n        }\n    };\n\n    /**\n     * @private\n     */\n    proto._dispatchZoomAction = function (snapshot) {\n        var batch = [];\n\n        // Convert from hash map to array.\n        each(snapshot, function (batchItem, dataZoomId) {\n            batch.push(zrUtil.clone(batchItem));\n        });\n\n        batch.length && this.api.dispatchAction({\n            type: 'dataZoom',\n            from: this.uid,\n            batch: batch\n        });\n    };\n\n    function retrieveAxisSetting(option) {\n        var setting = {};\n        // Compatible with previous setting: null => all axis, false => no axis.\n        zrUtil.each(['xAxisIndex', 'yAxisIndex'], function (name) {\n            setting[name] = option[name];\n            setting[name] == null && (setting[name] = 'all');\n            (setting[name] === false || setting[name] === 'none') && (setting[name] = []);\n        });\n        return setting;\n    }\n\n    function updateBackBtnStatus(featureModel, ecModel) {\n        featureModel.setIconStatus(\n            'back',\n            history.count(ecModel) > 1 ? 'emphasis' : 'normal'\n        );\n    }\n\n    function updateZoomBtnStatus(featureModel, ecModel, view, payload, api) {\n        var zoomActive = view._isZoomActive;\n\n        if (payload && payload.type === 'takeGlobalCursor') {\n            zoomActive = payload.key === 'dataZoomSelect'\n                ? payload.dataZoomSelectActive : false;\n        }\n\n        view._isZoomActive = zoomActive;\n\n        featureModel.setIconStatus('zoom', zoomActive ? 'emphasis' : 'normal');\n\n        var brushTargetManager = new BrushTargetManager(\n            retrieveAxisSetting(featureModel.option), ecModel, {include: ['grid']}\n        );\n\n        view._brushController\n            .setPanels(brushTargetManager.makePanelOpts(api, function (targetInfo) {\n                return (targetInfo.xAxisDeclared && !targetInfo.yAxisDeclared)\n                    ? 'lineX'\n                    : (!targetInfo.xAxisDeclared && targetInfo.yAxisDeclared)\n                    ? 'lineY'\n                    : 'rect';\n            }))\n            .enableBrush(\n                zoomActive\n                ? {\n                    brushType: 'auto',\n                    brushStyle: {\n                        // FIXME user customized?\n                        lineWidth: 0,\n                        fill: 'rgba(0,0,0,0.2)'\n                    }\n                }\n                : false\n            );\n    }\n\n\n    __webpack_require__(/*! ../featureManager */ 28).register('dataZoom', DataZoom);\n\n\n    // Create special dataZoom option for select\n    __webpack_require__(/*! ../../../echarts */ 1).registerPreprocessor(function (option) {\n        if (!option) {\n            return;\n        }\n\n        var dataZoomOpts = option.dataZoom || (option.dataZoom = []);\n        if (!zrUtil.isArray(dataZoomOpts)) {\n            option.dataZoom = dataZoomOpts = [dataZoomOpts];\n        }\n\n        var toolboxOpt = option.toolbox;\n        if (toolboxOpt) {\n            // Assume there is only one toolbox\n            if (zrUtil.isArray(toolboxOpt)) {\n                toolboxOpt = toolboxOpt[0];\n            }\n\n            if (toolboxOpt && toolboxOpt.feature) {\n                var dataZoomOpt = toolboxOpt.feature.dataZoom;\n                addForAxis('xAxis', dataZoomOpt);\n                addForAxis('yAxis', dataZoomOpt);\n            }\n        }\n\n        function addForAxis(axisName, dataZoomOpt) {\n            if (!dataZoomOpt) {\n                return;\n            }\n\n            // Try not to modify model, because it is not merged yet.\n            var axisIndicesName = axisName + 'Index';\n            var givenAxisIndices = dataZoomOpt[axisIndicesName];\n            if (givenAxisIndices != null\n                && givenAxisIndices != 'all'\n                && !zrUtil.isArray(givenAxisIndices)\n            ) {\n                givenAxisIndices = (givenAxisIndices === false || givenAxisIndices === 'none') ? [] : [givenAxisIndices];\n            }\n\n            forEachComponent(axisName, function (axisOpt, axisIndex) {\n                if (givenAxisIndices != null\n                    && givenAxisIndices != 'all'\n                    && zrUtil.indexOf(givenAxisIndices, axisIndex) === -1\n                ) {\n                    return;\n                }\n                var newOpt = {\n                    type: 'select',\n                    $fromToolbox: true,\n                    // Id for merge mapping.\n                    id: DATA_ZOOM_ID_BASE + axisName + axisIndex\n                };\n                // FIXME\n                // Only support one axis now.\n                newOpt[axisIndicesName] = axisIndex;\n                dataZoomOpts.push(newOpt);\n            });\n        }\n\n        function forEachComponent(mainType, cb) {\n            var opts = option[mainType];\n            if (!zrUtil.isArray(opts)) {\n                opts = opts ? [opts] : [];\n            }\n            each(opts, cb);\n        }\n    });\n\n    module.exports = DataZoom;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjMxLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2NvbXBvbmVudC90b29sYm94L2ZlYXR1cmUvRGF0YVpvb20uanM/NWMzNiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgQnJ1c2hDb250cm9sbGVyID0gcmVxdWlyZSgnLi4vLi4vaGVscGVyL0JydXNoQ29udHJvbGxlcicpO1xuICAgIHZhciBCcnVzaFRhcmdldE1hbmFnZXIgPSByZXF1aXJlKCcuLi8uLi9oZWxwZXIvQnJ1c2hUYXJnZXRNYW5hZ2VyJyk7XG4gICAgdmFyIGhpc3RvcnkgPSByZXF1aXJlKCcuLi8uLi9kYXRhWm9vbS9oaXN0b3J5Jyk7XG5cbiAgICB2YXIgZWFjaCA9IHpyVXRpbC5lYWNoO1xuXG4gICAgLy8gVXNlIGRhdGFab29tU2VsZWN0XG4gICAgcmVxdWlyZSgnLi4vLi4vZGF0YVpvb21TZWxlY3QnKTtcblxuICAgIC8vIFNwZWN0aWFsIGNvbXBvbmVudCBpZCBzdGFydCB3aXRoIFxcMGVjXFwwLCBzZWUgZWNoYXJ0cy9tb2RlbC9HbG9iYWwuanN+aGFzSW5uZXJJZFxuICAgIHZhciBEQVRBX1pPT01fSURfQkFTRSA9ICdcXDBfZWNfXFwwdG9vbGJveC1kYXRhWm9vbV8nO1xuXG4gICAgZnVuY3Rpb24gRGF0YVpvb20obW9kZWwsIGVjTW9kZWwsIGFwaSkge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7bW9kdWxlOmVjaGFydHMvY29tcG9uZW50L2hlbHBlci9CcnVzaENvbnRyb2xsZXJ9XG4gICAgICAgICAqL1xuICAgICAgICAodGhpcy5fYnJ1c2hDb250cm9sbGVyID0gbmV3IEJydXNoQ29udHJvbGxlcihhcGkuZ2V0WnIoKSkpXG4gICAgICAgICAgICAub24oJ2JydXNoJywgenJVdGlsLmJpbmQodGhpcy5fb25CcnVzaCwgdGhpcykpXG4gICAgICAgICAgICAubW91bnQoKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9pc1pvb21BY3RpdmU7XG4gICAgfVxuXG4gICAgRGF0YVpvb20uZGVmYXVsdE9wdGlvbiA9IHtcbiAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgLy8gSWNvbiBncm91cFxuICAgICAgICBpY29uOiB7XG4gICAgICAgICAgICB6b29tOiAnTTAsMTMuNWgyNi45IE0xMy41LDI2LjlWMCBNMzIuMSwxMy41SDU4VjU4SDEzLjUgVjMyLjEnLFxuICAgICAgICAgICAgYmFjazogJ00yMiwxLjRMOS45LDEzLjVsMTIuMywxMi4zIE0xMC4zLDEzLjVINTQuOXY0NC42IEgxMC4zdi0yNidcbiAgICAgICAgfSxcbiAgICAgICAgdGl0bGU6IHtcbiAgICAgICAgICAgIHpvb206ICfljLrln5/nvKnmlL4nLFxuICAgICAgICAgICAgYmFjazogJ+WMuuWfn+e8qeaUvui/mOWOnydcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgcHJvdG8gPSBEYXRhWm9vbS5wcm90b3R5cGU7XG5cbiAgICBwcm90by5yZW5kZXIgPSBmdW5jdGlvbiAoZmVhdHVyZU1vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpIHtcbiAgICAgICAgdGhpcy5tb2RlbCA9IGZlYXR1cmVNb2RlbDtcbiAgICAgICAgdGhpcy5lY01vZGVsID0gZWNNb2RlbDtcbiAgICAgICAgdGhpcy5hcGkgPSBhcGk7XG5cbiAgICAgICAgdXBkYXRlWm9vbUJ0blN0YXR1cyhmZWF0dXJlTW9kZWwsIGVjTW9kZWwsIHRoaXMsIHBheWxvYWQsIGFwaSk7XG4gICAgICAgIHVwZGF0ZUJhY2tCdG5TdGF0dXMoZmVhdHVyZU1vZGVsLCBlY01vZGVsKTtcbiAgICB9O1xuXG4gICAgcHJvdG8ub25jbGljayA9IGZ1bmN0aW9uIChlY01vZGVsLCBhcGksIHR5cGUpIHtcbiAgICAgICAgaGFuZGxlcnNbdHlwZV0uY2FsbCh0aGlzKTtcbiAgICB9O1xuXG4gICAgcHJvdG8ucmVtb3ZlID0gZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICAgICAgICB0aGlzLl9icnVzaENvbnRyb2xsZXIudW5tb3VudCgpO1xuICAgIH07XG5cbiAgICBwcm90by5kaXNwb3NlID0gZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICAgICAgICB0aGlzLl9icnVzaENvbnRyb2xsZXIuZGlzcG9zZSgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHZhciBoYW5kbGVycyA9IHtcblxuICAgICAgICB6b29tOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbmV4dEFjdGl2ZSA9ICF0aGlzLl9pc1pvb21BY3RpdmU7XG5cbiAgICAgICAgICAgIHRoaXMuYXBpLmRpc3BhdGNoQWN0aW9uKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAndGFrZUdsb2JhbEN1cnNvcicsXG4gICAgICAgICAgICAgICAga2V5OiAnZGF0YVpvb21TZWxlY3QnLFxuICAgICAgICAgICAgICAgIGRhdGFab29tU2VsZWN0QWN0aXZlOiBuZXh0QWN0aXZlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBiYWNrOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9kaXNwYXRjaFpvb21BY3Rpb24oaGlzdG9yeS5wb3AodGhpcy5lY01vZGVsKSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBwcm90by5fb25CcnVzaCA9IGZ1bmN0aW9uIChhcmVhcywgb3B0KSB7XG4gICAgICAgIGlmICghb3B0LmlzRW5kIHx8ICFhcmVhcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc25hcHNob3QgPSB7fTtcbiAgICAgICAgdmFyIGVjTW9kZWwgPSB0aGlzLmVjTW9kZWw7XG5cbiAgICAgICAgdGhpcy5fYnJ1c2hDb250cm9sbGVyLnVwZGF0ZUNvdmVycyhbXSk7IC8vIHJlbW92ZSBjb3ZlclxuXG4gICAgICAgIHZhciBicnVzaFRhcmdldE1hbmFnZXIgPSBuZXcgQnJ1c2hUYXJnZXRNYW5hZ2VyKFxuICAgICAgICAgICAgcmV0cmlldmVBeGlzU2V0dGluZyh0aGlzLm1vZGVsLm9wdGlvbiksIGVjTW9kZWwsIHtpbmNsdWRlOiBbJ2dyaWQnXX1cbiAgICAgICAgKTtcbiAgICAgICAgYnJ1c2hUYXJnZXRNYW5hZ2VyLm1hdGNoT3V0cHV0UmFuZ2VzKGFyZWFzLCBlY01vZGVsLCBmdW5jdGlvbiAoYXJlYSwgY29vcmRSYW5nZSwgY29vcmRTeXMpIHtcbiAgICAgICAgICAgIGlmIChjb29yZFN5cy50eXBlICE9PSAnY2FydGVzaWFuMmQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgYnJ1c2hUeXBlID0gYXJlYS5icnVzaFR5cGU7XG4gICAgICAgICAgICBpZiAoYnJ1c2hUeXBlID09PSAncmVjdCcpIHtcbiAgICAgICAgICAgICAgICBzZXRCYXRjaCgneCcsIGNvb3JkU3lzLCBjb29yZFJhbmdlWzBdKTtcbiAgICAgICAgICAgICAgICBzZXRCYXRjaCgneScsIGNvb3JkU3lzLCBjb29yZFJhbmdlWzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNldEJhdGNoKCh7bGluZVg6ICd4JywgbGluZVk6ICd5J30pW2JydXNoVHlwZV0sIGNvb3JkU3lzLCBjb29yZFJhbmdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaGlzdG9yeS5wdXNoKGVjTW9kZWwsIHNuYXBzaG90KTtcblxuICAgICAgICB0aGlzLl9kaXNwYXRjaFpvb21BY3Rpb24oc25hcHNob3QpO1xuXG4gICAgICAgIGZ1bmN0aW9uIHNldEJhdGNoKGRpbU5hbWUsIGNvb3JkU3lzLCBtaW5NYXgpIHtcbiAgICAgICAgICAgIHZhciBkYXRhWm9vbU1vZGVsID0gZmluZERhdGFab29tKGRpbU5hbWUsIGNvb3JkU3lzLmdldEF4aXMoZGltTmFtZSkubW9kZWwsIGVjTW9kZWwpO1xuICAgICAgICAgICAgZGF0YVpvb21Nb2RlbCAmJiAoc25hcHNob3RbZGF0YVpvb21Nb2RlbC5pZF0gPSB7XG4gICAgICAgICAgICAgICAgZGF0YVpvb21JZDogZGF0YVpvb21Nb2RlbC5pZCxcbiAgICAgICAgICAgICAgICBzdGFydFZhbHVlOiBtaW5NYXhbMF0sXG4gICAgICAgICAgICAgICAgZW5kVmFsdWU6IG1pbk1heFsxXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBmaW5kRGF0YVpvb20oZGltTmFtZSwgYXhpc01vZGVsLCBlY01vZGVsKSB7XG4gICAgICAgICAgICB2YXIgZm91bmQ7XG4gICAgICAgICAgICBlY01vZGVsLmVhY2hDb21wb25lbnQoe21haW5UeXBlOiAnZGF0YVpvb20nLCBzdWJUeXBlOiAnc2VsZWN0J30sIGZ1bmN0aW9uIChkek1vZGVsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGhhcyA9IGR6TW9kZWwuZ2V0QXhpc01vZGVsKGRpbU5hbWUsIGF4aXNNb2RlbC5jb21wb25lbnRJbmRleCk7XG4gICAgICAgICAgICAgICAgaGFzICYmIChmb3VuZCA9IGR6TW9kZWwpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBwcm90by5fZGlzcGF0Y2hab29tQWN0aW9uID0gZnVuY3Rpb24gKHNuYXBzaG90KSB7XG4gICAgICAgIHZhciBiYXRjaCA9IFtdO1xuXG4gICAgICAgIC8vIENvbnZlcnQgZnJvbSBoYXNoIG1hcCB0byBhcnJheS5cbiAgICAgICAgZWFjaChzbmFwc2hvdCwgZnVuY3Rpb24gKGJhdGNoSXRlbSwgZGF0YVpvb21JZCkge1xuICAgICAgICAgICAgYmF0Y2gucHVzaCh6clV0aWwuY2xvbmUoYmF0Y2hJdGVtKSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGJhdGNoLmxlbmd0aCAmJiB0aGlzLmFwaS5kaXNwYXRjaEFjdGlvbih7XG4gICAgICAgICAgICB0eXBlOiAnZGF0YVpvb20nLFxuICAgICAgICAgICAgZnJvbTogdGhpcy51aWQsXG4gICAgICAgICAgICBiYXRjaDogYmF0Y2hcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHJldHJpZXZlQXhpc1NldHRpbmcob3B0aW9uKSB7XG4gICAgICAgIHZhciBzZXR0aW5nID0ge307XG4gICAgICAgIC8vIENvbXBhdGlibGUgd2l0aCBwcmV2aW91cyBzZXR0aW5nOiBudWxsID0+IGFsbCBheGlzLCBmYWxzZSA9PiBubyBheGlzLlxuICAgICAgICB6clV0aWwuZWFjaChbJ3hBeGlzSW5kZXgnLCAneUF4aXNJbmRleCddLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgc2V0dGluZ1tuYW1lXSA9IG9wdGlvbltuYW1lXTtcbiAgICAgICAgICAgIHNldHRpbmdbbmFtZV0gPT0gbnVsbCAmJiAoc2V0dGluZ1tuYW1lXSA9ICdhbGwnKTtcbiAgICAgICAgICAgIChzZXR0aW5nW25hbWVdID09PSBmYWxzZSB8fCBzZXR0aW5nW25hbWVdID09PSAnbm9uZScpICYmIChzZXR0aW5nW25hbWVdID0gW10pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHNldHRpbmc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXBkYXRlQmFja0J0blN0YXR1cyhmZWF0dXJlTW9kZWwsIGVjTW9kZWwpIHtcbiAgICAgICAgZmVhdHVyZU1vZGVsLnNldEljb25TdGF0dXMoXG4gICAgICAgICAgICAnYmFjaycsXG4gICAgICAgICAgICBoaXN0b3J5LmNvdW50KGVjTW9kZWwpID4gMSA/ICdlbXBoYXNpcycgOiAnbm9ybWFsJ1xuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVwZGF0ZVpvb21CdG5TdGF0dXMoZmVhdHVyZU1vZGVsLCBlY01vZGVsLCB2aWV3LCBwYXlsb2FkLCBhcGkpIHtcbiAgICAgICAgdmFyIHpvb21BY3RpdmUgPSB2aWV3Ll9pc1pvb21BY3RpdmU7XG5cbiAgICAgICAgaWYgKHBheWxvYWQgJiYgcGF5bG9hZC50eXBlID09PSAndGFrZUdsb2JhbEN1cnNvcicpIHtcbiAgICAgICAgICAgIHpvb21BY3RpdmUgPSBwYXlsb2FkLmtleSA9PT0gJ2RhdGFab29tU2VsZWN0J1xuICAgICAgICAgICAgICAgID8gcGF5bG9hZC5kYXRhWm9vbVNlbGVjdEFjdGl2ZSA6IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmlldy5faXNab29tQWN0aXZlID0gem9vbUFjdGl2ZTtcblxuICAgICAgICBmZWF0dXJlTW9kZWwuc2V0SWNvblN0YXR1cygnem9vbScsIHpvb21BY3RpdmUgPyAnZW1waGFzaXMnIDogJ25vcm1hbCcpO1xuXG4gICAgICAgIHZhciBicnVzaFRhcmdldE1hbmFnZXIgPSBuZXcgQnJ1c2hUYXJnZXRNYW5hZ2VyKFxuICAgICAgICAgICAgcmV0cmlldmVBeGlzU2V0dGluZyhmZWF0dXJlTW9kZWwub3B0aW9uKSwgZWNNb2RlbCwge2luY2x1ZGU6IFsnZ3JpZCddfVxuICAgICAgICApO1xuXG4gICAgICAgIHZpZXcuX2JydXNoQ29udHJvbGxlclxuICAgICAgICAgICAgLnNldFBhbmVscyhicnVzaFRhcmdldE1hbmFnZXIubWFrZVBhbmVsT3B0cyhhcGksIGZ1bmN0aW9uICh0YXJnZXRJbmZvKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh0YXJnZXRJbmZvLnhBeGlzRGVjbGFyZWQgJiYgIXRhcmdldEluZm8ueUF4aXNEZWNsYXJlZClcbiAgICAgICAgICAgICAgICAgICAgPyAnbGluZVgnXG4gICAgICAgICAgICAgICAgICAgIDogKCF0YXJnZXRJbmZvLnhBeGlzRGVjbGFyZWQgJiYgdGFyZ2V0SW5mby55QXhpc0RlY2xhcmVkKVxuICAgICAgICAgICAgICAgICAgICA/ICdsaW5lWSdcbiAgICAgICAgICAgICAgICAgICAgOiAncmVjdCc7XG4gICAgICAgICAgICB9KSlcbiAgICAgICAgICAgIC5lbmFibGVCcnVzaChcbiAgICAgICAgICAgICAgICB6b29tQWN0aXZlXG4gICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgIGJydXNoVHlwZTogJ2F1dG8nLFxuICAgICAgICAgICAgICAgICAgICBicnVzaFN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGSVhNRSB1c2VyIGN1c3RvbWl6ZWQ/XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lV2lkdGg6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxsOiAncmdiYSgwLDAsMCwwLjIpJ1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDogZmFsc2VcbiAgICAgICAgICAgICk7XG4gICAgfVxuXG5cbiAgICByZXF1aXJlKCcuLi9mZWF0dXJlTWFuYWdlcicpLnJlZ2lzdGVyKCdkYXRhWm9vbScsIERhdGFab29tKTtcblxuXG4gICAgLy8gQ3JlYXRlIHNwZWNpYWwgZGF0YVpvb20gb3B0aW9uIGZvciBzZWxlY3RcbiAgICByZXF1aXJlKCcuLi8uLi8uLi9lY2hhcnRzJykucmVnaXN0ZXJQcmVwcm9jZXNzb3IoZnVuY3Rpb24gKG9wdGlvbikge1xuICAgICAgICBpZiAoIW9wdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRhdGFab29tT3B0cyA9IG9wdGlvbi5kYXRhWm9vbSB8fCAob3B0aW9uLmRhdGFab29tID0gW10pO1xuICAgICAgICBpZiAoIXpyVXRpbC5pc0FycmF5KGRhdGFab29tT3B0cykpIHtcbiAgICAgICAgICAgIG9wdGlvbi5kYXRhWm9vbSA9IGRhdGFab29tT3B0cyA9IFtkYXRhWm9vbU9wdHNdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRvb2xib3hPcHQgPSBvcHRpb24udG9vbGJveDtcbiAgICAgICAgaWYgKHRvb2xib3hPcHQpIHtcbiAgICAgICAgICAgIC8vIEFzc3VtZSB0aGVyZSBpcyBvbmx5IG9uZSB0b29sYm94XG4gICAgICAgICAgICBpZiAoenJVdGlsLmlzQXJyYXkodG9vbGJveE9wdCkpIHtcbiAgICAgICAgICAgICAgICB0b29sYm94T3B0ID0gdG9vbGJveE9wdFswXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRvb2xib3hPcHQgJiYgdG9vbGJveE9wdC5mZWF0dXJlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGFab29tT3B0ID0gdG9vbGJveE9wdC5mZWF0dXJlLmRhdGFab29tO1xuICAgICAgICAgICAgICAgIGFkZEZvckF4aXMoJ3hBeGlzJywgZGF0YVpvb21PcHQpO1xuICAgICAgICAgICAgICAgIGFkZEZvckF4aXMoJ3lBeGlzJywgZGF0YVpvb21PcHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gYWRkRm9yQXhpcyhheGlzTmFtZSwgZGF0YVpvb21PcHQpIHtcbiAgICAgICAgICAgIGlmICghZGF0YVpvb21PcHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRyeSBub3QgdG8gbW9kaWZ5IG1vZGVsLCBiZWNhdXNlIGl0IGlzIG5vdCBtZXJnZWQgeWV0LlxuICAgICAgICAgICAgdmFyIGF4aXNJbmRpY2VzTmFtZSA9IGF4aXNOYW1lICsgJ0luZGV4JztcbiAgICAgICAgICAgIHZhciBnaXZlbkF4aXNJbmRpY2VzID0gZGF0YVpvb21PcHRbYXhpc0luZGljZXNOYW1lXTtcbiAgICAgICAgICAgIGlmIChnaXZlbkF4aXNJbmRpY2VzICE9IG51bGxcbiAgICAgICAgICAgICAgICAmJiBnaXZlbkF4aXNJbmRpY2VzICE9ICdhbGwnXG4gICAgICAgICAgICAgICAgJiYgIXpyVXRpbC5pc0FycmF5KGdpdmVuQXhpc0luZGljZXMpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBnaXZlbkF4aXNJbmRpY2VzID0gKGdpdmVuQXhpc0luZGljZXMgPT09IGZhbHNlIHx8IGdpdmVuQXhpc0luZGljZXMgPT09ICdub25lJykgPyBbXSA6IFtnaXZlbkF4aXNJbmRpY2VzXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yRWFjaENvbXBvbmVudChheGlzTmFtZSwgZnVuY3Rpb24gKGF4aXNPcHQsIGF4aXNJbmRleCkge1xuICAgICAgICAgICAgICAgIGlmIChnaXZlbkF4aXNJbmRpY2VzICE9IG51bGxcbiAgICAgICAgICAgICAgICAgICAgJiYgZ2l2ZW5BeGlzSW5kaWNlcyAhPSAnYWxsJ1xuICAgICAgICAgICAgICAgICAgICAmJiB6clV0aWwuaW5kZXhPZihnaXZlbkF4aXNJbmRpY2VzLCBheGlzSW5kZXgpID09PSAtMVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBuZXdPcHQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdzZWxlY3QnLFxuICAgICAgICAgICAgICAgICAgICAkZnJvbVRvb2xib3g6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIC8vIElkIGZvciBtZXJnZSBtYXBwaW5nLlxuICAgICAgICAgICAgICAgICAgICBpZDogREFUQV9aT09NX0lEX0JBU0UgKyBheGlzTmFtZSArIGF4aXNJbmRleFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgLy8gRklYTUVcbiAgICAgICAgICAgICAgICAvLyBPbmx5IHN1cHBvcnQgb25lIGF4aXMgbm93LlxuICAgICAgICAgICAgICAgIG5ld09wdFtheGlzSW5kaWNlc05hbWVdID0gYXhpc0luZGV4O1xuICAgICAgICAgICAgICAgIGRhdGFab29tT3B0cy5wdXNoKG5ld09wdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGZvckVhY2hDb21wb25lbnQobWFpblR5cGUsIGNiKSB7XG4gICAgICAgICAgICB2YXIgb3B0cyA9IG9wdGlvblttYWluVHlwZV07XG4gICAgICAgICAgICBpZiAoIXpyVXRpbC5pc0FycmF5KG9wdHMpKSB7XG4gICAgICAgICAgICAgICAgb3B0cyA9IG9wdHMgPyBbb3B0c10gOiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVhY2gob3B0cywgY2IpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IERhdGFab29tO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvY29tcG9uZW50L3Rvb2xib3gvZmVhdHVyZS9EYXRhWm9vbS5qc1xuLy8gbW9kdWxlIGlkID0gMjMxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 232 */
/* unknown exports provided */
/* all exports used */
/*!****************************************************!*\
  !*** ./lib/component/toolbox/feature/MagicType.js ***!
  \****************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\n    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 0);\n\n    function MagicType(model) {\n        this.model = model;\n    }\n\n    MagicType.defaultOption = {\n        show: true,\n        type: [],\n        // Icon group\n        icon: {\n            line: 'M4.1,28.9h7.1l9.3-22l7.4,38l9.7-19.7l3,12.8h14.9M4.1,58h51.4',\n            bar: 'M6.7,22.9h10V48h-10V22.9zM24.9,13h10v35h-10V13zM43.2,2h10v46h-10V2zM3.1,58h53.7',\n            stack: 'M8.2,38.4l-8.4,4.1l30.6,15.3L60,42.5l-8.1-4.1l-21.5,11L8.2,38.4z M51.9,30l-8.1,4.2l-13.4,6.9l-13.9-6.9L8.2,30l-8.4,4.2l8.4,4.2l22.2,11l21.5-11l8.1-4.2L51.9,30z M51.9,21.7l-8.1,4.2L35.7,30l-5.3,2.8L24.9,30l-8.4-4.1l-8.3-4.2l-8.4,4.2L8.2,30l8.3,4.2l13.9,6.9l13.4-6.9l8.1-4.2l8.1-4.1L51.9,21.7zM30.4,2.2L-0.2,17.5l8.4,4.1l8.3,4.2l8.4,4.2l5.5,2.7l5.3-2.7l8.1-4.2l8.1-4.2l8.1-4.1L30.4,2.2z', // jshint ignore:line\n            tiled: 'M2.3,2.2h22.8V25H2.3V2.2z M35,2.2h22.8V25H35V2.2zM2.3,35h22.8v22.8H2.3V35z M35,35h22.8v22.8H35V35z'\n        },\n        title: {\n            line: '切换为折线图',\n            bar: '切换为柱状图',\n            stack: '切换为堆叠',\n            tiled: '切换为平铺'\n        },\n        option: {},\n        seriesIndex: {}\n    };\n\n    var proto = MagicType.prototype;\n\n    proto.getIcons = function () {\n        var model = this.model;\n        var availableIcons = model.get('icon');\n        var icons = {};\n        zrUtil.each(model.get('type'), function (type) {\n            if (availableIcons[type]) {\n                icons[type] = availableIcons[type];\n            }\n        });\n        return icons;\n    };\n\n    var seriesOptGenreator = {\n        'line': function (seriesType, seriesId, seriesModel, model) {\n            if (seriesType === 'bar') {\n                return zrUtil.merge({\n                    id: seriesId,\n                    type: 'line',\n                    // Preserve data related option\n                    data: seriesModel.get('data'),\n                    stack: seriesModel.get('stack'),\n                    markPoint: seriesModel.get('markPoint'),\n                    markLine: seriesModel.get('markLine')\n                }, model.get('option.line') || {}, true);\n            }\n        },\n        'bar': function (seriesType, seriesId, seriesModel, model) {\n            if (seriesType === 'line') {\n                return zrUtil.merge({\n                    id: seriesId,\n                    type: 'bar',\n                    // Preserve data related option\n                    data: seriesModel.get('data'),\n                    stack: seriesModel.get('stack'),\n                    markPoint: seriesModel.get('markPoint'),\n                    markLine: seriesModel.get('markLine')\n                }, model.get('option.bar') || {}, true);\n            }\n        },\n        'stack': function (seriesType, seriesId, seriesModel, model) {\n            if (seriesType === 'line' || seriesType === 'bar') {\n                return zrUtil.merge({\n                    id: seriesId,\n                    stack: '__ec_magicType_stack__'\n                }, model.get('option.stack') || {}, true);\n            }\n        },\n        'tiled': function (seriesType, seriesId, seriesModel, model) {\n            if (seriesType === 'line' || seriesType === 'bar') {\n                return zrUtil.merge({\n                    id: seriesId,\n                    stack: ''\n                }, model.get('option.tiled') || {}, true);\n            }\n        }\n    };\n\n    var radioTypes = [\n        ['line', 'bar'],\n        ['stack', 'tiled']\n    ];\n\n    proto.onclick = function (ecModel, api, type) {\n        var model = this.model;\n        var seriesIndex = model.get('seriesIndex.' + type);\n        // Not supported magicType\n        if (!seriesOptGenreator[type]) {\n            return;\n        }\n        var newOption = {\n            series: []\n        };\n        var generateNewSeriesTypes = function (seriesModel) {\n            var seriesType = seriesModel.subType;\n            var seriesId = seriesModel.id;\n            var newSeriesOpt = seriesOptGenreator[type](\n                seriesType, seriesId, seriesModel, model\n            );\n            if (newSeriesOpt) {\n                // PENDING If merge original option?\n                zrUtil.defaults(newSeriesOpt, seriesModel.option);\n                newOption.series.push(newSeriesOpt);\n            }\n            // Modify boundaryGap\n            var coordSys = seriesModel.coordinateSystem;\n            if (coordSys && coordSys.type === 'cartesian2d' && (type === 'line' || type === 'bar')) {\n                var categoryAxis = coordSys.getAxesByScale('ordinal')[0];\n                if (categoryAxis) {\n                    var axisDim = categoryAxis.dim;\n                    var axisType = axisDim + 'Axis';\n                    var axisModel = ecModel.queryComponents({\n                        mainType: axisType,\n                        index: seriesModel.get(name + 'Index'),\n                        id: seriesModel.get(name + 'Id')\n                    })[0];\n                    var axisIndex = axisModel.componentIndex;\n\n                    newOption[axisType] = newOption[axisType] || [];\n                    for (var i = 0; i <= axisIndex; i++) {\n                        newOption[axisType][axisIndex] = newOption[axisType][axisIndex] || {};\n                    }\n                    newOption[axisType][axisIndex].boundaryGap = type === 'bar' ? true : false;\n                }\n            }\n        };\n\n        zrUtil.each(radioTypes, function (radio) {\n            if (zrUtil.indexOf(radio, type) >= 0) {\n                zrUtil.each(radio, function (item) {\n                    model.setIconStatus(item, 'normal');\n                });\n            }\n        });\n\n        model.setIconStatus(type, 'emphasis');\n\n        ecModel.eachComponent(\n            {\n                mainType: 'series',\n                query: seriesIndex == null ? null : {\n                    seriesIndex: seriesIndex\n                }\n            }, generateNewSeriesTypes\n        );\n        api.dispatchAction({\n            type: 'changeMagicType',\n            currentType: type,\n            newOption: newOption\n        });\n    };\n\n    var echarts = __webpack_require__(/*! ../../../echarts */ 1);\n    echarts.registerAction({\n        type: 'changeMagicType',\n        event: 'magicTypeChanged',\n        update: 'prepareAndUpdate'\n    }, function (payload, ecModel) {\n        ecModel.mergeOption(payload.newOption);\n    });\n\n    __webpack_require__(/*! ../featureManager */ 28).register('magicType', MagicType);\n\n    module.exports = MagicType;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjMyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2NvbXBvbmVudC90b29sYm94L2ZlYXR1cmUvTWFnaWNUeXBlLmpzPzU2OTgiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG5cbiAgICBmdW5jdGlvbiBNYWdpY1R5cGUobW9kZWwpIHtcbiAgICAgICAgdGhpcy5tb2RlbCA9IG1vZGVsO1xuICAgIH1cblxuICAgIE1hZ2ljVHlwZS5kZWZhdWx0T3B0aW9uID0ge1xuICAgICAgICBzaG93OiB0cnVlLFxuICAgICAgICB0eXBlOiBbXSxcbiAgICAgICAgLy8gSWNvbiBncm91cFxuICAgICAgICBpY29uOiB7XG4gICAgICAgICAgICBsaW5lOiAnTTQuMSwyOC45aDcuMWw5LjMtMjJsNy40LDM4bDkuNy0xOS43bDMsMTIuOGgxNC45TTQuMSw1OGg1MS40JyxcbiAgICAgICAgICAgIGJhcjogJ002LjcsMjIuOWgxMFY0OGgtMTBWMjIuOXpNMjQuOSwxM2gxMHYzNWgtMTBWMTN6TTQzLjIsMmgxMHY0NmgtMTBWMnpNMy4xLDU4aDUzLjcnLFxuICAgICAgICAgICAgc3RhY2s6ICdNOC4yLDM4LjRsLTguNCw0LjFsMzAuNiwxNS4zTDYwLDQyLjVsLTguMS00LjFsLTIxLjUsMTFMOC4yLDM4LjR6IE01MS45LDMwbC04LjEsNC4ybC0xMy40LDYuOWwtMTMuOS02LjlMOC4yLDMwbC04LjQsNC4ybDguNCw0LjJsMjIuMiwxMWwyMS41LTExbDguMS00LjJMNTEuOSwzMHogTTUxLjksMjEuN2wtOC4xLDQuMkwzNS43LDMwbC01LjMsMi44TDI0LjksMzBsLTguNC00LjFsLTguMy00LjJsLTguNCw0LjJMOC4yLDMwbDguMyw0LjJsMTMuOSw2LjlsMTMuNC02LjlsOC4xLTQuMmw4LjEtNC4xTDUxLjksMjEuN3pNMzAuNCwyLjJMLTAuMiwxNy41bDguNCw0LjFsOC4zLDQuMmw4LjQsNC4ybDUuNSwyLjdsNS4zLTIuN2w4LjEtNC4ybDguMS00LjJsOC4xLTQuMUwzMC40LDIuMnonLCAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICAgICAgICAgIHRpbGVkOiAnTTIuMywyLjJoMjIuOFYyNUgyLjNWMi4yeiBNMzUsMi4yaDIyLjhWMjVIMzVWMi4yek0yLjMsMzVoMjIuOHYyMi44SDIuM1YzNXogTTM1LDM1aDIyLjh2MjIuOEgzNVYzNXonXG4gICAgICAgIH0sXG4gICAgICAgIHRpdGxlOiB7XG4gICAgICAgICAgICBsaW5lOiAn5YiH5o2i5Li65oqY57q/5Zu+JyxcbiAgICAgICAgICAgIGJhcjogJ+WIh+aNouS4uuafseeKtuWbvicsXG4gICAgICAgICAgICBzdGFjazogJ+WIh+aNouS4uuWghuWPoCcsXG4gICAgICAgICAgICB0aWxlZDogJ+WIh+aNouS4uuW5s+mTuidcbiAgICAgICAgfSxcbiAgICAgICAgb3B0aW9uOiB7fSxcbiAgICAgICAgc2VyaWVzSW5kZXg6IHt9XG4gICAgfTtcblxuICAgIHZhciBwcm90byA9IE1hZ2ljVHlwZS5wcm90b3R5cGU7XG5cbiAgICBwcm90by5nZXRJY29ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG1vZGVsID0gdGhpcy5tb2RlbDtcbiAgICAgICAgdmFyIGF2YWlsYWJsZUljb25zID0gbW9kZWwuZ2V0KCdpY29uJyk7XG4gICAgICAgIHZhciBpY29ucyA9IHt9O1xuICAgICAgICB6clV0aWwuZWFjaChtb2RlbC5nZXQoJ3R5cGUnKSwgZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgICAgIGlmIChhdmFpbGFibGVJY29uc1t0eXBlXSkge1xuICAgICAgICAgICAgICAgIGljb25zW3R5cGVdID0gYXZhaWxhYmxlSWNvbnNbdHlwZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaWNvbnM7XG4gICAgfTtcblxuICAgIHZhciBzZXJpZXNPcHRHZW5yZWF0b3IgPSB7XG4gICAgICAgICdsaW5lJzogZnVuY3Rpb24gKHNlcmllc1R5cGUsIHNlcmllc0lkLCBzZXJpZXNNb2RlbCwgbW9kZWwpIHtcbiAgICAgICAgICAgIGlmIChzZXJpZXNUeXBlID09PSAnYmFyJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB6clV0aWwubWVyZ2Uoe1xuICAgICAgICAgICAgICAgICAgICBpZDogc2VyaWVzSWQsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdsaW5lJyxcbiAgICAgICAgICAgICAgICAgICAgLy8gUHJlc2VydmUgZGF0YSByZWxhdGVkIG9wdGlvblxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBzZXJpZXNNb2RlbC5nZXQoJ2RhdGEnKSxcbiAgICAgICAgICAgICAgICAgICAgc3RhY2s6IHNlcmllc01vZGVsLmdldCgnc3RhY2snKSxcbiAgICAgICAgICAgICAgICAgICAgbWFya1BvaW50OiBzZXJpZXNNb2RlbC5nZXQoJ21hcmtQb2ludCcpLFxuICAgICAgICAgICAgICAgICAgICBtYXJrTGluZTogc2VyaWVzTW9kZWwuZ2V0KCdtYXJrTGluZScpXG4gICAgICAgICAgICAgICAgfSwgbW9kZWwuZ2V0KCdvcHRpb24ubGluZScpIHx8IHt9LCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgJ2Jhcic6IGZ1bmN0aW9uIChzZXJpZXNUeXBlLCBzZXJpZXNJZCwgc2VyaWVzTW9kZWwsIG1vZGVsKSB7XG4gICAgICAgICAgICBpZiAoc2VyaWVzVHlwZSA9PT0gJ2xpbmUnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHpyVXRpbC5tZXJnZSh7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBzZXJpZXNJZCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2JhcicsXG4gICAgICAgICAgICAgICAgICAgIC8vIFByZXNlcnZlIGRhdGEgcmVsYXRlZCBvcHRpb25cbiAgICAgICAgICAgICAgICAgICAgZGF0YTogc2VyaWVzTW9kZWwuZ2V0KCdkYXRhJyksXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrOiBzZXJpZXNNb2RlbC5nZXQoJ3N0YWNrJyksXG4gICAgICAgICAgICAgICAgICAgIG1hcmtQb2ludDogc2VyaWVzTW9kZWwuZ2V0KCdtYXJrUG9pbnQnKSxcbiAgICAgICAgICAgICAgICAgICAgbWFya0xpbmU6IHNlcmllc01vZGVsLmdldCgnbWFya0xpbmUnKVxuICAgICAgICAgICAgICAgIH0sIG1vZGVsLmdldCgnb3B0aW9uLmJhcicpIHx8IHt9LCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgJ3N0YWNrJzogZnVuY3Rpb24gKHNlcmllc1R5cGUsIHNlcmllc0lkLCBzZXJpZXNNb2RlbCwgbW9kZWwpIHtcbiAgICAgICAgICAgIGlmIChzZXJpZXNUeXBlID09PSAnbGluZScgfHwgc2VyaWVzVHlwZSA9PT0gJ2JhcicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4genJVdGlsLm1lcmdlKHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHNlcmllc0lkLFxuICAgICAgICAgICAgICAgICAgICBzdGFjazogJ19fZWNfbWFnaWNUeXBlX3N0YWNrX18nXG4gICAgICAgICAgICAgICAgfSwgbW9kZWwuZ2V0KCdvcHRpb24uc3RhY2snKSB8fCB7fSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgICd0aWxlZCc6IGZ1bmN0aW9uIChzZXJpZXNUeXBlLCBzZXJpZXNJZCwgc2VyaWVzTW9kZWwsIG1vZGVsKSB7XG4gICAgICAgICAgICBpZiAoc2VyaWVzVHlwZSA9PT0gJ2xpbmUnIHx8IHNlcmllc1R5cGUgPT09ICdiYXInKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHpyVXRpbC5tZXJnZSh7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBzZXJpZXNJZCxcbiAgICAgICAgICAgICAgICAgICAgc3RhY2s6ICcnXG4gICAgICAgICAgICAgICAgfSwgbW9kZWwuZ2V0KCdvcHRpb24udGlsZWQnKSB8fCB7fSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHJhZGlvVHlwZXMgPSBbXG4gICAgICAgIFsnbGluZScsICdiYXInXSxcbiAgICAgICAgWydzdGFjaycsICd0aWxlZCddXG4gICAgXTtcblxuICAgIHByb3RvLm9uY2xpY2sgPSBmdW5jdGlvbiAoZWNNb2RlbCwgYXBpLCB0eXBlKSB7XG4gICAgICAgIHZhciBtb2RlbCA9IHRoaXMubW9kZWw7XG4gICAgICAgIHZhciBzZXJpZXNJbmRleCA9IG1vZGVsLmdldCgnc2VyaWVzSW5kZXguJyArIHR5cGUpO1xuICAgICAgICAvLyBOb3Qgc3VwcG9ydGVkIG1hZ2ljVHlwZVxuICAgICAgICBpZiAoIXNlcmllc09wdEdlbnJlYXRvclt0eXBlXSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuZXdPcHRpb24gPSB7XG4gICAgICAgICAgICBzZXJpZXM6IFtdXG4gICAgICAgIH07XG4gICAgICAgIHZhciBnZW5lcmF0ZU5ld1Nlcmllc1R5cGVzID0gZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICAgICAgICB2YXIgc2VyaWVzVHlwZSA9IHNlcmllc01vZGVsLnN1YlR5cGU7XG4gICAgICAgICAgICB2YXIgc2VyaWVzSWQgPSBzZXJpZXNNb2RlbC5pZDtcbiAgICAgICAgICAgIHZhciBuZXdTZXJpZXNPcHQgPSBzZXJpZXNPcHRHZW5yZWF0b3JbdHlwZV0oXG4gICAgICAgICAgICAgICAgc2VyaWVzVHlwZSwgc2VyaWVzSWQsIHNlcmllc01vZGVsLCBtb2RlbFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChuZXdTZXJpZXNPcHQpIHtcbiAgICAgICAgICAgICAgICAvLyBQRU5ESU5HIElmIG1lcmdlIG9yaWdpbmFsIG9wdGlvbj9cbiAgICAgICAgICAgICAgICB6clV0aWwuZGVmYXVsdHMobmV3U2VyaWVzT3B0LCBzZXJpZXNNb2RlbC5vcHRpb24pO1xuICAgICAgICAgICAgICAgIG5ld09wdGlvbi5zZXJpZXMucHVzaChuZXdTZXJpZXNPcHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTW9kaWZ5IGJvdW5kYXJ5R2FwXG4gICAgICAgICAgICB2YXIgY29vcmRTeXMgPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICAgICAgICAgICAgaWYgKGNvb3JkU3lzICYmIGNvb3JkU3lzLnR5cGUgPT09ICdjYXJ0ZXNpYW4yZCcgJiYgKHR5cGUgPT09ICdsaW5lJyB8fCB0eXBlID09PSAnYmFyJykpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2F0ZWdvcnlBeGlzID0gY29vcmRTeXMuZ2V0QXhlc0J5U2NhbGUoJ29yZGluYWwnKVswXTtcbiAgICAgICAgICAgICAgICBpZiAoY2F0ZWdvcnlBeGlzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBheGlzRGltID0gY2F0ZWdvcnlBeGlzLmRpbTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGF4aXNUeXBlID0gYXhpc0RpbSArICdBeGlzJztcbiAgICAgICAgICAgICAgICAgICAgdmFyIGF4aXNNb2RlbCA9IGVjTW9kZWwucXVlcnlDb21wb25lbnRzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1haW5UeXBlOiBheGlzVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBzZXJpZXNNb2RlbC5nZXQobmFtZSArICdJbmRleCcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHNlcmllc01vZGVsLmdldChuYW1lICsgJ0lkJylcbiAgICAgICAgICAgICAgICAgICAgfSlbMF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBheGlzSW5kZXggPSBheGlzTW9kZWwuY29tcG9uZW50SW5kZXg7XG5cbiAgICAgICAgICAgICAgICAgICAgbmV3T3B0aW9uW2F4aXNUeXBlXSA9IG5ld09wdGlvbltheGlzVHlwZV0gfHwgW107XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IGF4aXNJbmRleDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdPcHRpb25bYXhpc1R5cGVdW2F4aXNJbmRleF0gPSBuZXdPcHRpb25bYXhpc1R5cGVdW2F4aXNJbmRleF0gfHwge307XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbmV3T3B0aW9uW2F4aXNUeXBlXVtheGlzSW5kZXhdLmJvdW5kYXJ5R2FwID0gdHlwZSA9PT0gJ2JhcicgPyB0cnVlIDogZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHpyVXRpbC5lYWNoKHJhZGlvVHlwZXMsIGZ1bmN0aW9uIChyYWRpbykge1xuICAgICAgICAgICAgaWYgKHpyVXRpbC5pbmRleE9mKHJhZGlvLCB0eXBlKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgenJVdGlsLmVhY2gocmFkaW8sIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLnNldEljb25TdGF0dXMoaXRlbSwgJ25vcm1hbCcpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBtb2RlbC5zZXRJY29uU3RhdHVzKHR5cGUsICdlbXBoYXNpcycpO1xuXG4gICAgICAgIGVjTW9kZWwuZWFjaENvbXBvbmVudChcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBtYWluVHlwZTogJ3NlcmllcycsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHNlcmllc0luZGV4ID09IG51bGwgPyBudWxsIDoge1xuICAgICAgICAgICAgICAgICAgICBzZXJpZXNJbmRleDogc2VyaWVzSW5kZXhcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBnZW5lcmF0ZU5ld1Nlcmllc1R5cGVzXG4gICAgICAgICk7XG4gICAgICAgIGFwaS5kaXNwYXRjaEFjdGlvbih7XG4gICAgICAgICAgICB0eXBlOiAnY2hhbmdlTWFnaWNUeXBlJyxcbiAgICAgICAgICAgIGN1cnJlbnRUeXBlOiB0eXBlLFxuICAgICAgICAgICAgbmV3T3B0aW9uOiBuZXdPcHRpb25cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHZhciBlY2hhcnRzID0gcmVxdWlyZSgnLi4vLi4vLi4vZWNoYXJ0cycpO1xuICAgIGVjaGFydHMucmVnaXN0ZXJBY3Rpb24oe1xuICAgICAgICB0eXBlOiAnY2hhbmdlTWFnaWNUeXBlJyxcbiAgICAgICAgZXZlbnQ6ICdtYWdpY1R5cGVDaGFuZ2VkJyxcbiAgICAgICAgdXBkYXRlOiAncHJlcGFyZUFuZFVwZGF0ZSdcbiAgICB9LCBmdW5jdGlvbiAocGF5bG9hZCwgZWNNb2RlbCkge1xuICAgICAgICBlY01vZGVsLm1lcmdlT3B0aW9uKHBheWxvYWQubmV3T3B0aW9uKTtcbiAgICB9KTtcblxuICAgIHJlcXVpcmUoJy4uL2ZlYXR1cmVNYW5hZ2VyJykucmVnaXN0ZXIoJ21hZ2ljVHlwZScsIE1hZ2ljVHlwZSk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IE1hZ2ljVHlwZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2NvbXBvbmVudC90b29sYm94L2ZlYXR1cmUvTWFnaWNUeXBlLmpzXG4vLyBtb2R1bGUgaWQgPSAyMzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 233 */
/* unknown exports provided */
/* all exports used */
/*!**************************************************!*\
  !*** ./lib/component/toolbox/feature/Restore.js ***!
  \**************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\n    var history = __webpack_require__(/*! ../../dataZoom/history */ 154);\n\n    function Restore(model) {\n        this.model = model;\n    }\n\n    Restore.defaultOption = {\n        show: true,\n        icon: 'M3.8,33.4 M47,18.9h9.8V8.7 M56.3,20.1 C52.1,9,40.5,0.6,26.8,2.1C12.6,3.7,1.6,16.2,2.1,30.6 M13,41.1H3.1v10.2 M3.7,39.9c4.2,11.1,15.8,19.5,29.5,18 c14.2-1.6,25.2-14.1,24.7-28.5',\n        title: '还原'\n    };\n\n    var proto = Restore.prototype;\n\n    proto.onclick = function (ecModel, api, type) {\n        history.clear(ecModel);\n\n        api.dispatchAction({\n            type: 'restore',\n            from: this.uid\n        });\n    };\n\n\n    __webpack_require__(/*! ../featureManager */ 28).register('restore', Restore);\n\n\n    __webpack_require__(/*! ../../../echarts */ 1).registerAction(\n        {type: 'restore', event: 'restore', update: 'prepareAndUpdate'},\n        function (payload, ecModel) {\n            ecModel.resetOption('recreate');\n        }\n    );\n\n    module.exports = Restore;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjMzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2NvbXBvbmVudC90b29sYm94L2ZlYXR1cmUvUmVzdG9yZS5qcz9iNDY4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuXG4gICAgdmFyIGhpc3RvcnkgPSByZXF1aXJlKCcuLi8uLi9kYXRhWm9vbS9oaXN0b3J5Jyk7XG5cbiAgICBmdW5jdGlvbiBSZXN0b3JlKG1vZGVsKSB7XG4gICAgICAgIHRoaXMubW9kZWwgPSBtb2RlbDtcbiAgICB9XG5cbiAgICBSZXN0b3JlLmRlZmF1bHRPcHRpb24gPSB7XG4gICAgICAgIHNob3c6IHRydWUsXG4gICAgICAgIGljb246ICdNMy44LDMzLjQgTTQ3LDE4LjloOS44VjguNyBNNTYuMywyMC4xIEM1Mi4xLDksNDAuNSwwLjYsMjYuOCwyLjFDMTIuNiwzLjcsMS42LDE2LjIsMi4xLDMwLjYgTTEzLDQxLjFIMy4xdjEwLjIgTTMuNywzOS45YzQuMiwxMS4xLDE1LjgsMTkuNSwyOS41LDE4IGMxNC4yLTEuNiwyNS4yLTE0LjEsMjQuNy0yOC41JyxcbiAgICAgICAgdGl0bGU6ICfov5jljp8nXG4gICAgfTtcblxuICAgIHZhciBwcm90byA9IFJlc3RvcmUucHJvdG90eXBlO1xuXG4gICAgcHJvdG8ub25jbGljayA9IGZ1bmN0aW9uIChlY01vZGVsLCBhcGksIHR5cGUpIHtcbiAgICAgICAgaGlzdG9yeS5jbGVhcihlY01vZGVsKTtcblxuICAgICAgICBhcGkuZGlzcGF0Y2hBY3Rpb24oe1xuICAgICAgICAgICAgdHlwZTogJ3Jlc3RvcmUnLFxuICAgICAgICAgICAgZnJvbTogdGhpcy51aWRcbiAgICAgICAgfSk7XG4gICAgfTtcblxuXG4gICAgcmVxdWlyZSgnLi4vZmVhdHVyZU1hbmFnZXInKS5yZWdpc3RlcigncmVzdG9yZScsIFJlc3RvcmUpO1xuXG5cbiAgICByZXF1aXJlKCcuLi8uLi8uLi9lY2hhcnRzJykucmVnaXN0ZXJBY3Rpb24oXG4gICAgICAgIHt0eXBlOiAncmVzdG9yZScsIGV2ZW50OiAncmVzdG9yZScsIHVwZGF0ZTogJ3ByZXBhcmVBbmRVcGRhdGUnfSxcbiAgICAgICAgZnVuY3Rpb24gKHBheWxvYWQsIGVjTW9kZWwpIHtcbiAgICAgICAgICAgIGVjTW9kZWwucmVzZXRPcHRpb24oJ3JlY3JlYXRlJyk7XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBSZXN0b3JlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvY29tcG9uZW50L3Rvb2xib3gvZmVhdHVyZS9SZXN0b3JlLmpzXG4vLyBtb2R1bGUgaWQgPSAyMzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 234 */
/* unknown exports provided */
/* all exports used */
/*!******************************************************!*\
  !*** ./lib/component/toolbox/feature/SaveAsImage.js ***!
  \******************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var env = __webpack_require__(/*! zrender/lib/core/env */ 8);\n\n    function SaveAsImage (model) {\n        this.model = model;\n    }\n\n    SaveAsImage.defaultOption = {\n        show: true,\n        icon: 'M4.7,22.9L29.3,45.5L54.7,23.4M4.6,43.6L4.6,58L53.8,58L53.8,43.6M29.2,45.1L29.2,0',\n        title: '保存为图片',\n        type: 'png',\n        // Default use option.backgroundColor\n        // backgroundColor: '#fff',\n        name: '',\n        excludeComponents: ['toolbox'],\n        pixelRatio: 1,\n        lang: ['右键另存为图片']\n    };\n\n    SaveAsImage.prototype.unusable = !env.canvasSupported;\n\n    var proto = SaveAsImage.prototype;\n\n    proto.onclick = function (ecModel, api) {\n        var model = this.model;\n        var title = model.get('name') || ecModel.get('title.0.text') || 'echarts';\n        var $a = document.createElement('a');\n        var type = model.get('type', true) || 'png';\n        $a.download = title + '.' + type;\n        $a.target = '_blank';\n        var url = api.getConnectedDataURL({\n            type: type,\n            backgroundColor: model.get('backgroundColor', true)\n                || ecModel.get('backgroundColor') || '#fff',\n            excludeComponents: model.get('excludeComponents'),\n            pixelRatio: model.get('pixelRatio')\n        });\n        $a.href = url;\n        // Chrome and Firefox\n        if (typeof MouseEvent === 'function' && !env.browser.ie && !env.browser.edge) {\n            var evt = new MouseEvent('click', {\n                view: window,\n                bubbles: true,\n                cancelable: false\n            });\n            $a.dispatchEvent(evt);\n        }\n        // IE\n        else {\n            var lang = model.get('lang');\n            var html = ''\n                + '<body style=\"margin:0;\">'\n                + '<img src=\"' + url + '\" style=\"max-width:100%;\" title=\"' + ((lang && lang[0]) || '') + '\" />'\n                + '</body>';\n            var tab = window.open();\n            tab.document.write(html);\n        }\n    };\n\n    __webpack_require__(/*! ../featureManager */ 28).register(\n        'saveAsImage', SaveAsImage\n    );\n\n    module.exports = SaveAsImage;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjM0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2NvbXBvbmVudC90b29sYm94L2ZlYXR1cmUvU2F2ZUFzSW1hZ2UuanM/MTFhNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcblxuICAgIHZhciBlbnYgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL2VudicpO1xuXG4gICAgZnVuY3Rpb24gU2F2ZUFzSW1hZ2UgKG1vZGVsKSB7XG4gICAgICAgIHRoaXMubW9kZWwgPSBtb2RlbDtcbiAgICB9XG5cbiAgICBTYXZlQXNJbWFnZS5kZWZhdWx0T3B0aW9uID0ge1xuICAgICAgICBzaG93OiB0cnVlLFxuICAgICAgICBpY29uOiAnTTQuNywyMi45TDI5LjMsNDUuNUw1NC43LDIzLjRNNC42LDQzLjZMNC42LDU4TDUzLjgsNThMNTMuOCw0My42TTI5LjIsNDUuMUwyOS4yLDAnLFxuICAgICAgICB0aXRsZTogJ+S/neWtmOS4uuWbvueJhycsXG4gICAgICAgIHR5cGU6ICdwbmcnLFxuICAgICAgICAvLyBEZWZhdWx0IHVzZSBvcHRpb24uYmFja2dyb3VuZENvbG9yXG4gICAgICAgIC8vIGJhY2tncm91bmRDb2xvcjogJyNmZmYnLFxuICAgICAgICBuYW1lOiAnJyxcbiAgICAgICAgZXhjbHVkZUNvbXBvbmVudHM6IFsndG9vbGJveCddLFxuICAgICAgICBwaXhlbFJhdGlvOiAxLFxuICAgICAgICBsYW5nOiBbJ+WPs+mUruWPpuWtmOS4uuWbvueJhyddXG4gICAgfTtcblxuICAgIFNhdmVBc0ltYWdlLnByb3RvdHlwZS51bnVzYWJsZSA9ICFlbnYuY2FudmFzU3VwcG9ydGVkO1xuXG4gICAgdmFyIHByb3RvID0gU2F2ZUFzSW1hZ2UucHJvdG90eXBlO1xuXG4gICAgcHJvdG8ub25jbGljayA9IGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHtcbiAgICAgICAgdmFyIG1vZGVsID0gdGhpcy5tb2RlbDtcbiAgICAgICAgdmFyIHRpdGxlID0gbW9kZWwuZ2V0KCduYW1lJykgfHwgZWNNb2RlbC5nZXQoJ3RpdGxlLjAudGV4dCcpIHx8ICdlY2hhcnRzJztcbiAgICAgICAgdmFyICRhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgICAgICB2YXIgdHlwZSA9IG1vZGVsLmdldCgndHlwZScsIHRydWUpIHx8ICdwbmcnO1xuICAgICAgICAkYS5kb3dubG9hZCA9IHRpdGxlICsgJy4nICsgdHlwZTtcbiAgICAgICAgJGEudGFyZ2V0ID0gJ19ibGFuayc7XG4gICAgICAgIHZhciB1cmwgPSBhcGkuZ2V0Q29ubmVjdGVkRGF0YVVSTCh7XG4gICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBtb2RlbC5nZXQoJ2JhY2tncm91bmRDb2xvcicsIHRydWUpXG4gICAgICAgICAgICAgICAgfHwgZWNNb2RlbC5nZXQoJ2JhY2tncm91bmRDb2xvcicpIHx8ICcjZmZmJyxcbiAgICAgICAgICAgIGV4Y2x1ZGVDb21wb25lbnRzOiBtb2RlbC5nZXQoJ2V4Y2x1ZGVDb21wb25lbnRzJyksXG4gICAgICAgICAgICBwaXhlbFJhdGlvOiBtb2RlbC5nZXQoJ3BpeGVsUmF0aW8nKVxuICAgICAgICB9KTtcbiAgICAgICAgJGEuaHJlZiA9IHVybDtcbiAgICAgICAgLy8gQ2hyb21lIGFuZCBGaXJlZm94XG4gICAgICAgIGlmICh0eXBlb2YgTW91c2VFdmVudCA9PT0gJ2Z1bmN0aW9uJyAmJiAhZW52LmJyb3dzZXIuaWUgJiYgIWVudi5icm93c2VyLmVkZ2UpIHtcbiAgICAgICAgICAgIHZhciBldnQgPSBuZXcgTW91c2VFdmVudCgnY2xpY2snLCB7XG4gICAgICAgICAgICAgICAgdmlldzogd2luZG93LFxuICAgICAgICAgICAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICAgICAgICAgICAgY2FuY2VsYWJsZTogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgJGEuZGlzcGF0Y2hFdmVudChldnQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElFXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGxhbmcgPSBtb2RlbC5nZXQoJ2xhbmcnKTtcbiAgICAgICAgICAgIHZhciBodG1sID0gJydcbiAgICAgICAgICAgICAgICArICc8Ym9keSBzdHlsZT1cIm1hcmdpbjowO1wiPidcbiAgICAgICAgICAgICAgICArICc8aW1nIHNyYz1cIicgKyB1cmwgKyAnXCIgc3R5bGU9XCJtYXgtd2lkdGg6MTAwJTtcIiB0aXRsZT1cIicgKyAoKGxhbmcgJiYgbGFuZ1swXSkgfHwgJycpICsgJ1wiIC8+J1xuICAgICAgICAgICAgICAgICsgJzwvYm9keT4nO1xuICAgICAgICAgICAgdmFyIHRhYiA9IHdpbmRvdy5vcGVuKCk7XG4gICAgICAgICAgICB0YWIuZG9jdW1lbnQud3JpdGUoaHRtbCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcmVxdWlyZSgnLi4vZmVhdHVyZU1hbmFnZXInKS5yZWdpc3RlcihcbiAgICAgICAgJ3NhdmVBc0ltYWdlJywgU2F2ZUFzSW1hZ2VcbiAgICApO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBTYXZlQXNJbWFnZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2NvbXBvbmVudC90b29sYm94L2ZlYXR1cmUvU2F2ZUFzSW1hZ2UuanNcbi8vIG1vZHVsZSBpZCA9IDIzNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 235 */
/* unknown exports provided */
/* all exports used */
/*!*************************************************!*\
  !*** ./lib/component/tooltip/TooltipContent.js ***!
  \*************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * @module echarts/component/tooltip/TooltipContent\n */\n\n\n    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 0);\n    var zrColor = __webpack_require__(/*! zrender/lib/tool/color */ 21);\n    var eventUtil = __webpack_require__(/*! zrender/lib/core/event */ 20);\n    var formatUtil = __webpack_require__(/*! ../../util/format */ 6);\n    var each = zrUtil.each;\n    var toCamelCase = formatUtil.toCamelCase;\n    var env = __webpack_require__(/*! zrender/lib/core/env */ 8);\n\n    var vendors = ['', '-webkit-', '-moz-', '-o-'];\n\n    var gCssText = 'position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;';\n\n    /**\n     * @param {number} duration\n     * @return {string}\n     * @inner\n     */\n    function assembleTransition(duration) {\n        var transitionCurve = 'cubic-bezier(0.23, 1, 0.32, 1)';\n        var transitionText = 'left ' + duration + 's ' + transitionCurve + ','\n                            + 'top ' + duration + 's ' + transitionCurve;\n        return zrUtil.map(vendors, function (vendorPrefix) {\n            return vendorPrefix + 'transition:' + transitionText;\n        }).join(';');\n    }\n\n    /**\n     * @param {Object} textStyle\n     * @return {string}\n     * @inner\n     */\n    function assembleFont(textStyleModel) {\n        var cssText = [];\n\n        var fontSize = textStyleModel.get('fontSize');\n        var color = textStyleModel.getTextColor();\n\n        color && cssText.push('color:' + color);\n\n        cssText.push('font:' + textStyleModel.getFont());\n\n        fontSize &&\n            cssText.push('line-height:' + Math.round(fontSize * 3 / 2) + 'px');\n\n        each(['decoration', 'align'], function (name) {\n            var val = textStyleModel.get(name);\n            val && cssText.push('text-' + name + ':' + val);\n        });\n\n        return cssText.join(';');\n    }\n\n    /**\n     * @param {Object} tooltipModel\n     * @return {string}\n     * @inner\n     */\n    function assembleCssText(tooltipModel) {\n\n        var cssText = [];\n\n        var transitionDuration = tooltipModel.get('transitionDuration');\n        var backgroundColor = tooltipModel.get('backgroundColor');\n        var textStyleModel = tooltipModel.getModel('textStyle');\n        var padding = tooltipModel.get('padding');\n\n        // Animation transition. Do not animate when transitionDuration is 0.\n        transitionDuration &&\n            cssText.push(assembleTransition(transitionDuration));\n\n        if (backgroundColor) {\n            if (env.canvasSupported) {\n                cssText.push('background-Color:' + backgroundColor);\n            }\n            else {\n                // for ie\n                cssText.push(\n                    'background-Color:#' + zrColor.toHex(backgroundColor)\n                );\n                cssText.push('filter:alpha(opacity=70)');\n            }\n        }\n\n        // Border style\n        each(['width', 'color', 'radius'], function (name) {\n            var borderName = 'border-' + name;\n            var camelCase = toCamelCase(borderName);\n            var val = tooltipModel.get(camelCase);\n            val != null &&\n                cssText.push(borderName + ':' + val + (name === 'color' ? '' : 'px'));\n        });\n\n        // Text style\n        cssText.push(assembleFont(textStyleModel));\n\n        // Padding\n        if (padding != null) {\n            cssText.push('padding:' + formatUtil.normalizeCssArray(padding).join('px ') + 'px');\n        }\n\n        return cssText.join(';') + ';';\n    }\n\n    /**\n     * @alias module:echarts/component/tooltip/TooltipContent\n     * @constructor\n     */\n    function TooltipContent(container, api) {\n        var el = document.createElement('div');\n        var zr = this._zr = api.getZr();\n\n        this.el = el;\n\n        this._x = api.getWidth() / 2;\n        this._y = api.getHeight() / 2;\n\n        container.appendChild(el);\n\n        this._container = container;\n\n        this._show = false;\n\n        /**\n         * @private\n         */\n        this._hideTimeout;\n\n        var self = this;\n        el.onmouseenter = function () {\n            // clear the timeout in hideLater and keep showing tooltip\n            if (self._enterable) {\n                clearTimeout(self._hideTimeout);\n                self._show = true;\n            }\n            self._inContent = true;\n        };\n        el.onmousemove = function (e) {\n            e = e || window.event;\n            if (!self._enterable) {\n                // Try trigger zrender event to avoid mouse\n                // in and out shape too frequently\n                var handler = zr.handler;\n                eventUtil.normalizeEvent(container, e, true);\n                handler.dispatch('mousemove', e);\n            }\n        };\n        el.onmouseleave = function () {\n            if (self._enterable) {\n                if (self._show) {\n                    self.hideLater(self._hideDelay);\n                }\n            }\n            self._inContent = false;\n        };\n    }\n\n    TooltipContent.prototype = {\n\n        constructor: TooltipContent,\n\n        /**\n         * @private\n         * @type {boolean}\n         */\n        _enterable: true,\n\n        /**\n         * Update when tooltip is rendered\n         */\n        update: function () {\n            // FIXME\n            // Move this logic to ec main?\n            var container = this._container;\n            var stl = container.currentStyle\n                || document.defaultView.getComputedStyle(container);\n            var domStyle = container.style;\n            if (domStyle.position !== 'absolute' && stl.position !== 'absolute') {\n                domStyle.position = 'relative';\n            }\n            // Hide the tooltip\n            // PENDING\n            // this.hide();\n        },\n\n        show: function (tooltipModel) {\n            clearTimeout(this._hideTimeout);\n            var el = this.el;\n\n            el.style.cssText = gCssText + assembleCssText(tooltipModel)\n                // http://stackoverflow.com/questions/21125587/css3-transition-not-working-in-chrome-anymore\n                + ';left:' + this._x + 'px;top:' + this._y + 'px;'\n                + (tooltipModel.get('extraCssText') || '');\n\n            el.style.display = el.innerHTML ?  'block' : 'none';\n\n            this._show = true;\n        },\n\n        setContent: function (content) {\n            this.el.innerHTML = content == null ? '' : content;\n        },\n\n        setEnterable: function (enterable) {\n            this._enterable = enterable;\n        },\n\n        getSize: function () {\n            var el = this.el;\n            return [el.clientWidth, el.clientHeight];\n        },\n\n        moveTo: function (x, y) {\n            // xy should be based on canvas root. But tooltipContent is\n            // the sibling of canvas root. So padding of ec container\n            // should be considered here.\n            var zr = this._zr;\n            var viewportRoot;\n            if (zr && zr.painter && (viewportRoot = zr.painter.getViewportRoot())) {\n                x += viewportRoot.offsetLeft || 0;\n                y += viewportRoot.offsetTop || 0;\n            }\n\n            var style = this.el.style;\n            style.left = x + 'px';\n            style.top = y + 'px';\n\n            this._x = x;\n            this._y = y;\n        },\n\n        hide: function () {\n            this.el.style.display = 'none';\n            this._show = false;\n        },\n\n        hideLater: function (time) {\n            if (this._show && !(this._inContent && this._enterable)) {\n                if (time) {\n                    this._hideDelay = time;\n                    // Set show false to avoid invoke hideLater mutiple times\n                    this._show = false;\n                    this._hideTimeout = setTimeout(zrUtil.bind(this.hide, this), time);\n                }\n                else {\n                    this.hide();\n                }\n            }\n        },\n\n        isShow: function () {\n            return this._show;\n        }\n    };\n\n    module.exports = TooltipContent;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjM1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2NvbXBvbmVudC90b29sdGlwL1Rvb2x0aXBDb250ZW50LmpzPzY2YjUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9kdWxlIGVjaGFydHMvY29tcG9uZW50L3Rvb2x0aXAvVG9vbHRpcENvbnRlbnRcbiAqL1xuXG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XG4gICAgdmFyIHpyQ29sb3IgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi90b29sL2NvbG9yJyk7XG4gICAgdmFyIGV2ZW50VXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvZXZlbnQnKTtcbiAgICB2YXIgZm9ybWF0VXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvZm9ybWF0Jyk7XG4gICAgdmFyIGVhY2ggPSB6clV0aWwuZWFjaDtcbiAgICB2YXIgdG9DYW1lbENhc2UgPSBmb3JtYXRVdGlsLnRvQ2FtZWxDYXNlO1xuICAgIHZhciBlbnYgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL2VudicpO1xuXG4gICAgdmFyIHZlbmRvcnMgPSBbJycsICctd2Via2l0LScsICctbW96LScsICctby0nXTtcblxuICAgIHZhciBnQ3NzVGV4dCA9ICdwb3NpdGlvbjphYnNvbHV0ZTtkaXNwbGF5OmJsb2NrO2JvcmRlci1zdHlsZTpzb2xpZDt3aGl0ZS1zcGFjZTpub3dyYXA7ei1pbmRleDo5OTk5OTk5Oyc7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZHVyYXRpb25cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXNzZW1ibGVUcmFuc2l0aW9uKGR1cmF0aW9uKSB7XG4gICAgICAgIHZhciB0cmFuc2l0aW9uQ3VydmUgPSAnY3ViaWMtYmV6aWVyKDAuMjMsIDEsIDAuMzIsIDEpJztcbiAgICAgICAgdmFyIHRyYW5zaXRpb25UZXh0ID0gJ2xlZnQgJyArIGR1cmF0aW9uICsgJ3MgJyArIHRyYW5zaXRpb25DdXJ2ZSArICcsJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgJ3RvcCAnICsgZHVyYXRpb24gKyAncyAnICsgdHJhbnNpdGlvbkN1cnZlO1xuICAgICAgICByZXR1cm4genJVdGlsLm1hcCh2ZW5kb3JzLCBmdW5jdGlvbiAodmVuZG9yUHJlZml4KSB7XG4gICAgICAgICAgICByZXR1cm4gdmVuZG9yUHJlZml4ICsgJ3RyYW5zaXRpb246JyArIHRyYW5zaXRpb25UZXh0O1xuICAgICAgICB9KS5qb2luKCc7Jyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRleHRTdHlsZVxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhc3NlbWJsZUZvbnQodGV4dFN0eWxlTW9kZWwpIHtcbiAgICAgICAgdmFyIGNzc1RleHQgPSBbXTtcblxuICAgICAgICB2YXIgZm9udFNpemUgPSB0ZXh0U3R5bGVNb2RlbC5nZXQoJ2ZvbnRTaXplJyk7XG4gICAgICAgIHZhciBjb2xvciA9IHRleHRTdHlsZU1vZGVsLmdldFRleHRDb2xvcigpO1xuXG4gICAgICAgIGNvbG9yICYmIGNzc1RleHQucHVzaCgnY29sb3I6JyArIGNvbG9yKTtcblxuICAgICAgICBjc3NUZXh0LnB1c2goJ2ZvbnQ6JyArIHRleHRTdHlsZU1vZGVsLmdldEZvbnQoKSk7XG5cbiAgICAgICAgZm9udFNpemUgJiZcbiAgICAgICAgICAgIGNzc1RleHQucHVzaCgnbGluZS1oZWlnaHQ6JyArIE1hdGgucm91bmQoZm9udFNpemUgKiAzIC8gMikgKyAncHgnKTtcblxuICAgICAgICBlYWNoKFsnZGVjb3JhdGlvbicsICdhbGlnbiddLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgdmFyIHZhbCA9IHRleHRTdHlsZU1vZGVsLmdldChuYW1lKTtcbiAgICAgICAgICAgIHZhbCAmJiBjc3NUZXh0LnB1c2goJ3RleHQtJyArIG5hbWUgKyAnOicgKyB2YWwpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gY3NzVGV4dC5qb2luKCc7Jyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRvb2x0aXBNb2RlbFxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhc3NlbWJsZUNzc1RleHQodG9vbHRpcE1vZGVsKSB7XG5cbiAgICAgICAgdmFyIGNzc1RleHQgPSBbXTtcblxuICAgICAgICB2YXIgdHJhbnNpdGlvbkR1cmF0aW9uID0gdG9vbHRpcE1vZGVsLmdldCgndHJhbnNpdGlvbkR1cmF0aW9uJyk7XG4gICAgICAgIHZhciBiYWNrZ3JvdW5kQ29sb3IgPSB0b29sdGlwTW9kZWwuZ2V0KCdiYWNrZ3JvdW5kQ29sb3InKTtcbiAgICAgICAgdmFyIHRleHRTdHlsZU1vZGVsID0gdG9vbHRpcE1vZGVsLmdldE1vZGVsKCd0ZXh0U3R5bGUnKTtcbiAgICAgICAgdmFyIHBhZGRpbmcgPSB0b29sdGlwTW9kZWwuZ2V0KCdwYWRkaW5nJyk7XG5cbiAgICAgICAgLy8gQW5pbWF0aW9uIHRyYW5zaXRpb24uIERvIG5vdCBhbmltYXRlIHdoZW4gdHJhbnNpdGlvbkR1cmF0aW9uIGlzIDAuXG4gICAgICAgIHRyYW5zaXRpb25EdXJhdGlvbiAmJlxuICAgICAgICAgICAgY3NzVGV4dC5wdXNoKGFzc2VtYmxlVHJhbnNpdGlvbih0cmFuc2l0aW9uRHVyYXRpb24pKTtcblxuICAgICAgICBpZiAoYmFja2dyb3VuZENvbG9yKSB7XG4gICAgICAgICAgICBpZiAoZW52LmNhbnZhc1N1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgIGNzc1RleHQucHVzaCgnYmFja2dyb3VuZC1Db2xvcjonICsgYmFja2dyb3VuZENvbG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGZvciBpZVxuICAgICAgICAgICAgICAgIGNzc1RleHQucHVzaChcbiAgICAgICAgICAgICAgICAgICAgJ2JhY2tncm91bmQtQ29sb3I6IycgKyB6ckNvbG9yLnRvSGV4KGJhY2tncm91bmRDb2xvcilcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGNzc1RleHQucHVzaCgnZmlsdGVyOmFscGhhKG9wYWNpdHk9NzApJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCb3JkZXIgc3R5bGVcbiAgICAgICAgZWFjaChbJ3dpZHRoJywgJ2NvbG9yJywgJ3JhZGl1cyddLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgdmFyIGJvcmRlck5hbWUgPSAnYm9yZGVyLScgKyBuYW1lO1xuICAgICAgICAgICAgdmFyIGNhbWVsQ2FzZSA9IHRvQ2FtZWxDYXNlKGJvcmRlck5hbWUpO1xuICAgICAgICAgICAgdmFyIHZhbCA9IHRvb2x0aXBNb2RlbC5nZXQoY2FtZWxDYXNlKTtcbiAgICAgICAgICAgIHZhbCAhPSBudWxsICYmXG4gICAgICAgICAgICAgICAgY3NzVGV4dC5wdXNoKGJvcmRlck5hbWUgKyAnOicgKyB2YWwgKyAobmFtZSA9PT0gJ2NvbG9yJyA/ICcnIDogJ3B4JykpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBUZXh0IHN0eWxlXG4gICAgICAgIGNzc1RleHQucHVzaChhc3NlbWJsZUZvbnQodGV4dFN0eWxlTW9kZWwpKTtcblxuICAgICAgICAvLyBQYWRkaW5nXG4gICAgICAgIGlmIChwYWRkaW5nICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNzc1RleHQucHVzaCgncGFkZGluZzonICsgZm9ybWF0VXRpbC5ub3JtYWxpemVDc3NBcnJheShwYWRkaW5nKS5qb2luKCdweCAnKSArICdweCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNzc1RleHQuam9pbignOycpICsgJzsnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBhbGlhcyBtb2R1bGU6ZWNoYXJ0cy9jb21wb25lbnQvdG9vbHRpcC9Ub29sdGlwQ29udGVudFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFRvb2x0aXBDb250ZW50KGNvbnRhaW5lciwgYXBpKSB7XG4gICAgICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB2YXIgenIgPSB0aGlzLl96ciA9IGFwaS5nZXRacigpO1xuXG4gICAgICAgIHRoaXMuZWwgPSBlbDtcblxuICAgICAgICB0aGlzLl94ID0gYXBpLmdldFdpZHRoKCkgLyAyO1xuICAgICAgICB0aGlzLl95ID0gYXBpLmdldEhlaWdodCgpIC8gMjtcblxuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZWwpO1xuXG4gICAgICAgIHRoaXMuX2NvbnRhaW5lciA9IGNvbnRhaW5lcjtcblxuICAgICAgICB0aGlzLl9zaG93ID0gZmFsc2U7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9oaWRlVGltZW91dDtcblxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIGVsLm9ubW91c2VlbnRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIGNsZWFyIHRoZSB0aW1lb3V0IGluIGhpZGVMYXRlciBhbmQga2VlcCBzaG93aW5nIHRvb2x0aXBcbiAgICAgICAgICAgIGlmIChzZWxmLl9lbnRlcmFibGUpIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoc2VsZi5faGlkZVRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIHNlbGYuX3Nob3cgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5faW5Db250ZW50ID0gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgZWwub25tb3VzZW1vdmUgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZSA9IGUgfHwgd2luZG93LmV2ZW50O1xuICAgICAgICAgICAgaWYgKCFzZWxmLl9lbnRlcmFibGUpIHtcbiAgICAgICAgICAgICAgICAvLyBUcnkgdHJpZ2dlciB6cmVuZGVyIGV2ZW50IHRvIGF2b2lkIG1vdXNlXG4gICAgICAgICAgICAgICAgLy8gaW4gYW5kIG91dCBzaGFwZSB0b28gZnJlcXVlbnRseVxuICAgICAgICAgICAgICAgIHZhciBoYW5kbGVyID0genIuaGFuZGxlcjtcbiAgICAgICAgICAgICAgICBldmVudFV0aWwubm9ybWFsaXplRXZlbnQoY29udGFpbmVyLCBlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBoYW5kbGVyLmRpc3BhdGNoKCdtb3VzZW1vdmUnLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZWwub25tb3VzZWxlYXZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHNlbGYuX2VudGVyYWJsZSkge1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLl9zaG93KSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuaGlkZUxhdGVyKHNlbGYuX2hpZGVEZWxheSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5faW5Db250ZW50ID0gZmFsc2U7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgVG9vbHRpcENvbnRlbnQucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBUb29sdGlwQ29udGVudCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBfZW50ZXJhYmxlOiB0cnVlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGUgd2hlbiB0b29sdGlwIGlzIHJlbmRlcmVkXG4gICAgICAgICAqL1xuICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIEZJWE1FXG4gICAgICAgICAgICAvLyBNb3ZlIHRoaXMgbG9naWMgdG8gZWMgbWFpbj9cbiAgICAgICAgICAgIHZhciBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXI7XG4gICAgICAgICAgICB2YXIgc3RsID0gY29udGFpbmVyLmN1cnJlbnRTdHlsZVxuICAgICAgICAgICAgICAgIHx8IGRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUoY29udGFpbmVyKTtcbiAgICAgICAgICAgIHZhciBkb21TdHlsZSA9IGNvbnRhaW5lci5zdHlsZTtcbiAgICAgICAgICAgIGlmIChkb21TdHlsZS5wb3NpdGlvbiAhPT0gJ2Fic29sdXRlJyAmJiBzdGwucG9zaXRpb24gIT09ICdhYnNvbHV0ZScpIHtcbiAgICAgICAgICAgICAgICBkb21TdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBIaWRlIHRoZSB0b29sdGlwXG4gICAgICAgICAgICAvLyBQRU5ESU5HXG4gICAgICAgICAgICAvLyB0aGlzLmhpZGUoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBzaG93OiBmdW5jdGlvbiAodG9vbHRpcE1vZGVsKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5faGlkZVRpbWVvdXQpO1xuICAgICAgICAgICAgdmFyIGVsID0gdGhpcy5lbDtcblxuICAgICAgICAgICAgZWwuc3R5bGUuY3NzVGV4dCA9IGdDc3NUZXh0ICsgYXNzZW1ibGVDc3NUZXh0KHRvb2x0aXBNb2RlbClcbiAgICAgICAgICAgICAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzIxMTI1NTg3L2NzczMtdHJhbnNpdGlvbi1ub3Qtd29ya2luZy1pbi1jaHJvbWUtYW55bW9yZVxuICAgICAgICAgICAgICAgICsgJztsZWZ0OicgKyB0aGlzLl94ICsgJ3B4O3RvcDonICsgdGhpcy5feSArICdweDsnXG4gICAgICAgICAgICAgICAgKyAodG9vbHRpcE1vZGVsLmdldCgnZXh0cmFDc3NUZXh0JykgfHwgJycpO1xuXG4gICAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gZWwuaW5uZXJIVE1MID8gICdibG9jaycgOiAnbm9uZSc7XG5cbiAgICAgICAgICAgIHRoaXMuX3Nob3cgPSB0cnVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldENvbnRlbnQ6IGZ1bmN0aW9uIChjb250ZW50KSB7XG4gICAgICAgICAgICB0aGlzLmVsLmlubmVySFRNTCA9IGNvbnRlbnQgPT0gbnVsbCA/ICcnIDogY29udGVudDtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXRFbnRlcmFibGU6IGZ1bmN0aW9uIChlbnRlcmFibGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2VudGVyYWJsZSA9IGVudGVyYWJsZTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRTaXplOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZWwgPSB0aGlzLmVsO1xuICAgICAgICAgICAgcmV0dXJuIFtlbC5jbGllbnRXaWR0aCwgZWwuY2xpZW50SGVpZ2h0XTtcbiAgICAgICAgfSxcblxuICAgICAgICBtb3ZlVG86IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICAvLyB4eSBzaG91bGQgYmUgYmFzZWQgb24gY2FudmFzIHJvb3QuIEJ1dCB0b29sdGlwQ29udGVudCBpc1xuICAgICAgICAgICAgLy8gdGhlIHNpYmxpbmcgb2YgY2FudmFzIHJvb3QuIFNvIHBhZGRpbmcgb2YgZWMgY29udGFpbmVyXG4gICAgICAgICAgICAvLyBzaG91bGQgYmUgY29uc2lkZXJlZCBoZXJlLlxuICAgICAgICAgICAgdmFyIHpyID0gdGhpcy5fenI7XG4gICAgICAgICAgICB2YXIgdmlld3BvcnRSb290O1xuICAgICAgICAgICAgaWYgKHpyICYmIHpyLnBhaW50ZXIgJiYgKHZpZXdwb3J0Um9vdCA9IHpyLnBhaW50ZXIuZ2V0Vmlld3BvcnRSb290KCkpKSB7XG4gICAgICAgICAgICAgICAgeCArPSB2aWV3cG9ydFJvb3Qub2Zmc2V0TGVmdCB8fCAwO1xuICAgICAgICAgICAgICAgIHkgKz0gdmlld3BvcnRSb290Lm9mZnNldFRvcCB8fCAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLmVsLnN0eWxlO1xuICAgICAgICAgICAgc3R5bGUubGVmdCA9IHggKyAncHgnO1xuICAgICAgICAgICAgc3R5bGUudG9wID0geSArICdweCc7XG5cbiAgICAgICAgICAgIHRoaXMuX3ggPSB4O1xuICAgICAgICAgICAgdGhpcy5feSA9IHk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGlkZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5lbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgdGhpcy5fc2hvdyA9IGZhbHNlO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhpZGVMYXRlcjogZnVuY3Rpb24gKHRpbWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zaG93ICYmICEodGhpcy5faW5Db250ZW50ICYmIHRoaXMuX2VudGVyYWJsZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAodGltZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9oaWRlRGVsYXkgPSB0aW1lO1xuICAgICAgICAgICAgICAgICAgICAvLyBTZXQgc2hvdyBmYWxzZSB0byBhdm9pZCBpbnZva2UgaGlkZUxhdGVyIG11dGlwbGUgdGltZXNcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2hvdyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9oaWRlVGltZW91dCA9IHNldFRpbWVvdXQoenJVdGlsLmJpbmQodGhpcy5oaWRlLCB0aGlzKSwgdGltZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNTaG93OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2hvdztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFRvb2x0aXBDb250ZW50O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvY29tcG9uZW50L3Rvb2x0aXAvVG9vbHRpcENvbnRlbnQuanNcbi8vIG1vZHVsZSBpZCA9IDIzNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 236 */
/* unknown exports provided */
/* all exports used */
/*!***********************************************!*\
  !*** ./lib/component/tooltip/TooltipModel.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    __webpack_require__(/*! ../../echarts */ 1).extendComponentModel({\n\n        type: 'tooltip',\n\n        dependencies: ['axisPointer'],\n\n        defaultOption: {\n            zlevel: 0,\n\n            z: 8,\n\n            show: true,\n\n            // tooltip主体内容\n            showContent: true,\n\n            // 'trigger' only works on coordinate system.\n            // 'item' | 'axis' | 'none'\n            trigger: 'item',\n\n            // 'click' | 'mousemove' | 'none'\n            triggerOn: 'mousemove|click',\n\n            alwaysShowContent: false,\n\n            displayMode: 'single', // 'single' | 'multipleByCoordSys'\n\n            // 位置 {Array} | {Function}\n            // position: null\n            // Consider triggered from axisPointer handle, verticalAlign should be 'middle'\n            // align: null,\n            // verticalAlign: null,\n\n            // 是否约束 content 在 viewRect 中。默认 false 是为了兼容以前版本。\n            confine: false,\n\n            // 内容格式器：{string}（Template） ¦ {Function}\n            // formatter: null\n\n            showDelay: 0,\n\n            // 隐藏延迟，单位ms\n            hideDelay: 100,\n\n            // 动画变换时间，单位s\n            transitionDuration: 0.4,\n\n            enterable: false,\n\n            // 提示背景颜色，默认为透明度为0.7的黑色\n            backgroundColor: 'rgba(50,50,50,0.7)',\n\n            // 提示边框颜色\n            borderColor: '#333',\n\n            // 提示边框圆角，单位px，默认为4\n            borderRadius: 4,\n\n            // 提示边框线宽，单位px，默认为0（无边框）\n            borderWidth: 0,\n\n            // 提示内边距，单位px，默认各方向内边距为5，\n            // 接受数组分别设定上右下左边距，同css\n            padding: 5,\n\n            // Extra css text\n            extraCssText: '',\n\n            // 坐标轴指示器，坐标轴触发有效\n            axisPointer: {\n                // 默认为直线\n                // 可选为：'line' | 'shadow' | 'cross'\n                type: 'line',\n\n                // type 为 line 的时候有效，指定 tooltip line 所在的轴，可选\n                // 可选 'x' | 'y' | 'angle' | 'radius' | 'auto'\n                // 默认 'auto'，会选择类型为 cateogry 的轴，对于双数值轴，笛卡尔坐标系会默认选择 x 轴\n                // 极坐标系会默认选择 angle 轴\n                axis: 'auto',\n\n                animation: 'auto',\n                animationDurationUpdate: 200,\n                animationEasingUpdate: 'exponentialOut',\n\n                crossStyle: {\n                    color: '#999',\n                    width: 1,\n                    type: 'dashed',\n\n                    // TODO formatter\n                    textStyle: {}\n                }\n\n                // lineStyle and shadowStyle should not be specified here,\n                // otherwise it will always override those styles on option.axisPointer.\n            },\n            textStyle: {\n                color: '#fff',\n                fontSize: 14\n            }\n        }\n    });\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjM2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2NvbXBvbmVudC90b29sdGlwL1Rvb2x0aXBNb2RlbC5qcz8xMzg5Il0sInNvdXJjZXNDb250ZW50IjpbIlxuXG4gICAgcmVxdWlyZSgnLi4vLi4vZWNoYXJ0cycpLmV4dGVuZENvbXBvbmVudE1vZGVsKHtcblxuICAgICAgICB0eXBlOiAndG9vbHRpcCcsXG5cbiAgICAgICAgZGVwZW5kZW5jaWVzOiBbJ2F4aXNQb2ludGVyJ10sXG5cbiAgICAgICAgZGVmYXVsdE9wdGlvbjoge1xuICAgICAgICAgICAgemxldmVsOiAwLFxuXG4gICAgICAgICAgICB6OiA4LFxuXG4gICAgICAgICAgICBzaG93OiB0cnVlLFxuXG4gICAgICAgICAgICAvLyB0b29sdGlw5Li75L2T5YaF5a65XG4gICAgICAgICAgICBzaG93Q29udGVudDogdHJ1ZSxcblxuICAgICAgICAgICAgLy8gJ3RyaWdnZXInIG9ubHkgd29ya3Mgb24gY29vcmRpbmF0ZSBzeXN0ZW0uXG4gICAgICAgICAgICAvLyAnaXRlbScgfCAnYXhpcycgfCAnbm9uZSdcbiAgICAgICAgICAgIHRyaWdnZXI6ICdpdGVtJyxcblxuICAgICAgICAgICAgLy8gJ2NsaWNrJyB8ICdtb3VzZW1vdmUnIHwgJ25vbmUnXG4gICAgICAgICAgICB0cmlnZ2VyT246ICdtb3VzZW1vdmV8Y2xpY2snLFxuXG4gICAgICAgICAgICBhbHdheXNTaG93Q29udGVudDogZmFsc2UsXG5cbiAgICAgICAgICAgIGRpc3BsYXlNb2RlOiAnc2luZ2xlJywgLy8gJ3NpbmdsZScgfCAnbXVsdGlwbGVCeUNvb3JkU3lzJ1xuXG4gICAgICAgICAgICAvLyDkvY3nva4ge0FycmF5fSB8IHtGdW5jdGlvbn1cbiAgICAgICAgICAgIC8vIHBvc2l0aW9uOiBudWxsXG4gICAgICAgICAgICAvLyBDb25zaWRlciB0cmlnZ2VyZWQgZnJvbSBheGlzUG9pbnRlciBoYW5kbGUsIHZlcnRpY2FsQWxpZ24gc2hvdWxkIGJlICdtaWRkbGUnXG4gICAgICAgICAgICAvLyBhbGlnbjogbnVsbCxcbiAgICAgICAgICAgIC8vIHZlcnRpY2FsQWxpZ246IG51bGwsXG5cbiAgICAgICAgICAgIC8vIOaYr+WQpue6puadnyBjb250ZW50IOWcqCB2aWV3UmVjdCDkuK3jgILpu5jorqQgZmFsc2Ug5piv5Li65LqG5YW85a655Lul5YmN54mI5pys44CCXG4gICAgICAgICAgICBjb25maW5lOiBmYWxzZSxcblxuICAgICAgICAgICAgLy8g5YaF5a655qC85byP5Zmo77yae3N0cmluZ33vvIhUZW1wbGF0Ze+8iSDCpiB7RnVuY3Rpb259XG4gICAgICAgICAgICAvLyBmb3JtYXR0ZXI6IG51bGxcblxuICAgICAgICAgICAgc2hvd0RlbGF5OiAwLFxuXG4gICAgICAgICAgICAvLyDpmpDol4/lu7bov5/vvIzljZXkvY1tc1xuICAgICAgICAgICAgaGlkZURlbGF5OiAxMDAsXG5cbiAgICAgICAgICAgIC8vIOWKqOeUu+WPmOaNouaXtumXtO+8jOWNleS9jXNcbiAgICAgICAgICAgIHRyYW5zaXRpb25EdXJhdGlvbjogMC40LFxuXG4gICAgICAgICAgICBlbnRlcmFibGU6IGZhbHNlLFxuXG4gICAgICAgICAgICAvLyDmj5DnpLrog4zmma/popzoibLvvIzpu5jorqTkuLrpgI/mmI7luqbkuLowLjfnmoTpu5HoibJcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoNTAsNTAsNTAsMC43KScsXG5cbiAgICAgICAgICAgIC8vIOaPkOekuui+ueahhuminOiJslxuICAgICAgICAgICAgYm9yZGVyQ29sb3I6ICcjMzMzJyxcblxuICAgICAgICAgICAgLy8g5o+Q56S66L655qGG5ZyG6KeS77yM5Y2V5L2NcHjvvIzpu5jorqTkuLo0XG4gICAgICAgICAgICBib3JkZXJSYWRpdXM6IDQsXG5cbiAgICAgICAgICAgIC8vIOaPkOekuui+ueahhue6v+Wuve+8jOWNleS9jXB477yM6buY6K6k5Li6MO+8iOaXoOi+ueahhu+8iVxuICAgICAgICAgICAgYm9yZGVyV2lkdGg6IDAsXG5cbiAgICAgICAgICAgIC8vIOaPkOekuuWGhei+uei3ne+8jOWNleS9jXB477yM6buY6K6k5ZCE5pa55ZCR5YaF6L656Led5Li6Ne+8jFxuICAgICAgICAgICAgLy8g5o6l5Y+X5pWw57uE5YiG5Yir6K6+5a6a5LiK5Y+z5LiL5bem6L656Led77yM5ZCMY3NzXG4gICAgICAgICAgICBwYWRkaW5nOiA1LFxuXG4gICAgICAgICAgICAvLyBFeHRyYSBjc3MgdGV4dFxuICAgICAgICAgICAgZXh0cmFDc3NUZXh0OiAnJyxcblxuICAgICAgICAgICAgLy8g5Z2Q5qCH6L205oyH56S65Zmo77yM5Z2Q5qCH6L206Kem5Y+R5pyJ5pWIXG4gICAgICAgICAgICBheGlzUG9pbnRlcjoge1xuICAgICAgICAgICAgICAgIC8vIOm7mOiupOS4uuebtOe6v1xuICAgICAgICAgICAgICAgIC8vIOWPr+mAieS4uu+8midsaW5lJyB8ICdzaGFkb3cnIHwgJ2Nyb3NzJ1xuICAgICAgICAgICAgICAgIHR5cGU6ICdsaW5lJyxcblxuICAgICAgICAgICAgICAgIC8vIHR5cGUg5Li6IGxpbmUg55qE5pe25YCZ5pyJ5pWI77yM5oyH5a6aIHRvb2x0aXAgbGluZSDmiYDlnKjnmoTovbTvvIzlj6/pgIlcbiAgICAgICAgICAgICAgICAvLyDlj6/pgIkgJ3gnIHwgJ3knIHwgJ2FuZ2xlJyB8ICdyYWRpdXMnIHwgJ2F1dG8nXG4gICAgICAgICAgICAgICAgLy8g6buY6K6kICdhdXRvJ++8jOS8mumAieaLqeexu+Wei+S4uiBjYXRlb2dyeSDnmoTovbTvvIzlr7nkuo7lj4zmlbDlgLzovbTvvIznrJvljaHlsJTlnZDmoIfns7vkvJrpu5jorqTpgInmi6kgeCDovbRcbiAgICAgICAgICAgICAgICAvLyDmnoHlnZDmoIfns7vkvJrpu5jorqTpgInmi6kgYW5nbGUg6L20XG4gICAgICAgICAgICAgICAgYXhpczogJ2F1dG8nLFxuXG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uOiAnYXV0bycsXG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uRHVyYXRpb25VcGRhdGU6IDIwMCxcbiAgICAgICAgICAgICAgICBhbmltYXRpb25FYXNpbmdVcGRhdGU6ICdleHBvbmVudGlhbE91dCcsXG5cbiAgICAgICAgICAgICAgICBjcm9zc1N0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiAnIzk5OScsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiAxLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZGFzaGVkJyxcblxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIGZvcm1hdHRlclxuICAgICAgICAgICAgICAgICAgICB0ZXh0U3R5bGU6IHt9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gbGluZVN0eWxlIGFuZCBzaGFkb3dTdHlsZSBzaG91bGQgbm90IGJlIHNwZWNpZmllZCBoZXJlLFxuICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZSBpdCB3aWxsIGFsd2F5cyBvdmVycmlkZSB0aG9zZSBzdHlsZXMgb24gb3B0aW9uLmF4aXNQb2ludGVyLlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRleHRTdHlsZToge1xuICAgICAgICAgICAgICAgIGNvbG9yOiAnI2ZmZicsXG4gICAgICAgICAgICAgICAgZm9udFNpemU6IDE0XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2NvbXBvbmVudC90b29sdGlwL1Rvb2x0aXBNb2RlbC5qc1xuLy8gbW9kdWxlIGlkID0gMjM2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 237 */
/* unknown exports provided */
/* all exports used */
/*!**********************************************!*\
  !*** ./lib/component/tooltip/TooltipView.js ***!
  \**********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n    var TooltipContent = __webpack_require__(/*! ./TooltipContent */ 235);\n    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 0);\n    var formatUtil = __webpack_require__(/*! ../../util/format */ 6);\n    var numberUtil = __webpack_require__(/*! ../../util/number */ 3);\n    var graphic = __webpack_require__(/*! ../../util/graphic */ 2);\n    var findPointFromSeries = __webpack_require__(/*! ../axisPointer/findPointFromSeries */ 150);\n    var layoutUtil = __webpack_require__(/*! ../../util/layout */ 11);\n    var env = __webpack_require__(/*! zrender/lib/core/env */ 8);\n    var Model = __webpack_require__(/*! ../../model/Model */ 9);\n    var globalListener = __webpack_require__(/*! ../axisPointer/globalListener */ 151);\n    var axisHelper = __webpack_require__(/*! ../../coord/axisHelper */ 16);\n    var axisPointerViewHelper = __webpack_require__(/*! ../axisPointer/viewHelper */ 81);\n\n    var bind = zrUtil.bind;\n    var each = zrUtil.each;\n    var parsePercent = numberUtil.parsePercent;\n\n\n    var proxyRect = new graphic.Rect({\n        shape: {x: -1, y: -1, width: 2, height: 2}\n    });\n\n    __webpack_require__(/*! ../../echarts */ 1).extendComponentView({\n\n        type: 'tooltip',\n\n        init: function (ecModel, api) {\n            if (env.node) {\n                return;\n            }\n            var tooltipContent = new TooltipContent(api.getDom(), api);\n            this._tooltipContent = tooltipContent;\n        },\n\n        render: function (tooltipModel, ecModel, api) {\n            if (env.node) {\n                return;\n            }\n\n            // Reset\n            this.group.removeAll();\n\n            /**\n             * @private\n             * @type {module:echarts/component/tooltip/TooltipModel}\n             */\n            this._tooltipModel = tooltipModel;\n\n            /**\n             * @private\n             * @type {module:echarts/model/Global}\n             */\n            this._ecModel = ecModel;\n\n            /**\n             * @private\n             * @type {module:echarts/ExtensionAPI}\n             */\n            this._api = api;\n\n            /**\n             * Should be cleaned when render.\n             * @private\n             * @type {Array.<Array.<Object>>}\n             */\n            this._lastDataByCoordSys = null;\n\n            /**\n             * @private\n             * @type {boolean}\n             */\n            this._alwaysShowContent = tooltipModel.get('alwaysShowContent');\n\n            var tooltipContent = this._tooltipContent;\n            tooltipContent.update();\n            tooltipContent.setEnterable(tooltipModel.get('enterable'));\n\n            this._initGlobalListener();\n\n            this._keepShow();\n        },\n\n        _initGlobalListener: function () {\n            var tooltipModel = this._tooltipModel;\n            var triggerOn = tooltipModel.get('triggerOn');\n\n            globalListener.register(\n                'itemTooltip',\n                this._api,\n                bind(function (currTrigger, e, dispatchAction) {\n                    // If 'none', it is not controlled by mouse totally.\n                    if (triggerOn !== 'none') {\n                        if (triggerOn.indexOf(currTrigger) >= 0) {\n                            this._tryShow(e, dispatchAction);\n                        }\n                        else if (currTrigger === 'leave') {\n                            this._hide(dispatchAction);\n                        }\n                    }\n                }, this)\n            );\n        },\n\n        _keepShow: function () {\n            var tooltipModel = this._tooltipModel;\n            var ecModel = this._ecModel;\n            var api = this._api;\n\n            // Try to keep the tooltip show when refreshing\n            if (this._lastX != null\n                && this._lastY != null\n                // When user is willing to control tooltip totally using API,\n                // self.manuallyShowTip({x, y}) might cause tooltip hide,\n                // which is not expected.\n                && tooltipModel.get('triggerOn') !== 'none'\n            ) {\n                var self = this;\n                clearTimeout(this._refreshUpdateTimeout);\n                this._refreshUpdateTimeout = setTimeout(function () {\n                    // Show tip next tick after other charts are rendered\n                    // In case highlight action has wrong result\n                    // FIXME\n                    self.manuallyShowTip(tooltipModel, ecModel, api, {\n                        x: self._lastX,\n                        y: self._lastY\n                    });\n                });\n            }\n        },\n\n        /**\n         * Show tip manually by\n         * dispatchAction({\n         *     type: 'showTip',\n         *     x: 10,\n         *     y: 10\n         * });\n         * Or\n         * dispatchAction({\n         *      type: 'showTip',\n         *      seriesIndex: 0,\n         *      dataIndex or dataIndexInside or name\n         * });\n         *\n         *  TODO Batch\n         */\n        manuallyShowTip: function (tooltipModel, ecModel, api, payload) {\n            if (payload.from === this.uid || env.node) {\n                return;\n            }\n\n            var dispatchAction = makeDispatchAction(payload, api);\n\n            // Reset ticket\n            this._ticket = '';\n\n            // When triggered from axisPointer.\n            var dataByCoordSys = payload.dataByCoordSys;\n\n            if (payload.tooltip && payload.x != null && payload.y != null) {\n                var el = proxyRect;\n                el.position = [payload.x, payload.y];\n                el.update();\n                el.tooltip = payload.tooltip;\n                // Manually show tooltip while view is not using zrender elements.\n                this._tryShow({\n                    offsetX: payload.x,\n                    offsetY: payload.y,\n                    target: el\n                }, dispatchAction);\n            }\n            else if (dataByCoordSys) {\n                this._tryShow({\n                    offsetX: payload.x,\n                    offsetY: payload.y,\n                    position: payload.position,\n                    event: {},\n                    dataByCoordSys: payload.dataByCoordSys,\n                    tooltipOption: payload.tooltipOption\n                }, dispatchAction);\n            }\n            else if (payload.seriesIndex != null) {\n\n                if (this._manuallyAxisShowTip(tooltipModel, ecModel, api, payload)) {\n                    return;\n                }\n\n                var pointInfo = findPointFromSeries(payload, ecModel);\n                var cx = pointInfo.point[0];\n                var cy = pointInfo.point[1];\n                if (cx != null && cy != null) {\n                    this._tryShow({\n                        offsetX: cx,\n                        offsetY: cy,\n                        position: payload.position,\n                        target: pointInfo.el,\n                        event: {}\n                    }, dispatchAction);\n                }\n            }\n            else if (payload.x != null && payload.y != null) {\n                // FIXME\n                // should wrap dispatchAction like `axisPointer/globalListener` ?\n                api.dispatchAction({\n                    type: 'updateAxisPointer',\n                    x: payload.x,\n                    y: payload.y\n                });\n\n                this._tryShow({\n                    offsetX: payload.x,\n                    offsetY: payload.y,\n                    position: payload.position,\n                    target: api.getZr().findHover(payload.x, payload.y).target,\n                    event: {}\n                }, dispatchAction);\n            }\n        },\n\n        manuallyHideTip: function (tooltipModel, ecModel, api, payload) {\n            var tooltipContent = this._tooltipContent;\n\n            if (!this._alwaysShowContent) {\n                tooltipContent.hideLater(this._tooltipModel.get('hideDelay'));\n            }\n\n            this._lastX = this._lastY = null;\n\n            if (payload.from !== this.uid) {\n                this._hide(makeDispatchAction(payload, api));\n            }\n        },\n\n        // Be compatible with previous design, that is, when tooltip.type is 'axis' and\n        // dispatchAction 'showTip' with seriesIndex and dataIndex will trigger axis pointer\n        // and tooltip.\n        _manuallyAxisShowTip: function (tooltipModel, ecModel, api, payload) {\n            var seriesIndex = payload.seriesIndex;\n            var dataIndex = payload.dataIndex;\n            var coordSysAxesInfo = ecModel.getComponent('axisPointer').coordSysAxesInfo;\n\n            if (seriesIndex == null || dataIndex == null || coordSysAxesInfo == null) {\n                return;\n            }\n\n            var seriesModel = ecModel.getSeriesByIndex(seriesIndex);\n            if (!seriesModel) {\n                return;\n            }\n\n            var data = seriesModel.getData();\n            var tooltipModel = buildTooltipModel([\n                data.getItemModel(dataIndex),\n                seriesModel,\n                (seriesModel.coordinateSystem || {}).model,\n                tooltipModel\n            ]);\n\n            if (tooltipModel.get('trigger') !== 'axis') {\n                return;\n            }\n\n            api.dispatchAction({\n                type: 'updateAxisPointer',\n                seriesIndex: seriesIndex,\n                dataIndex: dataIndex\n            });\n\n            return true;\n        },\n\n        _tryShow: function (e, dispatchAction) {\n            var el = e.target;\n            var tooltipModel = this._tooltipModel;\n\n            if (!tooltipModel) {\n                return;\n            }\n\n            // Save mouse x, mouse y. So we can try to keep showing the tip if chart is refreshed\n            this._lastX = e.offsetX;\n            this._lastY = e.offsetY;\n\n            var dataByCoordSys = e.dataByCoordSys;\n            if (dataByCoordSys && dataByCoordSys.length) {\n                this._showAxisTooltip(dataByCoordSys, e);\n            }\n            // Always show item tooltip if mouse is on the element with dataIndex\n            else if (el && el.dataIndex != null) {\n                this._lastDataByCoordSys = null;\n                this._showSeriesItemTooltip(e, el, dispatchAction);\n            }\n            // Tooltip provided directly. Like legend.\n            else if (el && el.tooltip) {\n                this._lastDataByCoordSys = null;\n                this._showComponentItemTooltip(e, el, dispatchAction);\n            }\n            else {\n                this._lastDataByCoordSys = null;\n                this._hide(dispatchAction);\n            }\n        },\n\n        _showOrMove: function (tooltipModel, cb) {\n            // showDelay is used in this case: tooltip.enterable is set\n            // as true. User intent to move mouse into tooltip and click\n            // something. `showDelay` makes it easyer to enter the content\n            // but tooltip do not move immediately.\n            var delay = tooltipModel.get('showDelay');\n            cb = zrUtil.bind(cb, this);\n            clearTimeout(this._showTimout);\n            delay > 0\n                ? (this._showTimout = setTimeout(cb, delay))\n                : cb();\n        },\n\n        _showAxisTooltip: function (dataByCoordSys, e) {\n            var ecModel = this._ecModel;\n            var globalTooltipModel = this._tooltipModel;\n            var point = [e.offsetX, e.offsetY];\n            var singleDefaultHTML = [];\n            var singleParamsList = [];\n            var singleTooltipModel = buildTooltipModel([\n                e.tooltipOption,\n                globalTooltipModel\n            ]);\n\n            each(dataByCoordSys, function (itemCoordSys) {\n                // var coordParamList = [];\n                // var coordDefaultHTML = [];\n                // var coordTooltipModel = buildTooltipModel([\n                //     e.tooltipOption,\n                //     itemCoordSys.tooltipOption,\n                //     ecModel.getComponent(itemCoordSys.coordSysMainType, itemCoordSys.coordSysIndex),\n                //     globalTooltipModel\n                // ]);\n                // var displayMode = coordTooltipModel.get('displayMode');\n                // var paramsList = displayMode === 'single' ? singleParamsList : [];\n\n                each(itemCoordSys.dataByAxis, function (item) {\n                    var axisModel = ecModel.getComponent(item.axisDim + 'Axis', item.axisIndex);\n                    var axisValue = item.value;\n                    var seriesDefaultHTML = [];\n\n                    if (!axisModel || axisValue == null) {\n                        return;\n                    }\n\n                    var valueLabel = axisPointerViewHelper.getValueLabel(\n                        axisValue, axisModel.axis, ecModel,\n                        item.seriesDataIndices,\n                        item.valueLabelOpt\n                    );\n\n                    zrUtil.each(item.seriesDataIndices, function (idxItem) {\n                        var series = ecModel.getSeriesByIndex(idxItem.seriesIndex);\n                        var dataIndex = idxItem.dataIndexInside;\n                        var dataParams = series && series.getDataParams(dataIndex);\n                        dataParams.axisDim = item.axisDim;\n                        dataParams.axisIndex = item.axisIndex;\n                        dataParams.axisType = item.axisType;\n                        dataParams.axisId = item.axisId;\n                        dataParams.axisValue = axisHelper.getAxisRawValue(axisModel.axis, axisValue);\n                        dataParams.axisValueLabel = valueLabel;\n\n                        if (dataParams) {\n                            singleParamsList.push(dataParams);\n                            seriesDefaultHTML.push(series.formatTooltip(dataIndex, true));\n                        }\n                    });\n\n                    // Default tooltip content\n                    // FIXME\n                    // (1) shold be the first data which has name?\n                    // (2) themeRiver, firstDataIndex is array, and first line is unnecessary.\n                    var firstLine = valueLabel;\n                    singleDefaultHTML.push(\n                        (firstLine ? formatUtil.encodeHTML(firstLine) + '<br />' : '')\n                        + seriesDefaultHTML.join('<br />')\n                    );\n                });\n            }, this);\n\n            // In most case, the second axis is shown upper than the first one.\n            singleDefaultHTML.reverse();\n            singleDefaultHTML = singleDefaultHTML.join('<br /><br />');\n\n            var positionExpr = e.position;\n            this._showOrMove(singleTooltipModel, function () {\n                if (this._updateContentNotChangedOnAxis(dataByCoordSys)) {\n                    this._updatePosition(\n                        singleTooltipModel,\n                        positionExpr,\n                        point[0], point[1],\n                        this._tooltipContent,\n                        singleParamsList\n                    );\n                }\n                else {\n                    this._showTooltipContent(\n                        singleTooltipModel, singleDefaultHTML, singleParamsList, Math.random(),\n                        point[0], point[1], positionExpr\n                    );\n                }\n            });\n\n            // Do not trigger events here, because this branch only be entered\n            // from dispatchAction.\n        },\n\n        _showSeriesItemTooltip: function (e, el, dispatchAction) {\n            var ecModel = this._ecModel;\n            // Use dataModel in element if possible\n            // Used when mouseover on a element like markPoint or edge\n            // In which case, the data is not main data in series.\n            var seriesIndex = el.seriesIndex;\n            var seriesModel = ecModel.getSeriesByIndex(seriesIndex);\n\n            // For example, graph link.\n            var dataModel = el.dataModel || seriesModel;\n            var dataIndex = el.dataIndex;\n            var dataType = el.dataType;\n            var data = dataModel.getData();\n\n            var tooltipModel = buildTooltipModel([\n                data.getItemModel(dataIndex),\n                dataModel,\n                seriesModel && (seriesModel.coordinateSystem || {}).model,\n                this._tooltipModel\n            ]);\n\n            var tooltipTrigger = tooltipModel.get('trigger');\n            if (tooltipTrigger != null && tooltipTrigger !== 'item') {\n                return;\n            }\n\n            var params = dataModel.getDataParams(dataIndex, dataType);\n            var defaultHtml = dataModel.formatTooltip(dataIndex, false, dataType);\n            var asyncTicket = 'item_' + dataModel.name + '_' + dataIndex;\n\n            this._showOrMove(tooltipModel, function () {\n                this._showTooltipContent(\n                    tooltipModel, defaultHtml, params, asyncTicket,\n                    e.offsetX, e.offsetY, e.position, e.target\n                );\n            });\n\n            // FIXME\n            // duplicated showtip if manuallyShowTip is called from dispatchAction.\n            dispatchAction({\n                type: 'showTip',\n                dataIndexInside: dataIndex,\n                dataIndex: data.getRawIndex(dataIndex),\n                seriesIndex: seriesIndex,\n                from: this.uid\n            });\n        },\n\n        _showComponentItemTooltip: function (e, el, dispatchAction) {\n            var tooltipOpt = el.tooltip;\n            if (typeof tooltipOpt === 'string') {\n                var content = tooltipOpt;\n                tooltipOpt = {\n                    content: content,\n                    // Fixed formatter\n                    formatter: content\n                };\n            }\n            var subTooltipModel = new Model(tooltipOpt, this._tooltipModel, this._ecModel);\n            var defaultHtml = subTooltipModel.get('content');\n            var asyncTicket = Math.random();\n\n            // Do not check whether `trigger` is 'none' here, because `trigger`\n            // only works on cooridinate system. In fact, we have not found case\n            // that requires setting `trigger` nothing on component yet.\n\n            this._showOrMove(subTooltipModel, function () {\n                this._showTooltipContent(\n                    subTooltipModel, defaultHtml, subTooltipModel.get('formatterParams') || {},\n                    asyncTicket, e.offsetX, e.offsetY, e.position, el\n                );\n            });\n\n            // If not dispatch showTip, tip may be hide triggered by axis.\n            dispatchAction({\n                type: 'showTip',\n                from: this.uid\n            });\n        },\n\n        _showTooltipContent: function (\n            tooltipModel, defaultHtml, params, asyncTicket, x, y, positionExpr, el\n        ) {\n            // Reset ticket\n            this._ticket = '';\n\n            if (!tooltipModel.get('showContent') || !tooltipModel.get('show')) {\n                return;\n            }\n\n            var tooltipContent = this._tooltipContent;\n\n            var formatter = tooltipModel.get('formatter');\n            positionExpr = positionExpr || tooltipModel.get('position');\n            var html = defaultHtml;\n\n            if (formatter && typeof formatter === 'string') {\n                html = formatUtil.formatTpl(formatter, params, true);\n            }\n            else if (typeof formatter === 'function') {\n                var callback = bind(function (cbTicket, html) {\n                    if (cbTicket === this._ticket) {\n                        tooltipContent.setContent(html);\n                        this._updatePosition(\n                            tooltipModel, positionExpr, x, y, tooltipContent, params, el\n                        );\n                    }\n                }, this);\n                this._ticket = asyncTicket;\n                html = formatter(params, asyncTicket, callback);\n            }\n\n            tooltipContent.setContent(html);\n            tooltipContent.show(tooltipModel);\n\n            this._updatePosition(\n                tooltipModel, positionExpr, x, y, tooltipContent, params, el\n            );\n        },\n\n        /**\n         * @param  {string|Function|Array.<number>} positionExpr\n         * @param  {number} x Mouse x\n         * @param  {number} y Mouse y\n         * @param  {boolean} confine Whether confine tooltip content in view rect.\n         * @param  {Object|<Array.<Object>} params\n         * @param  {module:zrender/Element} el target element\n         * @param  {module:echarts/ExtensionAPI} api\n         * @return {Array.<number>}\n         */\n        _updatePosition: function (tooltipModel, positionExpr, x, y, content, params, el) {\n            var viewWidth = this._api.getWidth();\n            var viewHeight = this._api.getHeight();\n            positionExpr = positionExpr || tooltipModel.get('position');\n\n            var contentSize = content.getSize();\n            var align = tooltipModel.get('align');\n            var vAlign = tooltipModel.get('verticalAlign');\n            var rect = el && el.getBoundingRect().clone();\n            el && rect.applyTransform(el.transform);\n\n            if (typeof positionExpr === 'function') {\n                // Callback of position can be an array or a string specify the position\n                positionExpr = positionExpr([x, y], params, content.el, rect, {\n                    viewSize: [viewWidth, viewHeight],\n                    contentSize: contentSize.slice()\n                });\n            }\n\n            if (zrUtil.isArray(positionExpr)) {\n                x = parsePercent(positionExpr[0], viewWidth);\n                y = parsePercent(positionExpr[1], viewHeight);\n            }\n            else if (zrUtil.isObject(positionExpr)) {\n                positionExpr.width = contentSize[0];\n                positionExpr.height = contentSize[1];\n                var layoutRect = layoutUtil.getLayoutRect(\n                    positionExpr, {width: viewWidth, height: viewHeight}\n                );\n                x = layoutRect.x;\n                y = layoutRect.y;\n                align = null;\n                // When positionExpr is left/top/right/bottom,\n                // align and verticalAlign will not work.\n                vAlign = null;\n            }\n            // Specify tooltip position by string 'top' 'bottom' 'left' 'right' around graphic element\n            else if (typeof positionExpr === 'string' && el) {\n                var pos = calcTooltipPosition(\n                    positionExpr, rect, contentSize\n                );\n                x = pos[0];\n                y = pos[1];\n            }\n            else {\n                var pos = refixTooltipPosition(\n                    x, y, content.el, viewWidth, viewHeight, align ? null : 20, vAlign ? null : 20\n                );\n                x = pos[0];\n                y = pos[1];\n            }\n\n            align && (x -= isCenterAlign(align) ? contentSize[0] / 2 : align === 'right' ? contentSize[0] : 0);\n            vAlign && (y -= isCenterAlign(vAlign) ? contentSize[1] / 2 : vAlign === 'bottom' ? contentSize[1] : 0);\n\n            if (tooltipModel.get('confine')) {\n                var pos = confineTooltipPosition(\n                    x, y, content.el, viewWidth, viewHeight\n                );\n                x = pos[0];\n                y = pos[1];\n            }\n\n            content.moveTo(x, y);\n        },\n\n        // FIXME\n        // Should we remove this but leave this to user?\n        _updateContentNotChangedOnAxis: function (dataByCoordSys) {\n            var lastCoordSys = this._lastDataByCoordSys;\n            var contentNotChanged = !!lastCoordSys\n                && lastCoordSys.length === dataByCoordSys.length;\n\n            each(lastCoordSys, function (lastItemCoordSys, indexCoordSys) {\n                var lastDataByAxis = lastItemCoordSys.dataByAxis || {};\n                var thisItemCoordSys = dataByCoordSys[indexCoordSys] || {};\n                var thisDataByAxis = thisItemCoordSys.dataByAxis || [];\n                contentNotChanged &= lastDataByAxis.length === thisDataByAxis.length;\n\n                each(lastDataByAxis, function (lastItem, indexAxis) {\n                    var thisItem = thisDataByAxis[indexAxis] || {};\n                    var lastIndices = lastItem.seriesDataIndices || [];\n                    var newIndices = thisItem.seriesDataIndices || [];\n\n                    contentNotChanged &=\n                        lastItem.value === thisItem.value\n                        && lastItem.axisType === thisItem.axisType\n                        && lastItem.axisId === thisItem.axisId\n                        && lastIndices.length === newIndices.length;\n\n                    each(lastIndices, function (lastIdxItem, j) {\n                        var newIdxItem = newIndices[j];\n                        contentNotChanged &=\n                            lastIdxItem.seriesIndex === newIdxItem.seriesIndex\n                            && lastIdxItem.dataIndex === newIdxItem.dataIndex;\n                    });\n                });\n            });\n\n            this._lastDataByCoordSys = dataByCoordSys;\n\n            return !!contentNotChanged;\n        },\n\n        _hide: function (dispatchAction) {\n            // Do not directly hideLater here, because this behavior may be prevented\n            // in dispatchAction when showTip is dispatched.\n\n            // FIXME\n            // duplicated hideTip if manuallyHideTip is called from dispatchAction.\n            this._lastDataByCoordSys = null;\n            dispatchAction({\n                type: 'hideTip',\n                from: this.uid\n            });\n        },\n\n        dispose: function (ecModel, api) {\n            if (env.node) {\n                return;\n            }\n            this._tooltipContent.hide();\n            globalListener.unregister('itemTooltip', api);\n        }\n    });\n\n\n    /**\n     * @param {Array.<Object|module:echarts/model/Model>} modelCascade\n     * From top to bottom. (the last one should be globalTooltipModel);\n     */\n    function buildTooltipModel(modelCascade) {\n        var resultModel = modelCascade.pop();\n        while (modelCascade.length) {\n            var tooltipOpt = modelCascade.pop();\n            if (tooltipOpt) {\n                if (tooltipOpt instanceof Model) {\n                    tooltipOpt = tooltipOpt.get('tooltip', true);\n                }\n                // In each data item tooltip can be simply write:\n                // {\n                //  value: 10,\n                //  tooltip: 'Something you need to know'\n                // }\n                if (typeof tooltipOpt === 'string') {\n                    tooltipOpt = {formatter: tooltipOpt};\n                }\n                resultModel = new Model(tooltipOpt, resultModel, resultModel.ecModel);\n            }\n        }\n        return resultModel;\n    }\n\n    function makeDispatchAction(payload, api) {\n        return payload.dispatchAction || zrUtil.bind(api.dispatchAction, api);\n    }\n\n    function refixTooltipPosition(x, y, el, viewWidth, viewHeight, gapH, gapV) {\n        var width = el.clientWidth;\n        var height = el.clientHeight;\n\n        if (gapH != null) {\n            if (x + width + gapH > viewWidth) {\n                x -= width + gapH;\n            }\n            else {\n                x += gapH;\n            }\n        }\n        if (gapV != null) {\n            if (y + height + gapV > viewHeight) {\n                y -= height + gapV;\n            }\n            else {\n                y += gapV;\n            }\n        }\n        return [x, y];\n    }\n\n    function confineTooltipPosition(x, y, el, viewWidth, viewHeight) {\n        var width = el.clientWidth;\n        var height = el.clientHeight;\n\n        x = Math.min(x + width, viewWidth) - width;\n        y = Math.min(y + height, viewHeight) - height;\n        x = Math.max(x, 0);\n        y = Math.max(y, 0);\n\n        return [x, y];\n    }\n\n    function calcTooltipPosition(position, rect, contentSize) {\n        var domWidth = contentSize[0];\n        var domHeight = contentSize[1];\n        var gap = 5;\n        var x = 0;\n        var y = 0;\n        var rectWidth = rect.width;\n        var rectHeight = rect.height;\n        switch (position) {\n            case 'inside':\n                x = rect.x + rectWidth / 2 - domWidth / 2;\n                y = rect.y + rectHeight / 2 - domHeight / 2;\n                break;\n            case 'top':\n                x = rect.x + rectWidth / 2 - domWidth / 2;\n                y = rect.y - domHeight - gap;\n                break;\n            case 'bottom':\n                x = rect.x + rectWidth / 2 - domWidth / 2;\n                y = rect.y + rectHeight + gap;\n                break;\n            case 'left':\n                x = rect.x - domWidth - gap;\n                y = rect.y + rectHeight / 2 - domHeight / 2;\n                break;\n            case 'right':\n                x = rect.x + rectWidth + gap;\n                y = rect.y + rectHeight / 2 - domHeight / 2;\n        }\n        return [x, y];\n    }\n\n    function isCenterAlign(align) {\n        return align === 'center' || align === 'middle';\n    }\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjM3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2NvbXBvbmVudC90b29sdGlwL1Rvb2x0aXBWaWV3LmpzPzg5ZGMiXSwic291cmNlc0NvbnRlbnQiOlsiXG5cbiAgICB2YXIgVG9vbHRpcENvbnRlbnQgPSByZXF1aXJlKCcuL1Rvb2x0aXBDb250ZW50Jyk7XG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xuICAgIHZhciBmb3JtYXRVdGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9mb3JtYXQnKTtcbiAgICB2YXIgbnVtYmVyVXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvbnVtYmVyJyk7XG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKCcuLi8uLi91dGlsL2dyYXBoaWMnKTtcbiAgICB2YXIgZmluZFBvaW50RnJvbVNlcmllcyA9IHJlcXVpcmUoJy4uL2F4aXNQb2ludGVyL2ZpbmRQb2ludEZyb21TZXJpZXMnKTtcbiAgICB2YXIgbGF5b3V0VXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvbGF5b3V0Jyk7XG4gICAgdmFyIGVudiA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvZW52Jyk7XG4gICAgdmFyIE1vZGVsID0gcmVxdWlyZSgnLi4vLi4vbW9kZWwvTW9kZWwnKTtcbiAgICB2YXIgZ2xvYmFsTGlzdGVuZXIgPSByZXF1aXJlKCcuLi9heGlzUG9pbnRlci9nbG9iYWxMaXN0ZW5lcicpO1xuICAgIHZhciBheGlzSGVscGVyID0gcmVxdWlyZSgnLi4vLi4vY29vcmQvYXhpc0hlbHBlcicpO1xuICAgIHZhciBheGlzUG9pbnRlclZpZXdIZWxwZXIgPSByZXF1aXJlKCcuLi9heGlzUG9pbnRlci92aWV3SGVscGVyJyk7XG5cbiAgICB2YXIgYmluZCA9IHpyVXRpbC5iaW5kO1xuICAgIHZhciBlYWNoID0genJVdGlsLmVhY2g7XG4gICAgdmFyIHBhcnNlUGVyY2VudCA9IG51bWJlclV0aWwucGFyc2VQZXJjZW50O1xuXG5cbiAgICB2YXIgcHJveHlSZWN0ID0gbmV3IGdyYXBoaWMuUmVjdCh7XG4gICAgICAgIHNoYXBlOiB7eDogLTEsIHk6IC0xLCB3aWR0aDogMiwgaGVpZ2h0OiAyfVxuICAgIH0pO1xuXG4gICAgcmVxdWlyZSgnLi4vLi4vZWNoYXJ0cycpLmV4dGVuZENvbXBvbmVudFZpZXcoe1xuXG4gICAgICAgIHR5cGU6ICd0b29sdGlwJyxcblxuICAgICAgICBpbml0OiBmdW5jdGlvbiAoZWNNb2RlbCwgYXBpKSB7XG4gICAgICAgICAgICBpZiAoZW52Lm5vZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdG9vbHRpcENvbnRlbnQgPSBuZXcgVG9vbHRpcENvbnRlbnQoYXBpLmdldERvbSgpLCBhcGkpO1xuICAgICAgICAgICAgdGhpcy5fdG9vbHRpcENvbnRlbnQgPSB0b29sdGlwQ29udGVudDtcbiAgICAgICAgfSxcblxuICAgICAgICByZW5kZXI6IGZ1bmN0aW9uICh0b29sdGlwTW9kZWwsIGVjTW9kZWwsIGFwaSkge1xuICAgICAgICAgICAgaWYgKGVudi5ub2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSZXNldFxuICAgICAgICAgICAgdGhpcy5ncm91cC5yZW1vdmVBbGwoKTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICogQHR5cGUge21vZHVsZTplY2hhcnRzL2NvbXBvbmVudC90b29sdGlwL1Rvb2x0aXBNb2RlbH1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5fdG9vbHRpcE1vZGVsID0gdG9vbHRpcE1vZGVsO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgKiBAdHlwZSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvR2xvYmFsfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLl9lY01vZGVsID0gZWNNb2RlbDtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICogQHR5cGUge21vZHVsZTplY2hhcnRzL0V4dGVuc2lvbkFQSX1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5fYXBpID0gYXBpO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFNob3VsZCBiZSBjbGVhbmVkIHdoZW4gcmVuZGVyLlxuICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAqIEB0eXBlIHtBcnJheS48QXJyYXkuPE9iamVjdD4+fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLl9sYXN0RGF0YUJ5Q29vcmRTeXMgPSBudWxsO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5fYWx3YXlzU2hvd0NvbnRlbnQgPSB0b29sdGlwTW9kZWwuZ2V0KCdhbHdheXNTaG93Q29udGVudCcpO1xuXG4gICAgICAgICAgICB2YXIgdG9vbHRpcENvbnRlbnQgPSB0aGlzLl90b29sdGlwQ29udGVudDtcbiAgICAgICAgICAgIHRvb2x0aXBDb250ZW50LnVwZGF0ZSgpO1xuICAgICAgICAgICAgdG9vbHRpcENvbnRlbnQuc2V0RW50ZXJhYmxlKHRvb2x0aXBNb2RlbC5nZXQoJ2VudGVyYWJsZScpKTtcblxuICAgICAgICAgICAgdGhpcy5faW5pdEdsb2JhbExpc3RlbmVyKCk7XG5cbiAgICAgICAgICAgIHRoaXMuX2tlZXBTaG93KCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2luaXRHbG9iYWxMaXN0ZW5lcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHRvb2x0aXBNb2RlbCA9IHRoaXMuX3Rvb2x0aXBNb2RlbDtcbiAgICAgICAgICAgIHZhciB0cmlnZ2VyT24gPSB0b29sdGlwTW9kZWwuZ2V0KCd0cmlnZ2VyT24nKTtcblxuICAgICAgICAgICAgZ2xvYmFsTGlzdGVuZXIucmVnaXN0ZXIoXG4gICAgICAgICAgICAgICAgJ2l0ZW1Ub29sdGlwJyxcbiAgICAgICAgICAgICAgICB0aGlzLl9hcGksXG4gICAgICAgICAgICAgICAgYmluZChmdW5jdGlvbiAoY3VyclRyaWdnZXIsIGUsIGRpc3BhdGNoQWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmICdub25lJywgaXQgaXMgbm90IGNvbnRyb2xsZWQgYnkgbW91c2UgdG90YWxseS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyaWdnZXJPbiAhPT0gJ25vbmUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHJpZ2dlck9uLmluZGV4T2YoY3VyclRyaWdnZXIpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90cnlTaG93KGUsIGRpc3BhdGNoQWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGN1cnJUcmlnZ2VyID09PSAnbGVhdmUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faGlkZShkaXNwYXRjaEFjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCB0aGlzKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfa2VlcFNob3c6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB0b29sdGlwTW9kZWwgPSB0aGlzLl90b29sdGlwTW9kZWw7XG4gICAgICAgICAgICB2YXIgZWNNb2RlbCA9IHRoaXMuX2VjTW9kZWw7XG4gICAgICAgICAgICB2YXIgYXBpID0gdGhpcy5fYXBpO1xuXG4gICAgICAgICAgICAvLyBUcnkgdG8ga2VlcCB0aGUgdG9vbHRpcCBzaG93IHdoZW4gcmVmcmVzaGluZ1xuICAgICAgICAgICAgaWYgKHRoaXMuX2xhc3RYICE9IG51bGxcbiAgICAgICAgICAgICAgICAmJiB0aGlzLl9sYXN0WSAhPSBudWxsXG4gICAgICAgICAgICAgICAgLy8gV2hlbiB1c2VyIGlzIHdpbGxpbmcgdG8gY29udHJvbCB0b29sdGlwIHRvdGFsbHkgdXNpbmcgQVBJLFxuICAgICAgICAgICAgICAgIC8vIHNlbGYubWFudWFsbHlTaG93VGlwKHt4LCB5fSkgbWlnaHQgY2F1c2UgdG9vbHRpcCBoaWRlLFxuICAgICAgICAgICAgICAgIC8vIHdoaWNoIGlzIG5vdCBleHBlY3RlZC5cbiAgICAgICAgICAgICAgICAmJiB0b29sdGlwTW9kZWwuZ2V0KCd0cmlnZ2VyT24nKSAhPT0gJ25vbmUnXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3JlZnJlc2hVcGRhdGVUaW1lb3V0KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWZyZXNoVXBkYXRlVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTaG93IHRpcCBuZXh0IHRpY2sgYWZ0ZXIgb3RoZXIgY2hhcnRzIGFyZSByZW5kZXJlZFxuICAgICAgICAgICAgICAgICAgICAvLyBJbiBjYXNlIGhpZ2hsaWdodCBhY3Rpb24gaGFzIHdyb25nIHJlc3VsdFxuICAgICAgICAgICAgICAgICAgICAvLyBGSVhNRVxuICAgICAgICAgICAgICAgICAgICBzZWxmLm1hbnVhbGx5U2hvd1RpcCh0b29sdGlwTW9kZWwsIGVjTW9kZWwsIGFwaSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgeDogc2VsZi5fbGFzdFgsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBzZWxmLl9sYXN0WVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2hvdyB0aXAgbWFudWFsbHkgYnlcbiAgICAgICAgICogZGlzcGF0Y2hBY3Rpb24oe1xuICAgICAgICAgKiAgICAgdHlwZTogJ3Nob3dUaXAnLFxuICAgICAgICAgKiAgICAgeDogMTAsXG4gICAgICAgICAqICAgICB5OiAxMFxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICogT3JcbiAgICAgICAgICogZGlzcGF0Y2hBY3Rpb24oe1xuICAgICAgICAgKiAgICAgIHR5cGU6ICdzaG93VGlwJyxcbiAgICAgICAgICogICAgICBzZXJpZXNJbmRleDogMCxcbiAgICAgICAgICogICAgICBkYXRhSW5kZXggb3IgZGF0YUluZGV4SW5zaWRlIG9yIG5hbWVcbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICBUT0RPIEJhdGNoXG4gICAgICAgICAqL1xuICAgICAgICBtYW51YWxseVNob3dUaXA6IGZ1bmN0aW9uICh0b29sdGlwTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCkge1xuICAgICAgICAgICAgaWYgKHBheWxvYWQuZnJvbSA9PT0gdGhpcy51aWQgfHwgZW52Lm5vZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBkaXNwYXRjaEFjdGlvbiA9IG1ha2VEaXNwYXRjaEFjdGlvbihwYXlsb2FkLCBhcGkpO1xuXG4gICAgICAgICAgICAvLyBSZXNldCB0aWNrZXRcbiAgICAgICAgICAgIHRoaXMuX3RpY2tldCA9ICcnO1xuXG4gICAgICAgICAgICAvLyBXaGVuIHRyaWdnZXJlZCBmcm9tIGF4aXNQb2ludGVyLlxuICAgICAgICAgICAgdmFyIGRhdGFCeUNvb3JkU3lzID0gcGF5bG9hZC5kYXRhQnlDb29yZFN5cztcblxuICAgICAgICAgICAgaWYgKHBheWxvYWQudG9vbHRpcCAmJiBwYXlsb2FkLnggIT0gbnVsbCAmJiBwYXlsb2FkLnkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciBlbCA9IHByb3h5UmVjdDtcbiAgICAgICAgICAgICAgICBlbC5wb3NpdGlvbiA9IFtwYXlsb2FkLngsIHBheWxvYWQueV07XG4gICAgICAgICAgICAgICAgZWwudXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgZWwudG9vbHRpcCA9IHBheWxvYWQudG9vbHRpcDtcbiAgICAgICAgICAgICAgICAvLyBNYW51YWxseSBzaG93IHRvb2x0aXAgd2hpbGUgdmlldyBpcyBub3QgdXNpbmcgenJlbmRlciBlbGVtZW50cy5cbiAgICAgICAgICAgICAgICB0aGlzLl90cnlTaG93KHtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0WDogcGF5bG9hZC54LFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXRZOiBwYXlsb2FkLnksXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDogZWxcbiAgICAgICAgICAgICAgICB9LCBkaXNwYXRjaEFjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkYXRhQnlDb29yZFN5cykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3RyeVNob3coe1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXRYOiBwYXlsb2FkLngsXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldFk6IHBheWxvYWQueSxcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHBheWxvYWQucG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50OiB7fSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YUJ5Q29vcmRTeXM6IHBheWxvYWQuZGF0YUJ5Q29vcmRTeXMsXG4gICAgICAgICAgICAgICAgICAgIHRvb2x0aXBPcHRpb246IHBheWxvYWQudG9vbHRpcE9wdGlvblxuICAgICAgICAgICAgICAgIH0sIGRpc3BhdGNoQWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBheWxvYWQuc2VyaWVzSW5kZXggIT0gbnVsbCkge1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX21hbnVhbGx5QXhpc1Nob3dUaXAodG9vbHRpcE1vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgcG9pbnRJbmZvID0gZmluZFBvaW50RnJvbVNlcmllcyhwYXlsb2FkLCBlY01vZGVsKTtcbiAgICAgICAgICAgICAgICB2YXIgY3ggPSBwb2ludEluZm8ucG9pbnRbMF07XG4gICAgICAgICAgICAgICAgdmFyIGN5ID0gcG9pbnRJbmZvLnBvaW50WzFdO1xuICAgICAgICAgICAgICAgIGlmIChjeCAhPSBudWxsICYmIGN5ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdHJ5U2hvdyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXRYOiBjeCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldFk6IGN5LFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHBheWxvYWQucG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IHBvaW50SW5mby5lbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OiB7fVxuICAgICAgICAgICAgICAgICAgICB9LCBkaXNwYXRjaEFjdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGF5bG9hZC54ICE9IG51bGwgJiYgcGF5bG9hZC55ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBGSVhNRVxuICAgICAgICAgICAgICAgIC8vIHNob3VsZCB3cmFwIGRpc3BhdGNoQWN0aW9uIGxpa2UgYGF4aXNQb2ludGVyL2dsb2JhbExpc3RlbmVyYCA/XG4gICAgICAgICAgICAgICAgYXBpLmRpc3BhdGNoQWN0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3VwZGF0ZUF4aXNQb2ludGVyJyxcbiAgICAgICAgICAgICAgICAgICAgeDogcGF5bG9hZC54LFxuICAgICAgICAgICAgICAgICAgICB5OiBwYXlsb2FkLnlcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHRoaXMuX3RyeVNob3coe1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXRYOiBwYXlsb2FkLngsXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldFk6IHBheWxvYWQueSxcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHBheWxvYWQucG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDogYXBpLmdldFpyKCkuZmluZEhvdmVyKHBheWxvYWQueCwgcGF5bG9hZC55KS50YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50OiB7fVxuICAgICAgICAgICAgICAgIH0sIGRpc3BhdGNoQWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBtYW51YWxseUhpZGVUaXA6IGZ1bmN0aW9uICh0b29sdGlwTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCkge1xuICAgICAgICAgICAgdmFyIHRvb2x0aXBDb250ZW50ID0gdGhpcy5fdG9vbHRpcENvbnRlbnQ7XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5fYWx3YXlzU2hvd0NvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICB0b29sdGlwQ29udGVudC5oaWRlTGF0ZXIodGhpcy5fdG9vbHRpcE1vZGVsLmdldCgnaGlkZURlbGF5JykpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9sYXN0WCA9IHRoaXMuX2xhc3RZID0gbnVsbDtcblxuICAgICAgICAgICAgaWYgKHBheWxvYWQuZnJvbSAhPT0gdGhpcy51aWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9oaWRlKG1ha2VEaXNwYXRjaEFjdGlvbihwYXlsb2FkLCBhcGkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBCZSBjb21wYXRpYmxlIHdpdGggcHJldmlvdXMgZGVzaWduLCB0aGF0IGlzLCB3aGVuIHRvb2x0aXAudHlwZSBpcyAnYXhpcycgYW5kXG4gICAgICAgIC8vIGRpc3BhdGNoQWN0aW9uICdzaG93VGlwJyB3aXRoIHNlcmllc0luZGV4IGFuZCBkYXRhSW5kZXggd2lsbCB0cmlnZ2VyIGF4aXMgcG9pbnRlclxuICAgICAgICAvLyBhbmQgdG9vbHRpcC5cbiAgICAgICAgX21hbnVhbGx5QXhpc1Nob3dUaXA6IGZ1bmN0aW9uICh0b29sdGlwTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCkge1xuICAgICAgICAgICAgdmFyIHNlcmllc0luZGV4ID0gcGF5bG9hZC5zZXJpZXNJbmRleDtcbiAgICAgICAgICAgIHZhciBkYXRhSW5kZXggPSBwYXlsb2FkLmRhdGFJbmRleDtcbiAgICAgICAgICAgIHZhciBjb29yZFN5c0F4ZXNJbmZvID0gZWNNb2RlbC5nZXRDb21wb25lbnQoJ2F4aXNQb2ludGVyJykuY29vcmRTeXNBeGVzSW5mbztcblxuICAgICAgICAgICAgaWYgKHNlcmllc0luZGV4ID09IG51bGwgfHwgZGF0YUluZGV4ID09IG51bGwgfHwgY29vcmRTeXNBeGVzSW5mbyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgc2VyaWVzTW9kZWwgPSBlY01vZGVsLmdldFNlcmllc0J5SW5kZXgoc2VyaWVzSW5kZXgpO1xuICAgICAgICAgICAgaWYgKCFzZXJpZXNNb2RlbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgICAgICAgICB2YXIgdG9vbHRpcE1vZGVsID0gYnVpbGRUb29sdGlwTW9kZWwoW1xuICAgICAgICAgICAgICAgIGRhdGEuZ2V0SXRlbU1vZGVsKGRhdGFJbmRleCksXG4gICAgICAgICAgICAgICAgc2VyaWVzTW9kZWwsXG4gICAgICAgICAgICAgICAgKHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW0gfHwge30pLm1vZGVsLFxuICAgICAgICAgICAgICAgIHRvb2x0aXBNb2RlbFxuICAgICAgICAgICAgXSk7XG5cbiAgICAgICAgICAgIGlmICh0b29sdGlwTW9kZWwuZ2V0KCd0cmlnZ2VyJykgIT09ICdheGlzJykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYXBpLmRpc3BhdGNoQWN0aW9uKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAndXBkYXRlQXhpc1BvaW50ZXInLFxuICAgICAgICAgICAgICAgIHNlcmllc0luZGV4OiBzZXJpZXNJbmRleCxcbiAgICAgICAgICAgICAgICBkYXRhSW5kZXg6IGRhdGFJbmRleFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIF90cnlTaG93OiBmdW5jdGlvbiAoZSwgZGlzcGF0Y2hBY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciBlbCA9IGUudGFyZ2V0O1xuICAgICAgICAgICAgdmFyIHRvb2x0aXBNb2RlbCA9IHRoaXMuX3Rvb2x0aXBNb2RlbDtcblxuICAgICAgICAgICAgaWYgKCF0b29sdGlwTW9kZWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNhdmUgbW91c2UgeCwgbW91c2UgeS4gU28gd2UgY2FuIHRyeSB0byBrZWVwIHNob3dpbmcgdGhlIHRpcCBpZiBjaGFydCBpcyByZWZyZXNoZWRcbiAgICAgICAgICAgIHRoaXMuX2xhc3RYID0gZS5vZmZzZXRYO1xuICAgICAgICAgICAgdGhpcy5fbGFzdFkgPSBlLm9mZnNldFk7XG5cbiAgICAgICAgICAgIHZhciBkYXRhQnlDb29yZFN5cyA9IGUuZGF0YUJ5Q29vcmRTeXM7XG4gICAgICAgICAgICBpZiAoZGF0YUJ5Q29vcmRTeXMgJiYgZGF0YUJ5Q29vcmRTeXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2hvd0F4aXNUb29sdGlwKGRhdGFCeUNvb3JkU3lzLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFsd2F5cyBzaG93IGl0ZW0gdG9vbHRpcCBpZiBtb3VzZSBpcyBvbiB0aGUgZWxlbWVudCB3aXRoIGRhdGFJbmRleFxuICAgICAgICAgICAgZWxzZSBpZiAoZWwgJiYgZWwuZGF0YUluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sYXN0RGF0YUJ5Q29vcmRTeXMgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3dTZXJpZXNJdGVtVG9vbHRpcChlLCBlbCwgZGlzcGF0Y2hBY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVG9vbHRpcCBwcm92aWRlZCBkaXJlY3RseS4gTGlrZSBsZWdlbmQuXG4gICAgICAgICAgICBlbHNlIGlmIChlbCAmJiBlbC50b29sdGlwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGFzdERhdGFCeUNvb3JkU3lzID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaG93Q29tcG9uZW50SXRlbVRvb2x0aXAoZSwgZWwsIGRpc3BhdGNoQWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xhc3REYXRhQnlDb29yZFN5cyA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5faGlkZShkaXNwYXRjaEFjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3Nob3dPck1vdmU6IGZ1bmN0aW9uICh0b29sdGlwTW9kZWwsIGNiKSB7XG4gICAgICAgICAgICAvLyBzaG93RGVsYXkgaXMgdXNlZCBpbiB0aGlzIGNhc2U6IHRvb2x0aXAuZW50ZXJhYmxlIGlzIHNldFxuICAgICAgICAgICAgLy8gYXMgdHJ1ZS4gVXNlciBpbnRlbnQgdG8gbW92ZSBtb3VzZSBpbnRvIHRvb2x0aXAgYW5kIGNsaWNrXG4gICAgICAgICAgICAvLyBzb21ldGhpbmcuIGBzaG93RGVsYXlgIG1ha2VzIGl0IGVhc3llciB0byBlbnRlciB0aGUgY29udGVudFxuICAgICAgICAgICAgLy8gYnV0IHRvb2x0aXAgZG8gbm90IG1vdmUgaW1tZWRpYXRlbHkuXG4gICAgICAgICAgICB2YXIgZGVsYXkgPSB0b29sdGlwTW9kZWwuZ2V0KCdzaG93RGVsYXknKTtcbiAgICAgICAgICAgIGNiID0genJVdGlsLmJpbmQoY2IsIHRoaXMpO1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3Nob3dUaW1vdXQpO1xuICAgICAgICAgICAgZGVsYXkgPiAwXG4gICAgICAgICAgICAgICAgPyAodGhpcy5fc2hvd1RpbW91dCA9IHNldFRpbWVvdXQoY2IsIGRlbGF5KSlcbiAgICAgICAgICAgICAgICA6IGNiKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3Nob3dBeGlzVG9vbHRpcDogZnVuY3Rpb24gKGRhdGFCeUNvb3JkU3lzLCBlKSB7XG4gICAgICAgICAgICB2YXIgZWNNb2RlbCA9IHRoaXMuX2VjTW9kZWw7XG4gICAgICAgICAgICB2YXIgZ2xvYmFsVG9vbHRpcE1vZGVsID0gdGhpcy5fdG9vbHRpcE1vZGVsO1xuICAgICAgICAgICAgdmFyIHBvaW50ID0gW2Uub2Zmc2V0WCwgZS5vZmZzZXRZXTtcbiAgICAgICAgICAgIHZhciBzaW5nbGVEZWZhdWx0SFRNTCA9IFtdO1xuICAgICAgICAgICAgdmFyIHNpbmdsZVBhcmFtc0xpc3QgPSBbXTtcbiAgICAgICAgICAgIHZhciBzaW5nbGVUb29sdGlwTW9kZWwgPSBidWlsZFRvb2x0aXBNb2RlbChbXG4gICAgICAgICAgICAgICAgZS50b29sdGlwT3B0aW9uLFxuICAgICAgICAgICAgICAgIGdsb2JhbFRvb2x0aXBNb2RlbFxuICAgICAgICAgICAgXSk7XG5cbiAgICAgICAgICAgIGVhY2goZGF0YUJ5Q29vcmRTeXMsIGZ1bmN0aW9uIChpdGVtQ29vcmRTeXMpIHtcbiAgICAgICAgICAgICAgICAvLyB2YXIgY29vcmRQYXJhbUxpc3QgPSBbXTtcbiAgICAgICAgICAgICAgICAvLyB2YXIgY29vcmREZWZhdWx0SFRNTCA9IFtdO1xuICAgICAgICAgICAgICAgIC8vIHZhciBjb29yZFRvb2x0aXBNb2RlbCA9IGJ1aWxkVG9vbHRpcE1vZGVsKFtcbiAgICAgICAgICAgICAgICAvLyAgICAgZS50b29sdGlwT3B0aW9uLFxuICAgICAgICAgICAgICAgIC8vICAgICBpdGVtQ29vcmRTeXMudG9vbHRpcE9wdGlvbixcbiAgICAgICAgICAgICAgICAvLyAgICAgZWNNb2RlbC5nZXRDb21wb25lbnQoaXRlbUNvb3JkU3lzLmNvb3JkU3lzTWFpblR5cGUsIGl0ZW1Db29yZFN5cy5jb29yZFN5c0luZGV4KSxcbiAgICAgICAgICAgICAgICAvLyAgICAgZ2xvYmFsVG9vbHRpcE1vZGVsXG4gICAgICAgICAgICAgICAgLy8gXSk7XG4gICAgICAgICAgICAgICAgLy8gdmFyIGRpc3BsYXlNb2RlID0gY29vcmRUb29sdGlwTW9kZWwuZ2V0KCdkaXNwbGF5TW9kZScpO1xuICAgICAgICAgICAgICAgIC8vIHZhciBwYXJhbXNMaXN0ID0gZGlzcGxheU1vZGUgPT09ICdzaW5nbGUnID8gc2luZ2xlUGFyYW1zTGlzdCA6IFtdO1xuXG4gICAgICAgICAgICAgICAgZWFjaChpdGVtQ29vcmRTeXMuZGF0YUJ5QXhpcywgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGF4aXNNb2RlbCA9IGVjTW9kZWwuZ2V0Q29tcG9uZW50KGl0ZW0uYXhpc0RpbSArICdBeGlzJywgaXRlbS5heGlzSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXhpc1ZhbHVlID0gaXRlbS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlcmllc0RlZmF1bHRIVE1MID0gW107XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFheGlzTW9kZWwgfHwgYXhpc1ZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZUxhYmVsID0gYXhpc1BvaW50ZXJWaWV3SGVscGVyLmdldFZhbHVlTGFiZWwoXG4gICAgICAgICAgICAgICAgICAgICAgICBheGlzVmFsdWUsIGF4aXNNb2RlbC5heGlzLCBlY01vZGVsLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5zZXJpZXNEYXRhSW5kaWNlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0udmFsdWVMYWJlbE9wdFxuICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgIHpyVXRpbC5lYWNoKGl0ZW0uc2VyaWVzRGF0YUluZGljZXMsIGZ1bmN0aW9uIChpZHhJdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2VyaWVzID0gZWNNb2RlbC5nZXRTZXJpZXNCeUluZGV4KGlkeEl0ZW0uc2VyaWVzSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGFJbmRleCA9IGlkeEl0ZW0uZGF0YUluZGV4SW5zaWRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGFQYXJhbXMgPSBzZXJpZXMgJiYgc2VyaWVzLmdldERhdGFQYXJhbXMoZGF0YUluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFQYXJhbXMuYXhpc0RpbSA9IGl0ZW0uYXhpc0RpbTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFQYXJhbXMuYXhpc0luZGV4ID0gaXRlbS5heGlzSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhUGFyYW1zLmF4aXNUeXBlID0gaXRlbS5heGlzVHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFQYXJhbXMuYXhpc0lkID0gaXRlbS5heGlzSWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhUGFyYW1zLmF4aXNWYWx1ZSA9IGF4aXNIZWxwZXIuZ2V0QXhpc1Jhd1ZhbHVlKGF4aXNNb2RlbC5heGlzLCBheGlzVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVBhcmFtcy5heGlzVmFsdWVMYWJlbCA9IHZhbHVlTGFiZWw7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhUGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2luZ2xlUGFyYW1zTGlzdC5wdXNoKGRhdGFQYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllc0RlZmF1bHRIVE1MLnB1c2goc2VyaWVzLmZvcm1hdFRvb2x0aXAoZGF0YUluZGV4LCB0cnVlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIERlZmF1bHQgdG9vbHRpcCBjb250ZW50XG4gICAgICAgICAgICAgICAgICAgIC8vIEZJWE1FXG4gICAgICAgICAgICAgICAgICAgIC8vICgxKSBzaG9sZCBiZSB0aGUgZmlyc3QgZGF0YSB3aGljaCBoYXMgbmFtZT9cbiAgICAgICAgICAgICAgICAgICAgLy8gKDIpIHRoZW1lUml2ZXIsIGZpcnN0RGF0YUluZGV4IGlzIGFycmF5LCBhbmQgZmlyc3QgbGluZSBpcyB1bm5lY2Vzc2FyeS5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpcnN0TGluZSA9IHZhbHVlTGFiZWw7XG4gICAgICAgICAgICAgICAgICAgIHNpbmdsZURlZmF1bHRIVE1MLnB1c2goXG4gICAgICAgICAgICAgICAgICAgICAgICAoZmlyc3RMaW5lID8gZm9ybWF0VXRpbC5lbmNvZGVIVE1MKGZpcnN0TGluZSkgKyAnPGJyIC8+JyA6ICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgKyBzZXJpZXNEZWZhdWx0SFRNTC5qb2luKCc8YnIgLz4nKVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgICAgIC8vIEluIG1vc3QgY2FzZSwgdGhlIHNlY29uZCBheGlzIGlzIHNob3duIHVwcGVyIHRoYW4gdGhlIGZpcnN0IG9uZS5cbiAgICAgICAgICAgIHNpbmdsZURlZmF1bHRIVE1MLnJldmVyc2UoKTtcbiAgICAgICAgICAgIHNpbmdsZURlZmF1bHRIVE1MID0gc2luZ2xlRGVmYXVsdEhUTUwuam9pbignPGJyIC8+PGJyIC8+Jyk7XG5cbiAgICAgICAgICAgIHZhciBwb3NpdGlvbkV4cHIgPSBlLnBvc2l0aW9uO1xuICAgICAgICAgICAgdGhpcy5fc2hvd09yTW92ZShzaW5nbGVUb29sdGlwTW9kZWwsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fdXBkYXRlQ29udGVudE5vdENoYW5nZWRPbkF4aXMoZGF0YUJ5Q29vcmRTeXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVBvc2l0aW9uKFxuICAgICAgICAgICAgICAgICAgICAgICAgc2luZ2xlVG9vbHRpcE1vZGVsLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25FeHByLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRbMF0sIHBvaW50WzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdG9vbHRpcENvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaW5nbGVQYXJhbXNMaXN0XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zaG93VG9vbHRpcENvbnRlbnQoXG4gICAgICAgICAgICAgICAgICAgICAgICBzaW5nbGVUb29sdGlwTW9kZWwsIHNpbmdsZURlZmF1bHRIVE1MLCBzaW5nbGVQYXJhbXNMaXN0LCBNYXRoLnJhbmRvbSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRbMF0sIHBvaW50WzFdLCBwb3NpdGlvbkV4cHJcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gRG8gbm90IHRyaWdnZXIgZXZlbnRzIGhlcmUsIGJlY2F1c2UgdGhpcyBicmFuY2ggb25seSBiZSBlbnRlcmVkXG4gICAgICAgICAgICAvLyBmcm9tIGRpc3BhdGNoQWN0aW9uLlxuICAgICAgICB9LFxuXG4gICAgICAgIF9zaG93U2VyaWVzSXRlbVRvb2x0aXA6IGZ1bmN0aW9uIChlLCBlbCwgZGlzcGF0Y2hBY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciBlY01vZGVsID0gdGhpcy5fZWNNb2RlbDtcbiAgICAgICAgICAgIC8vIFVzZSBkYXRhTW9kZWwgaW4gZWxlbWVudCBpZiBwb3NzaWJsZVxuICAgICAgICAgICAgLy8gVXNlZCB3aGVuIG1vdXNlb3ZlciBvbiBhIGVsZW1lbnQgbGlrZSBtYXJrUG9pbnQgb3IgZWRnZVxuICAgICAgICAgICAgLy8gSW4gd2hpY2ggY2FzZSwgdGhlIGRhdGEgaXMgbm90IG1haW4gZGF0YSBpbiBzZXJpZXMuXG4gICAgICAgICAgICB2YXIgc2VyaWVzSW5kZXggPSBlbC5zZXJpZXNJbmRleDtcbiAgICAgICAgICAgIHZhciBzZXJpZXNNb2RlbCA9IGVjTW9kZWwuZ2V0U2VyaWVzQnlJbmRleChzZXJpZXNJbmRleCk7XG5cbiAgICAgICAgICAgIC8vIEZvciBleGFtcGxlLCBncmFwaCBsaW5rLlxuICAgICAgICAgICAgdmFyIGRhdGFNb2RlbCA9IGVsLmRhdGFNb2RlbCB8fCBzZXJpZXNNb2RlbDtcbiAgICAgICAgICAgIHZhciBkYXRhSW5kZXggPSBlbC5kYXRhSW5kZXg7XG4gICAgICAgICAgICB2YXIgZGF0YVR5cGUgPSBlbC5kYXRhVHlwZTtcbiAgICAgICAgICAgIHZhciBkYXRhID0gZGF0YU1vZGVsLmdldERhdGEoKTtcblxuICAgICAgICAgICAgdmFyIHRvb2x0aXBNb2RlbCA9IGJ1aWxkVG9vbHRpcE1vZGVsKFtcbiAgICAgICAgICAgICAgICBkYXRhLmdldEl0ZW1Nb2RlbChkYXRhSW5kZXgpLFxuICAgICAgICAgICAgICAgIGRhdGFNb2RlbCxcbiAgICAgICAgICAgICAgICBzZXJpZXNNb2RlbCAmJiAoc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbSB8fCB7fSkubW9kZWwsXG4gICAgICAgICAgICAgICAgdGhpcy5fdG9vbHRpcE1vZGVsXG4gICAgICAgICAgICBdKTtcblxuICAgICAgICAgICAgdmFyIHRvb2x0aXBUcmlnZ2VyID0gdG9vbHRpcE1vZGVsLmdldCgndHJpZ2dlcicpO1xuICAgICAgICAgICAgaWYgKHRvb2x0aXBUcmlnZ2VyICE9IG51bGwgJiYgdG9vbHRpcFRyaWdnZXIgIT09ICdpdGVtJykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IGRhdGFNb2RlbC5nZXREYXRhUGFyYW1zKGRhdGFJbmRleCwgZGF0YVR5cGUpO1xuICAgICAgICAgICAgdmFyIGRlZmF1bHRIdG1sID0gZGF0YU1vZGVsLmZvcm1hdFRvb2x0aXAoZGF0YUluZGV4LCBmYWxzZSwgZGF0YVR5cGUpO1xuICAgICAgICAgICAgdmFyIGFzeW5jVGlja2V0ID0gJ2l0ZW1fJyArIGRhdGFNb2RlbC5uYW1lICsgJ18nICsgZGF0YUluZGV4O1xuXG4gICAgICAgICAgICB0aGlzLl9zaG93T3JNb3ZlKHRvb2x0aXBNb2RlbCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3dUb29sdGlwQ29udGVudChcbiAgICAgICAgICAgICAgICAgICAgdG9vbHRpcE1vZGVsLCBkZWZhdWx0SHRtbCwgcGFyYW1zLCBhc3luY1RpY2tldCxcbiAgICAgICAgICAgICAgICAgICAgZS5vZmZzZXRYLCBlLm9mZnNldFksIGUucG9zaXRpb24sIGUudGFyZ2V0XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBGSVhNRVxuICAgICAgICAgICAgLy8gZHVwbGljYXRlZCBzaG93dGlwIGlmIG1hbnVhbGx5U2hvd1RpcCBpcyBjYWxsZWQgZnJvbSBkaXNwYXRjaEFjdGlvbi5cbiAgICAgICAgICAgIGRpc3BhdGNoQWN0aW9uKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnc2hvd1RpcCcsXG4gICAgICAgICAgICAgICAgZGF0YUluZGV4SW5zaWRlOiBkYXRhSW5kZXgsXG4gICAgICAgICAgICAgICAgZGF0YUluZGV4OiBkYXRhLmdldFJhd0luZGV4KGRhdGFJbmRleCksXG4gICAgICAgICAgICAgICAgc2VyaWVzSW5kZXg6IHNlcmllc0luZGV4LFxuICAgICAgICAgICAgICAgIGZyb206IHRoaXMudWlkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBfc2hvd0NvbXBvbmVudEl0ZW1Ub29sdGlwOiBmdW5jdGlvbiAoZSwgZWwsIGRpc3BhdGNoQWN0aW9uKSB7XG4gICAgICAgICAgICB2YXIgdG9vbHRpcE9wdCA9IGVsLnRvb2x0aXA7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRvb2x0aXBPcHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSB0b29sdGlwT3B0O1xuICAgICAgICAgICAgICAgIHRvb2x0aXBPcHQgPSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGNvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgIC8vIEZpeGVkIGZvcm1hdHRlclxuICAgICAgICAgICAgICAgICAgICBmb3JtYXR0ZXI6IGNvbnRlbnRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHN1YlRvb2x0aXBNb2RlbCA9IG5ldyBNb2RlbCh0b29sdGlwT3B0LCB0aGlzLl90b29sdGlwTW9kZWwsIHRoaXMuX2VjTW9kZWwpO1xuICAgICAgICAgICAgdmFyIGRlZmF1bHRIdG1sID0gc3ViVG9vbHRpcE1vZGVsLmdldCgnY29udGVudCcpO1xuICAgICAgICAgICAgdmFyIGFzeW5jVGlja2V0ID0gTWF0aC5yYW5kb20oKTtcblxuICAgICAgICAgICAgLy8gRG8gbm90IGNoZWNrIHdoZXRoZXIgYHRyaWdnZXJgIGlzICdub25lJyBoZXJlLCBiZWNhdXNlIGB0cmlnZ2VyYFxuICAgICAgICAgICAgLy8gb25seSB3b3JrcyBvbiBjb29yaWRpbmF0ZSBzeXN0ZW0uIEluIGZhY3QsIHdlIGhhdmUgbm90IGZvdW5kIGNhc2VcbiAgICAgICAgICAgIC8vIHRoYXQgcmVxdWlyZXMgc2V0dGluZyBgdHJpZ2dlcmAgbm90aGluZyBvbiBjb21wb25lbnQgeWV0LlxuXG4gICAgICAgICAgICB0aGlzLl9zaG93T3JNb3ZlKHN1YlRvb2x0aXBNb2RlbCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3dUb29sdGlwQ29udGVudChcbiAgICAgICAgICAgICAgICAgICAgc3ViVG9vbHRpcE1vZGVsLCBkZWZhdWx0SHRtbCwgc3ViVG9vbHRpcE1vZGVsLmdldCgnZm9ybWF0dGVyUGFyYW1zJykgfHwge30sXG4gICAgICAgICAgICAgICAgICAgIGFzeW5jVGlja2V0LCBlLm9mZnNldFgsIGUub2Zmc2V0WSwgZS5wb3NpdGlvbiwgZWxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIElmIG5vdCBkaXNwYXRjaCBzaG93VGlwLCB0aXAgbWF5IGJlIGhpZGUgdHJpZ2dlcmVkIGJ5IGF4aXMuXG4gICAgICAgICAgICBkaXNwYXRjaEFjdGlvbih7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3Nob3dUaXAnLFxuICAgICAgICAgICAgICAgIGZyb206IHRoaXMudWlkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBfc2hvd1Rvb2x0aXBDb250ZW50OiBmdW5jdGlvbiAoXG4gICAgICAgICAgICB0b29sdGlwTW9kZWwsIGRlZmF1bHRIdG1sLCBwYXJhbXMsIGFzeW5jVGlja2V0LCB4LCB5LCBwb3NpdGlvbkV4cHIsIGVsXG4gICAgICAgICkge1xuICAgICAgICAgICAgLy8gUmVzZXQgdGlja2V0XG4gICAgICAgICAgICB0aGlzLl90aWNrZXQgPSAnJztcblxuICAgICAgICAgICAgaWYgKCF0b29sdGlwTW9kZWwuZ2V0KCdzaG93Q29udGVudCcpIHx8ICF0b29sdGlwTW9kZWwuZ2V0KCdzaG93JykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB0b29sdGlwQ29udGVudCA9IHRoaXMuX3Rvb2x0aXBDb250ZW50O1xuXG4gICAgICAgICAgICB2YXIgZm9ybWF0dGVyID0gdG9vbHRpcE1vZGVsLmdldCgnZm9ybWF0dGVyJyk7XG4gICAgICAgICAgICBwb3NpdGlvbkV4cHIgPSBwb3NpdGlvbkV4cHIgfHwgdG9vbHRpcE1vZGVsLmdldCgncG9zaXRpb24nKTtcbiAgICAgICAgICAgIHZhciBodG1sID0gZGVmYXVsdEh0bWw7XG5cbiAgICAgICAgICAgIGlmIChmb3JtYXR0ZXIgJiYgdHlwZW9mIGZvcm1hdHRlciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBodG1sID0gZm9ybWF0VXRpbC5mb3JtYXRUcGwoZm9ybWF0dGVyLCBwYXJhbXMsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGZvcm1hdHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IGJpbmQoZnVuY3Rpb24gKGNiVGlja2V0LCBodG1sKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjYlRpY2tldCA9PT0gdGhpcy5fdGlja2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b29sdGlwQ29udGVudC5zZXRDb250ZW50KGh0bWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlUG9zaXRpb24oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9vbHRpcE1vZGVsLCBwb3NpdGlvbkV4cHIsIHgsIHksIHRvb2x0aXBDb250ZW50LCBwYXJhbXMsIGVsXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGlja2V0ID0gYXN5bmNUaWNrZXQ7XG4gICAgICAgICAgICAgICAgaHRtbCA9IGZvcm1hdHRlcihwYXJhbXMsIGFzeW5jVGlja2V0LCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRvb2x0aXBDb250ZW50LnNldENvbnRlbnQoaHRtbCk7XG4gICAgICAgICAgICB0b29sdGlwQ29udGVudC5zaG93KHRvb2x0aXBNb2RlbCk7XG5cbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVBvc2l0aW9uKFxuICAgICAgICAgICAgICAgIHRvb2x0aXBNb2RlbCwgcG9zaXRpb25FeHByLCB4LCB5LCB0b29sdGlwQ29udGVudCwgcGFyYW1zLCBlbFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtICB7c3RyaW5nfEZ1bmN0aW9ufEFycmF5LjxudW1iZXI+fSBwb3NpdGlvbkV4cHJcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB4IE1vdXNlIHhcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB5IE1vdXNlIHlcbiAgICAgICAgICogQHBhcmFtICB7Ym9vbGVhbn0gY29uZmluZSBXaGV0aGVyIGNvbmZpbmUgdG9vbHRpcCBjb250ZW50IGluIHZpZXcgcmVjdC5cbiAgICAgICAgICogQHBhcmFtICB7T2JqZWN0fDxBcnJheS48T2JqZWN0Pn0gcGFyYW1zXG4gICAgICAgICAqIEBwYXJhbSAge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGVsIHRhcmdldCBlbGVtZW50XG4gICAgICAgICAqIEBwYXJhbSAge21vZHVsZTplY2hhcnRzL0V4dGVuc2lvbkFQSX0gYXBpXG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICAgICAgICAgKi9cbiAgICAgICAgX3VwZGF0ZVBvc2l0aW9uOiBmdW5jdGlvbiAodG9vbHRpcE1vZGVsLCBwb3NpdGlvbkV4cHIsIHgsIHksIGNvbnRlbnQsIHBhcmFtcywgZWwpIHtcbiAgICAgICAgICAgIHZhciB2aWV3V2lkdGggPSB0aGlzLl9hcGkuZ2V0V2lkdGgoKTtcbiAgICAgICAgICAgIHZhciB2aWV3SGVpZ2h0ID0gdGhpcy5fYXBpLmdldEhlaWdodCgpO1xuICAgICAgICAgICAgcG9zaXRpb25FeHByID0gcG9zaXRpb25FeHByIHx8IHRvb2x0aXBNb2RlbC5nZXQoJ3Bvc2l0aW9uJyk7XG5cbiAgICAgICAgICAgIHZhciBjb250ZW50U2l6ZSA9IGNvbnRlbnQuZ2V0U2l6ZSgpO1xuICAgICAgICAgICAgdmFyIGFsaWduID0gdG9vbHRpcE1vZGVsLmdldCgnYWxpZ24nKTtcbiAgICAgICAgICAgIHZhciB2QWxpZ24gPSB0b29sdGlwTW9kZWwuZ2V0KCd2ZXJ0aWNhbEFsaWduJyk7XG4gICAgICAgICAgICB2YXIgcmVjdCA9IGVsICYmIGVsLmdldEJvdW5kaW5nUmVjdCgpLmNsb25lKCk7XG4gICAgICAgICAgICBlbCAmJiByZWN0LmFwcGx5VHJhbnNmb3JtKGVsLnRyYW5zZm9ybSk7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcG9zaXRpb25FeHByID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2FsbGJhY2sgb2YgcG9zaXRpb24gY2FuIGJlIGFuIGFycmF5IG9yIGEgc3RyaW5nIHNwZWNpZnkgdGhlIHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgcG9zaXRpb25FeHByID0gcG9zaXRpb25FeHByKFt4LCB5XSwgcGFyYW1zLCBjb250ZW50LmVsLCByZWN0LCB7XG4gICAgICAgICAgICAgICAgICAgIHZpZXdTaXplOiBbdmlld1dpZHRoLCB2aWV3SGVpZ2h0XSxcbiAgICAgICAgICAgICAgICAgICAgY29udGVudFNpemU6IGNvbnRlbnRTaXplLnNsaWNlKClcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHpyVXRpbC5pc0FycmF5KHBvc2l0aW9uRXhwcikpIHtcbiAgICAgICAgICAgICAgICB4ID0gcGFyc2VQZXJjZW50KHBvc2l0aW9uRXhwclswXSwgdmlld1dpZHRoKTtcbiAgICAgICAgICAgICAgICB5ID0gcGFyc2VQZXJjZW50KHBvc2l0aW9uRXhwclsxXSwgdmlld0hlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh6clV0aWwuaXNPYmplY3QocG9zaXRpb25FeHByKSkge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uRXhwci53aWR0aCA9IGNvbnRlbnRTaXplWzBdO1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uRXhwci5oZWlnaHQgPSBjb250ZW50U2l6ZVsxXTtcbiAgICAgICAgICAgICAgICB2YXIgbGF5b3V0UmVjdCA9IGxheW91dFV0aWwuZ2V0TGF5b3V0UmVjdChcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25FeHByLCB7d2lkdGg6IHZpZXdXaWR0aCwgaGVpZ2h0OiB2aWV3SGVpZ2h0fVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgeCA9IGxheW91dFJlY3QueDtcbiAgICAgICAgICAgICAgICB5ID0gbGF5b3V0UmVjdC55O1xuICAgICAgICAgICAgICAgIGFsaWduID0gbnVsbDtcbiAgICAgICAgICAgICAgICAvLyBXaGVuIHBvc2l0aW9uRXhwciBpcyBsZWZ0L3RvcC9yaWdodC9ib3R0b20sXG4gICAgICAgICAgICAgICAgLy8gYWxpZ24gYW5kIHZlcnRpY2FsQWxpZ24gd2lsbCBub3Qgd29yay5cbiAgICAgICAgICAgICAgICB2QWxpZ24gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU3BlY2lmeSB0b29sdGlwIHBvc2l0aW9uIGJ5IHN0cmluZyAndG9wJyAnYm90dG9tJyAnbGVmdCcgJ3JpZ2h0JyBhcm91bmQgZ3JhcGhpYyBlbGVtZW50XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgcG9zaXRpb25FeHByID09PSAnc3RyaW5nJyAmJiBlbCkge1xuICAgICAgICAgICAgICAgIHZhciBwb3MgPSBjYWxjVG9vbHRpcFBvc2l0aW9uKFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbkV4cHIsIHJlY3QsIGNvbnRlbnRTaXplXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB4ID0gcG9zWzBdO1xuICAgICAgICAgICAgICAgIHkgPSBwb3NbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgcG9zID0gcmVmaXhUb29sdGlwUG9zaXRpb24oXG4gICAgICAgICAgICAgICAgICAgIHgsIHksIGNvbnRlbnQuZWwsIHZpZXdXaWR0aCwgdmlld0hlaWdodCwgYWxpZ24gPyBudWxsIDogMjAsIHZBbGlnbiA/IG51bGwgOiAyMFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgeCA9IHBvc1swXTtcbiAgICAgICAgICAgICAgICB5ID0gcG9zWzFdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhbGlnbiAmJiAoeCAtPSBpc0NlbnRlckFsaWduKGFsaWduKSA/IGNvbnRlbnRTaXplWzBdIC8gMiA6IGFsaWduID09PSAncmlnaHQnID8gY29udGVudFNpemVbMF0gOiAwKTtcbiAgICAgICAgICAgIHZBbGlnbiAmJiAoeSAtPSBpc0NlbnRlckFsaWduKHZBbGlnbikgPyBjb250ZW50U2l6ZVsxXSAvIDIgOiB2QWxpZ24gPT09ICdib3R0b20nID8gY29udGVudFNpemVbMV0gOiAwKTtcblxuICAgICAgICAgICAgaWYgKHRvb2x0aXBNb2RlbC5nZXQoJ2NvbmZpbmUnKSkge1xuICAgICAgICAgICAgICAgIHZhciBwb3MgPSBjb25maW5lVG9vbHRpcFBvc2l0aW9uKFxuICAgICAgICAgICAgICAgICAgICB4LCB5LCBjb250ZW50LmVsLCB2aWV3V2lkdGgsIHZpZXdIZWlnaHRcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHggPSBwb3NbMF07XG4gICAgICAgICAgICAgICAgeSA9IHBvc1sxXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29udGVudC5tb3ZlVG8oeCwgeSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gRklYTUVcbiAgICAgICAgLy8gU2hvdWxkIHdlIHJlbW92ZSB0aGlzIGJ1dCBsZWF2ZSB0aGlzIHRvIHVzZXI/XG4gICAgICAgIF91cGRhdGVDb250ZW50Tm90Q2hhbmdlZE9uQXhpczogZnVuY3Rpb24gKGRhdGFCeUNvb3JkU3lzKSB7XG4gICAgICAgICAgICB2YXIgbGFzdENvb3JkU3lzID0gdGhpcy5fbGFzdERhdGFCeUNvb3JkU3lzO1xuICAgICAgICAgICAgdmFyIGNvbnRlbnROb3RDaGFuZ2VkID0gISFsYXN0Q29vcmRTeXNcbiAgICAgICAgICAgICAgICAmJiBsYXN0Q29vcmRTeXMubGVuZ3RoID09PSBkYXRhQnlDb29yZFN5cy5sZW5ndGg7XG5cbiAgICAgICAgICAgIGVhY2gobGFzdENvb3JkU3lzLCBmdW5jdGlvbiAobGFzdEl0ZW1Db29yZFN5cywgaW5kZXhDb29yZFN5cykge1xuICAgICAgICAgICAgICAgIHZhciBsYXN0RGF0YUJ5QXhpcyA9IGxhc3RJdGVtQ29vcmRTeXMuZGF0YUJ5QXhpcyB8fCB7fTtcbiAgICAgICAgICAgICAgICB2YXIgdGhpc0l0ZW1Db29yZFN5cyA9IGRhdGFCeUNvb3JkU3lzW2luZGV4Q29vcmRTeXNdIHx8IHt9O1xuICAgICAgICAgICAgICAgIHZhciB0aGlzRGF0YUJ5QXhpcyA9IHRoaXNJdGVtQ29vcmRTeXMuZGF0YUJ5QXhpcyB8fCBbXTtcbiAgICAgICAgICAgICAgICBjb250ZW50Tm90Q2hhbmdlZCAmPSBsYXN0RGF0YUJ5QXhpcy5sZW5ndGggPT09IHRoaXNEYXRhQnlBeGlzLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgIGVhY2gobGFzdERhdGFCeUF4aXMsIGZ1bmN0aW9uIChsYXN0SXRlbSwgaW5kZXhBeGlzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0aGlzSXRlbSA9IHRoaXNEYXRhQnlBeGlzW2luZGV4QXhpc10gfHwge307XG4gICAgICAgICAgICAgICAgICAgIHZhciBsYXN0SW5kaWNlcyA9IGxhc3RJdGVtLnNlcmllc0RhdGFJbmRpY2VzIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3SW5kaWNlcyA9IHRoaXNJdGVtLnNlcmllc0RhdGFJbmRpY2VzIHx8IFtdO1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnROb3RDaGFuZ2VkICY9XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0SXRlbS52YWx1ZSA9PT0gdGhpc0l0ZW0udmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIGxhc3RJdGVtLmF4aXNUeXBlID09PSB0aGlzSXRlbS5heGlzVHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgbGFzdEl0ZW0uYXhpc0lkID09PSB0aGlzSXRlbS5heGlzSWRcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIGxhc3RJbmRpY2VzLmxlbmd0aCA9PT0gbmV3SW5kaWNlcy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICAgICAgZWFjaChsYXN0SW5kaWNlcywgZnVuY3Rpb24gKGxhc3RJZHhJdGVtLCBqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3SWR4SXRlbSA9IG5ld0luZGljZXNbal07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50Tm90Q2hhbmdlZCAmPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RJZHhJdGVtLnNlcmllc0luZGV4ID09PSBuZXdJZHhJdGVtLnNlcmllc0luZGV4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgbGFzdElkeEl0ZW0uZGF0YUluZGV4ID09PSBuZXdJZHhJdGVtLmRhdGFJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy5fbGFzdERhdGFCeUNvb3JkU3lzID0gZGF0YUJ5Q29vcmRTeXM7XG5cbiAgICAgICAgICAgIHJldHVybiAhIWNvbnRlbnROb3RDaGFuZ2VkO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9oaWRlOiBmdW5jdGlvbiAoZGlzcGF0Y2hBY3Rpb24pIHtcbiAgICAgICAgICAgIC8vIERvIG5vdCBkaXJlY3RseSBoaWRlTGF0ZXIgaGVyZSwgYmVjYXVzZSB0aGlzIGJlaGF2aW9yIG1heSBiZSBwcmV2ZW50ZWRcbiAgICAgICAgICAgIC8vIGluIGRpc3BhdGNoQWN0aW9uIHdoZW4gc2hvd1RpcCBpcyBkaXNwYXRjaGVkLlxuXG4gICAgICAgICAgICAvLyBGSVhNRVxuICAgICAgICAgICAgLy8gZHVwbGljYXRlZCBoaWRlVGlwIGlmIG1hbnVhbGx5SGlkZVRpcCBpcyBjYWxsZWQgZnJvbSBkaXNwYXRjaEFjdGlvbi5cbiAgICAgICAgICAgIHRoaXMuX2xhc3REYXRhQnlDb29yZFN5cyA9IG51bGw7XG4gICAgICAgICAgICBkaXNwYXRjaEFjdGlvbih7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2hpZGVUaXAnLFxuICAgICAgICAgICAgICAgIGZyb206IHRoaXMudWlkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBkaXNwb3NlOiBmdW5jdGlvbiAoZWNNb2RlbCwgYXBpKSB7XG4gICAgICAgICAgICBpZiAoZW52Lm5vZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl90b29sdGlwQ29udGVudC5oaWRlKCk7XG4gICAgICAgICAgICBnbG9iYWxMaXN0ZW5lci51bnJlZ2lzdGVyKCdpdGVtVG9vbHRpcCcsIGFwaSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBcnJheS48T2JqZWN0fG1vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsPn0gbW9kZWxDYXNjYWRlXG4gICAgICogRnJvbSB0b3AgdG8gYm90dG9tLiAodGhlIGxhc3Qgb25lIHNob3VsZCBiZSBnbG9iYWxUb29sdGlwTW9kZWwpO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJ1aWxkVG9vbHRpcE1vZGVsKG1vZGVsQ2FzY2FkZSkge1xuICAgICAgICB2YXIgcmVzdWx0TW9kZWwgPSBtb2RlbENhc2NhZGUucG9wKCk7XG4gICAgICAgIHdoaWxlIChtb2RlbENhc2NhZGUubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgdG9vbHRpcE9wdCA9IG1vZGVsQ2FzY2FkZS5wb3AoKTtcbiAgICAgICAgICAgIGlmICh0b29sdGlwT3B0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRvb2x0aXBPcHQgaW5zdGFuY2VvZiBNb2RlbCkge1xuICAgICAgICAgICAgICAgICAgICB0b29sdGlwT3B0ID0gdG9vbHRpcE9wdC5nZXQoJ3Rvb2x0aXAnLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSW4gZWFjaCBkYXRhIGl0ZW0gdG9vbHRpcCBjYW4gYmUgc2ltcGx5IHdyaXRlOlxuICAgICAgICAgICAgICAgIC8vIHtcbiAgICAgICAgICAgICAgICAvLyAgdmFsdWU6IDEwLFxuICAgICAgICAgICAgICAgIC8vICB0b29sdGlwOiAnU29tZXRoaW5nIHlvdSBuZWVkIHRvIGtub3cnXG4gICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdG9vbHRpcE9wdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9vbHRpcE9wdCA9IHtmb3JtYXR0ZXI6IHRvb2x0aXBPcHR9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHRNb2RlbCA9IG5ldyBNb2RlbCh0b29sdGlwT3B0LCByZXN1bHRNb2RlbCwgcmVzdWx0TW9kZWwuZWNNb2RlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdE1vZGVsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VEaXNwYXRjaEFjdGlvbihwYXlsb2FkLCBhcGkpIHtcbiAgICAgICAgcmV0dXJuIHBheWxvYWQuZGlzcGF0Y2hBY3Rpb24gfHwgenJVdGlsLmJpbmQoYXBpLmRpc3BhdGNoQWN0aW9uLCBhcGkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlZml4VG9vbHRpcFBvc2l0aW9uKHgsIHksIGVsLCB2aWV3V2lkdGgsIHZpZXdIZWlnaHQsIGdhcEgsIGdhcFYpIHtcbiAgICAgICAgdmFyIHdpZHRoID0gZWwuY2xpZW50V2lkdGg7XG4gICAgICAgIHZhciBoZWlnaHQgPSBlbC5jbGllbnRIZWlnaHQ7XG5cbiAgICAgICAgaWYgKGdhcEggIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHggKyB3aWR0aCArIGdhcEggPiB2aWV3V2lkdGgpIHtcbiAgICAgICAgICAgICAgICB4IC09IHdpZHRoICsgZ2FwSDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHggKz0gZ2FwSDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZ2FwViAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoeSArIGhlaWdodCArIGdhcFYgPiB2aWV3SGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgeSAtPSBoZWlnaHQgKyBnYXBWO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgeSArPSBnYXBWO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbeCwgeV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29uZmluZVRvb2x0aXBQb3NpdGlvbih4LCB5LCBlbCwgdmlld1dpZHRoLCB2aWV3SGVpZ2h0KSB7XG4gICAgICAgIHZhciB3aWR0aCA9IGVsLmNsaWVudFdpZHRoO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gZWwuY2xpZW50SGVpZ2h0O1xuXG4gICAgICAgIHggPSBNYXRoLm1pbih4ICsgd2lkdGgsIHZpZXdXaWR0aCkgLSB3aWR0aDtcbiAgICAgICAgeSA9IE1hdGgubWluKHkgKyBoZWlnaHQsIHZpZXdIZWlnaHQpIC0gaGVpZ2h0O1xuICAgICAgICB4ID0gTWF0aC5tYXgoeCwgMCk7XG4gICAgICAgIHkgPSBNYXRoLm1heCh5LCAwKTtcblxuICAgICAgICByZXR1cm4gW3gsIHldO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhbGNUb29sdGlwUG9zaXRpb24ocG9zaXRpb24sIHJlY3QsIGNvbnRlbnRTaXplKSB7XG4gICAgICAgIHZhciBkb21XaWR0aCA9IGNvbnRlbnRTaXplWzBdO1xuICAgICAgICB2YXIgZG9tSGVpZ2h0ID0gY29udGVudFNpemVbMV07XG4gICAgICAgIHZhciBnYXAgPSA1O1xuICAgICAgICB2YXIgeCA9IDA7XG4gICAgICAgIHZhciB5ID0gMDtcbiAgICAgICAgdmFyIHJlY3RXaWR0aCA9IHJlY3Qud2lkdGg7XG4gICAgICAgIHZhciByZWN0SGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XG4gICAgICAgIHN3aXRjaCAocG9zaXRpb24pIHtcbiAgICAgICAgICAgIGNhc2UgJ2luc2lkZSc6XG4gICAgICAgICAgICAgICAgeCA9IHJlY3QueCArIHJlY3RXaWR0aCAvIDIgLSBkb21XaWR0aCAvIDI7XG4gICAgICAgICAgICAgICAgeSA9IHJlY3QueSArIHJlY3RIZWlnaHQgLyAyIC0gZG9tSGVpZ2h0IC8gMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICAgICAgeCA9IHJlY3QueCArIHJlY3RXaWR0aCAvIDIgLSBkb21XaWR0aCAvIDI7XG4gICAgICAgICAgICAgICAgeSA9IHJlY3QueSAtIGRvbUhlaWdodCAtIGdhcDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICAgICAgeCA9IHJlY3QueCArIHJlY3RXaWR0aCAvIDIgLSBkb21XaWR0aCAvIDI7XG4gICAgICAgICAgICAgICAgeSA9IHJlY3QueSArIHJlY3RIZWlnaHQgKyBnYXA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgICAgICB4ID0gcmVjdC54IC0gZG9tV2lkdGggLSBnYXA7XG4gICAgICAgICAgICAgICAgeSA9IHJlY3QueSArIHJlY3RIZWlnaHQgLyAyIC0gZG9tSGVpZ2h0IC8gMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgICAgICB4ID0gcmVjdC54ICsgcmVjdFdpZHRoICsgZ2FwO1xuICAgICAgICAgICAgICAgIHkgPSByZWN0LnkgKyByZWN0SGVpZ2h0IC8gMiAtIGRvbUhlaWdodCAvIDI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFt4LCB5XTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0NlbnRlckFsaWduKGFsaWduKSB7XG4gICAgICAgIHJldHVybiBhbGlnbiA9PT0gJ2NlbnRlcicgfHwgYWxpZ24gPT09ICdtaWRkbGUnO1xuICAgIH1cblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvY29tcG9uZW50L3Rvb2x0aXAvVG9vbHRpcFZpZXcuanNcbi8vIG1vZHVsZSBpZCA9IDIzN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 238 */,
/* 239 */,
/* 240 */,
/* 241 */,
/* 242 */,
/* 243 */,
/* 244 */,
/* 245 */,
/* 246 */,
/* 247 */,
/* 248 */,
/* 249 */,
/* 250 */,
/* 251 */,
/* 252 */,
/* 253 */,
/* 254 */,
/* 255 */,
/* 256 */,
/* 257 */,
/* 258 */,
/* 259 */,
/* 260 */,
/* 261 */,
/* 262 */,
/* 263 */,
/* 264 */,
/* 265 */,
/* 266 */,
/* 267 */,
/* 268 */,
/* 269 */,
/* 270 */,
/* 271 */,
/* 272 */,
/* 273 */,
/* 274 */,
/* 275 */,
/* 276 */,
/* 277 */,
/* 278 */,
/* 279 */,
/* 280 */,
/* 281 */,
/* 282 */,
/* 283 */,
/* 284 */,
/* 285 */,
/* 286 */,
/* 287 */,
/* 288 */
/* unknown exports provided */
/* all exports used */
/*!*************************!*\
  !*** ./index.common.js ***!
  \*************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Export echarts as CommonJS module\n */\nmodule.exports = __webpack_require__(/*! ./lib/echarts */ 1);\n\n__webpack_require__(/*! ./lib/chart/line */ 74);\n__webpack_require__(/*! ./lib/chart/bar */ 73);\n__webpack_require__(/*! ./lib/chart/pie */ 75);\n__webpack_require__(/*! ./lib/chart/scatter */ 184);\n__webpack_require__(/*! ./lib/component/graphic */ 186);\n__webpack_require__(/*! ./lib/component/tooltip */ 194);\n__webpack_require__(/*! ./lib/component/axisPointer */ 51);\n__webpack_require__(/*! ./lib/component/legend */ 188);\n\n__webpack_require__(/*! ./lib/component/grid */ 187);\n__webpack_require__(/*! ./lib/component/title */ 192);\n\n__webpack_require__(/*! ./lib/component/markPoint */ 191);\n__webpack_require__(/*! ./lib/component/markLine */ 190);\n__webpack_require__(/*! ./lib/component/markArea */ 189);\n__webpack_require__(/*! ./lib/component/dataZoom */ 185);\n__webpack_require__(/*! ./lib/component/toolbox */ 193);\n\n__webpack_require__(/*! zrender/lib/vml/vml */ 183);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjg4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vaW5kZXguY29tbW9uLmpzP2RjYzQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBFeHBvcnQgZWNoYXJ0cyBhcyBDb21tb25KUyBtb2R1bGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9lY2hhcnRzJyk7XG5cbnJlcXVpcmUoJy4vbGliL2NoYXJ0L2xpbmUnKTtcbnJlcXVpcmUoJy4vbGliL2NoYXJ0L2JhcicpO1xucmVxdWlyZSgnLi9saWIvY2hhcnQvcGllJyk7XG5yZXF1aXJlKCcuL2xpYi9jaGFydC9zY2F0dGVyJyk7XG5yZXF1aXJlKCcuL2xpYi9jb21wb25lbnQvZ3JhcGhpYycpO1xucmVxdWlyZSgnLi9saWIvY29tcG9uZW50L3Rvb2x0aXAnKTtcbnJlcXVpcmUoJy4vbGliL2NvbXBvbmVudC9heGlzUG9pbnRlcicpO1xucmVxdWlyZSgnLi9saWIvY29tcG9uZW50L2xlZ2VuZCcpO1xuXG5yZXF1aXJlKCcuL2xpYi9jb21wb25lbnQvZ3JpZCcpO1xucmVxdWlyZSgnLi9saWIvY29tcG9uZW50L3RpdGxlJyk7XG5cbnJlcXVpcmUoJy4vbGliL2NvbXBvbmVudC9tYXJrUG9pbnQnKTtcbnJlcXVpcmUoJy4vbGliL2NvbXBvbmVudC9tYXJrTGluZScpO1xucmVxdWlyZSgnLi9saWIvY29tcG9uZW50L21hcmtBcmVhJyk7XG5yZXF1aXJlKCcuL2xpYi9jb21wb25lbnQvZGF0YVpvb20nKTtcbnJlcXVpcmUoJy4vbGliL2NvbXBvbmVudC90b29sYm94Jyk7XG5cbnJlcXVpcmUoJ3pyZW5kZXIvbGliL3ZtbC92bWwnKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2luZGV4LmNvbW1vbi5qc1xuLy8gbW9kdWxlIGlkID0gMjg4XG4vLyBtb2R1bGUgY2h1bmtzID0gMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ })
/******/ ]);
});